.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 3F0E111D313348DAC9D7C06D9684C4FC
.rdata:00000000 ; Input CRC32 : F7487772
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\tinyxmlparserA.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG94430        db '&amp;',0            ; DATA XREF: .data:TiXmlBaseA::Entity * TiXmlBaseA::entityo
.rdata:00000006 ; char _SG94532
.rdata:00000006 $SG94532        db 0                    ; DATA XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+3o
.rdata:00000007 ; char _SG94610
.rdata:00000007 $SG94610        db 0                    ; DATA XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+4o
.rdata:00000008 $SG94431        db '&lt;',0             ; DATA XREF: .data:00000610o
.rdata:0000000D ; char _SG94706
.rdata:0000000D $SG94706        db 0                    ; DATA XREF: TiXmlNodeA::Identify(char const *)+13Eo
.rdata:0000000E ; char _SG94741
.rdata:0000000E $SG94741        db 0                    ; DATA XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+10Eo
.rdata:0000000F ; char _SG94848
.rdata:0000000F $SG94848        db 0                    ; DATA XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+83o
.rdata:00000010 $SG94432        db '&gt;',0             ; DATA XREF: .data:0000061Co
.rdata:00000015 ; char _SG94885
.rdata:00000015 $SG94885        db 0                    ; DATA XREF: TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+8Eo
.rdata:00000016 ; char _SG94909
.rdata:00000016 $SG94909        db 0                    ; DATA XREF: TiXmlCommentA::Parse(char const *,TiXmlParsingDataA *)+14o
.rdata:00000017 ; char _SG94943
.rdata:00000017 $SG94943        db 0                    ; DATA XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *):loc_11EBo
.rdata:00000018 $SG94433        db '&quot;',0           ; DATA XREF: .data:00000628o
.rdata:0000001F ; char _SG94963
.rdata:0000001F $SG94963        db 0                    ; DATA XREF: TiXmlTextA::Parse(char const *,TiXmlParsingDataA *)+9o
.rdata:00000020 $SG94434        db  26h ; &             ; DATA XREF: .data:00000634o
.rdata:00000021                 db  61h ; a
.rdata:00000022 aPos            db 'pos;',0             ; DATA XREF: .rdata:$SG94941o
.rdata:00000027 ; char _SG94991
.rdata:00000027 $SG94991        db 0                    ; DATA XREF: .rdata:$SG94938o
.rdata:00000027                                         ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+D0o
.rdata:00000028 ; wchar_t _SG94463
.rdata:00000028 $SG94463:                               ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+11o
.rdata:00000028                                         ; .rdata:$SG94590o
.rdata:00000028                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:0000007E ; char _SG94992
.rdata:0000007E $SG94992        db 0                    ; DATA XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+E3o
.rdata:0000007F ; char _SG94993
.rdata:0000007F $SG94993        db 0                    ; DATA XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+F6o
.rdata:00000080 ; wchar_t _SG94464
.rdata:00000080 $SG94464:                               ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+16o
.rdata:00000080                 unicode 0, <now>,0
.rdata:00000088 ; wchar_t _SG94470
.rdata:00000088 $SG94470:                               ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+53o
.rdata:00000088                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:000000DE                 align 10h
.rdata:000000E0 ; wchar_t _SG94471
.rdata:000000E0 $SG94471        dd offset $SG94463+48h  ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+58o
.rdata:000000E0                                         ; "rA.cpp"
.rdata:000000E4 ; wchar_t _SG94488
.rdata:000000E4 $SG94488:                               ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+154o
.rdata:000000E4                 unicode 0, <cursor.row >
.rdata:000000E4                 dw 3Eh
.rdata:000000E4                 unicode 0, <= -1>,0
.rdata:00000106                 align 4
.rdata:00000108 ; wchar_t _SG94487
.rdata:00000108 $SG94487:                               ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+14Fo
.rdata:00000108                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:0000015E                 align 10h
.rdata:00000160 ; wchar_t _SG94490
.rdata:00000160 $SG94490:                               ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+16Fo
.rdata:00000160                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:000001B6                 align 4
.rdata:000001B8 ; wchar_t _SG94491
.rdata:000001B8 $SG94491:                               ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+174o
.rdata:000001B8                 unicode 0, <cursor.col >
.rdata:000001B8                 dw 3Eh
.rdata:000001B8                 unicode 0, <= -1>,0
.rdata:000001DA                 align 4
.rdata:000001DC ; wchar_t _SG94494
.rdata:000001DC $SG94494:                               ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+19Do
.rdata:000001DC                 unicode 0, <stamp>,0
.rdata:000001E8 ; wchar_t _SG94493
.rdata:000001E8 $SG94493:                               ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+198o
.rdata:000001E8                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:0000023E                 align 10h
.rdata:00000240 ; wchar_t _SG94534
.rdata:00000240 $SG94534:                               ; DATA XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+1Bo
.rdata:00000240                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:00000296                 align 4
.rdata:00000298 ; wchar_t _SG94535
.rdata:00000298 $SG94535        dd offset $SG94463+48h  ; DATA XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+20o
.rdata:00000298                                         ; "rA.cpp"
.rdata:0000029C ; char _SG94551[4]
.rdata:0000029C $SG94551        db '&#x',0              ; DATA XREF: TiXmlBaseA::GetEntity(char const *,char *)+3Do
.rdata:000002A0 ; wchar_t _SG94574
.rdata:000002A0 $SG94574:                               ; DATA XREF: TiXmlBaseA::GetEntity(char const *,char *)+23Bo
.rdata:000002A0                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:000002F6                 align 4
.rdata:000002F8 ; wchar_t _SG94575
.rdata:000002F8 $SG94575:                               ; DATA XREF: TiXmlBaseA::GetEntity(char const *,char *)+240o
.rdata:000002F8                 unicode 0, <strlen( entity[i].str ) == entity[i].strLength>,0
.rdata:00000356                 align 4
.rdata:00000358 ; wchar_t _SG94584
.rdata:00000358 $SG94584:                               ; DATA XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+10o
.rdata:00000358                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:000003AE                 align 10h
.rdata:000003B0 ; wchar_t _SG94585
.rdata:000003B0 $SG94585        dd offset $SG94463+48h  ; DATA XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+15o
.rdata:000003B0                                         ; "rA.cpp"
.rdata:000003B4 ; wchar_t _SG94590
.rdata:000003B4 $SG94590        dd offset $SG94463+8    ; DATA XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+40o
.rdata:000003B4                                         ; "rc\\TinyXml\\tinyXmlA\\tinyxmlparserA.c"...
.rdata:000003B8 ; wchar_t _SG94589
.rdata:000003B8 $SG94589:                               ; DATA XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+3Bo
.rdata:000003B8                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:0000040E                 align 10h
.rdata:00000410 ; wchar_t _SG94677
.rdata:00000410 $SG94677:                               ; DATA XREF: TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)+28o
.rdata:00000410                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:00000466                 align 4
.rdata:00000468 ; wchar_t _SG94678
.rdata:00000468 $SG94678:                               ; DATA XREF: TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)+2Do
.rdata:00000468                 unicode 0, <err >
.rdata:00000468                 dw 3Eh
.rdata:00000468                 unicode 0, < 0 && err >
.rdata:00000468                 dw 3Ch
.rdata:00000468                 unicode 0, < TIXMLA_ERROR_STRING_COUNT>,0
.rdata:000004BE                 align 10h
.rdata:000004C0 $SG94691        db '<?xml',0            ; DATA XREF: TiXmlNodeA::Identify(char const *):loc_E51o
.rdata:000004C6                 align 4
.rdata:000004C8 $SG94693        db '<!--',0             ; DATA XREF: TiXmlNodeA::Identify(char const *)+98o
.rdata:000004CD                 align 10h
.rdata:000004D0 ; wchar_t _SG94744
.rdata:000004D0 $SG94744:                               ; DATA XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+173o
.rdata:000004D0                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:00000526                 align 4
.rdata:00000528 ; wchar_t _SG94745
.rdata:00000528 $SG94745:                               ; DATA XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+178o
.rdata:00000528                 unicode 0, <in->
.rdata:00000528                 dw 3Eh
.rdata:00000528                 unicode 0, <peek() == >
.rdata:00000528                 dw 27h, 3Ch, 27h, 0
.rdata:0000054C ; wchar_t _SG94762
.rdata:0000054C $SG94762:                               ; DATA XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+230o
.rdata:0000054C                 unicode 0, <c == >
.rdata:0000054C                 dw 27h, 3Eh, 27h, 0
.rdata:0000055E                 align 10h
.rdata:00000560 ; wchar_t _SG94761
.rdata:00000560 $SG94761:                               ; DATA XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+22Bo
.rdata:00000560                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:000005B6                 align 4
.rdata:000005B8 ; char _SG94787[]
.rdata:000005B8 $SG94787        dd offset loc_2F3A+2    ; DATA XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *):loc_1672o
.rdata:000005BC ; char _SG94788[]
.rdata:000005BC $SG94788        dd offset $SG94463+16h  ; DATA XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+145o
.rdata:000005BC                                         ; "Xml\\tinyXmlA\\tinyxmlparserA.cpp"
.rdata:000005C0 ; char _SG94857[]
.rdata:000005C0 $SG94857        dd offset loc_2F3A+2    ; DATA XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+135o
.rdata:000005C4 $SG94912        db '<!--',0             ; DATA XREF: TiXmlCommentA::Parse(char const *,TiXmlParsingDataA *):loc_1D2Bo
.rdata:000005C9                 align 4
.rdata:000005CC $SG94914        db '-->',0              ; DATA XREF: TiXmlCommentA::Parse(char const *,TiXmlParsingDataA *)+62o
.rdata:000005D0 $SG94938        dd offset $SG94991      ; DATA XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+176o
.rdata:000005D4 $SG94941        dd offset aPos          ; DATA XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+1B4o
.rdata:000005D4                                         ; "pos;"
.rdata:000005D8 $SG94967        dd offset $SG94463+14h  ; DATA XREF: TiXmlTextA::Parse(char const *,TiXmlParsingDataA *)+45o
.rdata:000005D8                                         ; "yXml\\tinyXmlA\\tinyxmlparserA.cpp"
.rdata:000005DC ; char _SG94988[]
.rdata:000005DC $SG94988        db '<?xml',0            ; DATA XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+63o
.rdata:000005E2                 align 4
.rdata:000005E4 ; char _SG94999[]
.rdata:000005E4 $SG94999        db 'version',0          ; DATA XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+14Eo
.rdata:000005EC ; char _SG95003[]
.rdata:000005EC $SG95003        db 'encoding',0         ; DATA XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+1B5o
.rdata:000005F5                 align 4
.rdata:000005F8 ; char _SG95007[]
.rdata:000005F8 $SG95007        db 'standalone',0       ; DATA XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+228o
.rdata:00000603                 align 4
.rdata:00000603 _rdata          ends
.rdata:00000603
.data:00000604 ; ===========================================================================
.data:00000604
.data:00000604 ; Segment type: Pure data
.data:00000604 ; Segment permissions: Read/Write
.data:00000604 _data           segment dword public 'DATA' use32
.data:00000604                 assume cs:_data
.data:00000604                 ;org 604h
.data:00000604                 public ?entity@TiXmlBaseA@@0PAUEntity@1@A
.data:00000604 ; private: static struct TiXmlBaseA::Entity * TiXmlBaseA::entity
.data:00000604 ?entity@TiXmlBaseA@@0PAUEntity@1@A dd offset $SG94430
.data:00000604                                         ; DATA XREF: TiXmlBaseA::GetEntity(char const *,char *)+204r
.data:00000604                                         ; TiXmlBaseA::GetEntity(char const *,char *)+21Br
.data:00000604                                         ; "&amp;"
.data:00000608 dword_608       dd 5                    ; DATA XREF: TiXmlBaseA::GetEntity(char const *,char *)+1F5r
.data:00000608                                         ; TiXmlBaseA::GetEntity(char const *,char *)+22Er ...
.data:0000060C byte_60C        db 26h                  ; DATA XREF: TiXmlBaseA::GetEntity(char const *,char *)+254r
.data:0000060D                 align 10h
.data:00000610                 dd offset $SG94431      ; "&lt;"
.data:00000614                 db    4
.data:00000615                 db    0
.data:00000616                 db    0
.data:00000617                 db    0
.data:00000618                 db  3Ch ; <
.data:00000619                 db    0
.data:0000061A                 db    0
.data:0000061B                 db    0
.data:0000061C                 dd offset $SG94432      ; "&gt;"
.data:00000620                 db    4
.data:00000621                 db    0
.data:00000622                 db    0
.data:00000623                 db    0
.data:00000624                 db  3Eh ; >
.data:00000625                 db    0
.data:00000626                 db    0
.data:00000627                 db    0
.data:00000628                 dd offset $SG94433      ; "&quot;"
.data:0000062C                 db    6
.data:0000062D                 db    0
.data:0000062E                 db    0
.data:0000062F                 db    0
.data:00000630                 db  22h ; "
.data:00000631                 db    0
.data:00000632                 db    0
.data:00000633                 db    0
.data:00000634                 dd offset $SG94434
.data:00000638                 db    6
.data:00000639                 db    0
.data:0000063A                 db    0
.data:0000063B                 db    0
.data:0000063C                 db  27h ; '
.data:0000063D                 db    0
.data:0000063E                 db    0
.data:0000063F                 db    0
.data:0000063F _data           ends
.data:0000063F
.text$mn:00000640 ; ===========================================================================
.text$mn:00000640
.text$mn:00000640 ; Segment type: Pure code
.text$mn:00000640 ; Segment permissions: Read/Execute
.text$mn:00000640 _text$mn        segment para public 'CODE' use32
.text$mn:00000640                 assume cs:_text$mn
.text$mn:00000640                 ;org 640h
.text$mn:00000640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000640
.text$mn:00000640 ; =============== S U B R O U T I N E =======================================
.text$mn:00000640
.text$mn:00000640 ; Attributes: bp-based frame
.text$mn:00000640
.text$mn:00000640 ; const char *__cdecl TiXmlBaseA::SkipWhiteSpace(const char *)
.text$mn:00000640                 public ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z
.text$mn:00000640 ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z proc near
.text$mn:00000640                                         ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+7Fp
.text$mn:00000640                                         ; TiXmlNodeA::Identify(char const *)+33p ...
.text$mn:00000640
.text$mn:00000640 arg_0           = dword ptr  8
.text$mn:00000640
.text$mn:00000640                 push    ebp
.text$mn:00000641                 mov     ebp, esp
.text$mn:00000643                 cmp     [ebp+arg_0], 0
.text$mn:00000647                 jz      short loc_653
.text$mn:00000649                 mov     eax, [ebp+arg_0]
.text$mn:0000064C                 movsx   ecx, byte ptr [eax]
.text$mn:0000064F                 test    ecx, ecx
.text$mn:00000651                 jnz     short loc_657
.text$mn:00000653
.text$mn:00000653 loc_653:                                ; CODE XREF: TiXmlBaseA::SkipWhiteSpace(char const *)+7j
.text$mn:00000653                 xor     eax, eax
.text$mn:00000655                 jmp     short loc_6A2
.text$mn:00000657 ; ---------------------------------------------------------------------------
.text$mn:00000657
.text$mn:00000657 loc_657:                                ; CODE XREF: TiXmlBaseA::SkipWhiteSpace(char const *)+11j
.text$mn:00000657                                         ; TiXmlBaseA::SkipWhiteSpace(char const *):loc_69Dj
.text$mn:00000657                 cmp     [ebp+arg_0], 0
.text$mn:0000065B                 jz      short loc_69F
.text$mn:0000065D                 mov     edx, [ebp+arg_0]
.text$mn:00000660                 movsx   eax, byte ptr [edx]
.text$mn:00000663                 test    eax, eax
.text$mn:00000665                 jz      short loc_69F
.text$mn:00000667                 mov     ecx, [ebp+arg_0]
.text$mn:0000066A                 movsx   edx, byte ptr [ecx]
.text$mn:0000066D                 push    edx             ; C
.text$mn:0000066E                 call    _isspace
.text$mn:00000673                 add     esp, 4
.text$mn:00000676                 test    eax, eax
.text$mn:00000678                 jnz     short loc_690
.text$mn:0000067A                 mov     eax, [ebp+arg_0]
.text$mn:0000067D                 movsx   ecx, byte ptr [eax]
.text$mn:00000680                 cmp     ecx, 0Ah
.text$mn:00000683                 jz      short loc_690
.text$mn:00000685                 mov     edx, [ebp+arg_0]
.text$mn:00000688                 movsx   eax, byte ptr [edx]
.text$mn:0000068B                 cmp     eax, 0Dh
.text$mn:0000068E                 jnz     short loc_69B
.text$mn:00000690
.text$mn:00000690 loc_690:                                ; CODE XREF: TiXmlBaseA::SkipWhiteSpace(char const *)+38j
.text$mn:00000690                                         ; TiXmlBaseA::SkipWhiteSpace(char const *)+43j
.text$mn:00000690                 mov     ecx, [ebp+arg_0]
.text$mn:00000693                 add     ecx, 1
.text$mn:00000696                 mov     [ebp+arg_0], ecx
.text$mn:00000699                 jmp     short loc_69D
.text$mn:0000069B ; ---------------------------------------------------------------------------
.text$mn:0000069B
.text$mn:0000069B loc_69B:                                ; CODE XREF: TiXmlBaseA::SkipWhiteSpace(char const *)+4Ej
.text$mn:0000069B                 jmp     short loc_69F
.text$mn:0000069D ; ---------------------------------------------------------------------------
.text$mn:0000069D
.text$mn:0000069D loc_69D:                                ; CODE XREF: TiXmlBaseA::SkipWhiteSpace(char const *)+59j
.text$mn:0000069D                 jmp     short loc_657
.text$mn:0000069F ; ---------------------------------------------------------------------------
.text$mn:0000069F
.text$mn:0000069F loc_69F:                                ; CODE XREF: TiXmlBaseA::SkipWhiteSpace(char const *)+1Bj
.text$mn:0000069F                                         ; TiXmlBaseA::SkipWhiteSpace(char const *)+25j ...
.text$mn:0000069F                 mov     eax, [ebp+arg_0]
.text$mn:000006A2
.text$mn:000006A2 loc_6A2:                                ; CODE XREF: TiXmlBaseA::SkipWhiteSpace(char const *)+15j
.text$mn:000006A2                 pop     ebp
.text$mn:000006A3                 retn
.text$mn:000006A3 ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z endp
.text$mn:000006A3
.text$mn:000006A3 ; ---------------------------------------------------------------------------
.text$mn:000006A4                 align 10h
.text$mn:000006B0
.text$mn:000006B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000006B0
.text$mn:000006B0 ; Attributes: bp-based frame
.text$mn:000006B0
.text$mn:000006B0 ; protected: static bool __cdecl TiXmlBaseA::StreamWhiteSpace(class std::basic_istream<char, struct std::char_traits<char>> *, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> *)
.text$mn:000006B0                 public ?StreamWhiteSpace@TiXmlBaseA@@KA_NPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.text$mn:000006B0 ?StreamWhiteSpace@TiXmlBaseA@@KA_NPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z proc near
.text$mn:000006B0                                         ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+E2p
.text$mn:000006B0
.text$mn:000006B0 C               = dword ptr -4
.text$mn:000006B0 arg_0           = dword ptr  8
.text$mn:000006B0 arg_4           = dword ptr  0Ch
.text$mn:000006B0
.text$mn:000006B0                 push    ebp
.text$mn:000006B1                 mov     ebp, esp
.text$mn:000006B3                 push    ecx
.text$mn:000006B4
.text$mn:000006B4 loc_6B4:                                ; CODE XREF: TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+54j
.text$mn:000006B4                 mov     eax, [ebp+arg_0]
.text$mn:000006B7                 mov     ecx, [eax]
.text$mn:000006B9                 mov     edx, [ebp+arg_0]
.text$mn:000006BC                 add     edx, [ecx+4]
.text$mn:000006BF                 mov     ecx, edx        ; this
.text$mn:000006C1                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:000006C6                 movzx   eax, al
.text$mn:000006C9                 test    eax, eax
.text$mn:000006CB                 jnz     short loc_6D1
.text$mn:000006CD                 xor     al, al
.text$mn:000006CF                 jmp     short loc_706
.text$mn:000006D1 ; ---------------------------------------------------------------------------
.text$mn:000006D1
.text$mn:000006D1 loc_6D1:                                ; CODE XREF: TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+1Bj
.text$mn:000006D1                 mov     ecx, [ebp+arg_0]
.text$mn:000006D4                 call    ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::peek(void)
.text$mn:000006D9                 mov     [ebp+C], eax
.text$mn:000006DC                 mov     ecx, [ebp+C]
.text$mn:000006DF                 push    ecx             ; C
.text$mn:000006E0                 call    ?IsWhiteSpace@TiXmlBaseA@@KA_NH@Z ; TiXmlBaseA::IsWhiteSpace(int)
.text$mn:000006E5                 add     esp, 4
.text$mn:000006E8                 movzx   edx, al
.text$mn:000006EB                 test    edx, edx
.text$mn:000006ED                 jnz     short loc_6F3
.text$mn:000006EF                 mov     al, 1
.text$mn:000006F1                 jmp     short loc_706
.text$mn:000006F3 ; ---------------------------------------------------------------------------
.text$mn:000006F3
.text$mn:000006F3 loc_6F3:                                ; CODE XREF: TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+3Dj
.text$mn:000006F3                 mov     ecx, [ebp+arg_0]
.text$mn:000006F6                 call    ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::get(void)
.text$mn:000006FB                 push    eax
.text$mn:000006FC                 mov     ecx, [ebp+arg_4]
.text$mn:000006FF                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:00000704                 jmp     short loc_6B4
.text$mn:00000706 ; ---------------------------------------------------------------------------
.text$mn:00000706
.text$mn:00000706 loc_706:                                ; CODE XREF: TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+1Fj
.text$mn:00000706                                         ; TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+41j
.text$mn:00000706                 mov     esp, ebp
.text$mn:00000708                 pop     ebp
.text$mn:00000709                 retn
.text$mn:00000709 ?StreamWhiteSpace@TiXmlBaseA@@KA_NPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z endp
.text$mn:00000709
.text$mn:00000709 ; ---------------------------------------------------------------------------
.text$mn:0000070A                 align 10h
.text$mn:00000710
.text$mn:00000710 ; =============== S U B R O U T I N E =======================================
.text$mn:00000710
.text$mn:00000710 ; Attributes: bp-based frame
.text$mn:00000710
.text$mn:00000710 ; protected: static bool __cdecl TiXmlBaseA::StreamTo(class std::basic_istream<char, struct std::char_traits<char>> *, int, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> *)
.text$mn:00000710                 public ?StreamTo@TiXmlBaseA@@KA_NPAV?$basic_istream@DU?$char_traits@D@std@@@std@@HPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.text$mn:00000710 ?StreamTo@TiXmlBaseA@@KA_NPAV?$basic_istream@DU?$char_traits@D@std@@@std@@HPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z proc near
.text$mn:00000710                                         ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+13p
.text$mn:00000710
.text$mn:00000710 var_4           = dword ptr -4
.text$mn:00000710 arg_0           = dword ptr  8
.text$mn:00000710 arg_4           = dword ptr  0Ch
.text$mn:00000710 arg_8           = dword ptr  10h
.text$mn:00000710
.text$mn:00000710                 push    ebp
.text$mn:00000711                 mov     ebp, esp
.text$mn:00000713                 push    ecx
.text$mn:00000714
.text$mn:00000714 loc_714:                                ; CODE XREF: TiXmlBaseA::StreamTo(std::basic_istream<char,std::char_traits<char>> *,int,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+49j
.text$mn:00000714                 mov     eax, [ebp+arg_0]
.text$mn:00000717                 mov     ecx, [eax]
.text$mn:00000719                 mov     edx, [ebp+arg_0]
.text$mn:0000071C                 add     edx, [ecx+4]
.text$mn:0000071F                 mov     ecx, edx        ; this
.text$mn:00000721                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:00000726                 movzx   eax, al
.text$mn:00000729                 test    eax, eax
.text$mn:0000072B                 jz      short loc_75B
.text$mn:0000072D                 mov     ecx, [ebp+arg_0]
.text$mn:00000730                 call    ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::peek(void)
.text$mn:00000735                 mov     [ebp+var_4], eax
.text$mn:00000738                 mov     ecx, [ebp+var_4]
.text$mn:0000073B                 cmp     ecx, [ebp+arg_4]
.text$mn:0000073E                 jnz     short loc_744
.text$mn:00000740                 mov     al, 1
.text$mn:00000742                 jmp     short loc_75D
.text$mn:00000744 ; ---------------------------------------------------------------------------
.text$mn:00000744
.text$mn:00000744 loc_744:                                ; CODE XREF: TiXmlBaseA::StreamTo(std::basic_istream<char,std::char_traits<char>> *,int,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+2Ej
.text$mn:00000744                 mov     ecx, [ebp+arg_0]
.text$mn:00000747                 call    ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::get(void)
.text$mn:0000074C                 movzx   edx, byte ptr [ebp+var_4]
.text$mn:00000750                 push    edx
.text$mn:00000751                 mov     ecx, [ebp+arg_8]
.text$mn:00000754                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:00000759                 jmp     short loc_714
.text$mn:0000075B ; ---------------------------------------------------------------------------
.text$mn:0000075B
.text$mn:0000075B loc_75B:                                ; CODE XREF: TiXmlBaseA::StreamTo(std::basic_istream<char,std::char_traits<char>> *,int,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+1Bj
.text$mn:0000075B                 xor     al, al
.text$mn:0000075D
.text$mn:0000075D loc_75D:                                ; CODE XREF: TiXmlBaseA::StreamTo(std::basic_istream<char,std::char_traits<char>> *,int,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+32j
.text$mn:0000075D                 mov     esp, ebp
.text$mn:0000075F                 pop     ebp
.text$mn:00000760                 retn
.text$mn:00000760 ?StreamTo@TiXmlBaseA@@KA_NPAV?$basic_istream@DU?$char_traits@D@std@@@std@@HPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z endp
.text$mn:00000760
.text$mn:00000760 ; ---------------------------------------------------------------------------
.text$mn:00000761                 align 10h
.text$mn:00000770
.text$mn:00000770 ; =============== S U B R O U T I N E =======================================
.text$mn:00000770
.text$mn:00000770 ; Attributes: bp-based frame
.text$mn:00000770
.text$mn:00000770 ; protected: static char const * __cdecl TiXmlBaseA::ReadName(char const *, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> *)
.text$mn:00000770                 public ?ReadName@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
.text$mn:00000770 ?ReadName@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z proc near
.text$mn:00000770                                         ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+86p
.text$mn:00000770                                         ; TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+E8p
.text$mn:00000770
.text$mn:00000770 arg_0           = dword ptr  8
.text$mn:00000770 arg_4           = dword ptr  0Ch
.text$mn:00000770
.text$mn:00000770                 push    ebp
.text$mn:00000771                 mov     ebp, esp
.text$mn:00000773                 push    offset $SG94532 ; Str
.text$mn:00000778                 mov     ecx, [ebp+arg_4]
.text$mn:0000077B                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00000780                 cmp     [ebp+arg_0], 0
.text$mn:00000784                 jnz     short loc_79D
.text$mn:00000786                 push    0C7h ; 'Â¦'      ; Line
.text$mn:0000078B                 push    offset $SG94534 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:00000790                 push    offset $SG94535 ; Message
.text$mn:00000795                 call    __wassert
.text$mn:0000079A ; ---------------------------------------------------------------------------
.text$mn:0000079A                 add     esp, 0Ch
.text$mn:0000079D
.text$mn:0000079D loc_79D:                                ; CODE XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+14j
.text$mn:0000079D                 cmp     [ebp+arg_0], 0
.text$mn:000007A1                 jz      loc_841
.text$mn:000007A7                 mov     ecx, [ebp+arg_0]
.text$mn:000007AA                 movsx   edx, byte ptr [ecx]
.text$mn:000007AD                 test    edx, edx
.text$mn:000007AF                 jz      loc_841
.text$mn:000007B5                 mov     eax, [ebp+arg_0]
.text$mn:000007B8                 movzx   ecx, byte ptr [eax]
.text$mn:000007BB                 push    ecx             ; C
.text$mn:000007BC                 call    _isalpha
.text$mn:000007C1                 add     esp, 4
.text$mn:000007C4                 test    eax, eax
.text$mn:000007C6                 jnz     short loc_7D3
.text$mn:000007C8                 mov     edx, [ebp+arg_0]
.text$mn:000007CB                 movsx   eax, byte ptr [edx]
.text$mn:000007CE                 cmp     eax, 5Fh ; '_'
.text$mn:000007D1                 jnz     short loc_841
.text$mn:000007D3
.text$mn:000007D3 loc_7D3:                                ; CODE XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+56j
.text$mn:000007D3                                         ; TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+CAj
.text$mn:000007D3                 cmp     [ebp+arg_0], 0
.text$mn:000007D7                 jz      short loc_83C
.text$mn:000007D9                 mov     ecx, [ebp+arg_0]
.text$mn:000007DC                 movsx   edx, byte ptr [ecx]
.text$mn:000007DF                 test    edx, edx
.text$mn:000007E1                 jz      short loc_83C
.text$mn:000007E3                 mov     eax, [ebp+arg_0]
.text$mn:000007E6                 movzx   ecx, byte ptr [eax]
.text$mn:000007E9                 push    ecx             ; C
.text$mn:000007EA                 call    _isalnum
.text$mn:000007EF                 add     esp, 4
.text$mn:000007F2                 test    eax, eax
.text$mn:000007F4                 jnz     short loc_822
.text$mn:000007F6                 mov     edx, [ebp+arg_0]
.text$mn:000007F9                 movsx   eax, byte ptr [edx]
.text$mn:000007FC                 cmp     eax, 5Fh ; '_'
.text$mn:000007FF                 jz      short loc_822
.text$mn:00000801                 mov     ecx, [ebp+arg_0]
.text$mn:00000804                 movsx   edx, byte ptr [ecx]
.text$mn:00000807                 cmp     edx, 2Dh ; '-'
.text$mn:0000080A                 jz      short loc_822
.text$mn:0000080C                 mov     eax, [ebp+arg_0]
.text$mn:0000080F                 movsx   ecx, byte ptr [eax]
.text$mn:00000812                 cmp     ecx, 2Eh ; '.'
.text$mn:00000815                 jz      short loc_822
.text$mn:00000817                 mov     edx, [ebp+arg_0]
.text$mn:0000081A                 movsx   eax, byte ptr [edx]
.text$mn:0000081D                 cmp     eax, 3Ah ; ':'
.text$mn:00000820                 jnz     short loc_83C
.text$mn:00000822
.text$mn:00000822 loc_822:                                ; CODE XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+84j
.text$mn:00000822                                         ; TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+8Fj ...
.text$mn:00000822                 mov     ecx, [ebp+arg_0]
.text$mn:00000825                 movzx   edx, byte ptr [ecx]
.text$mn:00000828                 push    edx
.text$mn:00000829                 mov     ecx, [ebp+arg_4]
.text$mn:0000082C                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:00000831                 mov     eax, [ebp+arg_0]
.text$mn:00000834                 add     eax, 1
.text$mn:00000837                 mov     [ebp+arg_0], eax
.text$mn:0000083A                 jmp     short loc_7D3
.text$mn:0000083C ; ---------------------------------------------------------------------------
.text$mn:0000083C
.text$mn:0000083C loc_83C:                                ; CODE XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+67j
.text$mn:0000083C                                         ; TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+71j ...
.text$mn:0000083C                 mov     eax, [ebp+arg_0]
.text$mn:0000083F                 jmp     short loc_843
.text$mn:00000841 ; ---------------------------------------------------------------------------
.text$mn:00000841
.text$mn:00000841 loc_841:                                ; CODE XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+31j
.text$mn:00000841                                         ; TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+3Fj ...
.text$mn:00000841                 xor     eax, eax
.text$mn:00000843
.text$mn:00000843 loc_843:                                ; CODE XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+CFj
.text$mn:00000843                 pop     ebp
.text$mn:00000844                 retn
.text$mn:00000844 ?ReadName@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z endp
.text$mn:00000844
.text$mn:00000844 ; ---------------------------------------------------------------------------
.text$mn:00000845                 align 10h
.text$mn:00000850
.text$mn:00000850 ; =============== S U B R O U T I N E =======================================
.text$mn:00000850
.text$mn:00000850 ; Attributes: bp-based frame
.text$mn:00000850
.text$mn:00000850 ; int __cdecl TiXmlBaseA::ReadText(char *Str2, int, char, char *Str, char)
.text$mn:00000850                 public ?ReadText@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N02@Z
.text$mn:00000850 ?ReadText@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N02@Z proc near
.text$mn:00000850                                         ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+190p
.text$mn:00000850                                         ; TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+1CEp ...
.text$mn:00000850
.text$mn:00000850 var_3           = byte ptr -3
.text$mn:00000850 var_2           = byte ptr -2
.text$mn:00000850 var_1           = byte ptr -1
.text$mn:00000850 Str2            = dword ptr  8
.text$mn:00000850 arg_4           = dword ptr  0Ch
.text$mn:00000850 arg_8           = byte ptr  10h
.text$mn:00000850 Str             = dword ptr  14h
.text$mn:00000850 arg_10          = byte ptr  18h
.text$mn:00000850
.text$mn:00000850                 push    ebp
.text$mn:00000851                 mov     ebp, esp
.text$mn:00000853                 push    ecx
.text$mn:00000854                 push    offset $SG94610 ; Str
.text$mn:00000859                 mov     ecx, [ebp+arg_4]
.text$mn:0000085C                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00000861                 movzx   eax, [ebp+arg_8]
.text$mn:00000865                 test    eax, eax
.text$mn:00000867                 jz      short loc_874
.text$mn:00000869                 movzx   ecx, byte ptr ds:?condenseWhiteSpace@TiXmlBaseA@@0_NA ; bool TiXmlBaseA::condenseWhiteSpace
.text$mn:00000870                 test    ecx, ecx
.text$mn:00000872                 jnz     short loc_8C7
.text$mn:00000874
.text$mn:00000874 loc_874:                                ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+17j
.text$mn:00000874                                         ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+70j
.text$mn:00000874                 cmp     [ebp+Str2], 0
.text$mn:00000878                 jz      short loc_8C2
.text$mn:0000087A                 mov     edx, [ebp+Str2]
.text$mn:0000087D                 movsx   eax, byte ptr [edx]
.text$mn:00000880                 test    eax, eax
.text$mn:00000882                 jz      short loc_8C2
.text$mn:00000884                 movzx   ecx, [ebp+arg_10]
.text$mn:00000888                 push    ecx             ; bool
.text$mn:00000889                 mov     edx, [ebp+Str]
.text$mn:0000088C                 push    edx             ; char *
.text$mn:0000088D                 mov     eax, [ebp+Str2]
.text$mn:00000890                 push    eax             ; char *
.text$mn:00000891                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:00000896                 add     esp, 0Ch
.text$mn:00000899                 movzx   ecx, al
.text$mn:0000089C                 test    ecx, ecx
.text$mn:0000089E                 jnz     short loc_8C2
.text$mn:000008A0                 lea     edx, [ebp+var_2]
.text$mn:000008A3                 push    edx             ; char *
.text$mn:000008A4                 mov     eax, [ebp+Str2]
.text$mn:000008A7                 push    eax             ; Str2
.text$mn:000008A8                 call    ?GetChar@TiXmlBaseA@@KAPBDPBDPAD@Z ; TiXmlBaseA::GetChar(char const *,char *)
.text$mn:000008AD                 add     esp, 8
.text$mn:000008B0                 mov     [ebp+Str2], eax
.text$mn:000008B3                 movzx   ecx, [ebp+var_2]
.text$mn:000008B7                 push    ecx
.text$mn:000008B8                 mov     ecx, [ebp+arg_4]
.text$mn:000008BB                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:000008C0                 jmp     short loc_874
.text$mn:000008C2 ; ---------------------------------------------------------------------------
.text$mn:000008C2
.text$mn:000008C2 loc_8C2:                                ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+28j
.text$mn:000008C2                                         ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+32j ...
.text$mn:000008C2                 jmp     loc_994
.text$mn:000008C7 ; ---------------------------------------------------------------------------
.text$mn:000008C7
.text$mn:000008C7 loc_8C7:                                ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+22j
.text$mn:000008C7                 mov     [ebp+var_1], 0
.text$mn:000008CB                 mov     edx, [ebp+Str2]
.text$mn:000008CE                 push    edx             ; char *
.text$mn:000008CF                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:000008D4                 add     esp, 4
.text$mn:000008D7                 mov     [ebp+Str2], eax
.text$mn:000008DA
.text$mn:000008DA loc_8DA:                                ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool):loc_98Fj
.text$mn:000008DA                 cmp     [ebp+Str2], 0
.text$mn:000008DE                 jz      loc_994
.text$mn:000008E4                 mov     eax, [ebp+Str2]
.text$mn:000008E7                 movsx   ecx, byte ptr [eax]
.text$mn:000008EA                 test    ecx, ecx
.text$mn:000008EC                 jz      loc_994
.text$mn:000008F2                 movzx   edx, [ebp+arg_10]
.text$mn:000008F6                 push    edx             ; bool
.text$mn:000008F7                 mov     eax, [ebp+Str]
.text$mn:000008FA                 push    eax             ; char *
.text$mn:000008FB                 mov     ecx, [ebp+Str2]
.text$mn:000008FE                 push    ecx             ; char *
.text$mn:000008FF                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:00000904                 add     esp, 0Ch
.text$mn:00000907                 movzx   edx, al
.text$mn:0000090A                 test    edx, edx
.text$mn:0000090C                 jnz     loc_994
.text$mn:00000912                 mov     eax, [ebp+Str2]
.text$mn:00000915                 movsx   ecx, byte ptr [eax]
.text$mn:00000918                 cmp     ecx, 0Dh
.text$mn:0000091B                 jz      short loc_928
.text$mn:0000091D                 mov     edx, [ebp+Str2]
.text$mn:00000920                 movsx   eax, byte ptr [edx]
.text$mn:00000923                 cmp     eax, 0Ah
.text$mn:00000926                 jnz     short loc_937
.text$mn:00000928
.text$mn:00000928 loc_928:                                ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+CBj
.text$mn:00000928                 mov     [ebp+var_1], 1
.text$mn:0000092C                 mov     ecx, [ebp+Str2]
.text$mn:0000092F                 add     ecx, 1
.text$mn:00000932                 mov     [ebp+Str2], ecx
.text$mn:00000935                 jmp     short loc_98F
.text$mn:00000937 ; ---------------------------------------------------------------------------
.text$mn:00000937
.text$mn:00000937 loc_937:                                ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+D6j
.text$mn:00000937                 mov     edx, [ebp+Str2]
.text$mn:0000093A                 movsx   eax, byte ptr [edx]
.text$mn:0000093D                 push    eax             ; C
.text$mn:0000093E                 call    _isspace
.text$mn:00000943                 add     esp, 4
.text$mn:00000946                 test    eax, eax
.text$mn:00000948                 jz      short loc_959
.text$mn:0000094A                 mov     [ebp+var_1], 1
.text$mn:0000094E                 mov     ecx, [ebp+Str2]
.text$mn:00000951                 add     ecx, 1
.text$mn:00000954                 mov     [ebp+Str2], ecx
.text$mn:00000957                 jmp     short loc_98F
.text$mn:00000959 ; ---------------------------------------------------------------------------
.text$mn:00000959
.text$mn:00000959 loc_959:                                ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+F8j
.text$mn:00000959                 movzx   edx, [ebp+var_1]
.text$mn:0000095D                 test    edx, edx
.text$mn:0000095F                 jz      short loc_96F
.text$mn:00000961                 push    20h ; ' '
.text$mn:00000963                 mov     ecx, [ebp+arg_4]
.text$mn:00000966                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:0000096B                 mov     [ebp+var_1], 0
.text$mn:0000096F
.text$mn:0000096F loc_96F:                                ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+10Fj
.text$mn:0000096F                 lea     eax, [ebp+var_3]
.text$mn:00000972                 push    eax             ; char *
.text$mn:00000973                 mov     ecx, [ebp+Str2]
.text$mn:00000976                 push    ecx             ; Str2
.text$mn:00000977                 call    ?GetChar@TiXmlBaseA@@KAPBDPBDPAD@Z ; TiXmlBaseA::GetChar(char const *,char *)
.text$mn:0000097C                 add     esp, 8
.text$mn:0000097F                 mov     [ebp+Str2], eax
.text$mn:00000982                 movzx   edx, [ebp+var_3]
.text$mn:00000986                 push    edx
.text$mn:00000987                 mov     ecx, [ebp+arg_4]
.text$mn:0000098A                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:0000098F
.text$mn:0000098F loc_98F:                                ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+E5j
.text$mn:0000098F                                         ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+107j
.text$mn:0000098F                 jmp     loc_8DA
.text$mn:00000994 ; ---------------------------------------------------------------------------
.text$mn:00000994
.text$mn:00000994 loc_994:                                ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool):loc_8C2j
.text$mn:00000994                                         ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+8Ej ...
.text$mn:00000994                 mov     eax, [ebp+Str]
.text$mn:00000997                 push    eax             ; Str
.text$mn:00000998                 call    _strlen
.text$mn:0000099D                 add     esp, 4
.text$mn:000009A0                 add     eax, [ebp+Str2]
.text$mn:000009A3                 mov     esp, ebp
.text$mn:000009A5                 pop     ebp
.text$mn:000009A6                 retn
.text$mn:000009A6 ?ReadText@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N02@Z endp
.text$mn:000009A6
.text$mn:000009A6 ; ---------------------------------------------------------------------------
.text$mn:000009A7                 align 10h
.text$mn:000009B0
.text$mn:000009B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009B0
.text$mn:000009B0 ; Attributes: bp-based frame
.text$mn:000009B0
.text$mn:000009B0 ; const char *__cdecl TiXmlBaseA::GetEntity(const char *Str2, char *)
.text$mn:000009B0                 public ?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z
.text$mn:000009B0 ?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z proc near
.text$mn:000009B0                                         ; CODE XREF: TiXmlBaseA::GetChar(char const *,char *)+33p
.text$mn:000009B0
.text$mn:000009B0 var_40          = dword ptr -40h
.text$mn:000009B0 var_3C          = dword ptr -3Ch
.text$mn:000009B0 var_38          = dword ptr -38h
.text$mn:000009B0 var_34          = dword ptr -34h
.text$mn:000009B0 var_30          = dword ptr -30h
.text$mn:000009B0 var_2C          = byte ptr -2Ch
.text$mn:000009B0 var_10          = dword ptr -10h
.text$mn:000009B0 var_C           = dword ptr -0Ch
.text$mn:000009B0 var_4           = dword ptr -4
.text$mn:000009B0 Str2            = dword ptr  8
.text$mn:000009B0 arg_4           = dword ptr  0Ch
.text$mn:000009B0
.text$mn:000009B0                 push    ebp
.text$mn:000009B1                 mov     ebp, esp
.text$mn:000009B3                 push    0FFFFFFFFh
.text$mn:000009B5                 push    offset __ehhandler$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z
.text$mn:000009BA                 mov     eax, large fs:0
.text$mn:000009C0                 push    eax
.text$mn:000009C1                 sub     esp, 34h
.text$mn:000009C4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009C9                 xor     eax, ebp
.text$mn:000009CB                 mov     [ebp+var_10], eax
.text$mn:000009CE                 push    eax
.text$mn:000009CF                 lea     eax, [ebp+var_C]
.text$mn:000009D2                 mov     large fs:0, eax
.text$mn:000009D8                 lea     ecx, [ebp+var_2C]
.text$mn:000009DB                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000009E0                 mov     [ebp+var_4], 0
.text$mn:000009E7                 push    3               ; MaxCount
.text$mn:000009E9                 mov     eax, [ebp+Str2]
.text$mn:000009EC                 push    eax             ; Str2
.text$mn:000009ED                 push    offset $SG94551 ; "&#x"
.text$mn:000009F2                 call    _strncmp
.text$mn:000009F7                 add     esp, 0Ch
.text$mn:000009FA                 test    eax, eax
.text$mn:000009FC                 jnz     loc_B85
.text$mn:00000A02                 mov     ecx, [ebp+Str2]
.text$mn:00000A05                 movsx   edx, byte ptr [ecx+3]
.text$mn:00000A09                 test    edx, edx
.text$mn:00000A0B                 jz      loc_B85
.text$mn:00000A11                 mov     eax, [ebp+Str2]
.text$mn:00000A14                 movsx   ecx, byte ptr [eax+4]
.text$mn:00000A18                 test    ecx, ecx
.text$mn:00000A1A                 jz      loc_B85
.text$mn:00000A20                 mov     edx, [ebp+Str2]
.text$mn:00000A23                 movsx   eax, byte ptr [edx+4]
.text$mn:00000A27                 cmp     eax, 3Bh ; ';'
.text$mn:00000A2A                 jz      short loc_A3C
.text$mn:00000A2C                 mov     ecx, [ebp+Str2]
.text$mn:00000A2F                 movsx   edx, byte ptr [ecx+5]
.text$mn:00000A33                 cmp     edx, 3Bh ; ';'
.text$mn:00000A36                 jnz     loc_B85
.text$mn:00000A3C
.text$mn:00000A3C loc_A3C:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+7Aj
.text$mn:00000A3C                 mov     eax, [ebp+arg_4]
.text$mn:00000A3F                 mov     byte ptr [eax], 0
.text$mn:00000A42                 mov     ecx, [ebp+Str2]
.text$mn:00000A45                 movsx   edx, byte ptr [ecx+4]
.text$mn:00000A49                 cmp     edx, 3Bh ; ';'
.text$mn:00000A4C                 jnz     short loc_AC1
.text$mn:00000A4E                 mov     eax, [ebp+Str2]
.text$mn:00000A51                 movsx   ecx, byte ptr [eax+3]
.text$mn:00000A55                 push    ecx             ; C
.text$mn:00000A56                 call    _isalpha
.text$mn:00000A5B                 add     esp, 4
.text$mn:00000A5E                 test    eax, eax
.text$mn:00000A60                 jz      short loc_A86
.text$mn:00000A62                 mov     edx, [ebp+Str2]
.text$mn:00000A65                 movsx   eax, byte ptr [edx+3]
.text$mn:00000A69                 push    eax             ; C
.text$mn:00000A6A                 call    _tolower
.text$mn:00000A6F                 add     esp, 4
.text$mn:00000A72                 movsx   ecx, al
.text$mn:00000A75                 mov     edx, [ebp+arg_4]
.text$mn:00000A78                 movsx   eax, byte ptr [edx]
.text$mn:00000A7B                 lea     ecx, [eax+ecx-57h]
.text$mn:00000A7F                 mov     edx, [ebp+arg_4]
.text$mn:00000A82                 mov     [edx], cl
.text$mn:00000A84                 jmp     short loc_A9C
.text$mn:00000A86 ; ---------------------------------------------------------------------------
.text$mn:00000A86
.text$mn:00000A86 loc_A86:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+B0j
.text$mn:00000A86                 mov     eax, [ebp+Str2]
.text$mn:00000A89                 movsx   ecx, byte ptr [eax+3]
.text$mn:00000A8D                 mov     edx, [ebp+arg_4]
.text$mn:00000A90                 movsx   eax, byte ptr [edx]
.text$mn:00000A93                 lea     ecx, [eax+ecx-30h]
.text$mn:00000A97                 mov     edx, [ebp+arg_4]
.text$mn:00000A9A                 mov     [edx], cl
.text$mn:00000A9C
.text$mn:00000A9C loc_A9C:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+D4j
.text$mn:00000A9C                 mov     eax, [ebp+Str2]
.text$mn:00000A9F                 add     eax, 5
.text$mn:00000AA2                 mov     [ebp+var_40], eax
.text$mn:00000AA5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000AAC                 lea     ecx, [ebp+var_2C]
.text$mn:00000AAF                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000AB4                 mov     eax, [ebp+var_40]
.text$mn:00000AB7                 jmp     loc_C5A
.text$mn:00000ABC ; ---------------------------------------------------------------------------
.text$mn:00000ABC                 jmp     loc_B85
.text$mn:00000AC1 ; ---------------------------------------------------------------------------
.text$mn:00000AC1
.text$mn:00000AC1 loc_AC1:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+9Cj
.text$mn:00000AC1                 mov     ecx, [ebp+Str2]
.text$mn:00000AC4                 movsx   edx, byte ptr [ecx+3]
.text$mn:00000AC8                 push    edx             ; C
.text$mn:00000AC9                 call    _isalpha
.text$mn:00000ACE                 add     esp, 4
.text$mn:00000AD1                 test    eax, eax
.text$mn:00000AD3                 jz      short loc_AFD
.text$mn:00000AD5                 mov     eax, [ebp+Str2]
.text$mn:00000AD8                 movsx   ecx, byte ptr [eax+3]
.text$mn:00000ADC                 push    ecx             ; C
.text$mn:00000ADD                 call    _tolower
.text$mn:00000AE2                 add     esp, 4
.text$mn:00000AE5                 movsx   edx, al
.text$mn:00000AE8                 sub     edx, 57h ; 'W'
.text$mn:00000AEB                 shl     edx, 4
.text$mn:00000AEE                 mov     eax, [ebp+arg_4]
.text$mn:00000AF1                 movsx   ecx, byte ptr [eax]
.text$mn:00000AF4                 add     ecx, edx
.text$mn:00000AF6                 mov     edx, [ebp+arg_4]
.text$mn:00000AF9                 mov     [edx], cl
.text$mn:00000AFB                 jmp     short loc_B17
.text$mn:00000AFD ; ---------------------------------------------------------------------------
.text$mn:00000AFD
.text$mn:00000AFD loc_AFD:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+123j
.text$mn:00000AFD                 mov     eax, [ebp+Str2]
.text$mn:00000B00                 movsx   ecx, byte ptr [eax+3]
.text$mn:00000B04                 sub     ecx, 30h ; '0'
.text$mn:00000B07                 shl     ecx, 4
.text$mn:00000B0A                 mov     edx, [ebp+arg_4]
.text$mn:00000B0D                 movsx   eax, byte ptr [edx]
.text$mn:00000B10                 add     eax, ecx
.text$mn:00000B12                 mov     ecx, [ebp+arg_4]
.text$mn:00000B15                 mov     [ecx], al
.text$mn:00000B17
.text$mn:00000B17 loc_B17:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+14Bj
.text$mn:00000B17                 mov     edx, [ebp+Str2]
.text$mn:00000B1A                 movsx   eax, byte ptr [edx+4]
.text$mn:00000B1E                 push    eax             ; C
.text$mn:00000B1F                 call    _isalpha
.text$mn:00000B24                 add     esp, 4
.text$mn:00000B27                 test    eax, eax
.text$mn:00000B29                 jz      short loc_B4F
.text$mn:00000B2B                 mov     ecx, [ebp+Str2]
.text$mn:00000B2E                 movsx   edx, byte ptr [ecx+4]
.text$mn:00000B32                 push    edx             ; C
.text$mn:00000B33                 call    _tolower
.text$mn:00000B38                 add     esp, 4
.text$mn:00000B3B                 movsx   eax, al
.text$mn:00000B3E                 mov     ecx, [ebp+arg_4]
.text$mn:00000B41                 movsx   edx, byte ptr [ecx]
.text$mn:00000B44                 lea     eax, [edx+eax-57h]
.text$mn:00000B48                 mov     ecx, [ebp+arg_4]
.text$mn:00000B4B                 mov     [ecx], al
.text$mn:00000B4D                 jmp     short loc_B65
.text$mn:00000B4F ; ---------------------------------------------------------------------------
.text$mn:00000B4F
.text$mn:00000B4F loc_B4F:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+179j
.text$mn:00000B4F                 mov     edx, [ebp+Str2]
.text$mn:00000B52                 movsx   eax, byte ptr [edx+4]
.text$mn:00000B56                 mov     ecx, [ebp+arg_4]
.text$mn:00000B59                 movsx   edx, byte ptr [ecx]
.text$mn:00000B5C                 lea     eax, [edx+eax-30h]
.text$mn:00000B60                 mov     ecx, [ebp+arg_4]
.text$mn:00000B63                 mov     [ecx], al
.text$mn:00000B65
.text$mn:00000B65 loc_B65:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+19Dj
.text$mn:00000B65                 mov     edx, [ebp+Str2]
.text$mn:00000B68                 add     edx, 6
.text$mn:00000B6B                 mov     [ebp+var_34], edx
.text$mn:00000B6E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B75                 lea     ecx, [ebp+var_2C]
.text$mn:00000B78                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000B7D                 mov     eax, [ebp+var_34]
.text$mn:00000B80                 jmp     loc_C5A
.text$mn:00000B85 ; ---------------------------------------------------------------------------
.text$mn:00000B85
.text$mn:00000B85 loc_B85:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+4Cj
.text$mn:00000B85                                         ; TiXmlBaseA::GetEntity(char const *,char *)+5Bj ...
.text$mn:00000B85                 mov     [ebp+var_30], 0
.text$mn:00000B8C                 jmp     short loc_B97
.text$mn:00000B8E ; ---------------------------------------------------------------------------
.text$mn:00000B8E
.text$mn:00000B8E loc_B8E:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *):loc_C30j
.text$mn:00000B8E                 mov     eax, [ebp+var_30]
.text$mn:00000B91                 add     eax, 1
.text$mn:00000B94                 mov     [ebp+var_30], eax
.text$mn:00000B97
.text$mn:00000B97 loc_B97:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+1DCj
.text$mn:00000B97                 cmp     [ebp+var_30], 5
.text$mn:00000B9B                 jge     loc_C35
.text$mn:00000BA1                 imul    ecx, [ebp+var_30], 0Ch
.text$mn:00000BA5                 mov     edx, ds:dword_608[ecx]
.text$mn:00000BAB                 push    edx             ; MaxCount
.text$mn:00000BAC                 mov     eax, [ebp+Str2]
.text$mn:00000BAF                 push    eax             ; Str2
.text$mn:00000BB0                 imul    ecx, [ebp+var_30], 0Ch
.text$mn:00000BB4                 mov     edx, ds:?entity@TiXmlBaseA@@0PAUEntity@1@A[ecx] ; TiXmlBaseA::Entity * TiXmlBaseA::entity
.text$mn:00000BBA                 push    edx             ; Str1
.text$mn:00000BBB                 call    _strncmp
.text$mn:00000BC0                 add     esp, 0Ch
.text$mn:00000BC3                 test    eax, eax
.text$mn:00000BC5                 jnz     short loc_C30
.text$mn:00000BC7                 imul    eax, [ebp+var_30], 0Ch
.text$mn:00000BCB                 mov     ecx, ds:?entity@TiXmlBaseA@@0PAUEntity@1@A[eax] ; TiXmlBaseA::Entity * TiXmlBaseA::entity
.text$mn:00000BD1                 push    ecx             ; Str
.text$mn:00000BD2                 call    _strlen
.text$mn:00000BD7                 add     esp, 4
.text$mn:00000BDA                 imul    edx, [ebp+var_30], 0Ch
.text$mn:00000BDE                 cmp     eax, ds:dword_608[edx]
.text$mn:00000BE4                 jz      short loc_BFD
.text$mn:00000BE6                 push    10Ch            ; Line
.text$mn:00000BEB                 push    offset $SG94574 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:00000BF0                 push    offset $SG94575 ; "strlen( entity[i].str ) == entity[i].st"...
.text$mn:00000BF5                 call    __wassert
.text$mn:00000BFA ; ---------------------------------------------------------------------------
.text$mn:00000BFA                 add     esp, 0Ch
.text$mn:00000BFD
.text$mn:00000BFD loc_BFD:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+234j
.text$mn:00000BFD                 imul    ecx, [ebp+var_30], 0Ch
.text$mn:00000C01                 mov     edx, [ebp+arg_4]
.text$mn:00000C04                 mov     al, ds:byte_60C[ecx]
.text$mn:00000C0A                 mov     [edx], al
.text$mn:00000C0C                 imul    ecx, [ebp+var_30], 0Ch
.text$mn:00000C10                 mov     edx, [ebp+Str2]
.text$mn:00000C13                 add     edx, ds:dword_608[ecx]
.text$mn:00000C19                 mov     [ebp+var_3C], edx
.text$mn:00000C1C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C23                 lea     ecx, [ebp+var_2C]
.text$mn:00000C26                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000C2B                 mov     eax, [ebp+var_3C]
.text$mn:00000C2E                 jmp     short loc_C5A
.text$mn:00000C30 ; ---------------------------------------------------------------------------
.text$mn:00000C30
.text$mn:00000C30 loc_C30:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+215j
.text$mn:00000C30                 jmp     loc_B8E
.text$mn:00000C35 ; ---------------------------------------------------------------------------
.text$mn:00000C35
.text$mn:00000C35 loc_C35:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+1EBj
.text$mn:00000C35                 mov     eax, [ebp+arg_4]
.text$mn:00000C38                 mov     ecx, [ebp+Str2]
.text$mn:00000C3B                 mov     dl, [ecx]
.text$mn:00000C3D                 mov     [eax], dl
.text$mn:00000C3F                 mov     eax, [ebp+Str2]
.text$mn:00000C42                 add     eax, 1
.text$mn:00000C45                 mov     [ebp+var_38], eax
.text$mn:00000C48                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C4F                 lea     ecx, [ebp+var_2C]
.text$mn:00000C52                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000C57                 mov     eax, [ebp+var_38]
.text$mn:00000C5A
.text$mn:00000C5A loc_C5A:                                ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+107j
.text$mn:00000C5A                                         ; TiXmlBaseA::GetEntity(char const *,char *)+1D0j ...
.text$mn:00000C5A                 mov     ecx, [ebp+var_C]
.text$mn:00000C5D                 mov     large fs:0, ecx
.text$mn:00000C64                 pop     ecx
.text$mn:00000C65                 mov     ecx, [ebp+var_10]
.text$mn:00000C68                 xor     ecx, ebp
.text$mn:00000C6A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000C6F                 mov     esp, ebp
.text$mn:00000C71                 pop     ebp
.text$mn:00000C72                 retn
.text$mn:00000C72 ?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z endp
.text$mn:00000C72
.text$mn:00000C72 ; ---------------------------------------------------------------------------
.text$mn:00000C73                 align 10h
.text$mn:00000C80
.text$mn:00000C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C80
.text$mn:00000C80 ; Attributes: bp-based frame
.text$mn:00000C80
.text$mn:00000C80 ; bool __cdecl TiXmlBaseA::StringEqual(const char *, const char *, bool)
.text$mn:00000C80                 public ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z
.text$mn:00000C80 ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z proc near
.text$mn:00000C80                                         ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+41p
.text$mn:00000C80                                         ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+AFp ...
.text$mn:00000C80
.text$mn:00000C80 var_4           = dword ptr -4
.text$mn:00000C80 arg_0           = dword ptr  8
.text$mn:00000C80 arg_4           = dword ptr  0Ch
.text$mn:00000C80 arg_8           = byte ptr  10h
.text$mn:00000C80
.text$mn:00000C80                 push    ebp
.text$mn:00000C81                 mov     ebp, esp
.text$mn:00000C83                 push    ecx
.text$mn:00000C84                 push    esi
.text$mn:00000C85                 cmp     [ebp+arg_0], 0
.text$mn:00000C89                 jnz     short loc_CA2
.text$mn:00000C8B                 push    11Ch            ; Line
.text$mn:00000C90                 push    offset $SG94584 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:00000C95                 push    offset $SG94585 ; Message
.text$mn:00000C9A                 call    __wassert
.text$mn:00000C9F ; ---------------------------------------------------------------------------
.text$mn:00000C9F                 add     esp, 0Ch
.text$mn:00000CA2
.text$mn:00000CA2 loc_CA2:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+9j
.text$mn:00000CA2                 cmp     [ebp+arg_0], 0
.text$mn:00000CA6                 jz      short loc_CB2
.text$mn:00000CA8                 mov     ecx, [ebp+arg_0]
.text$mn:00000CAB                 movsx   edx, byte ptr [ecx]
.text$mn:00000CAE                 test    edx, edx
.text$mn:00000CB0                 jnz     short loc_CD4
.text$mn:00000CB2
.text$mn:00000CB2 loc_CB2:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+26j
.text$mn:00000CB2                 xor     eax, eax
.text$mn:00000CB4                 jnz     short loc_CCD
.text$mn:00000CB6                 push    11Fh            ; Line
.text$mn:00000CBB                 push    offset $SG94589 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:00000CC0                 push    offset $SG94590 ; Message
.text$mn:00000CC5                 call    __wassert
.text$mn:00000CCA ; ---------------------------------------------------------------------------
.text$mn:00000CCA                 add     esp, 0Ch
.text$mn:00000CCD
.text$mn:00000CCD loc_CCD:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+34j
.text$mn:00000CCD                 xor     al, al
.text$mn:00000CCF                 jmp     loc_DAE
.text$mn:00000CD4 ; ---------------------------------------------------------------------------
.text$mn:00000CD4
.text$mn:00000CD4 loc_CD4:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+30j
.text$mn:00000CD4                 mov     edx, [ebp+arg_0]
.text$mn:00000CD7                 movsx   eax, byte ptr [edx]
.text$mn:00000CDA                 push    eax             ; C
.text$mn:00000CDB                 call    _tolower
.text$mn:00000CE0                 add     esp, 4
.text$mn:00000CE3                 mov     esi, eax
.text$mn:00000CE5                 mov     ecx, [ebp+arg_4]
.text$mn:00000CE8                 movsx   edx, byte ptr [ecx]
.text$mn:00000CEB                 push    edx             ; C
.text$mn:00000CEC                 call    _tolower
.text$mn:00000CF1                 add     esp, 4
.text$mn:00000CF4                 cmp     esi, eax
.text$mn:00000CF6                 jnz     loc_DAC
.text$mn:00000CFC                 mov     eax, [ebp+arg_0]
.text$mn:00000CFF                 mov     [ebp+var_4], eax
.text$mn:00000D02                 movzx   ecx, [ebp+arg_8]
.text$mn:00000D06                 test    ecx, ecx
.text$mn:00000D08                 jz      short loc_D52
.text$mn:00000D0A
.text$mn:00000D0A loc_D0A:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+C0j
.text$mn:00000D0A                 mov     edx, [ebp+var_4]
.text$mn:00000D0D                 movsx   eax, byte ptr [edx]
.text$mn:00000D10                 test    eax, eax
.text$mn:00000D12                 jz      short loc_D42
.text$mn:00000D14                 mov     ecx, [ebp+arg_4]
.text$mn:00000D17                 movsx   edx, byte ptr [ecx]
.text$mn:00000D1A                 test    edx, edx
.text$mn:00000D1C                 jz      short loc_D42
.text$mn:00000D1E                 mov     eax, [ebp+var_4]
.text$mn:00000D21                 movsx   ecx, byte ptr [eax]
.text$mn:00000D24                 mov     edx, [ebp+arg_4]
.text$mn:00000D27                 movsx   eax, byte ptr [edx]
.text$mn:00000D2A                 cmp     ecx, eax
.text$mn:00000D2C                 jnz     short loc_D42
.text$mn:00000D2E                 mov     ecx, [ebp+var_4]
.text$mn:00000D31                 add     ecx, 1
.text$mn:00000D34                 mov     [ebp+var_4], ecx
.text$mn:00000D37                 mov     edx, [ebp+arg_4]
.text$mn:00000D3A                 add     edx, 1
.text$mn:00000D3D                 mov     [ebp+arg_4], edx
.text$mn:00000D40                 jmp     short loc_D0A
.text$mn:00000D42 ; ---------------------------------------------------------------------------
.text$mn:00000D42
.text$mn:00000D42 loc_D42:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+92j
.text$mn:00000D42                                         ; TiXmlBaseA::StringEqual(char const *,char const *,bool)+9Cj ...
.text$mn:00000D42                 mov     eax, [ebp+arg_4]
.text$mn:00000D45                 movsx   ecx, byte ptr [eax]
.text$mn:00000D48                 test    ecx, ecx
.text$mn:00000D4A                 jnz     short loc_D50
.text$mn:00000D4C                 mov     al, 1
.text$mn:00000D4E                 jmp     short loc_DAE
.text$mn:00000D50 ; ---------------------------------------------------------------------------
.text$mn:00000D50
.text$mn:00000D50 loc_D50:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+CAj
.text$mn:00000D50                 jmp     short loc_DAC
.text$mn:00000D52 ; ---------------------------------------------------------------------------
.text$mn:00000D52
.text$mn:00000D52 loc_D52:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+88j
.text$mn:00000D52                                         ; TiXmlBaseA::StringEqual(char const *,char const *,bool)+11Cj
.text$mn:00000D52                 mov     edx, [ebp+var_4]
.text$mn:00000D55                 movsx   eax, byte ptr [edx]
.text$mn:00000D58                 test    eax, eax
.text$mn:00000D5A                 jz      short loc_D9E
.text$mn:00000D5C                 mov     ecx, [ebp+arg_4]
.text$mn:00000D5F                 movsx   edx, byte ptr [ecx]
.text$mn:00000D62                 test    edx, edx
.text$mn:00000D64                 jz      short loc_D9E
.text$mn:00000D66                 mov     eax, [ebp+var_4]
.text$mn:00000D69                 movsx   ecx, byte ptr [eax]
.text$mn:00000D6C                 push    ecx             ; C
.text$mn:00000D6D                 call    _tolower
.text$mn:00000D72                 add     esp, 4
.text$mn:00000D75                 mov     esi, eax
.text$mn:00000D77                 mov     edx, [ebp+arg_4]
.text$mn:00000D7A                 movsx   eax, byte ptr [edx]
.text$mn:00000D7D                 push    eax             ; C
.text$mn:00000D7E                 call    _tolower
.text$mn:00000D83                 add     esp, 4
.text$mn:00000D86                 cmp     esi, eax
.text$mn:00000D88                 jnz     short loc_D9E
.text$mn:00000D8A                 mov     ecx, [ebp+var_4]
.text$mn:00000D8D                 add     ecx, 1
.text$mn:00000D90                 mov     [ebp+var_4], ecx
.text$mn:00000D93                 mov     edx, [ebp+arg_4]
.text$mn:00000D96                 add     edx, 1
.text$mn:00000D99                 mov     [ebp+arg_4], edx
.text$mn:00000D9C                 jmp     short loc_D52
.text$mn:00000D9E ; ---------------------------------------------------------------------------
.text$mn:00000D9E
.text$mn:00000D9E loc_D9E:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+DAj
.text$mn:00000D9E                                         ; TiXmlBaseA::StringEqual(char const *,char const *,bool)+E4j ...
.text$mn:00000D9E                 mov     eax, [ebp+arg_4]
.text$mn:00000DA1                 movsx   ecx, byte ptr [eax]
.text$mn:00000DA4                 test    ecx, ecx
.text$mn:00000DA6                 jnz     short loc_DAC
.text$mn:00000DA8                 mov     al, 1
.text$mn:00000DAA                 jmp     short loc_DAE
.text$mn:00000DAC ; ---------------------------------------------------------------------------
.text$mn:00000DAC
.text$mn:00000DAC loc_DAC:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+76j
.text$mn:00000DAC                                         ; TiXmlBaseA::StringEqual(char const *,char const *,bool):loc_D50j ...
.text$mn:00000DAC                 xor     al, al
.text$mn:00000DAE
.text$mn:00000DAE loc_DAE:                                ; CODE XREF: TiXmlBaseA::StringEqual(char const *,char const *,bool)+4Fj
.text$mn:00000DAE                                         ; TiXmlBaseA::StringEqual(char const *,char const *,bool)+CEj ...
.text$mn:00000DAE                 pop     esi
.text$mn:00000DAF                 mov     esp, ebp
.text$mn:00000DB1                 pop     ebp
.text$mn:00000DB2                 retn
.text$mn:00000DB2 ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z endp
.text$mn:00000DB2
.text$mn:00000DB2 ; ---------------------------------------------------------------------------
.text$mn:00000DB3                 align 10h
.text$mn:00000DC0
.text$mn:00000DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DC0
.text$mn:00000DC0 ; Attributes: bp-based frame
.text$mn:00000DC0
.text$mn:00000DC0 ; struct TiXmlNodeA *__thiscall TiXmlNodeA::Identify(TiXmlNodeA *this, const char *)
.text$mn:00000DC0                 public ?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z
.text$mn:00000DC0 ?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z proc near
.text$mn:00000DC0                                         ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+263p
.text$mn:00000DC0                                         ; TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+15Bp ...
.text$mn:00000DC0
.text$mn:00000DC0 var_50          = dword ptr -50h
.text$mn:00000DC0 var_4C          = dword ptr -4Ch
.text$mn:00000DC0 var_48          = dword ptr -48h
.text$mn:00000DC0 var_44          = dword ptr -44h
.text$mn:00000DC0 var_40          = dword ptr -40h
.text$mn:00000DC0 var_3C          = dword ptr -3Ch
.text$mn:00000DC0 var_38          = dword ptr -38h
.text$mn:00000DC0 var_34          = dword ptr -34h
.text$mn:00000DC0 var_30          = dword ptr -30h
.text$mn:00000DC0 var_2C          = dword ptr -2Ch
.text$mn:00000DC0 var_28          = dword ptr -28h
.text$mn:00000DC0 var_24          = dword ptr -24h
.text$mn:00000DC0 var_20          = dword ptr -20h
.text$mn:00000DC0 var_1C          = dword ptr -1Ch
.text$mn:00000DC0 var_18          = dword ptr -18h
.text$mn:00000DC0 var_14          = dword ptr -14h
.text$mn:00000DC0 var_10          = dword ptr -10h
.text$mn:00000DC0 var_C           = dword ptr -0Ch
.text$mn:00000DC0 var_4           = dword ptr -4
.text$mn:00000DC0 arg_0           = dword ptr  8
.text$mn:00000DC0
.text$mn:00000DC0                 push    ebp
.text$mn:00000DC1                 mov     ebp, esp
.text$mn:00000DC3                 push    0FFFFFFFFh
.text$mn:00000DC5                 push    offset __ehhandler$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z
.text$mn:00000DCA                 mov     eax, large fs:0
.text$mn:00000DD0                 push    eax
.text$mn:00000DD1                 sub     esp, 44h
.text$mn:00000DD4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DD9                 xor     eax, ebp
.text$mn:00000DDB                 push    eax
.text$mn:00000DDC                 lea     eax, [ebp+var_C]
.text$mn:00000DDF                 mov     large fs:0, eax
.text$mn:00000DE5                 mov     [ebp+var_34], ecx
.text$mn:00000DE8                 mov     [ebp+var_10], 0
.text$mn:00000DEF                 mov     eax, [ebp+arg_0]
.text$mn:00000DF2                 push    eax             ; char *
.text$mn:00000DF3                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00000DF8                 add     esp, 4
.text$mn:00000DFB                 mov     [ebp+arg_0], eax
.text$mn:00000DFE                 cmp     [ebp+arg_0], 0
.text$mn:00000E02                 jz      short loc_E19
.text$mn:00000E04                 mov     ecx, [ebp+arg_0]
.text$mn:00000E07                 movsx   edx, byte ptr [ecx]
.text$mn:00000E0A                 test    edx, edx
.text$mn:00000E0C                 jz      short loc_E19
.text$mn:00000E0E                 mov     eax, [ebp+arg_0]
.text$mn:00000E11                 movsx   ecx, byte ptr [eax]
.text$mn:00000E14                 cmp     ecx, 3Ch ; '<'
.text$mn:00000E17                 jz      short loc_E20
.text$mn:00000E19
.text$mn:00000E19 loc_E19:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+42j
.text$mn:00000E19                                         ; TiXmlNodeA::Identify(char const *)+4Cj
.text$mn:00000E19                 xor     eax, eax
.text$mn:00000E1B                 jmp     loc_FF4
.text$mn:00000E20 ; ---------------------------------------------------------------------------
.text$mn:00000E20
.text$mn:00000E20 loc_E20:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+57j
.text$mn:00000E20                 mov     ecx, [ebp+var_34] ; this
.text$mn:00000E23                 call    ?GetDocument@TiXmlNodeA@@QBEPAVTiXmlDocumentA@@XZ ; TiXmlNodeA::GetDocument(void)
.text$mn:00000E28                 mov     [ebp+var_38], eax
.text$mn:00000E2B                 mov     edx, [ebp+arg_0]
.text$mn:00000E2E                 push    edx             ; char *
.text$mn:00000E2F                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00000E34                 add     esp, 4
.text$mn:00000E37                 mov     [ebp+arg_0], eax
.text$mn:00000E3A                 cmp     [ebp+arg_0], 0
.text$mn:00000E3E                 jz      short loc_E4A
.text$mn:00000E40                 mov     eax, [ebp+arg_0]
.text$mn:00000E43                 movsx   ecx, byte ptr [eax]
.text$mn:00000E46                 test    ecx, ecx
.text$mn:00000E48                 jnz     short loc_E51
.text$mn:00000E4A
.text$mn:00000E4A loc_E4A:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+7Ej
.text$mn:00000E4A                 xor     eax, eax
.text$mn:00000E4C                 jmp     loc_FF4
.text$mn:00000E51 ; ---------------------------------------------------------------------------
.text$mn:00000E51
.text$mn:00000E51 loc_E51:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+88j
.text$mn:00000E51                 mov     [ebp+var_3C], offset $SG94691 ; "<?xml"
.text$mn:00000E58                 mov     [ebp+var_48], offset $SG94693 ; "<!--"
.text$mn:00000E5F                 push    1               ; bool
.text$mn:00000E61                 mov     edx, [ebp+var_3C]
.text$mn:00000E64                 push    edx             ; char *
.text$mn:00000E65                 mov     eax, [ebp+arg_0]
.text$mn:00000E68                 push    eax             ; char *
.text$mn:00000E69                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:00000E6E                 add     esp, 0Ch
.text$mn:00000E71                 movzx   ecx, al
.text$mn:00000E74                 test    ecx, ecx
.text$mn:00000E76                 jz      short loc_EC1
.text$mn:00000E78                 push    98h ; 'Ã¿'       ; unsigned int
.text$mn:00000E7D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000E82                 add     esp, 4
.text$mn:00000E85                 mov     [ebp+var_14], eax
.text$mn:00000E88                 mov     [ebp+var_4], 0
.text$mn:00000E8F                 cmp     [ebp+var_14], 0
.text$mn:00000E93                 jz      short loc_EA2
.text$mn:00000E95                 mov     ecx, [ebp+var_14] ; this
.text$mn:00000E98                 call    ??0TiXmlDeclarationA@@QAE@XZ ; TiXmlDeclarationA::TiXmlDeclarationA(void)
.text$mn:00000E9D                 mov     [ebp+var_18], eax
.text$mn:00000EA0                 jmp     short loc_EA9
.text$mn:00000EA2 ; ---------------------------------------------------------------------------
.text$mn:00000EA2
.text$mn:00000EA2 loc_EA2:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+D3j
.text$mn:00000EA2                 mov     [ebp+var_18], 0
.text$mn:00000EA9
.text$mn:00000EA9 loc_EA9:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+E0j
.text$mn:00000EA9                 mov     edx, [ebp+var_18]
.text$mn:00000EAC                 mov     [ebp+var_40], edx
.text$mn:00000EAF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EB6                 mov     eax, [ebp+var_40]
.text$mn:00000EB9                 mov     [ebp+var_10], eax
.text$mn:00000EBC                 jmp     loc_FCC
.text$mn:00000EC1 ; ---------------------------------------------------------------------------
.text$mn:00000EC1
.text$mn:00000EC1 loc_EC1:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+B6j
.text$mn:00000EC1                 mov     ecx, [ebp+arg_0]
.text$mn:00000EC4                 movsx   edx, byte ptr [ecx+1]
.text$mn:00000EC8                 push    edx             ; C
.text$mn:00000EC9                 call    _isalpha
.text$mn:00000ECE                 add     esp, 4
.text$mn:00000ED1                 test    eax, eax
.text$mn:00000ED3                 jnz     short loc_EE1
.text$mn:00000ED5                 mov     eax, [ebp+arg_0]
.text$mn:00000ED8                 movsx   ecx, byte ptr [eax+1]
.text$mn:00000EDC                 cmp     ecx, 5Fh ; '_'
.text$mn:00000EDF                 jnz     short loc_F2F
.text$mn:00000EE1
.text$mn:00000EE1 loc_EE1:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+113j
.text$mn:00000EE1                 push    94h ; 'Ã¶'       ; unsigned int
.text$mn:00000EE6                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000EEB                 add     esp, 4
.text$mn:00000EEE                 mov     [ebp+var_1C], eax
.text$mn:00000EF1                 mov     [ebp+var_4], 1
.text$mn:00000EF8                 cmp     [ebp+var_1C], 0
.text$mn:00000EFC                 jz      short loc_F10
.text$mn:00000EFE                 push    offset $SG94706 ; char *
.text$mn:00000F03                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00000F06                 call    ??0TiXmlElementA@@QAE@PBD@Z ; TiXmlElementA::TiXmlElementA(char const *)
.text$mn:00000F0B                 mov     [ebp+var_20], eax
.text$mn:00000F0E                 jmp     short loc_F17
.text$mn:00000F10 ; ---------------------------------------------------------------------------
.text$mn:00000F10
.text$mn:00000F10 loc_F10:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+13Cj
.text$mn:00000F10                 mov     [ebp+var_20], 0
.text$mn:00000F17
.text$mn:00000F17 loc_F17:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+14Ej
.text$mn:00000F17                 mov     edx, [ebp+var_20]
.text$mn:00000F1A                 mov     [ebp+var_44], edx
.text$mn:00000F1D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F24                 mov     eax, [ebp+var_44]
.text$mn:00000F27                 mov     [ebp+var_10], eax
.text$mn:00000F2A                 jmp     loc_FCC
.text$mn:00000F2F ; ---------------------------------------------------------------------------
.text$mn:00000F2F
.text$mn:00000F2F loc_F2F:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+11Fj
.text$mn:00000F2F                 push    0               ; bool
.text$mn:00000F31                 mov     ecx, [ebp+var_48]
.text$mn:00000F34                 push    ecx             ; char *
.text$mn:00000F35                 mov     edx, [ebp+arg_0]
.text$mn:00000F38                 push    edx             ; char *
.text$mn:00000F39                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:00000F3E                 add     esp, 0Ch
.text$mn:00000F41                 movzx   eax, al
.text$mn:00000F44                 test    eax, eax
.text$mn:00000F46                 jz      short loc_F8B
.text$mn:00000F48                 push    44h ; 'D'       ; unsigned int
.text$mn:00000F4A                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000F4F                 add     esp, 4
.text$mn:00000F52                 mov     [ebp+var_24], eax
.text$mn:00000F55                 mov     [ebp+var_4], 2
.text$mn:00000F5C                 cmp     [ebp+var_24], 0
.text$mn:00000F60                 jz      short loc_F6F
.text$mn:00000F62                 mov     ecx, [ebp+var_24] ; this
.text$mn:00000F65                 call    ??0TiXmlCommentA@@QAE@XZ ; TiXmlCommentA::TiXmlCommentA(void)
.text$mn:00000F6A                 mov     [ebp+var_28], eax
.text$mn:00000F6D                 jmp     short loc_F76
.text$mn:00000F6F ; ---------------------------------------------------------------------------
.text$mn:00000F6F
.text$mn:00000F6F loc_F6F:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+1A0j
.text$mn:00000F6F                 mov     [ebp+var_28], 0
.text$mn:00000F76
.text$mn:00000F76 loc_F76:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+1ADj
.text$mn:00000F76                 mov     ecx, [ebp+var_28]
.text$mn:00000F79                 mov     [ebp+var_4C], ecx
.text$mn:00000F7C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F83                 mov     edx, [ebp+var_4C]
.text$mn:00000F86                 mov     [ebp+var_10], edx
.text$mn:00000F89                 jmp     short loc_FCC
.text$mn:00000F8B ; ---------------------------------------------------------------------------
.text$mn:00000F8B
.text$mn:00000F8B loc_F8B:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+186j
.text$mn:00000F8B                 push    44h ; 'D'       ; unsigned int
.text$mn:00000F8D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000F92                 add     esp, 4
.text$mn:00000F95                 mov     [ebp+var_2C], eax
.text$mn:00000F98                 mov     [ebp+var_4], 3
.text$mn:00000F9F                 cmp     [ebp+var_2C], 0
.text$mn:00000FA3                 jz      short loc_FB2
.text$mn:00000FA5                 mov     ecx, [ebp+var_2C] ; this
.text$mn:00000FA8                 call    ??0TiXmlUnknownA@@QAE@XZ ; TiXmlUnknownA::TiXmlUnknownA(void)
.text$mn:00000FAD                 mov     [ebp+var_30], eax
.text$mn:00000FB0                 jmp     short loc_FB9
.text$mn:00000FB2 ; ---------------------------------------------------------------------------
.text$mn:00000FB2
.text$mn:00000FB2 loc_FB2:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+1E3j
.text$mn:00000FB2                 mov     [ebp+var_30], 0
.text$mn:00000FB9
.text$mn:00000FB9 loc_FB9:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+1F0j
.text$mn:00000FB9                 mov     eax, [ebp+var_30]
.text$mn:00000FBC                 mov     [ebp+var_50], eax
.text$mn:00000FBF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FC6                 mov     ecx, [ebp+var_50]
.text$mn:00000FC9                 mov     [ebp+var_10], ecx
.text$mn:00000FCC
.text$mn:00000FCC loc_FCC:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+FCj
.text$mn:00000FCC                                         ; TiXmlNodeA::Identify(char const *)+16Aj ...
.text$mn:00000FCC                 cmp     [ebp+var_10], 0
.text$mn:00000FD0                 jz      short loc_FDD
.text$mn:00000FD2                 mov     edx, [ebp+var_10]
.text$mn:00000FD5                 mov     eax, [ebp+var_34]
.text$mn:00000FD8                 mov     [edx+0Ch], eax
.text$mn:00000FDB                 jmp     short loc_FF1
.text$mn:00000FDD ; ---------------------------------------------------------------------------
.text$mn:00000FDD
.text$mn:00000FDD loc_FDD:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+210j
.text$mn:00000FDD                 cmp     [ebp+var_38], 0
.text$mn:00000FE1                 jz      short loc_FF1
.text$mn:00000FE3                 push    0               ; struct TiXmlParsingDataA *
.text$mn:00000FE5                 push    0               ; char *
.text$mn:00000FE7                 push    3               ; int
.text$mn:00000FE9                 mov     ecx, [ebp+var_38] ; this
.text$mn:00000FEC                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:00000FF1
.text$mn:00000FF1 loc_FF1:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+21Bj
.text$mn:00000FF1                                         ; TiXmlNodeA::Identify(char const *)+221j
.text$mn:00000FF1                 mov     eax, [ebp+var_10]
.text$mn:00000FF4
.text$mn:00000FF4 loc_FF4:                                ; CODE XREF: TiXmlNodeA::Identify(char const *)+5Bj
.text$mn:00000FF4                                         ; TiXmlNodeA::Identify(char const *)+8Cj
.text$mn:00000FF4                 mov     ecx, [ebp+var_C]
.text$mn:00000FF7                 mov     large fs:0, ecx
.text$mn:00000FFE                 pop     ecx
.text$mn:00000FFF                 mov     esp, ebp
.text$mn:00001001                 pop     ebp
.text$mn:00001002                 retn    4
.text$mn:00001002 ?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z endp
.text$mn:00001002
.text$mn:00001002 ; ---------------------------------------------------------------------------
.text$mn:00001005                 align 10h
.text$mn:00001010
.text$mn:00001010 ; =============== S U B R O U T I N E =======================================
.text$mn:00001010
.text$mn:00001010 ; Attributes: bp-based frame
.text$mn:00001010
.text$mn:00001010 ; const char *__thiscall TiXmlAttributeA::Parse(TiXmlAttributeA *this, const char *Str2, struct TiXmlParsingDataA *)
.text$mn:00001010                 public ?Parse@TiXmlAttributeA@@UAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:00001010 ?Parse@TiXmlAttributeA@@UAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$mn:00001010                                         ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+180p
.text$mn:00001010                                         ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+1EDp ...
.text$mn:00001010
.text$mn:00001010 var_10          = dword ptr -10h
.text$mn:00001010 var_C           = dword ptr -0Ch
.text$mn:00001010 Str             = dword ptr -8
.text$mn:00001010 var_4           = dword ptr -4
.text$mn:00001010 Str2            = dword ptr  8
.text$mn:00001010 arg_4           = dword ptr  0Ch
.text$mn:00001010
.text$mn:00001010                 push    ebp
.text$mn:00001011                 mov     ebp, esp
.text$mn:00001013                 sub     esp, 10h
.text$mn:00001016                 mov     [ebp+var_4], ecx
.text$mn:00001019                 mov     eax, [ebp+Str2]
.text$mn:0000101C                 push    eax             ; char *
.text$mn:0000101D                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00001022                 add     esp, 4
.text$mn:00001025                 mov     [ebp+Str2], eax
.text$mn:00001028                 cmp     [ebp+Str2], 0
.text$mn:0000102C                 jz      short loc_1038
.text$mn:0000102E                 mov     ecx, [ebp+Str2]
.text$mn:00001031                 movsx   edx, byte ptr [ecx]
.text$mn:00001034                 test    edx, edx
.text$mn:00001036                 jnz     short loc_103F
.text$mn:00001038
.text$mn:00001038 loc_1038:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+1Cj
.text$mn:00001038                 xor     eax, eax
.text$mn:0000103A                 jmp     loc_126A
.text$mn:0000103F ; ---------------------------------------------------------------------------
.text$mn:0000103F
.text$mn:0000103F loc_103F:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+26j
.text$mn:0000103F                 mov     [ebp+var_C], 4
.text$mn:00001046                 mov     eax, [ebp+var_4]
.text$mn:00001049                 cmp     dword ptr [eax+0Ch], 0
.text$mn:0000104D                 jz      short loc_105D
.text$mn:0000104F                 mov     ecx, [ebp+var_4]
.text$mn:00001052                 mov     ecx, [ecx+0Ch]  ; this
.text$mn:00001055                 call    ?TabSize@TiXmlDocumentA@@QBEHXZ ; TiXmlDocumentA::TabSize(void)
.text$mn:0000105A                 mov     [ebp+var_C], eax
.text$mn:0000105D
.text$mn:0000105D loc_105D:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+3Dj
.text$mn:0000105D                 cmp     [ebp+arg_4], 0
.text$mn:00001061                 jz      short loc_1085
.text$mn:00001063                 mov     edx, [ebp+Str2]
.text$mn:00001066                 push    edx             ; char *
.text$mn:00001067                 mov     ecx, [ebp+arg_4] ; this
.text$mn:0000106A                 call    ?Stamp@TiXmlParsingDataA@@QAEXPBD@Z ; TiXmlParsingDataA::Stamp(char const *)
.text$mn:0000106F                 mov     ecx, [ebp+arg_4] ; this
.text$mn:00001072                 call    ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ ; TiXmlParsingDataA::Cursor(void)
.text$mn:00001077                 mov     ecx, [eax]
.text$mn:00001079                 mov     edx, [eax+4]
.text$mn:0000107C                 mov     eax, [ebp+var_4]
.text$mn:0000107F                 mov     [eax+4], ecx
.text$mn:00001082                 mov     [eax+8], edx
.text$mn:00001085
.text$mn:00001085 loc_1085:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+51j
.text$mn:00001085                 mov     ecx, [ebp+Str2]
.text$mn:00001088                 mov     [ebp+var_10], ecx
.text$mn:0000108B                 mov     edx, [ebp+var_4]
.text$mn:0000108E                 add     edx, 10h
.text$mn:00001091                 push    edx
.text$mn:00001092                 mov     eax, [ebp+Str2]
.text$mn:00001095                 push    eax
.text$mn:00001096                 call    ?ReadName@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)
.text$mn:0000109B                 add     esp, 8
.text$mn:0000109E                 mov     [ebp+Str2], eax
.text$mn:000010A1                 cmp     [ebp+Str2], 0
.text$mn:000010A5                 jz      short loc_10B1
.text$mn:000010A7                 mov     ecx, [ebp+Str2]
.text$mn:000010AA                 movsx   edx, byte ptr [ecx]
.text$mn:000010AD                 test    edx, edx
.text$mn:000010AF                 jnz     short loc_10D6
.text$mn:000010B1
.text$mn:000010B1 loc_10B1:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+95j
.text$mn:000010B1                 mov     eax, [ebp+var_4]
.text$mn:000010B4                 cmp     dword ptr [eax+0Ch], 0
.text$mn:000010B8                 jz      short loc_10CF
.text$mn:000010BA                 mov     ecx, [ebp+arg_4]
.text$mn:000010BD                 push    ecx             ; struct TiXmlParsingDataA *
.text$mn:000010BE                 mov     edx, [ebp+var_10]
.text$mn:000010C1                 push    edx             ; char *
.text$mn:000010C2                 push    7               ; int
.text$mn:000010C4                 mov     eax, [ebp+var_4]
.text$mn:000010C7                 mov     ecx, [eax+0Ch]  ; this
.text$mn:000010CA                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:000010CF
.text$mn:000010CF loc_10CF:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+A8j
.text$mn:000010CF                 xor     eax, eax
.text$mn:000010D1                 jmp     loc_126A
.text$mn:000010D6 ; ---------------------------------------------------------------------------
.text$mn:000010D6
.text$mn:000010D6 loc_10D6:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+9Fj
.text$mn:000010D6                 mov     ecx, [ebp+Str2]
.text$mn:000010D9                 push    ecx             ; char *
.text$mn:000010DA                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:000010DF                 add     esp, 4
.text$mn:000010E2                 mov     [ebp+Str2], eax
.text$mn:000010E5                 cmp     [ebp+Str2], 0
.text$mn:000010E9                 jz      short loc_1100
.text$mn:000010EB                 mov     edx, [ebp+Str2]
.text$mn:000010EE                 movsx   eax, byte ptr [edx]
.text$mn:000010F1                 test    eax, eax
.text$mn:000010F3                 jz      short loc_1100
.text$mn:000010F5                 mov     ecx, [ebp+Str2]
.text$mn:000010F8                 movsx   edx, byte ptr [ecx]
.text$mn:000010FB                 cmp     edx, 3Dh ; '='
.text$mn:000010FE                 jz      short loc_1125
.text$mn:00001100
.text$mn:00001100 loc_1100:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+D9j
.text$mn:00001100                                         ; TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+E3j
.text$mn:00001100                 mov     eax, [ebp+var_4]
.text$mn:00001103                 cmp     dword ptr [eax+0Ch], 0
.text$mn:00001107                 jz      short loc_111E
.text$mn:00001109                 mov     ecx, [ebp+arg_4]
.text$mn:0000110C                 push    ecx             ; struct TiXmlParsingDataA *
.text$mn:0000110D                 mov     edx, [ebp+Str2]
.text$mn:00001110                 push    edx             ; char *
.text$mn:00001111                 push    7               ; int
.text$mn:00001113                 mov     eax, [ebp+var_4]
.text$mn:00001116                 mov     ecx, [eax+0Ch]  ; this
.text$mn:00001119                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:0000111E
.text$mn:0000111E loc_111E:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+F7j
.text$mn:0000111E                 xor     eax, eax
.text$mn:00001120                 jmp     loc_126A
.text$mn:00001125 ; ---------------------------------------------------------------------------
.text$mn:00001125
.text$mn:00001125 loc_1125:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+EEj
.text$mn:00001125                 mov     ecx, [ebp+Str2]
.text$mn:00001128                 add     ecx, 1
.text$mn:0000112B                 mov     [ebp+Str2], ecx
.text$mn:0000112E                 mov     edx, [ebp+Str2]
.text$mn:00001131                 push    edx             ; char *
.text$mn:00001132                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00001137                 add     esp, 4
.text$mn:0000113A                 mov     [ebp+Str2], eax
.text$mn:0000113D                 cmp     [ebp+Str2], 0
.text$mn:00001141                 jz      short loc_114D
.text$mn:00001143                 mov     eax, [ebp+Str2]
.text$mn:00001146                 movsx   ecx, byte ptr [eax]
.text$mn:00001149                 test    ecx, ecx
.text$mn:0000114B                 jnz     short loc_1172
.text$mn:0000114D
.text$mn:0000114D loc_114D:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+131j
.text$mn:0000114D                 mov     edx, [ebp+var_4]
.text$mn:00001150                 cmp     dword ptr [edx+0Ch], 0
.text$mn:00001154                 jz      short loc_116B
.text$mn:00001156                 mov     eax, [ebp+arg_4]
.text$mn:00001159                 push    eax             ; struct TiXmlParsingDataA *
.text$mn:0000115A                 mov     ecx, [ebp+Str2]
.text$mn:0000115D                 push    ecx             ; char *
.text$mn:0000115E                 push    7               ; int
.text$mn:00001160                 mov     edx, [ebp+var_4]
.text$mn:00001163                 mov     ecx, [edx+0Ch]  ; this
.text$mn:00001166                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:0000116B
.text$mn:0000116B loc_116B:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+144j
.text$mn:0000116B                 xor     eax, eax
.text$mn:0000116D                 jmp     loc_126A
.text$mn:00001172 ; ---------------------------------------------------------------------------
.text$mn:00001172
.text$mn:00001172 loc_1172:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+13Bj
.text$mn:00001172                 mov     eax, [ebp+Str2]
.text$mn:00001175                 movsx   ecx, byte ptr [eax]
.text$mn:00001178                 cmp     ecx, 27h ; '''
.text$mn:0000117B                 jnz     short loc_11B0
.text$mn:0000117D                 mov     edx, [ebp+Str2]
.text$mn:00001180                 add     edx, 1
.text$mn:00001183                 mov     [ebp+Str2], edx
.text$mn:00001186                 mov     [ebp+Str], offset $SG94938
.text$mn:0000118D                 push    0               ; char
.text$mn:0000118F                 mov     eax, [ebp+Str]
.text$mn:00001192                 push    eax             ; Str
.text$mn:00001193                 push    0               ; char
.text$mn:00001195                 mov     ecx, [ebp+var_4]
.text$mn:00001198                 add     ecx, 2Ch ; ','
.text$mn:0000119B                 push    ecx             ; int
.text$mn:0000119C                 mov     edx, [ebp+Str2]
.text$mn:0000119F                 push    edx             ; Str2
.text$mn:000011A0                 call    ?ReadText@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N02@Z ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)
.text$mn:000011A5                 add     esp, 14h
.text$mn:000011A8                 mov     [ebp+Str2], eax
.text$mn:000011AB                 jmp     loc_1267
.text$mn:000011B0 ; ---------------------------------------------------------------------------
.text$mn:000011B0
.text$mn:000011B0 loc_11B0:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+16Bj
.text$mn:000011B0                 mov     eax, [ebp+Str2]
.text$mn:000011B3                 movsx   ecx, byte ptr [eax]
.text$mn:000011B6                 cmp     ecx, 22h ; '"'
.text$mn:000011B9                 jnz     short loc_11EB
.text$mn:000011BB                 mov     edx, [ebp+Str2]
.text$mn:000011BE                 add     edx, 1
.text$mn:000011C1                 mov     [ebp+Str2], edx
.text$mn:000011C4                 mov     [ebp+Str], offset $SG94941
.text$mn:000011CB                 push    0               ; char
.text$mn:000011CD                 mov     eax, [ebp+Str]
.text$mn:000011D0                 push    eax             ; Str
.text$mn:000011D1                 push    0               ; char
.text$mn:000011D3                 mov     ecx, [ebp+var_4]
.text$mn:000011D6                 add     ecx, 2Ch ; ','
.text$mn:000011D9                 push    ecx             ; int
.text$mn:000011DA                 mov     edx, [ebp+Str2]
.text$mn:000011DD                 push    edx             ; Str2
.text$mn:000011DE                 call    ?ReadText@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N02@Z ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)
.text$mn:000011E3                 add     esp, 14h
.text$mn:000011E6                 mov     [ebp+Str2], eax
.text$mn:000011E9                 jmp     short loc_1267
.text$mn:000011EB ; ---------------------------------------------------------------------------
.text$mn:000011EB
.text$mn:000011EB loc_11EB:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+1A9j
.text$mn:000011EB                 push    offset $SG94943 ; Str
.text$mn:000011F0                 mov     ecx, [ebp+var_4]
.text$mn:000011F3                 add     ecx, 2Ch ; ','
.text$mn:000011F6                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:000011FB
.text$mn:000011FB loc_11FB:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+255j
.text$mn:000011FB                 cmp     [ebp+Str2], 0
.text$mn:000011FF                 jz      short loc_1267
.text$mn:00001201                 mov     eax, [ebp+Str2]
.text$mn:00001204                 movsx   ecx, byte ptr [eax]
.text$mn:00001207                 test    ecx, ecx
.text$mn:00001209                 jz      short loc_1267
.text$mn:0000120B                 mov     edx, [ebp+Str2]
.text$mn:0000120E                 movsx   eax, byte ptr [edx]
.text$mn:00001211                 push    eax             ; C
.text$mn:00001212                 call    _isspace
.text$mn:00001217                 add     esp, 4
.text$mn:0000121A                 test    eax, eax
.text$mn:0000121C                 jnz     short loc_1267
.text$mn:0000121E                 mov     ecx, [ebp+Str2]
.text$mn:00001221                 movsx   edx, byte ptr [ecx]
.text$mn:00001224                 cmp     edx, 0Ah
.text$mn:00001227                 jz      short loc_1267
.text$mn:00001229                 mov     eax, [ebp+Str2]
.text$mn:0000122C                 movsx   ecx, byte ptr [eax]
.text$mn:0000122F                 cmp     ecx, 0Dh
.text$mn:00001232                 jz      short loc_1267
.text$mn:00001234                 mov     edx, [ebp+Str2]
.text$mn:00001237                 movsx   eax, byte ptr [edx]
.text$mn:0000123A                 cmp     eax, 2Fh ; '/'
.text$mn:0000123D                 jz      short loc_1267
.text$mn:0000123F                 mov     ecx, [ebp+Str2]
.text$mn:00001242                 movsx   edx, byte ptr [ecx]
.text$mn:00001245                 cmp     edx, 3Eh ; '>'
.text$mn:00001248                 jz      short loc_1267
.text$mn:0000124A                 mov     eax, [ebp+Str2]
.text$mn:0000124D                 movzx   ecx, byte ptr [eax]
.text$mn:00001250                 push    ecx
.text$mn:00001251                 mov     ecx, [ebp+var_4]
.text$mn:00001254                 add     ecx, 2Ch ; ','
.text$mn:00001257                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:0000125C                 mov     edx, [ebp+Str2]
.text$mn:0000125F                 add     edx, 1
.text$mn:00001262                 mov     [ebp+Str2], edx
.text$mn:00001265                 jmp     short loc_11FB
.text$mn:00001267 ; ---------------------------------------------------------------------------
.text$mn:00001267
.text$mn:00001267 loc_1267:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+19Bj
.text$mn:00001267                                         ; TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+1D9j ...
.text$mn:00001267                 mov     eax, [ebp+Str2]
.text$mn:0000126A
.text$mn:0000126A loc_126A:                               ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+2Aj
.text$mn:0000126A                                         ; TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+C1j ...
.text$mn:0000126A                 mov     esp, ebp
.text$mn:0000126C                 pop     ebp
.text$mn:0000126D                 retn    8
.text$mn:0000126D ?Parse@TiXmlAttributeA@@UAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$mn:0000126D
.text$mn:00001270
.text$mn:00001270 ; =============== S U B R O U T I N E =======================================
.text$mn:00001270
.text$mn:00001270 ; Attributes: bp-based frame
.text$mn:00001270
.text$mn:00001270 ; protected: virtual void __thiscall TiXmlElementA::StreamIn(class std::basic_istream<char, struct std::char_traits<char>> *, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> *)
.text$mn:00001270                 public ?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.text$mn:00001270 ?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z proc near
.text$mn:00001270
.text$mn:00001270 var_80          = dword ptr -80h
.text$mn:00001270 var_7C          = dword ptr -7Ch
.text$mn:00001270 var_78          = dword ptr -78h
.text$mn:00001270 var_74          = dword ptr -74h
.text$mn:00001270 var_70          = dword ptr -70h
.text$mn:00001270 var_6C          = dword ptr -6Ch
.text$mn:00001270 var_68          = dword ptr -68h
.text$mn:00001270 var_64          = dword ptr -64h
.text$mn:00001270 var_60          = dword ptr -60h
.text$mn:00001270 C               = dword ptr -5Ch
.text$mn:00001270 var_56          = byte ptr -56h
.text$mn:00001270 var_55          = byte ptr -55h
.text$mn:00001270 var_54          = byte ptr -54h
.text$mn:00001270 var_10          = dword ptr -10h
.text$mn:00001270 var_C           = dword ptr -0Ch
.text$mn:00001270 var_4           = dword ptr -4
.text$mn:00001270 arg_0           = dword ptr  8
.text$mn:00001270 arg_4           = dword ptr  0Ch
.text$mn:00001270
.text$mn:00001270                 push    ebp
.text$mn:00001271                 mov     ebp, esp
.text$mn:00001273                 push    0FFFFFFFFh
.text$mn:00001275                 push    offset __ehhandler$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.text$mn:0000127A                 mov     eax, large fs:0
.text$mn:00001280                 push    eax
.text$mn:00001281                 sub     esp, 74h
.text$mn:00001284                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001289                 xor     eax, ebp
.text$mn:0000128B                 mov     [ebp+var_10], eax
.text$mn:0000128E                 push    eax
.text$mn:0000128F                 lea     eax, [ebp+var_C]
.text$mn:00001292                 mov     large fs:0, eax
.text$mn:00001298                 mov     [ebp+var_70], ecx
.text$mn:0000129B
.text$mn:0000129B loc_129B:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *):loc_12D4j
.text$mn:0000129B                 mov     eax, [ebp+arg_0]
.text$mn:0000129E                 mov     ecx, [eax]
.text$mn:000012A0                 mov     edx, [ebp+arg_0]
.text$mn:000012A3                 add     edx, [ecx+4]
.text$mn:000012A6                 mov     ecx, edx        ; this
.text$mn:000012A8                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:000012AD                 movzx   eax, al
.text$mn:000012B0                 test    eax, eax
.text$mn:000012B2                 jz      short loc_12D6
.text$mn:000012B4                 mov     ecx, [ebp+arg_0]
.text$mn:000012B7                 call    ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::get(void)
.text$mn:000012BC                 mov     [ebp+var_6C], eax
.text$mn:000012BF                 movzx   ecx, byte ptr [ebp+var_6C]
.text$mn:000012C3                 push    ecx
.text$mn:000012C4                 mov     ecx, [ebp+arg_4]
.text$mn:000012C7                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:000012CC                 cmp     [ebp+var_6C], 3Eh ; '>'
.text$mn:000012D0                 jnz     short loc_12D4
.text$mn:000012D2                 jmp     short loc_12D6
.text$mn:000012D4 ; ---------------------------------------------------------------------------
.text$mn:000012D4
.text$mn:000012D4 loc_12D4:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+60j
.text$mn:000012D4                 jmp     short loc_129B
.text$mn:000012D6 ; ---------------------------------------------------------------------------
.text$mn:000012D6
.text$mn:000012D6 loc_12D6:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+42j
.text$mn:000012D6                                         ; TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+62j
.text$mn:000012D6                 mov     ecx, [ebp+arg_4]
.text$mn:000012D9                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:000012DE                 cmp     eax, 3
.text$mn:000012E1                 jnb     short loc_12E8
.text$mn:000012E3                 jmp     loc_1530
.text$mn:000012E8 ; ---------------------------------------------------------------------------
.text$mn:000012E8
.text$mn:000012E8 loc_12E8:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+71j
.text$mn:000012E8                 mov     ecx, [ebp+arg_4]
.text$mn:000012EB                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:000012F0                 sub     eax, 1
.text$mn:000012F3                 push    eax
.text$mn:000012F4                 mov     ecx, [ebp+arg_4]
.text$mn:000012F7                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:000012FC                 movsx   edx, byte ptr [eax]
.text$mn:000012FF                 cmp     edx, 3Eh ; '>'
.text$mn:00001302                 jnz     short loc_132A
.text$mn:00001304                 mov     ecx, [ebp+arg_4]
.text$mn:00001307                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:0000130C                 sub     eax, 2
.text$mn:0000130F                 push    eax
.text$mn:00001310                 mov     ecx, [ebp+arg_4]
.text$mn:00001313                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:00001318                 movsx   eax, byte ptr [eax]
.text$mn:0000131B                 cmp     eax, 2Fh ; '/'
.text$mn:0000131E                 jnz     short loc_132A
.text$mn:00001320                 jmp     loc_1530
.text$mn:00001325 ; ---------------------------------------------------------------------------
.text$mn:00001325                 jmp     loc_1530
.text$mn:0000132A ; ---------------------------------------------------------------------------
.text$mn:0000132A
.text$mn:0000132A loc_132A:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+92j
.text$mn:0000132A                                         ; TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+AEj
.text$mn:0000132A                 mov     ecx, [ebp+arg_4]
.text$mn:0000132D                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:00001332                 sub     eax, 1
.text$mn:00001335                 push    eax
.text$mn:00001336                 mov     ecx, [ebp+arg_4]
.text$mn:00001339                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:0000133E                 movsx   ecx, byte ptr [eax]
.text$mn:00001341                 cmp     ecx, 3Eh ; '>'
.text$mn:00001344                 jnz     loc_1530
.text$mn:0000134A
.text$mn:0000134A loc_134A:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+141j
.text$mn:0000134A                                         ; TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *):loc_152Bj
.text$mn:0000134A                 mov     edx, [ebp+arg_4]
.text$mn:0000134D                 push    edx
.text$mn:0000134E                 mov     eax, [ebp+arg_0]
.text$mn:00001351                 push    eax
.text$mn:00001352                 call    ?StreamWhiteSpace@TiXmlBaseA@@KA_NPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)
.text$mn:00001357                 add     esp, 8
.text$mn:0000135A                 mov     ecx, [ebp+arg_0]
.text$mn:0000135D                 mov     edx, [ecx]
.text$mn:0000135F                 mov     ecx, [ebp+arg_0]
.text$mn:00001362                 add     ecx, [edx+4]    ; this
.text$mn:00001365                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:0000136A                 movzx   eax, al
.text$mn:0000136D                 test    eax, eax
.text$mn:0000136F                 jz      short loc_13B3
.text$mn:00001371                 mov     ecx, [ebp+arg_0]
.text$mn:00001374                 call    ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::peek(void)
.text$mn:00001379                 cmp     eax, 3Ch ; '<'
.text$mn:0000137C                 jz      short loc_13B3
.text$mn:0000137E                 push    offset $SG94741 ; char *
.text$mn:00001383                 lea     ecx, [ebp+var_54]
.text$mn:00001386                 call    ??0TiXmlTextA@@QAE@PBD@Z ; TiXmlTextA::TiXmlTextA(char const *)
.text$mn:0000138B                 mov     [ebp+var_4], 0
.text$mn:00001392                 mov     ecx, [ebp+arg_4]
.text$mn:00001395                 push    ecx
.text$mn:00001396                 mov     edx, [ebp+arg_0]
.text$mn:00001399                 push    edx
.text$mn:0000139A                 lea     ecx, [ebp+var_54]
.text$mn:0000139D                 call    ?StreamIn@TiXmlTextA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; TiXmlTextA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)
.text$mn:000013A2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013A9                 lea     ecx, [ebp+var_54] ; this
.text$mn:000013AC                 call    ??1TiXmlTextA@@UAE@XZ ; TiXmlTextA::~TiXmlTextA(void)
.text$mn:000013B1                 jmp     short loc_134A
.text$mn:000013B3 ; ---------------------------------------------------------------------------
.text$mn:000013B3
.text$mn:000013B3 loc_13B3:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+FFj
.text$mn:000013B3                                         ; TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+10Cj
.text$mn:000013B3                 mov     eax, [ebp+arg_0]
.text$mn:000013B6                 mov     ecx, [eax]
.text$mn:000013B8                 mov     edx, [ebp+arg_0]
.text$mn:000013BB                 add     edx, [ecx+4]
.text$mn:000013BE                 mov     ecx, edx        ; this
.text$mn:000013C0                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:000013C5                 movzx   eax, al
.text$mn:000013C8                 test    eax, eax
.text$mn:000013CA                 jnz     short loc_13D1
.text$mn:000013CC                 jmp     loc_1530
.text$mn:000013D1 ; ---------------------------------------------------------------------------
.text$mn:000013D1
.text$mn:000013D1 loc_13D1:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+15Aj
.text$mn:000013D1                 mov     ecx, [ebp+arg_0]
.text$mn:000013D4                 call    ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::peek(void)
.text$mn:000013D9                 cmp     eax, 3Ch ; '<'
.text$mn:000013DC                 jz      short loc_13F5
.text$mn:000013DE                 push    281h            ; Line
.text$mn:000013E3                 push    offset $SG94744 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:000013E8                 push    offset $SG94745 ; "in->peek() == '<'"
.text$mn:000013ED                 call    __wassert
.text$mn:000013F2 ; ---------------------------------------------------------------------------
.text$mn:000013F2                 add     esp, 0Ch
.text$mn:000013F5
.text$mn:000013F5 loc_13F5:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+16Cj
.text$mn:000013F5                 mov     ecx, [ebp+arg_4]
.text$mn:000013F8                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:000013FD                 mov     [ebp+var_7C], eax
.text$mn:00001400                 mov     [ebp+var_55], 0
.text$mn:00001404                 mov     [ebp+var_56], 0
.text$mn:00001408
.text$mn:00001408 loc_1408:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *):loc_147Bj
.text$mn:00001408                 mov     edx, [ebp+arg_0]
.text$mn:0000140B                 mov     eax, [edx]
.text$mn:0000140D                 mov     ecx, [ebp+arg_0]
.text$mn:00001410                 add     ecx, [eax+4]    ; this
.text$mn:00001413                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:00001418                 movzx   ecx, al
.text$mn:0000141B                 test    ecx, ecx
.text$mn:0000141D                 jnz     short loc_1424
.text$mn:0000141F                 jmp     loc_1530
.text$mn:00001424 ; ---------------------------------------------------------------------------
.text$mn:00001424
.text$mn:00001424 loc_1424:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+1ADj
.text$mn:00001424                 mov     ecx, [ebp+arg_0]
.text$mn:00001427                 call    ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::peek(void)
.text$mn:0000142C                 mov     [ebp+C], eax
.text$mn:0000142F                 cmp     [ebp+C], 3Eh ; '>'
.text$mn:00001433                 jnz     short loc_1437
.text$mn:00001435                 jmp     short loc_147D
.text$mn:00001437 ; ---------------------------------------------------------------------------
.text$mn:00001437
.text$mn:00001437 loc_1437:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+1C3j
.text$mn:00001437                 movzx   edx, byte ptr [ebp+C]
.text$mn:0000143B                 push    edx
.text$mn:0000143C                 mov     ecx, [ebp+arg_4]
.text$mn:0000143F                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:00001444                 mov     ecx, [ebp+arg_0]
.text$mn:00001447                 call    ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::get(void)
.text$mn:0000144C                 movzx   eax, [ebp+var_56]
.text$mn:00001450                 test    eax, eax
.text$mn:00001452                 jnz     short loc_147B
.text$mn:00001454                 cmp     [ebp+C], 3Ch ; '<'
.text$mn:00001458                 jz      short loc_147B
.text$mn:0000145A                 mov     ecx, [ebp+C]
.text$mn:0000145D                 push    ecx             ; C
.text$mn:0000145E                 call    ?IsWhiteSpace@TiXmlBaseA@@KA_NH@Z ; TiXmlBaseA::IsWhiteSpace(int)
.text$mn:00001463                 add     esp, 4
.text$mn:00001466                 movzx   edx, al
.text$mn:00001469                 test    edx, edx
.text$mn:0000146B                 jnz     short loc_147B
.text$mn:0000146D                 mov     [ebp+var_56], 1
.text$mn:00001471                 cmp     [ebp+C], 2Fh ; '/'
.text$mn:00001475                 jnz     short loc_147B
.text$mn:00001477                 mov     [ebp+var_55], 1
.text$mn:0000147B
.text$mn:0000147B loc_147B:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+1E2j
.text$mn:0000147B                                         ; TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+1E8j ...
.text$mn:0000147B                 jmp     short loc_1408
.text$mn:0000147D ; ---------------------------------------------------------------------------
.text$mn:0000147D
.text$mn:0000147D loc_147D:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+1C5j
.text$mn:0000147D                 movzx   eax, [ebp+var_55]
.text$mn:00001481                 test    eax, eax
.text$mn:00001483                 jz      short loc_14BE
.text$mn:00001485                 mov     ecx, [ebp+arg_0]
.text$mn:00001488                 call    ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::get(void)
.text$mn:0000148D                 mov     [ebp+var_68], eax
.text$mn:00001490                 cmp     [ebp+var_68], 3Eh ; '>'
.text$mn:00001494                 jz      short loc_14AD
.text$mn:00001496                 push    2A0h            ; Line
.text$mn:0000149B                 push    offset $SG94761 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:000014A0                 push    offset $SG94762 ; "c == '>'"
.text$mn:000014A5                 call    __wassert
.text$mn:000014AA ; ---------------------------------------------------------------------------
.text$mn:000014AA                 add     esp, 0Ch
.text$mn:000014AD
.text$mn:000014AD loc_14AD:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+224j
.text$mn:000014AD                 movzx   edx, byte ptr [ebp+var_68]
.text$mn:000014B1                 push    edx
.text$mn:000014B2                 mov     ecx, [ebp+arg_4]
.text$mn:000014B5                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:000014BA                 jmp     short loc_1530
.text$mn:000014BC ; ---------------------------------------------------------------------------
.text$mn:000014BC                 jmp     short loc_152B
.text$mn:000014BE ; ---------------------------------------------------------------------------
.text$mn:000014BE
.text$mn:000014BE loc_14BE:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+213j
.text$mn:000014BE                 mov     ecx, [ebp+arg_4]
.text$mn:000014C1                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:000014C6                 add     eax, [ebp+var_7C]
.text$mn:000014C9                 mov     [ebp+var_80], eax
.text$mn:000014CC                 mov     eax, [ebp+var_80]
.text$mn:000014CF                 push    eax             ; char *
.text$mn:000014D0                 mov     ecx, [ebp+var_70] ; this
.text$mn:000014D3                 call    ?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z ; TiXmlNodeA::Identify(char const *)
.text$mn:000014D8                 mov     [ebp+var_60], eax
.text$mn:000014DB                 cmp     [ebp+var_60], 0
.text$mn:000014DF                 jnz     short loc_14E3
.text$mn:000014E1                 jmp     short loc_1530
.text$mn:000014E3 ; ---------------------------------------------------------------------------
.text$mn:000014E3
.text$mn:000014E3 loc_14E3:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+26Fj
.text$mn:000014E3                 mov     ecx, [ebp+arg_4]
.text$mn:000014E6                 push    ecx
.text$mn:000014E7                 mov     edx, [ebp+arg_0]
.text$mn:000014EA                 push    edx
.text$mn:000014EB                 mov     eax, [ebp+var_60]
.text$mn:000014EE                 mov     edx, [eax]
.text$mn:000014F0                 mov     ecx, [ebp+var_60]
.text$mn:000014F3                 mov     eax, [edx+18h]
.text$mn:000014F6                 call    eax
.text$mn:000014F8                 mov     ecx, [ebp+var_60]
.text$mn:000014FB                 mov     [ebp+var_74], ecx
.text$mn:000014FE                 mov     edx, [ebp+var_74]
.text$mn:00001501                 mov     [ebp+var_64], edx
.text$mn:00001504                 cmp     [ebp+var_64], 0
.text$mn:00001508                 jz      short loc_151D
.text$mn:0000150A                 push    1
.text$mn:0000150C                 mov     eax, [ebp+var_64]
.text$mn:0000150F                 mov     edx, [eax]
.text$mn:00001511                 mov     ecx, [ebp+var_64]
.text$mn:00001514                 mov     eax, [edx]
.text$mn:00001516                 call    eax
.text$mn:00001518                 mov     [ebp+var_78], eax
.text$mn:0000151B                 jmp     short loc_1524
.text$mn:0000151D ; ---------------------------------------------------------------------------
.text$mn:0000151D
.text$mn:0000151D loc_151D:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+298j
.text$mn:0000151D                 mov     [ebp+var_78], 0
.text$mn:00001524
.text$mn:00001524 loc_1524:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+2ABj
.text$mn:00001524                 mov     [ebp+var_60], 0
.text$mn:0000152B
.text$mn:0000152B loc_152B:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+24Cj
.text$mn:0000152B                 jmp     loc_134A
.text$mn:00001530 ; ---------------------------------------------------------------------------
.text$mn:00001530
.text$mn:00001530 loc_1530:                               ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+73j
.text$mn:00001530                                         ; TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+B0j ...
.text$mn:00001530                 mov     ecx, [ebp+var_C]
.text$mn:00001533                 mov     large fs:0, ecx
.text$mn:0000153A                 pop     ecx
.text$mn:0000153B                 mov     ecx, [ebp+var_10]
.text$mn:0000153E                 xor     ecx, ebp
.text$mn:00001540                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001545                 mov     esp, ebp
.text$mn:00001547                 pop     ebp
.text$mn:00001548                 retn    8
.text$mn:00001548 ?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z endp
.text$mn:00001548
.text$mn:00001548 ; ---------------------------------------------------------------------------
.text$mn:0000154B                 align 10h
.text$mn:00001550
.text$mn:00001550 ; =============== S U B R O U T I N E =======================================
.text$mn:00001550
.text$mn:00001550 ; Attributes: bp-based frame
.text$mn:00001550
.text$mn:00001550 ; const char *__thiscall TiXmlElementA::Parse(TiXmlElementA *this, const char *, struct TiXmlParsingDataA *)
.text$mn:00001550                 public ?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:00001550 ?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$mn:00001550
.text$mn:00001550 var_90          = dword ptr -90h
.text$mn:00001550 var_8C          = dword ptr -8Ch
.text$mn:00001550 var_88          = dword ptr -88h
.text$mn:00001550 var_84          = dword ptr -84h
.text$mn:00001550 var_80          = dword ptr -80h
.text$mn:00001550 var_7C          = dword ptr -7Ch
.text$mn:00001550 var_78          = dword ptr -78h
.text$mn:00001550 var_74          = dword ptr -74h
.text$mn:00001550 var_70          = dword ptr -70h
.text$mn:00001550 var_6C          = dword ptr -6Ch
.text$mn:00001550 var_68          = dword ptr -68h
.text$mn:00001550 var_64          = dword ptr -64h
.text$mn:00001550 var_60          = dword ptr -60h
.text$mn:00001550 var_5C          = dword ptr -5Ch
.text$mn:00001550 var_58          = dword ptr -58h
.text$mn:00001550 var_54          = dword ptr -54h
.text$mn:00001550 var_50          = dword ptr -50h
.text$mn:00001550 var_4C          = dword ptr -4Ch
.text$mn:00001550 var_48          = dword ptr -48h
.text$mn:00001550 var_44          = dword ptr -44h
.text$mn:00001550 var_40          = dword ptr -40h
.text$mn:00001550 var_3C          = dword ptr -3Ch
.text$mn:00001550 var_38          = dword ptr -38h
.text$mn:00001550 var_34          = dword ptr -34h
.text$mn:00001550 var_30          = dword ptr -30h
.text$mn:00001550 var_2C          = byte ptr -2Ch
.text$mn:00001550 var_10          = dword ptr -10h
.text$mn:00001550 var_C           = dword ptr -0Ch
.text$mn:00001550 var_4           = dword ptr -4
.text$mn:00001550 arg_0           = dword ptr  8
.text$mn:00001550 arg_4           = dword ptr  0Ch
.text$mn:00001550
.text$mn:00001550                 push    ebp
.text$mn:00001551                 mov     ebp, esp
.text$mn:00001553                 push    0FFFFFFFFh
.text$mn:00001555                 push    offset __ehhandler$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:0000155A                 mov     eax, large fs:0
.text$mn:00001560                 push    eax
.text$mn:00001561                 sub     esp, 84h
.text$mn:00001567                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000156C                 xor     eax, ebp
.text$mn:0000156E                 mov     [ebp+var_10], eax
.text$mn:00001571                 push    eax
.text$mn:00001572                 lea     eax, [ebp+var_C]
.text$mn:00001575                 mov     large fs:0, eax
.text$mn:0000157B                 mov     [ebp+var_38], ecx
.text$mn:0000157E                 mov     eax, [ebp+arg_0]
.text$mn:00001581                 push    eax             ; char *
.text$mn:00001582                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00001587                 add     esp, 4
.text$mn:0000158A                 mov     [ebp+arg_0], eax
.text$mn:0000158D                 mov     ecx, [ebp+var_38] ; this
.text$mn:00001590                 call    ?GetDocument@TiXmlNodeA@@QBEPAVTiXmlDocumentA@@XZ ; TiXmlNodeA::GetDocument(void)
.text$mn:00001595                 mov     [ebp+var_30], eax
.text$mn:00001598                 cmp     [ebp+arg_0], 0
.text$mn:0000159C                 jz      short loc_15A8
.text$mn:0000159E                 mov     ecx, [ebp+arg_0]
.text$mn:000015A1                 movsx   edx, byte ptr [ecx]
.text$mn:000015A4                 test    edx, edx
.text$mn:000015A6                 jnz     short loc_15C3
.text$mn:000015A8
.text$mn:000015A8 loc_15A8:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+4Cj
.text$mn:000015A8                 cmp     [ebp+var_30], 0
.text$mn:000015AC                 jz      short loc_15BC
.text$mn:000015AE                 push    0               ; struct TiXmlParsingDataA *
.text$mn:000015B0                 push    0               ; char *
.text$mn:000015B2                 push    4               ; int
.text$mn:000015B4                 mov     ecx, [ebp+var_30] ; this
.text$mn:000015B7                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:000015BC
.text$mn:000015BC loc_15BC:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+5Cj
.text$mn:000015BC                 xor     eax, eax
.text$mn:000015BE                 jmp     loc_1A3A
.text$mn:000015C3 ; ---------------------------------------------------------------------------
.text$mn:000015C3
.text$mn:000015C3 loc_15C3:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+56j
.text$mn:000015C3                 cmp     [ebp+arg_4], 0
.text$mn:000015C7                 jz      short loc_15EB
.text$mn:000015C9                 mov     eax, [ebp+arg_0]
.text$mn:000015CC                 push    eax             ; char *
.text$mn:000015CD                 mov     ecx, [ebp+arg_4] ; this
.text$mn:000015D0                 call    ?Stamp@TiXmlParsingDataA@@QAEXPBD@Z ; TiXmlParsingDataA::Stamp(char const *)
.text$mn:000015D5                 mov     ecx, [ebp+arg_4] ; this
.text$mn:000015D8                 call    ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ ; TiXmlParsingDataA::Cursor(void)
.text$mn:000015DD                 mov     ecx, [eax]
.text$mn:000015DF                 mov     edx, [eax+4]
.text$mn:000015E2                 mov     eax, [ebp+var_38]
.text$mn:000015E5                 mov     [eax+4], ecx
.text$mn:000015E8                 mov     [eax+8], edx
.text$mn:000015EB
.text$mn:000015EB loc_15EB:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+77j
.text$mn:000015EB                 mov     ecx, [ebp+arg_0]
.text$mn:000015EE                 movsx   edx, byte ptr [ecx]
.text$mn:000015F1                 cmp     edx, 3Ch ; '<'
.text$mn:000015F4                 jz      short loc_1615
.text$mn:000015F6                 cmp     [ebp+var_30], 0
.text$mn:000015FA                 jz      short loc_160E
.text$mn:000015FC                 mov     eax, [ebp+arg_4]
.text$mn:000015FF                 push    eax             ; struct TiXmlParsingDataA *
.text$mn:00001600                 mov     ecx, [ebp+arg_0]
.text$mn:00001603                 push    ecx             ; char *
.text$mn:00001604                 push    4               ; int
.text$mn:00001606                 mov     ecx, [ebp+var_30] ; this
.text$mn:00001609                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:0000160E
.text$mn:0000160E loc_160E:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+AAj
.text$mn:0000160E                 xor     eax, eax
.text$mn:00001610                 jmp     loc_1A3A
.text$mn:00001615 ; ---------------------------------------------------------------------------
.text$mn:00001615
.text$mn:00001615 loc_1615:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+A4j
.text$mn:00001615                 mov     edx, [ebp+arg_0]
.text$mn:00001618                 add     edx, 1
.text$mn:0000161B                 push    edx             ; char *
.text$mn:0000161C                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00001621                 add     esp, 4
.text$mn:00001624                 mov     [ebp+arg_0], eax
.text$mn:00001627                 mov     eax, [ebp+arg_0]
.text$mn:0000162A                 mov     [ebp+var_3C], eax
.text$mn:0000162D                 mov     ecx, [ebp+var_38]
.text$mn:00001630                 add     ecx, 1Ch
.text$mn:00001633                 push    ecx
.text$mn:00001634                 mov     edx, [ebp+arg_0]
.text$mn:00001637                 push    edx
.text$mn:00001638                 call    ?ReadName@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)
.text$mn:0000163D                 add     esp, 8
.text$mn:00001640                 mov     [ebp+arg_0], eax
.text$mn:00001643                 cmp     [ebp+arg_0], 0
.text$mn:00001647                 jz      short loc_1653
.text$mn:00001649                 mov     eax, [ebp+arg_0]
.text$mn:0000164C                 movsx   ecx, byte ptr [eax]
.text$mn:0000164F                 test    ecx, ecx
.text$mn:00001651                 jnz     short loc_1672
.text$mn:00001653
.text$mn:00001653 loc_1653:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+F7j
.text$mn:00001653                 cmp     [ebp+var_30], 0
.text$mn:00001657                 jz      short loc_166B
.text$mn:00001659                 mov     edx, [ebp+arg_4]
.text$mn:0000165C                 push    edx             ; struct TiXmlParsingDataA *
.text$mn:0000165D                 mov     eax, [ebp+var_3C]
.text$mn:00001660                 push    eax             ; char *
.text$mn:00001661                 push    5               ; int
.text$mn:00001663                 mov     ecx, [ebp+var_30] ; this
.text$mn:00001666                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:0000166B
.text$mn:0000166B loc_166B:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+107j
.text$mn:0000166B                 xor     eax, eax
.text$mn:0000166D                 jmp     loc_1A3A
.text$mn:00001672 ; ---------------------------------------------------------------------------
.text$mn:00001672
.text$mn:00001672 loc_1672:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+101j
.text$mn:00001672                 push    offset $SG94787 ; Str
.text$mn:00001677                 lea     ecx, [ebp+var_2C]
.text$mn:0000167A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000167F                 mov     [ebp+var_4], 0
.text$mn:00001686                 mov     ecx, [ebp+var_38]
.text$mn:00001689                 add     ecx, 1Ch
.text$mn:0000168C                 push    ecx
.text$mn:0000168D                 lea     ecx, [ebp+var_2C]
.text$mn:00001690                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
.text$mn:00001695                 push    offset $SG94788 ; Str
.text$mn:0000169A                 lea     ecx, [ebp+var_2C]
.text$mn:0000169D                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char const *)
.text$mn:000016A2
.text$mn:000016A2 loc_16A2:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *):loc_1A17j
.text$mn:000016A2                 cmp     [ebp+arg_0], 0
.text$mn:000016A6                 jz      loc_1A1C
.text$mn:000016AC                 mov     edx, [ebp+arg_0]
.text$mn:000016AF                 movsx   eax, byte ptr [edx]
.text$mn:000016B2                 test    eax, eax
.text$mn:000016B4                 jz      loc_1A1C
.text$mn:000016BA                 mov     ecx, [ebp+arg_0]
.text$mn:000016BD                 mov     [ebp+var_3C], ecx
.text$mn:000016C0                 mov     edx, [ebp+arg_0]
.text$mn:000016C3                 push    edx             ; char *
.text$mn:000016C4                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:000016C9                 add     esp, 4
.text$mn:000016CC                 mov     [ebp+arg_0], eax
.text$mn:000016CF                 cmp     [ebp+arg_0], 0
.text$mn:000016D3                 jz      short loc_16DF
.text$mn:000016D5                 mov     eax, [ebp+arg_0]
.text$mn:000016D8                 movsx   ecx, byte ptr [eax]
.text$mn:000016DB                 test    ecx, ecx
.text$mn:000016DD                 jnz     short loc_171B
.text$mn:000016DF
.text$mn:000016DF loc_16DF:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+183j
.text$mn:000016DF                 cmp     [ebp+var_30], 0
.text$mn:000016E3                 jz      short loc_16F7
.text$mn:000016E5                 mov     edx, [ebp+arg_4]
.text$mn:000016E8                 push    edx             ; struct TiXmlParsingDataA *
.text$mn:000016E9                 mov     eax, [ebp+var_3C]
.text$mn:000016EC                 push    eax             ; char *
.text$mn:000016ED                 push    7               ; int
.text$mn:000016EF                 mov     ecx, [ebp+var_30] ; this
.text$mn:000016F2                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:000016F7
.text$mn:000016F7 loc_16F7:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+193j
.text$mn:000016F7                 mov     [ebp+var_84], 0
.text$mn:00001701                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001708                 lea     ecx, [ebp+var_2C]
.text$mn:0000170B                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00001710                 mov     eax, [ebp+var_84]
.text$mn:00001716                 jmp     loc_1A3A
.text$mn:0000171B ; ---------------------------------------------------------------------------
.text$mn:0000171B
.text$mn:0000171B loc_171B:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+18Dj
.text$mn:0000171B                 mov     ecx, [ebp+arg_0]
.text$mn:0000171E                 movsx   edx, byte ptr [ecx]
.text$mn:00001721                 cmp     edx, 2Fh ; '/'
.text$mn:00001724                 jnz     short loc_179B
.text$mn:00001726                 mov     eax, [ebp+arg_0]
.text$mn:00001729                 add     eax, 1
.text$mn:0000172C                 mov     [ebp+arg_0], eax
.text$mn:0000172F                 mov     ecx, [ebp+arg_0]
.text$mn:00001732                 movsx   edx, byte ptr [ecx]
.text$mn:00001735                 cmp     edx, 3Eh ; '>'
.text$mn:00001738                 jz      short loc_1776
.text$mn:0000173A                 cmp     [ebp+var_30], 0
.text$mn:0000173E                 jz      short loc_1752
.text$mn:00001740                 mov     eax, [ebp+arg_4]
.text$mn:00001743                 push    eax             ; struct TiXmlParsingDataA *
.text$mn:00001744                 mov     ecx, [ebp+arg_0]
.text$mn:00001747                 push    ecx             ; char *
.text$mn:00001748                 push    8               ; int
.text$mn:0000174A                 mov     ecx, [ebp+var_30] ; this
.text$mn:0000174D                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:00001752
.text$mn:00001752 loc_1752:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+1EEj
.text$mn:00001752                 mov     [ebp+var_90], 0
.text$mn:0000175C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001763                 lea     ecx, [ebp+var_2C]
.text$mn:00001766                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:0000176B                 mov     eax, [ebp+var_90]
.text$mn:00001771                 jmp     loc_1A3A
.text$mn:00001776 ; ---------------------------------------------------------------------------
.text$mn:00001776
.text$mn:00001776 loc_1776:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+1E8j
.text$mn:00001776                 mov     edx, [ebp+arg_0]
.text$mn:00001779                 add     edx, 1
.text$mn:0000177C                 mov     [ebp+var_5C], edx
.text$mn:0000177F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001786                 lea     ecx, [ebp+var_2C]
.text$mn:00001789                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:0000178E                 mov     eax, [ebp+var_5C]
.text$mn:00001791                 jmp     loc_1A3A
.text$mn:00001796 ; ---------------------------------------------------------------------------
.text$mn:00001796                 jmp     loc_1A17
.text$mn:0000179B ; ---------------------------------------------------------------------------
.text$mn:0000179B
.text$mn:0000179B loc_179B:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+1D4j
.text$mn:0000179B                 mov     eax, [ebp+arg_0]
.text$mn:0000179E                 movsx   ecx, byte ptr [eax]
.text$mn:000017A1                 cmp     ecx, 3Eh ; '>'
.text$mn:000017A4                 jnz     loc_187A
.text$mn:000017AA                 mov     edx, [ebp+arg_0]
.text$mn:000017AD                 add     edx, 1
.text$mn:000017B0                 mov     [ebp+arg_0], edx
.text$mn:000017B3                 mov     eax, [ebp+arg_4]
.text$mn:000017B6                 push    eax             ; struct TiXmlParsingDataA *
.text$mn:000017B7                 mov     ecx, [ebp+arg_0]
.text$mn:000017BA                 push    ecx             ; char *
.text$mn:000017BB                 mov     ecx, [ebp+var_38] ; this
.text$mn:000017BE                 call    ?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z ; TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)
.text$mn:000017C3                 mov     [ebp+arg_0], eax
.text$mn:000017C6                 cmp     [ebp+arg_0], 0
.text$mn:000017CA                 jz      short loc_17D6
.text$mn:000017CC                 mov     edx, [ebp+arg_0]
.text$mn:000017CF                 movsx   eax, byte ptr [edx]
.text$mn:000017D2                 test    eax, eax
.text$mn:000017D4                 jnz     short loc_17F4
.text$mn:000017D6
.text$mn:000017D6 loc_17D6:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+27Aj
.text$mn:000017D6                 mov     [ebp+var_54], 0
.text$mn:000017DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000017E4                 lea     ecx, [ebp+var_2C]
.text$mn:000017E7                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000017EC                 mov     eax, [ebp+var_54]
.text$mn:000017EF                 jmp     loc_1A3A
.text$mn:000017F4 ; ---------------------------------------------------------------------------
.text$mn:000017F4
.text$mn:000017F4 loc_17F4:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+284j
.text$mn:000017F4                 push    0               ; bool
.text$mn:000017F6                 lea     ecx, [ebp+var_2C]
.text$mn:000017F9                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:000017FE                 push    eax             ; char *
.text$mn:000017FF                 mov     ecx, [ebp+arg_0]
.text$mn:00001802                 push    ecx             ; char *
.text$mn:00001803                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:00001808                 add     esp, 0Ch
.text$mn:0000180B                 movzx   edx, al
.text$mn:0000180E                 test    edx, edx
.text$mn:00001810                 jz      short loc_183F
.text$mn:00001812                 lea     ecx, [ebp+var_2C]
.text$mn:00001815                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:0000181A                 add     eax, [ebp+arg_0]
.text$mn:0000181D                 mov     [ebp+arg_0], eax
.text$mn:00001820                 mov     eax, [ebp+arg_0]
.text$mn:00001823                 mov     [ebp+var_64], eax
.text$mn:00001826                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000182D                 lea     ecx, [ebp+var_2C]
.text$mn:00001830                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00001835                 mov     eax, [ebp+var_64]
.text$mn:00001838                 jmp     loc_1A3A
.text$mn:0000183D ; ---------------------------------------------------------------------------
.text$mn:0000183D                 jmp     short loc_1875
.text$mn:0000183F ; ---------------------------------------------------------------------------
.text$mn:0000183F
.text$mn:0000183F loc_183F:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+2C0j
.text$mn:0000183F                 cmp     [ebp+var_30], 0
.text$mn:00001843                 jz      short loc_1857
.text$mn:00001845                 mov     ecx, [ebp+arg_4]
.text$mn:00001848                 push    ecx             ; struct TiXmlParsingDataA *
.text$mn:00001849                 mov     edx, [ebp+arg_0]
.text$mn:0000184C                 push    edx             ; char *
.text$mn:0000184D                 push    9               ; int
.text$mn:0000184F                 mov     ecx, [ebp+var_30] ; this
.text$mn:00001852                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:00001857
.text$mn:00001857 loc_1857:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+2F3j
.text$mn:00001857                 mov     [ebp+var_7C], 0
.text$mn:0000185E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001865                 lea     ecx, [ebp+var_2C]
.text$mn:00001868                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:0000186D                 mov     eax, [ebp+var_7C]
.text$mn:00001870                 jmp     loc_1A3A
.text$mn:00001875 ; ---------------------------------------------------------------------------
.text$mn:00001875
.text$mn:00001875 loc_1875:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+2EDj
.text$mn:00001875                 jmp     loc_1A17
.text$mn:0000187A ; ---------------------------------------------------------------------------
.text$mn:0000187A
.text$mn:0000187A loc_187A:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+254j
.text$mn:0000187A                 push    50h ; 'P'       ; unsigned int
.text$mn:0000187C                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001881                 add     esp, 4
.text$mn:00001884                 mov     [ebp+var_50], eax
.text$mn:00001887                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000188B                 cmp     [ebp+var_50], 0
.text$mn:0000188F                 jz      short loc_189E
.text$mn:00001891                 mov     ecx, [ebp+var_50]
.text$mn:00001894                 call    ??0TiXmlAttributeA@@QAE@XZ ; TiXmlAttributeA::TiXmlAttributeA(void)
.text$mn:00001899                 mov     [ebp+var_48], eax
.text$mn:0000189C                 jmp     short loc_18A5
.text$mn:0000189E ; ---------------------------------------------------------------------------
.text$mn:0000189E
.text$mn:0000189E loc_189E:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+33Fj
.text$mn:0000189E                 mov     [ebp+var_48], 0
.text$mn:000018A5
.text$mn:000018A5 loc_18A5:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+34Cj
.text$mn:000018A5                 mov     eax, [ebp+var_48]
.text$mn:000018A8                 mov     [ebp+var_6C], eax
.text$mn:000018AB                 mov     byte ptr [ebp+var_4], 0
.text$mn:000018AF                 mov     ecx, [ebp+var_6C]
.text$mn:000018B2                 mov     [ebp+var_34], ecx
.text$mn:000018B5                 cmp     [ebp+var_34], 0
.text$mn:000018B9                 jnz     short loc_18F7
.text$mn:000018BB                 cmp     [ebp+var_30], 0
.text$mn:000018BF                 jz      short loc_18D3
.text$mn:000018C1                 mov     edx, [ebp+arg_4]
.text$mn:000018C4                 push    edx             ; struct TiXmlParsingDataA *
.text$mn:000018C5                 mov     eax, [ebp+var_3C]
.text$mn:000018C8                 push    eax             ; char *
.text$mn:000018C9                 push    3               ; int
.text$mn:000018CB                 mov     ecx, [ebp+var_30] ; this
.text$mn:000018CE                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:000018D3
.text$mn:000018D3 loc_18D3:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+36Fj
.text$mn:000018D3                 mov     [ebp+var_8C], 0
.text$mn:000018DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000018E4                 lea     ecx, [ebp+var_2C]
.text$mn:000018E7                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000018EC                 mov     eax, [ebp+var_8C]
.text$mn:000018F2                 jmp     loc_1A3A
.text$mn:000018F7 ; ---------------------------------------------------------------------------
.text$mn:000018F7
.text$mn:000018F7 loc_18F7:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+369j
.text$mn:000018F7                 mov     ecx, [ebp+var_30]
.text$mn:000018FA                 push    ecx             ; struct TiXmlDocumentA *
.text$mn:000018FB                 mov     ecx, [ebp+var_34] ; this
.text$mn:000018FE                 call    ?SetDocument@TiXmlAttributeA@@QAEXPAVTiXmlDocumentA@@@Z ; TiXmlAttributeA::SetDocument(TiXmlDocumentA *)
.text$mn:00001903                 mov     edx, [ebp+arg_0]
.text$mn:00001906                 mov     [ebp+var_74], edx
.text$mn:00001909                 mov     eax, [ebp+arg_4]
.text$mn:0000190C                 push    eax
.text$mn:0000190D                 mov     ecx, [ebp+arg_0]
.text$mn:00001910                 push    ecx
.text$mn:00001911                 mov     edx, [ebp+var_34]
.text$mn:00001914                 mov     eax, [edx]
.text$mn:00001916                 mov     ecx, [ebp+var_34]
.text$mn:00001919                 mov     edx, [eax+0Ch]
.text$mn:0000191C                 call    edx
.text$mn:0000191E                 mov     [ebp+arg_0], eax
.text$mn:00001921                 cmp     [ebp+arg_0], 0
.text$mn:00001925                 jz      short loc_1931
.text$mn:00001927                 mov     eax, [ebp+arg_0]
.text$mn:0000192A                 movsx   ecx, byte ptr [eax]
.text$mn:0000192D                 test    ecx, ecx
.text$mn:0000192F                 jnz     short loc_1993
.text$mn:00001931
.text$mn:00001931 loc_1931:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+3D5j
.text$mn:00001931                 cmp     [ebp+var_30], 0
.text$mn:00001935                 jz      short loc_1949
.text$mn:00001937                 mov     edx, [ebp+arg_4]
.text$mn:0000193A                 push    edx             ; struct TiXmlParsingDataA *
.text$mn:0000193B                 mov     eax, [ebp+var_74]
.text$mn:0000193E                 push    eax             ; char *
.text$mn:0000193F                 push    4               ; int
.text$mn:00001941                 mov     ecx, [ebp+var_30] ; this
.text$mn:00001944                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:00001949
.text$mn:00001949 loc_1949:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+3E5j
.text$mn:00001949                 mov     ecx, [ebp+var_34]
.text$mn:0000194C                 mov     [ebp+var_58], ecx
.text$mn:0000194F                 mov     edx, [ebp+var_58]
.text$mn:00001952                 mov     [ebp+var_40], edx
.text$mn:00001955                 cmp     [ebp+var_40], 0
.text$mn:00001959                 jz      short loc_196E
.text$mn:0000195B                 push    1
.text$mn:0000195D                 mov     eax, [ebp+var_40]
.text$mn:00001960                 mov     edx, [eax]
.text$mn:00001962                 mov     ecx, [ebp+var_40]
.text$mn:00001965                 mov     eax, [edx]
.text$mn:00001967                 call    eax
.text$mn:00001969                 mov     [ebp+var_60], eax
.text$mn:0000196C                 jmp     short loc_1975
.text$mn:0000196E ; ---------------------------------------------------------------------------
.text$mn:0000196E
.text$mn:0000196E loc_196E:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+409j
.text$mn:0000196E                 mov     [ebp+var_60], 0
.text$mn:00001975
.text$mn:00001975 loc_1975:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+41Cj
.text$mn:00001975                 mov     [ebp+var_68], 0
.text$mn:0000197C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001983                 lea     ecx, [ebp+var_2C]
.text$mn:00001986                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:0000198B                 mov     eax, [ebp+var_68]
.text$mn:0000198E                 jmp     loc_1A3A
.text$mn:00001993 ; ---------------------------------------------------------------------------
.text$mn:00001993
.text$mn:00001993 loc_1993:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+3DFj
.text$mn:00001993                 mov     ecx, [ebp+var_34] ; this
.text$mn:00001996                 call    ?Name@TiXmlAttributeA@@QBEPBDXZ ; TiXmlAttributeA::Name(void)
.text$mn:0000199B                 push    eax             ; char *
.text$mn:0000199C                 mov     ecx, [ebp+var_38]
.text$mn:0000199F                 add     ecx, 44h ; 'D'  ; this
.text$mn:000019A2                 call    ?Find@TiXmlAttributeSetA@@QBEPAVTiXmlAttributeA@@PBD@Z ; TiXmlAttributeSetA::Find(char const *)
.text$mn:000019A7                 mov     [ebp+var_4C], eax
.text$mn:000019AA                 cmp     [ebp+var_4C], 0
.text$mn:000019AE                 jz      short loc_1A08
.text$mn:000019B0                 mov     ecx, [ebp+var_34] ; this
.text$mn:000019B3                 call    ?Value@TiXmlAttributeA@@QBEPBDXZ ; TiXmlAttributeA::Value(void)
.text$mn:000019B8                 push    eax             ; char *
.text$mn:000019B9                 mov     ecx, [ebp+var_4C] ; this
.text$mn:000019BC                 call    ?SetValue@TiXmlAttributeA@@QAEXPBD@Z ; TiXmlAttributeA::SetValue(char const *)
.text$mn:000019C1                 mov     ecx, [ebp+var_34]
.text$mn:000019C4                 mov     [ebp+var_70], ecx
.text$mn:000019C7                 mov     edx, [ebp+var_70]
.text$mn:000019CA                 mov     [ebp+var_44], edx
.text$mn:000019CD                 cmp     [ebp+var_44], 0
.text$mn:000019D1                 jz      short loc_19E6
.text$mn:000019D3                 push    1
.text$mn:000019D5                 mov     eax, [ebp+var_44]
.text$mn:000019D8                 mov     edx, [eax]
.text$mn:000019DA                 mov     ecx, [ebp+var_44]
.text$mn:000019DD                 mov     eax, [edx]
.text$mn:000019DF                 call    eax
.text$mn:000019E1                 mov     [ebp+var_78], eax
.text$mn:000019E4                 jmp     short loc_19ED
.text$mn:000019E6 ; ---------------------------------------------------------------------------
.text$mn:000019E6
.text$mn:000019E6 loc_19E6:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+481j
.text$mn:000019E6                 mov     [ebp+var_78], 0
.text$mn:000019ED
.text$mn:000019ED loc_19ED:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+494j
.text$mn:000019ED                 mov     [ebp+var_80], 0
.text$mn:000019F4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019FB                 lea     ecx, [ebp+var_2C]
.text$mn:000019FE                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00001A03                 mov     eax, [ebp+var_80]
.text$mn:00001A06                 jmp     short loc_1A3A
.text$mn:00001A08 ; ---------------------------------------------------------------------------
.text$mn:00001A08
.text$mn:00001A08 loc_1A08:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+45Ej
.text$mn:00001A08                 mov     ecx, [ebp+var_34]
.text$mn:00001A0B                 push    ecx             ; struct TiXmlAttributeA *
.text$mn:00001A0C                 mov     ecx, [ebp+var_38]
.text$mn:00001A0F                 add     ecx, 44h ; 'D'  ; this
.text$mn:00001A12                 call    ?Add@TiXmlAttributeSetA@@QAEXPAVTiXmlAttributeA@@@Z ; TiXmlAttributeSetA::Add(TiXmlAttributeA *)
.text$mn:00001A17
.text$mn:00001A17 loc_1A17:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+246j
.text$mn:00001A17                                         ; TiXmlElementA::Parse(char const *,TiXmlParsingDataA *):loc_1875j
.text$mn:00001A17                 jmp     loc_16A2
.text$mn:00001A1C ; ---------------------------------------------------------------------------
.text$mn:00001A1C
.text$mn:00001A1C loc_1A1C:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+156j
.text$mn:00001A1C                                         ; TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+164j
.text$mn:00001A1C                 mov     edx, [ebp+arg_0]
.text$mn:00001A1F                 mov     [ebp+var_88], edx
.text$mn:00001A25                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A2C                 lea     ecx, [ebp+var_2C]
.text$mn:00001A2F                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00001A34                 mov     eax, [ebp+var_88]
.text$mn:00001A3A
.text$mn:00001A3A loc_1A3A:                               ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+6Ej
.text$mn:00001A3A                                         ; TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+C0j ...
.text$mn:00001A3A                 mov     ecx, [ebp+var_C]
.text$mn:00001A3D                 mov     large fs:0, ecx
.text$mn:00001A44                 pop     ecx
.text$mn:00001A45                 mov     ecx, [ebp+var_10]
.text$mn:00001A48                 xor     ecx, ebp
.text$mn:00001A4A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001A4F                 mov     esp, ebp
.text$mn:00001A51                 pop     ebp
.text$mn:00001A52                 retn    8
.text$mn:00001A52 ?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$mn:00001A52
.text$mn:00001A52 ; ---------------------------------------------------------------------------
.text$mn:00001A55                 align 10h
.text$mn:00001A60
.text$mn:00001A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A60
.text$mn:00001A60 ; Attributes: bp-based frame
.text$mn:00001A60
.text$mn:00001A60 ; const char *__thiscall TiXmlElementA::ReadValue(TiXmlElementA *this, const char *, struct TiXmlParsingDataA *)
.text$mn:00001A60                 public ?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:00001A60 ?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$mn:00001A60                                         ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+26Ep
.text$mn:00001A60
.text$mn:00001A60 var_34          = dword ptr -34h
.text$mn:00001A60 var_30          = dword ptr -30h
.text$mn:00001A60 var_2C          = dword ptr -2Ch
.text$mn:00001A60 var_28          = dword ptr -28h
.text$mn:00001A60 var_24          = dword ptr -24h
.text$mn:00001A60 var_20          = dword ptr -20h
.text$mn:00001A60 var_1C          = dword ptr -1Ch
.text$mn:00001A60 var_18          = dword ptr -18h
.text$mn:00001A60 var_14          = dword ptr -14h
.text$mn:00001A60 var_10          = dword ptr -10h
.text$mn:00001A60 var_C           = dword ptr -0Ch
.text$mn:00001A60 var_4           = dword ptr -4
.text$mn:00001A60 arg_0           = dword ptr  8
.text$mn:00001A60 arg_4           = dword ptr  0Ch
.text$mn:00001A60
.text$mn:00001A60                 push    ebp
.text$mn:00001A61                 mov     ebp, esp
.text$mn:00001A63                 push    0FFFFFFFFh
.text$mn:00001A65                 push    offset __ehhandler$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:00001A6A                 mov     eax, large fs:0
.text$mn:00001A70                 push    eax
.text$mn:00001A71                 sub     esp, 28h
.text$mn:00001A74                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A79                 xor     eax, ebp
.text$mn:00001A7B                 push    eax
.text$mn:00001A7C                 lea     eax, [ebp+var_C]
.text$mn:00001A7F                 mov     large fs:0, eax
.text$mn:00001A85                 mov     [ebp+var_18], ecx
.text$mn:00001A88                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001A8B                 call    ?GetDocument@TiXmlNodeA@@QBEPAVTiXmlDocumentA@@XZ ; TiXmlNodeA::GetDocument(void)
.text$mn:00001A90                 mov     [ebp+var_1C], eax
.text$mn:00001A93                 mov     eax, [ebp+arg_0]
.text$mn:00001A96                 push    eax             ; char *
.text$mn:00001A97                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00001A9C                 add     esp, 4
.text$mn:00001A9F                 mov     [ebp+arg_0], eax
.text$mn:00001AA2
.text$mn:00001AA2 loc_1AA2:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+1A2j
.text$mn:00001AA2                 cmp     [ebp+arg_0], 0
.text$mn:00001AA6                 jz      loc_1C07
.text$mn:00001AAC                 mov     ecx, [ebp+arg_0]
.text$mn:00001AAF                 movsx   edx, byte ptr [ecx]
.text$mn:00001AB2                 test    edx, edx
.text$mn:00001AB4                 jz      loc_1C07
.text$mn:00001ABA                 mov     eax, [ebp+arg_0]
.text$mn:00001ABD                 movsx   ecx, byte ptr [eax]
.text$mn:00001AC0                 cmp     ecx, 3Ch ; '<'
.text$mn:00001AC3                 jz      loc_1B93
.text$mn:00001AC9                 push    44h ; 'D'       ; unsigned int
.text$mn:00001ACB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001AD0                 add     esp, 4
.text$mn:00001AD3                 mov     [ebp+var_24], eax
.text$mn:00001AD6                 mov     [ebp+var_4], 0
.text$mn:00001ADD                 cmp     [ebp+var_24], 0
.text$mn:00001AE1                 jz      short loc_1AF5
.text$mn:00001AE3                 push    offset $SG94848 ; char *
.text$mn:00001AE8                 mov     ecx, [ebp+var_24]
.text$mn:00001AEB                 call    ??0TiXmlTextA@@QAE@PBD@Z ; TiXmlTextA::TiXmlTextA(char const *)
.text$mn:00001AF0                 mov     [ebp+var_28], eax
.text$mn:00001AF3                 jmp     short loc_1AFC
.text$mn:00001AF5 ; ---------------------------------------------------------------------------
.text$mn:00001AF5
.text$mn:00001AF5 loc_1AF5:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+81j
.text$mn:00001AF5                 mov     [ebp+var_28], 0
.text$mn:00001AFC
.text$mn:00001AFC loc_1AFC:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+93j
.text$mn:00001AFC                 mov     edx, [ebp+var_28]
.text$mn:00001AFF                 mov     [ebp+var_2C], edx
.text$mn:00001B02                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B09                 mov     eax, [ebp+var_2C]
.text$mn:00001B0C                 mov     [ebp+var_10], eax
.text$mn:00001B0F                 cmp     [ebp+var_10], 0
.text$mn:00001B13                 jnz     short loc_1B30
.text$mn:00001B15                 cmp     [ebp+var_1C], 0
.text$mn:00001B19                 jz      short loc_1B29
.text$mn:00001B1B                 push    0               ; struct TiXmlParsingDataA *
.text$mn:00001B1D                 push    0               ; char *
.text$mn:00001B1F                 push    3               ; int
.text$mn:00001B21                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00001B24                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:00001B29
.text$mn:00001B29 loc_1B29:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+B9j
.text$mn:00001B29                 xor     eax, eax
.text$mn:00001B2B                 jmp     loc_1C24
.text$mn:00001B30 ; ---------------------------------------------------------------------------
.text$mn:00001B30
.text$mn:00001B30 loc_1B30:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+B3j
.text$mn:00001B30                 mov     ecx, [ebp+arg_4]
.text$mn:00001B33                 push    ecx
.text$mn:00001B34                 mov     edx, [ebp+arg_0]
.text$mn:00001B37                 push    edx
.text$mn:00001B38                 mov     eax, [ebp+var_10]
.text$mn:00001B3B                 mov     edx, [eax]
.text$mn:00001B3D                 mov     ecx, [ebp+var_10]
.text$mn:00001B40                 mov     eax, [edx+0Ch]
.text$mn:00001B43                 call    eax
.text$mn:00001B45                 mov     [ebp+arg_0], eax
.text$mn:00001B48                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001B4B                 call    ?Blank@TiXmlTextA@@IBE_NXZ ; TiXmlTextA::Blank(void)
.text$mn:00001B50                 movzx   ecx, al
.text$mn:00001B53                 test    ecx, ecx
.text$mn:00001B55                 jnz     short loc_1B65
.text$mn:00001B57                 mov     edx, [ebp+var_10]
.text$mn:00001B5A                 push    edx             ; struct TiXmlNodeA *
.text$mn:00001B5B                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001B5E                 call    ?LinkEndChild@TiXmlNodeA@@QAEPAV1@PAV1@@Z ; TiXmlNodeA::LinkEndChild(TiXmlNodeA *)
.text$mn:00001B63                 jmp     short loc_1B91
.text$mn:00001B65 ; ---------------------------------------------------------------------------
.text$mn:00001B65
.text$mn:00001B65 loc_1B65:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+F5j
.text$mn:00001B65                 mov     eax, [ebp+var_10]
.text$mn:00001B68                 mov     [ebp+var_30], eax
.text$mn:00001B6B                 mov     ecx, [ebp+var_30]
.text$mn:00001B6E                 mov     [ebp+var_20], ecx
.text$mn:00001B71                 cmp     [ebp+var_20], 0
.text$mn:00001B75                 jz      short loc_1B8A
.text$mn:00001B77                 push    1
.text$mn:00001B79                 mov     edx, [ebp+var_20]
.text$mn:00001B7C                 mov     eax, [edx]
.text$mn:00001B7E                 mov     ecx, [ebp+var_20]
.text$mn:00001B81                 mov     edx, [eax]
.text$mn:00001B83                 call    edx
.text$mn:00001B85                 mov     [ebp+var_34], eax
.text$mn:00001B88                 jmp     short loc_1B91
.text$mn:00001B8A ; ---------------------------------------------------------------------------
.text$mn:00001B8A
.text$mn:00001B8A loc_1B8A:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+115j
.text$mn:00001B8A                 mov     [ebp+var_34], 0
.text$mn:00001B91
.text$mn:00001B91 loc_1B91:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+103j
.text$mn:00001B91                                         ; TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+128j
.text$mn:00001B91                 jmp     short loc_1BF3
.text$mn:00001B93 ; ---------------------------------------------------------------------------
.text$mn:00001B93
.text$mn:00001B93 loc_1B93:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+63j
.text$mn:00001B93                 push    0               ; bool
.text$mn:00001B95                 push    offset $SG94857 ; char *
.text$mn:00001B9A                 mov     eax, [ebp+arg_0]
.text$mn:00001B9D                 push    eax             ; char *
.text$mn:00001B9E                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:00001BA3                 add     esp, 0Ch
.text$mn:00001BA6                 movzx   ecx, al
.text$mn:00001BA9                 test    ecx, ecx
.text$mn:00001BAB                 jz      short loc_1BB4
.text$mn:00001BAD                 mov     eax, [ebp+arg_0]
.text$mn:00001BB0                 jmp     short loc_1C24
.text$mn:00001BB2 ; ---------------------------------------------------------------------------
.text$mn:00001BB2                 jmp     short loc_1BF3
.text$mn:00001BB4 ; ---------------------------------------------------------------------------
.text$mn:00001BB4
.text$mn:00001BB4 loc_1BB4:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+14Bj
.text$mn:00001BB4                 mov     edx, [ebp+arg_0]
.text$mn:00001BB7                 push    edx             ; char *
.text$mn:00001BB8                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001BBB                 call    ?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z ; TiXmlNodeA::Identify(char const *)
.text$mn:00001BC0                 mov     [ebp+var_14], eax
.text$mn:00001BC3                 cmp     [ebp+var_14], 0
.text$mn:00001BC7                 jz      short loc_1BEF
.text$mn:00001BC9                 mov     eax, [ebp+arg_4]
.text$mn:00001BCC                 push    eax
.text$mn:00001BCD                 mov     ecx, [ebp+arg_0]
.text$mn:00001BD0                 push    ecx
.text$mn:00001BD1                 mov     edx, [ebp+var_14]
.text$mn:00001BD4                 mov     eax, [edx]
.text$mn:00001BD6                 mov     ecx, [ebp+var_14]
.text$mn:00001BD9                 mov     edx, [eax+0Ch]
.text$mn:00001BDC                 call    edx
.text$mn:00001BDE                 mov     [ebp+arg_0], eax
.text$mn:00001BE1                 mov     eax, [ebp+var_14]
.text$mn:00001BE4                 push    eax             ; struct TiXmlNodeA *
.text$mn:00001BE5                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001BE8                 call    ?LinkEndChild@TiXmlNodeA@@QAEPAV1@PAV1@@Z ; TiXmlNodeA::LinkEndChild(TiXmlNodeA *)
.text$mn:00001BED                 jmp     short loc_1BF3
.text$mn:00001BEF ; ---------------------------------------------------------------------------
.text$mn:00001BEF
.text$mn:00001BEF loc_1BEF:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+167j
.text$mn:00001BEF                 xor     eax, eax
.text$mn:00001BF1                 jmp     short loc_1C24
.text$mn:00001BF3 ; ---------------------------------------------------------------------------
.text$mn:00001BF3
.text$mn:00001BF3 loc_1BF3:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *):loc_1B91j
.text$mn:00001BF3                                         ; TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+152j ...
.text$mn:00001BF3                 mov     ecx, [ebp+arg_0]
.text$mn:00001BF6                 push    ecx             ; char *
.text$mn:00001BF7                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00001BFC                 add     esp, 4
.text$mn:00001BFF                 mov     [ebp+arg_0], eax
.text$mn:00001C02                 jmp     loc_1AA2
.text$mn:00001C07 ; ---------------------------------------------------------------------------
.text$mn:00001C07
.text$mn:00001C07 loc_1C07:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+46j
.text$mn:00001C07                                         ; TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+54j
.text$mn:00001C07                 cmp     [ebp+arg_0], 0
.text$mn:00001C0B                 jnz     short loc_1C21
.text$mn:00001C0D                 cmp     [ebp+var_1C], 0
.text$mn:00001C11                 jz      short loc_1C21
.text$mn:00001C13                 push    0               ; struct TiXmlParsingDataA *
.text$mn:00001C15                 push    0               ; char *
.text$mn:00001C17                 push    6               ; int
.text$mn:00001C19                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00001C1C                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:00001C21
.text$mn:00001C21 loc_1C21:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+1ABj
.text$mn:00001C21                                         ; TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+1B1j
.text$mn:00001C21                 mov     eax, [ebp+arg_0]
.text$mn:00001C24
.text$mn:00001C24 loc_1C24:                               ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+CBj
.text$mn:00001C24                                         ; TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+150j ...
.text$mn:00001C24                 mov     ecx, [ebp+var_C]
.text$mn:00001C27                 mov     large fs:0, ecx
.text$mn:00001C2E                 pop     ecx
.text$mn:00001C2F                 mov     esp, ebp
.text$mn:00001C31                 pop     ebp
.text$mn:00001C32                 retn    8
.text$mn:00001C32 ?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$mn:00001C32
.text$mn:00001C32 ; ---------------------------------------------------------------------------
.text$mn:00001C35                 align 10h
.text$mn:00001C40
.text$mn:00001C40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C40
.text$mn:00001C40 ; Attributes: bp-based frame
.text$mn:00001C40
.text$mn:00001C40 ; protected: virtual void __thiscall TiXmlCommentA::StreamIn(class std::basic_istream<char, struct std::char_traits<char>> *, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> *)
.text$mn:00001C40                 public ?StreamIn@TiXmlCommentA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.text$mn:00001C40 ?StreamIn@TiXmlCommentA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z proc near
.text$mn:00001C40                                         ; DATA XREF: .rdata:00009118o
.text$mn:00001C40
.text$mn:00001C40 var_8           = dword ptr -8
.text$mn:00001C40 var_4           = dword ptr -4
.text$mn:00001C40 arg_0           = dword ptr  8
.text$mn:00001C40 arg_4           = dword ptr  0Ch
.text$mn:00001C40
.text$mn:00001C40                 push    ebp
.text$mn:00001C41                 mov     ebp, esp
.text$mn:00001C43                 sub     esp, 8
.text$mn:00001C46                 mov     [ebp+var_8], ecx
.text$mn:00001C49
.text$mn:00001C49 loc_1C49:                               ; CODE XREF: TiXmlCommentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *):loc_1CBAj
.text$mn:00001C49                 mov     eax, [ebp+arg_0]
.text$mn:00001C4C                 mov     ecx, [eax]
.text$mn:00001C4E                 mov     edx, [ebp+arg_0]
.text$mn:00001C51                 add     edx, [ecx+4]
.text$mn:00001C54                 mov     ecx, edx        ; this
.text$mn:00001C56                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:00001C5B                 movzx   eax, al
.text$mn:00001C5E                 test    eax, eax
.text$mn:00001C60                 jz      short loc_1CBC
.text$mn:00001C62                 mov     ecx, [ebp+arg_0]
.text$mn:00001C65                 call    ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::get(void)
.text$mn:00001C6A                 mov     [ebp+var_4], eax
.text$mn:00001C6D                 movzx   ecx, byte ptr [ebp+var_4]
.text$mn:00001C71                 push    ecx
.text$mn:00001C72                 mov     ecx, [ebp+arg_4]
.text$mn:00001C75                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:00001C7A                 cmp     [ebp+var_4], 3Eh ; '>'
.text$mn:00001C7E                 jnz     short loc_1CBA
.text$mn:00001C80                 mov     ecx, [ebp+arg_4]
.text$mn:00001C83                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:00001C88                 sub     eax, 2
.text$mn:00001C8B                 push    eax
.text$mn:00001C8C                 mov     ecx, [ebp+arg_4]
.text$mn:00001C8F                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:00001C94                 movsx   edx, byte ptr [eax]
.text$mn:00001C97                 cmp     edx, 2Dh ; '-'
.text$mn:00001C9A                 jnz     short loc_1CBA
.text$mn:00001C9C                 mov     ecx, [ebp+arg_4]
.text$mn:00001C9F                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:00001CA4                 sub     eax, 3
.text$mn:00001CA7                 push    eax
.text$mn:00001CA8                 mov     ecx, [ebp+arg_4]
.text$mn:00001CAB                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:00001CB0                 movsx   eax, byte ptr [eax]
.text$mn:00001CB3                 cmp     eax, 2Dh ; '-'
.text$mn:00001CB6                 jnz     short loc_1CBA
.text$mn:00001CB8                 jmp     short loc_1CBC
.text$mn:00001CBA ; ---------------------------------------------------------------------------
.text$mn:00001CBA
.text$mn:00001CBA loc_1CBA:                               ; CODE XREF: TiXmlCommentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+3Ej
.text$mn:00001CBA                                         ; TiXmlCommentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+5Aj ...
.text$mn:00001CBA                 jmp     short loc_1C49
.text$mn:00001CBC ; ---------------------------------------------------------------------------
.text$mn:00001CBC
.text$mn:00001CBC loc_1CBC:                               ; CODE XREF: TiXmlCommentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+20j
.text$mn:00001CBC                                         ; TiXmlCommentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+78j
.text$mn:00001CBC                 mov     esp, ebp
.text$mn:00001CBE                 pop     ebp
.text$mn:00001CBF                 retn    8
.text$mn:00001CBF ?StreamIn@TiXmlCommentA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z endp
.text$mn:00001CBF
.text$mn:00001CBF ; ---------------------------------------------------------------------------
.text$mn:00001CC2                 align 10h
.text$mn:00001CD0
.text$mn:00001CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CD0
.text$mn:00001CD0 ; Attributes: bp-based frame
.text$mn:00001CD0
.text$mn:00001CD0 ; const char *__thiscall TiXmlCommentA::Parse(TiXmlCommentA *this, const char *Str2, struct TiXmlParsingDataA *)
.text$mn:00001CD0                 public ?Parse@TiXmlCommentA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:00001CD0 ?Parse@TiXmlCommentA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$mn:00001CD0                                         ; DATA XREF: .rdata:0000910Co
.text$mn:00001CD0
.text$mn:00001CD0 var_10          = dword ptr -10h
.text$mn:00001CD0 var_C           = dword ptr -0Ch
.text$mn:00001CD0 Str             = dword ptr -8
.text$mn:00001CD0 var_4           = dword ptr -4
.text$mn:00001CD0 Str2            = dword ptr  8
.text$mn:00001CD0 arg_4           = dword ptr  0Ch
.text$mn:00001CD0
.text$mn:00001CD0                 push    ebp
.text$mn:00001CD1                 mov     ebp, esp
.text$mn:00001CD3                 sub     esp, 10h
.text$mn:00001CD6                 mov     [ebp+var_4], ecx
.text$mn:00001CD9                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001CDC                 call    ?GetDocument@TiXmlNodeA@@QBEPAVTiXmlDocumentA@@XZ ; TiXmlNodeA::GetDocument(void)
.text$mn:00001CE1                 mov     [ebp+var_C], eax
.text$mn:00001CE4                 push    offset $SG94909 ; Str
.text$mn:00001CE9                 mov     ecx, [ebp+var_4]
.text$mn:00001CEC                 add     ecx, 1Ch
.text$mn:00001CEF                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00001CF4                 mov     eax, [ebp+Str2]
.text$mn:00001CF7                 push    eax             ; char *
.text$mn:00001CF8                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00001CFD                 add     esp, 4
.text$mn:00001D00                 mov     [ebp+Str2], eax
.text$mn:00001D03                 cmp     [ebp+arg_4], 0
.text$mn:00001D07                 jz      short loc_1D2B
.text$mn:00001D09                 mov     ecx, [ebp+Str2]
.text$mn:00001D0C                 push    ecx             ; char *
.text$mn:00001D0D                 mov     ecx, [ebp+arg_4] ; this
.text$mn:00001D10                 call    ?Stamp@TiXmlParsingDataA@@QAEXPBD@Z ; TiXmlParsingDataA::Stamp(char const *)
.text$mn:00001D15                 mov     ecx, [ebp+arg_4] ; this
.text$mn:00001D18                 call    ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ ; TiXmlParsingDataA::Cursor(void)
.text$mn:00001D1D                 mov     edx, [eax]
.text$mn:00001D1F                 mov     eax, [eax+4]
.text$mn:00001D22                 mov     ecx, [ebp+var_4]
.text$mn:00001D25                 mov     [ecx+4], edx
.text$mn:00001D28                 mov     [ecx+8], eax
.text$mn:00001D2B
.text$mn:00001D2B loc_1D2B:                               ; CODE XREF: TiXmlCommentA::Parse(char const *,TiXmlParsingDataA *)+37j
.text$mn:00001D2B                 mov     [ebp+Str], offset $SG94912 ; "<!--"
.text$mn:00001D32                 mov     [ebp+var_10], offset $SG94914 ; "-->"
.text$mn:00001D39                 push    0               ; bool
.text$mn:00001D3B                 mov     edx, [ebp+Str]
.text$mn:00001D3E                 push    edx             ; char *
.text$mn:00001D3F                 mov     eax, [ebp+Str2]
.text$mn:00001D42                 push    eax             ; char *
.text$mn:00001D43                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:00001D48                 add     esp, 0Ch
.text$mn:00001D4B                 movzx   ecx, al
.text$mn:00001D4E                 test    ecx, ecx
.text$mn:00001D50                 jnz     short loc_1D68
.text$mn:00001D52                 mov     edx, [ebp+arg_4]
.text$mn:00001D55                 push    edx             ; struct TiXmlParsingDataA *
.text$mn:00001D56                 mov     eax, [ebp+Str2]
.text$mn:00001D59                 push    eax             ; char *
.text$mn:00001D5A                 push    0Bh             ; int
.text$mn:00001D5C                 mov     ecx, [ebp+var_C] ; this
.text$mn:00001D5F                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:00001D64                 xor     eax, eax
.text$mn:00001D66                 jmp     short loc_1D9B
.text$mn:00001D68 ; ---------------------------------------------------------------------------
.text$mn:00001D68
.text$mn:00001D68 loc_1D68:                               ; CODE XREF: TiXmlCommentA::Parse(char const *,TiXmlParsingDataA *)+80j
.text$mn:00001D68                 mov     ecx, [ebp+Str]
.text$mn:00001D6B                 push    ecx             ; Str
.text$mn:00001D6C                 call    _strlen
.text$mn:00001D71                 add     esp, 4
.text$mn:00001D74                 add     eax, [ebp+Str2]
.text$mn:00001D77                 mov     [ebp+Str2], eax
.text$mn:00001D7A                 push    0               ; char
.text$mn:00001D7C                 mov     edx, [ebp+var_10]
.text$mn:00001D7F                 push    edx             ; Str
.text$mn:00001D80                 push    0               ; char
.text$mn:00001D82                 mov     eax, [ebp+var_4]
.text$mn:00001D85                 add     eax, 1Ch
.text$mn:00001D88                 push    eax             ; int
.text$mn:00001D89                 mov     ecx, [ebp+Str2]
.text$mn:00001D8C                 push    ecx             ; Str2
.text$mn:00001D8D                 call    ?ReadText@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N02@Z ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)
.text$mn:00001D92                 add     esp, 14h
.text$mn:00001D95                 mov     [ebp+Str2], eax
.text$mn:00001D98                 mov     eax, [ebp+Str2]
.text$mn:00001D9B
.text$mn:00001D9B loc_1D9B:                               ; CODE XREF: TiXmlCommentA::Parse(char const *,TiXmlParsingDataA *)+96j
.text$mn:00001D9B                 mov     esp, ebp
.text$mn:00001D9D                 pop     ebp
.text$mn:00001D9E                 retn    8
.text$mn:00001D9E ?Parse@TiXmlCommentA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$mn:00001D9E
.text$mn:00001D9E ; ---------------------------------------------------------------------------
.text$mn:00001DA1                 align 10h
.text$mn:00001DB0
.text$mn:00001DB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DB0
.text$mn:00001DB0 ; Attributes: bp-based frame
.text$mn:00001DB0
.text$mn:00001DB0 ; bool __thiscall TiXmlTextA::Blank(TiXmlTextA *__hidden this)
.text$mn:00001DB0                 public ?Blank@TiXmlTextA@@IBE_NXZ
.text$mn:00001DB0 ?Blank@TiXmlTextA@@IBE_NXZ proc near    ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+EBp
.text$mn:00001DB0
.text$mn:00001DB0 var_C           = dword ptr -0Ch
.text$mn:00001DB0 var_8           = dword ptr -8
.text$mn:00001DB0 var_4           = dword ptr -4
.text$mn:00001DB0
.text$mn:00001DB0                 push    ebp
.text$mn:00001DB1                 mov     ebp, esp
.text$mn:00001DB3                 sub     esp, 0Ch
.text$mn:00001DB6                 mov     [ebp+var_8], ecx
.text$mn:00001DB9                 mov     [ebp+var_4], 0
.text$mn:00001DC0                 mov     ecx, [ebp+var_8]
.text$mn:00001DC3                 add     ecx, 1Ch
.text$mn:00001DC6                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:00001DCB                 mov     [ebp+var_C], eax
.text$mn:00001DCE                 jmp     short loc_1DD9
.text$mn:00001DD0 ; ---------------------------------------------------------------------------
.text$mn:00001DD0
.text$mn:00001DD0 loc_1DD0:                               ; CODE XREF: TiXmlTextA::Blank(void):loc_1E04j
.text$mn:00001DD0                 mov     eax, [ebp+var_4]
.text$mn:00001DD3                 add     eax, 1
.text$mn:00001DD6                 mov     [ebp+var_4], eax
.text$mn:00001DD9
.text$mn:00001DD9 loc_1DD9:                               ; CODE XREF: TiXmlTextA::Blank(void)+1Ej
.text$mn:00001DD9                 mov     ecx, [ebp+var_4]
.text$mn:00001DDC                 cmp     ecx, [ebp+var_C]
.text$mn:00001DDF                 jnb     short loc_1E06
.text$mn:00001DE1                 mov     edx, [ebp+var_4]
.text$mn:00001DE4                 push    edx
.text$mn:00001DE5                 mov     ecx, [ebp+var_8]
.text$mn:00001DE8                 add     ecx, 1Ch
.text$mn:00001DEB                 call    ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator[](uint)
.text$mn:00001DF0                 movsx   eax, byte ptr [eax]
.text$mn:00001DF3                 push    eax             ; C
.text$mn:00001DF4                 call    _isspace
.text$mn:00001DF9                 add     esp, 4
.text$mn:00001DFC                 test    eax, eax
.text$mn:00001DFE                 jnz     short loc_1E04
.text$mn:00001E00                 xor     al, al
.text$mn:00001E02                 jmp     short loc_1E08
.text$mn:00001E04 ; ---------------------------------------------------------------------------
.text$mn:00001E04
.text$mn:00001E04 loc_1E04:                               ; CODE XREF: TiXmlTextA::Blank(void)+4Ej
.text$mn:00001E04                 jmp     short loc_1DD0
.text$mn:00001E06 ; ---------------------------------------------------------------------------
.text$mn:00001E06
.text$mn:00001E06 loc_1E06:                               ; CODE XREF: TiXmlTextA::Blank(void)+2Fj
.text$mn:00001E06                 mov     al, 1
.text$mn:00001E08
.text$mn:00001E08 loc_1E08:                               ; CODE XREF: TiXmlTextA::Blank(void)+52j
.text$mn:00001E08                 mov     esp, ebp
.text$mn:00001E0A                 pop     ebp
.text$mn:00001E0B                 retn
.text$mn:00001E0B ?Blank@TiXmlTextA@@IBE_NXZ endp
.text$mn:00001E0B
.text$mn:00001E0B ; ---------------------------------------------------------------------------
.text$mn:00001E0C                 align 10h
.text$mn:00001E10
.text$mn:00001E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E10
.text$mn:00001E10 ; Attributes: bp-based frame
.text$mn:00001E10
.text$mn:00001E10 ; const char *__thiscall TiXmlTextA::Parse(TiXmlTextA *this, const char *Str2, struct TiXmlParsingDataA *)
.text$mn:00001E10                 public ?Parse@TiXmlTextA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:00001E10 ?Parse@TiXmlTextA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$mn:00001E10                                         ; DATA XREF: .rdata:0000912Co
.text$mn:00001E10
.text$mn:00001E10 Str             = dword ptr -0Ch
.text$mn:00001E10 var_8           = dword ptr -8
.text$mn:00001E10 var_1           = byte ptr -1
.text$mn:00001E10 Str2            = dword ptr  8
.text$mn:00001E10 arg_4           = dword ptr  0Ch
.text$mn:00001E10
.text$mn:00001E10                 push    ebp
.text$mn:00001E11                 mov     ebp, esp
.text$mn:00001E13                 sub     esp, 0Ch
.text$mn:00001E16                 mov     [ebp+var_8], ecx
.text$mn:00001E19                 push    offset $SG94963 ; Str
.text$mn:00001E1E                 mov     ecx, [ebp+var_8]
.text$mn:00001E21                 add     ecx, 1Ch
.text$mn:00001E24                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00001E29                 cmp     [ebp+arg_4], 0
.text$mn:00001E2D                 jz      short loc_1E51
.text$mn:00001E2F                 mov     eax, [ebp+Str2]
.text$mn:00001E32                 push    eax             ; char *
.text$mn:00001E33                 mov     ecx, [ebp+arg_4] ; this
.text$mn:00001E36                 call    ?Stamp@TiXmlParsingDataA@@QAEXPBD@Z ; TiXmlParsingDataA::Stamp(char const *)
.text$mn:00001E3B                 mov     ecx, [ebp+arg_4] ; this
.text$mn:00001E3E                 call    ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ ; TiXmlParsingDataA::Cursor(void)
.text$mn:00001E43                 mov     ecx, [eax]
.text$mn:00001E45                 mov     edx, [eax+4]
.text$mn:00001E48                 mov     eax, [ebp+var_8]
.text$mn:00001E4B                 mov     [eax+4], ecx
.text$mn:00001E4E                 mov     [eax+8], edx
.text$mn:00001E51
.text$mn:00001E51 loc_1E51:                               ; CODE XREF: TiXmlTextA::Parse(char const *,TiXmlParsingDataA *)+1Dj
.text$mn:00001E51                 mov     [ebp+var_1], 1
.text$mn:00001E55                 mov     [ebp+Str], offset $SG94967
.text$mn:00001E5C                 push    0               ; char
.text$mn:00001E5E                 mov     ecx, [ebp+Str]
.text$mn:00001E61                 push    ecx             ; Str
.text$mn:00001E62                 movzx   edx, [ebp+var_1]
.text$mn:00001E66                 push    edx             ; char
.text$mn:00001E67                 mov     eax, [ebp+var_8]
.text$mn:00001E6A                 add     eax, 1Ch
.text$mn:00001E6D                 push    eax             ; int
.text$mn:00001E6E                 mov     ecx, [ebp+Str2]
.text$mn:00001E71                 push    ecx             ; Str2
.text$mn:00001E72                 call    ?ReadText@TiXmlBaseA@@KAPBDPBDPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N02@Z ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)
.text$mn:00001E77                 add     esp, 14h
.text$mn:00001E7A                 mov     [ebp+Str2], eax
.text$mn:00001E7D                 cmp     [ebp+Str2], 0
.text$mn:00001E81                 jz      short loc_1E8B
.text$mn:00001E83                 mov     eax, [ebp+Str2]
.text$mn:00001E86                 sub     eax, 1
.text$mn:00001E89                 jmp     short loc_1E8D
.text$mn:00001E8B ; ---------------------------------------------------------------------------
.text$mn:00001E8B
.text$mn:00001E8B loc_1E8B:                               ; CODE XREF: TiXmlTextA::Parse(char const *,TiXmlParsingDataA *)+71j
.text$mn:00001E8B                 xor     eax, eax
.text$mn:00001E8D
.text$mn:00001E8D loc_1E8D:                               ; CODE XREF: TiXmlTextA::Parse(char const *,TiXmlParsingDataA *)+79j
.text$mn:00001E8D                 mov     esp, ebp
.text$mn:00001E8F                 pop     ebp
.text$mn:00001E90                 retn    8
.text$mn:00001E90 ?Parse@TiXmlTextA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$mn:00001E90
.text$mn:00001E90 ; ---------------------------------------------------------------------------
.text$mn:00001E93                 align 10h
.text$mn:00001EA0
.text$mn:00001EA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EA0
.text$mn:00001EA0 ; Attributes: bp-based frame
.text$mn:00001EA0
.text$mn:00001EA0 ; protected: virtual void __thiscall TiXmlTextA::StreamIn(class std::basic_istream<char, struct std::char_traits<char>> *, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> *)
.text$mn:00001EA0                 public ?StreamIn@TiXmlTextA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.text$mn:00001EA0 ?StreamIn@TiXmlTextA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z proc near
.text$mn:00001EA0                                         ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+12Dp
.text$mn:00001EA0                                         ; DATA XREF: .rdata:00009138o
.text$mn:00001EA0
.text$mn:00001EA0 var_8           = dword ptr -8
.text$mn:00001EA0 var_4           = dword ptr -4
.text$mn:00001EA0 arg_0           = dword ptr  8
.text$mn:00001EA0 arg_4           = dword ptr  0Ch
.text$mn:00001EA0
.text$mn:00001EA0                 push    ebp
.text$mn:00001EA1                 mov     ebp, esp
.text$mn:00001EA3                 sub     esp, 8
.text$mn:00001EA6                 mov     [ebp+var_8], ecx
.text$mn:00001EA9
.text$mn:00001EA9 loc_1EA9:                               ; CODE XREF: TiXmlTextA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+4Aj
.text$mn:00001EA9                 mov     eax, [ebp+arg_0]
.text$mn:00001EAC                 mov     ecx, [eax]
.text$mn:00001EAE                 mov     edx, [ebp+arg_0]
.text$mn:00001EB1                 add     edx, [ecx+4]
.text$mn:00001EB4                 mov     ecx, edx        ; this
.text$mn:00001EB6                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:00001EBB                 movzx   eax, al
.text$mn:00001EBE                 test    eax, eax
.text$mn:00001EC0                 jz      short loc_1EEC
.text$mn:00001EC2                 mov     ecx, [ebp+arg_0]
.text$mn:00001EC5                 call    ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::peek(void)
.text$mn:00001ECA                 mov     [ebp+var_4], eax
.text$mn:00001ECD                 cmp     [ebp+var_4], 3Ch ; '<'
.text$mn:00001ED1                 jnz     short loc_1ED5
.text$mn:00001ED3                 jmp     short loc_1EEC
.text$mn:00001ED5 ; ---------------------------------------------------------------------------
.text$mn:00001ED5
.text$mn:00001ED5 loc_1ED5:                               ; CODE XREF: TiXmlTextA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+31j
.text$mn:00001ED5                 movzx   ecx, byte ptr [ebp+var_4]
.text$mn:00001ED9                 push    ecx
.text$mn:00001EDA                 mov     ecx, [ebp+arg_4]
.text$mn:00001EDD                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:00001EE2                 mov     ecx, [ebp+arg_0]
.text$mn:00001EE5                 call    ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::get(void)
.text$mn:00001EEA                 jmp     short loc_1EA9
.text$mn:00001EEC ; ---------------------------------------------------------------------------
.text$mn:00001EEC
.text$mn:00001EEC loc_1EEC:                               ; CODE XREF: TiXmlTextA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+20j
.text$mn:00001EEC                                         ; TiXmlTextA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+33j
.text$mn:00001EEC                 mov     esp, ebp
.text$mn:00001EEE                 pop     ebp
.text$mn:00001EEF                 retn    8
.text$mn:00001EEF ?StreamIn@TiXmlTextA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z endp
.text$mn:00001EEF
.text$mn:00001EEF ; ---------------------------------------------------------------------------
.text$mn:00001EF2                 align 10h
.text$mn:00001F00
.text$mn:00001F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F00
.text$mn:00001F00 ; Attributes: bp-based frame
.text$mn:00001F00
.text$mn:00001F00 ; protected: virtual void __thiscall TiXmlDeclarationA::StreamIn(class std::basic_istream<char, struct std::char_traits<char>> *, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> *)
.text$mn:00001F00                 public ?StreamIn@TiXmlDeclarationA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.text$mn:00001F00 ?StreamIn@TiXmlDeclarationA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z proc near
.text$mn:00001F00                                         ; DATA XREF: .rdata:00009158o
.text$mn:00001F00
.text$mn:00001F00 var_8           = dword ptr -8
.text$mn:00001F00 var_4           = dword ptr -4
.text$mn:00001F00 arg_0           = dword ptr  8
.text$mn:00001F00 arg_4           = dword ptr  0Ch
.text$mn:00001F00
.text$mn:00001F00                 push    ebp
.text$mn:00001F01                 mov     ebp, esp
.text$mn:00001F03                 sub     esp, 8
.text$mn:00001F06                 mov     [ebp+var_8], ecx
.text$mn:00001F09
.text$mn:00001F09 loc_1F09:                               ; CODE XREF: TiXmlDeclarationA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *):loc_1F42j
.text$mn:00001F09                 mov     eax, [ebp+arg_0]
.text$mn:00001F0C                 mov     ecx, [eax]
.text$mn:00001F0E                 mov     edx, [ebp+arg_0]
.text$mn:00001F11                 add     edx, [ecx+4]
.text$mn:00001F14                 mov     ecx, edx        ; this
.text$mn:00001F16                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:00001F1B                 movzx   eax, al
.text$mn:00001F1E                 test    eax, eax
.text$mn:00001F20                 jz      short loc_1F44
.text$mn:00001F22                 mov     ecx, [ebp+arg_0]
.text$mn:00001F25                 call    ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::get(void)
.text$mn:00001F2A                 mov     [ebp+var_4], eax
.text$mn:00001F2D                 movzx   ecx, byte ptr [ebp+var_4]
.text$mn:00001F31                 push    ecx
.text$mn:00001F32                 mov     ecx, [ebp+arg_4]
.text$mn:00001F35                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:00001F3A                 cmp     [ebp+var_4], 3Eh ; '>'
.text$mn:00001F3E                 jnz     short loc_1F42
.text$mn:00001F40                 jmp     short loc_1F44
.text$mn:00001F42 ; ---------------------------------------------------------------------------
.text$mn:00001F42
.text$mn:00001F42 loc_1F42:                               ; CODE XREF: TiXmlDeclarationA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+3Ej
.text$mn:00001F42                 jmp     short loc_1F09
.text$mn:00001F44 ; ---------------------------------------------------------------------------
.text$mn:00001F44
.text$mn:00001F44 loc_1F44:                               ; CODE XREF: TiXmlDeclarationA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+20j
.text$mn:00001F44                                         ; TiXmlDeclarationA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+40j
.text$mn:00001F44                 mov     esp, ebp
.text$mn:00001F46                 pop     ebp
.text$mn:00001F47                 retn    8
.text$mn:00001F47 ?StreamIn@TiXmlDeclarationA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z endp
.text$mn:00001F47
.text$mn:00001F47 ; ---------------------------------------------------------------------------
.text$mn:00001F4A                 align 10h
.text$mn:00001F50
.text$mn:00001F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F50
.text$mn:00001F50 ; Attributes: bp-based frame
.text$mn:00001F50
.text$mn:00001F50 ; const char *__thiscall TiXmlDeclarationA::Parse(TiXmlDeclarationA *this, const char *Str2, struct TiXmlParsingDataA *)
.text$mn:00001F50                 public ?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:00001F50 ?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$mn:00001F50                                         ; DATA XREF: .rdata:0000914Co
.text$mn:00001F50
.text$mn:00001F50 var_108         = dword ptr -108h
.text$mn:00001F50 var_104         = dword ptr -104h
.text$mn:00001F50 var_100         = byte ptr -100h
.text$mn:00001F50 var_B0          = byte ptr -0B0h
.text$mn:00001F50 var_60          = byte ptr -60h
.text$mn:00001F50 var_10          = dword ptr -10h
.text$mn:00001F50 var_C           = dword ptr -0Ch
.text$mn:00001F50 var_4           = dword ptr -4
.text$mn:00001F50 Str2            = dword ptr  8
.text$mn:00001F50 arg_4           = dword ptr  0Ch
.text$mn:00001F50
.text$mn:00001F50                 push    ebp
.text$mn:00001F51                 mov     ebp, esp
.text$mn:00001F53                 push    0FFFFFFFFh
.text$mn:00001F55                 push    offset __ehhandler$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:00001F5A                 mov     eax, large fs:0
.text$mn:00001F60                 push    eax
.text$mn:00001F61                 sub     esp, 0FCh
.text$mn:00001F67                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F6C                 xor     eax, ebp
.text$mn:00001F6E                 mov     [ebp+var_10], eax
.text$mn:00001F71                 push    eax
.text$mn:00001F72                 lea     eax, [ebp+var_C]
.text$mn:00001F75                 mov     large fs:0, eax
.text$mn:00001F7B                 mov     [ebp+var_104], ecx
.text$mn:00001F81                 mov     eax, [ebp+Str2]
.text$mn:00001F84                 push    eax             ; char *
.text$mn:00001F85                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00001F8A                 add     esp, 4
.text$mn:00001F8D                 mov     [ebp+Str2], eax
.text$mn:00001F90                 mov     ecx, [ebp+var_104] ; this
.text$mn:00001F96                 call    ?GetDocument@TiXmlNodeA@@QBEPAVTiXmlDocumentA@@XZ ; TiXmlNodeA::GetDocument(void)
.text$mn:00001F9B                 mov     [ebp+var_108], eax
.text$mn:00001FA1                 cmp     [ebp+Str2], 0
.text$mn:00001FA5                 jz      short loc_1FCB
.text$mn:00001FA7                 mov     ecx, [ebp+Str2]
.text$mn:00001FAA                 movsx   edx, byte ptr [ecx]
.text$mn:00001FAD                 test    edx, edx
.text$mn:00001FAF                 jz      short loc_1FCB
.text$mn:00001FB1                 push    1               ; bool
.text$mn:00001FB3                 push    offset $SG94988 ; "<?xml"
.text$mn:00001FB8                 mov     eax, [ebp+Str2]
.text$mn:00001FBB                 push    eax             ; char *
.text$mn:00001FBC                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:00001FC1                 add     esp, 0Ch
.text$mn:00001FC4                 movzx   ecx, al
.text$mn:00001FC7                 test    ecx, ecx
.text$mn:00001FC9                 jnz     short loc_1FEC
.text$mn:00001FCB
.text$mn:00001FCB loc_1FCB:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+55j
.text$mn:00001FCB                                         ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+5Fj
.text$mn:00001FCB                 cmp     [ebp+var_108], 0
.text$mn:00001FD2                 jz      short loc_1FE5
.text$mn:00001FD4                 push    0               ; struct TiXmlParsingDataA *
.text$mn:00001FD6                 push    0               ; char *
.text$mn:00001FD8                 push    0Ch             ; int
.text$mn:00001FDA                 mov     ecx, [ebp+var_108] ; this
.text$mn:00001FE0                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:00001FE5
.text$mn:00001FE5 loc_1FE5:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+82j
.text$mn:00001FE5                 xor     eax, eax
.text$mn:00001FE7                 jmp     loc_2226
.text$mn:00001FEC ; ---------------------------------------------------------------------------
.text$mn:00001FEC
.text$mn:00001FEC loc_1FEC:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+79j
.text$mn:00001FEC                 cmp     [ebp+arg_4], 0
.text$mn:00001FF0                 jz      short loc_2017
.text$mn:00001FF2                 mov     edx, [ebp+Str2]
.text$mn:00001FF5                 push    edx             ; char *
.text$mn:00001FF6                 mov     ecx, [ebp+arg_4] ; this
.text$mn:00001FF9                 call    ?Stamp@TiXmlParsingDataA@@QAEXPBD@Z ; TiXmlParsingDataA::Stamp(char const *)
.text$mn:00001FFE                 mov     ecx, [ebp+arg_4] ; this
.text$mn:00002001                 call    ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ ; TiXmlParsingDataA::Cursor(void)
.text$mn:00002006                 mov     ecx, [eax]
.text$mn:00002008                 mov     edx, [eax+4]
.text$mn:0000200B                 mov     eax, [ebp+var_104]
.text$mn:00002011                 mov     [eax+4], ecx
.text$mn:00002014                 mov     [eax+8], edx
.text$mn:00002017
.text$mn:00002017 loc_2017:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+A0j
.text$mn:00002017                 mov     ecx, [ebp+Str2]
.text$mn:0000201A                 add     ecx, 5
.text$mn:0000201D                 mov     [ebp+Str2], ecx
.text$mn:00002020                 push    offset $SG94991 ; Str
.text$mn:00002025                 mov     ecx, [ebp+var_104]
.text$mn:0000202B                 add     ecx, 44h ; 'D'
.text$mn:0000202E                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00002033                 push    offset $SG94992 ; Str
.text$mn:00002038                 mov     ecx, [ebp+var_104]
.text$mn:0000203E                 add     ecx, 60h ; '`'
.text$mn:00002041                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00002046                 push    offset $SG94993 ; Str
.text$mn:0000204B                 mov     ecx, [ebp+var_104]
.text$mn:00002051                 add     ecx, 7Ch ; '|'
.text$mn:00002054                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00002059
.text$mn:00002059 loc_2059:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *):loc_221Fj
.text$mn:00002059                 cmp     [ebp+Str2], 0
.text$mn:0000205D                 jz      loc_2224
.text$mn:00002063                 mov     edx, [ebp+Str2]
.text$mn:00002066                 movsx   eax, byte ptr [edx]
.text$mn:00002069                 test    eax, eax
.text$mn:0000206B                 jz      loc_2224
.text$mn:00002071                 mov     ecx, [ebp+Str2]
.text$mn:00002074                 movsx   edx, byte ptr [ecx]
.text$mn:00002077                 cmp     edx, 3Eh ; '>'
.text$mn:0000207A                 jnz     short loc_208D
.text$mn:0000207C                 mov     eax, [ebp+Str2]
.text$mn:0000207F                 add     eax, 1
.text$mn:00002082                 mov     [ebp+Str2], eax
.text$mn:00002085                 mov     eax, [ebp+Str2]
.text$mn:00002088                 jmp     loc_2226
.text$mn:0000208D ; ---------------------------------------------------------------------------
.text$mn:0000208D
.text$mn:0000208D loc_208D:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+12Aj
.text$mn:0000208D                 mov     ecx, [ebp+Str2]
.text$mn:00002090                 push    ecx             ; char *
.text$mn:00002091                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00002096                 add     esp, 4
.text$mn:00002099                 mov     [ebp+Str2], eax
.text$mn:0000209C                 push    1               ; bool
.text$mn:0000209E                 push    offset $SG94999 ; "version"
.text$mn:000020A3                 mov     edx, [ebp+Str2]
.text$mn:000020A6                 push    edx             ; char *
.text$mn:000020A7                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:000020AC                 add     esp, 0Ch
.text$mn:000020AF                 movzx   eax, al
.text$mn:000020B2                 test    eax, eax
.text$mn:000020B4                 jz      short loc_2103
.text$mn:000020B6                 lea     ecx, [ebp+var_60]
.text$mn:000020B9                 call    ??0TiXmlAttributeA@@QAE@XZ ; TiXmlAttributeA::TiXmlAttributeA(void)
.text$mn:000020BE                 mov     [ebp+var_4], 0
.text$mn:000020C5                 mov     ecx, [ebp+arg_4]
.text$mn:000020C8                 push    ecx             ; struct TiXmlParsingDataA *
.text$mn:000020C9                 mov     edx, [ebp+Str2]
.text$mn:000020CC                 push    edx             ; Str2
.text$mn:000020CD                 lea     ecx, [ebp+var_60] ; this
.text$mn:000020D0                 call    ?Parse@TiXmlAttributeA@@UAEPBDPBDPAVTiXmlParsingDataA@@@Z ; TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)
.text$mn:000020D5                 mov     [ebp+Str2], eax
.text$mn:000020D8                 lea     ecx, [ebp+var_60] ; this
.text$mn:000020DB                 call    ?Value@TiXmlAttributeA@@QBEPBDXZ ; TiXmlAttributeA::Value(void)
.text$mn:000020E0                 push    eax             ; Str
.text$mn:000020E1                 mov     ecx, [ebp+var_104]
.text$mn:000020E7                 add     ecx, 44h ; 'D'
.text$mn:000020EA                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:000020EF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000020F6                 lea     ecx, [ebp+var_60] ; this
.text$mn:000020F9                 call    ??1TiXmlAttributeA@@UAE@XZ ; TiXmlAttributeA::~TiXmlAttributeA(void)
.text$mn:000020FE                 jmp     loc_221F
.text$mn:00002103 ; ---------------------------------------------------------------------------
.text$mn:00002103
.text$mn:00002103 loc_2103:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+164j
.text$mn:00002103                 push    1               ; bool
.text$mn:00002105                 push    offset $SG95003 ; "encoding"
.text$mn:0000210A                 mov     eax, [ebp+Str2]
.text$mn:0000210D                 push    eax             ; char *
.text$mn:0000210E                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:00002113                 add     esp, 0Ch
.text$mn:00002116                 movzx   ecx, al
.text$mn:00002119                 test    ecx, ecx
.text$mn:0000211B                 jz      short loc_2176
.text$mn:0000211D                 lea     ecx, [ebp+var_100]
.text$mn:00002123                 call    ??0TiXmlAttributeA@@QAE@XZ ; TiXmlAttributeA::TiXmlAttributeA(void)
.text$mn:00002128                 mov     [ebp+var_4], 1
.text$mn:0000212F                 mov     edx, [ebp+arg_4]
.text$mn:00002132                 push    edx             ; struct TiXmlParsingDataA *
.text$mn:00002133                 mov     eax, [ebp+Str2]
.text$mn:00002136                 push    eax             ; Str2
.text$mn:00002137                 lea     ecx, [ebp+var_100] ; this
.text$mn:0000213D                 call    ?Parse@TiXmlAttributeA@@UAEPBDPBDPAVTiXmlParsingDataA@@@Z ; TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)
.text$mn:00002142                 mov     [ebp+Str2], eax
.text$mn:00002145                 lea     ecx, [ebp+var_100] ; this
.text$mn:0000214B                 call    ?Value@TiXmlAttributeA@@QBEPBDXZ ; TiXmlAttributeA::Value(void)
.text$mn:00002150                 push    eax             ; Str
.text$mn:00002151                 mov     ecx, [ebp+var_104]
.text$mn:00002157                 add     ecx, 60h ; '`'
.text$mn:0000215A                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:0000215F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002166                 lea     ecx, [ebp+var_100] ; this
.text$mn:0000216C                 call    ??1TiXmlAttributeA@@UAE@XZ ; TiXmlAttributeA::~TiXmlAttributeA(void)
.text$mn:00002171                 jmp     loc_221F
.text$mn:00002176 ; ---------------------------------------------------------------------------
.text$mn:00002176
.text$mn:00002176 loc_2176:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+1CBj
.text$mn:00002176                 push    1               ; bool
.text$mn:00002178                 push    offset $SG95007 ; "standalone"
.text$mn:0000217D                 mov     ecx, [ebp+Str2]
.text$mn:00002180                 push    ecx             ; char *
.text$mn:00002181                 call    ?StringEqual@TiXmlBaseA@@KA_NPBD0_N@Z ; TiXmlBaseA::StringEqual(char const *,char const *,bool)
.text$mn:00002186                 add     esp, 0Ch
.text$mn:00002189                 movzx   edx, al
.text$mn:0000218C                 test    edx, edx
.text$mn:0000218E                 jz      short loc_21E6
.text$mn:00002190                 lea     ecx, [ebp+var_B0]
.text$mn:00002196                 call    ??0TiXmlAttributeA@@QAE@XZ ; TiXmlAttributeA::TiXmlAttributeA(void)
.text$mn:0000219B                 mov     [ebp+var_4], 2
.text$mn:000021A2                 mov     eax, [ebp+arg_4]
.text$mn:000021A5                 push    eax             ; struct TiXmlParsingDataA *
.text$mn:000021A6                 mov     ecx, [ebp+Str2]
.text$mn:000021A9                 push    ecx             ; Str2
.text$mn:000021AA                 lea     ecx, [ebp+var_B0] ; this
.text$mn:000021B0                 call    ?Parse@TiXmlAttributeA@@UAEPBDPBDPAVTiXmlParsingDataA@@@Z ; TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)
.text$mn:000021B5                 mov     [ebp+Str2], eax
.text$mn:000021B8                 lea     ecx, [ebp+var_B0] ; this
.text$mn:000021BE                 call    ?Value@TiXmlAttributeA@@QBEPBDXZ ; TiXmlAttributeA::Value(void)
.text$mn:000021C3                 push    eax             ; Str
.text$mn:000021C4                 mov     ecx, [ebp+var_104]
.text$mn:000021CA                 add     ecx, 7Ch ; '|'
.text$mn:000021CD                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:000021D2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000021D9                 lea     ecx, [ebp+var_B0] ; this
.text$mn:000021DF                 call    ??1TiXmlAttributeA@@UAE@XZ ; TiXmlAttributeA::~TiXmlAttributeA(void)
.text$mn:000021E4                 jmp     short loc_221F
.text$mn:000021E6 ; ---------------------------------------------------------------------------
.text$mn:000021E6
.text$mn:000021E6 loc_21E6:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+23Ej
.text$mn:000021E6                                         ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+2CDj
.text$mn:000021E6                 cmp     [ebp+Str2], 0
.text$mn:000021EA                 jz      short loc_221F
.text$mn:000021EC                 mov     edx, [ebp+Str2]
.text$mn:000021EF                 movsx   eax, byte ptr [edx]
.text$mn:000021F2                 test    eax, eax
.text$mn:000021F4                 jz      short loc_221F
.text$mn:000021F6                 mov     ecx, [ebp+Str2]
.text$mn:000021F9                 movsx   edx, byte ptr [ecx]
.text$mn:000021FC                 cmp     edx, 3Eh ; '>'
.text$mn:000021FF                 jz      short loc_221F
.text$mn:00002201                 mov     eax, [ebp+Str2]
.text$mn:00002204                 movsx   ecx, byte ptr [eax]
.text$mn:00002207                 push    ecx             ; C
.text$mn:00002208                 call    _isspace
.text$mn:0000220D                 add     esp, 4
.text$mn:00002210                 test    eax, eax
.text$mn:00002212                 jnz     short loc_221F
.text$mn:00002214                 mov     edx, [ebp+Str2]
.text$mn:00002217                 add     edx, 1
.text$mn:0000221A                 mov     [ebp+Str2], edx
.text$mn:0000221D                 jmp     short loc_21E6
.text$mn:0000221F ; ---------------------------------------------------------------------------
.text$mn:0000221F
.text$mn:0000221F loc_221F:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+1AEj
.text$mn:0000221F                                         ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+221j ...
.text$mn:0000221F                 jmp     loc_2059
.text$mn:00002224 ; ---------------------------------------------------------------------------
.text$mn:00002224
.text$mn:00002224 loc_2224:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+10Dj
.text$mn:00002224                                         ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+11Bj
.text$mn:00002224                 xor     eax, eax
.text$mn:00002226
.text$mn:00002226 loc_2226:                               ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+97j
.text$mn:00002226                                         ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+138j
.text$mn:00002226                 mov     ecx, [ebp+var_C]
.text$mn:00002229                 mov     large fs:0, ecx
.text$mn:00002230                 pop     ecx
.text$mn:00002231                 mov     ecx, [ebp+var_10]
.text$mn:00002234                 xor     ecx, ebp
.text$mn:00002236                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000223B                 mov     esp, ebp
.text$mn:0000223D                 pop     ebp
.text$mn:0000223E                 retn    8
.text$mn:0000223E ?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$mn:0000223E
.text$mn:0000223E ; ---------------------------------------------------------------------------
.text$mn:00002241                 align 10h
.text$mn:00002250
.text$mn:00002250 ; =============== S U B R O U T I N E =======================================
.text$mn:00002250
.text$mn:00002250 ; Attributes: bp-based frame
.text$mn:00002250
.text$mn:00002250 ; protected: virtual void __thiscall TiXmlUnknownA::StreamIn(class std::basic_istream<char, struct std::char_traits<char>> *, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> *)
.text$mn:00002250                 public ?StreamIn@TiXmlUnknownA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.text$mn:00002250 ?StreamIn@TiXmlUnknownA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z proc near
.text$mn:00002250                                         ; DATA XREF: .rdata:00009178o
.text$mn:00002250
.text$mn:00002250 var_8           = dword ptr -8
.text$mn:00002250 var_4           = dword ptr -4
.text$mn:00002250 arg_0           = dword ptr  8
.text$mn:00002250 arg_4           = dword ptr  0Ch
.text$mn:00002250
.text$mn:00002250                 push    ebp
.text$mn:00002251                 mov     ebp, esp
.text$mn:00002253                 sub     esp, 8
.text$mn:00002256                 mov     [ebp+var_8], ecx
.text$mn:00002259
.text$mn:00002259 loc_2259:                               ; CODE XREF: TiXmlUnknownA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *):loc_2292j
.text$mn:00002259                 mov     eax, [ebp+arg_0]
.text$mn:0000225C                 mov     ecx, [eax]
.text$mn:0000225E                 mov     edx, [ebp+arg_0]
.text$mn:00002261                 add     edx, [ecx+4]
.text$mn:00002264                 mov     ecx, edx        ; this
.text$mn:00002266                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:0000226B                 movzx   eax, al
.text$mn:0000226E                 test    eax, eax
.text$mn:00002270                 jz      short loc_2294
.text$mn:00002272                 mov     ecx, [ebp+arg_0]
.text$mn:00002275                 call    ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::get(void)
.text$mn:0000227A                 mov     [ebp+var_4], eax
.text$mn:0000227D                 movzx   ecx, byte ptr [ebp+var_4]
.text$mn:00002281                 push    ecx
.text$mn:00002282                 mov     ecx, [ebp+arg_4]
.text$mn:00002285                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:0000228A                 cmp     [ebp+var_4], 3Eh ; '>'
.text$mn:0000228E                 jnz     short loc_2292
.text$mn:00002290                 jmp     short loc_2294
.text$mn:00002292 ; ---------------------------------------------------------------------------
.text$mn:00002292
.text$mn:00002292 loc_2292:                               ; CODE XREF: TiXmlUnknownA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+3Ej
.text$mn:00002292                 jmp     short loc_2259
.text$mn:00002294 ; ---------------------------------------------------------------------------
.text$mn:00002294
.text$mn:00002294 loc_2294:                               ; CODE XREF: TiXmlUnknownA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+20j
.text$mn:00002294                                         ; TiXmlUnknownA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+40j
.text$mn:00002294                 mov     esp, ebp
.text$mn:00002296                 pop     ebp
.text$mn:00002297                 retn    8
.text$mn:00002297 ?StreamIn@TiXmlUnknownA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z endp
.text$mn:00002297
.text$mn:00002297 ; ---------------------------------------------------------------------------
.text$mn:0000229A                 align 10h
.text$mn:000022A0
.text$mn:000022A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022A0
.text$mn:000022A0 ; Attributes: bp-based frame
.text$mn:000022A0
.text$mn:000022A0 ; const char *__thiscall TiXmlUnknownA::Parse(TiXmlUnknownA *this, const char *, struct TiXmlParsingDataA *)
.text$mn:000022A0                 public ?Parse@TiXmlUnknownA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:000022A0 ?Parse@TiXmlUnknownA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$mn:000022A0                                         ; DATA XREF: .rdata:0000916Co
.text$mn:000022A0
.text$mn:000022A0 var_8           = dword ptr -8
.text$mn:000022A0 var_4           = dword ptr -4
.text$mn:000022A0 arg_0           = dword ptr  8
.text$mn:000022A0 arg_4           = dword ptr  0Ch
.text$mn:000022A0
.text$mn:000022A0                 push    ebp
.text$mn:000022A1                 mov     ebp, esp
.text$mn:000022A3                 sub     esp, 8
.text$mn:000022A6                 mov     [ebp+var_4], ecx
.text$mn:000022A9                 mov     ecx, [ebp+var_4] ; this
.text$mn:000022AC                 call    ?GetDocument@TiXmlNodeA@@QBEPAVTiXmlDocumentA@@XZ ; TiXmlNodeA::GetDocument(void)
.text$mn:000022B1                 mov     [ebp+var_8], eax
.text$mn:000022B4                 mov     eax, [ebp+arg_0]
.text$mn:000022B7                 push    eax             ; char *
.text$mn:000022B8                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:000022BD                 add     esp, 4
.text$mn:000022C0                 mov     [ebp+arg_0], eax
.text$mn:000022C3                 cmp     [ebp+arg_4], 0
.text$mn:000022C7                 jz      short loc_22EB
.text$mn:000022C9                 mov     ecx, [ebp+arg_0]
.text$mn:000022CC                 push    ecx             ; char *
.text$mn:000022CD                 mov     ecx, [ebp+arg_4] ; this
.text$mn:000022D0                 call    ?Stamp@TiXmlParsingDataA@@QAEXPBD@Z ; TiXmlParsingDataA::Stamp(char const *)
.text$mn:000022D5                 mov     ecx, [ebp+arg_4] ; this
.text$mn:000022D8                 call    ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ ; TiXmlParsingDataA::Cursor(void)
.text$mn:000022DD                 mov     edx, [eax]
.text$mn:000022DF                 mov     eax, [eax+4]
.text$mn:000022E2                 mov     ecx, [ebp+var_4]
.text$mn:000022E5                 mov     [ecx+4], edx
.text$mn:000022E8                 mov     [ecx+8], eax
.text$mn:000022EB
.text$mn:000022EB loc_22EB:                               ; CODE XREF: TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+27j
.text$mn:000022EB                 cmp     [ebp+arg_0], 0
.text$mn:000022EF                 jz      short loc_2306
.text$mn:000022F1                 mov     edx, [ebp+arg_0]
.text$mn:000022F4                 movsx   eax, byte ptr [edx]
.text$mn:000022F7                 test    eax, eax
.text$mn:000022F9                 jz      short loc_2306
.text$mn:000022FB                 mov     ecx, [ebp+arg_0]
.text$mn:000022FE                 movsx   edx, byte ptr [ecx]
.text$mn:00002301                 cmp     edx, 3Ch ; '<'
.text$mn:00002304                 jz      short loc_2325
.text$mn:00002306
.text$mn:00002306 loc_2306:                               ; CODE XREF: TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+4Fj
.text$mn:00002306                                         ; TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+59j
.text$mn:00002306                 cmp     [ebp+var_8], 0
.text$mn:0000230A                 jz      short loc_231E
.text$mn:0000230C                 mov     eax, [ebp+arg_4]
.text$mn:0000230F                 push    eax             ; struct TiXmlParsingDataA *
.text$mn:00002310                 mov     ecx, [ebp+arg_0]
.text$mn:00002313                 push    ecx             ; char *
.text$mn:00002314                 push    0Ah             ; int
.text$mn:00002316                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002319                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:0000231E
.text$mn:0000231E loc_231E:                               ; CODE XREF: TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+6Aj
.text$mn:0000231E                 xor     eax, eax
.text$mn:00002320                 jmp     loc_23A6
.text$mn:00002325 ; ---------------------------------------------------------------------------
.text$mn:00002325
.text$mn:00002325 loc_2325:                               ; CODE XREF: TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+64j
.text$mn:00002325                 mov     edx, [ebp+arg_0]
.text$mn:00002328                 add     edx, 1
.text$mn:0000232B                 mov     [ebp+arg_0], edx
.text$mn:0000232E                 push    offset $SG94885 ; Str
.text$mn:00002333                 mov     ecx, [ebp+var_4]
.text$mn:00002336                 add     ecx, 1Ch
.text$mn:00002339                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:0000233E
.text$mn:0000233E loc_233E:                               ; CODE XREF: TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+D4j
.text$mn:0000233E                 cmp     [ebp+arg_0], 0
.text$mn:00002342                 jz      short loc_2376
.text$mn:00002344                 mov     eax, [ebp+arg_0]
.text$mn:00002347                 movsx   ecx, byte ptr [eax]
.text$mn:0000234A                 test    ecx, ecx
.text$mn:0000234C                 jz      short loc_2376
.text$mn:0000234E                 mov     edx, [ebp+arg_0]
.text$mn:00002351                 movsx   eax, byte ptr [edx]
.text$mn:00002354                 cmp     eax, 3Eh ; '>'
.text$mn:00002357                 jz      short loc_2376
.text$mn:00002359                 mov     ecx, [ebp+arg_0]
.text$mn:0000235C                 movzx   edx, byte ptr [ecx]
.text$mn:0000235F                 push    edx
.text$mn:00002360                 mov     ecx, [ebp+var_4]
.text$mn:00002363                 add     ecx, 1Ch
.text$mn:00002366                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:0000236B                 mov     eax, [ebp+arg_0]
.text$mn:0000236E                 add     eax, 1
.text$mn:00002371                 mov     [ebp+arg_0], eax
.text$mn:00002374                 jmp     short loc_233E
.text$mn:00002376 ; ---------------------------------------------------------------------------
.text$mn:00002376
.text$mn:00002376 loc_2376:                               ; CODE XREF: TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+A2j
.text$mn:00002376                                         ; TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+ACj ...
.text$mn:00002376                 cmp     [ebp+arg_0], 0
.text$mn:0000237A                 jnz     short loc_2390
.text$mn:0000237C                 cmp     [ebp+var_8], 0
.text$mn:00002380                 jz      short loc_2390
.text$mn:00002382                 push    0               ; struct TiXmlParsingDataA *
.text$mn:00002384                 push    0               ; char *
.text$mn:00002386                 push    0Ah             ; int
.text$mn:00002388                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000238B                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:00002390
.text$mn:00002390 loc_2390:                               ; CODE XREF: TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+DAj
.text$mn:00002390                                         ; TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+E0j
.text$mn:00002390                 mov     ecx, [ebp+arg_0]
.text$mn:00002393                 movsx   edx, byte ptr [ecx]
.text$mn:00002396                 cmp     edx, 3Eh ; '>'
.text$mn:00002399                 jnz     short loc_23A3
.text$mn:0000239B                 mov     eax, [ebp+arg_0]
.text$mn:0000239E                 add     eax, 1
.text$mn:000023A1                 jmp     short loc_23A6
.text$mn:000023A3 ; ---------------------------------------------------------------------------
.text$mn:000023A3
.text$mn:000023A3 loc_23A3:                               ; CODE XREF: TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+F9j
.text$mn:000023A3                 mov     eax, [ebp+arg_0]
.text$mn:000023A6
.text$mn:000023A6 loc_23A6:                               ; CODE XREF: TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+80j
.text$mn:000023A6                                         ; TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)+101j
.text$mn:000023A6                 mov     esp, ebp
.text$mn:000023A8                 pop     ebp
.text$mn:000023A9                 retn    8
.text$mn:000023A9 ?Parse@TiXmlUnknownA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$mn:000023A9
.text$mn:000023A9 ; ---------------------------------------------------------------------------
.text$mn:000023AC                 align 10h
.text$mn:000023B0
.text$mn:000023B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000023B0
.text$mn:000023B0 ; Attributes: bp-based frame
.text$mn:000023B0
.text$mn:000023B0 ; const char *__thiscall TiXmlDocumentA::Parse(TiXmlDocumentA *this, const char *, struct TiXmlParsingDataA *)
.text$mn:000023B0                 public ?Parse@TiXmlDocumentA@@UAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$mn:000023B0 ?Parse@TiXmlDocumentA@@UAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$mn:000023B0
.text$mn:000023B0 var_18          = byte ptr -18h
.text$mn:000023B0 var_8           = dword ptr -8
.text$mn:000023B0 var_4           = dword ptr -4
.text$mn:000023B0 arg_0           = dword ptr  8
.text$mn:000023B0 arg_4           = dword ptr  0Ch
.text$mn:000023B0
.text$mn:000023B0                 push    ebp
.text$mn:000023B1                 mov     ebp, esp
.text$mn:000023B3                 sub     esp, 18h
.text$mn:000023B6                 mov     [ebp+var_4], ecx
.text$mn:000023B9                 mov     ecx, [ebp+var_4] ; this
.text$mn:000023BC                 call    ?ClearError@TiXmlDocumentA@@QAEXXZ ; TiXmlDocumentA::ClearError(void)
.text$mn:000023C1                 cmp     [ebp+arg_0], 0
.text$mn:000023C5                 jz      short loc_23D1
.text$mn:000023C7                 mov     eax, [ebp+arg_0]
.text$mn:000023CA                 movsx   ecx, byte ptr [eax]
.text$mn:000023CD                 test    ecx, ecx
.text$mn:000023CF                 jnz     short loc_23E6
.text$mn:000023D1
.text$mn:000023D1 loc_23D1:                               ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+15j
.text$mn:000023D1                 push    0               ; struct TiXmlParsingDataA *
.text$mn:000023D3                 push    0               ; char *
.text$mn:000023D5                 push    0Dh             ; int
.text$mn:000023D7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000023DA                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:000023DF                 xor     eax, eax
.text$mn:000023E1                 jmp     loc_24E5
.text$mn:000023E6 ; ---------------------------------------------------------------------------
.text$mn:000023E6
.text$mn:000023E6 loc_23E6:                               ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+1Fj
.text$mn:000023E6                 mov     ecx, [ebp+var_4]
.text$mn:000023E9                 add     ecx, 4          ; this
.text$mn:000023EC                 call    ?Clear@TiXmlCursorA@@QAEXXZ ; TiXmlCursorA::Clear(void)
.text$mn:000023F1                 cmp     [ebp+arg_4], 0
.text$mn:000023F5                 jz      short loc_2410
.text$mn:000023F7                 mov     edx, [ebp+var_4]
.text$mn:000023FA                 mov     eax, [ebp+arg_4]
.text$mn:000023FD                 mov     ecx, [eax]
.text$mn:000023FF                 mov     [edx+4], ecx
.text$mn:00002402                 mov     edx, [ebp+var_4]
.text$mn:00002405                 mov     eax, [ebp+arg_4]
.text$mn:00002408                 mov     ecx, [eax+4]
.text$mn:0000240B                 mov     [edx+8], ecx
.text$mn:0000240E                 jmp     short loc_2424
.text$mn:00002410 ; ---------------------------------------------------------------------------
.text$mn:00002410
.text$mn:00002410 loc_2410:                               ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+45j
.text$mn:00002410                 mov     edx, [ebp+var_4]
.text$mn:00002413                 mov     dword ptr [edx+4], 0
.text$mn:0000241A                 mov     eax, [ebp+var_4]
.text$mn:0000241D                 mov     dword ptr [eax+8], 0
.text$mn:00002424
.text$mn:00002424 loc_2424:                               ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+5Ej
.text$mn:00002424                 mov     ecx, [ebp+var_4]
.text$mn:00002427                 mov     edx, [ecx+8]
.text$mn:0000242A                 push    edx
.text$mn:0000242B                 mov     eax, [ebp+var_4]
.text$mn:0000242E                 mov     ecx, [eax+4]
.text$mn:00002431                 push    ecx
.text$mn:00002432                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002435                 call    ?TabSize@TiXmlDocumentA@@QBEHXZ ; TiXmlDocumentA::TabSize(void)
.text$mn:0000243A                 push    eax
.text$mn:0000243B                 mov     edx, [ebp+arg_0]
.text$mn:0000243E                 push    edx
.text$mn:0000243F                 lea     ecx, [ebp+var_18]
.text$mn:00002442                 call    ??0TiXmlParsingDataA@@AAE@PBDHHH@Z ; TiXmlParsingDataA::TiXmlParsingDataA(char const *,int,int,int)
.text$mn:00002447                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000244A                 call    ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ ; TiXmlParsingDataA::Cursor(void)
.text$mn:0000244F                 mov     ecx, [eax]
.text$mn:00002451                 mov     edx, [eax+4]
.text$mn:00002454                 mov     eax, [ebp+var_4]
.text$mn:00002457                 mov     [eax+4], ecx
.text$mn:0000245A                 mov     [eax+8], edx
.text$mn:0000245D                 mov     ecx, [ebp+arg_0]
.text$mn:00002460                 push    ecx             ; char *
.text$mn:00002461                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:00002466                 add     esp, 4
.text$mn:00002469                 mov     [ebp+arg_0], eax
.text$mn:0000246C                 cmp     [ebp+arg_0], 0
.text$mn:00002470                 jnz     short loc_2484
.text$mn:00002472                 push    0               ; struct TiXmlParsingDataA *
.text$mn:00002474                 push    0               ; char *
.text$mn:00002476                 push    0Dh             ; int
.text$mn:00002478                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000247B                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:00002480                 xor     eax, eax
.text$mn:00002482                 jmp     short loc_24E5
.text$mn:00002484 ; ---------------------------------------------------------------------------
.text$mn:00002484
.text$mn:00002484 loc_2484:                               ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+C0j
.text$mn:00002484                                         ; TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+130j
.text$mn:00002484                 cmp     [ebp+arg_0], 0
.text$mn:00002488                 jz      short loc_24E2
.text$mn:0000248A                 mov     edx, [ebp+arg_0]
.text$mn:0000248D                 movsx   eax, byte ptr [edx]
.text$mn:00002490                 test    eax, eax
.text$mn:00002492                 jz      short loc_24E2
.text$mn:00002494                 mov     ecx, [ebp+arg_0]
.text$mn:00002497                 push    ecx             ; char *
.text$mn:00002498                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000249B                 call    ?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z ; TiXmlNodeA::Identify(char const *)
.text$mn:000024A0                 mov     [ebp+var_8], eax
.text$mn:000024A3                 cmp     [ebp+var_8], 0
.text$mn:000024A7                 jz      short loc_24CF
.text$mn:000024A9                 lea     edx, [ebp+var_18]
.text$mn:000024AC                 push    edx
.text$mn:000024AD                 mov     eax, [ebp+arg_0]
.text$mn:000024B0                 push    eax
.text$mn:000024B1                 mov     ecx, [ebp+var_8]
.text$mn:000024B4                 mov     edx, [ecx]
.text$mn:000024B6                 mov     ecx, [ebp+var_8]
.text$mn:000024B9                 mov     eax, [edx+0Ch]
.text$mn:000024BC                 call    eax
.text$mn:000024BE                 mov     [ebp+arg_0], eax
.text$mn:000024C1                 mov     ecx, [ebp+var_8]
.text$mn:000024C4                 push    ecx             ; struct TiXmlNodeA *
.text$mn:000024C5                 mov     ecx, [ebp+var_4] ; this
.text$mn:000024C8                 call    ?LinkEndChild@TiXmlNodeA@@QAEPAV1@PAV1@@Z ; TiXmlNodeA::LinkEndChild(TiXmlNodeA *)
.text$mn:000024CD                 jmp     short loc_24D1
.text$mn:000024CF ; ---------------------------------------------------------------------------
.text$mn:000024CF
.text$mn:000024CF loc_24CF:                               ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+F7j
.text$mn:000024CF                 jmp     short loc_24E2
.text$mn:000024D1 ; ---------------------------------------------------------------------------
.text$mn:000024D1
.text$mn:000024D1 loc_24D1:                               ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+11Dj
.text$mn:000024D1                 mov     edx, [ebp+arg_0]
.text$mn:000024D4                 push    edx             ; char *
.text$mn:000024D5                 call    ?SkipWhiteSpace@TiXmlBaseA@@KAPBDPBD@Z ; TiXmlBaseA::SkipWhiteSpace(char const *)
.text$mn:000024DA                 add     esp, 4
.text$mn:000024DD                 mov     [ebp+arg_0], eax
.text$mn:000024E0                 jmp     short loc_2484
.text$mn:000024E2 ; ---------------------------------------------------------------------------
.text$mn:000024E2
.text$mn:000024E2 loc_24E2:                               ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+D8j
.text$mn:000024E2                                         ; TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+E2j ...
.text$mn:000024E2                 mov     eax, [ebp+arg_0]
.text$mn:000024E5
.text$mn:000024E5 loc_24E5:                               ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+31j
.text$mn:000024E5                                         ; TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+D2j
.text$mn:000024E5                 mov     esp, ebp
.text$mn:000024E7                 pop     ebp
.text$mn:000024E8                 retn    8
.text$mn:000024E8 ?Parse@TiXmlDocumentA@@UAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$mn:000024E8
.text$mn:000024E8 ; ---------------------------------------------------------------------------
.text$mn:000024EB                 align 10h
.text$mn:000024F0
.text$mn:000024F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024F0
.text$mn:000024F0 ; Attributes: bp-based frame
.text$mn:000024F0
.text$mn:000024F0 ; void __thiscall TiXmlDocumentA::SetError(TiXmlDocumentA *this, int, const char *, struct TiXmlParsingDataA *)
.text$mn:000024F0                 public ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z
.text$mn:000024F0 ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z proc near
.text$mn:000024F0                                         ; CODE XREF: TiXmlNodeA::Identify(char const *)+22Cp
.text$mn:000024F0                                         ; TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+BAp ...
.text$mn:000024F0
.text$mn:000024F0 var_4           = dword ptr -4
.text$mn:000024F0 arg_0           = dword ptr  8
.text$mn:000024F0 arg_4           = dword ptr  0Ch
.text$mn:000024F0 arg_8           = dword ptr  10h
.text$mn:000024F0
.text$mn:000024F0                 push    ebp
.text$mn:000024F1                 mov     ebp, esp
.text$mn:000024F3                 push    ecx
.text$mn:000024F4                 mov     [ebp+var_4], ecx
.text$mn:000024F7                 mov     eax, [ebp+var_4]
.text$mn:000024FA                 movzx   ecx, byte ptr [eax+44h]
.text$mn:000024FE                 test    ecx, ecx
.text$mn:00002500                 jz      short loc_2507
.text$mn:00002502                 jmp     loc_258C
.text$mn:00002507 ; ---------------------------------------------------------------------------
.text$mn:00002507
.text$mn:00002507 loc_2507:                               ; CODE XREF: TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)+10j
.text$mn:00002507                 cmp     [ebp+arg_0], 0
.text$mn:0000250B                 jle     short loc_2513
.text$mn:0000250D                 cmp     [ebp+arg_0], 0Eh
.text$mn:00002511                 jl      short loc_252A
.text$mn:00002513
.text$mn:00002513 loc_2513:                               ; CODE XREF: TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)+1Bj
.text$mn:00002513                 push    1F8h            ; Line
.text$mn:00002518                 push    offset $SG94677 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:0000251D                 push    offset $SG94678 ; "err > 0 && err < TIXMLA_ERROR_STRING_CO"...
.text$mn:00002522                 call    __wassert
.text$mn:00002527 ; ---------------------------------------------------------------------------
.text$mn:00002527                 add     esp, 0Ch
.text$mn:0000252A
.text$mn:0000252A loc_252A:                               ; CODE XREF: TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)+21j
.text$mn:0000252A                 mov     eax, [ebp+var_4]
.text$mn:0000252D                 mov     byte ptr [eax+44h], 1
.text$mn:00002531                 mov     ecx, [ebp+var_4]
.text$mn:00002534                 mov     edx, [ebp+arg_0]
.text$mn:00002537                 mov     [ecx+48h], edx
.text$mn:0000253A                 mov     eax, [ebp+var_4]
.text$mn:0000253D                 mov     ecx, [eax+48h]
.text$mn:00002540                 mov     edx, dword ptr ds:?errorString@TiXmlBaseA@@1PAPBDA[ecx*4] ; char const * * TiXmlBaseA::errorString
.text$mn:00002547                 push    edx             ; Str
.text$mn:00002548                 mov     ecx, [ebp+var_4]
.text$mn:0000254B                 add     ecx, 4Ch ; 'L'
.text$mn:0000254E                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00002553                 mov     ecx, [ebp+var_4]
.text$mn:00002556                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:00002559                 call    ?Clear@TiXmlCursorA@@QAEXXZ ; TiXmlCursorA::Clear(void)
.text$mn:0000255E                 cmp     [ebp+arg_4], 0
.text$mn:00002562                 jz      short loc_258C
.text$mn:00002564                 cmp     [ebp+arg_8], 0
.text$mn:00002568                 jz      short loc_258C
.text$mn:0000256A                 mov     eax, [ebp+arg_4]
.text$mn:0000256D                 push    eax             ; char *
.text$mn:0000256E                 mov     ecx, [ebp+arg_8] ; this
.text$mn:00002571                 call    ?Stamp@TiXmlParsingDataA@@QAEXPBD@Z ; TiXmlParsingDataA::Stamp(char const *)
.text$mn:00002576                 mov     ecx, [ebp+arg_8] ; this
.text$mn:00002579                 call    ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ ; TiXmlParsingDataA::Cursor(void)
.text$mn:0000257E                 mov     ecx, [eax]
.text$mn:00002580                 mov     edx, [eax+4]
.text$mn:00002583                 mov     eax, [ebp+var_4]
.text$mn:00002586                 mov     [eax+6Ch], ecx
.text$mn:00002589                 mov     [eax+70h], edx
.text$mn:0000258C
.text$mn:0000258C loc_258C:                               ; CODE XREF: TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)+12j
.text$mn:0000258C                                         ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)+72j ...
.text$mn:0000258C                 mov     esp, ebp
.text$mn:0000258E                 pop     ebp
.text$mn:0000258F                 retn    0Ch
.text$mn:0000258F ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z endp
.text$mn:0000258F
.text$mn:0000258F ; ---------------------------------------------------------------------------
.text$mn:00002592                 align 10h
.text$mn:000025A0
.text$mn:000025A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025A0
.text$mn:000025A0 ; Attributes: bp-based frame
.text$mn:000025A0
.text$mn:000025A0 ; protected: virtual void __thiscall TiXmlDocumentA::StreamIn(class std::basic_istream<char, struct std::char_traits<char>> *, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> *)
.text$mn:000025A0                 public ?StreamIn@TiXmlDocumentA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.text$mn:000025A0 ?StreamIn@TiXmlDocumentA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z proc near
.text$mn:000025A0
.text$mn:000025A0 var_24          = dword ptr -24h
.text$mn:000025A0 var_20          = dword ptr -20h
.text$mn:000025A0 var_1C          = dword ptr -1Ch
.text$mn:000025A0 var_18          = dword ptr -18h
.text$mn:000025A0 var_14          = dword ptr -14h
.text$mn:000025A0 var_10          = dword ptr -10h
.text$mn:000025A0 var_C           = dword ptr -0Ch
.text$mn:000025A0 var_8           = dword ptr -8
.text$mn:000025A0 var_1           = byte ptr -1
.text$mn:000025A0 arg_0           = dword ptr  8
.text$mn:000025A0 arg_4           = dword ptr  0Ch
.text$mn:000025A0
.text$mn:000025A0                 push    ebp
.text$mn:000025A1                 mov     ebp, esp
.text$mn:000025A3                 sub     esp, 24h
.text$mn:000025A6                 mov     [ebp+var_C], ecx
.text$mn:000025A9                 mov     eax, [ebp+arg_4]
.text$mn:000025AC                 push    eax
.text$mn:000025AD                 push    3Ch ; '<'
.text$mn:000025AF                 mov     ecx, [ebp+arg_0]
.text$mn:000025B2                 push    ecx
.text$mn:000025B3                 call    ?StreamTo@TiXmlBaseA@@KA_NPAV?$basic_istream@DU?$char_traits@D@std@@@std@@HPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; TiXmlBaseA::StreamTo(std::basic_istream<char,std::char_traits<char>> *,int,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)
.text$mn:000025B8                 add     esp, 0Ch
.text$mn:000025BB                 movzx   edx, al
.text$mn:000025BE                 test    edx, edx
.text$mn:000025C0                 jnz     short loc_25D5
.text$mn:000025C2                 push    0               ; struct TiXmlParsingDataA *
.text$mn:000025C4                 push    0               ; char *
.text$mn:000025C6                 push    8               ; int
.text$mn:000025C8                 mov     ecx, [ebp+var_C] ; this
.text$mn:000025CB                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:000025D0                 jmp     loc_270C
.text$mn:000025D5 ; ---------------------------------------------------------------------------
.text$mn:000025D5
.text$mn:000025D5 loc_25D5:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+20j
.text$mn:000025D5                                         ; TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *):loc_26F9j
.text$mn:000025D5                 mov     eax, [ebp+arg_0]
.text$mn:000025D8                 mov     ecx, [eax]
.text$mn:000025DA                 mov     edx, [ebp+arg_0]
.text$mn:000025DD                 add     edx, [ecx+4]
.text$mn:000025E0                 mov     ecx, edx        ; this
.text$mn:000025E2                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:000025E7                 movzx   eax, al
.text$mn:000025EA                 test    eax, eax
.text$mn:000025EC                 jz      loc_26FE
.text$mn:000025F2                 mov     ecx, [ebp+arg_4]
.text$mn:000025F5                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:000025FA                 mov     [ebp+var_1C], eax
.text$mn:000025FD
.text$mn:000025FD loc_25FD:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+99j
.text$mn:000025FD                 mov     ecx, [ebp+arg_0]
.text$mn:00002600                 mov     edx, [ecx]
.text$mn:00002602                 mov     ecx, [ebp+arg_0]
.text$mn:00002605                 add     ecx, [edx+4]    ; this
.text$mn:00002608                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:0000260D                 movzx   eax, al
.text$mn:00002610                 test    eax, eax
.text$mn:00002612                 jz      short loc_263B
.text$mn:00002614                 mov     ecx, [ebp+arg_0]
.text$mn:00002617                 call    ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::peek(void)
.text$mn:0000261C                 cmp     eax, 3Eh ; '>'
.text$mn:0000261F                 jz      short loc_263B
.text$mn:00002621                 mov     ecx, [ebp+arg_0]
.text$mn:00002624                 call    ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_istream<char,std::char_traits<char>>::get(void)
.text$mn:00002629                 mov     [ebp+var_18], eax
.text$mn:0000262C                 movzx   ecx, byte ptr [ebp+var_18]
.text$mn:00002630                 push    ecx
.text$mn:00002631                 mov     ecx, [ebp+arg_4]
.text$mn:00002634                 call    ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)
.text$mn:00002639                 jmp     short loc_25FD
.text$mn:0000263B ; ---------------------------------------------------------------------------
.text$mn:0000263B
.text$mn:0000263B loc_263B:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+72j
.text$mn:0000263B                                         ; TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+7Fj
.text$mn:0000263B                 mov     edx, [ebp+arg_0]
.text$mn:0000263E                 mov     eax, [edx]
.text$mn:00002640                 mov     ecx, [ebp+arg_0]
.text$mn:00002643                 add     ecx, [eax+4]    ; this
.text$mn:00002646                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:0000264B                 movzx   ecx, al
.text$mn:0000264E                 test    ecx, ecx
.text$mn:00002650                 jz      loc_26F9
.text$mn:00002656                 mov     ecx, [ebp+arg_4]
.text$mn:00002659                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:0000265E                 add     eax, [ebp+var_1C]
.text$mn:00002661                 push    eax             ; char *
.text$mn:00002662                 mov     ecx, [ebp+var_C] ; this
.text$mn:00002665                 call    ?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z ; TiXmlNodeA::Identify(char const *)
.text$mn:0000266A                 mov     [ebp+var_8], eax
.text$mn:0000266D                 cmp     [ebp+var_8], 0
.text$mn:00002671                 jz      short loc_26E9
.text$mn:00002673                 mov     edx, [ebp+arg_4]
.text$mn:00002676                 push    edx
.text$mn:00002677                 mov     eax, [ebp+arg_0]
.text$mn:0000267A                 push    eax
.text$mn:0000267B                 mov     ecx, [ebp+var_8]
.text$mn:0000267E                 mov     edx, [ecx]
.text$mn:00002680                 mov     ecx, [ebp+var_8]
.text$mn:00002683                 mov     eax, [edx+18h]
.text$mn:00002686                 call    eax
.text$mn:00002688                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000268B                 call    ?ToElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@XZ ; TiXmlNodeA::ToElement(void)
.text$mn:00002690                 test    eax, eax
.text$mn:00002692                 jz      short loc_269D
.text$mn:00002694                 mov     [ebp+var_14], 1
.text$mn:0000269B                 jmp     short loc_26A4
.text$mn:0000269D ; ---------------------------------------------------------------------------
.text$mn:0000269D
.text$mn:0000269D loc_269D:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+F2j
.text$mn:0000269D                 mov     [ebp+var_14], 0
.text$mn:000026A4
.text$mn:000026A4 loc_26A4:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+FBj
.text$mn:000026A4                 mov     cl, byte ptr [ebp+var_14]
.text$mn:000026A7                 mov     [ebp+var_1], cl
.text$mn:000026AA                 mov     edx, [ebp+var_8]
.text$mn:000026AD                 mov     [ebp+var_20], edx
.text$mn:000026B0                 mov     eax, [ebp+var_20]
.text$mn:000026B3                 mov     [ebp+var_10], eax
.text$mn:000026B6                 cmp     [ebp+var_10], 0
.text$mn:000026BA                 jz      short loc_26CF
.text$mn:000026BC                 push    1
.text$mn:000026BE                 mov     ecx, [ebp+var_10]
.text$mn:000026C1                 mov     edx, [ecx]
.text$mn:000026C3                 mov     ecx, [ebp+var_10]
.text$mn:000026C6                 mov     eax, [edx]
.text$mn:000026C8                 call    eax
.text$mn:000026CA                 mov     [ebp+var_24], eax
.text$mn:000026CD                 jmp     short loc_26D6
.text$mn:000026CF ; ---------------------------------------------------------------------------
.text$mn:000026CF
.text$mn:000026CF loc_26CF:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+11Aj
.text$mn:000026CF                 mov     [ebp+var_24], 0
.text$mn:000026D6
.text$mn:000026D6 loc_26D6:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+12Dj
.text$mn:000026D6                 mov     [ebp+var_8], 0
.text$mn:000026DD                 movzx   ecx, [ebp+var_1]
.text$mn:000026E1                 test    ecx, ecx
.text$mn:000026E3                 jz      short loc_26E7
.text$mn:000026E5                 jmp     short loc_270C
.text$mn:000026E7 ; ---------------------------------------------------------------------------
.text$mn:000026E7
.text$mn:000026E7 loc_26E7:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+143j
.text$mn:000026E7                 jmp     short loc_26F9
.text$mn:000026E9 ; ---------------------------------------------------------------------------
.text$mn:000026E9
.text$mn:000026E9 loc_26E9:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+D1j
.text$mn:000026E9                 push    0               ; struct TiXmlParsingDataA *
.text$mn:000026EB                 push    0               ; char *
.text$mn:000026ED                 push    1               ; int
.text$mn:000026EF                 mov     ecx, [ebp+var_C] ; this
.text$mn:000026F2                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:000026F7                 jmp     short loc_270C
.text$mn:000026F9 ; ---------------------------------------------------------------------------
.text$mn:000026F9
.text$mn:000026F9 loc_26F9:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+B0j
.text$mn:000026F9                                         ; TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *):loc_26E7j
.text$mn:000026F9                 jmp     loc_25D5
.text$mn:000026FE ; ---------------------------------------------------------------------------
.text$mn:000026FE
.text$mn:000026FE loc_26FE:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+4Cj
.text$mn:000026FE                 push    0               ; struct TiXmlParsingDataA *
.text$mn:00002700                 push    0               ; char *
.text$mn:00002702                 push    1               ; int
.text$mn:00002704                 mov     ecx, [ebp+var_C] ; this
.text$mn:00002707                 call    ?SetError@TiXmlDocumentA@@QAEXHPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)
.text$mn:0000270C
.text$mn:0000270C loc_270C:                               ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+30j
.text$mn:0000270C                                         ; TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+145j ...
.text$mn:0000270C                 mov     esp, ebp
.text$mn:0000270E                 pop     ebp
.text$mn:0000270F                 retn    8
.text$mn:0000270F ?StreamIn@TiXmlDocumentA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z endp
.text$mn:0000270F
.text$mn:0000270F ; ---------------------------------------------------------------------------
.text$mn:00002712                 align 10h
.text$mn:00002720
.text$mn:00002720 ; =============== S U B R O U T I N E =======================================
.text$mn:00002720
.text$mn:00002720 ; Attributes: bp-based frame
.text$mn:00002720
.text$mn:00002720 ; void __thiscall TiXmlParsingDataA::Stamp(TiXmlParsingDataA *this, const char *)
.text$mn:00002720                 public ?Stamp@TiXmlParsingDataA@@QAEXPBD@Z
.text$mn:00002720 ?Stamp@TiXmlParsingDataA@@QAEXPBD@Z proc near
.text$mn:00002720                                         ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+5Ap
.text$mn:00002720                                         ; TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+80p ...
.text$mn:00002720
.text$mn:00002720 var_14          = dword ptr -14h
.text$mn:00002720 var_10          = dword ptr -10h
.text$mn:00002720 var_C           = dword ptr -0Ch
.text$mn:00002720 var_8           = dword ptr -8
.text$mn:00002720 var_4           = dword ptr -4
.text$mn:00002720 arg_0           = dword ptr  8
.text$mn:00002720
.text$mn:00002720                 push    ebp
.text$mn:00002721                 mov     ebp, esp
.text$mn:00002723                 sub     esp, 14h
.text$mn:00002726                 mov     [ebp+var_8], ecx
.text$mn:00002729                 cmp     [ebp+arg_0], 0
.text$mn:0000272D                 jnz     short loc_2743
.text$mn:0000272F                 push    48h ; 'H'       ; Line
.text$mn:00002731                 push    offset $SG94463 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:00002736                 push    offset $SG94464 ; "now"
.text$mn:0000273B                 call    __wassert
.text$mn:00002740 ; ---------------------------------------------------------------------------
.text$mn:00002740                 add     esp, 0Ch
.text$mn:00002743
.text$mn:00002743 loc_2743:                               ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+Dj
.text$mn:00002743                 mov     ecx, [ebp+var_8]
.text$mn:00002746                 cmp     dword ptr [ecx+0Ch], 1
.text$mn:0000274A                 jge     short loc_2751
.text$mn:0000274C                 jmp     loc_28CA
.text$mn:00002751 ; ---------------------------------------------------------------------------
.text$mn:00002751
.text$mn:00002751 loc_2751:                               ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+2Aj
.text$mn:00002751                 mov     edx, [ebp+var_8]
.text$mn:00002754                 mov     eax, [edx]
.text$mn:00002756                 mov     [ebp+var_10], eax
.text$mn:00002759                 mov     ecx, [ebp+var_8]
.text$mn:0000275C                 mov     edx, [ecx+4]
.text$mn:0000275F                 mov     [ebp+var_C], edx
.text$mn:00002762                 mov     eax, [ebp+var_8]
.text$mn:00002765                 mov     ecx, [eax+8]
.text$mn:00002768                 mov     [ebp+var_4], ecx
.text$mn:0000276B                 cmp     [ebp+var_4], 0
.text$mn:0000276F                 jnz     short loc_2785
.text$mn:00002771                 push    54h ; 'T'       ; Line
.text$mn:00002773                 push    offset $SG94470 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:00002778                 push    offset $SG94471 ; Message
.text$mn:0000277D                 call    __wassert
.text$mn:00002782 ; ---------------------------------------------------------------------------
.text$mn:00002782                 add     esp, 0Ch
.text$mn:00002785
.text$mn:00002785 loc_2785:                               ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+4Fj
.text$mn:00002785                                         ; TiXmlParsingDataA::Stamp(char const *):loc_284Cj
.text$mn:00002785                 mov     eax, [ebp+var_4]
.text$mn:00002788                 cmp     eax, [ebp+arg_0]
.text$mn:0000278B                 jnb     loc_2851
.text$mn:00002791                 mov     ecx, [ebp+var_4]
.text$mn:00002794                 movsx   edx, byte ptr [ecx]
.text$mn:00002797                 mov     [ebp+var_14], edx
.text$mn:0000279A                 cmp     [ebp+var_14], 0Dh ; switch 14 cases
.text$mn:0000279E                 ja      $LN1            ; jumptable 000027AE default case
.text$mn:000027A4                 mov     eax, [ebp+var_14]
.text$mn:000027A7                 movzx   ecx, ds:$LN20[eax]
.text$mn:000027AE                 jmp     ds:$LN21[ecx*4] ; switch jump
.text$mn:000027B5 ; ---------------------------------------------------------------------------
.text$mn:000027B5
.text$mn:000027B5 $LN7_0:                                 ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+8Ej
.text$mn:000027B5                                         ; DATA XREF: .text$mn:$LN21o
.text$mn:000027B5                 jmp     loc_28CA        ; jumptable 000027AE case 0
.text$mn:000027BA ; ---------------------------------------------------------------------------
.text$mn:000027BA
.text$mn:000027BA $LN6_2:                                 ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+8Ej
.text$mn:000027BA                                         ; DATA XREF: .text$mn:$LN21o
.text$mn:000027BA                 mov     edx, [ebp+var_10] ; jumptable 000027AE case 13
.text$mn:000027BD                 add     edx, 1
.text$mn:000027C0                 mov     [ebp+var_10], edx
.text$mn:000027C3                 mov     [ebp+var_C], 0
.text$mn:000027CA                 mov     eax, [ebp+var_4]
.text$mn:000027CD                 add     eax, 1
.text$mn:000027D0                 mov     [ebp+var_4], eax
.text$mn:000027D3                 mov     ecx, [ebp+var_4]
.text$mn:000027D6                 movsx   edx, byte ptr [ecx]
.text$mn:000027D9                 cmp     edx, 0Ah
.text$mn:000027DC                 jnz     short loc_27E7
.text$mn:000027DE                 mov     eax, [ebp+var_4]
.text$mn:000027E1                 add     eax, 1
.text$mn:000027E4                 mov     [ebp+var_4], eax
.text$mn:000027E7
.text$mn:000027E7 loc_27E7:                               ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+BCj
.text$mn:000027E7                 jmp     short loc_284C
.text$mn:000027E9 ; ---------------------------------------------------------------------------
.text$mn:000027E9
.text$mn:000027E9 $LN4_1:                                 ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+8Ej
.text$mn:000027E9                                         ; DATA XREF: .text$mn:$LN21o
.text$mn:000027E9                 mov     ecx, [ebp+var_10] ; jumptable 000027AE case 10
.text$mn:000027EC                 add     ecx, 1
.text$mn:000027EF                 mov     [ebp+var_10], ecx
.text$mn:000027F2                 mov     [ebp+var_C], 0
.text$mn:000027F9                 mov     edx, [ebp+var_4]
.text$mn:000027FC                 add     edx, 1
.text$mn:000027FF                 mov     [ebp+var_4], edx
.text$mn:00002802                 mov     eax, [ebp+var_4]
.text$mn:00002805                 movsx   ecx, byte ptr [eax]
.text$mn:00002808                 cmp     ecx, 0Dh
.text$mn:0000280B                 jnz     short loc_2816
.text$mn:0000280D                 mov     edx, [ebp+var_4]
.text$mn:00002810                 add     edx, 1
.text$mn:00002813                 mov     [ebp+var_4], edx
.text$mn:00002816
.text$mn:00002816 loc_2816:                               ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+EBj
.text$mn:00002816                 jmp     short loc_284C
.text$mn:00002818 ; ---------------------------------------------------------------------------
.text$mn:00002818
.text$mn:00002818 $LN2:                                   ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+8Ej
.text$mn:00002818                                         ; DATA XREF: .text$mn:$LN21o
.text$mn:00002818                 mov     eax, [ebp+var_4] ; jumptable 000027AE case 9
.text$mn:0000281B                 add     eax, 1
.text$mn:0000281E                 mov     [ebp+var_4], eax
.text$mn:00002821                 mov     ecx, [ebp+var_8]
.text$mn:00002824                 mov     eax, [ebp+var_C]
.text$mn:00002827                 cdq
.text$mn:00002828                 idiv    dword ptr [ecx+0Ch]
.text$mn:0000282B                 add     eax, 1
.text$mn:0000282E                 mov     edx, [ebp+var_8]
.text$mn:00002831                 imul    eax, [edx+0Ch]
.text$mn:00002835                 mov     [ebp+var_C], eax
.text$mn:00002838                 jmp     short loc_284C
.text$mn:0000283A ; ---------------------------------------------------------------------------
.text$mn:0000283A
.text$mn:0000283A $LN1:                                   ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+7Ej
.text$mn:0000283A                                         ; TiXmlParsingDataA::Stamp(char const *)+8Ej
.text$mn:0000283A                                         ; DATA XREF: ...
.text$mn:0000283A                 mov     eax, [ebp+var_4] ; jumptable 000027AE default case
.text$mn:0000283D                 add     eax, 1
.text$mn:00002840                 mov     [ebp+var_4], eax
.text$mn:00002843                 mov     ecx, [ebp+var_C]
.text$mn:00002846                 add     ecx, 1
.text$mn:00002849                 mov     [ebp+var_C], ecx
.text$mn:0000284C
.text$mn:0000284C loc_284C:                               ; CODE XREF: TiXmlParsingDataA::Stamp(char const *):loc_27E7j
.text$mn:0000284C                                         ; TiXmlParsingDataA::Stamp(char const *):loc_2816j ...
.text$mn:0000284C                 jmp     loc_2785
.text$mn:00002851 ; ---------------------------------------------------------------------------
.text$mn:00002851
.text$mn:00002851 loc_2851:                               ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+6Bj
.text$mn:00002851                 mov     edx, [ebp+var_8]
.text$mn:00002854                 mov     eax, [ebp+var_10]
.text$mn:00002857                 mov     [edx], eax
.text$mn:00002859                 mov     ecx, [ebp+var_8]
.text$mn:0000285C                 mov     edx, [ebp+var_C]
.text$mn:0000285F                 mov     [ecx+4], edx
.text$mn:00002862                 mov     eax, [ebp+var_8]
.text$mn:00002865                 cmp     dword ptr [eax], 0FFFFFFFFh
.text$mn:00002868                 jge     short loc_2881
.text$mn:0000286A                 push    8Fh ; 'Ã'       ; Line
.text$mn:0000286F                 push    offset $SG94487 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:00002874                 push    offset $SG94488 ; "cursor.row >= -1"
.text$mn:00002879                 call    __wassert
.text$mn:0000287E ; ---------------------------------------------------------------------------
.text$mn:0000287E                 add     esp, 0Ch
.text$mn:00002881
.text$mn:00002881 loc_2881:                               ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+148j
.text$mn:00002881                 mov     edx, [ebp+var_8]
.text$mn:00002884                 cmp     dword ptr [edx+4], 0FFFFFFFFh
.text$mn:00002888                 jge     short loc_28A1
.text$mn:0000288A                 push    90h ; 'Ã'       ; Line
.text$mn:0000288F                 push    offset $SG94490 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:00002894                 push    offset $SG94491 ; "cursor.col >= -1"
.text$mn:00002899                 call    __wassert
.text$mn:0000289E ; ---------------------------------------------------------------------------
.text$mn:0000289E                 add     esp, 0Ch
.text$mn:000028A1
.text$mn:000028A1 loc_28A1:                               ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+168j
.text$mn:000028A1                 mov     ecx, [ebp+var_8]
.text$mn:000028A4                 mov     edx, [ebp+var_4]
.text$mn:000028A7                 mov     [ecx+8], edx
.text$mn:000028AA                 mov     eax, [ebp+var_8]
.text$mn:000028AD                 cmp     dword ptr [eax+8], 0
.text$mn:000028B1                 jnz     short loc_28CA
.text$mn:000028B3                 push    92h ; 'Ã'       ; Line
.text$mn:000028B8                 push    offset $SG94493 ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:000028BD                 push    offset $SG94494 ; "stamp"
.text$mn:000028C2                 call    __wassert
.text$mn:000028C7 ; ---------------------------------------------------------------------------
.text$mn:000028C7                 add     esp, 0Ch
.text$mn:000028CA
.text$mn:000028CA loc_28CA:                               ; CODE XREF: TiXmlParsingDataA::Stamp(char const *)+2Cj
.text$mn:000028CA                                         ; TiXmlParsingDataA::Stamp(char const *):$LN7_0j ...
.text$mn:000028CA                 mov     esp, ebp
.text$mn:000028CC                 pop     ebp
.text$mn:000028CD                 retn    4
.text$mn:000028CD ?Stamp@TiXmlParsingDataA@@QAEXPBD@Z endp
.text$mn:000028CD
.text$mn:000028CD ; ---------------------------------------------------------------------------
.text$mn:000028D0 $LN21           dd offset $LN7_0        ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+8Er
.text$mn:000028D0                 dd offset $LN2          ; jump table for switch statement
.text$mn:000028D0                 dd offset $LN4_1
.text$mn:000028D0                 dd offset $LN6_2
.text$mn:000028D0                 dd offset $LN1
.text$mn:000028E4 $LN20           db      0,     4,     4,     4
.text$mn:000028E4                                         ; DATA XREF: TiXmlParsingDataA::Stamp(char const *)+87r
.text$mn:000028E4                 db      4,     4,     4,     4 ; indirect table for switch statement
.text$mn:000028E4                 db      4,     1,     2,     4
.text$mn:000028E4                 db      4,     3
.text$mn:000028F2                 align 4
.text$mn:000028F2 _text$mn        ends
.text$mn:000028F2
.text$x:000028F4 ; ===========================================================================
.text$x:000028F4
.text$x:000028F4 ; Segment type: Pure code
.text$x:000028F4 ; Segment permissions: Read/Execute
.text$x:000028F4 _text$x         segment para public 'CODE' use32
.text$x:000028F4                 assume cs:_text$x
.text$x:000028F4                 ;org 28F4h
.text$x:000028F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000028F4
.text$x:000028F4 ; =============== S U B R O U T I N E =======================================
.text$x:000028F4
.text$x:000028F4
.text$x:000028F4 __unwindfunclet$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z$0 proc near
.text$x:000028F4                                         ; DATA XREF: .xdata$x:00008844o
.text$x:000028F4                 lea     ecx, [ebp-2Ch]
.text$x:000028F7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000028F7 __unwindfunclet$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z$0 endp
.text$x:000028F7
.text$x:000028FC
.text$x:000028FC ; =============== S U B R O U T I N E =======================================
.text$x:000028FC
.text$x:000028FC
.text$x:000028FC __ehhandler$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z proc near
.text$x:000028FC                                         ; DATA XREF: TiXmlBaseA::GetEntity(char const *,char *)+5o
.text$x:000028FC
.text$x:000028FC arg_4           = dword ptr  8
.text$x:000028FC
.text$x:000028FC                 mov     edx, [esp+arg_4]
.text$x:00002900                 lea     eax, [edx+0Ch]
.text$x:00002903                 mov     ecx, [edx-38h]
.text$x:00002906                 xor     ecx, eax
.text$x:00002908                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000290D                 mov     ecx, [edx-4]
.text$x:00002910                 xor     ecx, eax
.text$x:00002912                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002917                 mov     eax, offset __ehfuncinfo$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z
.text$x:0000291C                 jmp     ___CxxFrameHandler3
.text$x:0000291C __ehhandler$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z endp
.text$x:0000291C
.text$x:00002921
.text$x:00002921 ; =============== S U B R O U T I N E =======================================
.text$x:00002921
.text$x:00002921
.text$x:00002921 __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$0 proc near
.text$x:00002921                                         ; DATA XREF: .xdata$x:00008874o
.text$x:00002921                 mov     eax, [ebp-14h]
.text$x:00002924                 push    eax             ; void *
.text$x:00002925                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000292A                 pop     ecx
.text$x:0000292B                 retn
.text$x:0000292B __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$0 endp
.text$x:0000292B
.text$x:0000292C
.text$x:0000292C ; =============== S U B R O U T I N E =======================================
.text$x:0000292C
.text$x:0000292C
.text$x:0000292C __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$1 proc near
.text$x:0000292C                                         ; DATA XREF: .xdata$x:0000887Co
.text$x:0000292C                 mov     eax, [ebp-1Ch]
.text$x:0000292F                 push    eax             ; void *
.text$x:00002930                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002935                 pop     ecx
.text$x:00002936                 retn
.text$x:00002936 __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$1 endp
.text$x:00002936
.text$x:00002937
.text$x:00002937 ; =============== S U B R O U T I N E =======================================
.text$x:00002937
.text$x:00002937
.text$x:00002937 __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$2 proc near
.text$x:00002937                                         ; DATA XREF: .xdata$x:00008884o
.text$x:00002937                 mov     eax, [ebp-24h]
.text$x:0000293A                 push    eax             ; void *
.text$x:0000293B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002940                 pop     ecx
.text$x:00002941                 retn
.text$x:00002941 __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$2 endp
.text$x:00002941
.text$x:00002942
.text$x:00002942 ; =============== S U B R O U T I N E =======================================
.text$x:00002942
.text$x:00002942
.text$x:00002942 __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$3 proc near
.text$x:00002942                                         ; DATA XREF: .xdata$x:0000888Co
.text$x:00002942                 mov     eax, [ebp-2Ch]
.text$x:00002945                 push    eax             ; void *
.text$x:00002946                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000294B                 pop     ecx
.text$x:0000294C                 retn
.text$x:0000294C __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$3 endp
.text$x:0000294C
.text$x:0000294D
.text$x:0000294D ; =============== S U B R O U T I N E =======================================
.text$x:0000294D
.text$x:0000294D
.text$x:0000294D __ehhandler$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z proc near
.text$x:0000294D                                         ; DATA XREF: TiXmlNodeA::Identify(char const *)+5o
.text$x:0000294D
.text$x:0000294D arg_4           = dword ptr  8
.text$x:0000294D
.text$x:0000294D                 mov     edx, [esp+arg_4]
.text$x:00002951                 lea     eax, [edx+0Ch]
.text$x:00002954                 mov     ecx, [edx-48h]
.text$x:00002957                 xor     ecx, eax
.text$x:00002959                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000295E                 mov     eax, offset __ehfuncinfo$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z
.text$x:00002963                 jmp     ___CxxFrameHandler3
.text$x:00002963 __ehhandler$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z endp
.text$x:00002963
.text$x:00002968
.text$x:00002968 ; =============== S U B R O U T I N E =======================================
.text$x:00002968
.text$x:00002968
.text$x:00002968 __unwindfunclet$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$0 proc near
.text$x:00002968                                         ; DATA XREF: .xdata$x:0000883Co
.text$x:00002968                 lea     ecx, [ebp-54h]  ; this
.text$x:0000296B                 jmp     ??1TiXmlTextA@@UAE@XZ ; TiXmlTextA::~TiXmlTextA(void)
.text$x:0000296B __unwindfunclet$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$0 endp
.text$x:0000296B
.text$x:00002970
.text$x:00002970 ; =============== S U B R O U T I N E =======================================
.text$x:00002970
.text$x:00002970
.text$x:00002970 __ehhandler$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z proc near
.text$x:00002970                                         ; DATA XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+5o
.text$x:00002970
.text$x:00002970 arg_4           = dword ptr  8
.text$x:00002970
.text$x:00002970                 mov     edx, [esp+arg_4]
.text$x:00002974                 lea     eax, [edx+0Ch]
.text$x:00002977                 mov     ecx, [edx-78h]
.text$x:0000297A                 xor     ecx, eax
.text$x:0000297C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002981                 mov     ecx, [edx-4]
.text$x:00002984                 xor     ecx, eax
.text$x:00002986                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000298B                 mov     eax, offset __ehfuncinfo$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.text$x:00002990                 jmp     ___CxxFrameHandler3
.text$x:00002990 __ehhandler$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z endp
.text$x:00002990
.text$x:00002995
.text$x:00002995 ; =============== S U B R O U T I N E =======================================
.text$x:00002995
.text$x:00002995
.text$x:00002995 __unwindfunclet$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$0 proc near
.text$x:00002995                                         ; DATA XREF: .xdata$x:0000884Co
.text$x:00002995                 lea     ecx, [ebp-2Ch]
.text$x:00002998                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002998 __unwindfunclet$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$0 endp
.text$x:00002998
.text$x:0000299D
.text$x:0000299D ; =============== S U B R O U T I N E =======================================
.text$x:0000299D
.text$x:0000299D
.text$x:0000299D __unwindfunclet$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$1 proc near
.text$x:0000299D                                         ; DATA XREF: .xdata$x:00008854o
.text$x:0000299D                 mov     eax, [ebp-50h]
.text$x:000029A0                 push    eax             ; void *
.text$x:000029A1                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000029A6                 pop     ecx
.text$x:000029A7                 retn
.text$x:000029A7 __unwindfunclet$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$1 endp
.text$x:000029A7
.text$x:000029A8
.text$x:000029A8 ; =============== S U B R O U T I N E =======================================
.text$x:000029A8
.text$x:000029A8
.text$x:000029A8 __ehhandler$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$x:000029A8                                         ; DATA XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+5o
.text$x:000029A8
.text$x:000029A8 arg_4           = dword ptr  8
.text$x:000029A8
.text$x:000029A8                 mov     edx, [esp+arg_4]
.text$x:000029AC                 lea     eax, [edx+0Ch]
.text$x:000029AF                 mov     ecx, [edx-88h]
.text$x:000029B5                 xor     ecx, eax
.text$x:000029B7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029BC                 mov     ecx, [edx-4]
.text$x:000029BF                 xor     ecx, eax
.text$x:000029C1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029C6                 mov     eax, offset __ehfuncinfo$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$x:000029CB                 jmp     ___CxxFrameHandler3
.text$x:000029CB __ehhandler$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$x:000029CB
.text$x:000029D0
.text$x:000029D0 ; =============== S U B R O U T I N E =======================================
.text$x:000029D0
.text$x:000029D0
.text$x:000029D0 __unwindfunclet$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z$0 proc near
.text$x:000029D0                                         ; DATA XREF: .xdata$x:00008834o
.text$x:000029D0                 mov     eax, [ebp-24h]
.text$x:000029D3                 push    eax             ; void *
.text$x:000029D4                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000029D9                 pop     ecx
.text$x:000029DA                 retn
.text$x:000029DA __unwindfunclet$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z$0 endp
.text$x:000029DA
.text$x:000029DB
.text$x:000029DB ; =============== S U B R O U T I N E =======================================
.text$x:000029DB
.text$x:000029DB
.text$x:000029DB __ehhandler$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$x:000029DB                                         ; DATA XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+5o
.text$x:000029DB
.text$x:000029DB arg_4           = dword ptr  8
.text$x:000029DB
.text$x:000029DB                 mov     edx, [esp+arg_4]
.text$x:000029DF                 lea     eax, [edx+0Ch]
.text$x:000029E2                 mov     ecx, [edx-2Ch]
.text$x:000029E5                 xor     ecx, eax
.text$x:000029E7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029EC                 mov     eax, offset __ehfuncinfo$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$x:000029F1                 jmp     ___CxxFrameHandler3
.text$x:000029F1 __ehhandler$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$x:000029F1
.text$x:000029F6
.text$x:000029F6 ; =============== S U B R O U T I N E =======================================
.text$x:000029F6
.text$x:000029F6
.text$x:000029F6 __unwindfunclet$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$0 proc near
.text$x:000029F6                                         ; DATA XREF: .xdata$x:0000885Co
.text$x:000029F6                 lea     ecx, [ebp-60h]  ; this
.text$x:000029F9                 jmp     ??1TiXmlAttributeA@@UAE@XZ ; TiXmlAttributeA::~TiXmlAttributeA(void)
.text$x:000029F9 __unwindfunclet$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$0 endp
.text$x:000029F9
.text$x:000029FE
.text$x:000029FE ; =============== S U B R O U T I N E =======================================
.text$x:000029FE
.text$x:000029FE
.text$x:000029FE __unwindfunclet$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$1 proc near
.text$x:000029FE                                         ; DATA XREF: .xdata$x:00008864o
.text$x:000029FE                 lea     ecx, [ebp-100h] ; this
.text$x:00002A04                 jmp     ??1TiXmlAttributeA@@UAE@XZ ; TiXmlAttributeA::~TiXmlAttributeA(void)
.text$x:00002A04 __unwindfunclet$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$1 endp
.text$x:00002A04
.text$x:00002A09
.text$x:00002A09 ; =============== S U B R O U T I N E =======================================
.text$x:00002A09
.text$x:00002A09
.text$x:00002A09 __unwindfunclet$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$2 proc near
.text$x:00002A09                                         ; DATA XREF: .xdata$x:0000886Co
.text$x:00002A09                 lea     ecx, [ebp-0B0h] ; this
.text$x:00002A0F                 jmp     ??1TiXmlAttributeA@@UAE@XZ ; TiXmlAttributeA::~TiXmlAttributeA(void)
.text$x:00002A0F __unwindfunclet$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$2 endp
.text$x:00002A0F
.text$x:00002A14
.text$x:00002A14 ; =============== S U B R O U T I N E =======================================
.text$x:00002A14
.text$x:00002A14
.text$x:00002A14 __ehhandler$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z proc near
.text$x:00002A14                                         ; DATA XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+5o
.text$x:00002A14
.text$x:00002A14 arg_4           = dword ptr  8
.text$x:00002A14
.text$x:00002A14                 mov     edx, [esp+arg_4]
.text$x:00002A18                 lea     eax, [edx+0Ch]
.text$x:00002A1B                 mov     ecx, [edx-100h]
.text$x:00002A21                 xor     ecx, eax
.text$x:00002A23                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A28                 mov     ecx, [edx-4]
.text$x:00002A2B                 xor     ecx, eax
.text$x:00002A2D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A32                 mov     eax, offset __ehfuncinfo$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.text$x:00002A37                 jmp     ___CxxFrameHandler3
.text$x:00002A37 __ehhandler$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z endp
.text$x:00002A37
.text$x:00002A37 _text$x         ends
.text$x:00002A37
.text$mn:00002A3C ; ===========================================================================
.text$mn:00002A3C
.text$mn:00002A3C ; Segment type: Pure code
.text$mn:00002A3C ; Segment permissions: Read/Execute
.text$mn:00002A3C _text$mn        segment para public 'CODE' use32
.text$mn:00002A3C                 assume cs:_text$mn
.text$mn:00002A3C                 ;org 2A3Ch
.text$mn:00002A3C ; COMDAT (pick any)
.text$mn:00002A3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A3C
.text$mn:00002A3C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A3C
.text$mn:00002A3C ; Attributes: bp-based frame
.text$mn:00002A3C
.text$mn:00002A3C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00002A3C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00002A3C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00002A3C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00002A3C
.text$mn:00002A3C var_4           = dword ptr -4
.text$mn:00002A3C arg_0           = dword ptr  8
.text$mn:00002A3C
.text$mn:00002A3C                 push    ebp
.text$mn:00002A3D                 mov     ebp, esp
.text$mn:00002A3F                 push    ecx
.text$mn:00002A40                 mov     [ebp+var_4], 0
.text$mn:00002A47                 cmp     [ebp+arg_0], 0
.text$mn:00002A4B                 jnz     short loc_2A4F
.text$mn:00002A4D                 jmp     short loc_2A6F
.text$mn:00002A4F ; ---------------------------------------------------------------------------
.text$mn:00002A4F
.text$mn:00002A4F loc_2A4F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00002A4F                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00002A53                 ja      short loc_2A6A
.text$mn:00002A55                 mov     eax, [ebp+arg_0]
.text$mn:00002A58                 push    eax             ; unsigned int
.text$mn:00002A59                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002A5E                 add     esp, 4
.text$mn:00002A61                 mov     [ebp+var_4], eax
.text$mn:00002A64                 cmp     [ebp+var_4], 0
.text$mn:00002A68                 jnz     short loc_2A6F
.text$mn:00002A6A
.text$mn:00002A6A loc_2A6A:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00002A6A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002A6F
.text$mn:00002A6F loc_2A6F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00002A6F                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00002A6F                 mov     eax, [ebp+var_4]
.text$mn:00002A72                 mov     esp, ebp
.text$mn:00002A74                 pop     ebp
.text$mn:00002A75                 retn
.text$mn:00002A75 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00002A75
.text$mn:00002A75 ; ---------------------------------------------------------------------------
.text$mn:00002A76                 align 4
.text$mn:00002A76 _text$mn        ends
.text$mn:00002A76
.text$mn:00002A78 ; ===========================================================================
.text$mn:00002A78
.text$mn:00002A78 ; Segment type: Pure code
.text$mn:00002A78 ; Segment permissions: Read/Execute
.text$mn:00002A78 _text$mn        segment para public 'CODE' use32
.text$mn:00002A78                 assume cs:_text$mn
.text$mn:00002A78                 ;org 2A78h
.text$mn:00002A78 ; COMDAT (pick any)
.text$mn:00002A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A78
.text$mn:00002A78 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A78
.text$mn:00002A78 ; Attributes: bp-based frame
.text$mn:00002A78
.text$mn:00002A78 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00002A78                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00002A78 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00002A78                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00002A78
.text$mn:00002A78 var_4           = dword ptr -4
.text$mn:00002A78 arg_0           = dword ptr  8
.text$mn:00002A78
.text$mn:00002A78                 push    ebp
.text$mn:00002A79                 mov     ebp, esp
.text$mn:00002A7B                 push    ecx
.text$mn:00002A7C                 mov     [ebp+var_4], 0
.text$mn:00002A83                 cmp     [ebp+arg_0], 0
.text$mn:00002A87                 jnz     short loc_2A8B
.text$mn:00002A89                 jmp     short loc_2AB1
.text$mn:00002A8B ; ---------------------------------------------------------------------------
.text$mn:00002A8B
.text$mn:00002A8B loc_2A8B:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00002A8B                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00002A92                 ja      short loc_2AAC
.text$mn:00002A94                 mov     eax, [ebp+arg_0]
.text$mn:00002A97                 shl     eax, 3
.text$mn:00002A9A                 push    eax             ; unsigned int
.text$mn:00002A9B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002AA0                 add     esp, 4
.text$mn:00002AA3                 mov     [ebp+var_4], eax
.text$mn:00002AA6                 cmp     [ebp+var_4], 0
.text$mn:00002AAA                 jnz     short loc_2AB1
.text$mn:00002AAC
.text$mn:00002AAC loc_2AAC:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00002AAC                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002AB1
.text$mn:00002AB1 loc_2AB1:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00002AB1                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00002AB1                 mov     eax, [ebp+var_4]
.text$mn:00002AB4                 mov     esp, ebp
.text$mn:00002AB6                 pop     ebp
.text$mn:00002AB7                 retn
.text$mn:00002AB7 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00002AB7
.text$mn:00002AB7 _text$mn        ends
.text$mn:00002AB7
.text$mn:00002AB8 ; ===========================================================================
.text$mn:00002AB8
.text$mn:00002AB8 ; Segment type: Pure code
.text$mn:00002AB8 ; Segment permissions: Read/Execute
.text$mn:00002AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AB8                 assume cs:_text$mn
.text$mn:00002AB8                 ;org 2AB8h
.text$mn:00002AB8 ; COMDAT (pick any)
.text$mn:00002AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AB8
.text$mn:00002AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AB8
.text$mn:00002AB8 ; Attributes: bp-based frame
.text$mn:00002AB8
.text$mn:00002AB8 ; int __cdecl std::_DebugHeapDelete<std::_Facet_base>(void *Memory)
.text$mn:00002AB8                 public ??$_DebugHeapDelete@V_Facet_base@std@@@std@@YAXPAV_Facet_base@0@@Z
.text$mn:00002AB8 ??$_DebugHeapDelete@V_Facet_base@std@@@std@@YAXPAV_Facet_base@0@@Z proc near
.text$mn:00002AB8                                         ; CODE XREF: std::locale::~locale(void)+21p
.text$mn:00002AB8
.text$mn:00002AB8 Memory          = dword ptr  8
.text$mn:00002AB8
.text$mn:00002AB8                 push    ebp
.text$mn:00002AB9                 mov     ebp, esp
.text$mn:00002ABB                 cmp     [ebp+Memory], 0
.text$mn:00002ABF                 jz      short loc_2ADB
.text$mn:00002AC1                 push    0
.text$mn:00002AC3                 mov     eax, [ebp+Memory]
.text$mn:00002AC6                 mov     edx, [eax]
.text$mn:00002AC8                 mov     ecx, [ebp+Memory]
.text$mn:00002ACB                 mov     eax, [edx]
.text$mn:00002ACD                 call    eax
.text$mn:00002ACF                 mov     ecx, [ebp+Memory]
.text$mn:00002AD2                 push    ecx             ; Memory
.text$mn:00002AD3                 call    _free
.text$mn:00002AD8                 add     esp, 4
.text$mn:00002ADB
.text$mn:00002ADB loc_2ADB:                               ; CODE XREF: std::_DebugHeapDelete<std::_Facet_base>(std::_Facet_base *)+7j
.text$mn:00002ADB                 pop     ebp
.text$mn:00002ADC                 retn
.text$mn:00002ADC ??$_DebugHeapDelete@V_Facet_base@std@@@std@@YAXPAV_Facet_base@0@@Z endp
.text$mn:00002ADC
.text$mn:00002ADC ; ---------------------------------------------------------------------------
.text$mn:00002ADD                 align 10h
.text$mn:00002ADD _text$mn        ends
.text$mn:00002ADD
.text$mn:00002AE0 ; ===========================================================================
.text$mn:00002AE0
.text$mn:00002AE0 ; Segment type: Pure code
.text$mn:00002AE0 ; Segment permissions: Read/Execute
.text$mn:00002AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00002AE0                 assume cs:_text$mn
.text$mn:00002AE0                 ;org 2AE0h
.text$mn:00002AE0 ; COMDAT (pick any)
.text$mn:00002AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AE0
.text$mn:00002AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AE0
.text$mn:00002AE0 ; Attributes: bp-based frame
.text$mn:00002AE0
.text$mn:00002AE0 ; int __cdecl std::_DebugHeapDelete<std::locale::facet>(void *Memory)
.text$mn:00002AE0                 public ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
.text$mn:00002AE0 ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z proc near
.text$mn:00002AE0                                         ; CODE XREF: std::locale::facet::operator delete(void *)+7p
.text$mn:00002AE0
.text$mn:00002AE0 Memory          = dword ptr  8
.text$mn:00002AE0
.text$mn:00002AE0                 push    ebp
.text$mn:00002AE1                 mov     ebp, esp
.text$mn:00002AE3                 cmp     [ebp+Memory], 0
.text$mn:00002AE7                 jz      short loc_2B03
.text$mn:00002AE9                 push    0
.text$mn:00002AEB                 mov     eax, [ebp+Memory]
.text$mn:00002AEE                 mov     edx, [eax]
.text$mn:00002AF0                 mov     ecx, [ebp+Memory]
.text$mn:00002AF3                 mov     eax, [edx]
.text$mn:00002AF5                 call    eax
.text$mn:00002AF7                 mov     ecx, [ebp+Memory]
.text$mn:00002AFA                 push    ecx             ; Memory
.text$mn:00002AFB                 call    _free
.text$mn:00002B00                 add     esp, 4
.text$mn:00002B03
.text$mn:00002B03 loc_2B03:                               ; CODE XREF: std::_DebugHeapDelete<std::locale::facet>(std::locale::facet *)+7j
.text$mn:00002B03                 pop     ebp
.text$mn:00002B04                 retn
.text$mn:00002B04 ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z endp
.text$mn:00002B04
.text$mn:00002B04 ; ---------------------------------------------------------------------------
.text$mn:00002B05                 align 4
.text$mn:00002B05 _text$mn        ends
.text$mn:00002B05
.text$mn:00002B08 ; ===========================================================================
.text$mn:00002B08
.text$mn:00002B08 ; Segment type: Pure code
.text$mn:00002B08 ; Segment permissions: Read/Execute
.text$mn:00002B08 _text$mn        segment para public 'CODE' use32
.text$mn:00002B08                 assume cs:_text$mn
.text$mn:00002B08                 ;org 2B08h
.text$mn:00002B08 ; COMDAT (pick any)
.text$mn:00002B08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B08
.text$mn:00002B08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B08
.text$mn:00002B08 ; Attributes: bp-based frame
.text$mn:00002B08
.text$mn:00002B08 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00002B08                 public ??$_Debug_pointer@D@std@@YAXPADPB_WI@Z
.text$mn:00002B08 ??$_Debug_pointer@D@std@@YAXPADPB_WI@Z proc near
.text$mn:00002B08                                         ; CODE XREF: std::ctype<char>::do_narrow(char const *,char const *,char,char *)+2Fp
.text$mn:00002B08                                         ; std::ctype<char>::do_widen(char const *,char const *,char *)+2Fp
.text$mn:00002B08
.text$mn:00002B08 arg_0           = dword ptr  8
.text$mn:00002B08 arg_4           = dword ptr  0Ch
.text$mn:00002B08 arg_8           = dword ptr  10h
.text$mn:00002B08
.text$mn:00002B08                 push    ebp
.text$mn:00002B09                 mov     ebp, esp
.text$mn:00002B0B                 cmp     [ebp+arg_0], 0
.text$mn:00002B0F                 jnz     short loc_2B26
.text$mn:00002B11                 mov     eax, [ebp+arg_8]
.text$mn:00002B14                 push    eax             ; unsigned int
.text$mn:00002B15                 mov     ecx, [ebp+arg_4]
.text$mn:00002B18                 push    ecx             ; wchar_t *
.text$mn:00002B19                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002B1E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002B23                 add     esp, 0Ch
.text$mn:00002B26
.text$mn:00002B26 loc_2B26:                               ; CODE XREF: std::_Debug_pointer<char>(char *,wchar_t const *,uint)+7j
.text$mn:00002B26                 pop     ebp
.text$mn:00002B27                 retn
.text$mn:00002B27 ??$_Debug_pointer@D@std@@YAXPADPB_WI@Z endp
.text$mn:00002B27
.text$mn:00002B27 _text$mn        ends
.text$mn:00002B27
.text$mn:00002B28 ; ===========================================================================
.text$mn:00002B28
.text$mn:00002B28 ; Segment type: Pure code
.text$mn:00002B28 ; Segment permissions: Read/Execute
.text$mn:00002B28 _text$mn        segment para public 'CODE' use32
.text$mn:00002B28                 assume cs:_text$mn
.text$mn:00002B28                 ;org 2B28h
.text$mn:00002B28 ; COMDAT (pick any)
.text$mn:00002B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B28
.text$mn:00002B28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B28
.text$mn:00002B28 ; Attributes: bp-based frame
.text$mn:00002B28
.text$mn:00002B28 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00002B28                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00002B28 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00002B28                                         ; CODE XREF: std::_Debug_range2<char const *>(char const *,char const *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00002B28                                         ; std::_Debug_range2<char const *>(char const *,char const *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00002B28
.text$mn:00002B28 arg_0           = dword ptr  8
.text$mn:00002B28 arg_4           = dword ptr  0Ch
.text$mn:00002B28 arg_8           = dword ptr  10h
.text$mn:00002B28
.text$mn:00002B28                 push    ebp
.text$mn:00002B29                 mov     ebp, esp
.text$mn:00002B2B                 cmp     [ebp+arg_0], 0
.text$mn:00002B2F                 jnz     short loc_2B46
.text$mn:00002B31                 mov     eax, [ebp+arg_8]
.text$mn:00002B34                 push    eax             ; unsigned int
.text$mn:00002B35                 mov     ecx, [ebp+arg_4]
.text$mn:00002B38                 push    ecx             ; wchar_t *
.text$mn:00002B39                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002B3E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002B43                 add     esp, 0Ch
.text$mn:00002B46
.text$mn:00002B46 loc_2B46:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00002B46                 pop     ebp
.text$mn:00002B47                 retn
.text$mn:00002B47 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00002B47
.text$mn:00002B47 _text$mn        ends
.text$mn:00002B47
.text$mn:00002B48 ; ===========================================================================
.text$mn:00002B48
.text$mn:00002B48 ; Segment type: Pure code
.text$mn:00002B48 ; Segment permissions: Read/Execute
.text$mn:00002B48 _text$mn        segment para public 'CODE' use32
.text$mn:00002B48                 assume cs:_text$mn
.text$mn:00002B48                 ;org 2B48h
.text$mn:00002B48 ; COMDAT (pick any)
.text$mn:00002B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B48
.text$mn:00002B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B48
.text$mn:00002B48 ; Attributes: bp-based frame
.text$mn:00002B48
.text$mn:00002B48 ; int __cdecl std::_Debug_range2<char const *>(int, int, wchar_t *, unsigned int)
.text$mn:00002B48                 public ??$_Debug_range2@PBD@std@@YAXPBD0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002B48 ??$_Debug_range2@PBD@std@@YAXPBD0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002B48                                         ; CODE XREF: std::_Debug_range<char const *>(char const *,char const *,wchar_t const *,uint)+2Ap
.text$mn:00002B48
.text$mn:00002B48 arg_0           = dword ptr  8
.text$mn:00002B48 arg_4           = dword ptr  0Ch
.text$mn:00002B48 arg_8           = dword ptr  10h
.text$mn:00002B48 arg_C           = dword ptr  14h
.text$mn:00002B48
.text$mn:00002B48                 push    ebp
.text$mn:00002B49                 mov     ebp, esp
.text$mn:00002B4B                 mov     eax, [ebp+arg_0]
.text$mn:00002B4E                 cmp     eax, [ebp+arg_4]
.text$mn:00002B51                 jz      short loc_2B98
.text$mn:00002B53                 mov     ecx, [ebp+arg_C]
.text$mn:00002B56                 push    ecx             ; unsigned int
.text$mn:00002B57                 mov     edx, [ebp+arg_8]
.text$mn:00002B5A                 push    edx             ; wchar_t *
.text$mn:00002B5B                 mov     eax, [ebp+arg_0]
.text$mn:00002B5E                 push    eax             ; int
.text$mn:00002B5F                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00002B64                 add     esp, 0Ch
.text$mn:00002B67                 mov     ecx, [ebp+arg_C]
.text$mn:00002B6A                 push    ecx             ; unsigned int
.text$mn:00002B6B                 mov     edx, [ebp+arg_8]
.text$mn:00002B6E                 push    edx             ; wchar_t *
.text$mn:00002B6F                 mov     eax, [ebp+arg_4]
.text$mn:00002B72                 push    eax             ; int
.text$mn:00002B73                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00002B78                 add     esp, 0Ch
.text$mn:00002B7B                 mov     ecx, [ebp+arg_4]
.text$mn:00002B7E                 cmp     ecx, [ebp+arg_0]
.text$mn:00002B81                 jnb     short loc_2B98
.text$mn:00002B83                 mov     edx, [ebp+arg_C]
.text$mn:00002B86                 push    edx             ; unsigned int
.text$mn:00002B87                 mov     eax, [ebp+arg_8]
.text$mn:00002B8A                 push    eax             ; wchar_t *
.text$mn:00002B8B                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002B90                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002B95                 add     esp, 0Ch
.text$mn:00002B98
.text$mn:00002B98 loc_2B98:                               ; CODE XREF: std::_Debug_range2<char const *>(char const *,char const *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002B98                                         ; std::_Debug_range2<char const *>(char const *,char const *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002B98                 pop     ebp
.text$mn:00002B99                 retn
.text$mn:00002B99 ??$_Debug_range2@PBD@std@@YAXPBD0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002B99
.text$mn:00002B99 ; ---------------------------------------------------------------------------
.text$mn:00002B9A                 align 4
.text$mn:00002B9A _text$mn        ends
.text$mn:00002B9A
.text$mn:00002B9C ; ===========================================================================
.text$mn:00002B9C
.text$mn:00002B9C ; Segment type: Pure code
.text$mn:00002B9C ; Segment permissions: Read/Execute
.text$mn:00002B9C _text$mn        segment para public 'CODE' use32
.text$mn:00002B9C                 assume cs:_text$mn
.text$mn:00002B9C                 ;org 2B9Ch
.text$mn:00002B9C ; COMDAT (pick any)
.text$mn:00002B9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B9C
.text$mn:00002B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B9C
.text$mn:00002B9C ; Attributes: bp-based frame
.text$mn:00002B9C
.text$mn:00002B9C ; int __cdecl std::_Debug_range<char const *>(int, int, wchar_t *, unsigned int)
.text$mn:00002B9C                 public ??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z
.text$mn:00002B9C ??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z proc near
.text$mn:00002B9C                                         ; CODE XREF: std::ctype<char>::do_narrow(char const *,char const *,char,char *)+19p
.text$mn:00002B9C                                         ; std::ctype<char>::do_tolower(char *,char const *)+19p ...
.text$mn:00002B9C
.text$mn:00002B9C var_1           = byte ptr -1
.text$mn:00002B9C arg_0           = dword ptr  8
.text$mn:00002B9C arg_4           = dword ptr  0Ch
.text$mn:00002B9C arg_8           = dword ptr  10h
.text$mn:00002B9C arg_C           = dword ptr  14h
.text$mn:00002B9C
.text$mn:00002B9C                 push    ebp
.text$mn:00002B9D                 mov     ebp, esp
.text$mn:00002B9F                 push    ecx
.text$mn:00002BA0                 lea     eax, [ebp+arg_0]
.text$mn:00002BA3                 push    eax
.text$mn:00002BA4                 lea     ecx, [ebp+var_1]
.text$mn:00002BA7                 push    ecx
.text$mn:00002BA8                 call    ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z ; std::_Iter_cat<char const *>(char const * const &)
.text$mn:00002BAD                 add     esp, 8
.text$mn:00002BB0                 mov     dl, [eax]
.text$mn:00002BB2                 movzx   eax, dl
.text$mn:00002BB5                 push    eax
.text$mn:00002BB6                 mov     ecx, [ebp+arg_C]
.text$mn:00002BB9                 push    ecx             ; unsigned int
.text$mn:00002BBA                 mov     edx, [ebp+arg_8]
.text$mn:00002BBD                 push    edx             ; wchar_t *
.text$mn:00002BBE                 mov     eax, [ebp+arg_4]
.text$mn:00002BC1                 push    eax             ; int
.text$mn:00002BC2                 mov     ecx, [ebp+arg_0]
.text$mn:00002BC5                 push    ecx             ; int
.text$mn:00002BC6                 call    ??$_Debug_range2@PBD@std@@YAXPBD0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<char const *>(char const *,char const *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002BCB                 add     esp, 14h
.text$mn:00002BCE                 mov     esp, ebp
.text$mn:00002BD0                 pop     ebp
.text$mn:00002BD1                 retn
.text$mn:00002BD1 ??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z endp
.text$mn:00002BD1
.text$mn:00002BD1 ; ---------------------------------------------------------------------------
.text$mn:00002BD2                 align 4
.text$mn:00002BD2 _text$mn        ends
.text$mn:00002BD2
.text$mn:00002BD4 ; ===========================================================================
.text$mn:00002BD4
.text$mn:00002BD4 ; Segment type: Pure code
.text$mn:00002BD4 ; Segment permissions: Read/Execute
.text$mn:00002BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00002BD4                 assume cs:_text$mn
.text$mn:00002BD4                 ;org 2BD4h
.text$mn:00002BD4 ; COMDAT (pick any)
.text$mn:00002BD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BD4
.text$mn:00002BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BD4
.text$mn:00002BD4 ; Attributes: bp-based frame
.text$mn:00002BD4
.text$mn:00002BD4 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<char const *>(char const * const &)
.text$mn:00002BD4                 public ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z
.text$mn:00002BD4 ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z proc near
.text$mn:00002BD4                                         ; CODE XREF: std::_Debug_range<char const *>(char const *,char const *,wchar_t const *,uint)+Cp
.text$mn:00002BD4
.text$mn:00002BD4 var_1           = byte ptr -1
.text$mn:00002BD4 arg_0           = dword ptr  8
.text$mn:00002BD4
.text$mn:00002BD4                 push    ebp
.text$mn:00002BD5                 mov     ebp, esp
.text$mn:00002BD7                 push    ecx
.text$mn:00002BD8                 mov     eax, [ebp+arg_0]
.text$mn:00002BDB                 mov     cl, [ebp+var_1]
.text$mn:00002BDE                 mov     [eax], cl
.text$mn:00002BE0                 mov     eax, [ebp+arg_0]
.text$mn:00002BE3                 mov     esp, ebp
.text$mn:00002BE5                 pop     ebp
.text$mn:00002BE6                 retn
.text$mn:00002BE6 ??$_Iter_cat@PBD@std@@YA?AUrandom_access_iterator_tag@0@ABQBD@Z endp
.text$mn:00002BE6
.text$mn:00002BE6 ; ---------------------------------------------------------------------------
.text$mn:00002BE7                 align 4
.text$mn:00002BE7 _text$mn        ends
.text$mn:00002BE7
.text$mn:00002BE8 ; ===========================================================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Segment type: Pure code
.text$mn:00002BE8 ; Segment permissions: Read/Execute
.text$mn:00002BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BE8                 assume cs:_text$mn
.text$mn:00002BE8                 ;org 2BE8h
.text$mn:00002BE8 ; COMDAT (pick any)
.text$mn:00002BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BE8
.text$mn:00002BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Attributes: bp-based frame
.text$mn:00002BE8
.text$mn:00002BE8 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00002BE8                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00002BE8 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00002BE8                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00002BE8                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00002BE8
.text$mn:00002BE8 arg_0           = dword ptr  8
.text$mn:00002BE8
.text$mn:00002BE8                 push    ebp
.text$mn:00002BE9                 mov     ebp, esp
.text$mn:00002BEB                 mov     eax, [ebp+arg_0]
.text$mn:00002BEE                 pop     ebp
.text$mn:00002BEF                 retn
.text$mn:00002BEF ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00002BEF
.text$mn:00002BEF _text$mn        ends
.text$mn:00002BEF
.text$mn:00002BF0 ; ===========================================================================
.text$mn:00002BF0
.text$mn:00002BF0 ; Segment type: Pure code
.text$mn:00002BF0 ; Segment permissions: Read/Execute
.text$mn:00002BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BF0                 assume cs:_text$mn
.text$mn:00002BF0                 ;org 2BF0h
.text$mn:00002BF0 ; COMDAT (pick any)
.text$mn:00002BF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BF0
.text$mn:00002BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BF0
.text$mn:00002BF0 ; Attributes: bp-based frame
.text$mn:00002BF0
.text$mn:00002BF0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00002BF0                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00002BF0 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00002BF0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+50p
.text$mn:00002BF0                                         ; $LN19+4Bp
.text$mn:00002BF0
.text$mn:00002BF0 var_4           = dword ptr -4
.text$mn:00002BF0 arg_0           = dword ptr  8
.text$mn:00002BF0 arg_4           = dword ptr  0Ch
.text$mn:00002BF0
.text$mn:00002BF0                 push    ebp
.text$mn:00002BF1                 mov     ebp, esp
.text$mn:00002BF3                 push    ecx
.text$mn:00002BF4                 mov     [ebp+var_4], ecx
.text$mn:00002BF7                 mov     eax, [ebp+arg_4]
.text$mn:00002BFA                 push    eax
.text$mn:00002BFB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00002C00                 add     esp, 4
.text$mn:00002C03                 push    eax             ; int
.text$mn:00002C04                 mov     ecx, [ebp+arg_0]
.text$mn:00002C07                 push    ecx             ; void *
.text$mn:00002C08                 mov     edx, [ebp+var_4]
.text$mn:00002C0B                 push    edx             ; int
.text$mn:00002C0C                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00002C11                 add     esp, 0Ch
.text$mn:00002C14                 mov     esp, ebp
.text$mn:00002C16                 pop     ebp
.text$mn:00002C17                 retn    8
.text$mn:00002C17 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00002C17
.text$mn:00002C17 ; ---------------------------------------------------------------------------
.text$mn:00002C1A                 align 4
.text$mn:00002C1A _text$mn        ends
.text$mn:00002C1A
.text$mn:00002C1C ; ===========================================================================
.text$mn:00002C1C
.text$mn:00002C1C ; Segment type: Pure code
.text$mn:00002C1C ; Segment permissions: Read/Execute
.text$mn:00002C1C _text$mn        segment para public 'CODE' use32
.text$mn:00002C1C                 assume cs:_text$mn
.text$mn:00002C1C                 ;org 2C1Ch
.text$mn:00002C1C ; COMDAT (pick any)
.text$mn:00002C1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C1C
.text$mn:00002C1C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C1C
.text$mn:00002C1C ; Attributes: bp-based frame
.text$mn:00002C1C
.text$mn:00002C1C ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00002C1C                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00002C1C ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00002C1C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00002C1C
.text$mn:00002C1C var_1C          = dword ptr -1Ch
.text$mn:00002C1C var_18          = dword ptr -18h
.text$mn:00002C1C var_14          = dword ptr -14h
.text$mn:00002C1C var_10          = dword ptr -10h
.text$mn:00002C1C var_C           = dword ptr -0Ch
.text$mn:00002C1C var_4           = dword ptr -4
.text$mn:00002C1C arg_0           = dword ptr  8
.text$mn:00002C1C arg_4           = dword ptr  0Ch
.text$mn:00002C1C
.text$mn:00002C1C                 push    ebp
.text$mn:00002C1D                 mov     ebp, esp
.text$mn:00002C1F                 push    0FFFFFFFFh
.text$mn:00002C21                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00002C26                 mov     eax, large fs:0
.text$mn:00002C2C                 push    eax
.text$mn:00002C2D                 sub     esp, 10h
.text$mn:00002C30                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C35                 xor     eax, ebp
.text$mn:00002C37                 push    eax
.text$mn:00002C38                 lea     eax, [ebp+var_C]
.text$mn:00002C3B                 mov     large fs:0, eax
.text$mn:00002C41                 mov     [ebp+var_18], ecx
.text$mn:00002C44                 mov     eax, [ebp+arg_0]
.text$mn:00002C47                 push    eax             ; void *
.text$mn:00002C48                 push    4               ; unsigned int
.text$mn:00002C4A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002C4F                 add     esp, 8
.text$mn:00002C52                 mov     [ebp+var_10], eax
.text$mn:00002C55                 mov     [ebp+var_4], 0
.text$mn:00002C5C                 cmp     [ebp+var_10], 0
.text$mn:00002C60                 jz      short loc_2C7D
.text$mn:00002C62                 mov     ecx, [ebp+arg_4]
.text$mn:00002C65                 push    ecx
.text$mn:00002C66                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00002C6B                 add     esp, 4
.text$mn:00002C6E                 mov     edx, [ebp+var_10]
.text$mn:00002C71                 mov     eax, [eax]
.text$mn:00002C73                 mov     [edx], eax
.text$mn:00002C75                 mov     ecx, [ebp+var_10]
.text$mn:00002C78                 mov     [ebp+var_14], ecx
.text$mn:00002C7B                 jmp     short loc_2C84
.text$mn:00002C7D ; ---------------------------------------------------------------------------
.text$mn:00002C7D
.text$mn:00002C7D loc_2C7D:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00002C7D                 mov     [ebp+var_14], 0
.text$mn:00002C84
.text$mn:00002C84 loc_2C84:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00002C84                 mov     edx, [ebp+var_14]
.text$mn:00002C87                 mov     [ebp+var_1C], edx
.text$mn:00002C8A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C91                 mov     ecx, [ebp+var_C]
.text$mn:00002C94                 mov     large fs:0, ecx
.text$mn:00002C9B                 pop     ecx
.text$mn:00002C9C                 mov     esp, ebp
.text$mn:00002C9E                 pop     ebp
.text$mn:00002C9F                 retn    8
.text$mn:00002C9F ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00002C9F
.text$mn:00002C9F ; ---------------------------------------------------------------------------
.text$mn:00002CA2                 align 4
.text$mn:00002CA2 _text$mn        ends
.text$mn:00002CA2
.text$x:00002CA4 ; ===========================================================================
.text$x:00002CA4
.text$x:00002CA4 ; Segment type: Pure code
.text$x:00002CA4 ; Segment permissions: Read/Execute
.text$x:00002CA4 _text$x         segment para public 'CODE' use32
.text$x:00002CA4                 assume cs:_text$x
.text$x:00002CA4                 ;org 2CA4h
.text$x:00002CA4 ; COMDAT (pick associative to section at 2C1C)
.text$x:00002CA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002CA4
.text$x:00002CA4 ; =============== S U B R O U T I N E =======================================
.text$x:00002CA4
.text$x:00002CA4
.text$x:00002CA4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00002CA4                                         ; DATA XREF: .xdata$x:00008BF8o
.text$x:00002CA4                 mov     eax, [ebp+8]
.text$x:00002CA7                 push    eax
.text$x:00002CA8                 mov     eax, [ebp-10h]
.text$x:00002CAB                 push    eax             ; void *
.text$x:00002CAC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002CB1                 add     esp, 8
.text$x:00002CB4                 retn
.text$x:00002CB4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00002CB4
.text$x:00002CB5
.text$x:00002CB5 ; =============== S U B R O U T I N E =======================================
.text$x:00002CB5
.text$x:00002CB5
.text$x:00002CB5 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00002CB5                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00002CB5
.text$x:00002CB5 arg_4           = dword ptr  8
.text$x:00002CB5
.text$x:00002CB5                 mov     edx, [esp+arg_4]
.text$x:00002CB9                 lea     eax, [edx+0Ch]
.text$x:00002CBC                 mov     ecx, [edx-14h]
.text$x:00002CBF                 xor     ecx, eax
.text$x:00002CC1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002CC6                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00002CCB                 jmp     ___CxxFrameHandler3
.text$x:00002CCB __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00002CCB
.text$x:00002CCB _text$x         ends
.text$x:00002CCB
.text$mn:00002CD0 ; ===========================================================================
.text$mn:00002CD0
.text$mn:00002CD0 ; Segment type: Pure code
.text$mn:00002CD0 ; Segment permissions: Read/Execute
.text$mn:00002CD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CD0                 assume cs:_text$mn
.text$mn:00002CD0                 ;org 2CD0h
.text$mn:00002CD0 ; COMDAT (pick any)
.text$mn:00002CD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CD0
.text$mn:00002CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CD0
.text$mn:00002CD0 ; Attributes: bp-based frame
.text$mn:00002CD0
.text$mn:00002CD0 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00002CD0                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00002CD0 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00002CD0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00002CD0
.text$mn:00002CD0 arg_0           = dword ptr  8
.text$mn:00002CD0 arg_4           = dword ptr  0Ch
.text$mn:00002CD0 arg_8           = dword ptr  10h
.text$mn:00002CD0
.text$mn:00002CD0                 push    ebp
.text$mn:00002CD1                 mov     ebp, esp
.text$mn:00002CD3                 mov     eax, [ebp+arg_8]
.text$mn:00002CD6                 push    eax
.text$mn:00002CD7                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00002CDC                 add     esp, 4
.text$mn:00002CDF                 push    eax             ; int
.text$mn:00002CE0                 mov     ecx, [ebp+arg_4]
.text$mn:00002CE3                 push    ecx             ; void *
.text$mn:00002CE4                 mov     ecx, [ebp+arg_0]
.text$mn:00002CE7                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00002CEC                 pop     ebp
.text$mn:00002CED                 retn
.text$mn:00002CED ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00002CED
.text$mn:00002CED ; ---------------------------------------------------------------------------
.text$mn:00002CEE                 align 10h
.text$mn:00002CEE _text$mn        ends
.text$mn:00002CEE
.text$mn:00002CF0 ; ===========================================================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Segment type: Pure code
.text$mn:00002CF0 ; Segment permissions: Read/Execute
.text$mn:00002CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CF0                 assume cs:_text$mn
.text$mn:00002CF0                 ;org 2CF0h
.text$mn:00002CF0 ; COMDAT (pick any)
.text$mn:00002CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CF0
.text$mn:00002CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Attributes: bp-based frame
.text$mn:00002CF0
.text$mn:00002CF0 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00002CF0                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002CF0 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00002CF0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00002CF0
.text$mn:00002CF0 var_1C          = dword ptr -1Ch
.text$mn:00002CF0 var_18          = dword ptr -18h
.text$mn:00002CF0 var_14          = dword ptr -14h
.text$mn:00002CF0 var_10          = dword ptr -10h
.text$mn:00002CF0 var_C           = dword ptr -0Ch
.text$mn:00002CF0 var_4           = dword ptr -4
.text$mn:00002CF0 arg_0           = dword ptr  8
.text$mn:00002CF0 arg_4           = dword ptr  0Ch
.text$mn:00002CF0
.text$mn:00002CF0                 push    ebp
.text$mn:00002CF1                 mov     ebp, esp
.text$mn:00002CF3                 push    0FFFFFFFFh
.text$mn:00002CF5                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002CFA                 mov     eax, large fs:0
.text$mn:00002D00                 push    eax
.text$mn:00002D01                 sub     esp, 10h
.text$mn:00002D04                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D09                 xor     eax, ebp
.text$mn:00002D0B                 push    eax
.text$mn:00002D0C                 lea     eax, [ebp+var_C]
.text$mn:00002D0F                 mov     large fs:0, eax
.text$mn:00002D15                 mov     [ebp+var_18], ecx
.text$mn:00002D18                 mov     eax, [ebp+arg_0]
.text$mn:00002D1B                 push    eax             ; void *
.text$mn:00002D1C                 push    8               ; unsigned int
.text$mn:00002D1E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002D23                 add     esp, 8
.text$mn:00002D26                 mov     [ebp+var_10], eax
.text$mn:00002D29                 mov     [ebp+var_4], 0
.text$mn:00002D30                 cmp     [ebp+var_10], 0
.text$mn:00002D34                 jz      short loc_2D57
.text$mn:00002D36                 mov     ecx, [ebp+arg_4]
.text$mn:00002D39                 push    ecx
.text$mn:00002D3A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00002D3F                 add     esp, 4
.text$mn:00002D42                 mov     edx, [eax]
.text$mn:00002D44                 mov     eax, [eax+4]
.text$mn:00002D47                 mov     ecx, [ebp+var_10]
.text$mn:00002D4A                 mov     [ecx], edx
.text$mn:00002D4C                 mov     [ecx+4], eax
.text$mn:00002D4F                 mov     edx, [ebp+var_10]
.text$mn:00002D52                 mov     [ebp+var_14], edx
.text$mn:00002D55                 jmp     short loc_2D5E
.text$mn:00002D57 ; ---------------------------------------------------------------------------
.text$mn:00002D57
.text$mn:00002D57 loc_2D57:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00002D57                 mov     [ebp+var_14], 0
.text$mn:00002D5E
.text$mn:00002D5E loc_2D5E:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00002D5E                 mov     eax, [ebp+var_14]
.text$mn:00002D61                 mov     [ebp+var_1C], eax
.text$mn:00002D64                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D6B                 mov     ecx, [ebp+var_C]
.text$mn:00002D6E                 mov     large fs:0, ecx
.text$mn:00002D75                 pop     ecx
.text$mn:00002D76                 mov     esp, ebp
.text$mn:00002D78                 pop     ebp
.text$mn:00002D79                 retn    8
.text$mn:00002D79 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00002D79
.text$mn:00002D79 _text$mn        ends
.text$mn:00002D79
.text$x:00002D7C ; ===========================================================================
.text$x:00002D7C
.text$x:00002D7C ; Segment type: Pure code
.text$x:00002D7C ; Segment permissions: Read/Execute
.text$x:00002D7C _text$x         segment para public 'CODE' use32
.text$x:00002D7C                 assume cs:_text$x
.text$x:00002D7C                 ;org 2D7Ch
.text$x:00002D7C ; COMDAT (pick associative to section at 2CF0)
.text$x:00002D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002D7C
.text$x:00002D7C ; =============== S U B R O U T I N E =======================================
.text$x:00002D7C
.text$x:00002D7C
.text$x:00002D7C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00002D7C                                         ; DATA XREF: .xdata$x:00008B74o
.text$x:00002D7C                 mov     eax, [ebp+8]
.text$x:00002D7F                 push    eax
.text$x:00002D80                 mov     eax, [ebp-10h]
.text$x:00002D83                 push    eax             ; void *
.text$x:00002D84                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002D89                 add     esp, 8
.text$x:00002D8C                 retn
.text$x:00002D8C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00002D8C
.text$x:00002D8D
.text$x:00002D8D ; =============== S U B R O U T I N E =======================================
.text$x:00002D8D
.text$x:00002D8D
.text$x:00002D8D __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00002D8D                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00002D8D
.text$x:00002D8D arg_4           = dword ptr  8
.text$x:00002D8D
.text$x:00002D8D                 mov     edx, [esp+arg_4]
.text$x:00002D91                 lea     eax, [edx+0Ch]
.text$x:00002D94                 mov     ecx, [edx-14h]
.text$x:00002D97                 xor     ecx, eax
.text$x:00002D99                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D9E                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00002DA3                 jmp     ___CxxFrameHandler3
.text$x:00002DA3 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00002DA3
.text$x:00002DA3 _text$x         ends
.text$x:00002DA3
.text$mn:00002DA8 ; ===========================================================================
.text$mn:00002DA8
.text$mn:00002DA8 ; Segment type: Pure code
.text$mn:00002DA8 ; Segment permissions: Read/Execute
.text$mn:00002DA8 _text$mn        segment para public 'CODE' use32
.text$mn:00002DA8                 assume cs:_text$mn
.text$mn:00002DA8                 ;org 2DA8h
.text$mn:00002DA8 ; COMDAT (pick any)
.text$mn:00002DA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DA8
.text$mn:00002DA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DA8
.text$mn:00002DA8 ; Attributes: bp-based frame
.text$mn:00002DA8
.text$mn:00002DA8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00002DA8                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00002DA8 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00002DA8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00002DA8
.text$mn:00002DA8 var_4           = dword ptr -4
.text$mn:00002DA8 arg_0           = dword ptr  8
.text$mn:00002DA8
.text$mn:00002DA8                 push    ebp
.text$mn:00002DA9                 mov     ebp, esp
.text$mn:00002DAB                 push    ecx
.text$mn:00002DAC                 mov     [ebp+var_4], ecx
.text$mn:00002DAF                 mov     eax, [ebp+arg_0]
.text$mn:00002DB2                 push    eax
.text$mn:00002DB3                 mov     ecx, [ebp+var_4]
.text$mn:00002DB6                 push    ecx
.text$mn:00002DB7                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00002DBC                 add     esp, 8
.text$mn:00002DBF                 mov     esp, ebp
.text$mn:00002DC1                 pop     ebp
.text$mn:00002DC2                 retn    4
.text$mn:00002DC2 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00002DC2
.text$mn:00002DC2 ; ---------------------------------------------------------------------------
.text$mn:00002DC5                 align 4
.text$mn:00002DC5 _text$mn        ends
.text$mn:00002DC5
.text$mn:00002DC8 ; ===========================================================================
.text$mn:00002DC8
.text$mn:00002DC8 ; Segment type: Pure code
.text$mn:00002DC8 ; Segment permissions: Read/Execute
.text$mn:00002DC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002DC8                 assume cs:_text$mn
.text$mn:00002DC8                 ;org 2DC8h
.text$mn:00002DC8 ; COMDAT (pick any)
.text$mn:00002DC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DC8
.text$mn:00002DC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DC8
.text$mn:00002DC8 ; Attributes: bp-based frame
.text$mn:00002DC8
.text$mn:00002DC8 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002DC8                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00002DC8 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00002DC8                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00002DC8
.text$mn:00002DC8 var_4           = dword ptr -4
.text$mn:00002DC8
.text$mn:00002DC8                 push    ebp
.text$mn:00002DC9                 mov     ebp, esp
.text$mn:00002DCB                 push    ecx
.text$mn:00002DCC                 mov     [ebp+var_4], ecx
.text$mn:00002DCF                 mov     esp, ebp
.text$mn:00002DD1                 pop     ebp
.text$mn:00002DD2                 retn    4
.text$mn:00002DD2 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00002DD2
.text$mn:00002DD2 ; ---------------------------------------------------------------------------
.text$mn:00002DD5                 align 4
.text$mn:00002DD5 _text$mn        ends
.text$mn:00002DD5
.text$mn:00002DD8 ; ===========================================================================
.text$mn:00002DD8
.text$mn:00002DD8 ; Segment type: Pure code
.text$mn:00002DD8 ; Segment permissions: Read/Execute
.text$mn:00002DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00002DD8                 assume cs:_text$mn
.text$mn:00002DD8                 ;org 2DD8h
.text$mn:00002DD8 ; COMDAT (pick any)
.text$mn:00002DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DD8
.text$mn:00002DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DD8
.text$mn:00002DD8 ; Attributes: bp-based frame
.text$mn:00002DD8
.text$mn:00002DD8 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00002DD8                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00002DD8 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00002DD8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00002DD8
.text$mn:00002DD8 arg_0           = dword ptr  8
.text$mn:00002DD8 arg_4           = dword ptr  0Ch
.text$mn:00002DD8
.text$mn:00002DD8                 push    ebp
.text$mn:00002DD9                 mov     ebp, esp
.text$mn:00002DDB                 mov     eax, [ebp+arg_4]
.text$mn:00002DDE                 push    eax
.text$mn:00002DDF                 mov     ecx, [ebp+arg_0]
.text$mn:00002DE2                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002DE7                 pop     ebp
.text$mn:00002DE8                 retn
.text$mn:00002DE8 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00002DE8
.text$mn:00002DE8 ; ---------------------------------------------------------------------------
.text$mn:00002DE9                 align 4
.text$mn:00002DE9 _text$mn        ends
.text$mn:00002DE9
.text$mn:00002DEC ; ===========================================================================
.text$mn:00002DEC
.text$mn:00002DEC ; Segment type: Pure code
.text$mn:00002DEC ; Segment permissions: Read/Execute
.text$mn:00002DEC _text$mn        segment para public 'CODE' use32
.text$mn:00002DEC                 assume cs:_text$mn
.text$mn:00002DEC                 ;org 2DECh
.text$mn:00002DEC ; COMDAT (pick any)
.text$mn:00002DEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DEC
.text$mn:00002DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00002DEC
.text$mn:00002DEC ; Attributes: bp-based frame
.text$mn:00002DEC
.text$mn:00002DEC ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00002DEC                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00002DEC ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00002DEC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00002DEC
.text$mn:00002DEC var_4           = dword ptr -4
.text$mn:00002DEC
.text$mn:00002DEC                 push    ebp
.text$mn:00002DED                 mov     ebp, esp
.text$mn:00002DEF                 push    ecx
.text$mn:00002DF0                 mov     [ebp+var_4], ecx
.text$mn:00002DF3                 mov     esp, ebp
.text$mn:00002DF5                 pop     ebp
.text$mn:00002DF6                 retn    4
.text$mn:00002DF6 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00002DF6
.text$mn:00002DF6 ; ---------------------------------------------------------------------------
.text$mn:00002DF9                 align 4
.text$mn:00002DF9 _text$mn        ends
.text$mn:00002DF9
.text$mn:00002DFC ; ===========================================================================
.text$mn:00002DFC
.text$mn:00002DFC ; Segment type: Pure code
.text$mn:00002DFC ; Segment permissions: Read/Execute
.text$mn:00002DFC _text$mn        segment para public 'CODE' use32
.text$mn:00002DFC                 assume cs:_text$mn
.text$mn:00002DFC                 ;org 2DFCh
.text$mn:00002DFC ; COMDAT (pick any)
.text$mn:00002DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DFC
.text$mn:00002DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00002DFC
.text$mn:00002DFC ; Attributes: bp-based frame
.text$mn:00002DFC
.text$mn:00002DFC ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00002DFC                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00002DFC ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00002DFC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00002DFC                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00002DFC
.text$mn:00002DFC arg_0           = dword ptr  8
.text$mn:00002DFC
.text$mn:00002DFC                 push    ebp
.text$mn:00002DFD                 mov     ebp, esp
.text$mn:00002DFF                 mov     eax, [ebp+arg_0]
.text$mn:00002E02                 pop     ebp
.text$mn:00002E03                 retn
.text$mn:00002E03 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00002E03
.text$mn:00002E03 _text$mn        ends
.text$mn:00002E03
.text$mn:00002E04 ; ===========================================================================
.text$mn:00002E04
.text$mn:00002E04 ; Segment type: Pure code
.text$mn:00002E04 ; Segment permissions: Read/Execute
.text$mn:00002E04 _text$mn        segment para public 'CODE' use32
.text$mn:00002E04                 assume cs:_text$mn
.text$mn:00002E04                 ;org 2E04h
.text$mn:00002E04 ; COMDAT (pick any)
.text$mn:00002E04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E04
.text$mn:00002E04 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E04
.text$mn:00002E04 ; Attributes: bp-based frame
.text$mn:00002E04
.text$mn:00002E04 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00002E04                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00002E04 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00002E04                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00002E04
.text$mn:00002E04 arg_0           = dword ptr  8
.text$mn:00002E04
.text$mn:00002E04                 push    ebp
.text$mn:00002E05                 mov     ebp, esp
.text$mn:00002E07                 mov     eax, [ebp+arg_0]
.text$mn:00002E0A                 pop     ebp
.text$mn:00002E0B                 retn
.text$mn:00002E0B ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00002E0B
.text$mn:00002E0B _text$mn        ends
.text$mn:00002E0B
.text$mn:00002E0C ; ===========================================================================
.text$mn:00002E0C
.text$mn:00002E0C ; Segment type: Pure code
.text$mn:00002E0C ; Segment permissions: Read/Execute
.text$mn:00002E0C _text$mn        segment para public 'CODE' use32
.text$mn:00002E0C                 assume cs:_text$mn
.text$mn:00002E0C                 ;org 2E0Ch
.text$mn:00002E0C ; COMDAT (pick any)
.text$mn:00002E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E0C
.text$mn:00002E0C ; =============== S U B R O U T I N E =======================================
.text$mn:00002E0C
.text$mn:00002E0C ; Attributes: bp-based frame
.text$mn:00002E0C
.text$mn:00002E0C ; class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> && __cdecl std::forward<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> &)
.text$mn:00002E0C                 public ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
.text$mn:00002E0C ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z proc near
.text$mn:00002E0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+54p
.text$mn:00002E0C
.text$mn:00002E0C arg_0           = dword ptr  8
.text$mn:00002E0C
.text$mn:00002E0C                 push    ebp
.text$mn:00002E0D                 mov     ebp, esp
.text$mn:00002E0F                 mov     eax, [ebp+arg_0]
.text$mn:00002E12                 pop     ebp
.text$mn:00002E13                 retn
.text$mn:00002E13 ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z endp
.text$mn:00002E13
.text$mn:00002E13 _text$mn        ends
.text$mn:00002E13
.text$mn:00002E14 ; ===========================================================================
.text$mn:00002E14
.text$mn:00002E14 ; Segment type: Pure code
.text$mn:00002E14 ; Segment permissions: Read/Execute
.text$mn:00002E14 _text$mn        segment para public 'CODE' use32
.text$mn:00002E14                 assume cs:_text$mn
.text$mn:00002E14                 ;org 2E14h
.text$mn:00002E14 ; COMDAT (pick any)
.text$mn:00002E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E14
.text$mn:00002E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E14
.text$mn:00002E14 ; Attributes: bp-based frame
.text$mn:00002E14
.text$mn:00002E14 ; int __cdecl std::use_facet<std::ctype<char>>(std::locale *)
.text$mn:00002E14                 public ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
.text$mn:00002E14 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z proc near
.text$mn:00002E14                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+C6p
.text$mn:00002E14
.text$mn:00002E14 var_30          = byte ptr -30h
.text$mn:00002E14 var_24          = dword ptr -24h
.text$mn:00002E14 var_20          = byte ptr -20h
.text$mn:00002E14 var_1C          = dword ptr -1Ch
.text$mn:00002E14 var_18          = dword ptr -18h
.text$mn:00002E14 var_14          = dword ptr -14h
.text$mn:00002E14 var_10          = dword ptr -10h
.text$mn:00002E14 var_C           = dword ptr -0Ch
.text$mn:00002E14 var_4           = dword ptr -4
.text$mn:00002E14 arg_0           = dword ptr  8
.text$mn:00002E14
.text$mn:00002E14                 push    ebp
.text$mn:00002E15                 mov     ebp, esp
.text$mn:00002E17                 push    0FFFFFFFFh
.text$mn:00002E19                 push    offset __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
.text$mn:00002E1E                 mov     eax, large fs:0
.text$mn:00002E24                 push    eax
.text$mn:00002E25                 sub     esp, 24h
.text$mn:00002E28                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E2D                 xor     eax, ebp
.text$mn:00002E2F                 push    eax
.text$mn:00002E30                 lea     eax, [ebp+var_C]
.text$mn:00002E33                 mov     large fs:0, eax
.text$mn:00002E39                 push    0               ; int
.text$mn:00002E3B                 lea     ecx, [ebp+var_20] ; this
.text$mn:00002E3E                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00002E43                 mov     [ebp+var_4], 0
.text$mn:00002E4A                 mov     eax, ds:?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::locale::facet const * const std::_Facetptr<std::ctype<char>>::_Psave
.text$mn:00002E4F                 mov     [ebp+var_10], eax
.text$mn:00002E52                 mov     ecx, offset ?id@?$ctype@D@std@@2V0locale@2@A ; std::locale::id std::ctype<char>::id
.text$mn:00002E57                 call    ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator uint(void)
.text$mn:00002E5C                 mov     [ebp+var_1C], eax
.text$mn:00002E5F                 mov     ecx, [ebp+var_1C]
.text$mn:00002E62                 push    ecx             ; unsigned int
.text$mn:00002E63                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002E66                 call    ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet(uint)
.text$mn:00002E6B                 mov     [ebp+var_14], eax
.text$mn:00002E6E                 cmp     [ebp+var_14], 0
.text$mn:00002E72                 jz      short loc_2E76
.text$mn:00002E74                 jmp     short loc_2EE4
.text$mn:00002E76 ; ---------------------------------------------------------------------------
.text$mn:00002E76
.text$mn:00002E76 loc_2E76:                               ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+5Ej
.text$mn:00002E76                 cmp     [ebp+var_10], 0
.text$mn:00002E7A                 jz      short loc_2E84
.text$mn:00002E7C                 mov     edx, [ebp+var_10]
.text$mn:00002E7F                 mov     [ebp+var_14], edx
.text$mn:00002E82                 jmp     short loc_2EE4
.text$mn:00002E84 ; ---------------------------------------------------------------------------
.text$mn:00002E84
.text$mn:00002E84 loc_2E84:                               ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+66j
.text$mn:00002E84                 mov     eax, [ebp+arg_0]
.text$mn:00002E87                 push    eax             ; std::locale *
.text$mn:00002E88                 lea     ecx, [ebp+var_10]
.text$mn:00002E8B                 push    ecx             ; int
.text$mn:00002E8C                 call    ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)
.text$mn:00002E91                 add     esp, 8
.text$mn:00002E94                 cmp     eax, 0FFFFFFFFh
.text$mn:00002E97                 jnz     short loc_2EB6
.text$mn:00002E99                 push    offset ??_C@_08EPJLHIJG@bad?5cast?$AA@ ; "bad cast"
.text$mn:00002E9E                 lea     ecx, [ebp+var_30] ; this
.text$mn:00002EA1                 call    ??0bad_cast@std@@QAE@PBD@Z ; std::bad_cast::bad_cast(char const *)
.text$mn:00002EA6                 push    offset __TI2?AVbad_cast@std@@
.text$mn:00002EAB                 lea     edx, [ebp+var_30]
.text$mn:00002EAE                 push    edx
.text$mn:00002EAF                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002EB4 ; ---------------------------------------------------------------------------
.text$mn:00002EB4                 jmp     short loc_2EE4
.text$mn:00002EB6 ; ---------------------------------------------------------------------------
.text$mn:00002EB6
.text$mn:00002EB6 loc_2EB6:                               ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+83j
.text$mn:00002EB6                 mov     eax, [ebp+var_10]
.text$mn:00002EB9                 mov     [ebp+var_14], eax
.text$mn:00002EBC                 mov     ecx, [ebp+var_10]
.text$mn:00002EBF                 mov     ds:?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::locale::facet const * const std::_Facetptr<std::ctype<char>>::_Psave
.text$mn:00002EC5                 mov     edx, [ebp+var_10]
.text$mn:00002EC8                 mov     [ebp+var_18], edx
.text$mn:00002ECB                 mov     eax, [ebp+var_18]
.text$mn:00002ECE                 mov     edx, [eax]
.text$mn:00002ED0                 mov     ecx, [ebp+var_18]
.text$mn:00002ED3                 mov     eax, [edx+4]
.text$mn:00002ED6                 call    eax
.text$mn:00002ED8                 mov     ecx, [ebp+var_18]
.text$mn:00002EDB                 push    ecx             ; struct std::_Facet_base *
.text$mn:00002EDC                 call    ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register(std::_Facet_base *)
.text$mn:00002EE1                 add     esp, 4
.text$mn:00002EE4
.text$mn:00002EE4 loc_2EE4:                               ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+60j
.text$mn:00002EE4                                         ; std::use_facet<std::ctype<char>>(std::locale const &)+6Ej ...
.text$mn:00002EE4                 mov     edx, [ebp+var_14]
.text$mn:00002EE7                 mov     [ebp+var_24], edx
.text$mn:00002EEA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002EF1                 lea     ecx, [ebp+var_20] ; this
.text$mn:00002EF4                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00002EF9                 mov     eax, [ebp+var_24]
.text$mn:00002EFC                 mov     ecx, [ebp+var_C]
.text$mn:00002EFF                 mov     large fs:0, ecx
.text$mn:00002F06                 pop     ecx
.text$mn:00002F07                 mov     esp, ebp
.text$mn:00002F09                 pop     ebp
.text$mn:00002F0A                 retn
.text$mn:00002F0A ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z endp
.text$mn:00002F0A
.text$mn:00002F0A ; ---------------------------------------------------------------------------
.text$mn:00002F0B                 align 4
.text$mn:00002F0B _text$mn        ends
.text$mn:00002F0B
.text$x:00002F0C ; ===========================================================================
.text$x:00002F0C
.text$x:00002F0C ; Segment type: Pure code
.text$x:00002F0C ; Segment permissions: Read/Execute
.text$x:00002F0C _text$x         segment para public 'CODE' use32
.text$x:00002F0C                 assume cs:_text$x
.text$x:00002F0C                 ;org 2F0Ch
.text$x:00002F0C ; COMDAT (pick associative to section at 2E14)
.text$x:00002F0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F0C
.text$x:00002F0C ; =============== S U B R O U T I N E =======================================
.text$x:00002F0C
.text$x:00002F0C
.text$x:00002F0C __unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0 proc near
.text$x:00002F0C                                         ; DATA XREF: .xdata$x:00008238o
.text$x:00002F0C                 lea     ecx, [ebp-20h]  ; this
.text$x:00002F0F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00002F0F __unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0 endp
.text$x:00002F0F
.text$x:00002F14
.text$x:00002F14 ; =============== S U B R O U T I N E =======================================
.text$x:00002F14
.text$x:00002F14
.text$x:00002F14 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z proc near
.text$x:00002F14                                         ; DATA XREF: std::use_facet<std::ctype<char>>(std::locale const &)+5o
.text$x:00002F14
.text$x:00002F14 arg_4           = dword ptr  8
.text$x:00002F14
.text$x:00002F14                 mov     edx, [esp+arg_4]
.text$x:00002F18                 lea     eax, [edx+0Ch]
.text$x:00002F1B                 mov     ecx, [edx-28h]
.text$x:00002F1E                 xor     ecx, eax
.text$x:00002F20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F25                 mov     eax, offset __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
.text$x:00002F2A                 jmp     ___CxxFrameHandler3
.text$x:00002F2A __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z endp
.text$x:00002F2A
.text$x:00002F2A ; ---------------------------------------------------------------------------
.text$x:00002F2F                 align 10h
.text$x:00002F2F _text$x         ends
.text$x:00002F2F
.text$mn:00002F30 ; ===========================================================================
.text$mn:00002F30
.text$mn:00002F30 ; Segment type: Pure code
.text$mn:00002F30 ; Segment permissions: Read/Execute
.text$mn:00002F30 _text$mn        segment para public 'CODE' use32
.text$mn:00002F30                 assume cs:_text$mn
.text$mn:00002F30                 ;org 2F30h
.text$mn:00002F30 ; COMDAT (pick any)
.text$mn:00002F30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F30
.text$mn:00002F30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F30
.text$mn:00002F30 ; Attributes: bp-based frame
.text$mn:00002F30
.text$mn:00002F30 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00002F30                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002F30 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00002F30                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+38p
.text$mn:00002F30                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+43p ...
.text$mn:00002F30
.text$mn:00002F30 var_10          = dword ptr -10h
.text$mn:00002F30 var_C           = dword ptr -0Ch
.text$mn:00002F30 var_4           = dword ptr -4
.text$mn:00002F30
.text$mn:00002F30                 push    ebp
.text$mn:00002F31                 mov     ebp, esp
.text$mn:00002F33                 push    0FFFFFFFFh
.text$mn:00002F35                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002F3A
.text$mn:00002F3A loc_2F3A:                               ; DATA XREF: .rdata:$SG94787o
.text$mn:00002F3A                                         ; .rdata:$SG94857o
.text$mn:00002F3A                 mov     eax, large fs:0
.text$mn:00002F40                 push    eax
.text$mn:00002F41                 push    ecx
.text$mn:00002F42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F47                 xor     eax, ebp
.text$mn:00002F49                 push    eax
.text$mn:00002F4A                 lea     eax, [ebp+var_C]
.text$mn:00002F4D                 mov     large fs:0, eax
.text$mn:00002F53                 mov     [ebp+var_10], ecx
.text$mn:00002F56                 mov     ecx, [ebp+var_10]
.text$mn:00002F59                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00002F5E                 mov     [ebp+var_4], 0
.text$mn:00002F65                 mov     ecx, [ebp+var_10]
.text$mn:00002F68                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00002F6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F74                 mov     eax, [ebp+var_10]
.text$mn:00002F77                 mov     ecx, [ebp+var_C]
.text$mn:00002F7A                 mov     large fs:0, ecx
.text$mn:00002F81                 pop     ecx
.text$mn:00002F82                 mov     esp, ebp
.text$mn:00002F84                 pop     ebp
.text$mn:00002F85                 retn    4
.text$mn:00002F85 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00002F85
.text$mn:00002F85 _text$mn        ends
.text$mn:00002F85
.text$x:00002F88 ; ===========================================================================
.text$x:00002F88
.text$x:00002F88 ; Segment type: Pure code
.text$x:00002F88 ; Segment permissions: Read/Execute
.text$x:00002F88 _text$x         segment para public 'CODE' use32
.text$x:00002F88                 assume cs:_text$x
.text$x:00002F88                 ;org 2F88h
.text$x:00002F88 ; COMDAT (pick associative to section at 2F30)
.text$x:00002F88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F88
.text$x:00002F88 ; =============== S U B R O U T I N E =======================================
.text$x:00002F88
.text$x:00002F88
.text$x:00002F88 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00002F88                                         ; DATA XREF: .xdata$x:00007DA0o
.text$x:00002F88                 mov     ecx, [ebp-10h]
.text$x:00002F8B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002F8B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00002F8B
.text$x:00002F90
.text$x:00002F90 ; =============== S U B R O U T I N E =======================================
.text$x:00002F90
.text$x:00002F90
.text$x:00002F90 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00002F90                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00002F90
.text$x:00002F90 arg_4           = dword ptr  8
.text$x:00002F90
.text$x:00002F90                 mov     edx, [esp+arg_4]
.text$x:00002F94                 lea     eax, [edx+0Ch]
.text$x:00002F97                 mov     ecx, [edx-8]
.text$x:00002F9A                 xor     ecx, eax
.text$x:00002F9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FA1                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00002FA6                 jmp     ___CxxFrameHandler3
.text$x:00002FA6 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00002FA6
.text$x:00002FA6 ; ---------------------------------------------------------------------------
.text$x:00002FAB                 align 4
.text$x:00002FAB _text$x         ends
.text$x:00002FAB
.text$mn:00002FAC ; ===========================================================================
.text$mn:00002FAC
.text$mn:00002FAC ; Segment type: Pure code
.text$mn:00002FAC ; Segment permissions: Read/Execute
.text$mn:00002FAC _text$mn        segment para public 'CODE' use32
.text$mn:00002FAC                 assume cs:_text$mn
.text$mn:00002FAC                 ;org 2FACh
.text$mn:00002FAC ; COMDAT (pick any)
.text$mn:00002FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FAC
.text$mn:00002FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00002FAC
.text$mn:00002FAC ; Attributes: bp-based frame
.text$mn:00002FAC
.text$mn:00002FAC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002FAC                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002FAC ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002FAC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00002FAC
.text$mn:00002FAC var_10          = dword ptr -10h
.text$mn:00002FAC var_C           = dword ptr -0Ch
.text$mn:00002FAC var_4           = dword ptr -4
.text$mn:00002FAC
.text$mn:00002FAC                 push    ebp
.text$mn:00002FAD                 mov     ebp, esp
.text$mn:00002FAF                 push    0FFFFFFFFh
.text$mn:00002FB1                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002FB6                 mov     eax, large fs:0
.text$mn:00002FBC                 push    eax
.text$mn:00002FBD                 push    ecx
.text$mn:00002FBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002FC3                 xor     eax, ebp
.text$mn:00002FC5                 push    eax
.text$mn:00002FC6                 lea     eax, [ebp+var_C]
.text$mn:00002FC9                 mov     large fs:0, eax
.text$mn:00002FCF                 mov     [ebp+var_10], ecx
.text$mn:00002FD2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002FD5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002FDA                 mov     [ebp+var_4], 0
.text$mn:00002FE1                 mov     eax, [ebp+var_10]
.text$mn:00002FE4                 mov     dword ptr [eax+14h], 0
.text$mn:00002FEB                 mov     ecx, [ebp+var_10]
.text$mn:00002FEE                 mov     dword ptr [ecx+18h], 0
.text$mn:00002FF5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002FFC                 mov     eax, [ebp+var_10]
.text$mn:00002FFF                 mov     ecx, [ebp+var_C]
.text$mn:00003002                 mov     large fs:0, ecx
.text$mn:00003009                 pop     ecx
.text$mn:0000300A                 mov     esp, ebp
.text$mn:0000300C                 pop     ebp
.text$mn:0000300D                 retn
.text$mn:0000300D ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000300D
.text$mn:0000300D ; ---------------------------------------------------------------------------
.text$mn:0000300E                 align 10h
.text$mn:0000300E _text$mn        ends
.text$mn:0000300E
.text$x:00003010 ; ===========================================================================
.text$x:00003010
.text$x:00003010 ; Segment type: Pure code
.text$x:00003010 ; Segment permissions: Read/Execute
.text$x:00003010 _text$x         segment para public 'CODE' use32
.text$x:00003010                 assume cs:_text$x
.text$x:00003010                 ;org 3010h
.text$x:00003010 ; COMDAT (pick associative to section at 2FAC)
.text$x:00003010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003010
.text$x:00003010 ; =============== S U B R O U T I N E =======================================
.text$x:00003010
.text$x:00003010
.text$x:00003010 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00003010                                         ; DATA XREF: .xdata$x:00007D48o
.text$x:00003010                 mov     ecx, [ebp-10h]  ; this
.text$x:00003013                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00003013 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00003013
.text$x:00003018
.text$x:00003018 ; =============== S U B R O U T I N E =======================================
.text$x:00003018
.text$x:00003018
.text$x:00003018 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00003018                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00003018
.text$x:00003018 arg_4           = dword ptr  8
.text$x:00003018
.text$x:00003018                 mov     edx, [esp+arg_4]
.text$x:0000301C                 lea     eax, [edx+0Ch]
.text$x:0000301F                 mov     ecx, [edx-8]
.text$x:00003022                 xor     ecx, eax
.text$x:00003024                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003029                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000302E                 jmp     ___CxxFrameHandler3
.text$x:0000302E __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000302E
.text$x:0000302E ; ---------------------------------------------------------------------------
.text$x:00003033                 align 4
.text$x:00003033 _text$x         ends
.text$x:00003033
.text$mn:00003034 ; ===========================================================================
.text$mn:00003034
.text$mn:00003034 ; Segment type: Pure code
.text$mn:00003034 ; Segment permissions: Read/Execute
.text$mn:00003034 _text$mn        segment para public 'CODE' use32
.text$mn:00003034                 assume cs:_text$mn
.text$mn:00003034                 ;org 3034h
.text$mn:00003034 ; COMDAT (pick any)
.text$mn:00003034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003034
.text$mn:00003034 ; =============== S U B R O U T I N E =======================================
.text$mn:00003034
.text$mn:00003034 ; Attributes: bp-based frame
.text$mn:00003034
.text$mn:00003034 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(class std::allocator<char> const &)
.text$mn:00003034                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00003034 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00003034                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00003034
.text$mn:00003034 var_4           = dword ptr -4
.text$mn:00003034 arg_0           = dword ptr  8
.text$mn:00003034
.text$mn:00003034                 push    ebp
.text$mn:00003035                 mov     ebp, esp
.text$mn:00003037                 push    ecx
.text$mn:00003038                 mov     [ebp+var_4], ecx
.text$mn:0000303B                 mov     eax, [ebp+arg_0]
.text$mn:0000303E                 push    eax
.text$mn:0000303F                 mov     ecx, [ebp+var_4]
.text$mn:00003042                 call    ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>(std::allocator<char> const &)
.text$mn:00003047                 mov     eax, [ebp+var_4]
.text$mn:0000304A                 mov     esp, ebp
.text$mn:0000304C                 pop     ebp
.text$mn:0000304D                 retn    4
.text$mn:0000304D ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:0000304D
.text$mn:0000304D _text$mn        ends
.text$mn:0000304D
.text$mn:00003050 ; ===========================================================================
.text$mn:00003050
.text$mn:00003050 ; Segment type: Pure code
.text$mn:00003050 ; Segment permissions: Read/Execute
.text$mn:00003050 _text$mn        segment para public 'CODE' use32
.text$mn:00003050                 assume cs:_text$mn
.text$mn:00003050                 ;org 3050h
.text$mn:00003050 ; COMDAT (pick any)
.text$mn:00003050                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003050
.text$mn:00003050 ; =============== S U B R O U T I N E =======================================
.text$mn:00003050
.text$mn:00003050 ; Attributes: bp-based frame
.text$mn:00003050
.text$mn:00003050 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00003050                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00003050 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00003050                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00003050
.text$mn:00003050 var_4           = dword ptr -4
.text$mn:00003050
.text$mn:00003050                 push    ebp
.text$mn:00003051                 mov     ebp, esp
.text$mn:00003053                 push    ecx
.text$mn:00003054                 mov     [ebp+var_4], ecx
.text$mn:00003057                 mov     ecx, [ebp+var_4]
.text$mn:0000305A                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000305F                 mov     eax, [ebp+var_4]
.text$mn:00003062                 mov     esp, ebp
.text$mn:00003064                 pop     ebp
.text$mn:00003065                 retn
.text$mn:00003065 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00003065
.text$mn:00003065 ; ---------------------------------------------------------------------------
.text$mn:00003066                 align 4
.text$mn:00003066 _text$mn        ends
.text$mn:00003066
.text$mn:00003068 ; ===========================================================================
.text$mn:00003068
.text$mn:00003068 ; Segment type: Pure code
.text$mn:00003068 ; Segment permissions: Read/Execute
.text$mn:00003068 _text$mn        segment para public 'CODE' use32
.text$mn:00003068                 assume cs:_text$mn
.text$mn:00003068                 ;org 3068h
.text$mn:00003068 ; COMDAT (pick any)
.text$mn:00003068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003068
.text$mn:00003068 ; =============== S U B R O U T I N E =======================================
.text$mn:00003068
.text$mn:00003068 ; Attributes: bp-based frame
.text$mn:00003068
.text$mn:00003068 ; public: __thiscall std::_Yarn<char>::_Yarn<char>(void)
.text$mn:00003068                 public ??0?$_Yarn@D@std@@QAE@XZ
.text$mn:00003068 ??0?$_Yarn@D@std@@QAE@XZ proc near      ; CODE XREF: std::_Locinfo::_Locinfo(char const *)+3Fp
.text$mn:00003068                                         ; std::_Locinfo::_Locinfo(char const *)+4Ep ...
.text$mn:00003068
.text$mn:00003068 var_4           = dword ptr -4
.text$mn:00003068
.text$mn:00003068                 push    ebp
.text$mn:00003069                 mov     ebp, esp
.text$mn:0000306B                 push    ecx
.text$mn:0000306C                 mov     [ebp+var_4], ecx
.text$mn:0000306F                 mov     eax, [ebp+var_4]
.text$mn:00003072                 mov     dword ptr [eax], 0
.text$mn:00003078                 mov     ecx, [ebp+var_4]
.text$mn:0000307B                 mov     byte ptr [ecx+4], 0
.text$mn:0000307F                 mov     eax, [ebp+var_4]
.text$mn:00003082                 mov     esp, ebp
.text$mn:00003084                 pop     ebp
.text$mn:00003085                 retn
.text$mn:00003085 ??0?$_Yarn@D@std@@QAE@XZ endp
.text$mn:00003085
.text$mn:00003085 ; ---------------------------------------------------------------------------
.text$mn:00003086                 align 4
.text$mn:00003086 _text$mn        ends
.text$mn:00003086
.text$mn:00003088 ; ===========================================================================
.text$mn:00003088
.text$mn:00003088 ; Segment type: Pure code
.text$mn:00003088 ; Segment permissions: Read/Execute
.text$mn:00003088 _text$mn        segment para public 'CODE' use32
.text$mn:00003088                 assume cs:_text$mn
.text$mn:00003088                 ;org 3088h
.text$mn:00003088 ; COMDAT (pick any)
.text$mn:00003088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003088
.text$mn:00003088 ; =============== S U B R O U T I N E =======================================
.text$mn:00003088
.text$mn:00003088 ; Attributes: bp-based frame
.text$mn:00003088
.text$mn:00003088 ; public: __thiscall std::_Yarn<wchar_t>::_Yarn<wchar_t>(void)
.text$mn:00003088                 public ??0?$_Yarn@_W@std@@QAE@XZ
.text$mn:00003088 ??0?$_Yarn@_W@std@@QAE@XZ proc near     ; CODE XREF: std::_Locinfo::_Locinfo(char const *)+5Dp
.text$mn:00003088                                         ; std::_Locinfo::_Locinfo(char const *)+6Cp
.text$mn:00003088
.text$mn:00003088 var_4           = dword ptr -4
.text$mn:00003088
.text$mn:00003088                 push    ebp
.text$mn:00003089                 mov     ebp, esp
.text$mn:0000308B                 push    ecx
.text$mn:0000308C                 mov     [ebp+var_4], ecx
.text$mn:0000308F                 mov     eax, [ebp+var_4]
.text$mn:00003092                 mov     dword ptr [eax], 0
.text$mn:00003098                 xor     ecx, ecx
.text$mn:0000309A                 mov     edx, [ebp+var_4]
.text$mn:0000309D                 mov     [edx+4], cx
.text$mn:000030A1                 mov     eax, [ebp+var_4]
.text$mn:000030A4                 mov     esp, ebp
.text$mn:000030A6                 pop     ebp
.text$mn:000030A7                 retn
.text$mn:000030A7 ??0?$_Yarn@_W@std@@QAE@XZ endp
.text$mn:000030A7
.text$mn:000030A7 _text$mn        ends
.text$mn:000030A7
.text$mn:000030A8 ; ===========================================================================
.text$mn:000030A8
.text$mn:000030A8 ; Segment type: Pure code
.text$mn:000030A8 ; Segment permissions: Read/Execute
.text$mn:000030A8 _text$mn        segment para public 'CODE' use32
.text$mn:000030A8                 assume cs:_text$mn
.text$mn:000030A8                 ;org 30A8h
.text$mn:000030A8 ; COMDAT (pick any)
.text$mn:000030A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030A8
.text$mn:000030A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000030A8
.text$mn:000030A8 ; Attributes: bp-based frame
.text$mn:000030A8
.text$mn:000030A8 ; public: __thiscall std::allocator<char>::allocator<char>(class std::allocator<char> const &)
.text$mn:000030A8                 public ??0?$allocator@D@std@@QAE@ABV01@@Z
.text$mn:000030A8 ??0?$allocator@D@std@@QAE@ABV01@@Z proc near
.text$mn:000030A8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(std::allocator<char> const &)+Ep
.text$mn:000030A8                                         ; std::allocator<char>::select_on_container_copy_construction(void)+Ep
.text$mn:000030A8
.text$mn:000030A8 var_4           = dword ptr -4
.text$mn:000030A8
.text$mn:000030A8                 push    ebp
.text$mn:000030A9                 mov     ebp, esp
.text$mn:000030AB                 push    ecx
.text$mn:000030AC                 mov     [ebp+var_4], ecx
.text$mn:000030AF                 mov     eax, [ebp+var_4]
.text$mn:000030B2                 mov     esp, ebp
.text$mn:000030B4                 pop     ebp
.text$mn:000030B5                 retn    4
.text$mn:000030B5 ??0?$allocator@D@std@@QAE@ABV01@@Z endp
.text$mn:000030B5
.text$mn:000030B5 _text$mn        ends
.text$mn:000030B5
.text$mn:000030B8 ; ===========================================================================
.text$mn:000030B8
.text$mn:000030B8 ; Segment type: Pure code
.text$mn:000030B8 ; Segment permissions: Read/Execute
.text$mn:000030B8 _text$mn        segment para public 'CODE' use32
.text$mn:000030B8                 assume cs:_text$mn
.text$mn:000030B8                 ;org 30B8h
.text$mn:000030B8 ; COMDAT (pick any)
.text$mn:000030B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030B8
.text$mn:000030B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000030B8
.text$mn:000030B8 ; Attributes: bp-based frame
.text$mn:000030B8
.text$mn:000030B8 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:000030B8                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:000030B8 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:000030B8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp ...
.text$mn:000030B8
.text$mn:000030B8 var_4           = dword ptr -4
.text$mn:000030B8
.text$mn:000030B8                 push    ebp
.text$mn:000030B9                 mov     ebp, esp
.text$mn:000030BB                 push    ecx
.text$mn:000030BC                 mov     [ebp+var_4], ecx
.text$mn:000030BF                 mov     eax, [ebp+var_4]
.text$mn:000030C2                 mov     esp, ebp
.text$mn:000030C4                 pop     ebp
.text$mn:000030C5                 retn
.text$mn:000030C5 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000030C5
.text$mn:000030C5 ; ---------------------------------------------------------------------------
.text$mn:000030C6                 align 4
.text$mn:000030C6 _text$mn        ends
.text$mn:000030C6
.text$mn:000030C8 ; ===========================================================================
.text$mn:000030C8
.text$mn:000030C8 ; Segment type: Pure code
.text$mn:000030C8 ; Segment permissions: Read/Execute
.text$mn:000030C8 _text$mn        segment para public 'CODE' use32
.text$mn:000030C8                 assume cs:_text$mn
.text$mn:000030C8                 ;org 30C8h
.text$mn:000030C8 ; COMDAT (pick any)
.text$mn:000030C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030C8
.text$mn:000030C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000030C8
.text$mn:000030C8 ; Attributes: bp-based frame
.text$mn:000030C8
.text$mn:000030C8 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000030C8                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000030C8 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000030C8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000030C8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:000030C8
.text$mn:000030C8 var_4           = dword ptr -4
.text$mn:000030C8
.text$mn:000030C8                 push    ebp
.text$mn:000030C9                 mov     ebp, esp
.text$mn:000030CB                 push    ecx
.text$mn:000030CC                 mov     [ebp+var_4], ecx
.text$mn:000030CF                 mov     eax, [ebp+var_4]
.text$mn:000030D2                 mov     esp, ebp
.text$mn:000030D4                 pop     ebp
.text$mn:000030D5                 retn
.text$mn:000030D5 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000030D5
.text$mn:000030D5 ; ---------------------------------------------------------------------------
.text$mn:000030D6                 align 4
.text$mn:000030D6 _text$mn        ends
.text$mn:000030D6
.text$mn:000030D8 ; ===========================================================================
.text$mn:000030D8
.text$mn:000030D8 ; Segment type: Pure code
.text$mn:000030D8 ; Segment permissions: Read/Execute
.text$mn:000030D8 _text$mn        segment para public 'CODE' use32
.text$mn:000030D8                 assume cs:_text$mn
.text$mn:000030D8                 ;org 30D8h
.text$mn:000030D8 ; COMDAT (pick any)
.text$mn:000030D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030D8
.text$mn:000030D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000030D8
.text$mn:000030D8 ; Attributes: bp-based frame
.text$mn:000030D8
.text$mn:000030D8 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> &&)
.text$mn:000030D8                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
.text$mn:000030D8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z proc near
.text$mn:000030D8                                         ; CODE XREF: std::_System_error::_Makestr(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>>)+8Ap
.text$mn:000030D8
.text$mn:000030D8 var_14          = dword ptr -14h
.text$mn:000030D8 var_D           = byte ptr -0Dh
.text$mn:000030D8 var_C           = dword ptr -0Ch
.text$mn:000030D8 var_4           = dword ptr -4
.text$mn:000030D8 arg_0           = dword ptr  8
.text$mn:000030D8
.text$mn:000030D8                 push    ebp
.text$mn:000030D9                 mov     ebp, esp
.text$mn:000030DB                 push    0FFFFFFFFh
.text$mn:000030DD                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
.text$mn:000030E2                 mov     eax, large fs:0
.text$mn:000030E8                 push    eax
.text$mn:000030E9                 sub     esp, 8
.text$mn:000030EC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000030F1                 xor     eax, ebp
.text$mn:000030F3                 push    eax
.text$mn:000030F4                 lea     eax, [ebp+var_C]
.text$mn:000030F7                 mov     large fs:0, eax
.text$mn:000030FD                 mov     [ebp+var_14], ecx
.text$mn:00003100                 lea     eax, [ebp+var_D]
.text$mn:00003103                 push    eax
.text$mn:00003104                 mov     ecx, [ebp+arg_0]
.text$mn:00003107                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000310C                 push    eax
.text$mn:0000310D                 mov     ecx, [ebp+var_14]
.text$mn:00003110                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00003115                 mov     [ebp+var_4], 0
.text$mn:0000311C                 push    0               ; Size
.text$mn:0000311E                 push    0               ; char
.text$mn:00003120                 mov     ecx, [ebp+var_14]
.text$mn:00003123                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003128                 mov     ecx, [ebp+arg_0]
.text$mn:0000312B                 push    ecx
.text$mn:0000312C                 call    ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &)
.text$mn:00003131                 add     esp, 4
.text$mn:00003134                 push    eax
.text$mn:00003135                 mov     ecx, [ebp+var_14]
.text$mn:00003138                 call    ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
.text$mn:0000313D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003144                 mov     eax, [ebp+var_14]
.text$mn:00003147                 mov     ecx, [ebp+var_C]
.text$mn:0000314A                 mov     large fs:0, ecx
.text$mn:00003151                 pop     ecx
.text$mn:00003152                 mov     esp, ebp
.text$mn:00003154                 pop     ebp
.text$mn:00003155                 retn    4
.text$mn:00003155 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z endp
.text$mn:00003155
.text$mn:00003155 _text$mn        ends
.text$mn:00003155
.text$x:00003158 ; ===========================================================================
.text$x:00003158
.text$x:00003158 ; Segment type: Pure code
.text$x:00003158 ; Segment permissions: Read/Execute
.text$x:00003158 _text$x         segment para public 'CODE' use32
.text$x:00003158                 assume cs:_text$x
.text$x:00003158                 ;org 3158h
.text$x:00003158 ; COMDAT (pick associative to section at 30D8)
.text$x:00003158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003158
.text$x:00003158 ; =============== S U B R O U T I N E =======================================
.text$x:00003158
.text$x:00003158
.text$x:00003158 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:00003158                                         ; DATA XREF: .xdata$x:00007E7Co
.text$x:00003158                 mov     ecx, [ebp-14h]
.text$x:0000315B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000315B __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:0000315B
.text$x:00003160
.text$x:00003160 ; =============== S U B R O U T I N E =======================================
.text$x:00003160
.text$x:00003160
.text$x:00003160 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z proc near
.text$x:00003160                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+5o
.text$x:00003160
.text$x:00003160 arg_4           = dword ptr  8
.text$x:00003160
.text$x:00003160                 mov     edx, [esp+arg_4]
.text$x:00003164                 lea     eax, [edx+0Ch]
.text$x:00003167                 mov     ecx, [edx-0Ch]
.text$x:0000316A                 xor     ecx, eax
.text$x:0000316C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003171                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
.text$x:00003176                 jmp     ___CxxFrameHandler3
.text$x:00003176 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z endp
.text$x:00003176
.text$x:00003176 ; ---------------------------------------------------------------------------
.text$x:0000317B                 align 4
.text$x:0000317B _text$x         ends
.text$x:0000317B
.text$mn:0000317C ; ===========================================================================
.text$mn:0000317C
.text$mn:0000317C ; Segment type: Pure code
.text$mn:0000317C ; Segment permissions: Read/Execute
.text$mn:0000317C _text$mn        segment para public 'CODE' use32
.text$mn:0000317C                 assume cs:_text$mn
.text$mn:0000317C                 ;org 317Ch
.text$mn:0000317C ; COMDAT (pick any)
.text$mn:0000317C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000317C
.text$mn:0000317C ; =============== S U B R O U T I N E =======================================
.text$mn:0000317C
.text$mn:0000317C ; Attributes: bp-based frame
.text$mn:0000317C
.text$mn:0000317C ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
.text$mn:0000317C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
.text$mn:0000317C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z proc near
.text$mn:0000317C                                         ; CODE XREF: std::_System_error::_System_error(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+37p
.text$mn:0000317C
.text$mn:0000317C var_14          = dword ptr -14h
.text$mn:0000317C var_E           = byte ptr -0Eh
.text$mn:0000317C var_D           = byte ptr -0Dh
.text$mn:0000317C var_C           = dword ptr -0Ch
.text$mn:0000317C var_4           = dword ptr -4
.text$mn:0000317C arg_0           = dword ptr  8
.text$mn:0000317C
.text$mn:0000317C                 push    ebp
.text$mn:0000317D                 mov     ebp, esp
.text$mn:0000317F                 push    0FFFFFFFFh
.text$mn:00003181                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
.text$mn:00003186                 mov     eax, large fs:0
.text$mn:0000318C                 push    eax
.text$mn:0000318D                 sub     esp, 8
.text$mn:00003190                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003195                 xor     eax, ebp
.text$mn:00003197                 push    eax
.text$mn:00003198                 lea     eax, [ebp+var_C]
.text$mn:0000319B                 mov     large fs:0, eax
.text$mn:000031A1                 mov     [ebp+var_14], ecx
.text$mn:000031A4                 lea     eax, [ebp+var_D]
.text$mn:000031A7                 push    eax
.text$mn:000031A8                 lea     ecx, [ebp+var_E]
.text$mn:000031AB                 push    ecx
.text$mn:000031AC                 mov     ecx, [ebp+arg_0]
.text$mn:000031AF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000031B4                 mov     ecx, eax
.text$mn:000031B6                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char>>::select_on_container_copy_construction(void)
.text$mn:000031BB                 push    eax
.text$mn:000031BC                 mov     ecx, [ebp+var_14]
.text$mn:000031BF                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000031C4                 mov     [ebp+var_4], 0
.text$mn:000031CB                 push    0               ; Size
.text$mn:000031CD                 push    0               ; char
.text$mn:000031CF                 mov     ecx, [ebp+var_14]
.text$mn:000031D2                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000031D7                 mov     edx, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:000031DD                 push    edx
.text$mn:000031DE                 push    0
.text$mn:000031E0                 mov     eax, [ebp+arg_0]
.text$mn:000031E3                 push    eax
.text$mn:000031E4                 mov     ecx, [ebp+var_14]
.text$mn:000031E7                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000031EC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000031F3                 mov     eax, [ebp+var_14]
.text$mn:000031F6                 mov     ecx, [ebp+var_C]
.text$mn:000031F9                 mov     large fs:0, ecx
.text$mn:00003200                 pop     ecx
.text$mn:00003201                 mov     esp, ebp
.text$mn:00003203                 pop     ebp
.text$mn:00003204                 retn    4
.text$mn:00003204 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z endp
.text$mn:00003204
.text$mn:00003204 ; ---------------------------------------------------------------------------
.text$mn:00003207                 align 4
.text$mn:00003207 _text$mn        ends
.text$mn:00003207
.text$x:00003208 ; ===========================================================================
.text$x:00003208
.text$x:00003208 ; Segment type: Pure code
.text$x:00003208 ; Segment permissions: Read/Execute
.text$x:00003208 _text$x         segment para public 'CODE' use32
.text$x:00003208                 assume cs:_text$x
.text$x:00003208                 ;org 3208h
.text$x:00003208 ; COMDAT (pick associative to section at 317C)
.text$x:00003208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003208
.text$x:00003208 ; =============== S U B R O U T I N E =======================================
.text$x:00003208
.text$x:00003208
.text$x:00003208 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00003208                                         ; DATA XREF: .xdata$x:00007DF8o
.text$x:00003208                 mov     ecx, [ebp-14h]
.text$x:0000320B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000320B __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000320B
.text$x:00003210
.text$x:00003210 ; =============== S U B R O U T I N E =======================================
.text$x:00003210
.text$x:00003210
.text$x:00003210 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z proc near
.text$x:00003210                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5o
.text$x:00003210
.text$x:00003210 arg_4           = dword ptr  8
.text$x:00003210
.text$x:00003210                 mov     edx, [esp+arg_4]
.text$x:00003214                 lea     eax, [edx+0Ch]
.text$x:00003217                 mov     ecx, [edx-0Ch]
.text$x:0000321A                 xor     ecx, eax
.text$x:0000321C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003221                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
.text$x:00003226                 jmp     ___CxxFrameHandler3
.text$x:00003226 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z endp
.text$x:00003226
.text$x:00003226 ; ---------------------------------------------------------------------------
.text$x:0000322B                 align 4
.text$x:0000322B _text$x         ends
.text$x:0000322B
.text$mn:0000322C ; ===========================================================================
.text$mn:0000322C
.text$mn:0000322C ; Segment type: Pure code
.text$mn:0000322C ; Segment permissions: Read/Execute
.text$mn:0000322C _text$mn        segment para public 'CODE' use32
.text$mn:0000322C                 assume cs:_text$mn
.text$mn:0000322C                 ;org 322Ch
.text$mn:0000322C ; COMDAT (pick any)
.text$mn:0000322C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000322C
.text$mn:0000322C ; =============== S U B R O U T I N E =======================================
.text$mn:0000322C
.text$mn:0000322C ; Attributes: bp-based frame
.text$mn:0000322C
.text$mn:0000322C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:0000322C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000322C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:0000322C                                         ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+12Ap
.text$mn:0000322C                                         ; std::system_error::system_error(std::error_code,char const *)+32p ...
.text$mn:0000322C
.text$mn:0000322C var_14          = dword ptr -14h
.text$mn:0000322C var_D           = byte ptr -0Dh
.text$mn:0000322C var_C           = dword ptr -0Ch
.text$mn:0000322C var_4           = dword ptr -4
.text$mn:0000322C Str             = dword ptr  8
.text$mn:0000322C
.text$mn:0000322C                 push    ebp
.text$mn:0000322D                 mov     ebp, esp
.text$mn:0000322F                 push    0FFFFFFFFh
.text$mn:00003231                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00003236                 mov     eax, large fs:0
.text$mn:0000323C                 push    eax
.text$mn:0000323D                 sub     esp, 8
.text$mn:00003240                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003245                 xor     eax, ebp
.text$mn:00003247                 push    eax
.text$mn:00003248                 lea     eax, [ebp+var_C]
.text$mn:0000324B                 mov     large fs:0, eax
.text$mn:00003251                 mov     [ebp+var_14], ecx
.text$mn:00003254                 lea     ecx, [ebp+var_D]
.text$mn:00003257                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000325C                 push    eax
.text$mn:0000325D                 mov     ecx, [ebp+var_14]
.text$mn:00003260                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00003265                 mov     [ebp+var_4], 0
.text$mn:0000326C                 push    0               ; Size
.text$mn:0000326E                 push    0               ; char
.text$mn:00003270                 mov     ecx, [ebp+var_14]
.text$mn:00003273                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003278                 mov     eax, [ebp+Str]
.text$mn:0000327B                 push    eax             ; Str
.text$mn:0000327C                 mov     ecx, [ebp+var_14]
.text$mn:0000327F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00003284                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000328B                 mov     eax, [ebp+var_14]
.text$mn:0000328E                 mov     ecx, [ebp+var_C]
.text$mn:00003291                 mov     large fs:0, ecx
.text$mn:00003298                 pop     ecx
.text$mn:00003299                 mov     esp, ebp
.text$mn:0000329B                 pop     ebp
.text$mn:0000329C                 retn    4
.text$mn:0000329C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:0000329C
.text$mn:0000329C ; ---------------------------------------------------------------------------
.text$mn:0000329F                 align 10h
.text$mn:0000329F _text$mn        ends
.text$mn:0000329F
.text$x:000032A0 ; ===========================================================================
.text$x:000032A0
.text$x:000032A0 ; Segment type: Pure code
.text$x:000032A0 ; Segment permissions: Read/Execute
.text$x:000032A0 _text$x         segment para public 'CODE' use32
.text$x:000032A0                 assume cs:_text$x
.text$x:000032A0                 ;org 32A0h
.text$x:000032A0 ; COMDAT (pick associative to section at 322C)
.text$x:000032A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000032A0
.text$x:000032A0 ; =============== S U B R O U T I N E =======================================
.text$x:000032A0
.text$x:000032A0
.text$x:000032A0 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000032A0                                         ; DATA XREF: .xdata$x:00007E50o
.text$x:000032A0                 mov     ecx, [ebp-14h]
.text$x:000032A3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000032A3 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000032A3
.text$x:000032A8
.text$x:000032A8 ; =============== S U B R O U T I N E =======================================
.text$x:000032A8
.text$x:000032A8
.text$x:000032A8 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000032A8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000032A8
.text$x:000032A8 arg_4           = dword ptr  8
.text$x:000032A8
.text$x:000032A8                 mov     edx, [esp+arg_4]
.text$x:000032AC                 lea     eax, [edx+0Ch]
.text$x:000032AF                 mov     ecx, [edx-0Ch]
.text$x:000032B2                 xor     ecx, eax
.text$x:000032B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000032B9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000032BE                 jmp     ___CxxFrameHandler3
.text$x:000032BE __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000032BE
.text$x:000032BE ; ---------------------------------------------------------------------------
.text$x:000032C3                 align 4
.text$x:000032C3 _text$x         ends
.text$x:000032C3
.text$mn:000032C4 ; ===========================================================================
.text$mn:000032C4
.text$mn:000032C4 ; Segment type: Pure code
.text$mn:000032C4 ; Segment permissions: Read/Execute
.text$mn:000032C4 _text$mn        segment para public 'CODE' use32
.text$mn:000032C4                 assume cs:_text$mn
.text$mn:000032C4                 ;org 32C4h
.text$mn:000032C4 ; COMDAT (pick any)
.text$mn:000032C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032C4
.text$mn:000032C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032C4
.text$mn:000032C4 ; Attributes: bp-based frame
.text$mn:000032C4
.text$mn:000032C4 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000032C4                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000032C4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000032C4                                         ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+2Bp
.text$mn:000032C4                                         ; TiXmlAttributeA::TiXmlAttributeA(void)+44p ...
.text$mn:000032C4
.text$mn:000032C4 var_14          = dword ptr -14h
.text$mn:000032C4 var_D           = byte ptr -0Dh
.text$mn:000032C4 var_C           = dword ptr -0Ch
.text$mn:000032C4 var_4           = dword ptr -4
.text$mn:000032C4
.text$mn:000032C4                 push    ebp
.text$mn:000032C5                 mov     ebp, esp
.text$mn:000032C7                 push    0FFFFFFFFh
.text$mn:000032C9                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000032CE                 mov     eax, large fs:0
.text$mn:000032D4                 push    eax
.text$mn:000032D5                 sub     esp, 8
.text$mn:000032D8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000032DD                 xor     eax, ebp
.text$mn:000032DF                 push    eax
.text$mn:000032E0                 lea     eax, [ebp+var_C]
.text$mn:000032E3                 mov     large fs:0, eax
.text$mn:000032E9                 mov     [ebp+var_14], ecx
.text$mn:000032EC                 lea     ecx, [ebp+var_D]
.text$mn:000032EF                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000032F4                 push    eax
.text$mn:000032F5                 mov     ecx, [ebp+var_14]
.text$mn:000032F8                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000032FD                 mov     [ebp+var_4], 0
.text$mn:00003304                 push    0               ; Size
.text$mn:00003306                 push    0               ; char
.text$mn:00003308                 mov     ecx, [ebp+var_14]
.text$mn:0000330B                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003310                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003317                 mov     eax, [ebp+var_14]
.text$mn:0000331A                 mov     ecx, [ebp+var_C]
.text$mn:0000331D                 mov     large fs:0, ecx
.text$mn:00003324                 pop     ecx
.text$mn:00003325                 mov     esp, ebp
.text$mn:00003327                 pop     ebp
.text$mn:00003328                 retn
.text$mn:00003328 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00003328
.text$mn:00003328 ; ---------------------------------------------------------------------------
.text$mn:00003329                 align 4
.text$mn:00003329 _text$mn        ends
.text$mn:00003329
.text$x:0000332C ; ===========================================================================
.text$x:0000332C
.text$x:0000332C ; Segment type: Pure code
.text$x:0000332C ; Segment permissions: Read/Execute
.text$x:0000332C _text$x         segment para public 'CODE' use32
.text$x:0000332C                 assume cs:_text$x
.text$x:0000332C                 ;org 332Ch
.text$x:0000332C ; COMDAT (pick associative to section at 32C4)
.text$x:0000332C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000332C
.text$x:0000332C ; =============== S U B R O U T I N E =======================================
.text$x:0000332C
.text$x:0000332C
.text$x:0000332C __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:0000332C                                         ; DATA XREF: .xdata$x:00007E24o
.text$x:0000332C                 mov     ecx, [ebp-14h]
.text$x:0000332F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000332F __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000332F
.text$x:00003334
.text$x:00003334 ; =============== S U B R O U T I N E =======================================
.text$x:00003334
.text$x:00003334
.text$x:00003334 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00003334                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00003334
.text$x:00003334 arg_4           = dword ptr  8
.text$x:00003334
.text$x:00003334                 mov     edx, [esp+arg_4]
.text$x:00003338                 lea     eax, [edx+0Ch]
.text$x:0000333B                 mov     ecx, [edx-0Ch]
.text$x:0000333E                 xor     ecx, eax
.text$x:00003340                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003345                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:0000334A                 jmp     ___CxxFrameHandler3
.text$x:0000334A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:0000334A
.text$x:0000334A ; ---------------------------------------------------------------------------
.text$x:0000334F                 align 10h
.text$x:0000334F _text$x         ends
.text$x:0000334F
.text$mn:00003350 ; ===========================================================================
.text$mn:00003350
.text$mn:00003350 ; Segment type: Pure code
.text$mn:00003350 ; Segment permissions: Read/Execute
.text$mn:00003350 _text$mn        segment para public 'CODE' use32
.text$mn:00003350                 assume cs:_text$mn
.text$mn:00003350                 ;org 3350h
.text$mn:00003350 ; COMDAT (pick any)
.text$mn:00003350                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003350
.text$mn:00003350 ; =============== S U B R O U T I N E =======================================
.text$mn:00003350
.text$mn:00003350 ; Attributes: bp-based frame
.text$mn:00003350
.text$mn:00003350 ; public: __thiscall std::ctype<char>::ctype<char>(class std::_Locinfo const &, unsigned int)
.text$mn:00003350                 public ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
.text$mn:00003350 ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z proc near
.text$mn:00003350                                         ; CODE XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+A2p
.text$mn:00003350
.text$mn:00003350 var_10          = dword ptr -10h
.text$mn:00003350 var_C           = dword ptr -0Ch
.text$mn:00003350 var_4           = dword ptr -4
.text$mn:00003350 arg_0           = dword ptr  8
.text$mn:00003350 arg_4           = dword ptr  0Ch
.text$mn:00003350
.text$mn:00003350                 push    ebp
.text$mn:00003351                 mov     ebp, esp
.text$mn:00003353                 push    0FFFFFFFFh
.text$mn:00003355                 push    offset __ehhandler$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
.text$mn:0000335A                 mov     eax, large fs:0
.text$mn:00003360                 push    eax
.text$mn:00003361                 push    ecx
.text$mn:00003362                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003367                 xor     eax, ebp
.text$mn:00003369                 push    eax
.text$mn:0000336A                 lea     eax, [ebp+var_C]
.text$mn:0000336D                 mov     large fs:0, eax
.text$mn:00003373                 mov     [ebp+var_10], ecx
.text$mn:00003376                 mov     eax, [ebp+arg_4]
.text$mn:00003379                 push    eax             ; unsigned int
.text$mn:0000337A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000337D                 call    ??0ctype_base@std@@QAE@I@Z ; std::ctype_base::ctype_base(uint)
.text$mn:00003382                 mov     [ebp+var_4], 0
.text$mn:00003389                 mov     ecx, [ebp+var_10]
.text$mn:0000338C                 mov     dword ptr [ecx], offset ??_7?$ctype@D@std@@6B@ ; const std::ctype<char>::`vftable'
.text$mn:00003392                 mov     edx, [ebp+arg_0]
.text$mn:00003395                 push    edx
.text$mn:00003396                 mov     ecx, [ebp+var_10]
.text$mn:00003399                 call    ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ; std::ctype<char>::_Init(std::_Locinfo const &)
.text$mn:0000339E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000033A5                 mov     eax, [ebp+var_10]
.text$mn:000033A8                 mov     ecx, [ebp+var_C]
.text$mn:000033AB                 mov     large fs:0, ecx
.text$mn:000033B2                 pop     ecx
.text$mn:000033B3                 mov     esp, ebp
.text$mn:000033B5                 pop     ebp
.text$mn:000033B6                 retn    8
.text$mn:000033B6 ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z endp
.text$mn:000033B6
.text$mn:000033B6 ; ---------------------------------------------------------------------------
.text$mn:000033B9                 align 4
.text$mn:000033B9 _text$mn        ends
.text$mn:000033B9
.text$x:000033BC ; ===========================================================================
.text$x:000033BC
.text$x:000033BC ; Segment type: Pure code
.text$x:000033BC ; Segment permissions: Read/Execute
.text$x:000033BC _text$x         segment para public 'CODE' use32
.text$x:000033BC                 assume cs:_text$x
.text$x:000033BC                 ;org 33BCh
.text$x:000033BC ; COMDAT (pick associative to section at 3350)
.text$x:000033BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000033BC
.text$x:000033BC ; =============== S U B R O U T I N E =======================================
.text$x:000033BC
.text$x:000033BC
.text$x:000033BC __unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0 proc near
.text$x:000033BC                                         ; DATA XREF: .xdata$x:000081A4o
.text$x:000033BC                 mov     ecx, [ebp-10h]  ; this
.text$x:000033BF                 jmp     ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base(void)
.text$x:000033BF __unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0 endp
.text$x:000033BF
.text$x:000033C4
.text$x:000033C4 ; =============== S U B R O U T I N E =======================================
.text$x:000033C4
.text$x:000033C4
.text$x:000033C4 __ehhandler$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z proc near
.text$x:000033C4                                         ; DATA XREF: std::ctype<char>::ctype<char>(std::_Locinfo const &,uint)+5o
.text$x:000033C4
.text$x:000033C4 arg_4           = dword ptr  8
.text$x:000033C4
.text$x:000033C4                 mov     edx, [esp+arg_4]
.text$x:000033C8                 lea     eax, [edx+0Ch]
.text$x:000033CB                 mov     ecx, [edx-8]
.text$x:000033CE                 xor     ecx, eax
.text$x:000033D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000033D5                 mov     eax, offset __ehfuncinfo$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
.text$x:000033DA                 jmp     ___CxxFrameHandler3
.text$x:000033DA __ehhandler$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z endp
.text$x:000033DA
.text$x:000033DA ; ---------------------------------------------------------------------------
.text$x:000033DF                 align 10h
.text$x:000033DF _text$x         ends
.text$x:000033DF
.text$mn:000033E0 ; ===========================================================================
.text$mn:000033E0
.text$mn:000033E0 ; Segment type: Pure code
.text$mn:000033E0 ; Segment permissions: Read/Execute
.text$mn:000033E0 _text$mn        segment para public 'CODE' use32
.text$mn:000033E0                 assume cs:_text$mn
.text$mn:000033E0                 ;org 33E0h
.text$mn:000033E0 ; COMDAT (pick any)
.text$mn:000033E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033E0
.text$mn:000033E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000033E0
.text$mn:000033E0 ; Attributes: bp-based frame
.text$mn:000033E0
.text$mn:000033E0 ; public: __thiscall TiXmlAttributeA::TiXmlAttributeA(void)
.text$mn:000033E0                 public ??0TiXmlAttributeA@@QAE@XZ
.text$mn:000033E0 ??0TiXmlAttributeA@@QAE@XZ proc near    ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+344p
.text$mn:000033E0                                         ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+169p ...
.text$mn:000033E0
.text$mn:000033E0 var_10          = dword ptr -10h
.text$mn:000033E0 var_C           = dword ptr -0Ch
.text$mn:000033E0 var_4           = dword ptr -4
.text$mn:000033E0
.text$mn:000033E0                 push    ebp
.text$mn:000033E1                 mov     ebp, esp
.text$mn:000033E3                 push    0FFFFFFFFh
.text$mn:000033E5                 push    offset __ehhandler$??0TiXmlAttributeA@@QAE@XZ
.text$mn:000033EA                 mov     eax, large fs:0
.text$mn:000033F0                 push    eax
.text$mn:000033F1                 push    ecx
.text$mn:000033F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000033F7                 xor     eax, ebp
.text$mn:000033F9                 push    eax
.text$mn:000033FA                 lea     eax, [ebp+var_C]
.text$mn:000033FD                 mov     large fs:0, eax
.text$mn:00003403                 mov     [ebp+var_10], ecx
.text$mn:00003406                 mov     ecx, [ebp+var_10]
.text$mn:00003409                 call    ??0TiXmlBaseA@@QAE@XZ ; TiXmlBaseA::TiXmlBaseA(void)
.text$mn:0000340E                 mov     [ebp+var_4], 0
.text$mn:00003415                 mov     eax, [ebp+var_10]
.text$mn:00003418                 mov     dword ptr [eax], offset ??_7TiXmlAttributeA@@6B@ ; const TiXmlAttributeA::`vftable'
.text$mn:0000341E                 mov     ecx, [ebp+var_10]
.text$mn:00003421                 add     ecx, 10h
.text$mn:00003424                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00003429                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000342D                 mov     ecx, [ebp+var_10]
.text$mn:00003430                 add     ecx, 2Ch ; ','
.text$mn:00003433                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00003438                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000343C                 mov     ecx, [ebp+var_10]
.text$mn:0000343F                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00003446                 mov     edx, [ebp+var_10]
.text$mn:00003449                 mov     dword ptr [edx+4Ch], 0
.text$mn:00003450                 mov     eax, [ebp+var_10]
.text$mn:00003453                 mov     dword ptr [eax+48h], 0
.text$mn:0000345A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003461                 mov     eax, [ebp+var_10]
.text$mn:00003464                 mov     ecx, [ebp+var_C]
.text$mn:00003467                 mov     large fs:0, ecx
.text$mn:0000346E                 pop     ecx
.text$mn:0000346F                 mov     esp, ebp
.text$mn:00003471                 pop     ebp
.text$mn:00003472                 retn
.text$mn:00003472 ??0TiXmlAttributeA@@QAE@XZ endp
.text$mn:00003472
.text$mn:00003472 ; ---------------------------------------------------------------------------
.text$mn:00003473                 align 4
.text$mn:00003473 _text$mn        ends
.text$mn:00003473
.text$x:00003474 ; ===========================================================================
.text$x:00003474
.text$x:00003474 ; Segment type: Pure code
.text$x:00003474 ; Segment permissions: Read/Execute
.text$x:00003474 _text$x         segment para public 'CODE' use32
.text$x:00003474                 assume cs:_text$x
.text$x:00003474                 ;org 3474h
.text$x:00003474 ; COMDAT (pick associative to section at 33E0)
.text$x:00003474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003474
.text$x:00003474 ; =============== S U B R O U T I N E =======================================
.text$x:00003474
.text$x:00003474
.text$x:00003474 __unwindfunclet$??0TiXmlAttributeA@@QAE@XZ$0 proc near
.text$x:00003474                                         ; DATA XREF: .xdata$x:0000896Co
.text$x:00003474                 mov     ecx, [ebp-10h]  ; this
.text$x:00003477                 jmp     ??1TiXmlBaseA@@UAE@XZ ; TiXmlBaseA::~TiXmlBaseA(void)
.text$x:00003477 __unwindfunclet$??0TiXmlAttributeA@@QAE@XZ$0 endp
.text$x:00003477
.text$x:0000347C
.text$x:0000347C ; =============== S U B R O U T I N E =======================================
.text$x:0000347C
.text$x:0000347C
.text$x:0000347C __unwindfunclet$??0TiXmlAttributeA@@QAE@XZ$1 proc near
.text$x:0000347C                                         ; DATA XREF: .xdata$x:00008974o
.text$x:0000347C                 mov     ecx, [ebp-10h]
.text$x:0000347F                 add     ecx, 10h
.text$x:00003482                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003482 __unwindfunclet$??0TiXmlAttributeA@@QAE@XZ$1 endp
.text$x:00003482
.text$x:00003487
.text$x:00003487 ; =============== S U B R O U T I N E =======================================
.text$x:00003487
.text$x:00003487
.text$x:00003487 __unwindfunclet$??0TiXmlAttributeA@@QAE@XZ$2 proc near
.text$x:00003487                                         ; DATA XREF: .xdata$x:0000897Co
.text$x:00003487                 mov     ecx, [ebp-10h]
.text$x:0000348A                 add     ecx, 2Ch ; ','
.text$x:0000348D                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000348D __unwindfunclet$??0TiXmlAttributeA@@QAE@XZ$2 endp
.text$x:0000348D
.text$x:00003492
.text$x:00003492 ; =============== S U B R O U T I N E =======================================
.text$x:00003492
.text$x:00003492
.text$x:00003492 __ehhandler$??0TiXmlAttributeA@@QAE@XZ proc near
.text$x:00003492                                         ; DATA XREF: TiXmlAttributeA::TiXmlAttributeA(void)+5o
.text$x:00003492
.text$x:00003492 arg_4           = dword ptr  8
.text$x:00003492
.text$x:00003492                 mov     edx, [esp+arg_4]
.text$x:00003496                 lea     eax, [edx+0Ch]
.text$x:00003499                 mov     ecx, [edx-8]
.text$x:0000349C                 xor     ecx, eax
.text$x:0000349E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000034A3                 mov     eax, offset __ehfuncinfo$??0TiXmlAttributeA@@QAE@XZ
.text$x:000034A8                 jmp     ___CxxFrameHandler3
.text$x:000034A8 __ehhandler$??0TiXmlAttributeA@@QAE@XZ endp
.text$x:000034A8
.text$x:000034A8 ; ---------------------------------------------------------------------------
.text$x:000034AD                 align 10h
.text$x:000034AD _text$x         ends
.text$x:000034AD
.text$mn:000034B0 ; ===========================================================================
.text$mn:000034B0
.text$mn:000034B0 ; Segment type: Pure code
.text$mn:000034B0 ; Segment permissions: Read/Execute
.text$mn:000034B0 _text$mn        segment para public 'CODE' use32
.text$mn:000034B0                 assume cs:_text$mn
.text$mn:000034B0                 ;org 34B0h
.text$mn:000034B0 ; COMDAT (pick any)
.text$mn:000034B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034B0
.text$mn:000034B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000034B0
.text$mn:000034B0 ; Attributes: bp-based frame
.text$mn:000034B0
.text$mn:000034B0 ; public: __thiscall TiXmlBaseA::TiXmlBaseA(void)
.text$mn:000034B0                 public ??0TiXmlBaseA@@QAE@XZ
.text$mn:000034B0 ??0TiXmlBaseA@@QAE@XZ proc near         ; CODE XREF: TiXmlAttributeA::TiXmlAttributeA(void)+29p
.text$mn:000034B0
.text$mn:000034B0 var_4           = dword ptr -4
.text$mn:000034B0
.text$mn:000034B0                 push    ebp
.text$mn:000034B1                 mov     ebp, esp
.text$mn:000034B3                 push    ecx
.text$mn:000034B4                 mov     [ebp+var_4], ecx
.text$mn:000034B7                 mov     eax, [ebp+var_4]
.text$mn:000034BA                 mov     dword ptr [eax], offset ??_7TiXmlBaseA@@6B@ ; const TiXmlBaseA::`vftable'
.text$mn:000034C0                 mov     ecx, [ebp+var_4]
.text$mn:000034C3                 add     ecx, 4
.text$mn:000034C6                 call    ??0TiXmlCursorA@@QAE@XZ ; TiXmlCursorA::TiXmlCursorA(void)
.text$mn:000034CB                 mov     eax, [ebp+var_4]
.text$mn:000034CE                 mov     esp, ebp
.text$mn:000034D0                 pop     ebp
.text$mn:000034D1                 retn
.text$mn:000034D1 ??0TiXmlBaseA@@QAE@XZ endp
.text$mn:000034D1
.text$mn:000034D1 ; ---------------------------------------------------------------------------
.text$mn:000034D2                 align 4
.text$mn:000034D2 _text$mn        ends
.text$mn:000034D2
.text$mn:000034D4 ; ===========================================================================
.text$mn:000034D4
.text$mn:000034D4 ; Segment type: Pure code
.text$mn:000034D4 ; Segment permissions: Read/Execute
.text$mn:000034D4 _text$mn        segment para public 'CODE' use32
.text$mn:000034D4                 assume cs:_text$mn
.text$mn:000034D4                 ;org 34D4h
.text$mn:000034D4 ; COMDAT (pick any)
.text$mn:000034D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034D4
.text$mn:000034D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034D4
.text$mn:000034D4 ; Attributes: bp-based frame
.text$mn:000034D4
.text$mn:000034D4 ; _DWORD __thiscall TiXmlCommentA::TiXmlCommentA(TiXmlCommentA *__hidden this)
.text$mn:000034D4                 public ??0TiXmlCommentA@@QAE@XZ
.text$mn:000034D4 ??0TiXmlCommentA@@QAE@XZ proc near      ; CODE XREF: TiXmlNodeA::Identify(char const *)+1A5p
.text$mn:000034D4
.text$mn:000034D4 var_10          = dword ptr -10h
.text$mn:000034D4 var_C           = dword ptr -0Ch
.text$mn:000034D4 var_4           = dword ptr -4
.text$mn:000034D4
.text$mn:000034D4                 push    ebp
.text$mn:000034D5                 mov     ebp, esp
.text$mn:000034D7                 push    0FFFFFFFFh
.text$mn:000034D9                 push    offset __ehhandler$??0TiXmlCommentA@@QAE@XZ
.text$mn:000034DE                 mov     eax, large fs:0
.text$mn:000034E4                 push    eax
.text$mn:000034E5                 push    ecx
.text$mn:000034E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000034EB                 xor     eax, ebp
.text$mn:000034ED                 push    eax
.text$mn:000034EE                 lea     eax, [ebp+var_C]
.text$mn:000034F1                 mov     large fs:0, eax
.text$mn:000034F7                 mov     [ebp+var_10], ecx
.text$mn:000034FA                 push    2
.text$mn:000034FC                 mov     ecx, [ebp+var_10]
.text$mn:000034FF                 call    ??0TiXmlNodeA@@IAE@W4NodeType@0@@Z ; TiXmlNodeA::TiXmlNodeA(TiXmlNodeA::NodeType)
.text$mn:00003504                 mov     [ebp+var_4], 0
.text$mn:0000350B                 mov     eax, [ebp+var_10]
.text$mn:0000350E                 mov     dword ptr [eax], offset ??_7TiXmlCommentA@@6B@ ; const TiXmlCommentA::`vftable'
.text$mn:00003514                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000351B                 mov     eax, [ebp+var_10]
.text$mn:0000351E                 mov     ecx, [ebp+var_C]
.text$mn:00003521                 mov     large fs:0, ecx
.text$mn:00003528                 pop     ecx
.text$mn:00003529                 mov     esp, ebp
.text$mn:0000352B                 pop     ebp
.text$mn:0000352C                 retn
.text$mn:0000352C ??0TiXmlCommentA@@QAE@XZ endp
.text$mn:0000352C
.text$mn:0000352C ; ---------------------------------------------------------------------------
.text$mn:0000352D                 align 10h
.text$mn:0000352D _text$mn        ends
.text$mn:0000352D
.text$x:00003530 ; ===========================================================================
.text$x:00003530
.text$x:00003530 ; Segment type: Pure code
.text$x:00003530 ; Segment permissions: Read/Execute
.text$x:00003530 _text$x         segment para public 'CODE' use32
.text$x:00003530                 assume cs:_text$x
.text$x:00003530                 ;org 3530h
.text$x:00003530 ; COMDAT (pick associative to section at 34D4)
.text$x:00003530                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003530
.text$x:00003530 ; =============== S U B R O U T I N E =======================================
.text$x:00003530
.text$x:00003530
.text$x:00003530 __unwindfunclet$??0TiXmlCommentA@@QAE@XZ$0 proc near
.text$x:00003530                                         ; DATA XREF: .xdata$x:000089E4o
.text$x:00003530                 mov     ecx, [ebp-10h]  ; this
.text$x:00003533                 jmp     ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$x:00003533 __unwindfunclet$??0TiXmlCommentA@@QAE@XZ$0 endp
.text$x:00003533
.text$x:00003538
.text$x:00003538 ; =============== S U B R O U T I N E =======================================
.text$x:00003538
.text$x:00003538
.text$x:00003538 __ehhandler$??0TiXmlCommentA@@QAE@XZ proc near
.text$x:00003538                                         ; DATA XREF: TiXmlCommentA::TiXmlCommentA(void)+5o
.text$x:00003538
.text$x:00003538 arg_4           = dword ptr  8
.text$x:00003538
.text$x:00003538                 mov     edx, [esp+arg_4]
.text$x:0000353C                 lea     eax, [edx+0Ch]
.text$x:0000353F                 mov     ecx, [edx-8]
.text$x:00003542                 xor     ecx, eax
.text$x:00003544                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003549                 mov     eax, offset __ehfuncinfo$??0TiXmlCommentA@@QAE@XZ
.text$x:0000354E                 jmp     ___CxxFrameHandler3
.text$x:0000354E __ehhandler$??0TiXmlCommentA@@QAE@XZ endp
.text$x:0000354E
.text$x:0000354E ; ---------------------------------------------------------------------------
.text$x:00003553                 align 4
.text$x:00003553 _text$x         ends
.text$x:00003553
.text$mn:00003554 ; ===========================================================================
.text$mn:00003554
.text$mn:00003554 ; Segment type: Pure code
.text$mn:00003554 ; Segment permissions: Read/Execute
.text$mn:00003554 _text$mn        segment para public 'CODE' use32
.text$mn:00003554                 assume cs:_text$mn
.text$mn:00003554                 ;org 3554h
.text$mn:00003554 ; COMDAT (pick any)
.text$mn:00003554                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003554
.text$mn:00003554 ; =============== S U B R O U T I N E =======================================
.text$mn:00003554
.text$mn:00003554 ; Attributes: bp-based frame
.text$mn:00003554
.text$mn:00003554 ; public: __thiscall TiXmlCursorA::TiXmlCursorA(void)
.text$mn:00003554                 public ??0TiXmlCursorA@@QAE@XZ
.text$mn:00003554 ??0TiXmlCursorA@@QAE@XZ proc near       ; CODE XREF: TiXmlBaseA::TiXmlBaseA(void)+16p
.text$mn:00003554                                         ; TiXmlParsingDataA::TiXmlParsingDataA(char const *,int,int,int)+Ap
.text$mn:00003554
.text$mn:00003554 var_4           = dword ptr -4
.text$mn:00003554
.text$mn:00003554                 push    ebp
.text$mn:00003555                 mov     ebp, esp
.text$mn:00003557                 push    ecx
.text$mn:00003558                 mov     [ebp+var_4], ecx
.text$mn:0000355B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000355E                 call    ?Clear@TiXmlCursorA@@QAEXXZ ; TiXmlCursorA::Clear(void)
.text$mn:00003563                 mov     eax, [ebp+var_4]
.text$mn:00003566                 mov     esp, ebp
.text$mn:00003568                 pop     ebp
.text$mn:00003569                 retn
.text$mn:00003569 ??0TiXmlCursorA@@QAE@XZ endp
.text$mn:00003569
.text$mn:00003569 ; ---------------------------------------------------------------------------
.text$mn:0000356A                 align 4
.text$mn:0000356A _text$mn        ends
.text$mn:0000356A
.text$mn:0000356C ; ===========================================================================
.text$mn:0000356C
.text$mn:0000356C ; Segment type: Pure code
.text$mn:0000356C ; Segment permissions: Read/Execute
.text$mn:0000356C _text$mn        segment para public 'CODE' use32
.text$mn:0000356C                 assume cs:_text$mn
.text$mn:0000356C                 ;org 356Ch
.text$mn:0000356C ; COMDAT (pick any)
.text$mn:0000356C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000356C
.text$mn:0000356C ; =============== S U B R O U T I N E =======================================
.text$mn:0000356C
.text$mn:0000356C ; Attributes: bp-based frame
.text$mn:0000356C
.text$mn:0000356C ; _DWORD __thiscall TiXmlDeclarationA::TiXmlDeclarationA(TiXmlDeclarationA *__hidden this)
.text$mn:0000356C                 public ??0TiXmlDeclarationA@@QAE@XZ
.text$mn:0000356C ??0TiXmlDeclarationA@@QAE@XZ proc near  ; CODE XREF: TiXmlNodeA::Identify(char const *)+D8p
.text$mn:0000356C
.text$mn:0000356C var_10          = dword ptr -10h
.text$mn:0000356C var_C           = dword ptr -0Ch
.text$mn:0000356C var_4           = dword ptr -4
.text$mn:0000356C
.text$mn:0000356C                 push    ebp
.text$mn:0000356D                 mov     ebp, esp
.text$mn:0000356F                 push    0FFFFFFFFh
.text$mn:00003571                 push    offset __ehhandler$??0TiXmlDeclarationA@@QAE@XZ
.text$mn:00003576                 mov     eax, large fs:0
.text$mn:0000357C                 push    eax
.text$mn:0000357D                 push    ecx
.text$mn:0000357E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003583                 xor     eax, ebp
.text$mn:00003585                 push    eax
.text$mn:00003586                 lea     eax, [ebp+var_C]
.text$mn:00003589                 mov     large fs:0, eax
.text$mn:0000358F                 mov     [ebp+var_10], ecx
.text$mn:00003592                 push    5
.text$mn:00003594                 mov     ecx, [ebp+var_10]
.text$mn:00003597                 call    ??0TiXmlNodeA@@IAE@W4NodeType@0@@Z ; TiXmlNodeA::TiXmlNodeA(TiXmlNodeA::NodeType)
.text$mn:0000359C                 mov     [ebp+var_4], 0
.text$mn:000035A3                 mov     eax, [ebp+var_10]
.text$mn:000035A6                 mov     dword ptr [eax], offset ??_7TiXmlDeclarationA@@6B@ ; const TiXmlDeclarationA::`vftable'
.text$mn:000035AC                 mov     ecx, [ebp+var_10]
.text$mn:000035AF                 add     ecx, 44h ; 'D'
.text$mn:000035B2                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000035B7                 mov     byte ptr [ebp+var_4], 1
.text$mn:000035BB                 mov     ecx, [ebp+var_10]
.text$mn:000035BE                 add     ecx, 60h ; '`'
.text$mn:000035C1                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000035C6                 mov     byte ptr [ebp+var_4], 2
.text$mn:000035CA                 mov     ecx, [ebp+var_10]
.text$mn:000035CD                 add     ecx, 7Ch ; '|'
.text$mn:000035D0                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000035D5                 mov     byte ptr [ebp+var_4], 3
.text$mn:000035D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000035E0                 mov     eax, [ebp+var_10]
.text$mn:000035E3                 mov     ecx, [ebp+var_C]
.text$mn:000035E6                 mov     large fs:0, ecx
.text$mn:000035ED                 pop     ecx
.text$mn:000035EE                 mov     esp, ebp
.text$mn:000035F0                 pop     ebp
.text$mn:000035F1                 retn
.text$mn:000035F1 ??0TiXmlDeclarationA@@QAE@XZ endp
.text$mn:000035F1
.text$mn:000035F1 ; ---------------------------------------------------------------------------
.text$mn:000035F2                 align 4
.text$mn:000035F2 _text$mn        ends
.text$mn:000035F2
.text$x:000035F4 ; ===========================================================================
.text$x:000035F4
.text$x:000035F4 ; Segment type: Pure code
.text$x:000035F4 ; Segment permissions: Read/Execute
.text$x:000035F4 _text$x         segment para public 'CODE' use32
.text$x:000035F4                 assume cs:_text$x
.text$x:000035F4                 ;org 35F4h
.text$x:000035F4 ; COMDAT (pick associative to section at 356C)
.text$x:000035F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000035F4
.text$x:000035F4 ; =============== S U B R O U T I N E =======================================
.text$x:000035F4
.text$x:000035F4
.text$x:000035F4 __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$0 proc near
.text$x:000035F4                                         ; DATA XREF: .xdata$x:00008A94o
.text$x:000035F4                 mov     ecx, [ebp-10h]  ; this
.text$x:000035F7                 jmp     ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$x:000035F7 __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$0 endp
.text$x:000035F7
.text$x:000035FC
.text$x:000035FC ; =============== S U B R O U T I N E =======================================
.text$x:000035FC
.text$x:000035FC
.text$x:000035FC __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$1 proc near
.text$x:000035FC                                         ; DATA XREF: .xdata$x:00008A9Co
.text$x:000035FC                 mov     ecx, [ebp-10h]
.text$x:000035FF                 add     ecx, 44h ; 'D'
.text$x:00003602                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003602 __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$1 endp
.text$x:00003602
.text$x:00003607
.text$x:00003607 ; =============== S U B R O U T I N E =======================================
.text$x:00003607
.text$x:00003607
.text$x:00003607 __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$2 proc near
.text$x:00003607                                         ; DATA XREF: .xdata$x:00008AA4o
.text$x:00003607                 mov     ecx, [ebp-10h]
.text$x:0000360A                 add     ecx, 60h ; '`'
.text$x:0000360D                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000360D __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$2 endp
.text$x:0000360D
.text$x:00003612
.text$x:00003612 ; =============== S U B R O U T I N E =======================================
.text$x:00003612
.text$x:00003612
.text$x:00003612 __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$3 proc near
.text$x:00003612                                         ; DATA XREF: .xdata$x:00008AACo
.text$x:00003612                 mov     ecx, [ebp-10h]
.text$x:00003615                 add     ecx, 7Ch ; '|'
.text$x:00003618                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003618 __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$3 endp
.text$x:00003618
.text$x:0000361D
.text$x:0000361D ; =============== S U B R O U T I N E =======================================
.text$x:0000361D
.text$x:0000361D
.text$x:0000361D __ehhandler$??0TiXmlDeclarationA@@QAE@XZ proc near
.text$x:0000361D                                         ; DATA XREF: TiXmlDeclarationA::TiXmlDeclarationA(void)+5o
.text$x:0000361D
.text$x:0000361D arg_4           = dword ptr  8
.text$x:0000361D
.text$x:0000361D                 mov     edx, [esp+arg_4]
.text$x:00003621                 lea     eax, [edx+0Ch]
.text$x:00003624                 mov     ecx, [edx-8]
.text$x:00003627                 xor     ecx, eax
.text$x:00003629                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000362E                 mov     eax, offset __ehfuncinfo$??0TiXmlDeclarationA@@QAE@XZ
.text$x:00003633                 jmp     ___CxxFrameHandler3
.text$x:00003633 __ehhandler$??0TiXmlDeclarationA@@QAE@XZ endp
.text$x:00003633
.text$x:00003633 _text$x         ends
.text$x:00003633
.text$mn:00003638 ; ===========================================================================
.text$mn:00003638
.text$mn:00003638 ; Segment type: Pure code
.text$mn:00003638 ; Segment permissions: Read/Execute
.text$mn:00003638 _text$mn        segment para public 'CODE' use32
.text$mn:00003638                 assume cs:_text$mn
.text$mn:00003638                 ;org 3638h
.text$mn:00003638 ; COMDAT (pick any)
.text$mn:00003638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003638
.text$mn:00003638 ; =============== S U B R O U T I N E =======================================
.text$mn:00003638
.text$mn:00003638 ; Attributes: bp-based frame
.text$mn:00003638
.text$mn:00003638 ; private: __thiscall TiXmlParsingDataA::TiXmlParsingDataA(char const *, int, int, int)
.text$mn:00003638                 public ??0TiXmlParsingDataA@@AAE@PBDHHH@Z
.text$mn:00003638 ??0TiXmlParsingDataA@@AAE@PBDHHH@Z proc near
.text$mn:00003638                                         ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+92p
.text$mn:00003638
.text$mn:00003638 var_4           = dword ptr -4
.text$mn:00003638 arg_0           = dword ptr  8
.text$mn:00003638 arg_4           = dword ptr  0Ch
.text$mn:00003638 arg_8           = dword ptr  10h
.text$mn:00003638 arg_C           = dword ptr  14h
.text$mn:00003638
.text$mn:00003638                 push    ebp
.text$mn:00003639                 mov     ebp, esp
.text$mn:0000363B                 push    ecx
.text$mn:0000363C                 mov     [ebp+var_4], ecx
.text$mn:0000363F                 mov     ecx, [ebp+var_4]
.text$mn:00003642                 call    ??0TiXmlCursorA@@QAE@XZ ; TiXmlCursorA::TiXmlCursorA(void)
.text$mn:00003647                 cmp     [ebp+arg_0], 0
.text$mn:0000364B                 jnz     short loc_3661
.text$mn:0000364D                 push    39h ; '9'       ; Line
.text$mn:0000364F                 push    offset ??_C@_1FG@OIOOBCOF@?$AA?4?$AA?4?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAT?$AAi?$AAn?$AAy?$AAX?$AAm?$AAl?$AA?2?$AAt?$AAi?$AAn?$AAy?$AAX?$AAm?$AAl?$AAA?$AA?2?$AAt?$AAi?$AAn?$AAy?$AAx?$AAm?$AAl?$AAp@ ; "..\\src\\TinyXml\\tinyXmlA\\tinyxmlpars"...
.text$mn:00003654                 push    offset ??_C@_1M@JGKKHEFC@?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?$AA@ ; "start"
.text$mn:00003659                 call    __wassert
.text$mn:0000365E ; ---------------------------------------------------------------------------
.text$mn:0000365E                 add     esp, 0Ch
.text$mn:00003661
.text$mn:00003661 loc_3661:                               ; CODE XREF: TiXmlParsingDataA::TiXmlParsingDataA(char const *,int,int,int)+13j
.text$mn:00003661                 mov     ecx, [ebp+var_4]
.text$mn:00003664                 mov     edx, [ebp+arg_0]
.text$mn:00003667                 mov     [ecx+8], edx
.text$mn:0000366A                 mov     eax, [ebp+var_4]
.text$mn:0000366D                 mov     ecx, [ebp+arg_4]
.text$mn:00003670                 mov     [eax+0Ch], ecx
.text$mn:00003673                 mov     edx, [ebp+var_4]
.text$mn:00003676                 mov     eax, [ebp+arg_8]
.text$mn:00003679                 mov     [edx], eax
.text$mn:0000367B                 mov     ecx, [ebp+var_4]
.text$mn:0000367E                 mov     edx, [ebp+arg_C]
.text$mn:00003681                 mov     [ecx+4], edx
.text$mn:00003684                 mov     eax, [ebp+var_4]
.text$mn:00003687                 mov     esp, ebp
.text$mn:00003689                 pop     ebp
.text$mn:0000368A                 retn    10h
.text$mn:0000368A ??0TiXmlParsingDataA@@AAE@PBDHHH@Z endp
.text$mn:0000368A
.text$mn:0000368A ; ---------------------------------------------------------------------------
.text$mn:0000368D                 align 10h
.text$mn:0000368D _text$mn        ends
.text$mn:0000368D
.text$mn:00003690 ; ===========================================================================
.text$mn:00003690
.text$mn:00003690 ; Segment type: Pure code
.text$mn:00003690 ; Segment permissions: Read/Execute
.text$mn:00003690 _text$mn        segment para public 'CODE' use32
.text$mn:00003690                 assume cs:_text$mn
.text$mn:00003690                 ;org 3690h
.text$mn:00003690 ; COMDAT (pick any)
.text$mn:00003690                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003690
.text$mn:00003690 ; =============== S U B R O U T I N E =======================================
.text$mn:00003690
.text$mn:00003690 ; Attributes: bp-based frame
.text$mn:00003690
.text$mn:00003690 ; int __stdcall TiXmlTextA::TiXmlTextA(char *)
.text$mn:00003690                 public ??0TiXmlTextA@@QAE@PBD@Z
.text$mn:00003690 ??0TiXmlTextA@@QAE@PBD@Z proc near      ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+116p
.text$mn:00003690                                         ; TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+8Bp
.text$mn:00003690
.text$mn:00003690 var_10          = dword ptr -10h
.text$mn:00003690 var_C           = dword ptr -0Ch
.text$mn:00003690 var_4           = dword ptr -4
.text$mn:00003690 arg_0           = dword ptr  8
.text$mn:00003690
.text$mn:00003690                 push    ebp
.text$mn:00003691                 mov     ebp, esp
.text$mn:00003693                 push    0FFFFFFFFh
.text$mn:00003695                 push    offset __ehhandler$??0TiXmlTextA@@QAE@PBD@Z
.text$mn:0000369A                 mov     eax, large fs:0
.text$mn:000036A0                 push    eax
.text$mn:000036A1                 push    ecx
.text$mn:000036A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000036A7                 xor     eax, ebp
.text$mn:000036A9                 push    eax
.text$mn:000036AA                 lea     eax, [ebp+var_C]
.text$mn:000036AD                 mov     large fs:0, eax
.text$mn:000036B3                 mov     [ebp+var_10], ecx
.text$mn:000036B6                 push    4
.text$mn:000036B8                 mov     ecx, [ebp+var_10]
.text$mn:000036BB                 call    ??0TiXmlNodeA@@IAE@W4NodeType@0@@Z ; TiXmlNodeA::TiXmlNodeA(TiXmlNodeA::NodeType)
.text$mn:000036C0                 mov     [ebp+var_4], 0
.text$mn:000036C7                 mov     eax, [ebp+var_10]
.text$mn:000036CA                 mov     dword ptr [eax], offset ??_7TiXmlTextA@@6B@ ; const TiXmlTextA::`vftable'
.text$mn:000036D0                 mov     ecx, [ebp+arg_0]
.text$mn:000036D3                 push    ecx             ; char *
.text$mn:000036D4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000036D7                 call    ?SetValue@TiXmlNodeA@@QAEXPBD@Z ; TiXmlNodeA::SetValue(char const *)
.text$mn:000036DC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000036E3                 mov     eax, [ebp+var_10]
.text$mn:000036E6                 mov     ecx, [ebp+var_C]
.text$mn:000036E9                 mov     large fs:0, ecx
.text$mn:000036F0                 pop     ecx
.text$mn:000036F1                 mov     esp, ebp
.text$mn:000036F3                 pop     ebp
.text$mn:000036F4                 retn    4
.text$mn:000036F4 ??0TiXmlTextA@@QAE@PBD@Z endp
.text$mn:000036F4
.text$mn:000036F4 ; ---------------------------------------------------------------------------
.text$mn:000036F7                 align 4
.text$mn:000036F7 _text$mn        ends
.text$mn:000036F7
.text$x:000036F8 ; ===========================================================================
.text$x:000036F8
.text$x:000036F8 ; Segment type: Pure code
.text$x:000036F8 ; Segment permissions: Read/Execute
.text$x:000036F8 _text$x         segment para public 'CODE' use32
.text$x:000036F8                 assume cs:_text$x
.text$x:000036F8                 ;org 36F8h
.text$x:000036F8 ; COMDAT (pick associative to section at 3690)
.text$x:000036F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000036F8
.text$x:000036F8 ; =============== S U B R O U T I N E =======================================
.text$x:000036F8
.text$x:000036F8
.text$x:000036F8 __unwindfunclet$??0TiXmlTextA@@QAE@PBD@Z$0 proc near
.text$x:000036F8                                         ; DATA XREF: .xdata$x:00008A3Co
.text$x:000036F8                 mov     ecx, [ebp-10h]  ; this
.text$x:000036FB                 jmp     ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$x:000036FB __unwindfunclet$??0TiXmlTextA@@QAE@PBD@Z$0 endp
.text$x:000036FB
.text$x:00003700
.text$x:00003700 ; =============== S U B R O U T I N E =======================================
.text$x:00003700
.text$x:00003700
.text$x:00003700 __ehhandler$??0TiXmlTextA@@QAE@PBD@Z proc near
.text$x:00003700                                         ; DATA XREF: TiXmlTextA::TiXmlTextA(char const *)+5o
.text$x:00003700
.text$x:00003700 arg_4           = dword ptr  8
.text$x:00003700
.text$x:00003700                 mov     edx, [esp+arg_4]
.text$x:00003704                 lea     eax, [edx+0Ch]
.text$x:00003707                 mov     ecx, [edx-8]
.text$x:0000370A                 xor     ecx, eax
.text$x:0000370C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003711                 mov     eax, offset __ehfuncinfo$??0TiXmlTextA@@QAE@PBD@Z
.text$x:00003716                 jmp     ___CxxFrameHandler3
.text$x:00003716 __ehhandler$??0TiXmlTextA@@QAE@PBD@Z endp
.text$x:00003716
.text$x:00003716 ; ---------------------------------------------------------------------------
.text$x:0000371B                 align 4
.text$x:0000371B _text$x         ends
.text$x:0000371B
.text$mn:0000371C ; ===========================================================================
.text$mn:0000371C
.text$mn:0000371C ; Segment type: Pure code
.text$mn:0000371C ; Segment permissions: Read/Execute
.text$mn:0000371C _text$mn        segment para public 'CODE' use32
.text$mn:0000371C                 assume cs:_text$mn
.text$mn:0000371C                 ;org 371Ch
.text$mn:0000371C ; COMDAT (pick any)
.text$mn:0000371C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000371C
.text$mn:0000371C ; =============== S U B R O U T I N E =======================================
.text$mn:0000371C
.text$mn:0000371C ; Attributes: bp-based frame
.text$mn:0000371C
.text$mn:0000371C ; _DWORD __thiscall TiXmlUnknownA::TiXmlUnknownA(TiXmlUnknownA *__hidden this)
.text$mn:0000371C                 public ??0TiXmlUnknownA@@QAE@XZ
.text$mn:0000371C ??0TiXmlUnknownA@@QAE@XZ proc near      ; CODE XREF: TiXmlNodeA::Identify(char const *)+1E8p
.text$mn:0000371C
.text$mn:0000371C var_10          = dword ptr -10h
.text$mn:0000371C var_C           = dword ptr -0Ch
.text$mn:0000371C var_4           = dword ptr -4
.text$mn:0000371C
.text$mn:0000371C                 push    ebp
.text$mn:0000371D                 mov     ebp, esp
.text$mn:0000371F                 push    0FFFFFFFFh
.text$mn:00003721                 push    offset __ehhandler$??0TiXmlUnknownA@@QAE@XZ
.text$mn:00003726                 mov     eax, large fs:0
.text$mn:0000372C                 push    eax
.text$mn:0000372D                 push    ecx
.text$mn:0000372E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003733                 xor     eax, ebp
.text$mn:00003735                 push    eax
.text$mn:00003736                 lea     eax, [ebp+var_C]
.text$mn:00003739                 mov     large fs:0, eax
.text$mn:0000373F                 mov     [ebp+var_10], ecx
.text$mn:00003742                 push    3
.text$mn:00003744                 mov     ecx, [ebp+var_10]
.text$mn:00003747                 call    ??0TiXmlNodeA@@IAE@W4NodeType@0@@Z ; TiXmlNodeA::TiXmlNodeA(TiXmlNodeA::NodeType)
.text$mn:0000374C                 mov     [ebp+var_4], 0
.text$mn:00003753                 mov     eax, [ebp+var_10]
.text$mn:00003756                 mov     dword ptr [eax], offset ??_7TiXmlUnknownA@@6B@ ; const TiXmlUnknownA::`vftable'
.text$mn:0000375C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003763                 mov     eax, [ebp+var_10]
.text$mn:00003766                 mov     ecx, [ebp+var_C]
.text$mn:00003769                 mov     large fs:0, ecx
.text$mn:00003770                 pop     ecx
.text$mn:00003771                 mov     esp, ebp
.text$mn:00003773                 pop     ebp
.text$mn:00003774                 retn
.text$mn:00003774 ??0TiXmlUnknownA@@QAE@XZ endp
.text$mn:00003774
.text$mn:00003774 ; ---------------------------------------------------------------------------
.text$mn:00003775                 align 4
.text$mn:00003775 _text$mn        ends
.text$mn:00003775
.text$x:00003778 ; ===========================================================================
.text$x:00003778
.text$x:00003778 ; Segment type: Pure code
.text$x:00003778 ; Segment permissions: Read/Execute
.text$x:00003778 _text$x         segment para public 'CODE' use32
.text$x:00003778                 assume cs:_text$x
.text$x:00003778                 ;org 3778h
.text$x:00003778 ; COMDAT (pick associative to section at 371C)
.text$x:00003778                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003778
.text$x:00003778 ; =============== S U B R O U T I N E =======================================
.text$x:00003778
.text$x:00003778
.text$x:00003778 __unwindfunclet$??0TiXmlUnknownA@@QAE@XZ$0 proc near
.text$x:00003778                                         ; DATA XREF: .xdata$x:00008B1Co
.text$x:00003778                 mov     ecx, [ebp-10h]  ; this
.text$x:0000377B                 jmp     ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$x:0000377B __unwindfunclet$??0TiXmlUnknownA@@QAE@XZ$0 endp
.text$x:0000377B
.text$x:00003780
.text$x:00003780 ; =============== S U B R O U T I N E =======================================
.text$x:00003780
.text$x:00003780
.text$x:00003780 __ehhandler$??0TiXmlUnknownA@@QAE@XZ proc near
.text$x:00003780                                         ; DATA XREF: TiXmlUnknownA::TiXmlUnknownA(void)+5o
.text$x:00003780
.text$x:00003780 arg_4           = dword ptr  8
.text$x:00003780
.text$x:00003780                 mov     edx, [esp+arg_4]
.text$x:00003784                 lea     eax, [edx+0Ch]
.text$x:00003787                 mov     ecx, [edx-8]
.text$x:0000378A                 xor     ecx, eax
.text$x:0000378C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003791                 mov     eax, offset __ehfuncinfo$??0TiXmlUnknownA@@QAE@XZ
.text$x:00003796                 jmp     ___CxxFrameHandler3
.text$x:00003796 __ehhandler$??0TiXmlUnknownA@@QAE@XZ endp
.text$x:00003796
.text$x:00003796 ; ---------------------------------------------------------------------------
.text$x:0000379B                 align 4
.text$x:0000379B _text$x         ends
.text$x:0000379B
.text$mn:0000379C ; ===========================================================================
.text$mn:0000379C
.text$mn:0000379C ; Segment type: Pure code
.text$mn:0000379C ; Segment permissions: Read/Execute
.text$mn:0000379C _text$mn        segment para public 'CODE' use32
.text$mn:0000379C                 assume cs:_text$mn
.text$mn:0000379C                 ;org 379Ch
.text$mn:0000379C ; COMDAT (pick any)
.text$mn:0000379C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000379C
.text$mn:0000379C ; =============== S U B R O U T I N E =======================================
.text$mn:0000379C
.text$mn:0000379C ; Attributes: bp-based frame
.text$mn:0000379C
.text$mn:0000379C ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000379C                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:0000379C ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:0000379C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:0000379C
.text$mn:0000379C var_4           = dword ptr -4
.text$mn:0000379C
.text$mn:0000379C                 push    ebp
.text$mn:0000379D                 mov     ebp, esp
.text$mn:0000379F                 push    ecx
.text$mn:000037A0                 mov     [ebp+var_4], ecx
.text$mn:000037A3                 mov     eax, [ebp+var_4]
.text$mn:000037A6                 mov     dword ptr [eax], 0
.text$mn:000037AC                 mov     eax, [ebp+var_4]
.text$mn:000037AF                 mov     esp, ebp
.text$mn:000037B1                 pop     ebp
.text$mn:000037B2                 retn
.text$mn:000037B2 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:000037B2
.text$mn:000037B2 ; ---------------------------------------------------------------------------
.text$mn:000037B3                 align 4
.text$mn:000037B3 _text$mn        ends
.text$mn:000037B3
.text$mn:000037B4 ; ===========================================================================
.text$mn:000037B4
.text$mn:000037B4 ; Segment type: Pure code
.text$mn:000037B4 ; Segment permissions: Read/Execute
.text$mn:000037B4 _text$mn        segment para public 'CODE' use32
.text$mn:000037B4                 assume cs:_text$mn
.text$mn:000037B4                 ;org 37B4h
.text$mn:000037B4 ; COMDAT (pick any)
.text$mn:000037B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037B4
.text$mn:000037B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000037B4
.text$mn:000037B4 ; Attributes: bp-based frame
.text$mn:000037B4
.text$mn:000037B4 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:000037B4                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:000037B4 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:000037B4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:000037B4
.text$mn:000037B4 var_4           = dword ptr -4
.text$mn:000037B4
.text$mn:000037B4                 push    ebp
.text$mn:000037B5                 mov     ebp, esp
.text$mn:000037B7                 push    ecx
.text$mn:000037B8                 mov     [ebp+var_4], ecx
.text$mn:000037BB                 mov     eax, [ebp+var_4]
.text$mn:000037BE                 mov     dword ptr [eax], 0
.text$mn:000037C4                 mov     ecx, [ebp+var_4]
.text$mn:000037C7                 mov     dword ptr [ecx+4], 0
.text$mn:000037CE                 mov     eax, [ebp+var_4]
.text$mn:000037D1                 mov     esp, ebp
.text$mn:000037D3                 pop     ebp
.text$mn:000037D4                 retn
.text$mn:000037D4 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:000037D4
.text$mn:000037D4 ; ---------------------------------------------------------------------------
.text$mn:000037D5                 align 4
.text$mn:000037D5 _text$mn        ends
.text$mn:000037D5
.text$mn:000037D8 ; ===========================================================================
.text$mn:000037D8
.text$mn:000037D8 ; Segment type: Pure code
.text$mn:000037D8 ; Segment permissions: Read/Execute
.text$mn:000037D8 _text$mn        segment para public 'CODE' use32
.text$mn:000037D8                 assume cs:_text$mn
.text$mn:000037D8                 ;org 37D8h
.text$mn:000037D8 ; COMDAT (pick any)
.text$mn:000037D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037D8
.text$mn:000037D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000037D8
.text$mn:000037D8 ; Attributes: bp-based frame
.text$mn:000037D8
.text$mn:000037D8 ; _DWORD __thiscall std::_Facet_base::_Facet_base(std::_Facet_base *__hidden this)
.text$mn:000037D8                 public ??0_Facet_base@std@@QAE@XZ
.text$mn:000037D8 ??0_Facet_base@std@@QAE@XZ proc near    ; CODE XREF: std::locale::facet::facet(uint)+29p
.text$mn:000037D8
.text$mn:000037D8 var_4           = dword ptr -4
.text$mn:000037D8
.text$mn:000037D8                 push    ebp
.text$mn:000037D9                 mov     ebp, esp
.text$mn:000037DB                 push    ecx
.text$mn:000037DC                 mov     [ebp+var_4], ecx
.text$mn:000037DF                 mov     eax, [ebp+var_4]
.text$mn:000037E2                 mov     dword ptr [eax], offset ??_7_Facet_base@std@@6B@ ; const std::_Facet_base::`vftable'
.text$mn:000037E8                 mov     eax, [ebp+var_4]
.text$mn:000037EB                 mov     esp, ebp
.text$mn:000037ED                 pop     ebp
.text$mn:000037EE                 retn
.text$mn:000037EE ??0_Facet_base@std@@QAE@XZ endp
.text$mn:000037EE
.text$mn:000037EE ; ---------------------------------------------------------------------------
.text$mn:000037EF                 align 10h
.text$mn:000037EF _text$mn        ends
.text$mn:000037EF
.text$mn:000037F0 ; ===========================================================================
.text$mn:000037F0
.text$mn:000037F0 ; Segment type: Pure code
.text$mn:000037F0 ; Segment permissions: Read/Execute
.text$mn:000037F0 _text$mn        segment para public 'CODE' use32
.text$mn:000037F0                 assume cs:_text$mn
.text$mn:000037F0                 ;org 37F0h
.text$mn:000037F0 ; COMDAT (pick any)
.text$mn:000037F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037F0
.text$mn:000037F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000037F0
.text$mn:000037F0 ; Attributes: bp-based frame
.text$mn:000037F0
.text$mn:000037F0 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000037F0                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:000037F0 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:000037F0                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:000037F0                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:000037F0
.text$mn:000037F0 var_10          = dword ptr -10h
.text$mn:000037F0 var_C           = dword ptr -0Ch
.text$mn:000037F0 var_4           = dword ptr -4
.text$mn:000037F0
.text$mn:000037F0                 push    ebp
.text$mn:000037F1                 mov     ebp, esp
.text$mn:000037F3                 push    0FFFFFFFFh
.text$mn:000037F5                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:000037FA                 mov     eax, large fs:0
.text$mn:00003800                 push    eax
.text$mn:00003801                 push    ecx
.text$mn:00003802                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003807                 xor     eax, ebp
.text$mn:00003809                 push    eax
.text$mn:0000380A                 lea     eax, [ebp+var_C]
.text$mn:0000380D                 mov     large fs:0, eax
.text$mn:00003813                 mov     [ebp+var_10], ecx
.text$mn:00003816                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003819                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:0000381E                 mov     [ebp+var_4], 0
.text$mn:00003825                 mov     eax, [ebp+var_10]
.text$mn:00003828                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:0000382E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003835                 mov     eax, [ebp+var_10]
.text$mn:00003838                 mov     ecx, [ebp+var_C]
.text$mn:0000383B                 mov     large fs:0, ecx
.text$mn:00003842                 pop     ecx
.text$mn:00003843                 mov     esp, ebp
.text$mn:00003845                 pop     ebp
.text$mn:00003846                 retn
.text$mn:00003846 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00003846
.text$mn:00003846 ; ---------------------------------------------------------------------------
.text$mn:00003847                 align 4
.text$mn:00003847 _text$mn        ends
.text$mn:00003847
.text$x:00003848 ; ===========================================================================
.text$x:00003848
.text$x:00003848 ; Segment type: Pure code
.text$x:00003848 ; Segment permissions: Read/Execute
.text$x:00003848 _text$x         segment para public 'CODE' use32
.text$x:00003848                 assume cs:_text$x
.text$x:00003848                 ;org 3848h
.text$x:00003848 ; COMDAT (pick associative to section at 37F0)
.text$x:00003848                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003848
.text$x:00003848 ; =============== S U B R O U T I N E =======================================
.text$x:00003848
.text$x:00003848
.text$x:00003848 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00003848                                         ; DATA XREF: .xdata$x:000083FCo
.text$x:00003848                 mov     ecx, [ebp-10h]  ; this
.text$x:0000384B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000384B __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:0000384B
.text$x:00003850
.text$x:00003850 ; =============== S U B R O U T I N E =======================================
.text$x:00003850
.text$x:00003850
.text$x:00003850 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00003850                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00003850
.text$x:00003850 arg_4           = dword ptr  8
.text$x:00003850
.text$x:00003850                 mov     edx, [esp+arg_4]
.text$x:00003854                 lea     eax, [edx+0Ch]
.text$x:00003857                 mov     ecx, [edx-8]
.text$x:0000385A                 xor     ecx, eax
.text$x:0000385C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003861                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00003866                 jmp     ___CxxFrameHandler3
.text$x:00003866 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00003866
.text$x:00003866 ; ---------------------------------------------------------------------------
.text$x:0000386B                 align 4
.text$x:0000386B _text$x         ends
.text$x:0000386B
.text$mn:0000386C ; ===========================================================================
.text$mn:0000386C
.text$mn:0000386C ; Segment type: Pure code
.text$mn:0000386C ; Segment permissions: Read/Execute
.text$mn:0000386C _text$mn        segment para public 'CODE' use32
.text$mn:0000386C                 assume cs:_text$mn
.text$mn:0000386C                 ;org 386Ch
.text$mn:0000386C ; COMDAT (pick any)
.text$mn:0000386C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000386C
.text$mn:0000386C ; =============== S U B R O U T I N E =======================================
.text$mn:0000386C
.text$mn:0000386C ; Attributes: bp-based frame
.text$mn:0000386C
.text$mn:0000386C ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:0000386C                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000386C ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:0000386C                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:0000386C
.text$mn:0000386C var_10          = dword ptr -10h
.text$mn:0000386C var_C           = dword ptr -0Ch
.text$mn:0000386C var_4           = dword ptr -4
.text$mn:0000386C
.text$mn:0000386C                 push    ebp
.text$mn:0000386D                 mov     ebp, esp
.text$mn:0000386F                 push    0FFFFFFFFh
.text$mn:00003871                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00003876                 mov     eax, large fs:0
.text$mn:0000387C                 push    eax
.text$mn:0000387D                 push    ecx
.text$mn:0000387E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003883                 xor     eax, ebp
.text$mn:00003885                 push    eax
.text$mn:00003886                 lea     eax, [ebp+var_C]
.text$mn:00003889                 mov     large fs:0, eax
.text$mn:0000388F                 mov     [ebp+var_10], ecx
.text$mn:00003892                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003895                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000389A                 mov     [ebp+var_4], 0
.text$mn:000038A1                 mov     eax, [ebp+var_10]
.text$mn:000038A4                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:000038AA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000038B1                 mov     eax, [ebp+var_10]
.text$mn:000038B4                 mov     ecx, [ebp+var_C]
.text$mn:000038B7                 mov     large fs:0, ecx
.text$mn:000038BE                 pop     ecx
.text$mn:000038BF                 mov     esp, ebp
.text$mn:000038C1                 pop     ebp
.text$mn:000038C2                 retn
.text$mn:000038C2 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:000038C2
.text$mn:000038C2 ; ---------------------------------------------------------------------------
.text$mn:000038C3                 align 4
.text$mn:000038C3 _text$mn        ends
.text$mn:000038C3
.text$x:000038C4 ; ===========================================================================
.text$x:000038C4
.text$x:000038C4 ; Segment type: Pure code
.text$x:000038C4 ; Segment permissions: Read/Execute
.text$x:000038C4 _text$x         segment para public 'CODE' use32
.text$x:000038C4                 assume cs:_text$x
.text$x:000038C4                 ;org 38C4h
.text$x:000038C4 ; COMDAT (pick associative to section at 386C)
.text$x:000038C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000038C4
.text$x:000038C4 ; =============== S U B R O U T I N E =======================================
.text$x:000038C4
.text$x:000038C4
.text$x:000038C4 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:000038C4                                         ; DATA XREF: .xdata$x:00008480o
.text$x:000038C4                 mov     ecx, [ebp-10h]  ; this
.text$x:000038C7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000038C7 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:000038C7
.text$x:000038CC
.text$x:000038CC ; =============== S U B R O U T I N E =======================================
.text$x:000038CC
.text$x:000038CC
.text$x:000038CC __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:000038CC                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:000038CC
.text$x:000038CC arg_4           = dword ptr  8
.text$x:000038CC
.text$x:000038CC                 mov     edx, [esp+arg_4]
.text$x:000038D0                 lea     eax, [edx+0Ch]
.text$x:000038D3                 mov     ecx, [edx-8]
.text$x:000038D6                 xor     ecx, eax
.text$x:000038D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000038DD                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:000038E2                 jmp     ___CxxFrameHandler3
.text$x:000038E2 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:000038E2
.text$x:000038E2 ; ---------------------------------------------------------------------------
.text$x:000038E7                 align 4
.text$x:000038E7 _text$x         ends
.text$x:000038E7
.text$mn:000038E8 ; ===========================================================================
.text$mn:000038E8
.text$mn:000038E8 ; Segment type: Pure code
.text$mn:000038E8 ; Segment permissions: Read/Execute
.text$mn:000038E8 _text$mn        segment para public 'CODE' use32
.text$mn:000038E8                 assume cs:_text$mn
.text$mn:000038E8                 ;org 38E8h
.text$mn:000038E8 ; COMDAT (pick any)
.text$mn:000038E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038E8
.text$mn:000038E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038E8
.text$mn:000038E8 ; Attributes: bp-based frame
.text$mn:000038E8
.text$mn:000038E8 ; _DWORD __thiscall std::_Locinfo::_Locinfo(std::_Locinfo *this, const char *)
.text$mn:000038E8                 public ??0_Locinfo@std@@QAE@PBD@Z
.text$mn:000038E8 ??0_Locinfo@std@@QAE@PBD@Z proc near    ; CODE XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+80p
.text$mn:000038E8
.text$mn:000038E8 var_1C          = byte ptr -1Ch
.text$mn:000038E8 var_10          = dword ptr -10h
.text$mn:000038E8 var_C           = dword ptr -0Ch
.text$mn:000038E8 var_4           = dword ptr -4
.text$mn:000038E8 arg_0           = dword ptr  8
.text$mn:000038E8
.text$mn:000038E8                 push    ebp
.text$mn:000038E9                 mov     ebp, esp
.text$mn:000038EB                 push    0FFFFFFFFh
.text$mn:000038ED                 push    offset __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
.text$mn:000038F2                 mov     eax, large fs:0
.text$mn:000038F8                 push    eax
.text$mn:000038F9                 sub     esp, 10h
.text$mn:000038FC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003901                 xor     eax, ebp
.text$mn:00003903                 push    eax
.text$mn:00003904                 lea     eax, [ebp+var_C]
.text$mn:00003907                 mov     large fs:0, eax
.text$mn:0000390D                 mov     [ebp+var_10], ecx
.text$mn:00003910                 push    0               ; int
.text$mn:00003912                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003915                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000391A                 mov     [ebp+var_4], 0
.text$mn:00003921                 mov     ecx, [ebp+var_10]
.text$mn:00003924                 add     ecx, 4
.text$mn:00003927                 call    ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>(void)
.text$mn:0000392C                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003930                 mov     ecx, [ebp+var_10]
.text$mn:00003933                 add     ecx, 0Ch
.text$mn:00003936                 call    ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>(void)
.text$mn:0000393B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000393F                 mov     ecx, [ebp+var_10]
.text$mn:00003942                 add     ecx, 14h
.text$mn:00003945                 call    ??0?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::_Yarn<wchar_t>(void)
.text$mn:0000394A                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000394E                 mov     ecx, [ebp+var_10]
.text$mn:00003951                 add     ecx, 1Ch
.text$mn:00003954                 call    ??0?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::_Yarn<wchar_t>(void)
.text$mn:00003959                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000395D                 mov     ecx, [ebp+var_10]
.text$mn:00003960                 add     ecx, 24h ; '$'
.text$mn:00003963                 call    ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>(void)
.text$mn:00003968                 mov     byte ptr [ebp+var_4], 5
.text$mn:0000396C                 mov     ecx, [ebp+var_10]
.text$mn:0000396F                 add     ecx, 2Ch ; ','
.text$mn:00003972                 call    ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>(void)
.text$mn:00003977                 mov     byte ptr [ebp+var_4], 6
.text$mn:0000397B                 cmp     [ebp+arg_0], 0
.text$mn:0000397F                 jnz     short loc_399C
.text$mn:00003981                 push    offset ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ ; "bad locale name"
.text$mn:00003986                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00003989                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:0000398E                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00003993                 lea     eax, [ebp+var_1C]
.text$mn:00003996                 push    eax
.text$mn:00003997                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000399C ; ---------------------------------------------------------------------------
.text$mn:0000399C
.text$mn:0000399C loc_399C:                               ; CODE XREF: std::_Locinfo::_Locinfo(char const *)+97j
.text$mn:0000399C                 mov     ecx, [ebp+arg_0]
.text$mn:0000399F                 push    ecx             ; char *
.text$mn:000039A0                 mov     edx, [ebp+var_10]
.text$mn:000039A3                 push    edx             ; struct std::_Locinfo *
.text$mn:000039A4                 call    ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor(std::_Locinfo *,char const *)
.text$mn:000039A9                 add     esp, 8
.text$mn:000039AC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000039B3                 mov     eax, [ebp+var_10]
.text$mn:000039B6                 mov     ecx, [ebp+var_C]
.text$mn:000039B9                 mov     large fs:0, ecx
.text$mn:000039C0                 pop     ecx
.text$mn:000039C1                 mov     esp, ebp
.text$mn:000039C3                 pop     ebp
.text$mn:000039C4                 retn    4
.text$mn:000039C4 ??0_Locinfo@std@@QAE@PBD@Z endp
.text$mn:000039C4
.text$mn:000039C4 ; ---------------------------------------------------------------------------
.text$mn:000039C7                 align 4
.text$mn:000039C7 _text$mn        ends
.text$mn:000039C7
.text$x:000039C8 ; ===========================================================================
.text$x:000039C8
.text$x:000039C8 ; Segment type: Pure code
.text$x:000039C8 ; Segment permissions: Read/Execute
.text$x:000039C8 _text$x         segment para public 'CODE' use32
.text$x:000039C8                 assume cs:_text$x
.text$x:000039C8                 ;org 39C8h
.text$x:000039C8 ; COMDAT (pick associative to section at 38E8)
.text$x:000039C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000039C8
.text$x:000039C8 ; =============== S U B R O U T I N E =======================================
.text$x:000039C8
.text$x:000039C8
.text$x:000039C8 __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0 proc near
.text$x:000039C8                                         ; DATA XREF: .xdata$x:00008034o
.text$x:000039C8                 mov     ecx, [ebp-10h]  ; this
.text$x:000039CB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000039CB __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0 endp
.text$x:000039CB
.text$x:000039D0
.text$x:000039D0 ; =============== S U B R O U T I N E =======================================
.text$x:000039D0
.text$x:000039D0
.text$x:000039D0 __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1 proc near
.text$x:000039D0                                         ; DATA XREF: .xdata$x:0000803Co
.text$x:000039D0                 mov     ecx, [ebp-10h]
.text$x:000039D3                 add     ecx, 4
.text$x:000039D6                 jmp     ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$x:000039D6 __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1 endp
.text$x:000039D6
.text$x:000039DB
.text$x:000039DB ; =============== S U B R O U T I N E =======================================
.text$x:000039DB
.text$x:000039DB
.text$x:000039DB __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2 proc near
.text$x:000039DB                                         ; DATA XREF: .xdata$x:00008044o
.text$x:000039DB                 mov     ecx, [ebp-10h]
.text$x:000039DE                 add     ecx, 0Ch
.text$x:000039E1                 jmp     ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$x:000039E1 __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2 endp
.text$x:000039E1
.text$x:000039E6
.text$x:000039E6 ; =============== S U B R O U T I N E =======================================
.text$x:000039E6
.text$x:000039E6
.text$x:000039E6 __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3 proc near
.text$x:000039E6                                         ; DATA XREF: .xdata$x:0000804Co
.text$x:000039E6                 mov     ecx, [ebp-10h]
.text$x:000039E9                 add     ecx, 14h
.text$x:000039EC                 jmp     ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>(void)
.text$x:000039EC __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3 endp
.text$x:000039EC
.text$x:000039F1
.text$x:000039F1 ; =============== S U B R O U T I N E =======================================
.text$x:000039F1
.text$x:000039F1
.text$x:000039F1 __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4 proc near
.text$x:000039F1                                         ; DATA XREF: .xdata$x:00008054o
.text$x:000039F1                 mov     ecx, [ebp-10h]
.text$x:000039F4                 add     ecx, 1Ch
.text$x:000039F7                 jmp     ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>(void)
.text$x:000039F7 __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4 endp
.text$x:000039F7
.text$x:000039FC
.text$x:000039FC ; =============== S U B R O U T I N E =======================================
.text$x:000039FC
.text$x:000039FC
.text$x:000039FC __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5 proc near
.text$x:000039FC                                         ; DATA XREF: .xdata$x:0000805Co
.text$x:000039FC                 mov     ecx, [ebp-10h]
.text$x:000039FF                 add     ecx, 24h ; '$'
.text$x:00003A02                 jmp     ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$x:00003A02 __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5 endp
.text$x:00003A02
.text$x:00003A07
.text$x:00003A07 ; =============== S U B R O U T I N E =======================================
.text$x:00003A07
.text$x:00003A07
.text$x:00003A07 __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6 proc near
.text$x:00003A07                                         ; DATA XREF: .xdata$x:00008064o
.text$x:00003A07                 mov     ecx, [ebp-10h]
.text$x:00003A0A                 add     ecx, 2Ch ; ','
.text$x:00003A0D                 jmp     ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$x:00003A0D __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6 endp
.text$x:00003A0D
.text$x:00003A12
.text$x:00003A12 ; =============== S U B R O U T I N E =======================================
.text$x:00003A12
.text$x:00003A12
.text$x:00003A12 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z proc near
.text$x:00003A12                                         ; DATA XREF: std::_Locinfo::_Locinfo(char const *)+5o
.text$x:00003A12
.text$x:00003A12 arg_4           = dword ptr  8
.text$x:00003A12
.text$x:00003A12                 mov     edx, [esp+arg_4]
.text$x:00003A16                 lea     eax, [edx+0Ch]
.text$x:00003A19                 mov     ecx, [edx-14h]
.text$x:00003A1C                 xor     ecx, eax
.text$x:00003A1E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003A23                 mov     eax, offset __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
.text$x:00003A28                 jmp     ___CxxFrameHandler3
.text$x:00003A28 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z endp
.text$x:00003A28
.text$x:00003A28 ; ---------------------------------------------------------------------------
.text$x:00003A2D                 align 10h
.text$x:00003A2D _text$x         ends
.text$x:00003A2D
.text$mn:00003A30 ; ===========================================================================
.text$mn:00003A30
.text$mn:00003A30 ; Segment type: Pure code
.text$mn:00003A30 ; Segment permissions: Read/Execute
.text$mn:00003A30 _text$mn        segment para public 'CODE' use32
.text$mn:00003A30                 assume cs:_text$mn
.text$mn:00003A30                 ;org 3A30h
.text$mn:00003A30 ; COMDAT (pick any)
.text$mn:00003A30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A30
.text$mn:00003A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A30
.text$mn:00003A30 ; Attributes: bp-based frame
.text$mn:00003A30
.text$mn:00003A30 ; public: __thiscall std::basic_istream<char, struct std::char_traits<char>>::_Sentry_base::_Sentry_base(class std::basic_istream<char, struct std::char_traits<char>> &)
.text$mn:00003A30                 public ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
.text$mn:00003A30 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z proc near
.text$mn:00003A30                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::sentry::sentry(std::basic_istream<char,std::char_traits<char>> &,bool)+2Dp
.text$mn:00003A30
.text$mn:00003A30 var_10          = dword ptr -10h
.text$mn:00003A30 var_C           = dword ptr -0Ch
.text$mn:00003A30 var_8           = dword ptr -8
.text$mn:00003A30 var_4           = dword ptr -4
.text$mn:00003A30 arg_0           = dword ptr  8
.text$mn:00003A30
.text$mn:00003A30                 push    ebp
.text$mn:00003A31                 mov     ebp, esp
.text$mn:00003A33                 sub     esp, 10h
.text$mn:00003A36                 mov     [ebp+var_4], ecx
.text$mn:00003A39                 mov     eax, [ebp+var_4]
.text$mn:00003A3C                 mov     ecx, [ebp+arg_0]
.text$mn:00003A3F                 mov     [eax], ecx
.text$mn:00003A41                 mov     edx, [ebp+var_4]
.text$mn:00003A44                 mov     eax, [edx]
.text$mn:00003A46                 mov     [ebp+var_8], eax
.text$mn:00003A49                 mov     ecx, [ebp+var_8]
.text$mn:00003A4C                 mov     edx, [ecx]
.text$mn:00003A4E                 mov     ecx, [ebp+var_8]
.text$mn:00003A51                 add     ecx, [edx+4]
.text$mn:00003A54                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00003A59                 test    eax, eax
.text$mn:00003A5B                 jz      short loc_3A85
.text$mn:00003A5D                 mov     eax, [ebp+var_4]
.text$mn:00003A60                 mov     ecx, [eax]
.text$mn:00003A62                 mov     [ebp+var_C], ecx
.text$mn:00003A65                 mov     edx, [ebp+var_C]
.text$mn:00003A68                 mov     eax, [edx]
.text$mn:00003A6A                 mov     ecx, [ebp+var_C]
.text$mn:00003A6D                 add     ecx, [eax+4]
.text$mn:00003A70                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00003A75                 mov     [ebp+var_10], eax
.text$mn:00003A78                 mov     ecx, [ebp+var_10]
.text$mn:00003A7B                 mov     edx, [ecx]
.text$mn:00003A7D                 mov     ecx, [ebp+var_10]
.text$mn:00003A80                 mov     eax, [edx+4]
.text$mn:00003A83                 call    eax
.text$mn:00003A85
.text$mn:00003A85 loc_3A85:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_istream<char,std::char_traits<char>> &)+2Bj
.text$mn:00003A85                 mov     eax, [ebp+var_4]
.text$mn:00003A88                 mov     esp, ebp
.text$mn:00003A8A                 pop     ebp
.text$mn:00003A8B                 retn    4
.text$mn:00003A8B ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z endp
.text$mn:00003A8B
.text$mn:00003A8B ; ---------------------------------------------------------------------------
.text$mn:00003A8E                 align 10h
.text$mn:00003A8E _text$mn        ends
.text$mn:00003A8E
.text$mn:00003A90 ; ===========================================================================
.text$mn:00003A90
.text$mn:00003A90 ; Segment type: Pure code
.text$mn:00003A90 ; Segment permissions: Read/Execute
.text$mn:00003A90 _text$mn        segment para public 'CODE' use32
.text$mn:00003A90                 assume cs:_text$mn
.text$mn:00003A90                 ;org 3A90h
.text$mn:00003A90 ; COMDAT (pick any)
.text$mn:00003A90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A90
.text$mn:00003A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A90
.text$mn:00003A90 ; Attributes: bp-based frame
.text$mn:00003A90
.text$mn:00003A90 ; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::_Sentry_base::_Sentry_base(class std::basic_ostream<char, struct std::char_traits<char>> &)
.text$mn:00003A90                 public ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
.text$mn:00003A90 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z proc near
.text$mn:00003A90                                         ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+2Dp
.text$mn:00003A90
.text$mn:00003A90 var_10          = dword ptr -10h
.text$mn:00003A90 var_C           = dword ptr -0Ch
.text$mn:00003A90 var_8           = dword ptr -8
.text$mn:00003A90 var_4           = dword ptr -4
.text$mn:00003A90 arg_0           = dword ptr  8
.text$mn:00003A90
.text$mn:00003A90                 push    ebp
.text$mn:00003A91                 mov     ebp, esp
.text$mn:00003A93                 sub     esp, 10h
.text$mn:00003A96                 mov     [ebp+var_4], ecx
.text$mn:00003A99                 mov     eax, [ebp+var_4]
.text$mn:00003A9C                 mov     ecx, [ebp+arg_0]
.text$mn:00003A9F                 mov     [eax], ecx
.text$mn:00003AA1                 mov     edx, [ebp+var_4]
.text$mn:00003AA4                 mov     eax, [edx]
.text$mn:00003AA6                 mov     [ebp+var_8], eax
.text$mn:00003AA9                 mov     ecx, [ebp+var_8]
.text$mn:00003AAC                 mov     edx, [ecx]
.text$mn:00003AAE                 mov     ecx, [ebp+var_8]
.text$mn:00003AB1                 add     ecx, [edx+4]
.text$mn:00003AB4                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00003AB9                 test    eax, eax
.text$mn:00003ABB                 jz      short loc_3AE5
.text$mn:00003ABD                 mov     eax, [ebp+var_4]
.text$mn:00003AC0                 mov     ecx, [eax]
.text$mn:00003AC2                 mov     [ebp+var_C], ecx
.text$mn:00003AC5                 mov     edx, [ebp+var_C]
.text$mn:00003AC8                 mov     eax, [edx]
.text$mn:00003ACA                 mov     ecx, [ebp+var_C]
.text$mn:00003ACD                 add     ecx, [eax+4]
.text$mn:00003AD0                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00003AD5                 mov     [ebp+var_10], eax
.text$mn:00003AD8                 mov     ecx, [ebp+var_10]
.text$mn:00003ADB                 mov     edx, [ecx]
.text$mn:00003ADD                 mov     ecx, [ebp+var_10]
.text$mn:00003AE0                 mov     eax, [edx+4]
.text$mn:00003AE3                 call    eax
.text$mn:00003AE5
.text$mn:00003AE5 loc_3AE5:                               ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_ostream<char,std::char_traits<char>> &)+2Bj
.text$mn:00003AE5                 mov     eax, [ebp+var_4]
.text$mn:00003AE8                 mov     esp, ebp
.text$mn:00003AEA                 pop     ebp
.text$mn:00003AEB                 retn    4
.text$mn:00003AEB ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z endp
.text$mn:00003AEB
.text$mn:00003AEB ; ---------------------------------------------------------------------------
.text$mn:00003AEE                 align 10h
.text$mn:00003AEE _text$mn        ends
.text$mn:00003AEE
.text$mn:00003AF0 ; ===========================================================================
.text$mn:00003AF0
.text$mn:00003AF0 ; Segment type: Pure code
.text$mn:00003AF0 ; Segment permissions: Read/Execute
.text$mn:00003AF0 _text$mn        segment para public 'CODE' use32
.text$mn:00003AF0                 assume cs:_text$mn
.text$mn:00003AF0                 ;org 3AF0h
.text$mn:00003AF0 ; COMDAT (pick any)
.text$mn:00003AF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AF0
.text$mn:00003AF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AF0
.text$mn:00003AF0 ; Attributes: bp-based frame
.text$mn:00003AF0
.text$mn:00003AF0 ; protected: __thiscall std::_System_error::_System_error(class std::error_code, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
.text$mn:00003AF0                 public ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
.text$mn:00003AF0 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z proc near
.text$mn:00003AF0                                         ; CODE XREF: std::system_error::system_error(std::error_code,char const *)+4Dp
.text$mn:00003AF0
.text$mn:00003AF0 var_44          = dword ptr -44h
.text$mn:00003AF0 var_40          = dword ptr -40h
.text$mn:00003AF0 var_3C          = dword ptr -3Ch
.text$mn:00003AF0 var_38          = dword ptr -38h
.text$mn:00003AF0 var_34          = dword ptr -34h
.text$mn:00003AF0 var_30          = dword ptr -30h
.text$mn:00003AF0 var_2C          = byte ptr -2Ch
.text$mn:00003AF0 var_10          = dword ptr -10h
.text$mn:00003AF0 var_C           = dword ptr -0Ch
.text$mn:00003AF0 var_4           = dword ptr -4
.text$mn:00003AF0 arg_0           = dword ptr  8
.text$mn:00003AF0 arg_4           = dword ptr  0Ch
.text$mn:00003AF0 arg_8           = dword ptr  10h
.text$mn:00003AF0
.text$mn:00003AF0                 push    ebp
.text$mn:00003AF1                 mov     ebp, esp
.text$mn:00003AF3                 push    0FFFFFFFFh
.text$mn:00003AF5                 push    offset __ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
.text$mn:00003AFA                 mov     eax, large fs:0
.text$mn:00003B00                 push    eax
.text$mn:00003B01                 sub     esp, 38h
.text$mn:00003B04                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B09                 xor     eax, ebp
.text$mn:00003B0B                 mov     [ebp+var_10], eax
.text$mn:00003B0E                 push    eax
.text$mn:00003B0F                 lea     eax, [ebp+var_C]
.text$mn:00003B12                 mov     large fs:0, eax
.text$mn:00003B18                 mov     [ebp+var_30], ecx
.text$mn:00003B1B                 sub     esp, 1Ch
.text$mn:00003B1E                 mov     ecx, esp
.text$mn:00003B20                 mov     [ebp+var_40], esp
.text$mn:00003B23                 mov     eax, [ebp+arg_8]
.text$mn:00003B26                 push    eax
.text$mn:00003B27                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
.text$mn:00003B2C                 mov     [ebp+var_3C], eax
.text$mn:00003B2F                 mov     ecx, [ebp+var_3C]
.text$mn:00003B32                 mov     [ebp+var_44], ecx
.text$mn:00003B35                 mov     [ebp+var_4], 0
.text$mn:00003B3C                 mov     edx, [ebp+arg_4]
.text$mn:00003B3F                 push    edx
.text$mn:00003B40                 mov     eax, [ebp+arg_0]
.text$mn:00003B43                 push    eax
.text$mn:00003B44                 lea     ecx, [ebp+var_2C]
.text$mn:00003B47                 push    ecx
.text$mn:00003B48                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B4F                 call    ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>>)
.text$mn:00003B54                 add     esp, 28h
.text$mn:00003B57                 mov     [ebp+var_38], eax
.text$mn:00003B5A                 mov     edx, [ebp+var_38]
.text$mn:00003B5D                 mov     [ebp+var_34], edx
.text$mn:00003B60                 mov     [ebp+var_4], 1
.text$mn:00003B67                 mov     eax, [ebp+var_34]
.text$mn:00003B6A                 push    eax
.text$mn:00003B6B                 mov     ecx, [ebp+var_30]
.text$mn:00003B6E                 call    ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
.text$mn:00003B73                 mov     byte ptr [ebp+var_4], 3
.text$mn:00003B77                 lea     ecx, [ebp+var_2C]
.text$mn:00003B7A                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00003B7F                 mov     ecx, [ebp+var_30]
.text$mn:00003B82                 mov     dword ptr [ecx], offset ??_7_System_error@std@@6B@ ; const std::_System_error::`vftable'
.text$mn:00003B88                 mov     edx, [ebp+var_30]
.text$mn:00003B8B                 mov     eax, [ebp+arg_0]
.text$mn:00003B8E                 mov     [edx+0Ch], eax
.text$mn:00003B91                 mov     ecx, [ebp+arg_4]
.text$mn:00003B94                 mov     [edx+10h], ecx
.text$mn:00003B97                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B9E                 mov     eax, [ebp+var_30]
.text$mn:00003BA1                 mov     ecx, [ebp+var_C]
.text$mn:00003BA4                 mov     large fs:0, ecx
.text$mn:00003BAB                 pop     ecx
.text$mn:00003BAC                 mov     ecx, [ebp+var_10]
.text$mn:00003BAF                 xor     ecx, ebp
.text$mn:00003BB1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00003BB6                 mov     esp, ebp
.text$mn:00003BB8                 pop     ebp
.text$mn:00003BB9                 retn    0Ch
.text$mn:00003BB9 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z endp
.text$mn:00003BB9
.text$mn:00003BB9 _text$mn        ends
.text$mn:00003BB9
.text$x:00003BBC ; ===========================================================================
.text$x:00003BBC
.text$x:00003BBC ; Segment type: Pure code
.text$x:00003BBC ; Segment permissions: Read/Execute
.text$x:00003BBC _text$x         segment para public 'CODE' use32
.text$x:00003BBC                 assume cs:_text$x
.text$x:00003BBC                 ;org 3BBCh
.text$x:00003BBC ; COMDAT (pick associative to section at 3AF0)
.text$x:00003BBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003BBC
.text$x:00003BBC ; =============== S U B R O U T I N E =======================================
.text$x:00003BBC
.text$x:00003BBC
.text$x:00003BBC __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0 proc near
.text$x:00003BBC                                         ; DATA XREF: .xdata$x:000082CCo
.text$x:00003BBC                 mov     ecx, [ebp-40h]
.text$x:00003BBF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003BBF __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0 endp
.text$x:00003BBF
.text$x:00003BC4
.text$x:00003BC4 ; =============== S U B R O U T I N E =======================================
.text$x:00003BC4
.text$x:00003BC4
.text$x:00003BC4 __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1 proc near
.text$x:00003BC4                                         ; DATA XREF: .xdata$x:000082D4o
.text$x:00003BC4                 lea     ecx, [ebp-2Ch]
.text$x:00003BC7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003BC7 __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1 endp
.text$x:00003BC7
.text$x:00003BCC
.text$x:00003BCC ; =============== S U B R O U T I N E =======================================
.text$x:00003BCC
.text$x:00003BCC
.text$x:00003BCC __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2 proc near
.text$x:00003BCC                                         ; DATA XREF: .xdata$x:000082DCo
.text$x:00003BCC                                         ; .xdata$x:000082E4o
.text$x:00003BCC                 mov     ecx, [ebp-30h]  ; this
.text$x:00003BCF                 jmp     ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$x:00003BCF __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2 endp
.text$x:00003BCF
.text$x:00003BD4
.text$x:00003BD4 ; =============== S U B R O U T I N E =======================================
.text$x:00003BD4
.text$x:00003BD4
.text$x:00003BD4 __ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z proc near
.text$x:00003BD4                                         ; DATA XREF: std::_System_error::_System_error(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5o
.text$x:00003BD4
.text$x:00003BD4 arg_4           = dword ptr  8
.text$x:00003BD4
.text$x:00003BD4                 mov     edx, [esp+arg_4]
.text$x:00003BD8                 lea     eax, [edx+0Ch]
.text$x:00003BDB                 mov     ecx, [edx-3Ch]
.text$x:00003BDE                 xor     ecx, eax
.text$x:00003BE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BE5                 mov     ecx, [edx-4]
.text$x:00003BE8                 xor     ecx, eax
.text$x:00003BEA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BEF                 mov     eax, offset __ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
.text$x:00003BF4                 jmp     ___CxxFrameHandler3
.text$x:00003BF4 __ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z endp
.text$x:00003BF4
.text$x:00003BF4 ; ---------------------------------------------------------------------------
.text$x:00003BF9                 align 4
.text$x:00003BF9 _text$x         ends
.text$x:00003BF9
.text$mn:00003BFC ; ===========================================================================
.text$mn:00003BFC
.text$mn:00003BFC ; Segment type: Pure code
.text$mn:00003BFC ; Segment permissions: Read/Execute
.text$mn:00003BFC _text$mn        segment para public 'CODE' use32
.text$mn:00003BFC                 assume cs:_text$mn
.text$mn:00003BFC                 ;org 3BFCh
.text$mn:00003BFC ; COMDAT (pick any)
.text$mn:00003BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BFC
.text$mn:00003BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00003BFC
.text$mn:00003BFC ; Attributes: bp-based frame
.text$mn:00003BFC
.text$mn:00003BFC ; _DWORD __thiscall std::_System_error::_System_error(std::_System_error *this, const struct std::_System_error *)
.text$mn:00003BFC                 public ??0_System_error@std@@QAE@ABV01@@Z
.text$mn:00003BFC ??0_System_error@std@@QAE@ABV01@@Z proc near
.text$mn:00003BFC                                         ; CODE XREF: std::system_error::system_error(std::system_error const &)+2Dp
.text$mn:00003BFC                                         ; DATA XREF: .xdata$x:00008FD4o
.text$mn:00003BFC
.text$mn:00003BFC var_10          = dword ptr -10h
.text$mn:00003BFC var_C           = dword ptr -0Ch
.text$mn:00003BFC var_4           = dword ptr -4
.text$mn:00003BFC arg_0           = dword ptr  8
.text$mn:00003BFC
.text$mn:00003BFC                 push    ebp
.text$mn:00003BFD                 mov     ebp, esp
.text$mn:00003BFF                 push    0FFFFFFFFh
.text$mn:00003C01                 push    offset __ehhandler$??0_System_error@std@@QAE@ABV01@@Z
.text$mn:00003C06                 mov     eax, large fs:0
.text$mn:00003C0C                 push    eax
.text$mn:00003C0D                 push    ecx
.text$mn:00003C0E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C13                 xor     eax, ebp
.text$mn:00003C15                 push    eax
.text$mn:00003C16                 lea     eax, [ebp+var_C]
.text$mn:00003C19                 mov     large fs:0, eax
.text$mn:00003C1F                 mov     [ebp+var_10], ecx
.text$mn:00003C22                 mov     eax, [ebp+arg_0]
.text$mn:00003C25                 push    eax             ; struct std::runtime_error *
.text$mn:00003C26                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003C29                 call    ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.text$mn:00003C2E                 mov     [ebp+var_4], 0
.text$mn:00003C35                 mov     ecx, [ebp+var_10]
.text$mn:00003C38                 mov     dword ptr [ecx], offset ??_7_System_error@std@@6B@ ; const std::_System_error::`vftable'
.text$mn:00003C3E                 mov     edx, [ebp+arg_0]
.text$mn:00003C41                 mov     eax, [edx+0Ch]
.text$mn:00003C44                 mov     ecx, [edx+10h]
.text$mn:00003C47                 mov     edx, [ebp+var_10]
.text$mn:00003C4A                 mov     [edx+0Ch], eax
.text$mn:00003C4D                 mov     [edx+10h], ecx
.text$mn:00003C50                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003C57                 mov     eax, [ebp+var_10]
.text$mn:00003C5A                 mov     ecx, [ebp+var_C]
.text$mn:00003C5D                 mov     large fs:0, ecx
.text$mn:00003C64                 pop     ecx
.text$mn:00003C65                 mov     esp, ebp
.text$mn:00003C67                 pop     ebp
.text$mn:00003C68                 retn    4
.text$mn:00003C68 ??0_System_error@std@@QAE@ABV01@@Z endp
.text$mn:00003C68
.text$mn:00003C68 ; ---------------------------------------------------------------------------
.text$mn:00003C6B                 align 4
.text$mn:00003C6B _text$mn        ends
.text$mn:00003C6B
.text$x:00003C6C ; ===========================================================================
.text$x:00003C6C
.text$x:00003C6C ; Segment type: Pure code
.text$x:00003C6C ; Segment permissions: Read/Execute
.text$x:00003C6C _text$x         segment para public 'CODE' use32
.text$x:00003C6C                 assume cs:_text$x
.text$x:00003C6C                 ;org 3C6Ch
.text$x:00003C6C ; COMDAT (pick associative to section at 3BFC)
.text$x:00003C6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003C6C
.text$x:00003C6C ; =============== S U B R O U T I N E =======================================
.text$x:00003C6C
.text$x:00003C6C
.text$x:00003C6C __unwindfunclet$??0_System_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00003C6C                                         ; DATA XREF: .xdata$x:0000833Co
.text$x:00003C6C                 mov     ecx, [ebp-10h]  ; this
.text$x:00003C6F                 jmp     ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$x:00003C6F __unwindfunclet$??0_System_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00003C6F
.text$x:00003C74
.text$x:00003C74 ; =============== S U B R O U T I N E =======================================
.text$x:00003C74
.text$x:00003C74
.text$x:00003C74 __ehhandler$??0_System_error@std@@QAE@ABV01@@Z proc near
.text$x:00003C74                                         ; DATA XREF: std::_System_error::_System_error(std::_System_error const &)+5o
.text$x:00003C74
.text$x:00003C74 arg_4           = dword ptr  8
.text$x:00003C74
.text$x:00003C74                 mov     edx, [esp+arg_4]
.text$x:00003C78                 lea     eax, [edx+0Ch]
.text$x:00003C7B                 mov     ecx, [edx-8]
.text$x:00003C7E                 xor     ecx, eax
.text$x:00003C80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003C85                 mov     eax, offset __ehfuncinfo$??0_System_error@std@@QAE@ABV01@@Z
.text$x:00003C8A                 jmp     ___CxxFrameHandler3
.text$x:00003C8A __ehhandler$??0_System_error@std@@QAE@ABV01@@Z endp
.text$x:00003C8A
.text$x:00003C8A ; ---------------------------------------------------------------------------
.text$x:00003C8F                 align 10h
.text$x:00003C8F _text$x         ends
.text$x:00003C8F
.text$mn:00003C90 ; ===========================================================================
.text$mn:00003C90
.text$mn:00003C90 ; Segment type: Pure code
.text$mn:00003C90 ; Segment permissions: Read/Execute
.text$mn:00003C90 _text$mn        segment para public 'CODE' use32
.text$mn:00003C90                 assume cs:_text$mn
.text$mn:00003C90                 ;org 3C90h
.text$mn:00003C90 ; COMDAT (pick any)
.text$mn:00003C90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C90
.text$mn:00003C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C90
.text$mn:00003C90 ; Attributes: bp-based frame
.text$mn:00003C90
.text$mn:00003C90 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00003C90                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00003C90 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00003C90                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00003C90
.text$mn:00003C90 var_10          = dword ptr -10h
.text$mn:00003C90 var_C           = dword ptr -0Ch
.text$mn:00003C90 var_4           = dword ptr -4
.text$mn:00003C90
.text$mn:00003C90                 push    ebp
.text$mn:00003C91                 mov     ebp, esp
.text$mn:00003C93                 push    0FFFFFFFFh
.text$mn:00003C95                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00003C9A                 mov     eax, large fs:0
.text$mn:00003CA0                 push    eax
.text$mn:00003CA1                 push    ecx
.text$mn:00003CA2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003CA7                 xor     eax, ebp
.text$mn:00003CA9                 push    eax
.text$mn:00003CAA                 lea     eax, [ebp+var_C]
.text$mn:00003CAD                 mov     large fs:0, eax
.text$mn:00003CB3                 mov     [ebp+var_10], ecx
.text$mn:00003CB6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003CB9                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00003CBE                 mov     [ebp+var_4], 0
.text$mn:00003CC5                 mov     eax, [ebp+var_10]
.text$mn:00003CC8                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00003CCE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003CD5                 mov     eax, [ebp+var_10]
.text$mn:00003CD8                 mov     ecx, [ebp+var_C]
.text$mn:00003CDB                 mov     large fs:0, ecx
.text$mn:00003CE2                 pop     ecx
.text$mn:00003CE3                 mov     esp, ebp
.text$mn:00003CE5                 pop     ebp
.text$mn:00003CE6                 retn
.text$mn:00003CE6 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00003CE6
.text$mn:00003CE6 ; ---------------------------------------------------------------------------
.text$mn:00003CE7                 align 4
.text$mn:00003CE7 _text$mn        ends
.text$mn:00003CE7
.text$x:00003CE8 ; ===========================================================================
.text$x:00003CE8
.text$x:00003CE8 ; Segment type: Pure code
.text$x:00003CE8 ; Segment permissions: Read/Execute
.text$x:00003CE8 _text$x         segment para public 'CODE' use32
.text$x:00003CE8                 assume cs:_text$x
.text$x:00003CE8                 ;org 3CE8h
.text$x:00003CE8 ; COMDAT (pick associative to section at 3C90)
.text$x:00003CE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003CE8
.text$x:00003CE8 ; =============== S U B R O U T I N E =======================================
.text$x:00003CE8
.text$x:00003CE8
.text$x:00003CE8 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00003CE8                                         ; DATA XREF: .xdata$x:00008504o
.text$x:00003CE8                 mov     ecx, [ebp-10h]  ; this
.text$x:00003CEB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003CEB __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00003CEB
.text$x:00003CF0
.text$x:00003CF0 ; =============== S U B R O U T I N E =======================================
.text$x:00003CF0
.text$x:00003CF0
.text$x:00003CF0 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00003CF0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00003CF0
.text$x:00003CF0 arg_4           = dword ptr  8
.text$x:00003CF0
.text$x:00003CF0                 mov     edx, [esp+arg_4]
.text$x:00003CF4                 lea     eax, [edx+0Ch]
.text$x:00003CF7                 mov     ecx, [edx-8]
.text$x:00003CFA                 xor     ecx, eax
.text$x:00003CFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003D01                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00003D06                 jmp     ___CxxFrameHandler3
.text$x:00003D06 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00003D06
.text$x:00003D06 ; ---------------------------------------------------------------------------
.text$x:00003D0B                 align 4
.text$x:00003D0B _text$x         ends
.text$x:00003D0B
.text$mn:00003D0C ; ===========================================================================
.text$mn:00003D0C
.text$mn:00003D0C ; Segment type: Pure code
.text$mn:00003D0C ; Segment permissions: Read/Execute
.text$mn:00003D0C _text$mn        segment para public 'CODE' use32
.text$mn:00003D0C                 assume cs:_text$mn
.text$mn:00003D0C                 ;org 3D0Ch
.text$mn:00003D0C ; COMDAT (pick any)
.text$mn:00003D0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D0C
.text$mn:00003D0C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D0C
.text$mn:00003D0C ; Attributes: bp-based frame
.text$mn:00003D0C
.text$mn:00003D0C ; _DWORD __thiscall std::ctype_base::ctype_base(std::ctype_base *this, unsigned int)
.text$mn:00003D0C                 public ??0ctype_base@std@@QAE@I@Z
.text$mn:00003D0C ??0ctype_base@std@@QAE@I@Z proc near    ; CODE XREF: std::ctype<char>::ctype<char>(std::_Locinfo const &,uint)+2Dp
.text$mn:00003D0C
.text$mn:00003D0C var_10          = dword ptr -10h
.text$mn:00003D0C var_C           = dword ptr -0Ch
.text$mn:00003D0C var_4           = dword ptr -4
.text$mn:00003D0C arg_0           = dword ptr  8
.text$mn:00003D0C
.text$mn:00003D0C                 push    ebp
.text$mn:00003D0D                 mov     ebp, esp
.text$mn:00003D0F                 push    0FFFFFFFFh
.text$mn:00003D11                 push    offset __ehhandler$??0ctype_base@std@@QAE@I@Z
.text$mn:00003D16                 mov     eax, large fs:0
.text$mn:00003D1C                 push    eax
.text$mn:00003D1D                 push    ecx
.text$mn:00003D1E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003D23                 xor     eax, ebp
.text$mn:00003D25                 push    eax
.text$mn:00003D26                 lea     eax, [ebp+var_C]
.text$mn:00003D29                 mov     large fs:0, eax
.text$mn:00003D2F                 mov     [ebp+var_10], ecx
.text$mn:00003D32                 mov     eax, [ebp+arg_0]
.text$mn:00003D35                 push    eax             ; unsigned int
.text$mn:00003D36                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003D39                 call    ??0facet@locale@std@@IAE@I@Z ; std::locale::facet::facet(uint)
.text$mn:00003D3E                 mov     [ebp+var_4], 0
.text$mn:00003D45                 mov     ecx, [ebp+var_10]
.text$mn:00003D48                 mov     dword ptr [ecx], offset ??_7ctype_base@std@@6B@ ; const std::ctype_base::`vftable'
.text$mn:00003D4E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003D55                 mov     eax, [ebp+var_10]
.text$mn:00003D58                 mov     ecx, [ebp+var_C]
.text$mn:00003D5B                 mov     large fs:0, ecx
.text$mn:00003D62                 pop     ecx
.text$mn:00003D63                 mov     esp, ebp
.text$mn:00003D65                 pop     ebp
.text$mn:00003D66                 retn    4
.text$mn:00003D66 ??0ctype_base@std@@QAE@I@Z endp
.text$mn:00003D66
.text$mn:00003D66 ; ---------------------------------------------------------------------------
.text$mn:00003D69                 align 4
.text$mn:00003D69 _text$mn        ends
.text$mn:00003D69
.text$x:00003D6C ; ===========================================================================
.text$x:00003D6C
.text$x:00003D6C ; Segment type: Pure code
.text$x:00003D6C ; Segment permissions: Read/Execute
.text$x:00003D6C _text$x         segment para public 'CODE' use32
.text$x:00003D6C                 assume cs:_text$x
.text$x:00003D6C                 ;org 3D6Ch
.text$x:00003D6C ; COMDAT (pick associative to section at 3D0C)
.text$x:00003D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003D6C
.text$x:00003D6C ; =============== S U B R O U T I N E =======================================
.text$x:00003D6C
.text$x:00003D6C
.text$x:00003D6C __unwindfunclet$??0ctype_base@std@@QAE@I@Z$0 proc near
.text$x:00003D6C                                         ; DATA XREF: .xdata$x:0000814Co
.text$x:00003D6C                 mov     ecx, [ebp-10h]  ; this
.text$x:00003D6F                 jmp     ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet(void)
.text$x:00003D6F __unwindfunclet$??0ctype_base@std@@QAE@I@Z$0 endp
.text$x:00003D6F
.text$x:00003D74
.text$x:00003D74 ; =============== S U B R O U T I N E =======================================
.text$x:00003D74
.text$x:00003D74
.text$x:00003D74 __ehhandler$??0ctype_base@std@@QAE@I@Z proc near
.text$x:00003D74                                         ; DATA XREF: std::ctype_base::ctype_base(uint)+5o
.text$x:00003D74
.text$x:00003D74 arg_4           = dword ptr  8
.text$x:00003D74
.text$x:00003D74                 mov     edx, [esp+arg_4]
.text$x:00003D78                 lea     eax, [edx+0Ch]
.text$x:00003D7B                 mov     ecx, [edx-8]
.text$x:00003D7E                 xor     ecx, eax
.text$x:00003D80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003D85                 mov     eax, offset __ehfuncinfo$??0ctype_base@std@@QAE@I@Z
.text$x:00003D8A                 jmp     ___CxxFrameHandler3
.text$x:00003D8A __ehhandler$??0ctype_base@std@@QAE@I@Z endp
.text$x:00003D8A
.text$x:00003D8A ; ---------------------------------------------------------------------------
.text$x:00003D8F                 align 10h
.text$x:00003D8F _text$x         ends
.text$x:00003D8F
.text$mn:00003D90 ; ===========================================================================
.text$mn:00003D90
.text$mn:00003D90 ; Segment type: Pure code
.text$mn:00003D90 ; Segment permissions: Read/Execute
.text$mn:00003D90 _text$mn        segment para public 'CODE' use32
.text$mn:00003D90                 assume cs:_text$mn
.text$mn:00003D90                 ;org 3D90h
.text$mn:00003D90 ; COMDAT (pick any)
.text$mn:00003D90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D90
.text$mn:00003D90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D90
.text$mn:00003D90 ; Attributes: bp-based frame
.text$mn:00003D90
.text$mn:00003D90 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00003D90                 public ??0error_category@std@@QAE@XZ
.text$mn:00003D90 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00003D90
.text$mn:00003D90 var_4           = dword ptr -4
.text$mn:00003D90
.text$mn:00003D90                 push    ebp
.text$mn:00003D91                 mov     ebp, esp
.text$mn:00003D93                 push    ecx
.text$mn:00003D94                 mov     [ebp+var_4], ecx
.text$mn:00003D97                 mov     eax, [ebp+var_4]
.text$mn:00003D9A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00003DA0                 mov     eax, [ebp+var_4]
.text$mn:00003DA3                 mov     esp, ebp
.text$mn:00003DA5                 pop     ebp
.text$mn:00003DA6                 retn
.text$mn:00003DA6 ??0error_category@std@@QAE@XZ endp
.text$mn:00003DA6
.text$mn:00003DA6 ; ---------------------------------------------------------------------------
.text$mn:00003DA7                 align 4
.text$mn:00003DA7 _text$mn        ends
.text$mn:00003DA7
.text$mn:00003DA8 ; ===========================================================================
.text$mn:00003DA8
.text$mn:00003DA8 ; Segment type: Pure code
.text$mn:00003DA8 ; Segment permissions: Read/Execute
.text$mn:00003DA8 _text$mn        segment para public 'CODE' use32
.text$mn:00003DA8                 assume cs:_text$mn
.text$mn:00003DA8                 ;org 3DA8h
.text$mn:00003DA8 ; COMDAT (pick any)
.text$mn:00003DA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DA8
.text$mn:00003DA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DA8
.text$mn:00003DA8 ; Attributes: bp-based frame
.text$mn:00003DA8
.text$mn:00003DA8 ; _DWORD __thiscall std::error_code::error_code(std::error_code *this, int, const struct std::error_category *)
.text$mn:00003DA8                 public ??0error_code@std@@QAE@HABVerror_category@1@@Z
.text$mn:00003DA8 ??0error_code@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00003DA8                                         ; CODE XREF: std::make_error_code(std::io_errc)+10p
.text$mn:00003DA8
.text$mn:00003DA8 var_4           = dword ptr -4
.text$mn:00003DA8 arg_0           = dword ptr  8
.text$mn:00003DA8 arg_4           = dword ptr  0Ch
.text$mn:00003DA8
.text$mn:00003DA8                 push    ebp
.text$mn:00003DA9                 mov     ebp, esp
.text$mn:00003DAB                 push    ecx
.text$mn:00003DAC                 mov     [ebp+var_4], ecx
.text$mn:00003DAF                 mov     eax, [ebp+var_4]
.text$mn:00003DB2                 mov     ecx, [ebp+arg_0]
.text$mn:00003DB5                 mov     [eax], ecx
.text$mn:00003DB7                 mov     edx, [ebp+var_4]
.text$mn:00003DBA                 mov     eax, [ebp+arg_4]
.text$mn:00003DBD                 mov     [edx+4], eax
.text$mn:00003DC0                 mov     eax, [ebp+var_4]
.text$mn:00003DC3                 mov     esp, ebp
.text$mn:00003DC5                 pop     ebp
.text$mn:00003DC6                 retn    8
.text$mn:00003DC6 ??0error_code@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00003DC6
.text$mn:00003DC6 ; ---------------------------------------------------------------------------
.text$mn:00003DC9                 align 4
.text$mn:00003DC9 _text$mn        ends
.text$mn:00003DC9
.text$mn:00003DCC ; ===========================================================================
.text$mn:00003DCC
.text$mn:00003DCC ; Segment type: Pure code
.text$mn:00003DCC ; Segment permissions: Read/Execute
.text$mn:00003DCC _text$mn        segment para public 'CODE' use32
.text$mn:00003DCC                 assume cs:_text$mn
.text$mn:00003DCC                 ;org 3DCCh
.text$mn:00003DCC ; COMDAT (pick any)
.text$mn:00003DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DCC
.text$mn:00003DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DCC
.text$mn:00003DCC ; Attributes: bp-based frame
.text$mn:00003DCC
.text$mn:00003DCC ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00003DCC                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00003DCC ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00003DCC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00003DCC                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00003DCC
.text$mn:00003DCC var_4           = dword ptr -4
.text$mn:00003DCC arg_0           = dword ptr  8
.text$mn:00003DCC arg_4           = dword ptr  0Ch
.text$mn:00003DCC
.text$mn:00003DCC                 push    ebp
.text$mn:00003DCD                 mov     ebp, esp
.text$mn:00003DCF                 push    ecx
.text$mn:00003DD0                 mov     [ebp+var_4], ecx
.text$mn:00003DD3                 mov     eax, [ebp+var_4]
.text$mn:00003DD6                 mov     ecx, [ebp+arg_0]
.text$mn:00003DD9                 mov     [eax], ecx
.text$mn:00003DDB                 mov     edx, [ebp+var_4]
.text$mn:00003DDE                 mov     eax, [ebp+arg_4]
.text$mn:00003DE1                 mov     [edx+4], eax
.text$mn:00003DE4                 mov     eax, [ebp+var_4]
.text$mn:00003DE7                 mov     esp, ebp
.text$mn:00003DE9                 pop     ebp
.text$mn:00003DEA                 retn    8
.text$mn:00003DEA ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00003DEA
.text$mn:00003DEA ; ---------------------------------------------------------------------------
.text$mn:00003DED                 align 10h
.text$mn:00003DED _text$mn        ends
.text$mn:00003DED
.text$mn:00003DF0 ; ===========================================================================
.text$mn:00003DF0
.text$mn:00003DF0 ; Segment type: Pure code
.text$mn:00003DF0 ; Segment permissions: Read/Execute
.text$mn:00003DF0 _text$mn        segment para public 'CODE' use32
.text$mn:00003DF0                 assume cs:_text$mn
.text$mn:00003DF0                 ;org 3DF0h
.text$mn:00003DF0 ; COMDAT (pick any)
.text$mn:00003DF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DF0
.text$mn:00003DF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DF0
.text$mn:00003DF0 ; Attributes: bp-based frame
.text$mn:00003DF0
.text$mn:00003DF0 ; _DWORD __thiscall std::locale::facet::facet(std::locale::facet *this, unsigned int)
.text$mn:00003DF0                 public ??0facet@locale@std@@IAE@I@Z
.text$mn:00003DF0 ??0facet@locale@std@@IAE@I@Z proc near  ; CODE XREF: std::ctype_base::ctype_base(uint)+2Dp
.text$mn:00003DF0
.text$mn:00003DF0 var_10          = dword ptr -10h
.text$mn:00003DF0 var_C           = dword ptr -0Ch
.text$mn:00003DF0 var_4           = dword ptr -4
.text$mn:00003DF0 arg_0           = dword ptr  8
.text$mn:00003DF0
.text$mn:00003DF0                 push    ebp
.text$mn:00003DF1                 mov     ebp, esp
.text$mn:00003DF3                 push    0FFFFFFFFh
.text$mn:00003DF5                 push    offset __ehhandler$??0facet@locale@std@@IAE@I@Z
.text$mn:00003DFA                 mov     eax, large fs:0
.text$mn:00003E00                 push    eax
.text$mn:00003E01                 push    ecx
.text$mn:00003E02                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E07                 xor     eax, ebp
.text$mn:00003E09                 push    eax
.text$mn:00003E0A                 lea     eax, [ebp+var_C]
.text$mn:00003E0D                 mov     large fs:0, eax
.text$mn:00003E13                 mov     [ebp+var_10], ecx
.text$mn:00003E16                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003E19                 call    ??0_Facet_base@std@@QAE@XZ ; std::_Facet_base::_Facet_base(void)
.text$mn:00003E1E                 mov     [ebp+var_4], 0
.text$mn:00003E25                 mov     eax, [ebp+var_10]
.text$mn:00003E28                 mov     dword ptr [eax], offset ??_7facet@locale@std@@6B@ ; const std::locale::facet::`vftable'
.text$mn:00003E2E                 mov     ecx, [ebp+arg_0]
.text$mn:00003E31                 push    ecx             ; unsigned __int32
.text$mn:00003E32                 mov     edx, [ebp+var_10]
.text$mn:00003E35                 add     edx, 4
.text$mn:00003E38                 push    edx             ; unsigned __int32 *
.text$mn:00003E39                 call    ?_Init_atomic_counter@std@@YAXAAKK@Z ; std::_Init_atomic_counter(ulong &,ulong)
.text$mn:00003E3E                 add     esp, 8
.text$mn:00003E41                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003E48                 mov     eax, [ebp+var_10]
.text$mn:00003E4B                 mov     ecx, [ebp+var_C]
.text$mn:00003E4E                 mov     large fs:0, ecx
.text$mn:00003E55                 pop     ecx
.text$mn:00003E56                 mov     esp, ebp
.text$mn:00003E58                 pop     ebp
.text$mn:00003E59                 retn    4
.text$mn:00003E59 ??0facet@locale@std@@IAE@I@Z endp
.text$mn:00003E59
.text$mn:00003E59 _text$mn        ends
.text$mn:00003E59
.text$x:00003E5C ; ===========================================================================
.text$x:00003E5C
.text$x:00003E5C ; Segment type: Pure code
.text$x:00003E5C ; Segment permissions: Read/Execute
.text$x:00003E5C _text$x         segment para public 'CODE' use32
.text$x:00003E5C                 assume cs:_text$x
.text$x:00003E5C                 ;org 3E5Ch
.text$x:00003E5C ; COMDAT (pick associative to section at 3DF0)
.text$x:00003E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003E5C
.text$x:00003E5C ; =============== S U B R O U T I N E =======================================
.text$x:00003E5C
.text$x:00003E5C
.text$x:00003E5C __unwindfunclet$??0facet@locale@std@@IAE@I@Z$0 proc near
.text$x:00003E5C                                         ; DATA XREF: .xdata$x:000080F4o
.text$x:00003E5C                 mov     ecx, [ebp-10h]  ; this
.text$x:00003E5F                 jmp     ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base(void)
.text$x:00003E5F __unwindfunclet$??0facet@locale@std@@IAE@I@Z$0 endp
.text$x:00003E5F
.text$x:00003E64
.text$x:00003E64 ; =============== S U B R O U T I N E =======================================
.text$x:00003E64
.text$x:00003E64
.text$x:00003E64 __ehhandler$??0facet@locale@std@@IAE@I@Z proc near
.text$x:00003E64                                         ; DATA XREF: std::locale::facet::facet(uint)+5o
.text$x:00003E64
.text$x:00003E64 arg_4           = dword ptr  8
.text$x:00003E64
.text$x:00003E64                 mov     edx, [esp+arg_4]
.text$x:00003E68                 lea     eax, [edx+0Ch]
.text$x:00003E6B                 mov     ecx, [edx-8]
.text$x:00003E6E                 xor     ecx, eax
.text$x:00003E70                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003E75                 mov     eax, offset __ehfuncinfo$??0facet@locale@std@@IAE@I@Z
.text$x:00003E7A                 jmp     ___CxxFrameHandler3
.text$x:00003E7A __ehhandler$??0facet@locale@std@@IAE@I@Z endp
.text$x:00003E7A
.text$x:00003E7A ; ---------------------------------------------------------------------------
.text$x:00003E7F                 align 10h
.text$x:00003E7F _text$x         ends
.text$x:00003E7F
.text$mn:00003E80 ; ===========================================================================
.text$mn:00003E80
.text$mn:00003E80 ; Segment type: Pure code
.text$mn:00003E80 ; Segment permissions: Read/Execute
.text$mn:00003E80 _text$mn        segment para public 'CODE' use32
.text$mn:00003E80                 assume cs:_text$mn
.text$mn:00003E80                 ;org 3E80h
.text$mn:00003E80 ; COMDAT (pick any)
.text$mn:00003E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E80
.text$mn:00003E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E80
.text$mn:00003E80 ; Attributes: bp-based frame
.text$mn:00003E80
.text$mn:00003E80 ; _DWORD __thiscall std::ios_base::failure::failure(std::ios_base::failure *this, const struct std::ios_base::failure *)
.text$mn:00003E80                 public ??0failure@ios_base@std@@QAE@ABV012@@Z
.text$mn:00003E80 ??0failure@ios_base@std@@QAE@ABV012@@Z proc near
.text$mn:00003E80                                         ; DATA XREF: .xdata$x:00008F5Co
.text$mn:00003E80
.text$mn:00003E80 var_10          = dword ptr -10h
.text$mn:00003E80 var_C           = dword ptr -0Ch
.text$mn:00003E80 var_4           = dword ptr -4
.text$mn:00003E80 arg_0           = dword ptr  8
.text$mn:00003E80
.text$mn:00003E80                 push    ebp
.text$mn:00003E81                 mov     ebp, esp
.text$mn:00003E83                 push    0FFFFFFFFh
.text$mn:00003E85                 push    offset __ehhandler$??0failure@ios_base@std@@QAE@ABV012@@Z
.text$mn:00003E8A                 mov     eax, large fs:0
.text$mn:00003E90                 push    eax
.text$mn:00003E91                 push    ecx
.text$mn:00003E92                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E97                 xor     eax, ebp
.text$mn:00003E99                 push    eax
.text$mn:00003E9A                 lea     eax, [ebp+var_C]
.text$mn:00003E9D                 mov     large fs:0, eax
.text$mn:00003EA3                 mov     [ebp+var_10], ecx
.text$mn:00003EA6                 mov     eax, [ebp+arg_0]
.text$mn:00003EA9                 push    eax             ; struct std::system_error *
.text$mn:00003EAA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003EAD                 call    ??0system_error@std@@QAE@ABV01@@Z ; std::system_error::system_error(std::system_error const &)
.text$mn:00003EB2                 mov     [ebp+var_4], 0
.text$mn:00003EB9                 mov     ecx, [ebp+var_10]
.text$mn:00003EBC                 mov     dword ptr [ecx], offset ??_7failure@ios_base@std@@6B@ ; const std::ios_base::failure::`vftable'
.text$mn:00003EC2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003EC9                 mov     eax, [ebp+var_10]
.text$mn:00003ECC                 mov     ecx, [ebp+var_C]
.text$mn:00003ECF                 mov     large fs:0, ecx
.text$mn:00003ED6                 pop     ecx
.text$mn:00003ED7                 mov     esp, ebp
.text$mn:00003ED9                 pop     ebp
.text$mn:00003EDA                 retn    4
.text$mn:00003EDA ??0failure@ios_base@std@@QAE@ABV012@@Z endp
.text$mn:00003EDA
.text$mn:00003EDA ; ---------------------------------------------------------------------------
.text$mn:00003EDD                 align 10h
.text$mn:00003EDD _text$mn        ends
.text$mn:00003EDD
.text$x:00003EE0 ; ===========================================================================
.text$x:00003EE0
.text$x:00003EE0 ; Segment type: Pure code
.text$x:00003EE0 ; Segment permissions: Read/Execute
.text$x:00003EE0 _text$x         segment para public 'CODE' use32
.text$x:00003EE0                 assume cs:_text$x
.text$x:00003EE0                 ;org 3EE0h
.text$x:00003EE0 ; COMDAT (pick associative to section at 3E80)
.text$x:00003EE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003EE0
.text$x:00003EE0 ; =============== S U B R O U T I N E =======================================
.text$x:00003EE0
.text$x:00003EE0
.text$x:00003EE0 __unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$0 proc near
.text$x:00003EE0                                         ; DATA XREF: .xdata$x:000085E0o
.text$x:00003EE0                 mov     ecx, [ebp-10h]  ; this
.text$x:00003EE3                 jmp     ??1system_error@std@@UAE@XZ ; std::system_error::~system_error(void)
.text$x:00003EE3 __unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$0 endp
.text$x:00003EE3
.text$x:00003EE8
.text$x:00003EE8 ; =============== S U B R O U T I N E =======================================
.text$x:00003EE8
.text$x:00003EE8
.text$x:00003EE8 __ehhandler$??0failure@ios_base@std@@QAE@ABV012@@Z proc near
.text$x:00003EE8                                         ; DATA XREF: std::ios_base::failure::failure(std::ios_base::failure const &)+5o
.text$x:00003EE8
.text$x:00003EE8 arg_4           = dword ptr  8
.text$x:00003EE8
.text$x:00003EE8                 mov     edx, [esp+arg_4]
.text$x:00003EEC                 lea     eax, [edx+0Ch]
.text$x:00003EEF                 mov     ecx, [edx-8]
.text$x:00003EF2                 xor     ecx, eax
.text$x:00003EF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003EF9                 mov     eax, offset __ehfuncinfo$??0failure@ios_base@std@@QAE@ABV012@@Z
.text$x:00003EFE                 jmp     ___CxxFrameHandler3
.text$x:00003EFE __ehhandler$??0failure@ios_base@std@@QAE@ABV012@@Z endp
.text$x:00003EFE
.text$x:00003EFE ; ---------------------------------------------------------------------------
.text$x:00003F03                 align 4
.text$x:00003F03 _text$x         ends
.text$x:00003F03
.text$mn:00003F04 ; ===========================================================================
.text$mn:00003F04
.text$mn:00003F04 ; Segment type: Pure code
.text$mn:00003F04 ; Segment permissions: Read/Execute
.text$mn:00003F04 _text$mn        segment para public 'CODE' use32
.text$mn:00003F04                 assume cs:_text$mn
.text$mn:00003F04                 ;org 3F04h
.text$mn:00003F04 ; COMDAT (pick any)
.text$mn:00003F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F04
.text$mn:00003F04 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F04
.text$mn:00003F04 ; Attributes: bp-based frame
.text$mn:00003F04
.text$mn:00003F04 ; _DWORD __thiscall std::ios_base::failure::failure(std::ios_base::failure *this, const char *, const struct std::error_code *)
.text$mn:00003F04                 public ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
.text$mn:00003F04 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z proc near
.text$mn:00003F04                                         ; CODE XREF: std::ios_base::clear(int,bool)+66p
.text$mn:00003F04                                         ; std::ios_base::clear(int,bool)+A3p ...
.text$mn:00003F04
.text$mn:00003F04 var_10          = dword ptr -10h
.text$mn:00003F04 var_C           = dword ptr -0Ch
.text$mn:00003F04 var_4           = dword ptr -4
.text$mn:00003F04 arg_0           = dword ptr  8
.text$mn:00003F04 arg_4           = dword ptr  0Ch
.text$mn:00003F04
.text$mn:00003F04                 push    ebp
.text$mn:00003F05                 mov     ebp, esp
.text$mn:00003F07                 push    0FFFFFFFFh
.text$mn:00003F09                 push    offset __ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
.text$mn:00003F0E                 mov     eax, large fs:0
.text$mn:00003F14                 push    eax
.text$mn:00003F15                 push    ecx
.text$mn:00003F16                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003F1B                 xor     eax, ebp
.text$mn:00003F1D                 push    eax
.text$mn:00003F1E                 lea     eax, [ebp+var_C]
.text$mn:00003F21                 mov     large fs:0, eax
.text$mn:00003F27                 mov     [ebp+var_10], ecx
.text$mn:00003F2A                 mov     eax, [ebp+arg_0]
.text$mn:00003F2D                 push    eax
.text$mn:00003F2E                 mov     ecx, [ebp+arg_4]
.text$mn:00003F31                 mov     edx, [ecx+4]
.text$mn:00003F34                 push    edx
.text$mn:00003F35                 mov     eax, [ecx]
.text$mn:00003F37                 push    eax
.text$mn:00003F38                 mov     ecx, [ebp+var_10]
.text$mn:00003F3B                 call    ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error(std::error_code,char const *)
.text$mn:00003F40                 mov     [ebp+var_4], 0
.text$mn:00003F47                 mov     ecx, [ebp+var_10]
.text$mn:00003F4A                 mov     dword ptr [ecx], offset ??_7failure@ios_base@std@@6B@ ; const std::ios_base::failure::`vftable'
.text$mn:00003F50                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F57                 mov     eax, [ebp+var_10]
.text$mn:00003F5A                 mov     ecx, [ebp+var_C]
.text$mn:00003F5D                 mov     large fs:0, ecx
.text$mn:00003F64                 pop     ecx
.text$mn:00003F65                 mov     esp, ebp
.text$mn:00003F67                 pop     ebp
.text$mn:00003F68                 retn    8
.text$mn:00003F68 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z endp
.text$mn:00003F68
.text$mn:00003F68 ; ---------------------------------------------------------------------------
.text$mn:00003F6B                 align 4
.text$mn:00003F6B _text$mn        ends
.text$mn:00003F6B
.text$x:00003F6C ; ===========================================================================
.text$x:00003F6C
.text$x:00003F6C ; Segment type: Pure code
.text$x:00003F6C ; Segment permissions: Read/Execute
.text$x:00003F6C _text$x         segment para public 'CODE' use32
.text$x:00003F6C                 assume cs:_text$x
.text$x:00003F6C                 ;org 3F6Ch
.text$x:00003F6C ; COMDAT (pick associative to section at 3F04)
.text$x:00003F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F6C
.text$x:00003F6C ; =============== S U B R O U T I N E =======================================
.text$x:00003F6C
.text$x:00003F6C
.text$x:00003F6C __unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$0 proc near
.text$x:00003F6C                                         ; DATA XREF: .xdata$x:00008588o
.text$x:00003F6C                 mov     ecx, [ebp-10h]  ; this
.text$x:00003F6F                 jmp     ??1system_error@std@@UAE@XZ ; std::system_error::~system_error(void)
.text$x:00003F6F __unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$0 endp
.text$x:00003F6F
.text$x:00003F74
.text$x:00003F74 ; =============== S U B R O U T I N E =======================================
.text$x:00003F74
.text$x:00003F74
.text$x:00003F74 __ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z proc near
.text$x:00003F74                                         ; DATA XREF: std::ios_base::failure::failure(char const *,std::error_code const &)+5o
.text$x:00003F74
.text$x:00003F74 arg_4           = dword ptr  8
.text$x:00003F74
.text$x:00003F74                 mov     edx, [esp+arg_4]
.text$x:00003F78                 lea     eax, [edx+0Ch]
.text$x:00003F7B                 mov     ecx, [edx-8]
.text$x:00003F7E                 xor     ecx, eax
.text$x:00003F80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F85                 mov     eax, offset __ehfuncinfo$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
.text$x:00003F8A                 jmp     ___CxxFrameHandler3
.text$x:00003F8A __ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z endp
.text$x:00003F8A
.text$x:00003F8A ; ---------------------------------------------------------------------------
.text$x:00003F8F                 align 10h
.text$x:00003F8F _text$x         ends
.text$x:00003F8F
.text$mn:00003F90 ; ===========================================================================
.text$mn:00003F90
.text$mn:00003F90 ; Segment type: Pure code
.text$mn:00003F90 ; Segment permissions: Read/Execute
.text$mn:00003F90 _text$mn        segment para public 'CODE' use32
.text$mn:00003F90                 assume cs:_text$mn
.text$mn:00003F90                 ;org 3F90h
.text$mn:00003F90 ; COMDAT (pick any)
.text$mn:00003F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F90
.text$mn:00003F90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F90
.text$mn:00003F90 ; Attributes: bp-based frame
.text$mn:00003F90
.text$mn:00003F90 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00003F90                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00003F90 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00003F90                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00003F90
.text$mn:00003F90 var_4           = dword ptr -4
.text$mn:00003F90 arg_0           = dword ptr  8
.text$mn:00003F90
.text$mn:00003F90                 push    ebp
.text$mn:00003F91                 mov     ebp, esp
.text$mn:00003F93                 push    ecx
.text$mn:00003F94                 mov     [ebp+var_4], ecx
.text$mn:00003F97                 mov     eax, [ebp+var_4]
.text$mn:00003F9A                 mov     ecx, [ebp+arg_0]
.text$mn:00003F9D                 mov     [eax], ecx
.text$mn:00003F9F                 mov     eax, [ebp+var_4]
.text$mn:00003FA2                 mov     esp, ebp
.text$mn:00003FA4                 pop     ebp
.text$mn:00003FA5                 retn    4
.text$mn:00003FA5 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00003FA5
.text$mn:00003FA5 _text$mn        ends
.text$mn:00003FA5
.text$mn:00003FA8 ; ===========================================================================
.text$mn:00003FA8
.text$mn:00003FA8 ; Segment type: Pure code
.text$mn:00003FA8 ; Segment permissions: Read/Execute
.text$mn:00003FA8 _text$mn        segment para public 'CODE' use32
.text$mn:00003FA8                 assume cs:_text$mn
.text$mn:00003FA8                 ;org 3FA8h
.text$mn:00003FA8 ; COMDAT (pick any)
.text$mn:00003FA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FA8
.text$mn:00003FA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FA8
.text$mn:00003FA8 ; Attributes: bp-based frame
.text$mn:00003FA8
.text$mn:00003FA8 ; _DWORD __thiscall std::locale::locale(std::locale *this, const struct std::locale *)
.text$mn:00003FA8                 public ??0locale@std@@QAE@ABV01@@Z
.text$mn:00003FA8 ??0locale@std@@QAE@ABV01@@Z proc near   ; CODE XREF: std::ios_base::getloc(void)+39p
.text$mn:00003FA8
.text$mn:00003FA8 var_4           = dword ptr -4
.text$mn:00003FA8 arg_0           = dword ptr  8
.text$mn:00003FA8
.text$mn:00003FA8                 push    ebp
.text$mn:00003FA9                 mov     ebp, esp
.text$mn:00003FAB                 push    ecx
.text$mn:00003FAC                 mov     [ebp+var_4], ecx
.text$mn:00003FAF                 mov     eax, [ebp+var_4]
.text$mn:00003FB2                 mov     ecx, [ebp+arg_0]
.text$mn:00003FB5                 mov     edx, [ecx]
.text$mn:00003FB7                 mov     [eax], edx
.text$mn:00003FB9                 mov     eax, [ebp+var_4]
.text$mn:00003FBC                 mov     ecx, [eax]
.text$mn:00003FBE                 mov     edx, [ebp+var_4]
.text$mn:00003FC1                 mov     eax, [ecx]
.text$mn:00003FC3                 mov     ecx, [edx]
.text$mn:00003FC5                 mov     edx, [eax+4]
.text$mn:00003FC8                 call    edx
.text$mn:00003FCA                 mov     eax, [ebp+var_4]
.text$mn:00003FCD                 mov     esp, ebp
.text$mn:00003FCF                 pop     ebp
.text$mn:00003FD0                 retn    4
.text$mn:00003FD0 ??0locale@std@@QAE@ABV01@@Z endp
.text$mn:00003FD0
.text$mn:00003FD0 ; ---------------------------------------------------------------------------
.text$mn:00003FD3                 align 4
.text$mn:00003FD3 _text$mn        ends
.text$mn:00003FD3
.text$mn:00003FD4 ; ===========================================================================
.text$mn:00003FD4
.text$mn:00003FD4 ; Segment type: Pure code
.text$mn:00003FD4 ; Segment permissions: Read/Execute
.text$mn:00003FD4 _text$mn        segment para public 'CODE' use32
.text$mn:00003FD4                 assume cs:_text$mn
.text$mn:00003FD4                 ;org 3FD4h
.text$mn:00003FD4 ; COMDAT (pick any)
.text$mn:00003FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FD4
.text$mn:00003FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FD4
.text$mn:00003FD4 ; Attributes: bp-based frame
.text$mn:00003FD4
.text$mn:00003FD4 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00003FD4                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00003FD4 ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00003FD4                                         ; CODE XREF: std::_System_error::_System_error(std::_System_error const &)+2Dp
.text$mn:00003FD4                                         ; DATA XREF: .xdata$x:00008C88o
.text$mn:00003FD4
.text$mn:00003FD4 var_10          = dword ptr -10h
.text$mn:00003FD4 var_C           = dword ptr -0Ch
.text$mn:00003FD4 var_4           = dword ptr -4
.text$mn:00003FD4 arg_0           = dword ptr  8
.text$mn:00003FD4
.text$mn:00003FD4                 push    ebp
.text$mn:00003FD5                 mov     ebp, esp
.text$mn:00003FD7                 push    0FFFFFFFFh
.text$mn:00003FD9                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00003FDE                 mov     eax, large fs:0
.text$mn:00003FE4                 push    eax
.text$mn:00003FE5                 push    ecx
.text$mn:00003FE6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FEB                 xor     eax, ebp
.text$mn:00003FED                 push    eax
.text$mn:00003FEE                 lea     eax, [ebp+var_C]
.text$mn:00003FF1                 mov     large fs:0, eax
.text$mn:00003FF7                 mov     [ebp+var_10], ecx
.text$mn:00003FFA                 mov     eax, [ebp+arg_0]
.text$mn:00003FFD                 push    eax             ; struct std::exception *
.text$mn:00003FFE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004001                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:00004006                 mov     [ebp+var_4], 0
.text$mn:0000400D                 mov     ecx, [ebp+var_10]
.text$mn:00004010                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00004016                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000401D                 mov     eax, [ebp+var_10]
.text$mn:00004020                 mov     ecx, [ebp+var_C]
.text$mn:00004023                 mov     large fs:0, ecx
.text$mn:0000402A                 pop     ecx
.text$mn:0000402B                 mov     esp, ebp
.text$mn:0000402D                 pop     ebp
.text$mn:0000402E                 retn    4
.text$mn:0000402E ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:0000402E
.text$mn:0000402E ; ---------------------------------------------------------------------------
.text$mn:00004031                 align 4
.text$mn:00004031 _text$mn        ends
.text$mn:00004031
.text$x:00004034 ; ===========================================================================
.text$x:00004034
.text$x:00004034 ; Segment type: Pure code
.text$x:00004034 ; Segment permissions: Read/Execute
.text$x:00004034 _text$x         segment para public 'CODE' use32
.text$x:00004034                 assume cs:_text$x
.text$x:00004034                 ;org 4034h
.text$x:00004034 ; COMDAT (pick associative to section at 3FD4)
.text$x:00004034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004034
.text$x:00004034 ; =============== S U B R O U T I N E =======================================
.text$x:00004034
.text$x:00004034
.text$x:00004034 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00004034                                         ; DATA XREF: .xdata$x:00007FE4o
.text$x:00004034                 mov     ecx, [ebp-10h]  ; this
.text$x:00004037                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00004037 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00004037
.text$x:0000403C
.text$x:0000403C ; =============== S U B R O U T I N E =======================================
.text$x:0000403C
.text$x:0000403C
.text$x:0000403C __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:0000403C                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:0000403C
.text$x:0000403C arg_4           = dword ptr  8
.text$x:0000403C
.text$x:0000403C                 mov     edx, [esp+arg_4]
.text$x:00004040                 lea     eax, [edx+0Ch]
.text$x:00004043                 mov     ecx, [edx-8]
.text$x:00004046                 xor     ecx, eax
.text$x:00004048                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000404D                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:00004052                 jmp     ___CxxFrameHandler3
.text$x:00004052 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:00004052
.text$x:00004052 ; ---------------------------------------------------------------------------
.text$x:00004057                 align 4
.text$x:00004057 _text$x         ends
.text$x:00004057
.text$mn:00004058 ; ===========================================================================
.text$mn:00004058
.text$mn:00004058 ; Segment type: Pure code
.text$mn:00004058 ; Segment permissions: Read/Execute
.text$mn:00004058 _text$mn        segment para public 'CODE' use32
.text$mn:00004058                 assume cs:_text$mn
.text$mn:00004058                 ;org 4058h
.text$mn:00004058 ; COMDAT (pick any)
.text$mn:00004058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004058
.text$mn:00004058 ; =============== S U B R O U T I N E =======================================
.text$mn:00004058
.text$mn:00004058 ; Attributes: bp-based frame
.text$mn:00004058
.text$mn:00004058 ; public: __thiscall std::runtime_error::runtime_error(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
.text$mn:00004058                 public ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
.text$mn:00004058 ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z proc near
.text$mn:00004058                                         ; CODE XREF: std::_System_error::_System_error(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+7Ep
.text$mn:00004058
.text$mn:00004058 var_14          = dword ptr -14h
.text$mn:00004058 var_10          = dword ptr -10h
.text$mn:00004058 var_C           = dword ptr -0Ch
.text$mn:00004058 var_4           = dword ptr -4
.text$mn:00004058 arg_0           = dword ptr  8
.text$mn:00004058
.text$mn:00004058                 push    ebp
.text$mn:00004059                 mov     ebp, esp
.text$mn:0000405B                 push    0FFFFFFFFh
.text$mn:0000405D                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
.text$mn:00004062                 mov     eax, large fs:0
.text$mn:00004068                 push    eax
.text$mn:00004069                 sub     esp, 8
.text$mn:0000406C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004071                 xor     eax, ebp
.text$mn:00004073                 push    eax
.text$mn:00004074                 lea     eax, [ebp+var_C]
.text$mn:00004077                 mov     large fs:0, eax
.text$mn:0000407D                 mov     [ebp+var_10], ecx
.text$mn:00004080                 mov     ecx, [ebp+arg_0]
.text$mn:00004083                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:00004088                 mov     [ebp+var_14], eax
.text$mn:0000408B                 lea     eax, [ebp+var_14]
.text$mn:0000408E                 push    eax             ; char **
.text$mn:0000408F                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004092                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00004097                 mov     [ebp+var_4], 0
.text$mn:0000409E                 mov     ecx, [ebp+var_10]
.text$mn:000040A1                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:000040A7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000040AE                 mov     eax, [ebp+var_10]
.text$mn:000040B1                 mov     ecx, [ebp+var_C]
.text$mn:000040B4                 mov     large fs:0, ecx
.text$mn:000040BB                 pop     ecx
.text$mn:000040BC                 mov     esp, ebp
.text$mn:000040BE                 pop     ebp
.text$mn:000040BF                 retn    4
.text$mn:000040BF ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z endp
.text$mn:000040BF
.text$mn:000040BF ; ---------------------------------------------------------------------------
.text$mn:000040C2                 align 4
.text$mn:000040C2 _text$mn        ends
.text$mn:000040C2
.text$x:000040C4 ; ===========================================================================
.text$x:000040C4
.text$x:000040C4 ; Segment type: Pure code
.text$x:000040C4 ; Segment permissions: Read/Execute
.text$x:000040C4 _text$x         segment para public 'CODE' use32
.text$x:000040C4                 assume cs:_text$x
.text$x:000040C4                 ;org 40C4h
.text$x:000040C4 ; COMDAT (pick associative to section at 4058)
.text$x:000040C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000040C4
.text$x:000040C4 ; =============== S U B R O U T I N E =======================================
.text$x:000040C4
.text$x:000040C4
.text$x:000040C4 __unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0 proc near
.text$x:000040C4                                         ; DATA XREF: .xdata$x:00007F60o
.text$x:000040C4                 mov     ecx, [ebp-10h]  ; this
.text$x:000040C7                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:000040C7 __unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0 endp
.text$x:000040C7
.text$x:000040CC
.text$x:000040CC ; =============== S U B R O U T I N E =======================================
.text$x:000040CC
.text$x:000040CC
.text$x:000040CC __ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z proc near
.text$x:000040CC                                         ; DATA XREF: std::runtime_error::runtime_error(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5o
.text$x:000040CC
.text$x:000040CC arg_4           = dword ptr  8
.text$x:000040CC
.text$x:000040CC                 mov     edx, [esp+arg_4]
.text$x:000040D0                 lea     eax, [edx+0Ch]
.text$x:000040D3                 mov     ecx, [edx-0Ch]
.text$x:000040D6                 xor     ecx, eax
.text$x:000040D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000040DD                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
.text$x:000040E2                 jmp     ___CxxFrameHandler3
.text$x:000040E2 __ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z endp
.text$x:000040E2
.text$x:000040E2 ; ---------------------------------------------------------------------------
.text$x:000040E7                 align 4
.text$x:000040E7 _text$x         ends
.text$x:000040E7
.text$mn:000040E8 ; ===========================================================================
.text$mn:000040E8
.text$mn:000040E8 ; Segment type: Pure code
.text$mn:000040E8 ; Segment permissions: Read/Execute
.text$mn:000040E8 _text$mn        segment para public 'CODE' use32
.text$mn:000040E8                 assume cs:_text$mn
.text$mn:000040E8                 ;org 40E8h
.text$mn:000040E8 ; COMDAT (pick any)
.text$mn:000040E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040E8
.text$mn:000040E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000040E8
.text$mn:000040E8 ; Attributes: bp-based frame
.text$mn:000040E8
.text$mn:000040E8 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:000040E8                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:000040E8 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:000040E8                                         ; CODE XREF: std::_Locinfo::_Locinfo(char const *)+A1p
.text$mn:000040E8
.text$mn:000040E8 var_10          = dword ptr -10h
.text$mn:000040E8 var_C           = dword ptr -0Ch
.text$mn:000040E8 var_4           = dword ptr -4
.text$mn:000040E8 arg_0           = dword ptr  8
.text$mn:000040E8
.text$mn:000040E8                 push    ebp
.text$mn:000040E9                 mov     ebp, esp
.text$mn:000040EB                 push    0FFFFFFFFh
.text$mn:000040ED                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:000040F2                 mov     eax, large fs:0
.text$mn:000040F8                 push    eax
.text$mn:000040F9                 push    ecx
.text$mn:000040FA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000040FF                 xor     eax, ebp
.text$mn:00004101                 push    eax
.text$mn:00004102                 lea     eax, [ebp+var_C]
.text$mn:00004105                 mov     large fs:0, eax
.text$mn:0000410B                 mov     [ebp+var_10], ecx
.text$mn:0000410E                 lea     eax, [ebp+arg_0]
.text$mn:00004111                 push    eax             ; char **
.text$mn:00004112                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004115                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:0000411A                 mov     [ebp+var_4], 0
.text$mn:00004121                 mov     ecx, [ebp+var_10]
.text$mn:00004124                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:0000412A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004131                 mov     eax, [ebp+var_10]
.text$mn:00004134                 mov     ecx, [ebp+var_C]
.text$mn:00004137                 mov     large fs:0, ecx
.text$mn:0000413E                 pop     ecx
.text$mn:0000413F                 mov     esp, ebp
.text$mn:00004141                 pop     ebp
.text$mn:00004142                 retn    4
.text$mn:00004142 ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:00004142
.text$mn:00004142 ; ---------------------------------------------------------------------------
.text$mn:00004145                 align 4
.text$mn:00004145 _text$mn        ends
.text$mn:00004145
.text$x:00004148 ; ===========================================================================
.text$x:00004148
.text$x:00004148 ; Segment type: Pure code
.text$x:00004148 ; Segment permissions: Read/Execute
.text$x:00004148 _text$x         segment para public 'CODE' use32
.text$x:00004148                 assume cs:_text$x
.text$x:00004148                 ;org 4148h
.text$x:00004148 ; COMDAT (pick associative to section at 40E8)
.text$x:00004148                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004148
.text$x:00004148 ; =============== S U B R O U T I N E =======================================
.text$x:00004148
.text$x:00004148
.text$x:00004148 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00004148                                         ; DATA XREF: .xdata$x:00007F8Co
.text$x:00004148                 mov     ecx, [ebp-10h]  ; this
.text$x:0000414B                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:0000414B __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:0000414B
.text$x:00004150
.text$x:00004150 ; =============== S U B R O U T I N E =======================================
.text$x:00004150
.text$x:00004150
.text$x:00004150 __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00004150                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00004150
.text$x:00004150 arg_4           = dword ptr  8
.text$x:00004150
.text$x:00004150                 mov     edx, [esp+arg_4]
.text$x:00004154                 lea     eax, [edx+0Ch]
.text$x:00004157                 mov     ecx, [edx-8]
.text$x:0000415A                 xor     ecx, eax
.text$x:0000415C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004161                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00004166                 jmp     ___CxxFrameHandler3
.text$x:00004166 __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00004166
.text$x:00004166 ; ---------------------------------------------------------------------------
.text$x:0000416B                 align 4
.text$x:0000416B _text$x         ends
.text$x:0000416B
.text$mn:0000416C ; ===========================================================================
.text$mn:0000416C
.text$mn:0000416C ; Segment type: Pure code
.text$mn:0000416C ; Segment permissions: Read/Execute
.text$mn:0000416C _text$mn        segment para public 'CODE' use32
.text$mn:0000416C                 assume cs:_text$mn
.text$mn:0000416C                 ;org 416Ch
.text$mn:0000416C ; COMDAT (pick any)
.text$mn:0000416C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000416C
.text$mn:0000416C ; =============== S U B R O U T I N E =======================================
.text$mn:0000416C
.text$mn:0000416C ; Attributes: bp-based frame
.text$mn:0000416C
.text$mn:0000416C ; public: __thiscall std::basic_istream<char, struct std::char_traits<char>>::sentry::sentry(class std::basic_istream<char, struct std::char_traits<char>> &, bool)
.text$mn:0000416C                 public ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
.text$mn:0000416C ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z proc near
.text$mn:0000416C                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::get(void)+57p
.text$mn:0000416C                                         ; std::basic_istream<char,std::char_traits<char>>::peek(void)+57p
.text$mn:0000416C
.text$mn:0000416C var_10          = dword ptr -10h
.text$mn:0000416C var_C           = dword ptr -0Ch
.text$mn:0000416C var_4           = dword ptr -4
.text$mn:0000416C arg_0           = dword ptr  8
.text$mn:0000416C arg_4           = byte ptr  0Ch
.text$mn:0000416C
.text$mn:0000416C                 push    ebp
.text$mn:0000416D                 mov     ebp, esp
.text$mn:0000416F                 push    0FFFFFFFFh
.text$mn:00004171                 push    offset __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
.text$mn:00004176                 mov     eax, large fs:0
.text$mn:0000417C                 push    eax
.text$mn:0000417D                 push    ecx
.text$mn:0000417E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004183                 xor     eax, ebp
.text$mn:00004185                 push    eax
.text$mn:00004186                 lea     eax, [ebp+var_C]
.text$mn:00004189                 mov     large fs:0, eax
.text$mn:0000418F                 mov     [ebp+var_10], ecx
.text$mn:00004192                 mov     eax, [ebp+arg_0]
.text$mn:00004195                 push    eax
.text$mn:00004196                 mov     ecx, [ebp+var_10]
.text$mn:00004199                 call    ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_istream<char,std::char_traits<char>> &)
.text$mn:0000419E                 mov     [ebp+var_4], 0
.text$mn:000041A5                 movzx   ecx, [ebp+arg_4]
.text$mn:000041A9                 push    ecx
.text$mn:000041AA                 mov     edx, [ebp+var_10]
.text$mn:000041AD                 mov     ecx, [edx]
.text$mn:000041AF                 call    ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)
.text$mn:000041B4                 mov     ecx, [ebp+var_10]
.text$mn:000041B7                 mov     [ecx+4], al
.text$mn:000041BA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000041C1                 mov     eax, [ebp+var_10]
.text$mn:000041C4                 mov     ecx, [ebp+var_C]
.text$mn:000041C7                 mov     large fs:0, ecx
.text$mn:000041CE                 pop     ecx
.text$mn:000041CF                 mov     esp, ebp
.text$mn:000041D1                 pop     ebp
.text$mn:000041D2                 retn    8
.text$mn:000041D2 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z endp
.text$mn:000041D2
.text$mn:000041D2 ; ---------------------------------------------------------------------------
.text$mn:000041D5                 align 4
.text$mn:000041D5 _text$mn        ends
.text$mn:000041D5
.text$x:000041D8 ; ===========================================================================
.text$x:000041D8
.text$x:000041D8 ; Segment type: Pure code
.text$x:000041D8 ; Segment permissions: Read/Execute
.text$x:000041D8 _text$x         segment para public 'CODE' use32
.text$x:000041D8                 assume cs:_text$x
.text$x:000041D8                 ;org 41D8h
.text$x:000041D8 ; COMDAT (pick associative to section at 416C)
.text$x:000041D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000041D8
.text$x:000041D8 ; =============== S U B R O U T I N E =======================================
.text$x:000041D8
.text$x:000041D8
.text$x:000041D8 __unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0 proc near
.text$x:000041D8                                         ; DATA XREF: .xdata$x:00008758o
.text$x:000041D8                 mov     ecx, [ebp-10h]
.text$x:000041DB                 jmp     ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
.text$x:000041DB __unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0 endp
.text$x:000041DB
.text$x:000041E0
.text$x:000041E0 ; =============== S U B R O U T I N E =======================================
.text$x:000041E0
.text$x:000041E0
.text$x:000041E0 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z proc near
.text$x:000041E0                                         ; DATA XREF: std::basic_istream<char,std::char_traits<char>>::sentry::sentry(std::basic_istream<char,std::char_traits<char>> &,bool)+5o
.text$x:000041E0
.text$x:000041E0 arg_4           = dword ptr  8
.text$x:000041E0
.text$x:000041E0                 mov     edx, [esp+arg_4]
.text$x:000041E4                 lea     eax, [edx+0Ch]
.text$x:000041E7                 mov     ecx, [edx-8]
.text$x:000041EA                 xor     ecx, eax
.text$x:000041EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000041F1                 mov     eax, offset __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
.text$x:000041F6                 jmp     ___CxxFrameHandler3
.text$x:000041F6 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z endp
.text$x:000041F6
.text$x:000041F6 ; ---------------------------------------------------------------------------
.text$x:000041FB                 align 4
.text$x:000041FB _text$x         ends
.text$x:000041FB
.text$mn:000041FC ; ===========================================================================
.text$mn:000041FC
.text$mn:000041FC ; Segment type: Pure code
.text$mn:000041FC ; Segment permissions: Read/Execute
.text$mn:000041FC _text$mn        segment para public 'CODE' use32
.text$mn:000041FC                 assume cs:_text$mn
.text$mn:000041FC                 ;org 41FCh
.text$mn:000041FC ; COMDAT (pick any)
.text$mn:000041FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000041FC
.text$mn:000041FC ; =============== S U B R O U T I N E =======================================
.text$mn:000041FC
.text$mn:000041FC ; Attributes: bp-based frame
.text$mn:000041FC
.text$mn:000041FC ; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::sentry::sentry(class std::basic_ostream<char, struct std::char_traits<char>> &)
.text$mn:000041FC                 public ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
.text$mn:000041FC ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z proc near
.text$mn:000041FC                                         ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::flush(void)+45p
.text$mn:000041FC
.text$mn:000041FC var_10          = dword ptr -10h
.text$mn:000041FC var_C           = dword ptr -0Ch
.text$mn:000041FC var_4           = dword ptr -4
.text$mn:000041FC arg_0           = dword ptr  8
.text$mn:000041FC
.text$mn:000041FC                 push    ebp
.text$mn:000041FD                 mov     ebp, esp
.text$mn:000041FF                 push    0FFFFFFFFh
.text$mn:00004201                 push    offset __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
.text$mn:00004206                 mov     eax, large fs:0
.text$mn:0000420C                 push    eax
.text$mn:0000420D                 push    ecx
.text$mn:0000420E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004213                 xor     eax, ebp
.text$mn:00004215                 push    eax
.text$mn:00004216                 lea     eax, [ebp+var_C]
.text$mn:00004219                 mov     large fs:0, eax
.text$mn:0000421F                 mov     [ebp+var_10], ecx
.text$mn:00004222                 mov     eax, [ebp+arg_0]
.text$mn:00004225                 push    eax
.text$mn:00004226                 mov     ecx, [ebp+var_10]
.text$mn:00004229                 call    ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_ostream<char,std::char_traits<char>> &)
.text$mn:0000422E                 mov     [ebp+var_4], 0
.text$mn:00004235                 mov     ecx, [ebp+arg_0]
.text$mn:00004238                 mov     edx, [ecx]
.text$mn:0000423A                 mov     ecx, [ebp+arg_0]
.text$mn:0000423D                 add     ecx, [edx+4]    ; this
.text$mn:00004240                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:00004245                 movzx   eax, al
.text$mn:00004248                 test    eax, eax
.text$mn:0000424A                 jz      short loc_4290
.text$mn:0000424C                 mov     ecx, [ebp+arg_0]
.text$mn:0000424F                 mov     edx, [ecx]
.text$mn:00004251                 mov     ecx, [ebp+arg_0]
.text$mn:00004254                 add     ecx, [edx+4]
.text$mn:00004257                 call    ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
.text$mn:0000425C                 test    eax, eax
.text$mn:0000425E                 jz      short loc_4290
.text$mn:00004260                 mov     eax, [ebp+arg_0]
.text$mn:00004263                 mov     ecx, [eax]
.text$mn:00004265                 mov     edx, [ebp+arg_0]
.text$mn:00004268                 add     edx, [ecx+4]
.text$mn:0000426B                 mov     ecx, edx
.text$mn:0000426D                 call    ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
.text$mn:00004272                 cmp     eax, [ebp+arg_0]
.text$mn:00004275                 jz      short loc_4290
.text$mn:00004277                 mov     eax, [ebp+arg_0]
.text$mn:0000427A                 mov     ecx, [eax]
.text$mn:0000427C                 mov     edx, [ebp+arg_0]
.text$mn:0000427F                 add     edx, [ecx+4]
.text$mn:00004282                 mov     ecx, edx
.text$mn:00004284                 call    ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
.text$mn:00004289                 mov     ecx, eax
.text$mn:0000428B                 call    ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char>>::flush(void)
.text$mn:00004290
.text$mn:00004290 loc_4290:                               ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+4Ej
.text$mn:00004290                                         ; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+62j ...
.text$mn:00004290                 mov     eax, [ebp+arg_0]
.text$mn:00004293                 mov     ecx, [eax]
.text$mn:00004295                 mov     edx, [ebp+arg_0]
.text$mn:00004298                 add     edx, [ecx+4]
.text$mn:0000429B                 mov     ecx, edx        ; this
.text$mn:0000429D                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:000042A2                 mov     ecx, [ebp+var_10]
.text$mn:000042A5                 mov     [ecx+4], al
.text$mn:000042A8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000042AF                 mov     eax, [ebp+var_10]
.text$mn:000042B2                 mov     ecx, [ebp+var_C]
.text$mn:000042B5                 mov     large fs:0, ecx
.text$mn:000042BC                 pop     ecx
.text$mn:000042BD                 mov     esp, ebp
.text$mn:000042BF                 pop     ebp
.text$mn:000042C0                 retn    4
.text$mn:000042C0 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z endp
.text$mn:000042C0
.text$mn:000042C0 ; ---------------------------------------------------------------------------
.text$mn:000042C3                 align 4
.text$mn:000042C3 _text$mn        ends
.text$mn:000042C3
.text$x:000042C4 ; ===========================================================================
.text$x:000042C4
.text$x:000042C4 ; Segment type: Pure code
.text$x:000042C4 ; Segment permissions: Read/Execute
.text$x:000042C4 _text$x         segment para public 'CODE' use32
.text$x:000042C4                 assume cs:_text$x
.text$x:000042C4                 ;org 42C4h
.text$x:000042C4 ; COMDAT (pick associative to section at 41FC)
.text$x:000042C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000042C4
.text$x:000042C4 ; =============== S U B R O U T I N E =======================================
.text$x:000042C4
.text$x:000042C4
.text$x:000042C4 __unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0 proc near
.text$x:000042C4                                         ; DATA XREF: .xdata$x:00008BA0o
.text$x:000042C4                 mov     ecx, [ebp-10h]
.text$x:000042C7                 jmp     ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
.text$x:000042C7 __unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0 endp
.text$x:000042C7
.text$x:000042CC
.text$x:000042CC ; =============== S U B R O U T I N E =======================================
.text$x:000042CC
.text$x:000042CC
.text$x:000042CC __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z proc near
.text$x:000042CC                                         ; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+5o
.text$x:000042CC
.text$x:000042CC arg_4           = dword ptr  8
.text$x:000042CC
.text$x:000042CC                 mov     edx, [esp+arg_4]
.text$x:000042D0                 lea     eax, [edx+0Ch]
.text$x:000042D3                 mov     ecx, [edx-8]
.text$x:000042D6                 xor     ecx, eax
.text$x:000042D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000042DD                 mov     eax, offset __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
.text$x:000042E2                 jmp     ___CxxFrameHandler3
.text$x:000042E2 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z endp
.text$x:000042E2
.text$x:000042E2 ; ---------------------------------------------------------------------------
.text$x:000042E7                 align 4
.text$x:000042E7 _text$x         ends
.text$x:000042E7
.text$mn:000042E8 ; ===========================================================================
.text$mn:000042E8
.text$mn:000042E8 ; Segment type: Pure code
.text$mn:000042E8 ; Segment permissions: Read/Execute
.text$mn:000042E8 _text$mn        segment para public 'CODE' use32
.text$mn:000042E8                 assume cs:_text$mn
.text$mn:000042E8                 ;org 42E8h
.text$mn:000042E8 ; COMDAT (pick any)
.text$mn:000042E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000042E8
.text$mn:000042E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000042E8
.text$mn:000042E8 ; Attributes: bp-based frame
.text$mn:000042E8
.text$mn:000042E8 ; _DWORD __thiscall std::system_error::system_error(std::system_error *this, const struct std::system_error *)
.text$mn:000042E8                 public ??0system_error@std@@QAE@ABV01@@Z
.text$mn:000042E8 ??0system_error@std@@QAE@ABV01@@Z proc near
.text$mn:000042E8                                         ; CODE XREF: std::ios_base::failure::failure(std::ios_base::failure const &)+2Dp
.text$mn:000042E8                                         ; DATA XREF: .xdata$x:00008F98o
.text$mn:000042E8
.text$mn:000042E8 var_10          = dword ptr -10h
.text$mn:000042E8 var_C           = dword ptr -0Ch
.text$mn:000042E8 var_4           = dword ptr -4
.text$mn:000042E8 arg_0           = dword ptr  8
.text$mn:000042E8
.text$mn:000042E8                 push    ebp
.text$mn:000042E9                 mov     ebp, esp
.text$mn:000042EB                 push    0FFFFFFFFh
.text$mn:000042ED                 push    offset __ehhandler$??0system_error@std@@QAE@ABV01@@Z
.text$mn:000042F2                 mov     eax, large fs:0
.text$mn:000042F8                 push    eax
.text$mn:000042F9                 push    ecx
.text$mn:000042FA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000042FF                 xor     eax, ebp
.text$mn:00004301                 push    eax
.text$mn:00004302                 lea     eax, [ebp+var_C]
.text$mn:00004305                 mov     large fs:0, eax
.text$mn:0000430B                 mov     [ebp+var_10], ecx
.text$mn:0000430E                 mov     eax, [ebp+arg_0]
.text$mn:00004311                 push    eax             ; struct std::_System_error *
.text$mn:00004312                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004315                 call    ??0_System_error@std@@QAE@ABV01@@Z ; std::_System_error::_System_error(std::_System_error const &)
.text$mn:0000431A                 mov     [ebp+var_4], 0
.text$mn:00004321                 mov     ecx, [ebp+var_10]
.text$mn:00004324                 mov     dword ptr [ecx], offset ??_7system_error@std@@6B@ ; const std::system_error::`vftable'
.text$mn:0000432A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004331                 mov     eax, [ebp+var_10]
.text$mn:00004334                 mov     ecx, [ebp+var_C]
.text$mn:00004337                 mov     large fs:0, ecx
.text$mn:0000433E                 pop     ecx
.text$mn:0000433F                 mov     esp, ebp
.text$mn:00004341                 pop     ebp
.text$mn:00004342                 retn    4
.text$mn:00004342 ??0system_error@std@@QAE@ABV01@@Z endp
.text$mn:00004342
.text$mn:00004342 ; ---------------------------------------------------------------------------
.text$mn:00004345                 align 4
.text$mn:00004345 _text$mn        ends
.text$mn:00004345
.text$x:00004348 ; ===========================================================================
.text$x:00004348
.text$x:00004348 ; Segment type: Pure code
.text$x:00004348 ; Segment permissions: Read/Execute
.text$x:00004348 _text$x         segment para public 'CODE' use32
.text$x:00004348                 assume cs:_text$x
.text$x:00004348                 ;org 4348h
.text$x:00004348 ; COMDAT (pick associative to section at 42E8)
.text$x:00004348                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004348
.text$x:00004348 ; =============== S U B R O U T I N E =======================================
.text$x:00004348
.text$x:00004348
.text$x:00004348 __unwindfunclet$??0system_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00004348                                         ; DATA XREF: .xdata$x:000083D0o
.text$x:00004348                 mov     ecx, [ebp-10h]  ; this
.text$x:0000434B                 jmp     ??1_System_error@std@@UAE@XZ ; std::_System_error::~_System_error(void)
.text$x:0000434B __unwindfunclet$??0system_error@std@@QAE@ABV01@@Z$0 endp
.text$x:0000434B
.text$x:00004350
.text$x:00004350 ; =============== S U B R O U T I N E =======================================
.text$x:00004350
.text$x:00004350
.text$x:00004350 __ehhandler$??0system_error@std@@QAE@ABV01@@Z proc near
.text$x:00004350                                         ; DATA XREF: std::system_error::system_error(std::system_error const &)+5o
.text$x:00004350
.text$x:00004350 arg_4           = dword ptr  8
.text$x:00004350
.text$x:00004350                 mov     edx, [esp+arg_4]
.text$x:00004354                 lea     eax, [edx+0Ch]
.text$x:00004357                 mov     ecx, [edx-8]
.text$x:0000435A                 xor     ecx, eax
.text$x:0000435C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004361                 mov     eax, offset __ehfuncinfo$??0system_error@std@@QAE@ABV01@@Z
.text$x:00004366                 jmp     ___CxxFrameHandler3
.text$x:00004366 __ehhandler$??0system_error@std@@QAE@ABV01@@Z endp
.text$x:00004366
.text$x:00004366 ; ---------------------------------------------------------------------------
.text$x:0000436B                 align 4
.text$x:0000436B _text$x         ends
.text$x:0000436B
.text$mn:0000436C ; ===========================================================================
.text$mn:0000436C
.text$mn:0000436C ; Segment type: Pure code
.text$mn:0000436C ; Segment permissions: Read/Execute
.text$mn:0000436C _text$mn        segment para public 'CODE' use32
.text$mn:0000436C                 assume cs:_text$mn
.text$mn:0000436C                 ;org 436Ch
.text$mn:0000436C ; COMDAT (pick any)
.text$mn:0000436C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000436C
.text$mn:0000436C ; =============== S U B R O U T I N E =======================================
.text$mn:0000436C
.text$mn:0000436C ; Attributes: bp-based frame
.text$mn:0000436C
.text$mn:0000436C ; public: __thiscall std::system_error::system_error(class std::error_code, char const *)
.text$mn:0000436C                 public ??0system_error@std@@QAE@Verror_code@1@PBD@Z
.text$mn:0000436C ??0system_error@std@@QAE@Verror_code@1@PBD@Z proc near
.text$mn:0000436C                                         ; CODE XREF: std::ios_base::failure::failure(char const *,std::error_code const &)+37p
.text$mn:0000436C
.text$mn:0000436C var_30          = dword ptr -30h
.text$mn:0000436C var_2C          = byte ptr -2Ch
.text$mn:0000436C var_10          = dword ptr -10h
.text$mn:0000436C var_C           = dword ptr -0Ch
.text$mn:0000436C var_4           = dword ptr -4
.text$mn:0000436C arg_0           = dword ptr  8
.text$mn:0000436C arg_4           = dword ptr  0Ch
.text$mn:0000436C Str             = dword ptr  10h
.text$mn:0000436C
.text$mn:0000436C                 push    ebp
.text$mn:0000436D                 mov     ebp, esp
.text$mn:0000436F                 push    0FFFFFFFFh
.text$mn:00004371                 push    offset __ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z
.text$mn:00004376                 mov     eax, large fs:0
.text$mn:0000437C                 push    eax
.text$mn:0000437D                 sub     esp, 24h
.text$mn:00004380                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004385                 xor     eax, ebp
.text$mn:00004387                 mov     [ebp+var_10], eax
.text$mn:0000438A                 push    eax
.text$mn:0000438B                 lea     eax, [ebp+var_C]
.text$mn:0000438E                 mov     large fs:0, eax
.text$mn:00004394                 mov     [ebp+var_30], ecx
.text$mn:00004397                 mov     eax, [ebp+Str]
.text$mn:0000439A                 push    eax             ; Str
.text$mn:0000439B                 lea     ecx, [ebp+var_2C]
.text$mn:0000439E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000043A3                 mov     [ebp+var_4], 0
.text$mn:000043AA                 lea     ecx, [ebp+var_2C]
.text$mn:000043AD                 push    ecx
.text$mn:000043AE                 mov     edx, [ebp+arg_4]
.text$mn:000043B1                 push    edx
.text$mn:000043B2                 mov     eax, [ebp+arg_0]
.text$mn:000043B5                 push    eax
.text$mn:000043B6                 mov     ecx, [ebp+var_30]
.text$mn:000043B9                 call    ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
.text$mn:000043BE                 mov     byte ptr [ebp+var_4], 2
.text$mn:000043C2                 lea     ecx, [ebp+var_2C]
.text$mn:000043C5                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000043CA                 mov     ecx, [ebp+var_30]
.text$mn:000043CD                 mov     dword ptr [ecx], offset ??_7system_error@std@@6B@ ; const std::system_error::`vftable'
.text$mn:000043D3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000043DA                 mov     eax, [ebp+var_30]
.text$mn:000043DD                 mov     ecx, [ebp+var_C]
.text$mn:000043E0                 mov     large fs:0, ecx
.text$mn:000043E7                 pop     ecx
.text$mn:000043E8                 mov     ecx, [ebp+var_10]
.text$mn:000043EB                 xor     ecx, ebp
.text$mn:000043ED                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000043F2                 mov     esp, ebp
.text$mn:000043F4                 pop     ebp
.text$mn:000043F5                 retn    0Ch
.text$mn:000043F5 ??0system_error@std@@QAE@Verror_code@1@PBD@Z endp
.text$mn:000043F5
.text$mn:000043F5 _text$mn        ends
.text$mn:000043F5
.text$x:000043F8 ; ===========================================================================
.text$x:000043F8
.text$x:000043F8 ; Segment type: Pure code
.text$x:000043F8 ; Segment permissions: Read/Execute
.text$x:000043F8 _text$x         segment para public 'CODE' use32
.text$x:000043F8                 assume cs:_text$x
.text$x:000043F8                 ;org 43F8h
.text$x:000043F8 ; COMDAT (pick associative to section at 436C)
.text$x:000043F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000043F8
.text$x:000043F8 ; =============== S U B R O U T I N E =======================================
.text$x:000043F8
.text$x:000043F8
.text$x:000043F8 __unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0 proc near
.text$x:000043F8                                         ; DATA XREF: .xdata$x:00008368o
.text$x:000043F8                 lea     ecx, [ebp-2Ch]
.text$x:000043FB                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000043FB __unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0 endp
.text$x:000043FB
.text$x:00004400
.text$x:00004400 ; =============== S U B R O U T I N E =======================================
.text$x:00004400
.text$x:00004400
.text$x:00004400 __unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$1 proc near
.text$x:00004400                                         ; DATA XREF: .xdata$x:00008370o
.text$x:00004400                                         ; .xdata$x:00008378o
.text$x:00004400                 mov     ecx, [ebp-30h]  ; this
.text$x:00004403                 jmp     ??1_System_error@std@@UAE@XZ ; std::_System_error::~_System_error(void)
.text$x:00004403 __unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$1 endp
.text$x:00004403
.text$x:00004408
.text$x:00004408 ; =============== S U B R O U T I N E =======================================
.text$x:00004408
.text$x:00004408
.text$x:00004408 __ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z proc near
.text$x:00004408                                         ; DATA XREF: std::system_error::system_error(std::error_code,char const *)+5o
.text$x:00004408
.text$x:00004408 arg_4           = dword ptr  8
.text$x:00004408
.text$x:00004408                 mov     edx, [esp+arg_4]
.text$x:0000440C                 lea     eax, [edx+0Ch]
.text$x:0000440F                 mov     ecx, [edx-28h]
.text$x:00004412                 xor     ecx, eax
.text$x:00004414                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004419                 mov     ecx, [edx-4]
.text$x:0000441C                 xor     ecx, eax
.text$x:0000441E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004423                 mov     eax, offset __ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z
.text$x:00004428                 jmp     ___CxxFrameHandler3
.text$x:00004428 __ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z endp
.text$x:00004428
.text$x:00004428 ; ---------------------------------------------------------------------------
.text$x:0000442D                 align 10h
.text$x:0000442D _text$x         ends
.text$x:0000442D
.text$mn:00004430 ; ===========================================================================
.text$mn:00004430
.text$mn:00004430 ; Segment type: Pure code
.text$mn:00004430 ; Segment permissions: Read/Execute
.text$mn:00004430 _text$mn        segment para public 'CODE' use32
.text$mn:00004430                 assume cs:_text$mn
.text$mn:00004430                 ;org 4430h
.text$mn:00004430 ; COMDAT (pick any)
.text$mn:00004430                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004430
.text$mn:00004430 ; =============== S U B R O U T I N E =======================================
.text$mn:00004430
.text$mn:00004430 ; Attributes: bp-based frame
.text$mn:00004430
.text$mn:00004430 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00004430                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00004430 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00004430                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0+3j
.text$mn:00004430                                         ; __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0+3j ...
.text$mn:00004430
.text$mn:00004430 var_10          = dword ptr -10h
.text$mn:00004430 var_C           = dword ptr -0Ch
.text$mn:00004430 var_4           = dword ptr -4
.text$mn:00004430
.text$mn:00004430                 push    ebp
.text$mn:00004431                 mov     ebp, esp
.text$mn:00004433                 push    0FFFFFFFFh
.text$mn:00004435                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000443A                 mov     eax, large fs:0
.text$mn:00004440                 push    eax
.text$mn:00004441                 push    ecx
.text$mn:00004442                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004447                 xor     eax, ebp
.text$mn:00004449                 push    eax
.text$mn:0000444A                 lea     eax, [ebp+var_C]
.text$mn:0000444D                 mov     large fs:0, eax
.text$mn:00004453                 mov     [ebp+var_10], ecx
.text$mn:00004456                 mov     [ebp+var_4], 0
.text$mn:0000445D                 mov     ecx, [ebp+var_10]
.text$mn:00004460                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00004465                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000446C                 mov     ecx, [ebp+var_10]
.text$mn:0000446F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00004474                 mov     ecx, [ebp+var_C]
.text$mn:00004477                 mov     large fs:0, ecx
.text$mn:0000447E                 pop     ecx
.text$mn:0000447F                 mov     esp, ebp
.text$mn:00004481                 pop     ebp
.text$mn:00004482                 retn
.text$mn:00004482 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004482
.text$mn:00004482 ; ---------------------------------------------------------------------------
.text$mn:00004483                 align 4
.text$mn:00004483 _text$mn        ends
.text$mn:00004483
.text$x:00004484 ; ===========================================================================
.text$x:00004484
.text$x:00004484 ; Segment type: Pure code
.text$x:00004484 ; Segment permissions: Read/Execute
.text$x:00004484 _text$x         segment para public 'CODE' use32
.text$x:00004484                 assume cs:_text$x
.text$x:00004484                 ;org 4484h
.text$x:00004484 ; COMDAT (pick associative to section at 4430)
.text$x:00004484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004484
.text$x:00004484 ; =============== S U B R O U T I N E =======================================
.text$x:00004484
.text$x:00004484
.text$x:00004484 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004484                                         ; DATA XREF: .xdata$x:00007DCCo
.text$x:00004484                 mov     ecx, [ebp-10h]
.text$x:00004487                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00004487 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00004487
.text$x:0000448C
.text$x:0000448C ; =============== S U B R O U T I N E =======================================
.text$x:0000448C
.text$x:0000448C
.text$x:0000448C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000448C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:0000448C
.text$x:0000448C arg_4           = dword ptr  8
.text$x:0000448C
.text$x:0000448C                 mov     edx, [esp+arg_4]
.text$x:00004490                 lea     eax, [edx+0Ch]
.text$x:00004493                 mov     ecx, [edx-8]
.text$x:00004496                 xor     ecx, eax
.text$x:00004498                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000449D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:000044A2                 jmp     ___CxxFrameHandler3
.text$x:000044A2 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000044A2
.text$x:000044A2 ; ---------------------------------------------------------------------------
.text$x:000044A7                 align 4
.text$x:000044A7 _text$x         ends
.text$x:000044A7
.text$mn:000044A8 ; ===========================================================================
.text$mn:000044A8
.text$mn:000044A8 ; Segment type: Pure code
.text$mn:000044A8 ; Segment permissions: Read/Execute
.text$mn:000044A8 _text$mn        segment para public 'CODE' use32
.text$mn:000044A8                 assume cs:_text$mn
.text$mn:000044A8                 ;org 44A8h
.text$mn:000044A8 ; COMDAT (pick any)
.text$mn:000044A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044A8
.text$mn:000044A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000044A8
.text$mn:000044A8 ; Attributes: bp-based frame
.text$mn:000044A8
.text$mn:000044A8 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000044A8                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000044A8 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000044A8                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:000044A8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:000044A8
.text$mn:000044A8 var_10          = dword ptr -10h
.text$mn:000044A8 var_C           = dword ptr -0Ch
.text$mn:000044A8 var_4           = dword ptr -4
.text$mn:000044A8
.text$mn:000044A8                 push    ebp
.text$mn:000044A9                 mov     ebp, esp
.text$mn:000044AB                 push    0FFFFFFFFh
.text$mn:000044AD                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000044B2                 mov     eax, large fs:0
.text$mn:000044B8                 push    eax
.text$mn:000044B9                 push    ecx
.text$mn:000044BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000044BF                 xor     eax, ebp
.text$mn:000044C1                 push    eax
.text$mn:000044C2                 lea     eax, [ebp+var_C]
.text$mn:000044C5                 mov     large fs:0, eax
.text$mn:000044CB                 mov     [ebp+var_10], ecx
.text$mn:000044CE                 mov     [ebp+var_4], 0
.text$mn:000044D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000044DC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000044DF                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000044E4                 mov     ecx, [ebp+var_C]
.text$mn:000044E7                 mov     large fs:0, ecx
.text$mn:000044EE                 pop     ecx
.text$mn:000044EF                 mov     esp, ebp
.text$mn:000044F1                 pop     ebp
.text$mn:000044F2                 retn
.text$mn:000044F2 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000044F2
.text$mn:000044F2 ; ---------------------------------------------------------------------------
.text$mn:000044F3                 align 4
.text$mn:000044F3 _text$mn        ends
.text$mn:000044F3
.text$x:000044F4 ; ===========================================================================
.text$x:000044F4
.text$x:000044F4 ; Segment type: Pure code
.text$x:000044F4 ; Segment permissions: Read/Execute
.text$x:000044F4 _text$x         segment para public 'CODE' use32
.text$x:000044F4                 assume cs:_text$x
.text$x:000044F4                 ;org 44F4h
.text$x:000044F4 ; COMDAT (pick associative to section at 44A8)
.text$x:000044F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000044F4
.text$x:000044F4 ; =============== S U B R O U T I N E =======================================
.text$x:000044F4
.text$x:000044F4
.text$x:000044F4 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000044F4                                         ; DATA XREF: .xdata$x:00007D74o
.text$x:000044F4                 mov     ecx, [ebp-10h]  ; this
.text$x:000044F7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000044F7 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000044F7
.text$x:000044FC
.text$x:000044FC ; =============== S U B R O U T I N E =======================================
.text$x:000044FC
.text$x:000044FC
.text$x:000044FC __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000044FC                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000044FC
.text$x:000044FC arg_4           = dword ptr  8
.text$x:000044FC
.text$x:000044FC                 mov     edx, [esp+arg_4]
.text$x:00004500                 lea     eax, [edx+0Ch]
.text$x:00004503                 mov     ecx, [edx-8]
.text$x:00004506                 xor     ecx, eax
.text$x:00004508                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000450D                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00004512                 jmp     ___CxxFrameHandler3
.text$x:00004512 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00004512
.text$x:00004512 ; ---------------------------------------------------------------------------
.text$x:00004517                 align 4
.text$x:00004517 _text$x         ends
.text$x:00004517
.text$mn:00004518 ; ===========================================================================
.text$mn:00004518
.text$mn:00004518 ; Segment type: Pure code
.text$mn:00004518 ; Segment permissions: Read/Execute
.text$mn:00004518 _text$mn        segment para public 'CODE' use32
.text$mn:00004518                 assume cs:_text$mn
.text$mn:00004518                 ;org 4518h
.text$mn:00004518 ; COMDAT (pick any)
.text$mn:00004518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004518
.text$mn:00004518 ; =============== S U B R O U T I N E =======================================
.text$mn:00004518
.text$mn:00004518 ; Attributes: bp-based frame
.text$mn:00004518
.text$mn:00004518 ; public: __thiscall std::_Yarn<char>::~_Yarn<char>(void)
.text$mn:00004518                 public ??1?$_Yarn@D@std@@QAE@XZ
.text$mn:00004518 ??1?$_Yarn@D@std@@QAE@XZ proc near      ; CODE XREF: __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1+6j
.text$mn:00004518                                         ; __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2+6j ...
.text$mn:00004518
.text$mn:00004518 var_4           = dword ptr -4
.text$mn:00004518
.text$mn:00004518                 push    ebp
.text$mn:00004519                 mov     ebp, esp
.text$mn:0000451B                 push    ecx
.text$mn:0000451C                 mov     [ebp+var_4], ecx
.text$mn:0000451F                 mov     ecx, [ebp+var_4]
.text$mn:00004522                 call    ?_Tidy@?$_Yarn@D@std@@AAEXXZ ; std::_Yarn<char>::_Tidy(void)
.text$mn:00004527                 mov     esp, ebp
.text$mn:00004529                 pop     ebp
.text$mn:0000452A                 retn
.text$mn:0000452A ??1?$_Yarn@D@std@@QAE@XZ endp
.text$mn:0000452A
.text$mn:0000452A ; ---------------------------------------------------------------------------
.text$mn:0000452B                 align 4
.text$mn:0000452B _text$mn        ends
.text$mn:0000452B
.text$mn:0000452C ; ===========================================================================
.text$mn:0000452C
.text$mn:0000452C ; Segment type: Pure code
.text$mn:0000452C ; Segment permissions: Read/Execute
.text$mn:0000452C _text$mn        segment para public 'CODE' use32
.text$mn:0000452C                 assume cs:_text$mn
.text$mn:0000452C                 ;org 452Ch
.text$mn:0000452C ; COMDAT (pick any)
.text$mn:0000452C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000452C
.text$mn:0000452C ; =============== S U B R O U T I N E =======================================
.text$mn:0000452C
.text$mn:0000452C ; Attributes: bp-based frame
.text$mn:0000452C
.text$mn:0000452C ; public: __thiscall std::_Yarn<wchar_t>::~_Yarn<wchar_t>(void)
.text$mn:0000452C                 public ??1?$_Yarn@_W@std@@QAE@XZ
.text$mn:0000452C ??1?$_Yarn@_W@std@@QAE@XZ proc near     ; CODE XREF: __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3+6j
.text$mn:0000452C                                         ; __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4+6j ...
.text$mn:0000452C
.text$mn:0000452C var_4           = dword ptr -4
.text$mn:0000452C
.text$mn:0000452C                 push    ebp
.text$mn:0000452D                 mov     ebp, esp
.text$mn:0000452F                 push    ecx
.text$mn:00004530                 mov     [ebp+var_4], ecx
.text$mn:00004533                 mov     ecx, [ebp+var_4]
.text$mn:00004536                 call    ?_Tidy@?$_Yarn@_W@std@@AAEXXZ ; std::_Yarn<wchar_t>::_Tidy(void)
.text$mn:0000453B                 mov     esp, ebp
.text$mn:0000453D                 pop     ebp
.text$mn:0000453E                 retn
.text$mn:0000453E ??1?$_Yarn@_W@std@@QAE@XZ endp
.text$mn:0000453E
.text$mn:0000453E ; ---------------------------------------------------------------------------
.text$mn:0000453F                 align 10h
.text$mn:0000453F _text$mn        ends
.text$mn:0000453F
.text$mn:00004540 ; ===========================================================================
.text$mn:00004540
.text$mn:00004540 ; Segment type: Pure code
.text$mn:00004540 ; Segment permissions: Read/Execute
.text$mn:00004540 _text$mn        segment para public 'CODE' use32
.text$mn:00004540                 assume cs:_text$mn
.text$mn:00004540                 ;org 4540h
.text$mn:00004540 ; COMDAT (pick any)
.text$mn:00004540                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004540
.text$mn:00004540 ; =============== S U B R O U T I N E =======================================
.text$mn:00004540
.text$mn:00004540 ; Attributes: bp-based frame
.text$mn:00004540
.text$mn:00004540 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00004540                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00004540 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00004540                                         ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+FFp
.text$mn:00004540                                         ; TiXmlBaseA::GetEntity(char const *,char *)+1C8p ...
.text$mn:00004540
.text$mn:00004540 var_10          = dword ptr -10h
.text$mn:00004540 var_C           = dword ptr -0Ch
.text$mn:00004540 var_4           = dword ptr -4
.text$mn:00004540
.text$mn:00004540                 push    ebp
.text$mn:00004541                 mov     ebp, esp
.text$mn:00004543                 push    0FFFFFFFFh
.text$mn:00004545                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000454A                 mov     eax, large fs:0
.text$mn:00004550                 push    eax
.text$mn:00004551                 push    ecx
.text$mn:00004552                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004557                 xor     eax, ebp
.text$mn:00004559                 push    eax
.text$mn:0000455A                 lea     eax, [ebp+var_C]
.text$mn:0000455D                 mov     large fs:0, eax
.text$mn:00004563                 mov     [ebp+var_10], ecx
.text$mn:00004566                 mov     [ebp+var_4], 0
.text$mn:0000456D                 push    0               ; Size
.text$mn:0000456F                 push    1               ; char
.text$mn:00004571                 mov     ecx, [ebp+var_10]
.text$mn:00004574                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004579                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004580                 mov     ecx, [ebp+var_10]
.text$mn:00004583                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00004588                 mov     ecx, [ebp+var_C]
.text$mn:0000458B                 mov     large fs:0, ecx
.text$mn:00004592                 pop     ecx
.text$mn:00004593                 mov     esp, ebp
.text$mn:00004595                 pop     ebp
.text$mn:00004596                 retn
.text$mn:00004596 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00004596
.text$mn:00004596 ; ---------------------------------------------------------------------------
.text$mn:00004597                 align 4
.text$mn:00004597 _text$mn        ends
.text$mn:00004597
.text$x:00004598 ; ===========================================================================
.text$x:00004598
.text$x:00004598 ; Segment type: Pure code
.text$x:00004598 ; Segment permissions: Read/Execute
.text$x:00004598 _text$x         segment para public 'CODE' use32
.text$x:00004598                 assume cs:_text$x
.text$x:00004598                 ;org 4598h
.text$x:00004598 ; COMDAT (pick associative to section at 4540)
.text$x:00004598                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004598
.text$x:00004598 ; =============== S U B R O U T I N E =======================================
.text$x:00004598
.text$x:00004598
.text$x:00004598 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00004598                                         ; DATA XREF: .xdata$x:00007EA8o
.text$x:00004598                 mov     ecx, [ebp-10h]
.text$x:0000459B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000459B __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000459B
.text$x:000045A0
.text$x:000045A0 ; =============== S U B R O U T I N E =======================================
.text$x:000045A0
.text$x:000045A0
.text$x:000045A0 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000045A0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000045A0
.text$x:000045A0 arg_4           = dword ptr  8
.text$x:000045A0
.text$x:000045A0                 mov     edx, [esp+arg_4]
.text$x:000045A4                 lea     eax, [edx+0Ch]
.text$x:000045A7                 mov     ecx, [edx-8]
.text$x:000045AA                 xor     ecx, eax
.text$x:000045AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000045B1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000045B6                 jmp     ___CxxFrameHandler3
.text$x:000045B6 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000045B6
.text$x:000045B6 ; ---------------------------------------------------------------------------
.text$x:000045BB                 align 4
.text$x:000045BB _text$x         ends
.text$x:000045BB
.text$mn:000045BC ; ===========================================================================
.text$mn:000045BC
.text$mn:000045BC ; Segment type: Pure code
.text$mn:000045BC ; Segment permissions: Read/Execute
.text$mn:000045BC _text$mn        segment para public 'CODE' use32
.text$mn:000045BC                 assume cs:_text$mn
.text$mn:000045BC                 ;org 45BCh
.text$mn:000045BC ; COMDAT (pick any)
.text$mn:000045BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045BC
.text$mn:000045BC ; =============== S U B R O U T I N E =======================================
.text$mn:000045BC
.text$mn:000045BC ; Attributes: bp-based frame
.text$mn:000045BC
.text$mn:000045BC ; protected: virtual __thiscall std::ctype<char>::~ctype<char>(void)
.text$mn:000045BC                 public ??1?$ctype@D@std@@MAE@XZ
.text$mn:000045BC ??1?$ctype@D@std@@MAE@XZ proc near      ; CODE XREF: std::ctype<char>::`scalar deleting destructor'(uint)+Ap
.text$mn:000045BC
.text$mn:000045BC var_10          = dword ptr -10h
.text$mn:000045BC var_C           = dword ptr -0Ch
.text$mn:000045BC var_4           = dword ptr -4
.text$mn:000045BC
.text$mn:000045BC                 push    ebp
.text$mn:000045BD                 mov     ebp, esp
.text$mn:000045BF                 push    0FFFFFFFFh
.text$mn:000045C1                 push    offset __ehhandler$??1?$ctype@D@std@@MAE@XZ
.text$mn:000045C6                 mov     eax, large fs:0
.text$mn:000045CC                 push    eax
.text$mn:000045CD                 push    ecx
.text$mn:000045CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000045D3                 xor     eax, ebp
.text$mn:000045D5                 push    eax
.text$mn:000045D6                 lea     eax, [ebp+var_C]
.text$mn:000045D9                 mov     large fs:0, eax
.text$mn:000045DF                 mov     [ebp+var_10], ecx
.text$mn:000045E2                 mov     eax, [ebp+var_10]
.text$mn:000045E5                 mov     dword ptr [eax], offset ??_7?$ctype@D@std@@6B@ ; const std::ctype<char>::`vftable'
.text$mn:000045EB                 mov     [ebp+var_4], 0
.text$mn:000045F2                 mov     ecx, [ebp+var_10]
.text$mn:000045F5                 call    ?_Tidy@?$ctype@D@std@@IAEXXZ ; std::ctype<char>::_Tidy(void)
.text$mn:000045FA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004601                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004604                 call    ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base(void)
.text$mn:00004609                 mov     ecx, [ebp+var_C]
.text$mn:0000460C                 mov     large fs:0, ecx
.text$mn:00004613                 pop     ecx
.text$mn:00004614                 mov     esp, ebp
.text$mn:00004616                 pop     ebp
.text$mn:00004617                 retn
.text$mn:00004617 ??1?$ctype@D@std@@MAE@XZ endp
.text$mn:00004617
.text$mn:00004617 _text$mn        ends
.text$mn:00004617
.text$x:00004618 ; ===========================================================================
.text$x:00004618
.text$x:00004618 ; Segment type: Pure code
.text$x:00004618 ; Segment permissions: Read/Execute
.text$x:00004618 _text$x         segment para public 'CODE' use32
.text$x:00004618                 assume cs:_text$x
.text$x:00004618                 ;org 4618h
.text$x:00004618 ; COMDAT (pick associative to section at 45BC)
.text$x:00004618                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004618
.text$x:00004618 ; =============== S U B R O U T I N E =======================================
.text$x:00004618
.text$x:00004618
.text$x:00004618 __unwindfunclet$??1?$ctype@D@std@@MAE@XZ$0 proc near
.text$x:00004618                                         ; DATA XREF: .xdata$x:0000820Co
.text$x:00004618                 mov     ecx, [ebp-10h]  ; this
.text$x:0000461B                 jmp     ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base(void)
.text$x:0000461B __unwindfunclet$??1?$ctype@D@std@@MAE@XZ$0 endp
.text$x:0000461B
.text$x:00004620
.text$x:00004620 ; =============== S U B R O U T I N E =======================================
.text$x:00004620
.text$x:00004620
.text$x:00004620 __ehhandler$??1?$ctype@D@std@@MAE@XZ proc near
.text$x:00004620                                         ; DATA XREF: std::ctype<char>::~ctype<char>(void)+5o
.text$x:00004620
.text$x:00004620 arg_4           = dword ptr  8
.text$x:00004620
.text$x:00004620                 mov     edx, [esp+arg_4]
.text$x:00004624                 lea     eax, [edx+0Ch]
.text$x:00004627                 mov     ecx, [edx-8]
.text$x:0000462A                 xor     ecx, eax
.text$x:0000462C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004631                 mov     eax, offset __ehfuncinfo$??1?$ctype@D@std@@MAE@XZ
.text$x:00004636                 jmp     ___CxxFrameHandler3
.text$x:00004636 __ehhandler$??1?$ctype@D@std@@MAE@XZ endp
.text$x:00004636
.text$x:00004636 ; ---------------------------------------------------------------------------
.text$x:0000463B                 align 4
.text$x:0000463B _text$x         ends
.text$x:0000463B
.text$mn:0000463C ; ===========================================================================
.text$mn:0000463C
.text$mn:0000463C ; Segment type: Pure code
.text$mn:0000463C ; Segment permissions: Read/Execute
.text$mn:0000463C _text$mn        segment para public 'CODE' use32
.text$mn:0000463C                 assume cs:_text$mn
.text$mn:0000463C                 ;org 463Ch
.text$mn:0000463C ; COMDAT (pick any)
.text$mn:0000463C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000463C
.text$mn:0000463C ; =============== S U B R O U T I N E =======================================
.text$mn:0000463C
.text$mn:0000463C ; Attributes: bp-based frame
.text$mn:0000463C
.text$mn:0000463C ; _DWORD __thiscall TiXmlAttributeA::~TiXmlAttributeA(TiXmlAttributeA *__hidden this)
.text$mn:0000463C                 public ??1TiXmlAttributeA@@UAE@XZ
.text$mn:0000463C ??1TiXmlAttributeA@@UAE@XZ proc near    ; CODE XREF: TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+1A9p
.text$mn:0000463C                                         ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+21Cp ...
.text$mn:0000463C
.text$mn:0000463C var_10          = dword ptr -10h
.text$mn:0000463C var_C           = dword ptr -0Ch
.text$mn:0000463C var_4           = dword ptr -4
.text$mn:0000463C
.text$mn:0000463C                 push    ebp
.text$mn:0000463D                 mov     ebp, esp
.text$mn:0000463F                 push    0FFFFFFFFh
.text$mn:00004641                 push    offset __ehhandler$??1TiXmlAttributeA@@UAE@XZ
.text$mn:00004646                 mov     eax, large fs:0
.text$mn:0000464C                 push    eax
.text$mn:0000464D                 push    ecx
.text$mn:0000464E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004653                 xor     eax, ebp
.text$mn:00004655                 push    eax
.text$mn:00004656                 lea     eax, [ebp+var_C]
.text$mn:00004659                 mov     large fs:0, eax
.text$mn:0000465F                 mov     [ebp+var_10], ecx
.text$mn:00004662                 mov     [ebp+var_4], 2
.text$mn:00004669                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000466D                 mov     ecx, [ebp+var_10]
.text$mn:00004670                 add     ecx, 2Ch ; ','
.text$mn:00004673                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00004678                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000467C                 mov     ecx, [ebp+var_10]
.text$mn:0000467F                 add     ecx, 10h
.text$mn:00004682                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00004687                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000468E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004691                 call    ??1TiXmlBaseA@@UAE@XZ ; TiXmlBaseA::~TiXmlBaseA(void)
.text$mn:00004696                 mov     ecx, [ebp+var_C]
.text$mn:00004699                 mov     large fs:0, ecx
.text$mn:000046A0                 pop     ecx
.text$mn:000046A1                 mov     esp, ebp
.text$mn:000046A3                 pop     ebp
.text$mn:000046A4                 retn
.text$mn:000046A4 ??1TiXmlAttributeA@@UAE@XZ endp
.text$mn:000046A4
.text$mn:000046A4 ; ---------------------------------------------------------------------------
.text$mn:000046A5                 align 4
.text$mn:000046A5 _text$mn        ends
.text$mn:000046A5
.text$x:000046A8 ; ===========================================================================
.text$x:000046A8
.text$x:000046A8 ; Segment type: Pure code
.text$x:000046A8 ; Segment permissions: Read/Execute
.text$x:000046A8 _text$x         segment para public 'CODE' use32
.text$x:000046A8                 assume cs:_text$x
.text$x:000046A8                 ;org 46A8h
.text$x:000046A8 ; COMDAT (pick associative to section at 463C)
.text$x:000046A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000046A8
.text$x:000046A8 ; =============== S U B R O U T I N E =======================================
.text$x:000046A8
.text$x:000046A8
.text$x:000046A8 __unwindfunclet$??1TiXmlAttributeA@@UAE@XZ$0 proc near
.text$x:000046A8                                         ; DATA XREF: .xdata$x:000089A8o
.text$x:000046A8                 mov     ecx, [ebp-10h]  ; this
.text$x:000046AB                 jmp     ??1TiXmlBaseA@@UAE@XZ ; TiXmlBaseA::~TiXmlBaseA(void)
.text$x:000046AB __unwindfunclet$??1TiXmlAttributeA@@UAE@XZ$0 endp
.text$x:000046AB
.text$x:000046B0
.text$x:000046B0 ; =============== S U B R O U T I N E =======================================
.text$x:000046B0
.text$x:000046B0
.text$x:000046B0 __unwindfunclet$??1TiXmlAttributeA@@UAE@XZ$1 proc near
.text$x:000046B0                                         ; DATA XREF: .xdata$x:000089B0o
.text$x:000046B0                 mov     ecx, [ebp-10h]
.text$x:000046B3                 add     ecx, 10h
.text$x:000046B6                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000046B6 __unwindfunclet$??1TiXmlAttributeA@@UAE@XZ$1 endp
.text$x:000046B6
.text$x:000046BB
.text$x:000046BB ; =============== S U B R O U T I N E =======================================
.text$x:000046BB
.text$x:000046BB
.text$x:000046BB __unwindfunclet$??1TiXmlAttributeA@@UAE@XZ$2 proc near
.text$x:000046BB                                         ; DATA XREF: .xdata$x:000089B8o
.text$x:000046BB                 mov     ecx, [ebp-10h]
.text$x:000046BE                 add     ecx, 2Ch ; ','
.text$x:000046C1                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000046C1 __unwindfunclet$??1TiXmlAttributeA@@UAE@XZ$2 endp
.text$x:000046C1
.text$x:000046C6
.text$x:000046C6 ; =============== S U B R O U T I N E =======================================
.text$x:000046C6
.text$x:000046C6
.text$x:000046C6 __ehhandler$??1TiXmlAttributeA@@UAE@XZ proc near
.text$x:000046C6                                         ; DATA XREF: TiXmlAttributeA::~TiXmlAttributeA(void)+5o
.text$x:000046C6
.text$x:000046C6 arg_4           = dword ptr  8
.text$x:000046C6
.text$x:000046C6                 mov     edx, [esp+arg_4]
.text$x:000046CA                 lea     eax, [edx+0Ch]
.text$x:000046CD                 mov     ecx, [edx-8]
.text$x:000046D0                 xor     ecx, eax
.text$x:000046D2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000046D7                 mov     eax, offset __ehfuncinfo$??1TiXmlAttributeA@@UAE@XZ
.text$x:000046DC                 jmp     ___CxxFrameHandler3
.text$x:000046DC __ehhandler$??1TiXmlAttributeA@@UAE@XZ endp
.text$x:000046DC
.text$x:000046DC ; ---------------------------------------------------------------------------
.text$x:000046E1                 align 4
.text$x:000046E1 _text$x         ends
.text$x:000046E1
.text$mn:000046E4 ; ===========================================================================
.text$mn:000046E4
.text$mn:000046E4 ; Segment type: Pure code
.text$mn:000046E4 ; Segment permissions: Read/Execute
.text$mn:000046E4 _text$mn        segment para public 'CODE' use32
.text$mn:000046E4                 assume cs:_text$mn
.text$mn:000046E4                 ;org 46E4h
.text$mn:000046E4 ; COMDAT (pick any)
.text$mn:000046E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046E4
.text$mn:000046E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000046E4
.text$mn:000046E4 ; Attributes: bp-based frame
.text$mn:000046E4
.text$mn:000046E4 ; _DWORD __thiscall TiXmlBaseA::~TiXmlBaseA(TiXmlBaseA *__hidden this)
.text$mn:000046E4                 public ??1TiXmlBaseA@@UAE@XZ
.text$mn:000046E4 ??1TiXmlBaseA@@UAE@XZ proc near         ; CODE XREF: __unwindfunclet$??0TiXmlAttributeA@@QAE@XZ$0+3j
.text$mn:000046E4                                         ; TiXmlAttributeA::~TiXmlAttributeA(void)+55p ...
.text$mn:000046E4
.text$mn:000046E4 var_4           = dword ptr -4
.text$mn:000046E4
.text$mn:000046E4                 push    ebp
.text$mn:000046E5                 mov     ebp, esp
.text$mn:000046E7                 push    ecx
.text$mn:000046E8                 mov     [ebp+var_4], ecx
.text$mn:000046EB                 mov     eax, [ebp+var_4]
.text$mn:000046EE                 mov     dword ptr [eax], offset ??_7TiXmlBaseA@@6B@ ; const TiXmlBaseA::`vftable'
.text$mn:000046F4                 mov     esp, ebp
.text$mn:000046F6                 pop     ebp
.text$mn:000046F7                 retn
.text$mn:000046F7 ??1TiXmlBaseA@@UAE@XZ endp
.text$mn:000046F7
.text$mn:000046F7 _text$mn        ends
.text$mn:000046F7
.text$mn:000046F8 ; ===========================================================================
.text$mn:000046F8
.text$mn:000046F8 ; Segment type: Pure code
.text$mn:000046F8 ; Segment permissions: Read/Execute
.text$mn:000046F8 _text$mn        segment para public 'CODE' use32
.text$mn:000046F8                 assume cs:_text$mn
.text$mn:000046F8                 ;org 46F8h
.text$mn:000046F8 ; COMDAT (pick any)
.text$mn:000046F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046F8
.text$mn:000046F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046F8
.text$mn:000046F8 ; Attributes: bp-based frame
.text$mn:000046F8
.text$mn:000046F8 ; _DWORD __thiscall TiXmlCommentA::~TiXmlCommentA(TiXmlCommentA *__hidden this)
.text$mn:000046F8                 public ??1TiXmlCommentA@@UAE@XZ
.text$mn:000046F8 ??1TiXmlCommentA@@UAE@XZ proc near      ; CODE XREF: TiXmlCommentA::`scalar deleting destructor'(uint)+Ap
.text$mn:000046F8
.text$mn:000046F8 var_10          = dword ptr -10h
.text$mn:000046F8 var_C           = dword ptr -0Ch
.text$mn:000046F8 var_4           = dword ptr -4
.text$mn:000046F8
.text$mn:000046F8                 push    ebp
.text$mn:000046F9                 mov     ebp, esp
.text$mn:000046FB                 push    0FFFFFFFFh
.text$mn:000046FD                 push    offset __ehhandler$??1TiXmlCommentA@@UAE@XZ
.text$mn:00004702                 mov     eax, large fs:0
.text$mn:00004708                 push    eax
.text$mn:00004709                 push    ecx
.text$mn:0000470A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000470F                 xor     eax, ebp
.text$mn:00004711                 push    eax
.text$mn:00004712                 lea     eax, [ebp+var_C]
.text$mn:00004715                 mov     large fs:0, eax
.text$mn:0000471B                 mov     [ebp+var_10], ecx
.text$mn:0000471E                 mov     eax, [ebp+var_10]
.text$mn:00004721                 mov     dword ptr [eax], offset ??_7TiXmlCommentA@@6B@ ; const TiXmlCommentA::`vftable'
.text$mn:00004727                 mov     [ebp+var_4], 0
.text$mn:0000472E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004735                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004738                 call    ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$mn:0000473D                 mov     ecx, [ebp+var_C]
.text$mn:00004740                 mov     large fs:0, ecx
.text$mn:00004747                 pop     ecx
.text$mn:00004748                 mov     esp, ebp
.text$mn:0000474A                 pop     ebp
.text$mn:0000474B                 retn
.text$mn:0000474B ??1TiXmlCommentA@@UAE@XZ endp
.text$mn:0000474B
.text$mn:0000474B _text$mn        ends
.text$mn:0000474B
.text$x:0000474C ; ===========================================================================
.text$x:0000474C
.text$x:0000474C ; Segment type: Pure code
.text$x:0000474C ; Segment permissions: Read/Execute
.text$x:0000474C _text$x         segment para public 'CODE' use32
.text$x:0000474C                 assume cs:_text$x
.text$x:0000474C                 ;org 474Ch
.text$x:0000474C ; COMDAT (pick associative to section at 46F8)
.text$x:0000474C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000474C
.text$x:0000474C ; =============== S U B R O U T I N E =======================================
.text$x:0000474C
.text$x:0000474C
.text$x:0000474C __unwindfunclet$??1TiXmlCommentA@@UAE@XZ$0 proc near
.text$x:0000474C                                         ; DATA XREF: .xdata$x:00008A10o
.text$x:0000474C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000474F                 jmp     ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$x:0000474F __unwindfunclet$??1TiXmlCommentA@@UAE@XZ$0 endp
.text$x:0000474F
.text$x:00004754
.text$x:00004754 ; =============== S U B R O U T I N E =======================================
.text$x:00004754
.text$x:00004754
.text$x:00004754 __ehhandler$??1TiXmlCommentA@@UAE@XZ proc near
.text$x:00004754                                         ; DATA XREF: TiXmlCommentA::~TiXmlCommentA(void)+5o
.text$x:00004754
.text$x:00004754 arg_4           = dword ptr  8
.text$x:00004754
.text$x:00004754                 mov     edx, [esp+arg_4]
.text$x:00004758                 lea     eax, [edx+0Ch]
.text$x:0000475B                 mov     ecx, [edx-8]
.text$x:0000475E                 xor     ecx, eax
.text$x:00004760                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004765                 mov     eax, offset __ehfuncinfo$??1TiXmlCommentA@@UAE@XZ
.text$x:0000476A                 jmp     ___CxxFrameHandler3
.text$x:0000476A __ehhandler$??1TiXmlCommentA@@UAE@XZ endp
.text$x:0000476A
.text$x:0000476A ; ---------------------------------------------------------------------------
.text$x:0000476F                 align 10h
.text$x:0000476F _text$x         ends
.text$x:0000476F
.text$mn:00004770 ; ===========================================================================
.text$mn:00004770
.text$mn:00004770 ; Segment type: Pure code
.text$mn:00004770 ; Segment permissions: Read/Execute
.text$mn:00004770 _text$mn        segment para public 'CODE' use32
.text$mn:00004770                 assume cs:_text$mn
.text$mn:00004770                 ;org 4770h
.text$mn:00004770 ; COMDAT (pick any)
.text$mn:00004770                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004770
.text$mn:00004770 ; =============== S U B R O U T I N E =======================================
.text$mn:00004770
.text$mn:00004770 ; Attributes: bp-based frame
.text$mn:00004770
.text$mn:00004770 ; _DWORD __thiscall TiXmlDeclarationA::~TiXmlDeclarationA(TiXmlDeclarationA *__hidden this)
.text$mn:00004770                 public ??1TiXmlDeclarationA@@UAE@XZ
.text$mn:00004770 ??1TiXmlDeclarationA@@UAE@XZ proc near  ; CODE XREF: TiXmlDeclarationA::`scalar deleting destructor'(uint)+Ap
.text$mn:00004770
.text$mn:00004770 var_10          = dword ptr -10h
.text$mn:00004770 var_C           = dword ptr -0Ch
.text$mn:00004770 var_4           = dword ptr -4
.text$mn:00004770
.text$mn:00004770                 push    ebp
.text$mn:00004771                 mov     ebp, esp
.text$mn:00004773                 push    0FFFFFFFFh
.text$mn:00004775                 push    offset __ehhandler$??1TiXmlDeclarationA@@UAE@XZ
.text$mn:0000477A                 mov     eax, large fs:0
.text$mn:00004780                 push    eax
.text$mn:00004781                 push    ecx
.text$mn:00004782                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004787                 xor     eax, ebp
.text$mn:00004789                 push    eax
.text$mn:0000478A                 lea     eax, [ebp+var_C]
.text$mn:0000478D                 mov     large fs:0, eax
.text$mn:00004793                 mov     [ebp+var_10], ecx
.text$mn:00004796                 mov     eax, [ebp+var_10]
.text$mn:00004799                 mov     dword ptr [eax], offset ??_7TiXmlDeclarationA@@6B@ ; const TiXmlDeclarationA::`vftable'
.text$mn:0000479F                 mov     [ebp+var_4], 3
.text$mn:000047A6                 mov     byte ptr [ebp+var_4], 2
.text$mn:000047AA                 mov     ecx, [ebp+var_10]
.text$mn:000047AD                 add     ecx, 7Ch ; '|'
.text$mn:000047B0                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000047B5                 mov     byte ptr [ebp+var_4], 1
.text$mn:000047B9                 mov     ecx, [ebp+var_10]
.text$mn:000047BC                 add     ecx, 60h ; '`'
.text$mn:000047BF                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000047C4                 mov     byte ptr [ebp+var_4], 0
.text$mn:000047C8                 mov     ecx, [ebp+var_10]
.text$mn:000047CB                 add     ecx, 44h ; 'D'
.text$mn:000047CE                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000047D3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000047DA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000047DD                 call    ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$mn:000047E2                 mov     ecx, [ebp+var_C]
.text$mn:000047E5                 mov     large fs:0, ecx
.text$mn:000047EC                 pop     ecx
.text$mn:000047ED                 mov     esp, ebp
.text$mn:000047EF                 pop     ebp
.text$mn:000047F0                 retn
.text$mn:000047F0 ??1TiXmlDeclarationA@@UAE@XZ endp
.text$mn:000047F0
.text$mn:000047F0 ; ---------------------------------------------------------------------------
.text$mn:000047F1                 align 4
.text$mn:000047F1 _text$mn        ends
.text$mn:000047F1
.text$x:000047F4 ; ===========================================================================
.text$x:000047F4
.text$x:000047F4 ; Segment type: Pure code
.text$x:000047F4 ; Segment permissions: Read/Execute
.text$x:000047F4 _text$x         segment para public 'CODE' use32
.text$x:000047F4                 assume cs:_text$x
.text$x:000047F4                 ;org 47F4h
.text$x:000047F4 ; COMDAT (pick associative to section at 4770)
.text$x:000047F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000047F4
.text$x:000047F4 ; =============== S U B R O U T I N E =======================================
.text$x:000047F4
.text$x:000047F4
.text$x:000047F4 __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$0 proc near
.text$x:000047F4                                         ; DATA XREF: .xdata$x:00008AD8o
.text$x:000047F4                 mov     ecx, [ebp-10h]  ; this
.text$x:000047F7                 jmp     ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$x:000047F7 __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$0 endp
.text$x:000047F7
.text$x:000047FC
.text$x:000047FC ; =============== S U B R O U T I N E =======================================
.text$x:000047FC
.text$x:000047FC
.text$x:000047FC __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$1 proc near
.text$x:000047FC                                         ; DATA XREF: .xdata$x:00008AE0o
.text$x:000047FC                 mov     ecx, [ebp-10h]
.text$x:000047FF                 add     ecx, 44h ; 'D'
.text$x:00004802                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00004802 __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$1 endp
.text$x:00004802
.text$x:00004807
.text$x:00004807 ; =============== S U B R O U T I N E =======================================
.text$x:00004807
.text$x:00004807
.text$x:00004807 __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$2 proc near
.text$x:00004807                                         ; DATA XREF: .xdata$x:00008AE8o
.text$x:00004807                 mov     ecx, [ebp-10h]
.text$x:0000480A                 add     ecx, 60h ; '`'
.text$x:0000480D                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000480D __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$2 endp
.text$x:0000480D
.text$x:00004812
.text$x:00004812 ; =============== S U B R O U T I N E =======================================
.text$x:00004812
.text$x:00004812
.text$x:00004812 __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$3 proc near
.text$x:00004812                                         ; DATA XREF: .xdata$x:00008AF0o
.text$x:00004812                 mov     ecx, [ebp-10h]
.text$x:00004815                 add     ecx, 7Ch ; '|'
.text$x:00004818                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00004818 __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$3 endp
.text$x:00004818
.text$x:0000481D
.text$x:0000481D ; =============== S U B R O U T I N E =======================================
.text$x:0000481D
.text$x:0000481D
.text$x:0000481D __ehhandler$??1TiXmlDeclarationA@@UAE@XZ proc near
.text$x:0000481D                                         ; DATA XREF: TiXmlDeclarationA::~TiXmlDeclarationA(void)+5o
.text$x:0000481D
.text$x:0000481D arg_4           = dword ptr  8
.text$x:0000481D
.text$x:0000481D                 mov     edx, [esp+arg_4]
.text$x:00004821                 lea     eax, [edx+0Ch]
.text$x:00004824                 mov     ecx, [edx-8]
.text$x:00004827                 xor     ecx, eax
.text$x:00004829                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000482E                 mov     eax, offset __ehfuncinfo$??1TiXmlDeclarationA@@UAE@XZ
.text$x:00004833                 jmp     ___CxxFrameHandler3
.text$x:00004833 __ehhandler$??1TiXmlDeclarationA@@UAE@XZ endp
.text$x:00004833
.text$x:00004833 _text$x         ends
.text$x:00004833
.text$mn:00004838 ; ===========================================================================
.text$mn:00004838
.text$mn:00004838 ; Segment type: Pure code
.text$mn:00004838 ; Segment permissions: Read/Execute
.text$mn:00004838 _text$mn        segment para public 'CODE' use32
.text$mn:00004838                 assume cs:_text$mn
.text$mn:00004838                 ;org 4838h
.text$mn:00004838 ; COMDAT (pick any)
.text$mn:00004838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004838
.text$mn:00004838 ; =============== S U B R O U T I N E =======================================
.text$mn:00004838
.text$mn:00004838 ; Attributes: bp-based frame
.text$mn:00004838
.text$mn:00004838 ; _DWORD __thiscall TiXmlTextA::~TiXmlTextA(TiXmlTextA *__hidden this)
.text$mn:00004838                 public ??1TiXmlTextA@@UAE@XZ
.text$mn:00004838 ??1TiXmlTextA@@UAE@XZ proc near         ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+13Cp
.text$mn:00004838                                         ; __unwindfunclet$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$0+3j ...
.text$mn:00004838
.text$mn:00004838 var_10          = dword ptr -10h
.text$mn:00004838 var_C           = dword ptr -0Ch
.text$mn:00004838 var_4           = dword ptr -4
.text$mn:00004838
.text$mn:00004838                 push    ebp
.text$mn:00004839                 mov     ebp, esp
.text$mn:0000483B                 push    0FFFFFFFFh
.text$mn:0000483D                 push    offset __ehhandler$??1TiXmlTextA@@UAE@XZ
.text$mn:00004842                 mov     eax, large fs:0
.text$mn:00004848                 push    eax
.text$mn:00004849                 push    ecx
.text$mn:0000484A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000484F                 xor     eax, ebp
.text$mn:00004851                 push    eax
.text$mn:00004852                 lea     eax, [ebp+var_C]
.text$mn:00004855                 mov     large fs:0, eax
.text$mn:0000485B                 mov     [ebp+var_10], ecx
.text$mn:0000485E                 mov     eax, [ebp+var_10]
.text$mn:00004861                 mov     dword ptr [eax], offset ??_7TiXmlTextA@@6B@ ; const TiXmlTextA::`vftable'
.text$mn:00004867                 mov     [ebp+var_4], 0
.text$mn:0000486E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004875                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004878                 call    ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$mn:0000487D                 mov     ecx, [ebp+var_C]
.text$mn:00004880                 mov     large fs:0, ecx
.text$mn:00004887                 pop     ecx
.text$mn:00004888                 mov     esp, ebp
.text$mn:0000488A                 pop     ebp
.text$mn:0000488B                 retn
.text$mn:0000488B ??1TiXmlTextA@@UAE@XZ endp
.text$mn:0000488B
.text$mn:0000488B _text$mn        ends
.text$mn:0000488B
.text$x:0000488C ; ===========================================================================
.text$x:0000488C
.text$x:0000488C ; Segment type: Pure code
.text$x:0000488C ; Segment permissions: Read/Execute
.text$x:0000488C _text$x         segment para public 'CODE' use32
.text$x:0000488C                 assume cs:_text$x
.text$x:0000488C                 ;org 488Ch
.text$x:0000488C ; COMDAT (pick associative to section at 4838)
.text$x:0000488C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000488C
.text$x:0000488C ; =============== S U B R O U T I N E =======================================
.text$x:0000488C
.text$x:0000488C
.text$x:0000488C __unwindfunclet$??1TiXmlTextA@@UAE@XZ$0 proc near
.text$x:0000488C                                         ; DATA XREF: .xdata$x:00008A68o
.text$x:0000488C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000488F                 jmp     ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$x:0000488F __unwindfunclet$??1TiXmlTextA@@UAE@XZ$0 endp
.text$x:0000488F
.text$x:00004894
.text$x:00004894 ; =============== S U B R O U T I N E =======================================
.text$x:00004894
.text$x:00004894
.text$x:00004894 __ehhandler$??1TiXmlTextA@@UAE@XZ proc near
.text$x:00004894                                         ; DATA XREF: TiXmlTextA::~TiXmlTextA(void)+5o
.text$x:00004894
.text$x:00004894 arg_4           = dword ptr  8
.text$x:00004894
.text$x:00004894                 mov     edx, [esp+arg_4]
.text$x:00004898                 lea     eax, [edx+0Ch]
.text$x:0000489B                 mov     ecx, [edx-8]
.text$x:0000489E                 xor     ecx, eax
.text$x:000048A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000048A5                 mov     eax, offset __ehfuncinfo$??1TiXmlTextA@@UAE@XZ
.text$x:000048AA                 jmp     ___CxxFrameHandler3
.text$x:000048AA __ehhandler$??1TiXmlTextA@@UAE@XZ endp
.text$x:000048AA
.text$x:000048AA ; ---------------------------------------------------------------------------
.text$x:000048AF                 align 10h
.text$x:000048AF _text$x         ends
.text$x:000048AF
.text$mn:000048B0 ; ===========================================================================
.text$mn:000048B0
.text$mn:000048B0 ; Segment type: Pure code
.text$mn:000048B0 ; Segment permissions: Read/Execute
.text$mn:000048B0 _text$mn        segment para public 'CODE' use32
.text$mn:000048B0                 assume cs:_text$mn
.text$mn:000048B0                 ;org 48B0h
.text$mn:000048B0 ; COMDAT (pick any)
.text$mn:000048B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048B0
.text$mn:000048B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000048B0
.text$mn:000048B0 ; Attributes: bp-based frame
.text$mn:000048B0
.text$mn:000048B0 ; _DWORD __thiscall TiXmlUnknownA::~TiXmlUnknownA(TiXmlUnknownA *__hidden this)
.text$mn:000048B0                 public ??1TiXmlUnknownA@@UAE@XZ
.text$mn:000048B0 ??1TiXmlUnknownA@@UAE@XZ proc near      ; CODE XREF: TiXmlUnknownA::`scalar deleting destructor'(uint)+Ap
.text$mn:000048B0
.text$mn:000048B0 var_10          = dword ptr -10h
.text$mn:000048B0 var_C           = dword ptr -0Ch
.text$mn:000048B0 var_4           = dword ptr -4
.text$mn:000048B0
.text$mn:000048B0                 push    ebp
.text$mn:000048B1                 mov     ebp, esp
.text$mn:000048B3                 push    0FFFFFFFFh
.text$mn:000048B5                 push    offset __ehhandler$??1TiXmlUnknownA@@UAE@XZ
.text$mn:000048BA                 mov     eax, large fs:0
.text$mn:000048C0                 push    eax
.text$mn:000048C1                 push    ecx
.text$mn:000048C2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000048C7                 xor     eax, ebp
.text$mn:000048C9                 push    eax
.text$mn:000048CA                 lea     eax, [ebp+var_C]
.text$mn:000048CD                 mov     large fs:0, eax
.text$mn:000048D3                 mov     [ebp+var_10], ecx
.text$mn:000048D6                 mov     eax, [ebp+var_10]
.text$mn:000048D9                 mov     dword ptr [eax], offset ??_7TiXmlUnknownA@@6B@ ; const TiXmlUnknownA::`vftable'
.text$mn:000048DF                 mov     [ebp+var_4], 0
.text$mn:000048E6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000048ED                 mov     ecx, [ebp+var_10] ; this
.text$mn:000048F0                 call    ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$mn:000048F5                 mov     ecx, [ebp+var_C]
.text$mn:000048F8                 mov     large fs:0, ecx
.text$mn:000048FF                 pop     ecx
.text$mn:00004900                 mov     esp, ebp
.text$mn:00004902                 pop     ebp
.text$mn:00004903                 retn
.text$mn:00004903 ??1TiXmlUnknownA@@UAE@XZ endp
.text$mn:00004903
.text$mn:00004903 _text$mn        ends
.text$mn:00004903
.text$x:00004904 ; ===========================================================================
.text$x:00004904
.text$x:00004904 ; Segment type: Pure code
.text$x:00004904 ; Segment permissions: Read/Execute
.text$x:00004904 _text$x         segment para public 'CODE' use32
.text$x:00004904                 assume cs:_text$x
.text$x:00004904                 ;org 4904h
.text$x:00004904 ; COMDAT (pick associative to section at 48B0)
.text$x:00004904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004904
.text$x:00004904 ; =============== S U B R O U T I N E =======================================
.text$x:00004904
.text$x:00004904
.text$x:00004904 __unwindfunclet$??1TiXmlUnknownA@@UAE@XZ$0 proc near
.text$x:00004904                                         ; DATA XREF: .xdata$x:00008B48o
.text$x:00004904                 mov     ecx, [ebp-10h]  ; this
.text$x:00004907                 jmp     ??1TiXmlNodeA@@UAE@XZ ; TiXmlNodeA::~TiXmlNodeA(void)
.text$x:00004907 __unwindfunclet$??1TiXmlUnknownA@@UAE@XZ$0 endp
.text$x:00004907
.text$x:0000490C
.text$x:0000490C ; =============== S U B R O U T I N E =======================================
.text$x:0000490C
.text$x:0000490C
.text$x:0000490C __ehhandler$??1TiXmlUnknownA@@UAE@XZ proc near
.text$x:0000490C                                         ; DATA XREF: TiXmlUnknownA::~TiXmlUnknownA(void)+5o
.text$x:0000490C
.text$x:0000490C arg_4           = dword ptr  8
.text$x:0000490C
.text$x:0000490C                 mov     edx, [esp+arg_4]
.text$x:00004910                 lea     eax, [edx+0Ch]
.text$x:00004913                 mov     ecx, [edx-8]
.text$x:00004916                 xor     ecx, eax
.text$x:00004918                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000491D                 mov     eax, offset __ehfuncinfo$??1TiXmlUnknownA@@UAE@XZ
.text$x:00004922                 jmp     ___CxxFrameHandler3
.text$x:00004922 __ehhandler$??1TiXmlUnknownA@@UAE@XZ endp
.text$x:00004922
.text$x:00004922 ; ---------------------------------------------------------------------------
.text$x:00004927                 align 4
.text$x:00004927 _text$x         ends
.text$x:00004927
.text$mn:00004928 ; ===========================================================================
.text$mn:00004928
.text$mn:00004928 ; Segment type: Pure code
.text$mn:00004928 ; Segment permissions: Read/Execute
.text$mn:00004928 _text$mn        segment para public 'CODE' use32
.text$mn:00004928                 assume cs:_text$mn
.text$mn:00004928                 ;org 4928h
.text$mn:00004928 ; COMDAT (pick any)
.text$mn:00004928                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004928
.text$mn:00004928 ; =============== S U B R O U T I N E =======================================
.text$mn:00004928
.text$mn:00004928 ; Attributes: bp-based frame
.text$mn:00004928
.text$mn:00004928 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00004928                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00004928 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00004928                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00004928                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00004928
.text$mn:00004928 var_4           = dword ptr -4
.text$mn:00004928
.text$mn:00004928                 push    ebp
.text$mn:00004929                 mov     ebp, esp
.text$mn:0000492B                 push    ecx
.text$mn:0000492C                 mov     [ebp+var_4], ecx
.text$mn:0000492F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004932                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004937                 mov     esp, ebp
.text$mn:00004939                 pop     ebp
.text$mn:0000493A                 retn
.text$mn:0000493A ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000493A
.text$mn:0000493A ; ---------------------------------------------------------------------------
.text$mn:0000493B                 align 4
.text$mn:0000493B _text$mn        ends
.text$mn:0000493B
.text$mn:0000493C ; ===========================================================================
.text$mn:0000493C
.text$mn:0000493C ; Segment type: Pure code
.text$mn:0000493C ; Segment permissions: Read/Execute
.text$mn:0000493C _text$mn        segment para public 'CODE' use32
.text$mn:0000493C                 assume cs:_text$mn
.text$mn:0000493C                 ;org 493Ch
.text$mn:0000493C ; COMDAT (pick any)
.text$mn:0000493C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000493C
.text$mn:0000493C ; =============== S U B R O U T I N E =======================================
.text$mn:0000493C
.text$mn:0000493C ; Attributes: bp-based frame
.text$mn:0000493C
.text$mn:0000493C ; _DWORD __thiscall std::_Facet_base::~_Facet_base(std::_Facet_base *__hidden this)
.text$mn:0000493C                 public ??1_Facet_base@std@@UAE@XZ
.text$mn:0000493C ??1_Facet_base@std@@UAE@XZ proc near    ; CODE XREF: __unwindfunclet$??0facet@locale@std@@IAE@I@Z$0+3j
.text$mn:0000493C                                         ; std::locale::facet::~facet(void)+40p ...
.text$mn:0000493C
.text$mn:0000493C var_4           = dword ptr -4
.text$mn:0000493C
.text$mn:0000493C                 push    ebp
.text$mn:0000493D                 mov     ebp, esp
.text$mn:0000493F                 push    ecx
.text$mn:00004940                 mov     [ebp+var_4], ecx
.text$mn:00004943                 mov     eax, [ebp+var_4]
.text$mn:00004946                 mov     dword ptr [eax], offset ??_7_Facet_base@std@@6B@ ; const std::_Facet_base::`vftable'
.text$mn:0000494C                 mov     esp, ebp
.text$mn:0000494E                 pop     ebp
.text$mn:0000494F                 retn
.text$mn:0000494F ??1_Facet_base@std@@UAE@XZ endp
.text$mn:0000494F
.text$mn:0000494F _text$mn        ends
.text$mn:0000494F
.text$mn:00004950 ; ===========================================================================
.text$mn:00004950
.text$mn:00004950 ; Segment type: Pure code
.text$mn:00004950 ; Segment permissions: Read/Execute
.text$mn:00004950 _text$mn        segment para public 'CODE' use32
.text$mn:00004950                 assume cs:_text$mn
.text$mn:00004950                 ;org 4950h
.text$mn:00004950 ; COMDAT (pick any)
.text$mn:00004950                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004950
.text$mn:00004950 ; =============== S U B R O U T I N E =======================================
.text$mn:00004950
.text$mn:00004950 ; Attributes: bp-based frame
.text$mn:00004950
.text$mn:00004950 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00004950                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00004950 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00004950                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00004950                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00004950
.text$mn:00004950 var_10          = dword ptr -10h
.text$mn:00004950 var_C           = dword ptr -0Ch
.text$mn:00004950 var_4           = dword ptr -4
.text$mn:00004950
.text$mn:00004950                 push    ebp
.text$mn:00004951                 mov     ebp, esp
.text$mn:00004953                 push    0FFFFFFFFh
.text$mn:00004955                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000495A                 mov     eax, large fs:0
.text$mn:00004960                 push    eax
.text$mn:00004961                 push    ecx
.text$mn:00004962                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004967                 xor     eax, ebp
.text$mn:00004969                 push    eax
.text$mn:0000496A                 lea     eax, [ebp+var_C]
.text$mn:0000496D                 mov     large fs:0, eax
.text$mn:00004973                 mov     [ebp+var_10], ecx
.text$mn:00004976                 mov     [ebp+var_4], 0
.text$mn:0000497D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004984                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004987                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000498C                 mov     ecx, [ebp+var_C]
.text$mn:0000498F                 mov     large fs:0, ecx
.text$mn:00004996                 pop     ecx
.text$mn:00004997                 mov     esp, ebp
.text$mn:00004999                 pop     ebp
.text$mn:0000499A                 retn
.text$mn:0000499A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000499A
.text$mn:0000499A ; ---------------------------------------------------------------------------
.text$mn:0000499B                 align 4
.text$mn:0000499B _text$mn        ends
.text$mn:0000499B
.text$x:0000499C ; ===========================================================================
.text$x:0000499C
.text$x:0000499C ; Segment type: Pure code
.text$x:0000499C ; Segment permissions: Read/Execute
.text$x:0000499C _text$x         segment para public 'CODE' use32
.text$x:0000499C                 assume cs:_text$x
.text$x:0000499C                 ;org 499Ch
.text$x:0000499C ; COMDAT (pick associative to section at 4950)
.text$x:0000499C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000499C
.text$x:0000499C ; =============== S U B R O U T I N E =======================================
.text$x:0000499C
.text$x:0000499C
.text$x:0000499C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:0000499C                                         ; DATA XREF: .xdata$x:00008454o
.text$x:0000499C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000499F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000499F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000499F
.text$x:000049A4
.text$x:000049A4 ; =============== S U B R O U T I N E =======================================
.text$x:000049A4
.text$x:000049A4
.text$x:000049A4 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000049A4                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000049A4
.text$x:000049A4 arg_4           = dword ptr  8
.text$x:000049A4
.text$x:000049A4                 mov     edx, [esp+arg_4]
.text$x:000049A8                 lea     eax, [edx+0Ch]
.text$x:000049AB                 mov     ecx, [edx-8]
.text$x:000049AE                 xor     ecx, eax
.text$x:000049B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000049B5                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000049BA                 jmp     ___CxxFrameHandler3
.text$x:000049BA __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000049BA
.text$x:000049BA ; ---------------------------------------------------------------------------
.text$x:000049BF                 align 10h
.text$x:000049BF _text$x         ends
.text$x:000049BF
.text$mn:000049C0 ; ===========================================================================
.text$mn:000049C0
.text$mn:000049C0 ; Segment type: Pure code
.text$mn:000049C0 ; Segment permissions: Read/Execute
.text$mn:000049C0 _text$mn        segment para public 'CODE' use32
.text$mn:000049C0                 assume cs:_text$mn
.text$mn:000049C0                 ;org 49C0h
.text$mn:000049C0 ; COMDAT (pick any)
.text$mn:000049C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049C0
.text$mn:000049C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000049C0
.text$mn:000049C0 ; Attributes: bp-based frame
.text$mn:000049C0
.text$mn:000049C0 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000049C0                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000049C0 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000049C0                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000049C0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000049C0
.text$mn:000049C0 var_10          = dword ptr -10h
.text$mn:000049C0 var_C           = dword ptr -0Ch
.text$mn:000049C0 var_4           = dword ptr -4
.text$mn:000049C0
.text$mn:000049C0                 push    ebp
.text$mn:000049C1                 mov     ebp, esp
.text$mn:000049C3                 push    0FFFFFFFFh
.text$mn:000049C5                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000049CA                 mov     eax, large fs:0
.text$mn:000049D0                 push    eax
.text$mn:000049D1                 push    ecx
.text$mn:000049D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000049D7                 xor     eax, ebp
.text$mn:000049D9                 push    eax
.text$mn:000049DA                 lea     eax, [ebp+var_C]
.text$mn:000049DD                 mov     large fs:0, eax
.text$mn:000049E3                 mov     [ebp+var_10], ecx
.text$mn:000049E6                 mov     [ebp+var_4], 0
.text$mn:000049ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000049F4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000049F7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000049FC                 mov     ecx, [ebp+var_C]
.text$mn:000049FF                 mov     large fs:0, ecx
.text$mn:00004A06                 pop     ecx
.text$mn:00004A07                 mov     esp, ebp
.text$mn:00004A09                 pop     ebp
.text$mn:00004A0A                 retn
.text$mn:00004A0A ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00004A0A
.text$mn:00004A0A ; ---------------------------------------------------------------------------
.text$mn:00004A0B                 align 4
.text$mn:00004A0B _text$mn        ends
.text$mn:00004A0B
.text$x:00004A0C ; ===========================================================================
.text$x:00004A0C
.text$x:00004A0C ; Segment type: Pure code
.text$x:00004A0C ; Segment permissions: Read/Execute
.text$x:00004A0C _text$x         segment para public 'CODE' use32
.text$x:00004A0C                 assume cs:_text$x
.text$x:00004A0C                 ;org 4A0Ch
.text$x:00004A0C ; COMDAT (pick associative to section at 49C0)
.text$x:00004A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004A0C
.text$x:00004A0C ; =============== S U B R O U T I N E =======================================
.text$x:00004A0C
.text$x:00004A0C
.text$x:00004A0C __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00004A0C                                         ; DATA XREF: .xdata$x:000084D8o
.text$x:00004A0C                 mov     ecx, [ebp-10h]  ; this
.text$x:00004A0F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00004A0F __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00004A0F
.text$x:00004A14
.text$x:00004A14 ; =============== S U B R O U T I N E =======================================
.text$x:00004A14
.text$x:00004A14
.text$x:00004A14 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00004A14                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00004A14
.text$x:00004A14 arg_4           = dword ptr  8
.text$x:00004A14
.text$x:00004A14                 mov     edx, [esp+arg_4]
.text$x:00004A18                 lea     eax, [edx+0Ch]
.text$x:00004A1B                 mov     ecx, [edx-8]
.text$x:00004A1E                 xor     ecx, eax
.text$x:00004A20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A25                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00004A2A                 jmp     ___CxxFrameHandler3
.text$x:00004A2A __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00004A2A
.text$x:00004A2A ; ---------------------------------------------------------------------------
.text$x:00004A2F                 align 10h
.text$x:00004A2F _text$x         ends
.text$x:00004A2F
.text$mn:00004A30 ; ===========================================================================
.text$mn:00004A30
.text$mn:00004A30 ; Segment type: Pure code
.text$mn:00004A30 ; Segment permissions: Read/Execute
.text$mn:00004A30 _text$mn        segment para public 'CODE' use32
.text$mn:00004A30                 assume cs:_text$mn
.text$mn:00004A30                 ;org 4A30h
.text$mn:00004A30 ; COMDAT (pick any)
.text$mn:00004A30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A30
.text$mn:00004A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A30
.text$mn:00004A30 ; Attributes: bp-based frame
.text$mn:00004A30
.text$mn:00004A30 ; _DWORD __thiscall std::_Locinfo::~_Locinfo(std::_Locinfo *__hidden this)
.text$mn:00004A30                 public ??1_Locinfo@std@@QAE@XZ
.text$mn:00004A30 ??1_Locinfo@std@@QAE@XZ proc near       ; CODE XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+DEp
.text$mn:00004A30                                         ; __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1+13j
.text$mn:00004A30
.text$mn:00004A30 var_10          = dword ptr -10h
.text$mn:00004A30 var_C           = dword ptr -0Ch
.text$mn:00004A30 var_4           = dword ptr -4
.text$mn:00004A30
.text$mn:00004A30                 push    ebp
.text$mn:00004A31                 mov     ebp, esp
.text$mn:00004A33                 push    0FFFFFFFFh
.text$mn:00004A35                 push    offset __ehhandler$??1_Locinfo@std@@QAE@XZ
.text$mn:00004A3A                 mov     eax, large fs:0
.text$mn:00004A40                 push    eax
.text$mn:00004A41                 push    ecx
.text$mn:00004A42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004A47                 xor     eax, ebp
.text$mn:00004A49                 push    eax
.text$mn:00004A4A                 lea     eax, [ebp+var_C]
.text$mn:00004A4D                 mov     large fs:0, eax
.text$mn:00004A53                 mov     [ebp+var_10], ecx
.text$mn:00004A56                 mov     [ebp+var_4], 6
.text$mn:00004A5D                 mov     eax, [ebp+var_10]
.text$mn:00004A60                 push    eax             ; struct std::_Locinfo *
.text$mn:00004A61                 call    ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor(std::_Locinfo *)
.text$mn:00004A66                 add     esp, 4
.text$mn:00004A69                 mov     byte ptr [ebp+var_4], 5
.text$mn:00004A6D                 mov     ecx, [ebp+var_10]
.text$mn:00004A70                 add     ecx, 2Ch ; ','
.text$mn:00004A73                 call    ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$mn:00004A78                 mov     byte ptr [ebp+var_4], 4
.text$mn:00004A7C                 mov     ecx, [ebp+var_10]
.text$mn:00004A7F                 add     ecx, 24h ; '$'
.text$mn:00004A82                 call    ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$mn:00004A87                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004A8B                 mov     ecx, [ebp+var_10]
.text$mn:00004A8E                 add     ecx, 1Ch
.text$mn:00004A91                 call    ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>(void)
.text$mn:00004A96                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004A9A                 mov     ecx, [ebp+var_10]
.text$mn:00004A9D                 add     ecx, 14h
.text$mn:00004AA0                 call    ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>(void)
.text$mn:00004AA5                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004AA9                 mov     ecx, [ebp+var_10]
.text$mn:00004AAC                 add     ecx, 0Ch
.text$mn:00004AAF                 call    ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$mn:00004AB4                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004AB8                 mov     ecx, [ebp+var_10]
.text$mn:00004ABB                 add     ecx, 4
.text$mn:00004ABE                 call    ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$mn:00004AC3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004ACA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004ACD                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004AD2                 mov     ecx, [ebp+var_C]
.text$mn:00004AD5                 mov     large fs:0, ecx
.text$mn:00004ADC                 pop     ecx
.text$mn:00004ADD                 mov     esp, ebp
.text$mn:00004ADF                 pop     ebp
.text$mn:00004AE0                 retn
.text$mn:00004AE0 ??1_Locinfo@std@@QAE@XZ endp
.text$mn:00004AE0
.text$mn:00004AE0 ; ---------------------------------------------------------------------------
.text$mn:00004AE1                 align 4
.text$mn:00004AE1 _text$mn        ends
.text$mn:00004AE1
.text$x:00004AE4 ; ===========================================================================
.text$x:00004AE4
.text$x:00004AE4 ; Segment type: Pure code
.text$x:00004AE4 ; Segment permissions: Read/Execute
.text$x:00004AE4 _text$x         segment para public 'CODE' use32
.text$x:00004AE4                 assume cs:_text$x
.text$x:00004AE4                 ;org 4AE4h
.text$x:00004AE4 ; COMDAT (pick associative to section at 4A30)
.text$x:00004AE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004AE4
.text$x:00004AE4 ; =============== S U B R O U T I N E =======================================
.text$x:00004AE4
.text$x:00004AE4
.text$x:00004AE4 __unwindfunclet$??1_Locinfo@std@@QAE@XZ$0 proc near
.text$x:00004AE4                                         ; DATA XREF: .xdata$x:00008090o
.text$x:00004AE4                 mov     ecx, [ebp-10h]  ; this
.text$x:00004AE7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004AE7 __unwindfunclet$??1_Locinfo@std@@QAE@XZ$0 endp
.text$x:00004AE7
.text$x:00004AEC
.text$x:00004AEC ; =============== S U B R O U T I N E =======================================
.text$x:00004AEC
.text$x:00004AEC
.text$x:00004AEC __unwindfunclet$??1_Locinfo@std@@QAE@XZ$1 proc near
.text$x:00004AEC                                         ; DATA XREF: .xdata$x:00008098o
.text$x:00004AEC                 mov     ecx, [ebp-10h]
.text$x:00004AEF                 add     ecx, 4
.text$x:00004AF2                 jmp     ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$x:00004AF2 __unwindfunclet$??1_Locinfo@std@@QAE@XZ$1 endp
.text$x:00004AF2
.text$x:00004AF7
.text$x:00004AF7 ; =============== S U B R O U T I N E =======================================
.text$x:00004AF7
.text$x:00004AF7
.text$x:00004AF7 __unwindfunclet$??1_Locinfo@std@@QAE@XZ$2 proc near
.text$x:00004AF7                                         ; DATA XREF: .xdata$x:000080A0o
.text$x:00004AF7                 mov     ecx, [ebp-10h]
.text$x:00004AFA                 add     ecx, 0Ch
.text$x:00004AFD                 jmp     ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$x:00004AFD __unwindfunclet$??1_Locinfo@std@@QAE@XZ$2 endp
.text$x:00004AFD
.text$x:00004B02
.text$x:00004B02 ; =============== S U B R O U T I N E =======================================
.text$x:00004B02
.text$x:00004B02
.text$x:00004B02 __unwindfunclet$??1_Locinfo@std@@QAE@XZ$3 proc near
.text$x:00004B02                                         ; DATA XREF: .xdata$x:000080A8o
.text$x:00004B02                 mov     ecx, [ebp-10h]
.text$x:00004B05                 add     ecx, 14h
.text$x:00004B08                 jmp     ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>(void)
.text$x:00004B08 __unwindfunclet$??1_Locinfo@std@@QAE@XZ$3 endp
.text$x:00004B08
.text$x:00004B0D
.text$x:00004B0D ; =============== S U B R O U T I N E =======================================
.text$x:00004B0D
.text$x:00004B0D
.text$x:00004B0D __unwindfunclet$??1_Locinfo@std@@QAE@XZ$4 proc near
.text$x:00004B0D                                         ; DATA XREF: .xdata$x:000080B0o
.text$x:00004B0D                 mov     ecx, [ebp-10h]
.text$x:00004B10                 add     ecx, 1Ch
.text$x:00004B13                 jmp     ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>(void)
.text$x:00004B13 __unwindfunclet$??1_Locinfo@std@@QAE@XZ$4 endp
.text$x:00004B13
.text$x:00004B18
.text$x:00004B18 ; =============== S U B R O U T I N E =======================================
.text$x:00004B18
.text$x:00004B18
.text$x:00004B18 __unwindfunclet$??1_Locinfo@std@@QAE@XZ$5 proc near
.text$x:00004B18                                         ; DATA XREF: .xdata$x:000080B8o
.text$x:00004B18                 mov     ecx, [ebp-10h]
.text$x:00004B1B                 add     ecx, 24h ; '$'
.text$x:00004B1E                 jmp     ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$x:00004B1E __unwindfunclet$??1_Locinfo@std@@QAE@XZ$5 endp
.text$x:00004B1E
.text$x:00004B23
.text$x:00004B23 ; =============== S U B R O U T I N E =======================================
.text$x:00004B23
.text$x:00004B23
.text$x:00004B23 __unwindfunclet$??1_Locinfo@std@@QAE@XZ$6 proc near
.text$x:00004B23                                         ; DATA XREF: .xdata$x:000080C0o
.text$x:00004B23                 mov     ecx, [ebp-10h]
.text$x:00004B26                 add     ecx, 2Ch ; ','
.text$x:00004B29                 jmp     ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>(void)
.text$x:00004B29 __unwindfunclet$??1_Locinfo@std@@QAE@XZ$6 endp
.text$x:00004B29
.text$x:00004B2E
.text$x:00004B2E ; =============== S U B R O U T I N E =======================================
.text$x:00004B2E
.text$x:00004B2E
.text$x:00004B2E __ehhandler$??1_Locinfo@std@@QAE@XZ proc near
.text$x:00004B2E                                         ; DATA XREF: std::_Locinfo::~_Locinfo(void)+5o
.text$x:00004B2E
.text$x:00004B2E arg_4           = dword ptr  8
.text$x:00004B2E
.text$x:00004B2E                 mov     edx, [esp+arg_4]
.text$x:00004B32                 lea     eax, [edx+0Ch]
.text$x:00004B35                 mov     ecx, [edx-8]
.text$x:00004B38                 xor     ecx, eax
.text$x:00004B3A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004B3F                 mov     eax, offset __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
.text$x:00004B44                 jmp     ___CxxFrameHandler3
.text$x:00004B44 __ehhandler$??1_Locinfo@std@@QAE@XZ endp
.text$x:00004B44
.text$x:00004B44 ; ---------------------------------------------------------------------------
.text$x:00004B49                 align 4
.text$x:00004B49 _text$x         ends
.text$x:00004B49
.text$mn:00004B4C ; ===========================================================================
.text$mn:00004B4C
.text$mn:00004B4C ; Segment type: Pure code
.text$mn:00004B4C ; Segment permissions: Read/Execute
.text$mn:00004B4C _text$mn        segment para public 'CODE' use32
.text$mn:00004B4C                 assume cs:_text$mn
.text$mn:00004B4C                 ;org 4B4Ch
.text$mn:00004B4C ; COMDAT (pick any)
.text$mn:00004B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B4C
.text$mn:00004B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00004B4C
.text$mn:00004B4C ; Attributes: bp-based frame
.text$mn:00004B4C
.text$mn:00004B4C ; public: __thiscall std::basic_istream<char, struct std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
.text$mn:00004B4C                 public ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
.text$mn:00004B4C ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ proc near
.text$mn:00004B4C                                         ; CODE XREF: __unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0+3j
.text$mn:00004B4C                                         ; std::basic_istream<char,std::char_traits<char>>::sentry::~sentry(void)+37p ...
.text$mn:00004B4C
.text$mn:00004B4C var_10          = dword ptr -10h
.text$mn:00004B4C var_C           = dword ptr -0Ch
.text$mn:00004B4C var_8           = dword ptr -8
.text$mn:00004B4C var_4           = dword ptr -4
.text$mn:00004B4C
.text$mn:00004B4C                 push    ebp
.text$mn:00004B4D                 mov     ebp, esp
.text$mn:00004B4F                 sub     esp, 10h
.text$mn:00004B52                 mov     [ebp+var_8], ecx
.text$mn:00004B55                 mov     eax, [ebp+var_8]
.text$mn:00004B58                 mov     ecx, [eax]
.text$mn:00004B5A                 mov     [ebp+var_4], ecx
.text$mn:00004B5D                 mov     edx, [ebp+var_4]
.text$mn:00004B60                 mov     eax, [edx]
.text$mn:00004B62                 mov     ecx, [ebp+var_4]
.text$mn:00004B65                 add     ecx, [eax+4]
.text$mn:00004B68                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00004B6D                 test    eax, eax
.text$mn:00004B6F                 jz      short loc_4B9B
.text$mn:00004B71                 mov     ecx, [ebp+var_8]
.text$mn:00004B74                 mov     edx, [ecx]
.text$mn:00004B76                 mov     [ebp+var_C], edx
.text$mn:00004B79                 mov     eax, [ebp+var_C]
.text$mn:00004B7C                 mov     ecx, [eax]
.text$mn:00004B7E                 mov     edx, [ebp+var_C]
.text$mn:00004B81                 add     edx, [ecx+4]
.text$mn:00004B84                 mov     ecx, edx
.text$mn:00004B86                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00004B8B                 mov     [ebp+var_10], eax
.text$mn:00004B8E                 mov     eax, [ebp+var_10]
.text$mn:00004B91                 mov     edx, [eax]
.text$mn:00004B93                 mov     ecx, [ebp+var_10]
.text$mn:00004B96                 mov     eax, [edx+8]
.text$mn:00004B99                 call    eax
.text$mn:00004B9B
.text$mn:00004B9B loc_4B9B:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)+23j
.text$mn:00004B9B                 mov     esp, ebp
.text$mn:00004B9D                 pop     ebp
.text$mn:00004B9E                 retn
.text$mn:00004B9E ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ endp
.text$mn:00004B9E
.text$mn:00004B9E ; ---------------------------------------------------------------------------
.text$mn:00004B9F                 align 10h
.text$mn:00004B9F _text$mn        ends
.text$mn:00004B9F
.text$mn:00004BA0 ; ===========================================================================
.text$mn:00004BA0
.text$mn:00004BA0 ; Segment type: Pure code
.text$mn:00004BA0 ; Segment permissions: Read/Execute
.text$mn:00004BA0 _text$mn        segment para public 'CODE' use32
.text$mn:00004BA0                 assume cs:_text$mn
.text$mn:00004BA0                 ;org 4BA0h
.text$mn:00004BA0 ; COMDAT (pick any)
.text$mn:00004BA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BA0
.text$mn:00004BA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BA0
.text$mn:00004BA0 ; Attributes: bp-based frame
.text$mn:00004BA0
.text$mn:00004BA0 ; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
.text$mn:00004BA0                 public ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
.text$mn:00004BA0 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ proc near
.text$mn:00004BA0                                         ; CODE XREF: __unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0+3j
.text$mn:00004BA0                                         ; std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+4Dp ...
.text$mn:00004BA0
.text$mn:00004BA0 var_10          = dword ptr -10h
.text$mn:00004BA0 var_C           = dword ptr -0Ch
.text$mn:00004BA0 var_8           = dword ptr -8
.text$mn:00004BA0 var_4           = dword ptr -4
.text$mn:00004BA0
.text$mn:00004BA0                 push    ebp
.text$mn:00004BA1                 mov     ebp, esp
.text$mn:00004BA3                 sub     esp, 10h
.text$mn:00004BA6                 mov     [ebp+var_8], ecx
.text$mn:00004BA9                 mov     eax, [ebp+var_8]
.text$mn:00004BAC                 mov     ecx, [eax]
.text$mn:00004BAE                 mov     [ebp+var_4], ecx
.text$mn:00004BB1                 mov     edx, [ebp+var_4]
.text$mn:00004BB4                 mov     eax, [edx]
.text$mn:00004BB6                 mov     ecx, [ebp+var_4]
.text$mn:00004BB9                 add     ecx, [eax+4]
.text$mn:00004BBC                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00004BC1                 test    eax, eax
.text$mn:00004BC3                 jz      short loc_4BEF
.text$mn:00004BC5                 mov     ecx, [ebp+var_8]
.text$mn:00004BC8                 mov     edx, [ecx]
.text$mn:00004BCA                 mov     [ebp+var_C], edx
.text$mn:00004BCD                 mov     eax, [ebp+var_C]
.text$mn:00004BD0                 mov     ecx, [eax]
.text$mn:00004BD2                 mov     edx, [ebp+var_C]
.text$mn:00004BD5                 add     edx, [ecx+4]
.text$mn:00004BD8                 mov     ecx, edx
.text$mn:00004BDA                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00004BDF                 mov     [ebp+var_10], eax
.text$mn:00004BE2                 mov     eax, [ebp+var_10]
.text$mn:00004BE5                 mov     edx, [eax]
.text$mn:00004BE7                 mov     ecx, [ebp+var_10]
.text$mn:00004BEA                 mov     eax, [edx+8]
.text$mn:00004BED                 call    eax
.text$mn:00004BEF
.text$mn:00004BEF loc_4BEF:                               ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)+23j
.text$mn:00004BEF                 mov     esp, ebp
.text$mn:00004BF1                 pop     ebp
.text$mn:00004BF2                 retn
.text$mn:00004BF2 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ endp
.text$mn:00004BF2
.text$mn:00004BF2 ; ---------------------------------------------------------------------------
.text$mn:00004BF3                 align 4
.text$mn:00004BF3 _text$mn        ends
.text$mn:00004BF3
.text$mn:00004BF4 ; ===========================================================================
.text$mn:00004BF4
.text$mn:00004BF4 ; Segment type: Pure code
.text$mn:00004BF4 ; Segment permissions: Read/Execute
.text$mn:00004BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BF4                 assume cs:_text$mn
.text$mn:00004BF4                 ;org 4BF4h
.text$mn:00004BF4 ; COMDAT (pick any)
.text$mn:00004BF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BF4
.text$mn:00004BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BF4
.text$mn:00004BF4 ; Attributes: bp-based frame
.text$mn:00004BF4
.text$mn:00004BF4 ; _DWORD __thiscall std::_System_error::~_System_error(std::_System_error *__hidden this)
.text$mn:00004BF4                 public ??1_System_error@std@@UAE@XZ
.text$mn:00004BF4 ??1_System_error@std@@UAE@XZ proc near  ; CODE XREF: __unwindfunclet$??0system_error@std@@QAE@ABV01@@Z$0+3j
.text$mn:00004BF4                                         ; __unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$1+3j ...
.text$mn:00004BF4
.text$mn:00004BF4 var_10          = dword ptr -10h
.text$mn:00004BF4 var_C           = dword ptr -0Ch
.text$mn:00004BF4 var_4           = dword ptr -4
.text$mn:00004BF4
.text$mn:00004BF4                 push    ebp
.text$mn:00004BF5                 mov     ebp, esp
.text$mn:00004BF7                 push    0FFFFFFFFh
.text$mn:00004BF9                 push    offset __ehhandler$??1_System_error@std@@UAE@XZ
.text$mn:00004BFE                 mov     eax, large fs:0
.text$mn:00004C04                 push    eax
.text$mn:00004C05                 push    ecx
.text$mn:00004C06                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004C0B                 xor     eax, ebp
.text$mn:00004C0D                 push    eax
.text$mn:00004C0E                 lea     eax, [ebp+var_C]
.text$mn:00004C11                 mov     large fs:0, eax
.text$mn:00004C17                 mov     [ebp+var_10], ecx
.text$mn:00004C1A                 mov     [ebp+var_4], 0
.text$mn:00004C21                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004C28                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004C2B                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:00004C30                 mov     ecx, [ebp+var_C]
.text$mn:00004C33                 mov     large fs:0, ecx
.text$mn:00004C3A                 pop     ecx
.text$mn:00004C3B                 mov     esp, ebp
.text$mn:00004C3D                 pop     ebp
.text$mn:00004C3E                 retn
.text$mn:00004C3E ??1_System_error@std@@UAE@XZ endp
.text$mn:00004C3E
.text$mn:00004C3E ; ---------------------------------------------------------------------------
.text$mn:00004C3F                 align 10h
.text$mn:00004C3F _text$mn        ends
.text$mn:00004C3F
.text$x:00004C40 ; ===========================================================================
.text$x:00004C40
.text$x:00004C40 ; Segment type: Pure code
.text$x:00004C40 ; Segment permissions: Read/Execute
.text$x:00004C40 _text$x         segment para public 'CODE' use32
.text$x:00004C40                 assume cs:_text$x
.text$x:00004C40                 ;org 4C40h
.text$x:00004C40 ; COMDAT (pick associative to section at 4BF4)
.text$x:00004C40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004C40
.text$x:00004C40 ; =============== S U B R O U T I N E =======================================
.text$x:00004C40
.text$x:00004C40
.text$x:00004C40 __unwindfunclet$??1_System_error@std@@UAE@XZ$0 proc near
.text$x:00004C40                                         ; DATA XREF: .xdata$x:00008310o
.text$x:00004C40                 mov     ecx, [ebp-10h]  ; this
.text$x:00004C43                 jmp     ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$x:00004C43 __unwindfunclet$??1_System_error@std@@UAE@XZ$0 endp
.text$x:00004C43
.text$x:00004C48
.text$x:00004C48 ; =============== S U B R O U T I N E =======================================
.text$x:00004C48
.text$x:00004C48
.text$x:00004C48 __ehhandler$??1_System_error@std@@UAE@XZ proc near
.text$x:00004C48                                         ; DATA XREF: std::_System_error::~_System_error(void)+5o
.text$x:00004C48
.text$x:00004C48 arg_4           = dword ptr  8
.text$x:00004C48
.text$x:00004C48                 mov     edx, [esp+arg_4]
.text$x:00004C4C                 lea     eax, [edx+0Ch]
.text$x:00004C4F                 mov     ecx, [edx-8]
.text$x:00004C52                 xor     ecx, eax
.text$x:00004C54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004C59                 mov     eax, offset __ehfuncinfo$??1_System_error@std@@UAE@XZ
.text$x:00004C5E                 jmp     ___CxxFrameHandler3
.text$x:00004C5E __ehhandler$??1_System_error@std@@UAE@XZ endp
.text$x:00004C5E
.text$x:00004C5E ; ---------------------------------------------------------------------------
.text$x:00004C63                 align 4
.text$x:00004C63 _text$x         ends
.text$x:00004C63
.text$mn:00004C64 ; ===========================================================================
.text$mn:00004C64
.text$mn:00004C64 ; Segment type: Pure code
.text$mn:00004C64 ; Segment permissions: Read/Execute
.text$mn:00004C64 _text$mn        segment para public 'CODE' use32
.text$mn:00004C64                 assume cs:_text$mn
.text$mn:00004C64                 ;org 4C64h
.text$mn:00004C64 ; COMDAT (pick any)
.text$mn:00004C64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C64
.text$mn:00004C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C64
.text$mn:00004C64 ; Attributes: bp-based frame
.text$mn:00004C64
.text$mn:00004C64 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00004C64                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00004C64 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00004C64                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00004C64                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00004C64
.text$mn:00004C64 var_10          = dword ptr -10h
.text$mn:00004C64 var_C           = dword ptr -0Ch
.text$mn:00004C64 var_4           = dword ptr -4
.text$mn:00004C64
.text$mn:00004C64                 push    ebp
.text$mn:00004C65                 mov     ebp, esp
.text$mn:00004C67                 push    0FFFFFFFFh
.text$mn:00004C69                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00004C6E                 mov     eax, large fs:0
.text$mn:00004C74                 push    eax
.text$mn:00004C75                 push    ecx
.text$mn:00004C76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004C7B                 xor     eax, ebp
.text$mn:00004C7D                 push    eax
.text$mn:00004C7E                 lea     eax, [ebp+var_C]
.text$mn:00004C81                 mov     large fs:0, eax
.text$mn:00004C87                 mov     [ebp+var_10], ecx
.text$mn:00004C8A                 mov     [ebp+var_4], 0
.text$mn:00004C91                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004C98                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004C9B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00004CA0                 mov     ecx, [ebp+var_C]
.text$mn:00004CA3                 mov     large fs:0, ecx
.text$mn:00004CAA                 pop     ecx
.text$mn:00004CAB                 mov     esp, ebp
.text$mn:00004CAD                 pop     ebp
.text$mn:00004CAE                 retn
.text$mn:00004CAE ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00004CAE
.text$mn:00004CAE ; ---------------------------------------------------------------------------
.text$mn:00004CAF                 align 10h
.text$mn:00004CAF _text$mn        ends
.text$mn:00004CAF
.text$x:00004CB0 ; ===========================================================================
.text$x:00004CB0
.text$x:00004CB0 ; Segment type: Pure code
.text$x:00004CB0 ; Segment permissions: Read/Execute
.text$x:00004CB0 _text$x         segment para public 'CODE' use32
.text$x:00004CB0                 assume cs:_text$x
.text$x:00004CB0                 ;org 4CB0h
.text$x:00004CB0 ; COMDAT (pick associative to section at 4C64)
.text$x:00004CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004CB0
.text$x:00004CB0 ; =============== S U B R O U T I N E =======================================
.text$x:00004CB0
.text$x:00004CB0
.text$x:00004CB0 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00004CB0                                         ; DATA XREF: .xdata$x:0000855Co
.text$x:00004CB0                 mov     ecx, [ebp-10h]  ; this
.text$x:00004CB3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00004CB3 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00004CB3
.text$x:00004CB8
.text$x:00004CB8 ; =============== S U B R O U T I N E =======================================
.text$x:00004CB8
.text$x:00004CB8
.text$x:00004CB8 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00004CB8                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00004CB8
.text$x:00004CB8 arg_4           = dword ptr  8
.text$x:00004CB8
.text$x:00004CB8                 mov     edx, [esp+arg_4]
.text$x:00004CBC                 lea     eax, [edx+0Ch]
.text$x:00004CBF                 mov     ecx, [edx-8]
.text$x:00004CC2                 xor     ecx, eax
.text$x:00004CC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004CC9                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00004CCE                 jmp     ___CxxFrameHandler3
.text$x:00004CCE __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00004CCE
.text$x:00004CCE ; ---------------------------------------------------------------------------
.text$x:00004CD3                 align 4
.text$x:00004CD3 _text$x         ends
.text$x:00004CD3
.text$mn:00004CD4 ; ===========================================================================
.text$mn:00004CD4
.text$mn:00004CD4 ; Segment type: Pure code
.text$mn:00004CD4 ; Segment permissions: Read/Execute
.text$mn:00004CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CD4                 assume cs:_text$mn
.text$mn:00004CD4                 ;org 4CD4h
.text$mn:00004CD4 ; COMDAT (pick any)
.text$mn:00004CD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CD4
.text$mn:00004CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CD4
.text$mn:00004CD4 ; Attributes: bp-based frame
.text$mn:00004CD4
.text$mn:00004CD4 ; _DWORD __thiscall std::ctype_base::~ctype_base(std::ctype_base *__hidden this)
.text$mn:00004CD4                 public ??1ctype_base@std@@UAE@XZ
.text$mn:00004CD4 ??1ctype_base@std@@UAE@XZ proc near     ; CODE XREF: __unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0+3j
.text$mn:00004CD4                                         ; std::ctype<char>::~ctype<char>(void)+48p ...
.text$mn:00004CD4
.text$mn:00004CD4 var_10          = dword ptr -10h
.text$mn:00004CD4 var_C           = dword ptr -0Ch
.text$mn:00004CD4 var_4           = dword ptr -4
.text$mn:00004CD4
.text$mn:00004CD4                 push    ebp
.text$mn:00004CD5                 mov     ebp, esp
.text$mn:00004CD7                 push    0FFFFFFFFh
.text$mn:00004CD9                 push    offset __ehhandler$??1ctype_base@std@@UAE@XZ
.text$mn:00004CDE                 mov     eax, large fs:0
.text$mn:00004CE4                 push    eax
.text$mn:00004CE5                 push    ecx
.text$mn:00004CE6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004CEB                 xor     eax, ebp
.text$mn:00004CED                 push    eax
.text$mn:00004CEE                 lea     eax, [ebp+var_C]
.text$mn:00004CF1                 mov     large fs:0, eax
.text$mn:00004CF7                 mov     [ebp+var_10], ecx
.text$mn:00004CFA                 mov     eax, [ebp+var_10]
.text$mn:00004CFD                 mov     dword ptr [eax], offset ??_7ctype_base@std@@6B@ ; const std::ctype_base::`vftable'
.text$mn:00004D03                 mov     [ebp+var_4], 0
.text$mn:00004D0A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D11                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004D14                 call    ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet(void)
.text$mn:00004D19                 mov     ecx, [ebp+var_C]
.text$mn:00004D1C                 mov     large fs:0, ecx
.text$mn:00004D23                 pop     ecx
.text$mn:00004D24                 mov     esp, ebp
.text$mn:00004D26                 pop     ebp
.text$mn:00004D27                 retn
.text$mn:00004D27 ??1ctype_base@std@@UAE@XZ endp
.text$mn:00004D27
.text$mn:00004D27 _text$mn        ends
.text$mn:00004D27
.text$x:00004D28 ; ===========================================================================
.text$x:00004D28
.text$x:00004D28 ; Segment type: Pure code
.text$x:00004D28 ; Segment permissions: Read/Execute
.text$x:00004D28 _text$x         segment para public 'CODE' use32
.text$x:00004D28                 assume cs:_text$x
.text$x:00004D28                 ;org 4D28h
.text$x:00004D28 ; COMDAT (pick associative to section at 4CD4)
.text$x:00004D28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004D28
.text$x:00004D28 ; =============== S U B R O U T I N E =======================================
.text$x:00004D28
.text$x:00004D28
.text$x:00004D28 __unwindfunclet$??1ctype_base@std@@UAE@XZ$0 proc near
.text$x:00004D28                                         ; DATA XREF: .xdata$x:00008178o
.text$x:00004D28                 mov     ecx, [ebp-10h]  ; this
.text$x:00004D2B                 jmp     ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet(void)
.text$x:00004D2B __unwindfunclet$??1ctype_base@std@@UAE@XZ$0 endp
.text$x:00004D2B
.text$x:00004D30
.text$x:00004D30 ; =============== S U B R O U T I N E =======================================
.text$x:00004D30
.text$x:00004D30
.text$x:00004D30 __ehhandler$??1ctype_base@std@@UAE@XZ proc near
.text$x:00004D30                                         ; DATA XREF: std::ctype_base::~ctype_base(void)+5o
.text$x:00004D30
.text$x:00004D30 arg_4           = dword ptr  8
.text$x:00004D30
.text$x:00004D30                 mov     edx, [esp+arg_4]
.text$x:00004D34                 lea     eax, [edx+0Ch]
.text$x:00004D37                 mov     ecx, [edx-8]
.text$x:00004D3A                 xor     ecx, eax
.text$x:00004D3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004D41                 mov     eax, offset __ehfuncinfo$??1ctype_base@std@@UAE@XZ
.text$x:00004D46                 jmp     ___CxxFrameHandler3
.text$x:00004D46 __ehhandler$??1ctype_base@std@@UAE@XZ endp
.text$x:00004D46
.text$x:00004D46 ; ---------------------------------------------------------------------------
.text$x:00004D4B                 align 4
.text$x:00004D4B _text$x         ends
.text$x:00004D4B
.text$mn:00004D4C ; ===========================================================================
.text$mn:00004D4C
.text$mn:00004D4C ; Segment type: Pure code
.text$mn:00004D4C ; Segment permissions: Read/Execute
.text$mn:00004D4C _text$mn        segment para public 'CODE' use32
.text$mn:00004D4C                 assume cs:_text$mn
.text$mn:00004D4C                 ;org 4D4Ch
.text$mn:00004D4C ; COMDAT (pick any)
.text$mn:00004D4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D4C
.text$mn:00004D4C ; =============== S U B R O U T I N E =======================================
.text$mn:00004D4C
.text$mn:00004D4C ; Attributes: bp-based frame
.text$mn:00004D4C
.text$mn:00004D4C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00004D4C                 public ??1error_category@std@@UAE@XZ
.text$mn:00004D4C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00004D4C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00004D4C
.text$mn:00004D4C var_4           = dword ptr -4
.text$mn:00004D4C
.text$mn:00004D4C                 push    ebp
.text$mn:00004D4D                 mov     ebp, esp
.text$mn:00004D4F                 push    ecx
.text$mn:00004D50                 mov     [ebp+var_4], ecx
.text$mn:00004D53                 mov     eax, [ebp+var_4]
.text$mn:00004D56                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00004D5C                 mov     esp, ebp
.text$mn:00004D5E                 pop     ebp
.text$mn:00004D5F                 retn
.text$mn:00004D5F ??1error_category@std@@UAE@XZ endp
.text$mn:00004D5F
.text$mn:00004D5F _text$mn        ends
.text$mn:00004D5F
.text$mn:00004D60 ; ===========================================================================
.text$mn:00004D60
.text$mn:00004D60 ; Segment type: Pure code
.text$mn:00004D60 ; Segment permissions: Read/Execute
.text$mn:00004D60 _text$mn        segment para public 'CODE' use32
.text$mn:00004D60                 assume cs:_text$mn
.text$mn:00004D60                 ;org 4D60h
.text$mn:00004D60 ; COMDAT (pick any)
.text$mn:00004D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D60
.text$mn:00004D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D60
.text$mn:00004D60 ; Attributes: bp-based frame
.text$mn:00004D60
.text$mn:00004D60 ; _DWORD __thiscall std::locale::facet::~facet(std::locale::facet *__hidden this)
.text$mn:00004D60                 public ??1facet@locale@std@@MAE@XZ
.text$mn:00004D60 ??1facet@locale@std@@MAE@XZ proc near   ; CODE XREF: __unwindfunclet$??0ctype_base@std@@QAE@I@Z$0+3j
.text$mn:00004D60                                         ; std::ctype_base::~ctype_base(void)+40p ...
.text$mn:00004D60
.text$mn:00004D60 var_10          = dword ptr -10h
.text$mn:00004D60 var_C           = dword ptr -0Ch
.text$mn:00004D60 var_4           = dword ptr -4
.text$mn:00004D60
.text$mn:00004D60                 push    ebp
.text$mn:00004D61                 mov     ebp, esp
.text$mn:00004D63                 push    0FFFFFFFFh
.text$mn:00004D65                 push    offset __ehhandler$??1facet@locale@std@@MAE@XZ
.text$mn:00004D6A                 mov     eax, large fs:0
.text$mn:00004D70                 push    eax
.text$mn:00004D71                 push    ecx
.text$mn:00004D72                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004D77                 xor     eax, ebp
.text$mn:00004D79                 push    eax
.text$mn:00004D7A                 lea     eax, [ebp+var_C]
.text$mn:00004D7D                 mov     large fs:0, eax
.text$mn:00004D83                 mov     [ebp+var_10], ecx
.text$mn:00004D86                 mov     eax, [ebp+var_10]
.text$mn:00004D89                 mov     dword ptr [eax], offset ??_7facet@locale@std@@6B@ ; const std::locale::facet::`vftable'
.text$mn:00004D8F                 mov     [ebp+var_4], 0
.text$mn:00004D96                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D9D                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004DA0                 call    ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base(void)
.text$mn:00004DA5                 mov     ecx, [ebp+var_C]
.text$mn:00004DA8                 mov     large fs:0, ecx
.text$mn:00004DAF                 pop     ecx
.text$mn:00004DB0                 mov     esp, ebp
.text$mn:00004DB2                 pop     ebp
.text$mn:00004DB3                 retn
.text$mn:00004DB3 ??1facet@locale@std@@MAE@XZ endp
.text$mn:00004DB3
.text$mn:00004DB3 _text$mn        ends
.text$mn:00004DB3
.text$x:00004DB4 ; ===========================================================================
.text$x:00004DB4
.text$x:00004DB4 ; Segment type: Pure code
.text$x:00004DB4 ; Segment permissions: Read/Execute
.text$x:00004DB4 _text$x         segment para public 'CODE' use32
.text$x:00004DB4                 assume cs:_text$x
.text$x:00004DB4                 ;org 4DB4h
.text$x:00004DB4 ; COMDAT (pick associative to section at 4D60)
.text$x:00004DB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004DB4
.text$x:00004DB4 ; =============== S U B R O U T I N E =======================================
.text$x:00004DB4
.text$x:00004DB4
.text$x:00004DB4 __unwindfunclet$??1facet@locale@std@@MAE@XZ$0 proc near
.text$x:00004DB4                                         ; DATA XREF: .xdata$x:00008120o
.text$x:00004DB4                 mov     ecx, [ebp-10h]  ; this
.text$x:00004DB7                 jmp     ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base(void)
.text$x:00004DB7 __unwindfunclet$??1facet@locale@std@@MAE@XZ$0 endp
.text$x:00004DB7
.text$x:00004DBC
.text$x:00004DBC ; =============== S U B R O U T I N E =======================================
.text$x:00004DBC
.text$x:00004DBC
.text$x:00004DBC __ehhandler$??1facet@locale@std@@MAE@XZ proc near
.text$x:00004DBC                                         ; DATA XREF: std::locale::facet::~facet(void)+5o
.text$x:00004DBC
.text$x:00004DBC arg_4           = dword ptr  8
.text$x:00004DBC
.text$x:00004DBC                 mov     edx, [esp+arg_4]
.text$x:00004DC0                 lea     eax, [edx+0Ch]
.text$x:00004DC3                 mov     ecx, [edx-8]
.text$x:00004DC6                 xor     ecx, eax
.text$x:00004DC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004DCD                 mov     eax, offset __ehfuncinfo$??1facet@locale@std@@MAE@XZ
.text$x:00004DD2                 jmp     ___CxxFrameHandler3
.text$x:00004DD2 __ehhandler$??1facet@locale@std@@MAE@XZ endp
.text$x:00004DD2
.text$x:00004DD2 ; ---------------------------------------------------------------------------
.text$x:00004DD7                 align 4
.text$x:00004DD7 _text$x         ends
.text$x:00004DD7
.text$mn:00004DD8 ; ===========================================================================
.text$mn:00004DD8
.text$mn:00004DD8 ; Segment type: Pure code
.text$mn:00004DD8 ; Segment permissions: Read/Execute
.text$mn:00004DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00004DD8                 assume cs:_text$mn
.text$mn:00004DD8                 ;org 4DD8h
.text$mn:00004DD8 ; COMDAT (pick any)
.text$mn:00004DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DD8
.text$mn:00004DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DD8
.text$mn:00004DD8 ; Attributes: bp-based frame
.text$mn:00004DD8
.text$mn:00004DD8 ; _DWORD __thiscall std::ios_base::failure::~failure(std::ios_base::failure *__hidden this)
.text$mn:00004DD8                 public ??1failure@ios_base@std@@UAE@XZ
.text$mn:00004DD8 ??1failure@ios_base@std@@UAE@XZ proc near
.text$mn:00004DD8                                         ; CODE XREF: std::ios_base::failure::`scalar deleting destructor'(uint)+Ap
.text$mn:00004DD8                                         ; DATA XREF: .xdata$x:00008EFCo
.text$mn:00004DD8
.text$mn:00004DD8 var_10          = dword ptr -10h
.text$mn:00004DD8 var_C           = dword ptr -0Ch
.text$mn:00004DD8 var_4           = dword ptr -4
.text$mn:00004DD8
.text$mn:00004DD8                 push    ebp
.text$mn:00004DD9                 mov     ebp, esp
.text$mn:00004DDB                 push    0FFFFFFFFh
.text$mn:00004DDD                 push    offset __ehhandler$??1failure@ios_base@std@@UAE@XZ
.text$mn:00004DE2                 mov     eax, large fs:0
.text$mn:00004DE8                 push    eax
.text$mn:00004DE9                 push    ecx
.text$mn:00004DEA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004DEF                 xor     eax, ebp
.text$mn:00004DF1                 push    eax
.text$mn:00004DF2                 lea     eax, [ebp+var_C]
.text$mn:00004DF5                 mov     large fs:0, eax
.text$mn:00004DFB                 mov     [ebp+var_10], ecx
.text$mn:00004DFE                 mov     [ebp+var_4], 0
.text$mn:00004E05                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004E0C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004E0F                 call    ??1system_error@std@@UAE@XZ ; std::system_error::~system_error(void)
.text$mn:00004E14                 mov     ecx, [ebp+var_C]
.text$mn:00004E17                 mov     large fs:0, ecx
.text$mn:00004E1E                 pop     ecx
.text$mn:00004E1F                 mov     esp, ebp
.text$mn:00004E21                 pop     ebp
.text$mn:00004E22                 retn
.text$mn:00004E22 ??1failure@ios_base@std@@UAE@XZ endp
.text$mn:00004E22
.text$mn:00004E22 ; ---------------------------------------------------------------------------
.text$mn:00004E23                 align 4
.text$mn:00004E23 _text$mn        ends
.text$mn:00004E23
.text$x:00004E24 ; ===========================================================================
.text$x:00004E24
.text$x:00004E24 ; Segment type: Pure code
.text$x:00004E24 ; Segment permissions: Read/Execute
.text$x:00004E24 _text$x         segment para public 'CODE' use32
.text$x:00004E24                 assume cs:_text$x
.text$x:00004E24                 ;org 4E24h
.text$x:00004E24 ; COMDAT (pick associative to section at 4DD8)
.text$x:00004E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004E24
.text$x:00004E24 ; =============== S U B R O U T I N E =======================================
.text$x:00004E24
.text$x:00004E24
.text$x:00004E24 __unwindfunclet$??1failure@ios_base@std@@UAE@XZ$0 proc near
.text$x:00004E24                                         ; DATA XREF: .xdata$x:000085B4o
.text$x:00004E24                 mov     ecx, [ebp-10h]  ; this
.text$x:00004E27                 jmp     ??1system_error@std@@UAE@XZ ; std::system_error::~system_error(void)
.text$x:00004E27 __unwindfunclet$??1failure@ios_base@std@@UAE@XZ$0 endp
.text$x:00004E27
.text$x:00004E2C
.text$x:00004E2C ; =============== S U B R O U T I N E =======================================
.text$x:00004E2C
.text$x:00004E2C
.text$x:00004E2C __ehhandler$??1failure@ios_base@std@@UAE@XZ proc near
.text$x:00004E2C                                         ; DATA XREF: std::ios_base::failure::~failure(void)+5o
.text$x:00004E2C
.text$x:00004E2C arg_4           = dword ptr  8
.text$x:00004E2C
.text$x:00004E2C                 mov     edx, [esp+arg_4]
.text$x:00004E30                 lea     eax, [edx+0Ch]
.text$x:00004E33                 mov     ecx, [edx-8]
.text$x:00004E36                 xor     ecx, eax
.text$x:00004E38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004E3D                 mov     eax, offset __ehfuncinfo$??1failure@ios_base@std@@UAE@XZ
.text$x:00004E42                 jmp     ___CxxFrameHandler3
.text$x:00004E42 __ehhandler$??1failure@ios_base@std@@UAE@XZ endp
.text$x:00004E42
.text$x:00004E42 ; ---------------------------------------------------------------------------
.text$x:00004E47                 align 4
.text$x:00004E47 _text$x         ends
.text$x:00004E47
.text$mn:00004E48 ; ===========================================================================
.text$mn:00004E48
.text$mn:00004E48 ; Segment type: Pure code
.text$mn:00004E48 ; Segment permissions: Read/Execute
.text$mn:00004E48 _text$mn        segment para public 'CODE' use32
.text$mn:00004E48                 assume cs:_text$mn
.text$mn:00004E48                 ;org 4E48h
.text$mn:00004E48 ; COMDAT (pick any)
.text$mn:00004E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E48
.text$mn:00004E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E48
.text$mn:00004E48 ; Attributes: bp-based frame
.text$mn:00004E48
.text$mn:00004E48 ; _DWORD __thiscall std::locale::~locale(std::locale *__hidden this)
.text$mn:00004E48                 public ??1locale@std@@QAE@XZ
.text$mn:00004E48 ??1locale@std@@QAE@XZ proc near         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+DBp
.text$mn:00004E48                                         ; __unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2+3j ...
.text$mn:00004E48
.text$mn:00004E48 var_4           = dword ptr -4
.text$mn:00004E48
.text$mn:00004E48                 push    ebp
.text$mn:00004E49                 mov     ebp, esp
.text$mn:00004E4B                 push    ecx
.text$mn:00004E4C                 mov     [ebp+var_4], ecx
.text$mn:00004E4F                 mov     eax, [ebp+var_4]
.text$mn:00004E52                 cmp     dword ptr [eax], 0
.text$mn:00004E55                 jz      short loc_4E71
.text$mn:00004E57                 mov     ecx, [ebp+var_4]
.text$mn:00004E5A                 mov     edx, [ecx]
.text$mn:00004E5C                 mov     eax, [ebp+var_4]
.text$mn:00004E5F                 mov     edx, [edx]
.text$mn:00004E61                 mov     ecx, [eax]
.text$mn:00004E63                 mov     eax, [edx+8]
.text$mn:00004E66                 call    eax
.text$mn:00004E68                 push    eax             ; Memory
.text$mn:00004E69                 call    ??$_DebugHeapDelete@V_Facet_base@std@@@std@@YAXPAV_Facet_base@0@@Z ; std::_DebugHeapDelete<std::_Facet_base>(std::_Facet_base *)
.text$mn:00004E6E                 add     esp, 4
.text$mn:00004E71
.text$mn:00004E71 loc_4E71:                               ; CODE XREF: std::locale::~locale(void)+Dj
.text$mn:00004E71                 mov     esp, ebp
.text$mn:00004E73                 pop     ebp
.text$mn:00004E74                 retn
.text$mn:00004E74 ??1locale@std@@QAE@XZ endp
.text$mn:00004E74
.text$mn:00004E74 ; ---------------------------------------------------------------------------
.text$mn:00004E75                 align 4
.text$mn:00004E75 _text$mn        ends
.text$mn:00004E75
.text$mn:00004E78 ; ===========================================================================
.text$mn:00004E78
.text$mn:00004E78 ; Segment type: Pure code
.text$mn:00004E78 ; Segment permissions: Read/Execute
.text$mn:00004E78 _text$mn        segment para public 'CODE' use32
.text$mn:00004E78                 assume cs:_text$mn
.text$mn:00004E78                 ;org 4E78h
.text$mn:00004E78 ; COMDAT (pick any)
.text$mn:00004E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E78
.text$mn:00004E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E78
.text$mn:00004E78 ; Attributes: bp-based frame
.text$mn:00004E78
.text$mn:00004E78 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:00004E78                 public ??1runtime_error@std@@UAE@XZ
.text$mn:00004E78 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2+3j
.text$mn:00004E78                                         ; __unwindfunclet$??0_System_error@std@@QAE@ABV01@@Z$0+3j ...
.text$mn:00004E78
.text$mn:00004E78 var_10          = dword ptr -10h
.text$mn:00004E78 var_C           = dword ptr -0Ch
.text$mn:00004E78 var_4           = dword ptr -4
.text$mn:00004E78
.text$mn:00004E78                 push    ebp
.text$mn:00004E79                 mov     ebp, esp
.text$mn:00004E7B                 push    0FFFFFFFFh
.text$mn:00004E7D                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:00004E82                 mov     eax, large fs:0
.text$mn:00004E88                 push    eax
.text$mn:00004E89                 push    ecx
.text$mn:00004E8A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004E8F                 xor     eax, ebp
.text$mn:00004E91                 push    eax
.text$mn:00004E92                 lea     eax, [ebp+var_C]
.text$mn:00004E95                 mov     large fs:0, eax
.text$mn:00004E9B                 mov     [ebp+var_10], ecx
.text$mn:00004E9E                 mov     [ebp+var_4], 0
.text$mn:00004EA5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004EAC                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004EAF                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00004EB4                 mov     ecx, [ebp+var_C]
.text$mn:00004EB7                 mov     large fs:0, ecx
.text$mn:00004EBE                 pop     ecx
.text$mn:00004EBF                 mov     esp, ebp
.text$mn:00004EC1                 pop     ebp
.text$mn:00004EC2                 retn
.text$mn:00004EC2 ??1runtime_error@std@@UAE@XZ endp
.text$mn:00004EC2
.text$mn:00004EC2 ; ---------------------------------------------------------------------------
.text$mn:00004EC3                 align 4
.text$mn:00004EC3 _text$mn        ends
.text$mn:00004EC3
.text$x:00004EC4 ; ===========================================================================
.text$x:00004EC4
.text$x:00004EC4 ; Segment type: Pure code
.text$x:00004EC4 ; Segment permissions: Read/Execute
.text$x:00004EC4 _text$x         segment para public 'CODE' use32
.text$x:00004EC4                 assume cs:_text$x
.text$x:00004EC4                 ;org 4EC4h
.text$x:00004EC4 ; COMDAT (pick associative to section at 4E78)
.text$x:00004EC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004EC4
.text$x:00004EC4 ; =============== S U B R O U T I N E =======================================
.text$x:00004EC4
.text$x:00004EC4
.text$x:00004EC4 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:00004EC4                                         ; DATA XREF: .xdata$x:00007FB8o
.text$x:00004EC4                 mov     ecx, [ebp-10h]  ; this
.text$x:00004EC7                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00004EC7 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:00004EC7
.text$x:00004ECC
.text$x:00004ECC ; =============== S U B R O U T I N E =======================================
.text$x:00004ECC
.text$x:00004ECC
.text$x:00004ECC __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:00004ECC                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:00004ECC
.text$x:00004ECC arg_4           = dword ptr  8
.text$x:00004ECC
.text$x:00004ECC                 mov     edx, [esp+arg_4]
.text$x:00004ED0                 lea     eax, [edx+0Ch]
.text$x:00004ED3                 mov     ecx, [edx-8]
.text$x:00004ED6                 xor     ecx, eax
.text$x:00004ED8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004EDD                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:00004EE2                 jmp     ___CxxFrameHandler3
.text$x:00004EE2 __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:00004EE2
.text$x:00004EE2 ; ---------------------------------------------------------------------------
.text$x:00004EE7                 align 4
.text$x:00004EE7 _text$x         ends
.text$x:00004EE7
.text$mn:00004EE8 ; ===========================================================================
.text$mn:00004EE8
.text$mn:00004EE8 ; Segment type: Pure code
.text$mn:00004EE8 ; Segment permissions: Read/Execute
.text$mn:00004EE8 _text$mn        segment para public 'CODE' use32
.text$mn:00004EE8                 assume cs:_text$mn
.text$mn:00004EE8                 ;org 4EE8h
.text$mn:00004EE8 ; COMDAT (pick any)
.text$mn:00004EE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EE8
.text$mn:00004EE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EE8
.text$mn:00004EE8 ; Attributes: bp-based frame
.text$mn:00004EE8
.text$mn:00004EE8 ; public: __thiscall std::basic_istream<char, struct std::char_traits<char>>::sentry::~sentry(void)
.text$mn:00004EE8                 public ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
.text$mn:00004EE8 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ proc near
.text$mn:00004EE8                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::get(void)+14Ap
.text$mn:00004EE8                                         ; __unwindfunclet$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$2+3j ...
.text$mn:00004EE8
.text$mn:00004EE8 var_10          = dword ptr -10h
.text$mn:00004EE8 var_C           = dword ptr -0Ch
.text$mn:00004EE8 var_4           = dword ptr -4
.text$mn:00004EE8
.text$mn:00004EE8                 push    ebp
.text$mn:00004EE9                 mov     ebp, esp
.text$mn:00004EEB                 push    0FFFFFFFFh
.text$mn:00004EED                 push    offset __ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
.text$mn:00004EF2                 mov     eax, large fs:0
.text$mn:00004EF8                 push    eax
.text$mn:00004EF9                 push    ecx
.text$mn:00004EFA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004EFF                 xor     eax, ebp
.text$mn:00004F01                 push    eax
.text$mn:00004F02                 lea     eax, [ebp+var_C]
.text$mn:00004F05                 mov     large fs:0, eax
.text$mn:00004F0B                 mov     [ebp+var_10], ecx
.text$mn:00004F0E                 mov     [ebp+var_4], 0
.text$mn:00004F15                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004F1C                 mov     ecx, [ebp+var_10]
.text$mn:00004F1F                 call    ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
.text$mn:00004F24                 mov     ecx, [ebp+var_C]
.text$mn:00004F27                 mov     large fs:0, ecx
.text$mn:00004F2E                 pop     ecx
.text$mn:00004F2F                 mov     esp, ebp
.text$mn:00004F31                 pop     ebp
.text$mn:00004F32                 retn
.text$mn:00004F32 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ endp
.text$mn:00004F32
.text$mn:00004F32 ; ---------------------------------------------------------------------------
.text$mn:00004F33                 align 4
.text$mn:00004F33 _text$mn        ends
.text$mn:00004F33
.text$x:00004F34 ; ===========================================================================
.text$x:00004F34
.text$x:00004F34 ; Segment type: Pure code
.text$x:00004F34 ; Segment permissions: Read/Execute
.text$x:00004F34 _text$x         segment para public 'CODE' use32
.text$x:00004F34                 assume cs:_text$x
.text$x:00004F34                 ;org 4F34h
.text$x:00004F34 ; COMDAT (pick associative to section at 4EE8)
.text$x:00004F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004F34
.text$x:00004F34 ; =============== S U B R O U T I N E =======================================
.text$x:00004F34
.text$x:00004F34
.text$x:00004F34 __unwindfunclet$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00004F34                                         ; DATA XREF: .xdata$x:00008784o
.text$x:00004F34                 mov     ecx, [ebp-10h]
.text$x:00004F37                 jmp     ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
.text$x:00004F37 __unwindfunclet$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ$0 endp
.text$x:00004F37
.text$x:00004F3C
.text$x:00004F3C ; =============== S U B R O U T I N E =======================================
.text$x:00004F3C
.text$x:00004F3C
.text$x:00004F3C __ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ proc near
.text$x:00004F3C                                         ; DATA XREF: std::basic_istream<char,std::char_traits<char>>::sentry::~sentry(void)+5o
.text$x:00004F3C
.text$x:00004F3C arg_4           = dword ptr  8
.text$x:00004F3C
.text$x:00004F3C                 mov     edx, [esp+arg_4]
.text$x:00004F40                 lea     eax, [edx+0Ch]
.text$x:00004F43                 mov     ecx, [edx-8]
.text$x:00004F46                 xor     ecx, eax
.text$x:00004F48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004F4D                 mov     eax, offset __ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
.text$x:00004F52                 jmp     ___CxxFrameHandler3
.text$x:00004F52 __ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ endp
.text$x:00004F52
.text$x:00004F52 ; ---------------------------------------------------------------------------
.text$x:00004F57                 align 4
.text$x:00004F57 _text$x         ends
.text$x:00004F57
.text$mn:00004F58 ; ===========================================================================
.text$mn:00004F58
.text$mn:00004F58 ; Segment type: Pure code
.text$mn:00004F58 ; Segment permissions: Read/Execute
.text$mn:00004F58 _text$mn        segment para public 'CODE' use32
.text$mn:00004F58                 assume cs:_text$mn
.text$mn:00004F58                 ;org 4F58h
.text$mn:00004F58 ; COMDAT (pick any)
.text$mn:00004F58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F58
.text$mn:00004F58 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F58
.text$mn:00004F58 ; Attributes: bp-based frame
.text$mn:00004F58
.text$mn:00004F58 ; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::sentry::~sentry(void)
.text$mn:00004F58                 public ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
.text$mn:00004F58 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ proc near
.text$mn:00004F58                                         ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::flush(void)+9Ap
.text$mn:00004F58                                         ; __unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0+3j
.text$mn:00004F58
.text$mn:00004F58 var_10          = dword ptr -10h
.text$mn:00004F58 var_C           = dword ptr -0Ch
.text$mn:00004F58 var_4           = dword ptr -4
.text$mn:00004F58
.text$mn:00004F58                 push    ebp
.text$mn:00004F59                 mov     ebp, esp
.text$mn:00004F5B                 push    0FFFFFFFFh
.text$mn:00004F5D                 push    offset __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
.text$mn:00004F62                 mov     eax, large fs:0
.text$mn:00004F68                 push    eax
.text$mn:00004F69                 push    ecx
.text$mn:00004F6A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004F6F                 xor     eax, ebp
.text$mn:00004F71                 push    eax
.text$mn:00004F72                 lea     eax, [ebp+var_C]
.text$mn:00004F75                 mov     large fs:0, eax
.text$mn:00004F7B                 mov     [ebp+var_10], ecx
.text$mn:00004F7E                 mov     [ebp+var_4], 0
.text$mn:00004F85                 call    ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception(void)
.text$mn:00004F8A                 movzx   eax, al
.text$mn:00004F8D                 test    eax, eax
.text$mn:00004F8F                 jnz     short loc_4F9B
.text$mn:00004F91                 mov     ecx, [ebp+var_10]
.text$mn:00004F94                 mov     ecx, [ecx]
.text$mn:00004F96                 call    ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char>>::_Osfx(void)
.text$mn:00004F9B
.text$mn:00004F9B loc_4F9B:                               ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+37j
.text$mn:00004F9B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004FA2                 mov     ecx, [ebp+var_10]
.text$mn:00004FA5                 call    ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
.text$mn:00004FAA                 mov     ecx, [ebp+var_C]
.text$mn:00004FAD                 mov     large fs:0, ecx
.text$mn:00004FB4                 pop     ecx
.text$mn:00004FB5                 mov     esp, ebp
.text$mn:00004FB7                 pop     ebp
.text$mn:00004FB8                 retn
.text$mn:00004FB8 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ endp
.text$mn:00004FB8
.text$mn:00004FB8 ; ---------------------------------------------------------------------------
.text$mn:00004FB9                 align 4
.text$mn:00004FB9 _text$mn        ends
.text$mn:00004FB9
.text$x:00004FBC ; ===========================================================================
.text$x:00004FBC
.text$x:00004FBC ; Segment type: Pure code
.text$x:00004FBC ; Segment permissions: Read/Execute
.text$x:00004FBC _text$x         segment para public 'CODE' use32
.text$x:00004FBC                 assume cs:_text$x
.text$x:00004FBC                 ;org 4FBCh
.text$x:00004FBC ; COMDAT (pick associative to section at 4F58)
.text$x:00004FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004FBC
.text$x:00004FBC ; =============== S U B R O U T I N E =======================================
.text$x:00004FBC
.text$x:00004FBC
.text$x:00004FBC __unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00004FBC                                         ; DATA XREF: .xdata$x:00008BCCo
.text$x:00004FBC                 mov     ecx, [ebp-10h]
.text$x:00004FBF                 jmp     ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char>>::_Sentry_base::~_Sentry_base(void)
.text$x:00004FBF __unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0 endp
.text$x:00004FBF
.text$x:00004FC4
.text$x:00004FC4 ; =============== S U B R O U T I N E =======================================
.text$x:00004FC4
.text$x:00004FC4
.text$x:00004FC4 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ proc near
.text$x:00004FC4                                         ; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+5o
.text$x:00004FC4
.text$x:00004FC4 arg_4           = dword ptr  8
.text$x:00004FC4
.text$x:00004FC4                 mov     edx, [esp+arg_4]
.text$x:00004FC8                 lea     eax, [edx+0Ch]
.text$x:00004FCB                 mov     ecx, [edx-8]
.text$x:00004FCE                 xor     ecx, eax
.text$x:00004FD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004FD5                 mov     eax, offset __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
.text$x:00004FDA                 jmp     ___CxxFrameHandler3
.text$x:00004FDA __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ endp
.text$x:00004FDA
.text$x:00004FDA ; ---------------------------------------------------------------------------
.text$x:00004FDF                 align 10h
.text$x:00004FDF _text$x         ends
.text$x:00004FDF
.text$mn:00004FE0 ; ===========================================================================
.text$mn:00004FE0
.text$mn:00004FE0 ; Segment type: Pure code
.text$mn:00004FE0 ; Segment permissions: Read/Execute
.text$mn:00004FE0 _text$mn        segment para public 'CODE' use32
.text$mn:00004FE0                 assume cs:_text$mn
.text$mn:00004FE0                 ;org 4FE0h
.text$mn:00004FE0 ; COMDAT (pick any)
.text$mn:00004FE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FE0
.text$mn:00004FE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FE0
.text$mn:00004FE0 ; Attributes: bp-based frame
.text$mn:00004FE0
.text$mn:00004FE0 ; _DWORD __thiscall std::system_error::~system_error(std::system_error *__hidden this)
.text$mn:00004FE0                 public ??1system_error@std@@UAE@XZ
.text$mn:00004FE0 ??1system_error@std@@UAE@XZ proc near   ; CODE XREF: __unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$0+3j
.text$mn:00004FE0                                         ; __unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$0+3j ...
.text$mn:00004FE0
.text$mn:00004FE0 var_10          = dword ptr -10h
.text$mn:00004FE0 var_C           = dword ptr -0Ch
.text$mn:00004FE0 var_4           = dword ptr -4
.text$mn:00004FE0
.text$mn:00004FE0                 push    ebp
.text$mn:00004FE1                 mov     ebp, esp
.text$mn:00004FE3                 push    0FFFFFFFFh
.text$mn:00004FE5                 push    offset __ehhandler$??1system_error@std@@UAE@XZ
.text$mn:00004FEA                 mov     eax, large fs:0
.text$mn:00004FF0                 push    eax
.text$mn:00004FF1                 push    ecx
.text$mn:00004FF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004FF7                 xor     eax, ebp
.text$mn:00004FF9                 push    eax
.text$mn:00004FFA                 lea     eax, [ebp+var_C]
.text$mn:00004FFD                 mov     large fs:0, eax
.text$mn:00005003                 mov     [ebp+var_10], ecx
.text$mn:00005006                 mov     [ebp+var_4], 0
.text$mn:0000500D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005014                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005017                 call    ??1_System_error@std@@UAE@XZ ; std::_System_error::~_System_error(void)
.text$mn:0000501C                 mov     ecx, [ebp+var_C]
.text$mn:0000501F                 mov     large fs:0, ecx
.text$mn:00005026                 pop     ecx
.text$mn:00005027                 mov     esp, ebp
.text$mn:00005029                 pop     ebp
.text$mn:0000502A                 retn
.text$mn:0000502A ??1system_error@std@@UAE@XZ endp
.text$mn:0000502A
.text$mn:0000502A ; ---------------------------------------------------------------------------
.text$mn:0000502B                 align 4
.text$mn:0000502B _text$mn        ends
.text$mn:0000502B
.text$x:0000502C ; ===========================================================================
.text$x:0000502C
.text$x:0000502C ; Segment type: Pure code
.text$x:0000502C ; Segment permissions: Read/Execute
.text$x:0000502C _text$x         segment para public 'CODE' use32
.text$x:0000502C                 assume cs:_text$x
.text$x:0000502C                 ;org 502Ch
.text$x:0000502C ; COMDAT (pick associative to section at 4FE0)
.text$x:0000502C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000502C
.text$x:0000502C ; =============== S U B R O U T I N E =======================================
.text$x:0000502C
.text$x:0000502C
.text$x:0000502C __unwindfunclet$??1system_error@std@@UAE@XZ$0 proc near
.text$x:0000502C                                         ; DATA XREF: .xdata$x:000083A4o
.text$x:0000502C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000502F                 jmp     ??1_System_error@std@@UAE@XZ ; std::_System_error::~_System_error(void)
.text$x:0000502F __unwindfunclet$??1system_error@std@@UAE@XZ$0 endp
.text$x:0000502F
.text$x:00005034
.text$x:00005034 ; =============== S U B R O U T I N E =======================================
.text$x:00005034
.text$x:00005034
.text$x:00005034 __ehhandler$??1system_error@std@@UAE@XZ proc near
.text$x:00005034                                         ; DATA XREF: std::system_error::~system_error(void)+5o
.text$x:00005034
.text$x:00005034 arg_4           = dword ptr  8
.text$x:00005034
.text$x:00005034                 mov     edx, [esp+arg_4]
.text$x:00005038                 lea     eax, [edx+0Ch]
.text$x:0000503B                 mov     ecx, [edx-8]
.text$x:0000503E                 xor     ecx, eax
.text$x:00005040                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005045                 mov     eax, offset __ehfuncinfo$??1system_error@std@@UAE@XZ
.text$x:0000504A                 jmp     ___CxxFrameHandler3
.text$x:0000504A __ehhandler$??1system_error@std@@UAE@XZ endp
.text$x:0000504A
.text$x:0000504A ; ---------------------------------------------------------------------------
.text$x:0000504F                 align 10h
.text$x:0000504F _text$x         ends
.text$x:0000504F
.text$mn:00005050 ; ===========================================================================
.text$mn:00005050
.text$mn:00005050 ; Segment type: Pure code
.text$mn:00005050 ; Segment permissions: Read/Execute
.text$mn:00005050 _text$mn        segment para public 'CODE' use32
.text$mn:00005050                 assume cs:_text$mn
.text$mn:00005050                 ;org 5050h
.text$mn:00005050 ; COMDAT (pick any)
.text$mn:00005050                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005050
.text$mn:00005050 ; =============== S U B R O U T I N E =======================================
.text$mn:00005050
.text$mn:00005050 ; Attributes: bp-based frame
.text$mn:00005050
.text$mn:00005050 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00005050                 public ??2@YAPAXIPAX@Z
.text$mn:00005050 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00005050                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00005050
.text$mn:00005050 arg_4           = dword ptr  0Ch
.text$mn:00005050
.text$mn:00005050                 push    ebp
.text$mn:00005051                 mov     ebp, esp
.text$mn:00005053                 mov     eax, [ebp+arg_4]
.text$mn:00005056                 pop     ebp
.text$mn:00005057                 retn
.text$mn:00005057 ??2@YAPAXIPAX@Z endp
.text$mn:00005057
.text$mn:00005057 _text$mn        ends
.text$mn:00005057
.text$mn:00005058 ; ===========================================================================
.text$mn:00005058
.text$mn:00005058 ; Segment type: Pure code
.text$mn:00005058 ; Segment permissions: Read/Execute
.text$mn:00005058 _text$mn        segment para public 'CODE' use32
.text$mn:00005058                 assume cs:_text$mn
.text$mn:00005058                 ;org 5058h
.text$mn:00005058 ; COMDAT (pick any)
.text$mn:00005058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005058
.text$mn:00005058 ; =============== S U B R O U T I N E =======================================
.text$mn:00005058
.text$mn:00005058 ; Attributes: bp-based frame
.text$mn:00005058
.text$mn:00005058 ; void *__cdecl std::locale::facet::operator new(unsigned int, const struct std::_DebugHeapTag_t *, char *, int)
.text$mn:00005058                 public ??2facet@locale@std@@SAPAXIABU_DebugHeapTag_t@2@PADH@Z
.text$mn:00005058 ??2facet@locale@std@@SAPAXIABU_DebugHeapTag_t@2@PADH@Z proc near
.text$mn:00005058                                         ; CODE XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+5Ap
.text$mn:00005058
.text$mn:00005058 arg_0           = dword ptr  8
.text$mn:00005058 arg_4           = dword ptr  0Ch
.text$mn:00005058 arg_8           = dword ptr  10h
.text$mn:00005058 arg_C           = dword ptr  14h
.text$mn:00005058
.text$mn:00005058                 push    ebp
.text$mn:00005059                 mov     ebp, esp
.text$mn:0000505B                 mov     eax, [ebp+arg_C]
.text$mn:0000505E                 push    eax             ; int
.text$mn:0000505F                 mov     ecx, [ebp+arg_8]
.text$mn:00005062                 push    ecx             ; char *
.text$mn:00005063                 mov     edx, [ebp+arg_4]
.text$mn:00005066                 push    edx             ; struct std::_DebugHeapTag_t *
.text$mn:00005067                 mov     eax, [ebp+arg_0]
.text$mn:0000506A                 push    eax             ; unsigned int
.text$mn:0000506B                 call    ??2@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z ; operator new(uint,std::_DebugHeapTag_t const &,char *,int)
.text$mn:00005070                 add     esp, 10h
.text$mn:00005073                 pop     ebp
.text$mn:00005074                 retn
.text$mn:00005074 ??2facet@locale@std@@SAPAXIABU_DebugHeapTag_t@2@PADH@Z endp
.text$mn:00005074
.text$mn:00005074 ; ---------------------------------------------------------------------------
.text$mn:00005075                 align 4
.text$mn:00005075 _text$mn        ends
.text$mn:00005075
.text$mn:00005078 ; ===========================================================================
.text$mn:00005078
.text$mn:00005078 ; Segment type: Pure code
.text$mn:00005078 ; Segment permissions: Read/Execute
.text$mn:00005078 _text$mn        segment para public 'CODE' use32
.text$mn:00005078                 assume cs:_text$mn
.text$mn:00005078                 ;org 5078h
.text$mn:00005078 ; COMDAT (pick any)
.text$mn:00005078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005078
.text$mn:00005078 ; =============== S U B R O U T I N E =======================================
.text$mn:00005078
.text$mn:00005078 ; Attributes: bp-based frame
.text$mn:00005078
.text$mn:00005078 ; void __cdecl operator delete(void *)
.text$mn:00005078                 public ??3@YAXPAX0@Z
.text$mn:00005078 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00005078                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00005078                 push    ebp
.text$mn:00005079                 mov     ebp, esp
.text$mn:0000507B                 pop     ebp
.text$mn:0000507C                 retn
.text$mn:0000507C ??3@YAXPAX0@Z   endp
.text$mn:0000507C
.text$mn:0000507C ; ---------------------------------------------------------------------------
.text$mn:0000507D                 align 10h
.text$mn:0000507D _text$mn        ends
.text$mn:0000507D
.text$mn:00005080 ; ===========================================================================
.text$mn:00005080
.text$mn:00005080 ; Segment type: Pure code
.text$mn:00005080 ; Segment permissions: Read/Execute
.text$mn:00005080 _text$mn        segment para public 'CODE' use32
.text$mn:00005080                 assume cs:_text$mn
.text$mn:00005080                 ;org 5080h
.text$mn:00005080 ; COMDAT (pick any)
.text$mn:00005080                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005080
.text$mn:00005080 ; =============== S U B R O U T I N E =======================================
.text$mn:00005080
.text$mn:00005080 ; Attributes: bp-based frame
.text$mn:00005080
.text$mn:00005080 ; void __cdecl std::locale::facet::operator delete(void *Memory)
.text$mn:00005080                 public ??3facet@locale@std@@SAXPAX@Z
.text$mn:00005080 ??3facet@locale@std@@SAXPAX@Z proc near ; CODE XREF: std::locale::facet::operator delete(void *,std::_DebugHeapTag_t const &,char *,int)+7p
.text$mn:00005080                                         ; std::ctype<char>::`scalar deleting destructor'(uint)+1Bp ...
.text$mn:00005080
.text$mn:00005080 Memory          = dword ptr  8
.text$mn:00005080
.text$mn:00005080                 push    ebp
.text$mn:00005081                 mov     ebp, esp
.text$mn:00005083                 mov     eax, [ebp+Memory]
.text$mn:00005086                 push    eax             ; Memory
.text$mn:00005087                 call    ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z ; std::_DebugHeapDelete<std::locale::facet>(std::locale::facet *)
.text$mn:0000508C                 add     esp, 4
.text$mn:0000508F                 pop     ebp
.text$mn:00005090                 retn
.text$mn:00005090 ??3facet@locale@std@@SAXPAX@Z endp
.text$mn:00005090
.text$mn:00005090 ; ---------------------------------------------------------------------------
.text$mn:00005091                 align 4
.text$mn:00005091 _text$mn        ends
.text$mn:00005091
.text$mn:00005094 ; ===========================================================================
.text$mn:00005094
.text$mn:00005094 ; Segment type: Pure code
.text$mn:00005094 ; Segment permissions: Read/Execute
.text$mn:00005094 _text$mn        segment para public 'CODE' use32
.text$mn:00005094                 assume cs:_text$mn
.text$mn:00005094                 ;org 5094h
.text$mn:00005094 ; COMDAT (pick any)
.text$mn:00005094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005094
.text$mn:00005094 ; =============== S U B R O U T I N E =======================================
.text$mn:00005094
.text$mn:00005094 ; Attributes: bp-based frame
.text$mn:00005094
.text$mn:00005094 ; void __cdecl std::locale::facet::operator delete(void *Memory)
.text$mn:00005094                 public ??3facet@locale@std@@SAXPAXABU_DebugHeapTag_t@2@PADH@Z
.text$mn:00005094 ??3facet@locale@std@@SAXPAXABU_DebugHeapTag_t@2@PADH@Z proc near
.text$mn:00005094                                         ; CODE XREF: __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0+12p
.text$mn:00005094
.text$mn:00005094 Memory          = dword ptr  8
.text$mn:00005094
.text$mn:00005094                 push    ebp
.text$mn:00005095                 mov     ebp, esp
.text$mn:00005097                 mov     eax, [ebp+Memory]
.text$mn:0000509A                 push    eax             ; Memory
.text$mn:0000509B                 call    ??3facet@locale@std@@SAXPAX@Z ; std::locale::facet::operator delete(void *)
.text$mn:000050A0                 add     esp, 4
.text$mn:000050A3                 pop     ebp
.text$mn:000050A4                 retn
.text$mn:000050A4 ??3facet@locale@std@@SAXPAXABU_DebugHeapTag_t@2@PADH@Z endp
.text$mn:000050A4
.text$mn:000050A4 ; ---------------------------------------------------------------------------
.text$mn:000050A5                 align 4
.text$mn:000050A5 _text$mn        ends
.text$mn:000050A5
.text$mn:000050A8 ; ===========================================================================
.text$mn:000050A8
.text$mn:000050A8 ; Segment type: Pure code
.text$mn:000050A8 ; Segment permissions: Read/Execute
.text$mn:000050A8 _text$mn        segment para public 'CODE' use32
.text$mn:000050A8                 assume cs:_text$mn
.text$mn:000050A8                 ;org 50A8h
.text$mn:000050A8 ; COMDAT (pick any)
.text$mn:000050A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050A8
.text$mn:000050A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000050A8
.text$mn:000050A8 ; Attributes: bp-based frame
.text$mn:000050A8
.text$mn:000050A8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char *Str)
.text$mn:000050A8                 public ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
.text$mn:000050A8 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z proc near
.text$mn:000050A8                                         ; CODE XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+Bp
.text$mn:000050A8                                         ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+Cp ...
.text$mn:000050A8
.text$mn:000050A8 var_4           = dword ptr -4
.text$mn:000050A8 Str             = dword ptr  8
.text$mn:000050A8
.text$mn:000050A8                 push    ebp
.text$mn:000050A9                 mov     ebp, esp
.text$mn:000050AB                 push    ecx
.text$mn:000050AC                 mov     [ebp+var_4], ecx
.text$mn:000050AF                 mov     eax, [ebp+Str]
.text$mn:000050B2                 push    eax             ; Str
.text$mn:000050B3                 mov     ecx, [ebp+var_4]
.text$mn:000050B6                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000050BB                 mov     esp, ebp
.text$mn:000050BD                 pop     ebp
.text$mn:000050BE                 retn    4
.text$mn:000050BE ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z endp
.text$mn:000050BE
.text$mn:000050BE ; ---------------------------------------------------------------------------
.text$mn:000050C1                 align 4
.text$mn:000050C1 _text$mn        ends
.text$mn:000050C1
.text$mn:000050C4 ; ===========================================================================
.text$mn:000050C4
.text$mn:000050C4 ; Segment type: Pure code
.text$mn:000050C4 ; Segment permissions: Read/Execute
.text$mn:000050C4 _text$mn        segment para public 'CODE' use32
.text$mn:000050C4                 assume cs:_text$mn
.text$mn:000050C4                 ;org 50C4h
.text$mn:000050C4 ; COMDAT (pick any)
.text$mn:000050C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050C4
.text$mn:000050C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000050C4
.text$mn:000050C4 ; Attributes: bp-based frame
.text$mn:000050C4
.text$mn:000050C4 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:000050C4                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:000050C4 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:000050C4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:000050C4                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:000050C4
.text$mn:000050C4 var_8           = dword ptr -8
.text$mn:000050C4 var_4           = dword ptr -4
.text$mn:000050C4 arg_0           = dword ptr  8
.text$mn:000050C4
.text$mn:000050C4                 push    ebp
.text$mn:000050C5                 mov     ebp, esp
.text$mn:000050C7                 sub     esp, 8
.text$mn:000050CA                 mov     [ebp+var_8], ecx
.text$mn:000050CD                 mov     eax, [ebp+var_8]
.text$mn:000050D0                 cmp     eax, [ebp+arg_0]
.text$mn:000050D3                 jnz     short loc_50DE
.text$mn:000050D5                 mov     [ebp+var_4], 1
.text$mn:000050DC                 jmp     short loc_50E5
.text$mn:000050DE ; ---------------------------------------------------------------------------
.text$mn:000050DE
.text$mn:000050DE loc_50DE:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:000050DE                 mov     [ebp+var_4], 0
.text$mn:000050E5
.text$mn:000050E5 loc_50E5:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:000050E5                 mov     al, byte ptr [ebp+var_4]
.text$mn:000050E8                 mov     esp, ebp
.text$mn:000050EA                 pop     ebp
.text$mn:000050EB                 retn    4
.text$mn:000050EB ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:000050EB
.text$mn:000050EB ; ---------------------------------------------------------------------------
.text$mn:000050EE                 align 10h
.text$mn:000050EE _text$mn        ends
.text$mn:000050EE
.text$mn:000050F0 ; ===========================================================================
.text$mn:000050F0
.text$mn:000050F0 ; Segment type: Pure code
.text$mn:000050F0 ; Segment permissions: Read/Execute
.text$mn:000050F0 _text$mn        segment para public 'CODE' use32
.text$mn:000050F0                 assume cs:_text$mn
.text$mn:000050F0                 ;org 50F0h
.text$mn:000050F0 ; COMDAT (pick any)
.text$mn:000050F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050F0
.text$mn:000050F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000050F0
.text$mn:000050F0 ; Attributes: bp-based frame
.text$mn:000050F0
.text$mn:000050F0 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:000050F0                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:000050F0 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:000050F0                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:000050F0
.text$mn:000050F0 var_8           = dword ptr -8
.text$mn:000050F0 var_4           = dword ptr -4
.text$mn:000050F0 arg_0           = dword ptr  8
.text$mn:000050F0
.text$mn:000050F0                 push    ebp
.text$mn:000050F1                 mov     ebp, esp
.text$mn:000050F3                 sub     esp, 8
.text$mn:000050F6                 push    esi
.text$mn:000050F7                 mov     [ebp+var_4], ecx
.text$mn:000050FA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000050FD                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00005102                 push    eax
.text$mn:00005103                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005106                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000510B                 mov     ecx, eax
.text$mn:0000510D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00005112                 movzx   eax, al
.text$mn:00005115                 test    eax, eax
.text$mn:00005117                 jz      short loc_5138
.text$mn:00005119                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000511C                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00005121                 mov     esi, eax
.text$mn:00005123                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005126                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000512B                 cmp     esi, eax
.text$mn:0000512D                 jnz     short loc_5138
.text$mn:0000512F                 mov     [ebp+var_8], 1
.text$mn:00005136                 jmp     short loc_513F
.text$mn:00005138 ; ---------------------------------------------------------------------------
.text$mn:00005138
.text$mn:00005138 loc_5138:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00005138                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00005138                 mov     [ebp+var_8], 0
.text$mn:0000513F
.text$mn:0000513F loc_513F:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000513F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00005142                 pop     esi
.text$mn:00005143                 mov     esp, ebp
.text$mn:00005145                 pop     ebp
.text$mn:00005146                 retn    4
.text$mn:00005146 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00005146
.text$mn:00005146 ; ---------------------------------------------------------------------------
.text$mn:00005149                 align 4
.text$mn:00005149 _text$mn        ends
.text$mn:00005149
.text$mn:0000514C ; ===========================================================================
.text$mn:0000514C
.text$mn:0000514C ; Segment type: Pure code
.text$mn:0000514C ; Segment permissions: Read/Execute
.text$mn:0000514C _text$mn        segment para public 'CODE' use32
.text$mn:0000514C                 assume cs:_text$mn
.text$mn:0000514C                 ;org 514Ch
.text$mn:0000514C ; COMDAT (pick any)
.text$mn:0000514C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000514C
.text$mn:0000514C ; =============== S U B R O U T I N E =======================================
.text$mn:0000514C
.text$mn:0000514C ; Attributes: bp-based frame
.text$mn:0000514C
.text$mn:0000514C ; public: char const & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::operator[](unsigned int)const
.text$mn:0000514C                 public ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
.text$mn:0000514C ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z proc near
.text$mn:0000514C                                         ; CODE XREF: TiXmlTextA::Blank(void)+3Bp
.text$mn:0000514C
.text$mn:0000514C var_4           = dword ptr -4
.text$mn:0000514C arg_0           = dword ptr  8
.text$mn:0000514C
.text$mn:0000514C                 push    ebp
.text$mn:0000514D                 mov     ebp, esp
.text$mn:0000514F                 push    ecx
.text$mn:00005150                 mov     [ebp+var_4], ecx
.text$mn:00005153                 mov     eax, [ebp+var_4]
.text$mn:00005156                 mov     ecx, [eax+14h]
.text$mn:00005159                 cmp     ecx, [ebp+arg_0]
.text$mn:0000515C                 jnb     short loc_5175
.text$mn:0000515E                 push    6A2h            ; unsigned int
.text$mn:00005163                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005168                 push    offset ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "string subscript out of range"
.text$mn:0000516D                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005172                 add     esp, 0Ch
.text$mn:00005175
.text$mn:00005175 loc_5175:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator[](uint)+10j
.text$mn:00005175                 mov     ecx, [ebp+var_4]
.text$mn:00005178                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000517D                 add     eax, [ebp+arg_0]
.text$mn:00005180                 mov     esp, ebp
.text$mn:00005182                 pop     ebp
.text$mn:00005183                 retn    4
.text$mn:00005183 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z endp
.text$mn:00005183
.text$mn:00005183 ; ---------------------------------------------------------------------------
.text$mn:00005186                 align 4
.text$mn:00005186 _text$mn        ends
.text$mn:00005186
.text$mn:00005188 ; ===========================================================================
.text$mn:00005188
.text$mn:00005188 ; Segment type: Pure code
.text$mn:00005188 ; Segment permissions: Read/Execute
.text$mn:00005188 _text$mn        segment para public 'CODE' use32
.text$mn:00005188                 assume cs:_text$mn
.text$mn:00005188                 ;org 5188h
.text$mn:00005188 ; COMDAT (pick any)
.text$mn:00005188                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005188
.text$mn:00005188 ; =============== S U B R O U T I N E =======================================
.text$mn:00005188
.text$mn:00005188 ; Attributes: bp-based frame
.text$mn:00005188
.text$mn:00005188 ; public: __thiscall std::locale::id::operator unsigned int(void)
.text$mn:00005188                 public ??Bid@locale@std@@QAEIXZ
.text$mn:00005188 ??Bid@locale@std@@QAEIXZ proc near      ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+43p
.text$mn:00005188
.text$mn:00005188 var_14          = byte ptr -14h
.text$mn:00005188 var_10          = dword ptr -10h
.text$mn:00005188 var_C           = dword ptr -0Ch
.text$mn:00005188 var_4           = dword ptr -4
.text$mn:00005188
.text$mn:00005188                 push    ebp
.text$mn:00005189                 mov     ebp, esp
.text$mn:0000518B                 push    0FFFFFFFFh
.text$mn:0000518D                 push    offset __ehhandler$??Bid@locale@std@@QAEIXZ
.text$mn:00005192                 mov     eax, large fs:0
.text$mn:00005198                 push    eax
.text$mn:00005199                 sub     esp, 8
.text$mn:0000519C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000051A1                 xor     eax, ebp
.text$mn:000051A3                 push    eax
.text$mn:000051A4                 lea     eax, [ebp+var_C]
.text$mn:000051A7                 mov     large fs:0, eax
.text$mn:000051AD                 mov     [ebp+var_10], ecx
.text$mn:000051B0                 mov     eax, [ebp+var_10]
.text$mn:000051B3                 cmp     dword ptr [eax], 0
.text$mn:000051B6                 jnz     short loc_51FA
.text$mn:000051B8                 push    0               ; int
.text$mn:000051BA                 lea     ecx, [ebp+var_14] ; this
.text$mn:000051BD                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000051C2                 mov     [ebp+var_4], 0
.text$mn:000051C9                 mov     ecx, [ebp+var_10]
.text$mn:000051CC                 cmp     dword ptr [ecx], 0
.text$mn:000051CF                 jnz     short loc_51EB
.text$mn:000051D1                 mov     edx, dword ptr ds:?_Id_cnt@id@locale@std@@0HA ; int std::locale::id::_Id_cnt
.text$mn:000051D7                 add     edx, 1
.text$mn:000051DA                 mov     dword ptr ds:?_Id_cnt@id@locale@std@@0HA, edx ; int std::locale::id::_Id_cnt
.text$mn:000051E0                 mov     eax, [ebp+var_10]
.text$mn:000051E3                 mov     ecx, dword ptr ds:?_Id_cnt@id@locale@std@@0HA ; int std::locale::id::_Id_cnt
.text$mn:000051E9                 mov     [eax], ecx
.text$mn:000051EB
.text$mn:000051EB loc_51EB:                               ; CODE XREF: std::locale::id::operator uint(void)+47j
.text$mn:000051EB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000051F2                 lea     ecx, [ebp+var_14] ; this
.text$mn:000051F5                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000051FA
.text$mn:000051FA loc_51FA:                               ; CODE XREF: std::locale::id::operator uint(void)+2Ej
.text$mn:000051FA                 mov     edx, [ebp+var_10]
.text$mn:000051FD                 mov     eax, [edx]
.text$mn:000051FF                 mov     ecx, [ebp+var_C]
.text$mn:00005202                 mov     large fs:0, ecx
.text$mn:00005209                 pop     ecx
.text$mn:0000520A                 mov     esp, ebp
.text$mn:0000520C                 pop     ebp
.text$mn:0000520D                 retn
.text$mn:0000520D ??Bid@locale@std@@QAEIXZ endp
.text$mn:0000520D
.text$mn:0000520D ; ---------------------------------------------------------------------------
.text$mn:0000520E                 align 10h
.text$mn:0000520E _text$mn        ends
.text$mn:0000520E
.text$x:00005210 ; ===========================================================================
.text$x:00005210
.text$x:00005210 ; Segment type: Pure code
.text$x:00005210 ; Segment permissions: Read/Execute
.text$x:00005210 _text$x         segment para public 'CODE' use32
.text$x:00005210                 assume cs:_text$x
.text$x:00005210                 ;org 5210h
.text$x:00005210 ; COMDAT (pick associative to section at 5188)
.text$x:00005210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005210
.text$x:00005210 ; =============== S U B R O U T I N E =======================================
.text$x:00005210
.text$x:00005210
.text$x:00005210 __unwindfunclet$??Bid@locale@std@@QAEIXZ$0 proc near
.text$x:00005210                                         ; DATA XREF: .xdata$x:000080C8o
.text$x:00005210                 lea     ecx, [ebp-14h]  ; this
.text$x:00005213                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00005213 __unwindfunclet$??Bid@locale@std@@QAEIXZ$0 endp
.text$x:00005213
.text$x:00005218
.text$x:00005218 ; =============== S U B R O U T I N E =======================================
.text$x:00005218
.text$x:00005218
.text$x:00005218 __ehhandler$??Bid@locale@std@@QAEIXZ proc near
.text$x:00005218                                         ; DATA XREF: std::locale::id::operator uint(void)+5o
.text$x:00005218
.text$x:00005218 arg_4           = dword ptr  8
.text$x:00005218
.text$x:00005218                 mov     edx, [esp+arg_4]
.text$x:0000521C                 lea     eax, [edx+0Ch]
.text$x:0000521F                 mov     ecx, [edx-0Ch]
.text$x:00005222                 xor     ecx, eax
.text$x:00005224                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005229                 mov     eax, offset __ehfuncinfo$??Bid@locale@std@@QAEIXZ
.text$x:0000522E                 jmp     ___CxxFrameHandler3
.text$x:0000522E __ehhandler$??Bid@locale@std@@QAEIXZ endp
.text$x:0000522E
.text$x:0000522E ; ---------------------------------------------------------------------------
.text$x:00005233                 align 4
.text$x:00005233 _text$x         ends
.text$x:00005233
.text$mn:00005234 ; ===========================================================================
.text$mn:00005234
.text$mn:00005234 ; Segment type: Pure code
.text$mn:00005234 ; Segment permissions: Read/Execute
.text$mn:00005234 _text$mn        segment para public 'CODE' use32
.text$mn:00005234                 assume cs:_text$mn
.text$mn:00005234                 ;org 5234h
.text$mn:00005234 ; COMDAT (pick any)
.text$mn:00005234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005234
.text$mn:00005234 ; =============== S U B R O U T I N E =======================================
.text$mn:00005234
.text$mn:00005234 ; Attributes: bp-based frame
.text$mn:00005234
.text$mn:00005234 ; public: __thiscall std::basic_istream<char, struct std::char_traits<char>>::sentry::operator bool(void)const
.text$mn:00005234                 public ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
.text$mn:00005234 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ proc near
.text$mn:00005234                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::get(void)+66p
.text$mn:00005234                                         ; std::basic_istream<char,std::char_traits<char>>::peek(void)+66p
.text$mn:00005234
.text$mn:00005234 var_4           = dword ptr -4
.text$mn:00005234
.text$mn:00005234                 push    ebp
.text$mn:00005235                 mov     ebp, esp
.text$mn:00005237                 push    ecx
.text$mn:00005238                 mov     [ebp+var_4], ecx
.text$mn:0000523B                 mov     eax, [ebp+var_4]
.text$mn:0000523E                 mov     al, [eax+4]
.text$mn:00005241                 mov     esp, ebp
.text$mn:00005243                 pop     ebp
.text$mn:00005244                 retn
.text$mn:00005244 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ endp
.text$mn:00005244
.text$mn:00005244 ; ---------------------------------------------------------------------------
.text$mn:00005245                 align 4
.text$mn:00005245 _text$mn        ends
.text$mn:00005245
.text$mn:00005248 ; ===========================================================================
.text$mn:00005248
.text$mn:00005248 ; Segment type: Pure code
.text$mn:00005248 ; Segment permissions: Read/Execute
.text$mn:00005248 _text$mn        segment para public 'CODE' use32
.text$mn:00005248                 assume cs:_text$mn
.text$mn:00005248                 ;org 5248h
.text$mn:00005248 ; COMDAT (pick any)
.text$mn:00005248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005248
.text$mn:00005248 ; =============== S U B R O U T I N E =======================================
.text$mn:00005248
.text$mn:00005248 ; Attributes: bp-based frame
.text$mn:00005248
.text$mn:00005248 ; public: __thiscall std::basic_ostream<char, struct std::char_traits<char>>::sentry::operator bool(void)const
.text$mn:00005248                 public ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
.text$mn:00005248 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ proc near
.text$mn:00005248                                         ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::flush(void)+54p
.text$mn:00005248
.text$mn:00005248 var_4           = dword ptr -4
.text$mn:00005248
.text$mn:00005248                 push    ebp
.text$mn:00005249                 mov     ebp, esp
.text$mn:0000524B                 push    ecx
.text$mn:0000524C                 mov     [ebp+var_4], ecx
.text$mn:0000524F                 mov     eax, [ebp+var_4]
.text$mn:00005252                 mov     al, [eax+4]
.text$mn:00005255                 mov     esp, ebp
.text$mn:00005257                 pop     ebp
.text$mn:00005258                 retn
.text$mn:00005258 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ endp
.text$mn:00005258
.text$mn:00005258 ; ---------------------------------------------------------------------------
.text$mn:00005259                 align 4
.text$mn:00005259 _text$mn        ends
.text$mn:00005259
.text$mn:0000525C ; ===========================================================================
.text$mn:0000525C
.text$mn:0000525C ; Segment type: Pure code
.text$mn:0000525C ; Segment permissions: Read/Execute
.text$mn:0000525C _text$mn        segment para public 'CODE' use32
.text$mn:0000525C                 assume cs:_text$mn
.text$mn:0000525C                 ;org 525Ch
.text$mn:0000525C ; COMDAT (pick any)
.text$mn:0000525C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000525C
.text$mn:0000525C ; =============== S U B R O U T I N E =======================================
.text$mn:0000525C
.text$mn:0000525C ; Attributes: bp-based frame
.text$mn:0000525C
.text$mn:0000525C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::operator+=(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
.text$mn:0000525C                 public ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:0000525C ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:0000525C                                         ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+140p
.text$mn:0000525C
.text$mn:0000525C var_4           = dword ptr -4
.text$mn:0000525C arg_0           = dword ptr  8
.text$mn:0000525C
.text$mn:0000525C                 push    ebp
.text$mn:0000525D                 mov     ebp, esp
.text$mn:0000525F                 push    ecx
.text$mn:00005260                 mov     [ebp+var_4], ecx
.text$mn:00005263                 mov     eax, [ebp+arg_0]
.text$mn:00005266                 push    eax
.text$mn:00005267                 mov     ecx, [ebp+var_4]
.text$mn:0000526A                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
.text$mn:0000526F                 mov     esp, ebp
.text$mn:00005271                 pop     ebp
.text$mn:00005272                 retn    4
.text$mn:00005272 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00005272
.text$mn:00005272 ; ---------------------------------------------------------------------------
.text$mn:00005275                 align 4
.text$mn:00005275 _text$mn        ends
.text$mn:00005275
.text$mn:00005278 ; ===========================================================================
.text$mn:00005278
.text$mn:00005278 ; Segment type: Pure code
.text$mn:00005278 ; Segment permissions: Read/Execute
.text$mn:00005278 _text$mn        segment para public 'CODE' use32
.text$mn:00005278                 assume cs:_text$mn
.text$mn:00005278                 ;org 5278h
.text$mn:00005278 ; COMDAT (pick any)
.text$mn:00005278                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005278
.text$mn:00005278 ; =============== S U B R O U T I N E =======================================
.text$mn:00005278
.text$mn:00005278 ; Attributes: bp-based frame
.text$mn:00005278
.text$mn:00005278 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::operator+=(char)
.text$mn:00005278                 public ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
.text$mn:00005278 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z proc near
.text$mn:00005278                                         ; CODE XREF: TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+4Fp
.text$mn:00005278                                         ; TiXmlBaseA::StreamTo(std::basic_istream<char,std::char_traits<char>> *,int,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+44p ...
.text$mn:00005278
.text$mn:00005278 var_4           = dword ptr -4
.text$mn:00005278 arg_0           = byte ptr  8
.text$mn:00005278
.text$mn:00005278                 push    ebp
.text$mn:00005279                 mov     ebp, esp
.text$mn:0000527B                 push    ecx
.text$mn:0000527C                 mov     [ebp+var_4], ecx
.text$mn:0000527F                 movzx   eax, [ebp+arg_0]
.text$mn:00005283                 push    eax             ; char
.text$mn:00005284                 push    1               ; Size
.text$mn:00005286                 mov     ecx, [ebp+var_4]
.text$mn:00005289                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(uint,char)
.text$mn:0000528E                 mov     esp, ebp
.text$mn:00005290                 pop     ebp
.text$mn:00005291                 retn    4
.text$mn:00005291 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z endp
.text$mn:00005291
.text$mn:00005291 _text$mn        ends
.text$mn:00005291
.text$mn:00005294 ; ===========================================================================
.text$mn:00005294
.text$mn:00005294 ; Segment type: Pure code
.text$mn:00005294 ; Segment permissions: Read/Execute
.text$mn:00005294 _text$mn        segment para public 'CODE' use32
.text$mn:00005294                 assume cs:_text$mn
.text$mn:00005294                 ;org 5294h
.text$mn:00005294 ; COMDAT (pick any)
.text$mn:00005294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005294
.text$mn:00005294 ; =============== S U B R O U T I N E =======================================
.text$mn:00005294
.text$mn:00005294 ; Attributes: bp-based frame
.text$mn:00005294
.text$mn:00005294 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char *Str)
.text$mn:00005294                 public ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
.text$mn:00005294 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z proc near
.text$mn:00005294                                         ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+14Dp
.text$mn:00005294
.text$mn:00005294 var_4           = dword ptr -4
.text$mn:00005294 Str             = dword ptr  8
.text$mn:00005294
.text$mn:00005294                 push    ebp
.text$mn:00005295                 mov     ebp, esp
.text$mn:00005297                 push    ecx
.text$mn:00005298                 mov     [ebp+var_4], ecx
.text$mn:0000529B                 mov     eax, [ebp+Str]
.text$mn:0000529E                 push    eax             ; Str
.text$mn:0000529F                 mov     ecx, [ebp+var_4]
.text$mn:000052A2                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *)
.text$mn:000052A7                 mov     esp, ebp
.text$mn:000052A9                 pop     ebp
.text$mn:000052AA                 retn    4
.text$mn:000052AA ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z endp
.text$mn:000052AA
.text$mn:000052AA ; ---------------------------------------------------------------------------
.text$mn:000052AD                 align 10h
.text$mn:000052AD _text$mn        ends
.text$mn:000052AD
.text$mn:000052B0 ; ===========================================================================
.text$mn:000052B0
.text$mn:000052B0 ; Segment type: Pure code
.text$mn:000052B0 ; Segment permissions: Read/Execute
.text$mn:000052B0 _text$mn        segment para public 'CODE' use32
.text$mn:000052B0                 assume cs:_text$mn
.text$mn:000052B0                 ;org 52B0h
.text$mn:000052B0 ; COMDAT (pick any)
.text$mn:000052B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000052B0
.text$mn:000052B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000052B0
.text$mn:000052B0 ; Attributes: bp-based frame
.text$mn:000052B0
.text$mn:000052B0 ; protected: virtual void * __thiscall std::ctype<char>::`scalar deleting destructor'(unsigned int)
.text$mn:000052B0                 public ??_G?$ctype@D@std@@MAEPAXI@Z
.text$mn:000052B0 ??_G?$ctype@D@std@@MAEPAXI@Z proc near
.text$mn:000052B0
.text$mn:000052B0 Memory          = dword ptr -4
.text$mn:000052B0 arg_0           = dword ptr  8
.text$mn:000052B0
.text$mn:000052B0                 push    ebp
.text$mn:000052B1                 mov     ebp, esp
.text$mn:000052B3                 push    ecx
.text$mn:000052B4                 mov     [ebp+Memory], ecx
.text$mn:000052B7                 mov     ecx, [ebp+Memory]
.text$mn:000052BA                 call    ??1?$ctype@D@std@@MAE@XZ ; std::ctype<char>::~ctype<char>(void)
.text$mn:000052BF                 mov     eax, [ebp+arg_0]
.text$mn:000052C2                 and     eax, 1
.text$mn:000052C5                 jz      short loc_52D3
.text$mn:000052C7                 mov     ecx, [ebp+Memory]
.text$mn:000052CA                 push    ecx             ; Memory
.text$mn:000052CB                 call    ??3facet@locale@std@@SAXPAX@Z ; std::locale::facet::operator delete(void *)
.text$mn:000052D0                 add     esp, 4
.text$mn:000052D3
.text$mn:000052D3 loc_52D3:                               ; CODE XREF: std::ctype<char>::`scalar deleting destructor'(uint)+15j
.text$mn:000052D3                 mov     eax, [ebp+Memory]
.text$mn:000052D6                 mov     esp, ebp
.text$mn:000052D8                 pop     ebp
.text$mn:000052D9                 retn    4
.text$mn:000052D9 ??_G?$ctype@D@std@@MAEPAXI@Z endp
.text$mn:000052D9
.text$mn:000052D9 _text$mn        ends
.text$mn:000052D9
.text$mn:000052DC ; ===========================================================================
.text$mn:000052DC
.text$mn:000052DC ; Segment type: Pure code
.text$mn:000052DC ; Segment permissions: Read/Execute
.text$mn:000052DC _text$mn        segment para public 'CODE' use32
.text$mn:000052DC                 assume cs:_text$mn
.text$mn:000052DC                 ;org 52DCh
.text$mn:000052DC ; COMDAT (pick any)
.text$mn:000052DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000052DC
.text$mn:000052DC ; =============== S U B R O U T I N E =======================================
.text$mn:000052DC
.text$mn:000052DC ; Attributes: bp-based frame
.text$mn:000052DC
.text$mn:000052DC ; public: virtual void * __thiscall TiXmlAttributeA::`scalar deleting destructor'(unsigned int)
.text$mn:000052DC                 public ??_GTiXmlAttributeA@@UAEPAXI@Z
.text$mn:000052DC ??_GTiXmlAttributeA@@UAEPAXI@Z proc near
.text$mn:000052DC
.text$mn:000052DC var_4           = dword ptr -4
.text$mn:000052DC arg_0           = dword ptr  8
.text$mn:000052DC
.text$mn:000052DC                 push    ebp
.text$mn:000052DD                 mov     ebp, esp
.text$mn:000052DF                 push    ecx
.text$mn:000052E0                 mov     [ebp+var_4], ecx
.text$mn:000052E3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000052E6                 call    ??1TiXmlAttributeA@@UAE@XZ ; TiXmlAttributeA::~TiXmlAttributeA(void)
.text$mn:000052EB                 mov     eax, [ebp+arg_0]
.text$mn:000052EE                 and     eax, 1
.text$mn:000052F1                 jz      short loc_52FF
.text$mn:000052F3                 mov     ecx, [ebp+var_4]
.text$mn:000052F6                 push    ecx             ; void *
.text$mn:000052F7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000052FC                 add     esp, 4
.text$mn:000052FF
.text$mn:000052FF loc_52FF:                               ; CODE XREF: TiXmlAttributeA::`scalar deleting destructor'(uint)+15j
.text$mn:000052FF                 mov     eax, [ebp+var_4]
.text$mn:00005302                 mov     esp, ebp
.text$mn:00005304                 pop     ebp
.text$mn:00005305                 retn    4
.text$mn:00005305 ??_GTiXmlAttributeA@@UAEPAXI@Z endp
.text$mn:00005305
.text$mn:00005305 _text$mn        ends
.text$mn:00005305
.text$mn:00005308 ; ===========================================================================
.text$mn:00005308
.text$mn:00005308 ; Segment type: Pure code
.text$mn:00005308 ; Segment permissions: Read/Execute
.text$mn:00005308 _text$mn        segment para public 'CODE' use32
.text$mn:00005308                 assume cs:_text$mn
.text$mn:00005308                 ;org 5308h
.text$mn:00005308 ; COMDAT (pick any)
.text$mn:00005308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005308
.text$mn:00005308 ; =============== S U B R O U T I N E =======================================
.text$mn:00005308
.text$mn:00005308 ; Attributes: bp-based frame
.text$mn:00005308
.text$mn:00005308 ; public: virtual void * __thiscall TiXmlBaseA::`scalar deleting destructor'(unsigned int)
.text$mn:00005308                 public ??_GTiXmlBaseA@@UAEPAXI@Z
.text$mn:00005308 ??_GTiXmlBaseA@@UAEPAXI@Z proc near
.text$mn:00005308
.text$mn:00005308 var_4           = dword ptr -4
.text$mn:00005308 arg_0           = dword ptr  8
.text$mn:00005308
.text$mn:00005308                 push    ebp
.text$mn:00005309                 mov     ebp, esp
.text$mn:0000530B                 push    ecx
.text$mn:0000530C                 mov     [ebp+var_4], ecx
.text$mn:0000530F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005312                 call    ??1TiXmlBaseA@@UAE@XZ ; TiXmlBaseA::~TiXmlBaseA(void)
.text$mn:00005317                 mov     eax, [ebp+arg_0]
.text$mn:0000531A                 and     eax, 1
.text$mn:0000531D                 jz      short loc_532B
.text$mn:0000531F                 mov     ecx, [ebp+var_4]
.text$mn:00005322                 push    ecx             ; void *
.text$mn:00005323                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005328                 add     esp, 4
.text$mn:0000532B
.text$mn:0000532B loc_532B:                               ; CODE XREF: TiXmlBaseA::`scalar deleting destructor'(uint)+15j
.text$mn:0000532B                 mov     eax, [ebp+var_4]
.text$mn:0000532E                 mov     esp, ebp
.text$mn:00005330                 pop     ebp
.text$mn:00005331                 retn    4
.text$mn:00005331 ??_GTiXmlBaseA@@UAEPAXI@Z endp
.text$mn:00005331
.text$mn:00005331 _text$mn        ends
.text$mn:00005331
.text$mn:00005334 ; ===========================================================================
.text$mn:00005334
.text$mn:00005334 ; Segment type: Pure code
.text$mn:00005334 ; Segment permissions: Read/Execute
.text$mn:00005334 _text$mn        segment para public 'CODE' use32
.text$mn:00005334                 assume cs:_text$mn
.text$mn:00005334                 ;org 5334h
.text$mn:00005334 ; COMDAT (pick any)
.text$mn:00005334                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005334
.text$mn:00005334 ; =============== S U B R O U T I N E =======================================
.text$mn:00005334
.text$mn:00005334 ; Attributes: bp-based frame
.text$mn:00005334
.text$mn:00005334 ; public: virtual void * __thiscall TiXmlCommentA::`scalar deleting destructor'(unsigned int)
.text$mn:00005334                 public ??_GTiXmlCommentA@@UAEPAXI@Z
.text$mn:00005334 ??_GTiXmlCommentA@@UAEPAXI@Z proc near
.text$mn:00005334
.text$mn:00005334 var_4           = dword ptr -4
.text$mn:00005334 arg_0           = dword ptr  8
.text$mn:00005334
.text$mn:00005334                 push    ebp
.text$mn:00005335                 mov     ebp, esp
.text$mn:00005337                 push    ecx
.text$mn:00005338                 mov     [ebp+var_4], ecx
.text$mn:0000533B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000533E                 call    ??1TiXmlCommentA@@UAE@XZ ; TiXmlCommentA::~TiXmlCommentA(void)
.text$mn:00005343                 mov     eax, [ebp+arg_0]
.text$mn:00005346                 and     eax, 1
.text$mn:00005349                 jz      short loc_5357
.text$mn:0000534B                 mov     ecx, [ebp+var_4]
.text$mn:0000534E                 push    ecx             ; void *
.text$mn:0000534F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005354                 add     esp, 4
.text$mn:00005357
.text$mn:00005357 loc_5357:                               ; CODE XREF: TiXmlCommentA::`scalar deleting destructor'(uint)+15j
.text$mn:00005357                 mov     eax, [ebp+var_4]
.text$mn:0000535A                 mov     esp, ebp
.text$mn:0000535C                 pop     ebp
.text$mn:0000535D                 retn    4
.text$mn:0000535D ??_GTiXmlCommentA@@UAEPAXI@Z endp
.text$mn:0000535D
.text$mn:0000535D _text$mn        ends
.text$mn:0000535D
.text$mn:00005360 ; ===========================================================================
.text$mn:00005360
.text$mn:00005360 ; Segment type: Pure code
.text$mn:00005360 ; Segment permissions: Read/Execute
.text$mn:00005360 _text$mn        segment para public 'CODE' use32
.text$mn:00005360                 assume cs:_text$mn
.text$mn:00005360                 ;org 5360h
.text$mn:00005360 ; COMDAT (pick any)
.text$mn:00005360                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005360
.text$mn:00005360 ; =============== S U B R O U T I N E =======================================
.text$mn:00005360
.text$mn:00005360 ; Attributes: bp-based frame
.text$mn:00005360
.text$mn:00005360 ; public: virtual void * __thiscall TiXmlDeclarationA::`scalar deleting destructor'(unsigned int)
.text$mn:00005360                 public ??_GTiXmlDeclarationA@@UAEPAXI@Z
.text$mn:00005360 ??_GTiXmlDeclarationA@@UAEPAXI@Z proc near
.text$mn:00005360
.text$mn:00005360 var_4           = dword ptr -4
.text$mn:00005360 arg_0           = dword ptr  8
.text$mn:00005360
.text$mn:00005360                 push    ebp
.text$mn:00005361                 mov     ebp, esp
.text$mn:00005363                 push    ecx
.text$mn:00005364                 mov     [ebp+var_4], ecx
.text$mn:00005367                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000536A                 call    ??1TiXmlDeclarationA@@UAE@XZ ; TiXmlDeclarationA::~TiXmlDeclarationA(void)
.text$mn:0000536F                 mov     eax, [ebp+arg_0]
.text$mn:00005372                 and     eax, 1
.text$mn:00005375                 jz      short loc_5383
.text$mn:00005377                 mov     ecx, [ebp+var_4]
.text$mn:0000537A                 push    ecx             ; void *
.text$mn:0000537B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005380                 add     esp, 4
.text$mn:00005383
.text$mn:00005383 loc_5383:                               ; CODE XREF: TiXmlDeclarationA::`scalar deleting destructor'(uint)+15j
.text$mn:00005383                 mov     eax, [ebp+var_4]
.text$mn:00005386                 mov     esp, ebp
.text$mn:00005388                 pop     ebp
.text$mn:00005389                 retn    4
.text$mn:00005389 ??_GTiXmlDeclarationA@@UAEPAXI@Z endp
.text$mn:00005389
.text$mn:00005389 _text$mn        ends
.text$mn:00005389
.text$mn:0000538C ; ===========================================================================
.text$mn:0000538C
.text$mn:0000538C ; Segment type: Pure code
.text$mn:0000538C ; Segment permissions: Read/Execute
.text$mn:0000538C _text$mn        segment para public 'CODE' use32
.text$mn:0000538C                 assume cs:_text$mn
.text$mn:0000538C                 ;org 538Ch
.text$mn:0000538C ; COMDAT (pick any)
.text$mn:0000538C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000538C
.text$mn:0000538C ; =============== S U B R O U T I N E =======================================
.text$mn:0000538C
.text$mn:0000538C ; Attributes: bp-based frame
.text$mn:0000538C
.text$mn:0000538C ; public: virtual void * __thiscall TiXmlTextA::`scalar deleting destructor'(unsigned int)
.text$mn:0000538C                 public ??_GTiXmlTextA@@UAEPAXI@Z
.text$mn:0000538C ??_GTiXmlTextA@@UAEPAXI@Z proc near
.text$mn:0000538C
.text$mn:0000538C var_4           = dword ptr -4
.text$mn:0000538C arg_0           = dword ptr  8
.text$mn:0000538C
.text$mn:0000538C                 push    ebp
.text$mn:0000538D                 mov     ebp, esp
.text$mn:0000538F                 push    ecx
.text$mn:00005390                 mov     [ebp+var_4], ecx
.text$mn:00005393                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005396                 call    ??1TiXmlTextA@@UAE@XZ ; TiXmlTextA::~TiXmlTextA(void)
.text$mn:0000539B                 mov     eax, [ebp+arg_0]
.text$mn:0000539E                 and     eax, 1
.text$mn:000053A1                 jz      short loc_53AF
.text$mn:000053A3                 mov     ecx, [ebp+var_4]
.text$mn:000053A6                 push    ecx             ; void *
.text$mn:000053A7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000053AC                 add     esp, 4
.text$mn:000053AF
.text$mn:000053AF loc_53AF:                               ; CODE XREF: TiXmlTextA::`scalar deleting destructor'(uint)+15j
.text$mn:000053AF                 mov     eax, [ebp+var_4]
.text$mn:000053B2                 mov     esp, ebp
.text$mn:000053B4                 pop     ebp
.text$mn:000053B5                 retn    4
.text$mn:000053B5 ??_GTiXmlTextA@@UAEPAXI@Z endp
.text$mn:000053B5
.text$mn:000053B5 _text$mn        ends
.text$mn:000053B5
.text$mn:000053B8 ; ===========================================================================
.text$mn:000053B8
.text$mn:000053B8 ; Segment type: Pure code
.text$mn:000053B8 ; Segment permissions: Read/Execute
.text$mn:000053B8 _text$mn        segment para public 'CODE' use32
.text$mn:000053B8                 assume cs:_text$mn
.text$mn:000053B8                 ;org 53B8h
.text$mn:000053B8 ; COMDAT (pick any)
.text$mn:000053B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000053B8
.text$mn:000053B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000053B8
.text$mn:000053B8 ; Attributes: bp-based frame
.text$mn:000053B8
.text$mn:000053B8 ; public: virtual void * __thiscall TiXmlUnknownA::`scalar deleting destructor'(unsigned int)
.text$mn:000053B8                 public ??_GTiXmlUnknownA@@UAEPAXI@Z
.text$mn:000053B8 ??_GTiXmlUnknownA@@UAEPAXI@Z proc near
.text$mn:000053B8
.text$mn:000053B8 var_4           = dword ptr -4
.text$mn:000053B8 arg_0           = dword ptr  8
.text$mn:000053B8
.text$mn:000053B8                 push    ebp
.text$mn:000053B9                 mov     ebp, esp
.text$mn:000053BB                 push    ecx
.text$mn:000053BC                 mov     [ebp+var_4], ecx
.text$mn:000053BF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000053C2                 call    ??1TiXmlUnknownA@@UAE@XZ ; TiXmlUnknownA::~TiXmlUnknownA(void)
.text$mn:000053C7                 mov     eax, [ebp+arg_0]
.text$mn:000053CA                 and     eax, 1
.text$mn:000053CD                 jz      short loc_53DB
.text$mn:000053CF                 mov     ecx, [ebp+var_4]
.text$mn:000053D2                 push    ecx             ; void *
.text$mn:000053D3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000053D8                 add     esp, 4
.text$mn:000053DB
.text$mn:000053DB loc_53DB:                               ; CODE XREF: TiXmlUnknownA::`scalar deleting destructor'(uint)+15j
.text$mn:000053DB                 mov     eax, [ebp+var_4]
.text$mn:000053DE                 mov     esp, ebp
.text$mn:000053E0                 pop     ebp
.text$mn:000053E1                 retn    4
.text$mn:000053E1 ??_GTiXmlUnknownA@@UAEPAXI@Z endp
.text$mn:000053E1
.text$mn:000053E1 _text$mn        ends
.text$mn:000053E1
.text$mn:000053E4 ; ===========================================================================
.text$mn:000053E4
.text$mn:000053E4 ; Segment type: Pure code
.text$mn:000053E4 ; Segment permissions: Read/Execute
.text$mn:000053E4 _text$mn        segment para public 'CODE' use32
.text$mn:000053E4                 assume cs:_text$mn
.text$mn:000053E4                 ;org 53E4h
.text$mn:000053E4 ; COMDAT (pick any)
.text$mn:000053E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000053E4
.text$mn:000053E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000053E4
.text$mn:000053E4 ; Attributes: bp-based frame
.text$mn:000053E4
.text$mn:000053E4 ; public: virtual void * __thiscall std::_Facet_base::`scalar deleting destructor'(unsigned int)
.text$mn:000053E4                 public ??_G_Facet_base@std@@UAEPAXI@Z
.text$mn:000053E4 ??_G_Facet_base@std@@UAEPAXI@Z proc near
.text$mn:000053E4
.text$mn:000053E4 var_4           = dword ptr -4
.text$mn:000053E4 arg_0           = dword ptr  8
.text$mn:000053E4
.text$mn:000053E4                 push    ebp
.text$mn:000053E5                 mov     ebp, esp
.text$mn:000053E7                 push    ecx
.text$mn:000053E8                 mov     [ebp+var_4], ecx
.text$mn:000053EB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000053EE                 call    ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base(void)
.text$mn:000053F3                 mov     eax, [ebp+arg_0]
.text$mn:000053F6                 and     eax, 1
.text$mn:000053F9                 jz      short loc_5407
.text$mn:000053FB                 mov     ecx, [ebp+var_4]
.text$mn:000053FE                 push    ecx             ; void *
.text$mn:000053FF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005404                 add     esp, 4
.text$mn:00005407
.text$mn:00005407 loc_5407:                               ; CODE XREF: std::_Facet_base::`scalar deleting destructor'(uint)+15j
.text$mn:00005407                 mov     eax, [ebp+var_4]
.text$mn:0000540A                 mov     esp, ebp
.text$mn:0000540C                 pop     ebp
.text$mn:0000540D                 retn    4
.text$mn:0000540D ??_G_Facet_base@std@@UAEPAXI@Z endp
.text$mn:0000540D
.text$mn:0000540D _text$mn        ends
.text$mn:0000540D
.text$mn:00005410 ; ===========================================================================
.text$mn:00005410
.text$mn:00005410 ; Segment type: Pure code
.text$mn:00005410 ; Segment permissions: Read/Execute
.text$mn:00005410 _text$mn        segment para public 'CODE' use32
.text$mn:00005410                 assume cs:_text$mn
.text$mn:00005410                 ;org 5410h
.text$mn:00005410 ; COMDAT (pick any)
.text$mn:00005410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005410
.text$mn:00005410 ; =============== S U B R O U T I N E =======================================
.text$mn:00005410
.text$mn:00005410 ; Attributes: bp-based frame
.text$mn:00005410
.text$mn:00005410 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005410                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00005410 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005410
.text$mn:00005410 var_4           = dword ptr -4
.text$mn:00005410 arg_0           = dword ptr  8
.text$mn:00005410
.text$mn:00005410                 push    ebp
.text$mn:00005411                 mov     ebp, esp
.text$mn:00005413                 push    ecx
.text$mn:00005414                 mov     [ebp+var_4], ecx
.text$mn:00005417                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000541A                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000541F                 mov     eax, [ebp+arg_0]
.text$mn:00005422                 and     eax, 1
.text$mn:00005425                 jz      short loc_5433
.text$mn:00005427                 mov     ecx, [ebp+var_4]
.text$mn:0000542A                 push    ecx             ; void *
.text$mn:0000542B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005430                 add     esp, 4
.text$mn:00005433
.text$mn:00005433 loc_5433:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005433                 mov     eax, [ebp+var_4]
.text$mn:00005436                 mov     esp, ebp
.text$mn:00005438                 pop     ebp
.text$mn:00005439                 retn    4
.text$mn:00005439 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00005439
.text$mn:00005439 _text$mn        ends
.text$mn:00005439
.text$mn:0000543C ; ===========================================================================
.text$mn:0000543C
.text$mn:0000543C ; Segment type: Pure code
.text$mn:0000543C ; Segment permissions: Read/Execute
.text$mn:0000543C _text$mn        segment para public 'CODE' use32
.text$mn:0000543C                 assume cs:_text$mn
.text$mn:0000543C                 ;org 543Ch
.text$mn:0000543C ; COMDAT (pick any)
.text$mn:0000543C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000543C
.text$mn:0000543C ; =============== S U B R O U T I N E =======================================
.text$mn:0000543C
.text$mn:0000543C ; Attributes: bp-based frame
.text$mn:0000543C
.text$mn:0000543C ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000543C                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:0000543C ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000543C
.text$mn:0000543C var_4           = dword ptr -4
.text$mn:0000543C arg_0           = dword ptr  8
.text$mn:0000543C
.text$mn:0000543C                 push    ebp
.text$mn:0000543D                 mov     ebp, esp
.text$mn:0000543F                 push    ecx
.text$mn:00005440                 mov     [ebp+var_4], ecx
.text$mn:00005443                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005446                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000544B                 mov     eax, [ebp+arg_0]
.text$mn:0000544E                 and     eax, 1
.text$mn:00005451                 jz      short loc_545F
.text$mn:00005453                 mov     ecx, [ebp+var_4]
.text$mn:00005456                 push    ecx             ; void *
.text$mn:00005457                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000545C                 add     esp, 4
.text$mn:0000545F
.text$mn:0000545F loc_545F:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000545F                 mov     eax, [ebp+var_4]
.text$mn:00005462                 mov     esp, ebp
.text$mn:00005464                 pop     ebp
.text$mn:00005465                 retn    4
.text$mn:00005465 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00005465
.text$mn:00005465 _text$mn        ends
.text$mn:00005465
.text$mn:00005468 ; ===========================================================================
.text$mn:00005468
.text$mn:00005468 ; Segment type: Pure code
.text$mn:00005468 ; Segment permissions: Read/Execute
.text$mn:00005468 _text$mn        segment para public 'CODE' use32
.text$mn:00005468                 assume cs:_text$mn
.text$mn:00005468                 ;org 5468h
.text$mn:00005468 ; COMDAT (pick any)
.text$mn:00005468                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005468
.text$mn:00005468 ; =============== S U B R O U T I N E =======================================
.text$mn:00005468
.text$mn:00005468 ; Attributes: bp-based frame
.text$mn:00005468
.text$mn:00005468 ; public: virtual void * __thiscall std::_System_error::`scalar deleting destructor'(unsigned int)
.text$mn:00005468                 public ??_G_System_error@std@@UAEPAXI@Z
.text$mn:00005468 ??_G_System_error@std@@UAEPAXI@Z proc near
.text$mn:00005468
.text$mn:00005468 var_4           = dword ptr -4
.text$mn:00005468 arg_0           = dword ptr  8
.text$mn:00005468
.text$mn:00005468                 push    ebp
.text$mn:00005469                 mov     ebp, esp
.text$mn:0000546B                 push    ecx
.text$mn:0000546C                 mov     [ebp+var_4], ecx
.text$mn:0000546F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005472                 call    ??1_System_error@std@@UAE@XZ ; std::_System_error::~_System_error(void)
.text$mn:00005477                 mov     eax, [ebp+arg_0]
.text$mn:0000547A                 and     eax, 1
.text$mn:0000547D                 jz      short loc_548B
.text$mn:0000547F                 mov     ecx, [ebp+var_4]
.text$mn:00005482                 push    ecx             ; void *
.text$mn:00005483                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005488                 add     esp, 4
.text$mn:0000548B
.text$mn:0000548B loc_548B:                               ; CODE XREF: std::_System_error::`scalar deleting destructor'(uint)+15j
.text$mn:0000548B                 mov     eax, [ebp+var_4]
.text$mn:0000548E                 mov     esp, ebp
.text$mn:00005490                 pop     ebp
.text$mn:00005491                 retn    4
.text$mn:00005491 ??_G_System_error@std@@UAEPAXI@Z endp
.text$mn:00005491
.text$mn:00005491 _text$mn        ends
.text$mn:00005491
.text$mn:00005494 ; ===========================================================================
.text$mn:00005494
.text$mn:00005494 ; Segment type: Pure code
.text$mn:00005494 ; Segment permissions: Read/Execute
.text$mn:00005494 _text$mn        segment para public 'CODE' use32
.text$mn:00005494                 assume cs:_text$mn
.text$mn:00005494                 ;org 5494h
.text$mn:00005494 ; COMDAT (pick any)
.text$mn:00005494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005494
.text$mn:00005494 ; =============== S U B R O U T I N E =======================================
.text$mn:00005494
.text$mn:00005494 ; Attributes: bp-based frame
.text$mn:00005494
.text$mn:00005494 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005494                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00005494 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005494
.text$mn:00005494 var_4           = dword ptr -4
.text$mn:00005494 arg_0           = dword ptr  8
.text$mn:00005494
.text$mn:00005494                 push    ebp
.text$mn:00005495                 mov     ebp, esp
.text$mn:00005497                 push    ecx
.text$mn:00005498                 mov     [ebp+var_4], ecx
.text$mn:0000549B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000549E                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:000054A3                 mov     eax, [ebp+arg_0]
.text$mn:000054A6                 and     eax, 1
.text$mn:000054A9                 jz      short loc_54B7
.text$mn:000054AB                 mov     ecx, [ebp+var_4]
.text$mn:000054AE                 push    ecx             ; void *
.text$mn:000054AF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000054B4                 add     esp, 4
.text$mn:000054B7
.text$mn:000054B7 loc_54B7:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000054B7                 mov     eax, [ebp+var_4]
.text$mn:000054BA                 mov     esp, ebp
.text$mn:000054BC                 pop     ebp
.text$mn:000054BD                 retn    4
.text$mn:000054BD ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:000054BD
.text$mn:000054BD _text$mn        ends
.text$mn:000054BD
.text$mn:000054C0 ; ===========================================================================
.text$mn:000054C0
.text$mn:000054C0 ; Segment type: Pure code
.text$mn:000054C0 ; Segment permissions: Read/Execute
.text$mn:000054C0 _text$mn        segment para public 'CODE' use32
.text$mn:000054C0                 assume cs:_text$mn
.text$mn:000054C0                 ;org 54C0h
.text$mn:000054C0 ; COMDAT (pick any)
.text$mn:000054C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054C0
.text$mn:000054C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054C0
.text$mn:000054C0 ; Attributes: bp-based frame
.text$mn:000054C0
.text$mn:000054C0 ; public: virtual void * __thiscall std::ctype_base::`scalar deleting destructor'(unsigned int)
.text$mn:000054C0                 public ??_Gctype_base@std@@UAEPAXI@Z
.text$mn:000054C0 ??_Gctype_base@std@@UAEPAXI@Z proc near
.text$mn:000054C0
.text$mn:000054C0 Memory          = dword ptr -4
.text$mn:000054C0 arg_0           = dword ptr  8
.text$mn:000054C0
.text$mn:000054C0                 push    ebp
.text$mn:000054C1                 mov     ebp, esp
.text$mn:000054C3                 push    ecx
.text$mn:000054C4                 mov     [ebp+Memory], ecx
.text$mn:000054C7                 mov     ecx, [ebp+Memory] ; this
.text$mn:000054CA                 call    ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base(void)
.text$mn:000054CF                 mov     eax, [ebp+arg_0]
.text$mn:000054D2                 and     eax, 1
.text$mn:000054D5                 jz      short loc_54E3
.text$mn:000054D7                 mov     ecx, [ebp+Memory]
.text$mn:000054DA                 push    ecx             ; Memory
.text$mn:000054DB                 call    ??3facet@locale@std@@SAXPAX@Z ; std::locale::facet::operator delete(void *)
.text$mn:000054E0                 add     esp, 4
.text$mn:000054E3
.text$mn:000054E3 loc_54E3:                               ; CODE XREF: std::ctype_base::`scalar deleting destructor'(uint)+15j
.text$mn:000054E3                 mov     eax, [ebp+Memory]
.text$mn:000054E6                 mov     esp, ebp
.text$mn:000054E8                 pop     ebp
.text$mn:000054E9                 retn    4
.text$mn:000054E9 ??_Gctype_base@std@@UAEPAXI@Z endp
.text$mn:000054E9
.text$mn:000054E9 _text$mn        ends
.text$mn:000054E9
.text$mn:000054EC ; ===========================================================================
.text$mn:000054EC
.text$mn:000054EC ; Segment type: Pure code
.text$mn:000054EC ; Segment permissions: Read/Execute
.text$mn:000054EC _text$mn        segment para public 'CODE' use32
.text$mn:000054EC                 assume cs:_text$mn
.text$mn:000054EC                 ;org 54ECh
.text$mn:000054EC ; COMDAT (pick any)
.text$mn:000054EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054EC
.text$mn:000054EC ; =============== S U B R O U T I N E =======================================
.text$mn:000054EC
.text$mn:000054EC ; Attributes: bp-based frame
.text$mn:000054EC
.text$mn:000054EC ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000054EC                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:000054EC ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:000054EC
.text$mn:000054EC var_4           = dword ptr -4
.text$mn:000054EC arg_0           = dword ptr  8
.text$mn:000054EC
.text$mn:000054EC                 push    ebp
.text$mn:000054ED                 mov     ebp, esp
.text$mn:000054EF                 push    ecx
.text$mn:000054F0                 mov     [ebp+var_4], ecx
.text$mn:000054F3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000054F6                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000054FB                 mov     eax, [ebp+arg_0]
.text$mn:000054FE                 and     eax, 1
.text$mn:00005501                 jz      short loc_550F
.text$mn:00005503                 mov     ecx, [ebp+var_4]
.text$mn:00005506                 push    ecx             ; void *
.text$mn:00005507                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000550C                 add     esp, 4
.text$mn:0000550F
.text$mn:0000550F loc_550F:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000550F                 mov     eax, [ebp+var_4]
.text$mn:00005512                 mov     esp, ebp
.text$mn:00005514                 pop     ebp
.text$mn:00005515                 retn    4
.text$mn:00005515 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00005515
.text$mn:00005515 _text$mn        ends
.text$mn:00005515
.text$mn:00005518 ; ===========================================================================
.text$mn:00005518
.text$mn:00005518 ; Segment type: Pure code
.text$mn:00005518 ; Segment permissions: Read/Execute
.text$mn:00005518 _text$mn        segment para public 'CODE' use32
.text$mn:00005518                 assume cs:_text$mn
.text$mn:00005518                 ;org 5518h
.text$mn:00005518 ; COMDAT (pick any)
.text$mn:00005518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005518
.text$mn:00005518 ; =============== S U B R O U T I N E =======================================
.text$mn:00005518
.text$mn:00005518 ; Attributes: bp-based frame
.text$mn:00005518
.text$mn:00005518 ; protected: virtual void * __thiscall std::locale::facet::`scalar deleting destructor'(unsigned int)
.text$mn:00005518                 public ??_Gfacet@locale@std@@MAEPAXI@Z
.text$mn:00005518 ??_Gfacet@locale@std@@MAEPAXI@Z proc near
.text$mn:00005518
.text$mn:00005518 var_4           = dword ptr -4
.text$mn:00005518 arg_0           = dword ptr  8
.text$mn:00005518
.text$mn:00005518                 push    ebp
.text$mn:00005519                 mov     ebp, esp
.text$mn:0000551B                 push    ecx
.text$mn:0000551C                 mov     [ebp+var_4], ecx
.text$mn:0000551F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005522                 call    ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet(void)
.text$mn:00005527                 mov     eax, [ebp+arg_0]
.text$mn:0000552A                 and     eax, 1
.text$mn:0000552D                 jz      short loc_553B
.text$mn:0000552F                 mov     ecx, [ebp+var_4]
.text$mn:00005532                 push    ecx             ; Memory
.text$mn:00005533                 call    ??3facet@locale@std@@SAXPAX@Z ; std::locale::facet::operator delete(void *)
.text$mn:00005538                 add     esp, 4
.text$mn:0000553B
.text$mn:0000553B loc_553B:                               ; CODE XREF: std::locale::facet::`scalar deleting destructor'(uint)+15j
.text$mn:0000553B                 mov     eax, [ebp+var_4]
.text$mn:0000553E                 mov     esp, ebp
.text$mn:00005540                 pop     ebp
.text$mn:00005541                 retn    4
.text$mn:00005541 ??_Gfacet@locale@std@@MAEPAXI@Z endp
.text$mn:00005541
.text$mn:00005541 _text$mn        ends
.text$mn:00005541
.text$mn:00005544 ; ===========================================================================
.text$mn:00005544
.text$mn:00005544 ; Segment type: Pure code
.text$mn:00005544 ; Segment permissions: Read/Execute
.text$mn:00005544 _text$mn        segment para public 'CODE' use32
.text$mn:00005544                 assume cs:_text$mn
.text$mn:00005544                 ;org 5544h
.text$mn:00005544 ; COMDAT (pick any)
.text$mn:00005544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005544
.text$mn:00005544 ; =============== S U B R O U T I N E =======================================
.text$mn:00005544
.text$mn:00005544 ; Attributes: bp-based frame
.text$mn:00005544
.text$mn:00005544 ; public: virtual void * __thiscall std::ios_base::failure::`scalar deleting destructor'(unsigned int)
.text$mn:00005544                 public ??_Gfailure@ios_base@std@@UAEPAXI@Z
.text$mn:00005544 ??_Gfailure@ios_base@std@@UAEPAXI@Z proc near
.text$mn:00005544
.text$mn:00005544 var_4           = dword ptr -4
.text$mn:00005544 arg_0           = dword ptr  8
.text$mn:00005544
.text$mn:00005544                 push    ebp
.text$mn:00005545                 mov     ebp, esp
.text$mn:00005547                 push    ecx
.text$mn:00005548                 mov     [ebp+var_4], ecx
.text$mn:0000554B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000554E                 call    ??1failure@ios_base@std@@UAE@XZ ; std::ios_base::failure::~failure(void)
.text$mn:00005553                 mov     eax, [ebp+arg_0]
.text$mn:00005556                 and     eax, 1
.text$mn:00005559                 jz      short loc_5567
.text$mn:0000555B                 mov     ecx, [ebp+var_4]
.text$mn:0000555E                 push    ecx             ; void *
.text$mn:0000555F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005564                 add     esp, 4
.text$mn:00005567
.text$mn:00005567 loc_5567:                               ; CODE XREF: std::ios_base::failure::`scalar deleting destructor'(uint)+15j
.text$mn:00005567                 mov     eax, [ebp+var_4]
.text$mn:0000556A                 mov     esp, ebp
.text$mn:0000556C                 pop     ebp
.text$mn:0000556D                 retn    4
.text$mn:0000556D ??_Gfailure@ios_base@std@@UAEPAXI@Z endp
.text$mn:0000556D
.text$mn:0000556D _text$mn        ends
.text$mn:0000556D
.text$mn:00005570 ; ===========================================================================
.text$mn:00005570
.text$mn:00005570 ; Segment type: Pure code
.text$mn:00005570 ; Segment permissions: Read/Execute
.text$mn:00005570 _text$mn        segment para public 'CODE' use32
.text$mn:00005570                 assume cs:_text$mn
.text$mn:00005570                 ;org 5570h
.text$mn:00005570 ; COMDAT (pick any)
.text$mn:00005570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005570
.text$mn:00005570 ; =============== S U B R O U T I N E =======================================
.text$mn:00005570
.text$mn:00005570 ; Attributes: bp-based frame
.text$mn:00005570
.text$mn:00005570 ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:00005570                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:00005570 ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:00005570
.text$mn:00005570 var_4           = dword ptr -4
.text$mn:00005570 arg_0           = dword ptr  8
.text$mn:00005570
.text$mn:00005570                 push    ebp
.text$mn:00005571                 mov     ebp, esp
.text$mn:00005573                 push    ecx
.text$mn:00005574                 mov     [ebp+var_4], ecx
.text$mn:00005577                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000557A                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:0000557F                 mov     eax, [ebp+arg_0]
.text$mn:00005582                 and     eax, 1
.text$mn:00005585                 jz      short loc_5593
.text$mn:00005587                 mov     ecx, [ebp+var_4]
.text$mn:0000558A                 push    ecx             ; void *
.text$mn:0000558B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005590                 add     esp, 4
.text$mn:00005593
.text$mn:00005593 loc_5593:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:00005593                 mov     eax, [ebp+var_4]
.text$mn:00005596                 mov     esp, ebp
.text$mn:00005598                 pop     ebp
.text$mn:00005599                 retn    4
.text$mn:00005599 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:00005599
.text$mn:00005599 _text$mn        ends
.text$mn:00005599
.text$mn:0000559C ; ===========================================================================
.text$mn:0000559C
.text$mn:0000559C ; Segment type: Pure code
.text$mn:0000559C ; Segment permissions: Read/Execute
.text$mn:0000559C _text$mn        segment para public 'CODE' use32
.text$mn:0000559C                 assume cs:_text$mn
.text$mn:0000559C                 ;org 559Ch
.text$mn:0000559C ; COMDAT (pick any)
.text$mn:0000559C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000559C
.text$mn:0000559C ; =============== S U B R O U T I N E =======================================
.text$mn:0000559C
.text$mn:0000559C ; Attributes: bp-based frame
.text$mn:0000559C
.text$mn:0000559C ; public: virtual void * __thiscall std::system_error::`scalar deleting destructor'(unsigned int)
.text$mn:0000559C                 public ??_Gsystem_error@std@@UAEPAXI@Z
.text$mn:0000559C ??_Gsystem_error@std@@UAEPAXI@Z proc near
.text$mn:0000559C
.text$mn:0000559C var_4           = dword ptr -4
.text$mn:0000559C arg_0           = dword ptr  8
.text$mn:0000559C
.text$mn:0000559C                 push    ebp
.text$mn:0000559D                 mov     ebp, esp
.text$mn:0000559F                 push    ecx
.text$mn:000055A0                 mov     [ebp+var_4], ecx
.text$mn:000055A3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000055A6                 call    ??1system_error@std@@UAE@XZ ; std::system_error::~system_error(void)
.text$mn:000055AB                 mov     eax, [ebp+arg_0]
.text$mn:000055AE                 and     eax, 1
.text$mn:000055B1                 jz      short loc_55BF
.text$mn:000055B3                 mov     ecx, [ebp+var_4]
.text$mn:000055B6                 push    ecx             ; void *
.text$mn:000055B7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000055BC                 add     esp, 4
.text$mn:000055BF
.text$mn:000055BF loc_55BF:                               ; CODE XREF: std::system_error::`scalar deleting destructor'(uint)+15j
.text$mn:000055BF                 mov     eax, [ebp+var_4]
.text$mn:000055C2                 mov     esp, ebp
.text$mn:000055C4                 pop     ebp
.text$mn:000055C5                 retn    4
.text$mn:000055C5 ??_Gsystem_error@std@@UAEPAXI@Z endp
.text$mn:000055C5
.text$mn:000055C5 _text$mn        ends
.text$mn:000055C5
.text$di:000055C8 ; ===========================================================================
.text$di:000055C8
.text$di:000055C8 ; Segment type: Pure code
.text$di:000055C8 ; Segment permissions: Read/Execute
.text$di:000055C8 _text$di        segment para public 'CODE' use32
.text$di:000055C8                 assume cs:_text$di
.text$di:000055C8                 ;org 55C8h
.text$di:000055C8 ; COMDAT (pick any)
.text$di:000055C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000055C8
.text$di:000055C8 ; =============== S U B R O U T I N E =======================================
.text$di:000055C8
.text$di:000055C8 ; Attributes: bp-based frame
.text$di:000055C8
.text$di:000055C8 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000055C8 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000055C8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000055C8                 push    ebp
.text$di:000055C9                 mov     ebp, esp
.text$di:000055CB                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000055D0                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000055D5                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000055DA                 call    _atexit
.text$di:000055DF                 add     esp, 4
.text$di:000055E2                 pop     ebp
.text$di:000055E3                 retn
.text$di:000055E3 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000055E3
.text$di:000055E3 _text$di        ends
.text$di:000055E3
.text$di:000055E4 ; ===========================================================================
.text$di:000055E4
.text$di:000055E4 ; Segment type: Pure code
.text$di:000055E4 ; Segment permissions: Read/Execute
.text$di:000055E4 _text$di        segment para public 'CODE' use32
.text$di:000055E4                 assume cs:_text$di
.text$di:000055E4                 ;org 55E4h
.text$di:000055E4 ; COMDAT (pick any)
.text$di:000055E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000055E4
.text$di:000055E4 ; =============== S U B R O U T I N E =======================================
.text$di:000055E4
.text$di:000055E4 ; Attributes: bp-based frame
.text$di:000055E4
.text$di:000055E4 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000055E4 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000055E4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000055E4                 push    ebp
.text$di:000055E5                 mov     ebp, esp
.text$di:000055E7                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000055EC                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000055F1                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000055F6                 call    _atexit
.text$di:000055FB                 add     esp, 4
.text$di:000055FE                 pop     ebp
.text$di:000055FF                 retn
.text$di:000055FF ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000055FF
.text$di:000055FF _text$di        ends
.text$di:000055FF
.text$di:00005600 ; ===========================================================================
.text$di:00005600
.text$di:00005600 ; Segment type: Pure code
.text$di:00005600 ; Segment permissions: Read/Execute
.text$di:00005600 _text$di        segment para public 'CODE' use32
.text$di:00005600                 assume cs:_text$di
.text$di:00005600                 ;org 5600h
.text$di:00005600 ; COMDAT (pick any)
.text$di:00005600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005600
.text$di:00005600 ; =============== S U B R O U T I N E =======================================
.text$di:00005600
.text$di:00005600 ; Attributes: bp-based frame
.text$di:00005600
.text$di:00005600 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00005600 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00005600                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00005600                 push    ebp
.text$di:00005601                 mov     ebp, esp
.text$di:00005603                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00005608                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:0000560D                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00005612                 call    _atexit
.text$di:00005617                 add     esp, 4
.text$di:0000561A                 pop     ebp
.text$di:0000561B                 retn
.text$di:0000561B ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:0000561B
.text$di:0000561B _text$di        ends
.text$di:0000561B
.text$di:0000561C ; ===========================================================================
.text$di:0000561C
.text$di:0000561C ; Segment type: Pure code
.text$di:0000561C ; Segment permissions: Read/Execute
.text$di:0000561C _text$di        segment para public 'CODE' use32
.text$di:0000561C                 assume cs:_text$di
.text$di:0000561C                 ;org 561Ch
.text$di:0000561C ; COMDAT (pick any)
.text$di:0000561C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000561C
.text$di:0000561C ; =============== S U B R O U T I N E =======================================
.text$di:0000561C
.text$di:0000561C ; Attributes: bp-based frame
.text$di:0000561C
.text$di:0000561C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:0000561C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000561C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:0000561C                 push    ebp
.text$di:0000561D                 mov     ebp, esp
.text$di:0000561F                 push    0               ; unsigned int
.text$di:00005621                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00005626                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000562B                 pop     ebp
.text$di:0000562C                 retn
.text$di:0000562C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000562C
.text$di:0000562C ; ---------------------------------------------------------------------------
.text$di:0000562D                 align 10h
.text$di:0000562D _text$di        ends
.text$di:0000562D
.text$di:00005630 ; ===========================================================================
.text$di:00005630
.text$di:00005630 ; Segment type: Pure code
.text$di:00005630 ; Segment permissions: Read/Execute
.text$di:00005630 _text$di        segment para public 'CODE' use32
.text$di:00005630                 assume cs:_text$di
.text$di:00005630                 ;org 5630h
.text$di:00005630 ; COMDAT (pick any)
.text$di:00005630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005630
.text$di:00005630 ; =============== S U B R O U T I N E =======================================
.text$di:00005630
.text$di:00005630 ; Attributes: bp-based frame
.text$di:00005630
.text$di:00005630 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00005630 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005630                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00005630                 push    ebp
.text$di:00005631                 mov     ebp, esp
.text$di:00005633                 push    0               ; unsigned int
.text$di:00005635                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000563A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000563F                 pop     ebp
.text$di:00005640                 retn
.text$di:00005640 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005640
.text$di:00005640 ; ---------------------------------------------------------------------------
.text$di:00005641                 align 4
.text$di:00005641 _text$di        ends
.text$di:00005641
.text$di:00005644 ; ===========================================================================
.text$di:00005644
.text$di:00005644 ; Segment type: Pure code
.text$di:00005644 ; Segment permissions: Read/Execute
.text$di:00005644 _text$di        segment para public 'CODE' use32
.text$di:00005644                 assume cs:_text$di
.text$di:00005644                 ;org 5644h
.text$di:00005644 ; COMDAT (pick any)
.text$di:00005644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005644
.text$di:00005644 ; =============== S U B R O U T I N E =======================================
.text$di:00005644
.text$di:00005644 ; Attributes: bp-based frame
.text$di:00005644
.text$di:00005644 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00005644 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005644                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00005644                 push    ebp
.text$di:00005645                 mov     ebp, esp
.text$di:00005647                 push    0               ; unsigned int
.text$di:00005649                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:0000564E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005653                 pop     ebp
.text$di:00005654                 retn
.text$di:00005654 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005654
.text$di:00005654 ; ---------------------------------------------------------------------------
.text$di:00005655                 align 4
.text$di:00005655 _text$di        ends
.text$di:00005655
.text$di:00005658 ; ===========================================================================
.text$di:00005658
.text$di:00005658 ; Segment type: Pure code
.text$di:00005658 ; Segment permissions: Read/Execute
.text$di:00005658 _text$di        segment para public 'CODE' use32
.text$di:00005658                 assume cs:_text$di
.text$di:00005658                 ;org 5658h
.text$di:00005658 ; COMDAT (pick any)
.text$di:00005658                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005658
.text$di:00005658 ; =============== S U B R O U T I N E =======================================
.text$di:00005658
.text$di:00005658 ; Attributes: bp-based frame
.text$di:00005658
.text$di:00005658 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00005658 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005658                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00005658                 push    ebp
.text$di:00005659                 mov     ebp, esp
.text$di:0000565B                 push    0               ; unsigned int
.text$di:0000565D                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00005662                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005667                 pop     ebp
.text$di:00005668                 retn
.text$di:00005668 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005668
.text$di:00005668 ; ---------------------------------------------------------------------------
.text$di:00005669                 align 4
.text$di:00005669 _text$di        ends
.text$di:00005669
.text$di:0000566C ; ===========================================================================
.text$di:0000566C
.text$di:0000566C ; Segment type: Pure code
.text$di:0000566C ; Segment permissions: Read/Execute
.text$di:0000566C _text$di        segment para public 'CODE' use32
.text$di:0000566C                 assume cs:_text$di
.text$di:0000566C                 ;org 566Ch
.text$di:0000566C ; COMDAT (pick any)
.text$di:0000566C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000566C
.text$di:0000566C ; =============== S U B R O U T I N E =======================================
.text$di:0000566C
.text$di:0000566C ; Attributes: bp-based frame
.text$di:0000566C
.text$di:0000566C ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:0000566C ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:0000566C
.text$di:0000566C var_1           = byte ptr -1
.text$di:0000566C
.text$di:0000566C                 push    ebp
.text$di:0000566D                 mov     ebp, esp
.text$di:0000566F                 push    ecx
.text$di:00005670                 xor     eax, eax
.text$di:00005672                 mov     [ebp+var_1], al
.text$di:00005675                 mov     esp, ebp
.text$di:00005677                 pop     ebp
.text$di:00005678                 retn
.text$di:00005678 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00005678
.text$di:00005678 ; ---------------------------------------------------------------------------
.text$di:00005679                 align 4
.text$di:00005679 _text$di        ends
.text$di:00005679
.text$di:0000567C ; ===========================================================================
.text$di:0000567C
.text$di:0000567C ; Segment type: Pure code
.text$di:0000567C ; Segment permissions: Read/Execute
.text$di:0000567C _text$di        segment para public 'CODE' use32
.text$di:0000567C                 assume cs:_text$di
.text$di:0000567C                 ;org 567Ch
.text$di:0000567C ; COMDAT (pick any)
.text$di:0000567C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000567C
.text$di:0000567C ; =============== S U B R O U T I N E =======================================
.text$di:0000567C
.text$di:0000567C ; Attributes: bp-based frame
.text$di:0000567C
.text$di:0000567C ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:0000567C ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:0000567C                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:0000567C
.text$di:0000567C var_1           = byte ptr -1
.text$di:0000567C
.text$di:0000567C                 push    ebp
.text$di:0000567D                 mov     ebp, esp
.text$di:0000567F                 push    ecx
.text$di:00005680                 xor     eax, eax
.text$di:00005682                 mov     [ebp+var_1], al
.text$di:00005685                 mov     esp, ebp
.text$di:00005687                 pop     ebp
.text$di:00005688                 retn
.text$di:00005688 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00005688
.text$di:00005688 ; ---------------------------------------------------------------------------
.text$di:00005689                 align 4
.text$di:00005689 _text$di        ends
.text$di:00005689
.text$yd:0000568C ; ===========================================================================
.text$yd:0000568C
.text$yd:0000568C ; Segment type: Pure code
.text$yd:0000568C ; Segment permissions: Read/Execute
.text$yd:0000568C _text$yd        segment para public 'CODE' use32
.text$yd:0000568C                 assume cs:_text$yd
.text$yd:0000568C                 ;org 568Ch
.text$yd:0000568C ; COMDAT (pick any)
.text$yd:0000568C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:0000568C
.text$yd:0000568C ; =============== S U B R O U T I N E =======================================
.text$yd:0000568C
.text$yd:0000568C ; Attributes: bp-based frame
.text$yd:0000568C
.text$yd:0000568C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:0000568C ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:0000568C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:0000568C                 push    ebp
.text$yd:0000568D                 mov     ebp, esp
.text$yd:0000568F                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00005694                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00005699                 pop     ebp
.text$yd:0000569A                 retn
.text$yd:0000569A ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:0000569A
.text$yd:0000569A ; ---------------------------------------------------------------------------
.text$yd:0000569B                 align 4
.text$yd:0000569B _text$yd        ends
.text$yd:0000569B
.text$yd:0000569C ; ===========================================================================
.text$yd:0000569C
.text$yd:0000569C ; Segment type: Pure code
.text$yd:0000569C ; Segment permissions: Read/Execute
.text$yd:0000569C _text$yd        segment para public 'CODE' use32
.text$yd:0000569C                 assume cs:_text$yd
.text$yd:0000569C                 ;org 569Ch
.text$yd:0000569C ; COMDAT (pick any)
.text$yd:0000569C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:0000569C
.text$yd:0000569C ; =============== S U B R O U T I N E =======================================
.text$yd:0000569C
.text$yd:0000569C ; Attributes: bp-based frame
.text$yd:0000569C
.text$yd:0000569C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:0000569C ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:0000569C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:0000569C                 push    ebp
.text$yd:0000569D                 mov     ebp, esp
.text$yd:0000569F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:000056A4                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:000056A9                 pop     ebp
.text$yd:000056AA                 retn
.text$yd:000056AA ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:000056AA
.text$yd:000056AA ; ---------------------------------------------------------------------------
.text$yd:000056AB                 align 4
.text$yd:000056AB _text$yd        ends
.text$yd:000056AB
.text$yd:000056AC ; ===========================================================================
.text$yd:000056AC
.text$yd:000056AC ; Segment type: Pure code
.text$yd:000056AC ; Segment permissions: Read/Execute
.text$yd:000056AC _text$yd        segment para public 'CODE' use32
.text$yd:000056AC                 assume cs:_text$yd
.text$yd:000056AC                 ;org 56ACh
.text$yd:000056AC ; COMDAT (pick any)
.text$yd:000056AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000056AC
.text$yd:000056AC ; =============== S U B R O U T I N E =======================================
.text$yd:000056AC
.text$yd:000056AC ; Attributes: bp-based frame
.text$yd:000056AC
.text$yd:000056AC ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000056AC ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000056AC                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000056AC                 push    ebp
.text$yd:000056AD                 mov     ebp, esp
.text$yd:000056AF                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000056B4                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000056B9                 pop     ebp
.text$yd:000056BA                 retn
.text$yd:000056BA ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000056BA
.text$yd:000056BA ; ---------------------------------------------------------------------------
.text$yd:000056BB                 align 4
.text$yd:000056BB _text$yd        ends
.text$yd:000056BB
.text$mn:000056BC ; ===========================================================================
.text$mn:000056BC
.text$mn:000056BC ; Segment type: Pure code
.text$mn:000056BC ; Segment permissions: Read/Execute
.text$mn:000056BC _text$mn        segment para public 'CODE' use32
.text$mn:000056BC                 assume cs:_text$mn
.text$mn:000056BC                 ;org 56BCh
.text$mn:000056BC ; COMDAT (pick any)
.text$mn:000056BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056BC
.text$mn:000056BC ; =============== S U B R O U T I N E =======================================
.text$mn:000056BC
.text$mn:000056BC ; Attributes: bp-based frame
.text$mn:000056BC
.text$mn:000056BC ; void __thiscall TiXmlCursorA::Clear(TiXmlCursorA *__hidden this)
.text$mn:000056BC                 public ?Clear@TiXmlCursorA@@QAEXXZ
.text$mn:000056BC ?Clear@TiXmlCursorA@@QAEXXZ proc near   ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+3Cp
.text$mn:000056BC                                         ; TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)+69p ...
.text$mn:000056BC
.text$mn:000056BC var_4           = dword ptr -4
.text$mn:000056BC
.text$mn:000056BC                 push    ebp
.text$mn:000056BD                 mov     ebp, esp
.text$mn:000056BF                 push    ecx
.text$mn:000056C0                 mov     [ebp+var_4], ecx
.text$mn:000056C3                 mov     eax, [ebp+var_4]
.text$mn:000056C6                 mov     dword ptr [eax+4], 0FFFFFFFFh
.text$mn:000056CD                 mov     ecx, [ebp+var_4]
.text$mn:000056D0                 mov     dword ptr [ecx], 0FFFFFFFFh
.text$mn:000056D6                 mov     esp, ebp
.text$mn:000056D8                 pop     ebp
.text$mn:000056D9                 retn
.text$mn:000056D9 ?Clear@TiXmlCursorA@@QAEXXZ endp
.text$mn:000056D9
.text$mn:000056D9 ; ---------------------------------------------------------------------------
.text$mn:000056DA                 align 4
.text$mn:000056DA _text$mn        ends
.text$mn:000056DA
.text$mn:000056DC ; ===========================================================================
.text$mn:000056DC
.text$mn:000056DC ; Segment type: Pure code
.text$mn:000056DC ; Segment permissions: Read/Execute
.text$mn:000056DC _text$mn        segment para public 'CODE' use32
.text$mn:000056DC                 assume cs:_text$mn
.text$mn:000056DC                 ;org 56DCh
.text$mn:000056DC ; COMDAT (pick any)
.text$mn:000056DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056DC
.text$mn:000056DC ; =============== S U B R O U T I N E =======================================
.text$mn:000056DC
.text$mn:000056DC ; Attributes: bp-based frame
.text$mn:000056DC
.text$mn:000056DC ; void __thiscall TiXmlDocumentA::ClearError(TiXmlDocumentA *__hidden this)
.text$mn:000056DC                 public ?ClearError@TiXmlDocumentA@@QAEXXZ
.text$mn:000056DC ?ClearError@TiXmlDocumentA@@QAEXXZ proc near
.text$mn:000056DC                                         ; CODE XREF: TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+Cp
.text$mn:000056DC
.text$mn:000056DC var_4           = dword ptr -4
.text$mn:000056DC
.text$mn:000056DC                 push    ebp
.text$mn:000056DD                 mov     ebp, esp
.text$mn:000056DF                 push    ecx
.text$mn:000056E0                 mov     [ebp+var_4], ecx
.text$mn:000056E3                 mov     eax, [ebp+var_4]
.text$mn:000056E6                 mov     byte ptr [eax+44h], 0
.text$mn:000056EA                 mov     ecx, [ebp+var_4]
.text$mn:000056ED                 mov     dword ptr [ecx+48h], 0
.text$mn:000056F4                 push    offset ??_C@_00CNPNBAHC@?$AA@ ; Str
.text$mn:000056F9                 mov     ecx, [ebp+var_4]
.text$mn:000056FC                 add     ecx, 4Ch ; 'L'
.text$mn:000056FF                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00005704                 mov     edx, [ebp+var_4]
.text$mn:00005707                 mov     dword ptr [edx+70h], 0
.text$mn:0000570E                 mov     eax, [ebp+var_4]
.text$mn:00005711                 mov     dword ptr [eax+6Ch], 0
.text$mn:00005718                 mov     esp, ebp
.text$mn:0000571A                 pop     ebp
.text$mn:0000571B                 retn
.text$mn:0000571B ?ClearError@TiXmlDocumentA@@QAEXXZ endp
.text$mn:0000571B
.text$mn:0000571B _text$mn        ends
.text$mn:0000571B
.text$mn:0000571C ; ===========================================================================
.text$mn:0000571C
.text$mn:0000571C ; Segment type: Pure code
.text$mn:0000571C ; Segment permissions: Read/Execute
.text$mn:0000571C _text$mn        segment para public 'CODE' use32
.text$mn:0000571C                 assume cs:_text$mn
.text$mn:0000571C                 ;org 571Ch
.text$mn:0000571C ; COMDAT (pick any)
.text$mn:0000571C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000571C
.text$mn:0000571C ; =============== S U B R O U T I N E =======================================
.text$mn:0000571C
.text$mn:0000571C ; Attributes: bp-based frame
.text$mn:0000571C
.text$mn:0000571C ; const struct TiXmlCursorA *__thiscall TiXmlParsingDataA::Cursor(TiXmlParsingDataA *__hidden this)
.text$mn:0000571C                 public ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ
.text$mn:0000571C ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ proc near
.text$mn:0000571C                                         ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+62p
.text$mn:0000571C                                         ; TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+88p ...
.text$mn:0000571C
.text$mn:0000571C var_4           = dword ptr -4
.text$mn:0000571C
.text$mn:0000571C                 push    ebp
.text$mn:0000571D                 mov     ebp, esp
.text$mn:0000571F                 push    ecx
.text$mn:00005720                 mov     [ebp+var_4], ecx
.text$mn:00005723                 mov     eax, [ebp+var_4]
.text$mn:00005726                 mov     esp, ebp
.text$mn:00005728                 pop     ebp
.text$mn:00005729                 retn
.text$mn:00005729 ?Cursor@TiXmlParsingDataA@@QAEABUTiXmlCursorA@@XZ endp
.text$mn:00005729
.text$mn:00005729 ; ---------------------------------------------------------------------------
.text$mn:0000572A                 align 4
.text$mn:0000572A _text$mn        ends
.text$mn:0000572A
.text$mn:0000572C ; ===========================================================================
.text$mn:0000572C
.text$mn:0000572C ; Segment type: Pure code
.text$mn:0000572C ; Segment permissions: Read/Execute
.text$mn:0000572C _text$mn        segment para public 'CODE' use32
.text$mn:0000572C                 assume cs:_text$mn
.text$mn:0000572C                 ;org 572Ch
.text$mn:0000572C ; COMDAT (pick any)
.text$mn:0000572C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000572C
.text$mn:0000572C ; =============== S U B R O U T I N E =======================================
.text$mn:0000572C
.text$mn:0000572C ; Attributes: bp-based frame
.text$mn:0000572C
.text$mn:0000572C ; const char *__cdecl TiXmlBaseA::GetChar(const char *Str2, char *)
.text$mn:0000572C                 public ?GetChar@TiXmlBaseA@@KAPBDPBDPAD@Z
.text$mn:0000572C ?GetChar@TiXmlBaseA@@KAPBDPBDPAD@Z proc near
.text$mn:0000572C                                         ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+58p
.text$mn:0000572C                                         ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+127p
.text$mn:0000572C
.text$mn:0000572C Str2            = dword ptr  8
.text$mn:0000572C arg_4           = dword ptr  0Ch
.text$mn:0000572C
.text$mn:0000572C                 push    ebp
.text$mn:0000572D                 mov     ebp, esp
.text$mn:0000572F                 cmp     [ebp+Str2], 0
.text$mn:00005733                 jnz     short loc_574C
.text$mn:00005735                 push    0D2h ; '-'      ; Line
.text$mn:0000573A                 push    offset ??_C@_1KG@IIGNAHLC@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@ ; "c:\\workspace\\notepad-plus-plus-6.7.9."...
.text$mn:0000573F                 push    offset ??_C@_13LFIEIAHP@?$AAp?$AA?$AA@ ; Message
.text$mn:00005744                 call    __wassert
.text$mn:00005749 ; ---------------------------------------------------------------------------
.text$mn:00005749                 add     esp, 0Ch
.text$mn:0000574C
.text$mn:0000574C loc_574C:                               ; CODE XREF: TiXmlBaseA::GetChar(char const *,char *)+7j
.text$mn:0000574C                 mov     ecx, [ebp+Str2]
.text$mn:0000574F                 movsx   edx, byte ptr [ecx]
.text$mn:00005752                 cmp     edx, 26h ; '&'
.text$mn:00005755                 jnz     short loc_576B
.text$mn:00005757                 mov     eax, [ebp+arg_4]
.text$mn:0000575A                 push    eax             ; char *
.text$mn:0000575B                 mov     ecx, [ebp+Str2]
.text$mn:0000575E                 push    ecx             ; Str2
.text$mn:0000575F                 call    ?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z ; TiXmlBaseA::GetEntity(char const *,char *)
.text$mn:00005764                 add     esp, 8
.text$mn:00005767                 jmp     short loc_577B
.text$mn:00005769 ; ---------------------------------------------------------------------------
.text$mn:00005769                 jmp     short loc_577B
.text$mn:0000576B ; ---------------------------------------------------------------------------
.text$mn:0000576B
.text$mn:0000576B loc_576B:                               ; CODE XREF: TiXmlBaseA::GetChar(char const *,char *)+29j
.text$mn:0000576B                 mov     edx, [ebp+arg_4]
.text$mn:0000576E                 mov     eax, [ebp+Str2]
.text$mn:00005771                 mov     cl, [eax]
.text$mn:00005773                 mov     [edx], cl
.text$mn:00005775                 mov     eax, [ebp+Str2]
.text$mn:00005778                 add     eax, 1
.text$mn:0000577B
.text$mn:0000577B loc_577B:                               ; CODE XREF: TiXmlBaseA::GetChar(char const *,char *)+3Bj
.text$mn:0000577B                                         ; TiXmlBaseA::GetChar(char const *,char *)+3Dj
.text$mn:0000577B                 pop     ebp
.text$mn:0000577C                 retn
.text$mn:0000577C ?GetChar@TiXmlBaseA@@KAPBDPBDPAD@Z endp
.text$mn:0000577C
.text$mn:0000577C ; ---------------------------------------------------------------------------
.text$mn:0000577D                 align 10h
.text$mn:0000577D _text$mn        ends
.text$mn:0000577D
.text$mn:00005780 ; ===========================================================================
.text$mn:00005780
.text$mn:00005780 ; Segment type: Pure code
.text$mn:00005780 ; Segment permissions: Read/Execute
.text$mn:00005780 _text$mn        segment para public 'CODE' use32
.text$mn:00005780                 assume cs:_text$mn
.text$mn:00005780                 ;org 5780h
.text$mn:00005780 ; COMDAT (pick any)
.text$mn:00005780                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005780
.text$mn:00005780 ; =============== S U B R O U T I N E =======================================
.text$mn:00005780
.text$mn:00005780 ; Attributes: bp-based frame
.text$mn:00005780
.text$mn:00005780 ; bool __cdecl TiXmlBaseA::IsWhiteSpace(int C)
.text$mn:00005780                 public ?IsWhiteSpace@TiXmlBaseA@@KA_NH@Z
.text$mn:00005780 ?IsWhiteSpace@TiXmlBaseA@@KA_NH@Z proc near
.text$mn:00005780                                         ; CODE XREF: TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+30p
.text$mn:00005780                                         ; TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+1EEp
.text$mn:00005780
.text$mn:00005780 var_4           = dword ptr -4
.text$mn:00005780 C               = dword ptr  8
.text$mn:00005780
.text$mn:00005780                 push    ebp
.text$mn:00005781                 mov     ebp, esp
.text$mn:00005783                 push    ecx
.text$mn:00005784                 mov     eax, [ebp+C]
.text$mn:00005787                 push    eax             ; C
.text$mn:00005788                 call    _isspace
.text$mn:0000578D                 add     esp, 4
.text$mn:00005790                 test    eax, eax
.text$mn:00005792                 jnz     short loc_57A9
.text$mn:00005794                 cmp     [ebp+C], 0Ah
.text$mn:00005798                 jz      short loc_57A9
.text$mn:0000579A                 cmp     [ebp+C], 0Dh
.text$mn:0000579E                 jz      short loc_57A9
.text$mn:000057A0                 mov     [ebp+var_4], 0
.text$mn:000057A7                 jmp     short loc_57B0
.text$mn:000057A9 ; ---------------------------------------------------------------------------
.text$mn:000057A9
.text$mn:000057A9 loc_57A9:                               ; CODE XREF: TiXmlBaseA::IsWhiteSpace(int)+12j
.text$mn:000057A9                                         ; TiXmlBaseA::IsWhiteSpace(int)+18j ...
.text$mn:000057A9                 mov     [ebp+var_4], 1
.text$mn:000057B0
.text$mn:000057B0 loc_57B0:                               ; CODE XREF: TiXmlBaseA::IsWhiteSpace(int)+27j
.text$mn:000057B0                 mov     al, byte ptr [ebp+var_4]
.text$mn:000057B3                 mov     esp, ebp
.text$mn:000057B5                 pop     ebp
.text$mn:000057B6                 retn
.text$mn:000057B6 ?IsWhiteSpace@TiXmlBaseA@@KA_NH@Z endp
.text$mn:000057B6
.text$mn:000057B6 ; ---------------------------------------------------------------------------
.text$mn:000057B7                 align 4
.text$mn:000057B7 _text$mn        ends
.text$mn:000057B7
.text$mn:000057B8 ; ===========================================================================
.text$mn:000057B8
.text$mn:000057B8 ; Segment type: Pure code
.text$mn:000057B8 ; Segment permissions: Read/Execute
.text$mn:000057B8 _text$mn        segment para public 'CODE' use32
.text$mn:000057B8                 assume cs:_text$mn
.text$mn:000057B8                 ;org 57B8h
.text$mn:000057B8 ; COMDAT (pick any)
.text$mn:000057B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057B8
.text$mn:000057B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000057B8
.text$mn:000057B8 ; Attributes: bp-based frame
.text$mn:000057B8
.text$mn:000057B8 ; const char *__thiscall TiXmlAttributeA::Name(TiXmlAttributeA *__hidden this)
.text$mn:000057B8                 public ?Name@TiXmlAttributeA@@QBEPBDXZ
.text$mn:000057B8 ?Name@TiXmlAttributeA@@QBEPBDXZ proc near
.text$mn:000057B8                                         ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+446p
.text$mn:000057B8
.text$mn:000057B8 var_4           = dword ptr -4
.text$mn:000057B8
.text$mn:000057B8                 push    ebp
.text$mn:000057B9                 mov     ebp, esp
.text$mn:000057BB                 push    ecx
.text$mn:000057BC                 mov     [ebp+var_4], ecx
.text$mn:000057BF                 mov     ecx, [ebp+var_4]
.text$mn:000057C2                 add     ecx, 10h
.text$mn:000057C5                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:000057CA                 mov     esp, ebp
.text$mn:000057CC                 pop     ebp
.text$mn:000057CD                 retn
.text$mn:000057CD ?Name@TiXmlAttributeA@@QBEPBDXZ endp
.text$mn:000057CD
.text$mn:000057CD ; ---------------------------------------------------------------------------
.text$mn:000057CE                 align 10h
.text$mn:000057CE _text$mn        ends
.text$mn:000057CE
.text$mn:000057D0 ; ===========================================================================
.text$mn:000057D0
.text$mn:000057D0 ; Segment type: Pure code
.text$mn:000057D0 ; Segment permissions: Read/Execute
.text$mn:000057D0 _text$mn        segment para public 'CODE' use32
.text$mn:000057D0                 assume cs:_text$mn
.text$mn:000057D0                 ;org 57D0h
.text$mn:000057D0 ; COMDAT (pick any)
.text$mn:000057D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057D0
.text$mn:000057D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000057D0
.text$mn:000057D0 ; Attributes: bp-based frame
.text$mn:000057D0
.text$mn:000057D0 ; void __thiscall TiXmlAttributeA::SetDocument(TiXmlAttributeA *this, struct TiXmlDocumentA *)
.text$mn:000057D0                 public ?SetDocument@TiXmlAttributeA@@QAEXPAVTiXmlDocumentA@@@Z
.text$mn:000057D0 ?SetDocument@TiXmlAttributeA@@QAEXPAVTiXmlDocumentA@@@Z proc near
.text$mn:000057D0                                         ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+3AEp
.text$mn:000057D0
.text$mn:000057D0 var_4           = dword ptr -4
.text$mn:000057D0 arg_0           = dword ptr  8
.text$mn:000057D0
.text$mn:000057D0                 push    ebp
.text$mn:000057D1                 mov     ebp, esp
.text$mn:000057D3                 push    ecx
.text$mn:000057D4                 mov     [ebp+var_4], ecx
.text$mn:000057D7                 mov     eax, [ebp+var_4]
.text$mn:000057DA                 mov     ecx, [ebp+arg_0]
.text$mn:000057DD                 mov     [eax+0Ch], ecx
.text$mn:000057E0                 mov     esp, ebp
.text$mn:000057E2                 pop     ebp
.text$mn:000057E3                 retn    4
.text$mn:000057E3 ?SetDocument@TiXmlAttributeA@@QAEXPAVTiXmlDocumentA@@@Z endp
.text$mn:000057E3
.text$mn:000057E3 ; ---------------------------------------------------------------------------
.text$mn:000057E6                 align 4
.text$mn:000057E6 _text$mn        ends
.text$mn:000057E6
.text$mn:000057E8 ; ===========================================================================
.text$mn:000057E8
.text$mn:000057E8 ; Segment type: Pure code
.text$mn:000057E8 ; Segment permissions: Read/Execute
.text$mn:000057E8 _text$mn        segment para public 'CODE' use32
.text$mn:000057E8                 assume cs:_text$mn
.text$mn:000057E8                 ;org 57E8h
.text$mn:000057E8 ; COMDAT (pick any)
.text$mn:000057E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057E8
.text$mn:000057E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000057E8
.text$mn:000057E8 ; Attributes: bp-based frame
.text$mn:000057E8
.text$mn:000057E8 ; void __thiscall TiXmlAttributeA::SetValue(TiXmlAttributeA *this, const char *)
.text$mn:000057E8                 public ?SetValue@TiXmlAttributeA@@QAEXPBD@Z
.text$mn:000057E8 ?SetValue@TiXmlAttributeA@@QAEXPBD@Z proc near
.text$mn:000057E8                                         ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+46Cp
.text$mn:000057E8
.text$mn:000057E8 var_4           = dword ptr -4
.text$mn:000057E8 Str             = dword ptr  8
.text$mn:000057E8
.text$mn:000057E8                 push    ebp
.text$mn:000057E9                 mov     ebp, esp
.text$mn:000057EB                 push    ecx
.text$mn:000057EC                 mov     [ebp+var_4], ecx
.text$mn:000057EF                 mov     eax, [ebp+Str]
.text$mn:000057F2                 push    eax             ; Str
.text$mn:000057F3                 mov     ecx, [ebp+var_4]
.text$mn:000057F6                 add     ecx, 2Ch ; ','
.text$mn:000057F9                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:000057FE                 mov     esp, ebp
.text$mn:00005800                 pop     ebp
.text$mn:00005801                 retn    4
.text$mn:00005801 ?SetValue@TiXmlAttributeA@@QAEXPBD@Z endp
.text$mn:00005801
.text$mn:00005801 _text$mn        ends
.text$mn:00005801
.text$mn:00005804 ; ===========================================================================
.text$mn:00005804
.text$mn:00005804 ; Segment type: Pure code
.text$mn:00005804 ; Segment permissions: Read/Execute
.text$mn:00005804 _text$mn        segment para public 'CODE' use32
.text$mn:00005804                 assume cs:_text$mn
.text$mn:00005804                 ;org 5804h
.text$mn:00005804 ; COMDAT (pick any)
.text$mn:00005804                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005804
.text$mn:00005804 ; =============== S U B R O U T I N E =======================================
.text$mn:00005804
.text$mn:00005804 ; Attributes: bp-based frame
.text$mn:00005804
.text$mn:00005804 ; void __thiscall TiXmlNodeA::SetValue(TiXmlNodeA *this, const char *)
.text$mn:00005804                 public ?SetValue@TiXmlNodeA@@QAEXPBD@Z
.text$mn:00005804 ?SetValue@TiXmlNodeA@@QAEXPBD@Z proc near
.text$mn:00005804                                         ; CODE XREF: TiXmlTextA::TiXmlTextA(char const *)+47p
.text$mn:00005804
.text$mn:00005804 var_4           = dword ptr -4
.text$mn:00005804 Str             = dword ptr  8
.text$mn:00005804
.text$mn:00005804                 push    ebp
.text$mn:00005805                 mov     ebp, esp
.text$mn:00005807                 push    ecx
.text$mn:00005808                 mov     [ebp+var_4], ecx
.text$mn:0000580B                 mov     eax, [ebp+Str]
.text$mn:0000580E                 push    eax             ; Str
.text$mn:0000580F                 mov     ecx, [ebp+var_4]
.text$mn:00005812                 add     ecx, 1Ch
.text$mn:00005815                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:0000581A                 mov     esp, ebp
.text$mn:0000581C                 pop     ebp
.text$mn:0000581D                 retn    4
.text$mn:0000581D ?SetValue@TiXmlNodeA@@QAEXPBD@Z endp
.text$mn:0000581D
.text$mn:0000581D _text$mn        ends
.text$mn:0000581D
.text$mn:00005820 ; ===========================================================================
.text$mn:00005820
.text$mn:00005820 ; Segment type: Pure code
.text$mn:00005820 ; Segment permissions: Read/Execute
.text$mn:00005820 _text$mn        segment para public 'CODE' use32
.text$mn:00005820                 assume cs:_text$mn
.text$mn:00005820                 ;org 5820h
.text$mn:00005820 ; COMDAT (pick any)
.text$mn:00005820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005820
.text$mn:00005820 ; =============== S U B R O U T I N E =======================================
.text$mn:00005820
.text$mn:00005820 ; Attributes: bp-based frame
.text$mn:00005820
.text$mn:00005820 ; int __thiscall TiXmlDocumentA::TabSize(TiXmlDocumentA *__hidden this)
.text$mn:00005820                 public ?TabSize@TiXmlDocumentA@@QBEHXZ
.text$mn:00005820 ?TabSize@TiXmlDocumentA@@QBEHXZ proc near
.text$mn:00005820                                         ; CODE XREF: TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)+45p
.text$mn:00005820                                         ; TiXmlDocumentA::Parse(char const *,TiXmlParsingDataA *)+85p
.text$mn:00005820
.text$mn:00005820 var_4           = dword ptr -4
.text$mn:00005820
.text$mn:00005820                 push    ebp
.text$mn:00005821                 mov     ebp, esp
.text$mn:00005823                 push    ecx
.text$mn:00005824                 mov     [ebp+var_4], ecx
.text$mn:00005827                 mov     eax, [ebp+var_4]
.text$mn:0000582A                 mov     eax, [eax+68h]
.text$mn:0000582D                 mov     esp, ebp
.text$mn:0000582F                 pop     ebp
.text$mn:00005830                 retn
.text$mn:00005830 ?TabSize@TiXmlDocumentA@@QBEHXZ endp
.text$mn:00005830
.text$mn:00005830 ; ---------------------------------------------------------------------------
.text$mn:00005831                 align 4
.text$mn:00005831 _text$mn        ends
.text$mn:00005831
.text$mn:00005834 ; ===========================================================================
.text$mn:00005834
.text$mn:00005834 ; Segment type: Pure code
.text$mn:00005834 ; Segment permissions: Read/Execute
.text$mn:00005834 _text$mn        segment para public 'CODE' use32
.text$mn:00005834                 assume cs:_text$mn
.text$mn:00005834                 ;org 5834h
.text$mn:00005834 ; COMDAT (pick any)
.text$mn:00005834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005834
.text$mn:00005834 ; =============== S U B R O U T I N E =======================================
.text$mn:00005834
.text$mn:00005834 ; Attributes: bp-based frame
.text$mn:00005834
.text$mn:00005834 ; struct TiXmlElementA *__thiscall TiXmlNodeA::ToElement(TiXmlNodeA *__hidden this)
.text$mn:00005834                 public ?ToElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@XZ
.text$mn:00005834 ?ToElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@XZ proc near
.text$mn:00005834                                         ; CODE XREF: TiXmlDocumentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+EBp
.text$mn:00005834
.text$mn:00005834 var_8           = dword ptr -8
.text$mn:00005834 var_4           = dword ptr -4
.text$mn:00005834
.text$mn:00005834                 push    ebp
.text$mn:00005835                 mov     ebp, esp
.text$mn:00005837                 sub     esp, 8
.text$mn:0000583A                 mov     [ebp+var_4], ecx
.text$mn:0000583D                 cmp     [ebp+var_4], 0
.text$mn:00005841                 jz      short loc_5854
.text$mn:00005843                 mov     eax, [ebp+var_4]
.text$mn:00005846                 cmp     dword ptr [eax+10h], 1
.text$mn:0000584A                 jnz     short loc_5854
.text$mn:0000584C                 mov     ecx, [ebp+var_4]
.text$mn:0000584F                 mov     [ebp+var_8], ecx
.text$mn:00005852                 jmp     short loc_585B
.text$mn:00005854 ; ---------------------------------------------------------------------------
.text$mn:00005854
.text$mn:00005854 loc_5854:                               ; CODE XREF: TiXmlNodeA::ToElement(void)+Dj
.text$mn:00005854                                         ; TiXmlNodeA::ToElement(void)+16j
.text$mn:00005854                 mov     [ebp+var_8], 0
.text$mn:0000585B
.text$mn:0000585B loc_585B:                               ; CODE XREF: TiXmlNodeA::ToElement(void)+1Ej
.text$mn:0000585B                 mov     eax, [ebp+var_8]
.text$mn:0000585E                 mov     esp, ebp
.text$mn:00005860                 pop     ebp
.text$mn:00005861                 retn
.text$mn:00005861 ?ToElement@TiXmlNodeA@@QBEPAVTiXmlElementA@@XZ endp
.text$mn:00005861
.text$mn:00005861 ; ---------------------------------------------------------------------------
.text$mn:00005862                 align 4
.text$mn:00005862 _text$mn        ends
.text$mn:00005862
.text$mn:00005864 ; ===========================================================================
.text$mn:00005864
.text$mn:00005864 ; Segment type: Pure code
.text$mn:00005864 ; Segment permissions: Read/Execute
.text$mn:00005864 _text$mn        segment para public 'CODE' use32
.text$mn:00005864                 assume cs:_text$mn
.text$mn:00005864                 ;org 5864h
.text$mn:00005864 ; COMDAT (pick any)
.text$mn:00005864                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005864
.text$mn:00005864 ; =============== S U B R O U T I N E =======================================
.text$mn:00005864
.text$mn:00005864 ; Attributes: bp-based frame
.text$mn:00005864
.text$mn:00005864 ; int __thiscall TiXmlNodeA::Type(TiXmlNodeA *__hidden this)
.text$mn:00005864                 public ?Type@TiXmlNodeA@@UBEHXZ
.text$mn:00005864 ?Type@TiXmlNodeA@@UBEHXZ proc near      ; DATA XREF: .rdata:00009110o
.text$mn:00005864                                         ; .rdata:00009130o ...
.text$mn:00005864
.text$mn:00005864 var_4           = dword ptr -4
.text$mn:00005864
.text$mn:00005864                 push    ebp
.text$mn:00005865                 mov     ebp, esp
.text$mn:00005867                 push    ecx
.text$mn:00005868                 mov     [ebp+var_4], ecx
.text$mn:0000586B                 mov     eax, [ebp+var_4]
.text$mn:0000586E                 mov     eax, [eax+10h]
.text$mn:00005871                 mov     esp, ebp
.text$mn:00005873                 pop     ebp
.text$mn:00005874                 retn
.text$mn:00005874 ?Type@TiXmlNodeA@@UBEHXZ endp
.text$mn:00005874
.text$mn:00005874 ; ---------------------------------------------------------------------------
.text$mn:00005875                 align 4
.text$mn:00005875 _text$mn        ends
.text$mn:00005875
.text$mn:00005878 ; ===========================================================================
.text$mn:00005878
.text$mn:00005878 ; Segment type: Pure code
.text$mn:00005878 ; Segment permissions: Read/Execute
.text$mn:00005878 _text$mn        segment para public 'CODE' use32
.text$mn:00005878                 assume cs:_text$mn
.text$mn:00005878                 ;org 5878h
.text$mn:00005878 ; COMDAT (pick any)
.text$mn:00005878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005878
.text$mn:00005878 ; =============== S U B R O U T I N E =======================================
.text$mn:00005878
.text$mn:00005878 ; Attributes: bp-based frame
.text$mn:00005878
.text$mn:00005878 ; const char *__thiscall TiXmlAttributeA::Value(TiXmlAttributeA *__hidden this)
.text$mn:00005878                 public ?Value@TiXmlAttributeA@@QBEPBDXZ
.text$mn:00005878 ?Value@TiXmlAttributeA@@QBEPBDXZ proc near
.text$mn:00005878                                         ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+463p
.text$mn:00005878                                         ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)+18Bp ...
.text$mn:00005878
.text$mn:00005878 var_4           = dword ptr -4
.text$mn:00005878
.text$mn:00005878                 push    ebp
.text$mn:00005879                 mov     ebp, esp
.text$mn:0000587B                 push    ecx
.text$mn:0000587C                 mov     [ebp+var_4], ecx
.text$mn:0000587F                 mov     ecx, [ebp+var_4]
.text$mn:00005882                 add     ecx, 2Ch ; ','
.text$mn:00005885                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:0000588A                 mov     esp, ebp
.text$mn:0000588C                 pop     ebp
.text$mn:0000588D                 retn
.text$mn:0000588D ?Value@TiXmlAttributeA@@QBEPBDXZ endp
.text$mn:0000588D
.text$mn:0000588D ; ---------------------------------------------------------------------------
.text$mn:0000588E                 align 10h
.text$mn:0000588E _text$mn        ends
.text$mn:0000588E
.text$mn:00005890 ; ===========================================================================
.text$mn:00005890
.text$mn:00005890 ; Segment type: Pure code
.text$mn:00005890 ; Segment permissions: Read/Execute
.text$mn:00005890 _text$mn        segment para public 'CODE' use32
.text$mn:00005890                 assume cs:_text$mn
.text$mn:00005890                 ;org 5890h
.text$mn:00005890 ; COMDAT (pick any)
.text$mn:00005890                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005890
.text$mn:00005890 ; =============== S U B R O U T I N E =======================================
.text$mn:00005890
.text$mn:00005890 ; Attributes: bp-based frame
.text$mn:00005890
.text$mn:00005890 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00005890                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00005890 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00005890                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00005890
.text$mn:00005890 var_10          = byte ptr -10h
.text$mn:00005890 var_8           = dword ptr -8
.text$mn:00005890 var_1           = byte ptr -1
.text$mn:00005890
.text$mn:00005890                 push    ebp
.text$mn:00005891                 mov     ebp, esp
.text$mn:00005893                 sub     esp, 10h
.text$mn:00005896                 mov     [ebp+var_8], ecx
.text$mn:00005899                 lea     ecx, [ebp+var_1]
.text$mn:0000589C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000058A1                 push    1
.text$mn:000058A3                 lea     ecx, [ebp+var_1]
.text$mn:000058A6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000058AB                 mov     ecx, [ebp+var_8]
.text$mn:000058AE                 mov     [ecx], eax
.text$mn:000058B0                 lea     ecx, [ebp+var_10] ; this
.text$mn:000058B3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000058B8                 push    eax             ; int
.text$mn:000058B9                 mov     edx, [ebp+var_8]
.text$mn:000058BC                 mov     eax, [edx]
.text$mn:000058BE                 push    eax             ; void *
.text$mn:000058BF                 lea     ecx, [ebp+var_1]
.text$mn:000058C2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000058C7                 mov     ecx, [ebp+var_8]
.text$mn:000058CA                 mov     edx, [ecx]
.text$mn:000058CC                 mov     eax, [ebp+var_8]
.text$mn:000058CF                 mov     [edx], eax
.text$mn:000058D1                 mov     esp, ebp
.text$mn:000058D3                 pop     ebp
.text$mn:000058D4                 retn
.text$mn:000058D4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000058D4
.text$mn:000058D4 ; ---------------------------------------------------------------------------
.text$mn:000058D5                 align 4
.text$mn:000058D5 _text$mn        ends
.text$mn:000058D5
.text$mn:000058D8 ; ===========================================================================
.text$mn:000058D8
.text$mn:000058D8 ; Segment type: Pure code
.text$mn:000058D8 ; Segment permissions: Read/Execute
.text$mn:000058D8 _text$mn        segment para public 'CODE' use32
.text$mn:000058D8                 assume cs:_text$mn
.text$mn:000058D8                 ;org 58D8h
.text$mn:000058D8 ; COMDAT (pick any)
.text$mn:000058D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000058D8
.text$mn:000058D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000058D8
.text$mn:000058D8 ; Attributes: bp-based frame
.text$mn:000058D8
.text$mn:000058D8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Assign_rv(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> &&)
.text$mn:000058D8                 public ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
.text$mn:000058D8 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z proc near
.text$mn:000058D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+60p
.text$mn:000058D8
.text$mn:000058D8 var_8           = dword ptr -8
.text$mn:000058D8 var_1           = byte ptr -1
.text$mn:000058D8 arg_0           = dword ptr  8
.text$mn:000058D8
.text$mn:000058D8                 push    ebp
.text$mn:000058D9                 mov     ebp, esp
.text$mn:000058DB                 sub     esp, 8
.text$mn:000058DE                 mov     [ebp+var_8], ecx
.text$mn:000058E1                 mov     eax, [ebp+arg_0]
.text$mn:000058E4                 cmp     dword ptr [eax+18h], 10h
.text$mn:000058E8                 jnb     short loc_590C
.text$mn:000058EA                 mov     ecx, [ebp+arg_0]
.text$mn:000058ED                 mov     edx, [ecx+14h]
.text$mn:000058F0                 add     edx, 1
.text$mn:000058F3                 push    edx             ; Size
.text$mn:000058F4                 mov     eax, [ebp+arg_0]
.text$mn:000058F7                 add     eax, 4
.text$mn:000058FA                 push    eax             ; Src
.text$mn:000058FB                 mov     ecx, [ebp+var_8]
.text$mn:000058FE                 add     ecx, 4
.text$mn:00005901                 push    ecx             ; Dst
.text$mn:00005902                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00005907                 add     esp, 0Ch
.text$mn:0000590A                 jmp     short loc_5937
.text$mn:0000590C ; ---------------------------------------------------------------------------
.text$mn:0000590C
.text$mn:0000590C loc_590C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+10j
.text$mn:0000590C                 mov     edx, [ebp+arg_0]
.text$mn:0000590F                 add     edx, 4
.text$mn:00005912                 push    edx             ; int
.text$mn:00005913                 mov     eax, [ebp+var_8]
.text$mn:00005916                 add     eax, 4
.text$mn:00005919                 push    eax             ; void *
.text$mn:0000591A                 lea     ecx, [ebp+var_1]
.text$mn:0000591D                 push    ecx
.text$mn:0000591E                 mov     ecx, [ebp+var_8]
.text$mn:00005921                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005926                 mov     ecx, eax
.text$mn:00005928                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000592D                 mov     edx, [ebp+arg_0]
.text$mn:00005930                 mov     dword ptr [edx+4], 0
.text$mn:00005937
.text$mn:00005937 loc_5937:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+32j
.text$mn:00005937                 mov     eax, [ebp+var_8]
.text$mn:0000593A                 mov     ecx, [ebp+arg_0]
.text$mn:0000593D                 mov     edx, [ecx+14h]
.text$mn:00005940                 mov     [eax+14h], edx
.text$mn:00005943                 mov     eax, [ebp+var_8]
.text$mn:00005946                 mov     ecx, [ebp+arg_0]
.text$mn:00005949                 mov     edx, [ecx+18h]
.text$mn:0000594C                 mov     [eax+18h], edx
.text$mn:0000594F                 push    0               ; Size
.text$mn:00005951                 push    0               ; char
.text$mn:00005953                 mov     ecx, [ebp+arg_0]
.text$mn:00005956                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000595B                 mov     esp, ebp
.text$mn:0000595D                 pop     ebp
.text$mn:0000595E                 retn    4
.text$mn:0000595E ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z endp
.text$mn:0000595E
.text$mn:0000595E ; ---------------------------------------------------------------------------
.text$mn:00005961                 align 4
.text$mn:00005961 _text$mn        ends
.text$mn:00005961
.text$mn:00005964 ; ===========================================================================
.text$mn:00005964
.text$mn:00005964 ; Segment type: Pure code
.text$mn:00005964 ; Segment permissions: Read/Execute
.text$mn:00005964 _text$mn        segment para public 'CODE' use32
.text$mn:00005964                 assume cs:_text$mn
.text$mn:00005964                 ;org 5964h
.text$mn:00005964 ; COMDAT (pick any)
.text$mn:00005964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005964
.text$mn:00005964 ; =============== S U B R O U T I N E =======================================
.text$mn:00005964
.text$mn:00005964 ; Attributes: bp-based frame
.text$mn:00005964
.text$mn:00005964 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(int, size_t Size, char)
.text$mn:00005964                 public ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
.text$mn:00005964 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z proc near
.text$mn:00005964                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(uint,char)+5Cp
.text$mn:00005964
.text$mn:00005964 var_4           = dword ptr -4
.text$mn:00005964 arg_0           = dword ptr  8
.text$mn:00005964 Size            = dword ptr  0Ch
.text$mn:00005964 arg_8           = byte ptr  10h
.text$mn:00005964
.text$mn:00005964                 push    ebp
.text$mn:00005965                 mov     ebp, esp
.text$mn:00005967                 push    ecx
.text$mn:00005968                 mov     [ebp+var_4], ecx
.text$mn:0000596B                 cmp     [ebp+Size], 1
.text$mn:0000596F                 jnz     short loc_598B
.text$mn:00005971                 lea     eax, [ebp+arg_8]
.text$mn:00005974                 push    eax
.text$mn:00005975                 mov     ecx, [ebp+var_4]
.text$mn:00005978                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000597D                 add     eax, [ebp+arg_0]
.text$mn:00005980                 push    eax
.text$mn:00005981                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00005986                 add     esp, 8
.text$mn:00005989                 jmp     short loc_59A8
.text$mn:0000598B ; ---------------------------------------------------------------------------
.text$mn:0000598B
.text$mn:0000598B loc_598B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)+Bj
.text$mn:0000598B                 movzx   ecx, [ebp+arg_8]
.text$mn:0000598F                 push    ecx             ; char
.text$mn:00005990                 mov     edx, [ebp+Size]
.text$mn:00005993                 push    edx             ; Size
.text$mn:00005994                 mov     ecx, [ebp+var_4]
.text$mn:00005997                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000599C                 add     eax, [ebp+arg_0]
.text$mn:0000599F                 push    eax             ; Dst
.text$mn:000059A0                 call    ?assign@?$char_traits@D@std@@SAPADPADID@Z ; std::char_traits<char>::assign(char *,uint,char)
.text$mn:000059A5                 add     esp, 0Ch
.text$mn:000059A8
.text$mn:000059A8 loc_59A8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)+25j
.text$mn:000059A8                 mov     esp, ebp
.text$mn:000059AA                 pop     ebp
.text$mn:000059AB                 retn    0Ch
.text$mn:000059AB ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z endp
.text$mn:000059AB
.text$mn:000059AB ; ---------------------------------------------------------------------------
.text$mn:000059AE                 align 10h
.text$mn:000059AE _text$mn        ends
.text$mn:000059AE
.text$mn:000059B0 ; ===========================================================================
.text$mn:000059B0
.text$mn:000059B0 ; Segment type: Pure code
.text$mn:000059B0 ; Segment permissions: Read/Execute
.text$mn:000059B0 _text$mn        segment para public 'CODE' use32
.text$mn:000059B0                 assume cs:_text$mn
.text$mn:000059B0                 ;org 59B0h
.text$mn:000059B0 ; COMDAT (pick any)
.text$mn:000059B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000059B0
.text$mn:000059B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000059B0
.text$mn:000059B0 ; Attributes: bp-based frame
.text$mn:000059B0
.text$mn:000059B0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:000059B0                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000059B0 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:000059B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:000059B0
.text$mn:000059B0 var_20          = dword ptr -20h
.text$mn:000059B0 var_1C          = dword ptr -1Ch
.text$mn:000059B0 var_18          = dword ptr -18h
.text$mn:000059B0 var_11          = byte ptr -11h
.text$mn:000059B0 var_10          = dword ptr -10h
.text$mn:000059B0 var_C           = byte ptr -0Ch
.text$mn:000059B0 var_4           = dword ptr -4
.text$mn:000059B0 arg_0           = dword ptr  8
.text$mn:000059B0
.text$mn:000059B0 ; FUNCTION CHUNK AT .text$mn:00005AD2 SIZE 00000009 BYTES
.text$mn:000059B0
.text$mn:000059B0                 push    ebp
.text$mn:000059B1                 mov     ebp, esp
.text$mn:000059B3                 push    0FFFFFFFFh
.text$mn:000059B5                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000059BA                 mov     eax, large fs:0
.text$mn:000059C0                 push    eax
.text$mn:000059C1                 push    ecx
.text$mn:000059C2                 sub     esp, 10h
.text$mn:000059C5                 push    ebx
.text$mn:000059C6                 push    esi
.text$mn:000059C7                 push    edi
.text$mn:000059C8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000059CD                 xor     eax, ebp
.text$mn:000059CF                 push    eax
.text$mn:000059D0                 lea     eax, [ebp+var_C]
.text$mn:000059D3                 mov     large fs:0, eax
.text$mn:000059D9                 mov     [ebp+var_10], esp
.text$mn:000059DC                 mov     [ebp+var_18], ecx
.text$mn:000059DF                 mov     eax, [ebp+arg_0]
.text$mn:000059E2                 or      eax, 0Fh
.text$mn:000059E5                 mov     [ebp+var_1C], eax
.text$mn:000059E8                 mov     ecx, [ebp+var_18]
.text$mn:000059EB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000059F0                 cmp     eax, [ebp+var_1C]
.text$mn:000059F3                 jnb     short loc_59FD
.text$mn:000059F5                 mov     ecx, [ebp+arg_0]
.text$mn:000059F8                 mov     [ebp+var_1C], ecx
.text$mn:000059FB                 jmp     short loc_5A4F
.text$mn:000059FD ; ---------------------------------------------------------------------------
.text$mn:000059FD
.text$mn:000059FD loc_59FD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:000059FD                 mov     edx, [ebp+var_18]
.text$mn:00005A00                 mov     ecx, [edx+18h]
.text$mn:00005A03                 shr     ecx, 1
.text$mn:00005A05                 mov     eax, [ebp+var_1C]
.text$mn:00005A08                 xor     edx, edx
.text$mn:00005A0A                 mov     esi, 3
.text$mn:00005A0F                 div     esi
.text$mn:00005A11                 cmp     ecx, eax
.text$mn:00005A13                 ja      short loc_5A17
.text$mn:00005A15                 jmp     short loc_5A4F
.text$mn:00005A17 ; ---------------------------------------------------------------------------
.text$mn:00005A17
.text$mn:00005A17 loc_5A17:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00005A17                 mov     ecx, [ebp+var_18]
.text$mn:00005A1A                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00005A1F                 mov     edx, [ebp+var_18]
.text$mn:00005A22                 mov     ecx, [edx+18h]
.text$mn:00005A25                 shr     ecx, 1
.text$mn:00005A27                 sub     eax, ecx
.text$mn:00005A29                 mov     edx, [ebp+var_18]
.text$mn:00005A2C                 cmp     [edx+18h], eax
.text$mn:00005A2F                 ja      short loc_5A44
.text$mn:00005A31                 mov     eax, [ebp+var_18]
.text$mn:00005A34                 mov     ecx, [eax+18h]
.text$mn:00005A37                 shr     ecx, 1
.text$mn:00005A39                 mov     edx, [ebp+var_18]
.text$mn:00005A3C                 add     ecx, [edx+18h]
.text$mn:00005A3F                 mov     [ebp+var_1C], ecx
.text$mn:00005A42                 jmp     short loc_5A4F
.text$mn:00005A44 ; ---------------------------------------------------------------------------
.text$mn:00005A44
.text$mn:00005A44 loc_5A44:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00005A44                 mov     ecx, [ebp+var_18]
.text$mn:00005A47                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00005A4C                 mov     [ebp+var_1C], eax
.text$mn:00005A4F
.text$mn:00005A4F loc_5A4F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00005A4F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00005A4F                 mov     [ebp+var_4], 0
.text$mn:00005A56                 mov     eax, [ebp+var_1C]
.text$mn:00005A59                 add     eax, 1
.text$mn:00005A5C                 push    eax
.text$mn:00005A5D                 lea     ecx, [ebp+var_11]
.text$mn:00005A60                 push    ecx
.text$mn:00005A61                 mov     ecx, [ebp+var_18]
.text$mn:00005A64                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005A69                 mov     ecx, eax
.text$mn:00005A6B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00005A70                 mov     [ebp+var_20], eax
.text$mn:00005A73                 jmp     short loc_5AD2
.text$mn:00005A73 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00005A73
.text$mn:00005A75
.text$mn:00005A75 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A75
.text$mn:00005A75
.text$mn:00005A75 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00005A75                                         ; DATA XREF: .xdata$x:00007EDCo
.text$mn:00005A75
.text$mn:00005A75 ; FUNCTION CHUNK AT .text$mn:00005ABC SIZE 00000009 BYTES
.text$mn:00005A75 ; FUNCTION CHUNK AT .text$mn:00005ACC SIZE 00000006 BYTES
.text$mn:00005A75
.text$mn:00005A75                 mov     [ebp-10h], esp
.text$mn:00005A78                 mov     edx, [ebp+8]
.text$mn:00005A7B                 mov     [ebp-1Ch], edx
.text$mn:00005A7E                 mov     byte ptr [ebp-4], 2
.text$mn:00005A82                 mov     eax, [ebp-1Ch]
.text$mn:00005A85                 add     eax, 1
.text$mn:00005A88                 push    eax
.text$mn:00005A89                 lea     ecx, [ebp-12h]
.text$mn:00005A8C                 push    ecx
.text$mn:00005A8D                 mov     ecx, [ebp-18h]
.text$mn:00005A90                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005A95                 mov     ecx, eax
.text$mn:00005A97                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00005A9C                 mov     [ebp-20h], eax
.text$mn:00005A9F                 jmp     short loc_5ABC
.text$mn:00005A9F __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00005A9F
.text$mn:00005AA1
.text$mn:00005AA1 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AA1
.text$mn:00005AA1 ; Attributes: noreturn
.text$mn:00005AA1
.text$mn:00005AA1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00005AA1                                         ; DATA XREF: .xdata$x:00007EECo
.text$mn:00005AA1                 push    0               ; Size
.text$mn:00005AA3                 push    1               ; char
.text$mn:00005AA5                 mov     ecx, [ebp-18h]
.text$mn:00005AA8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00005AAD                 push    0
.text$mn:00005AAF                 push    0
.text$mn:00005AB1                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00005AB1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00005AB1
.text$mn:00005AB6 ; ---------------------------------------------------------------------------
.text$mn:00005AB6                 mov     eax, offset $LN17
.text$mn:00005ABB                 retn
.text$mn:00005ABC ; ---------------------------------------------------------------------------
.text$mn:00005ABC ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00005ABC
.text$mn:00005ABC loc_5ABC:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00005ABC                 mov     dword ptr [ebp-4], 1
.text$mn:00005AC3                 jmp     short loc_5ACC
.text$mn:00005AC3 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00005AC5
.text$mn:00005AC5 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AC5
.text$mn:00005AC5
.text$mn:00005AC5 $LN17           proc near               ; DATA XREF: .text$mn:00005AB6o
.text$mn:00005AC5                 mov     dword ptr [ebp-4], 1
.text$mn:00005AC5 $LN17           endp ; sp-analysis failed
.text$mn:00005AC5
.text$mn:00005ACC ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00005ACC
.text$mn:00005ACC loc_5ACC:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00005ACC                 mov     eax, offset $LN19
.text$mn:00005AD1                 retn
.text$mn:00005AD1 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00005AD2 ; ---------------------------------------------------------------------------
.text$mn:00005AD2 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00005AD2
.text$mn:00005AD2 loc_5AD2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00005AD2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005AD9                 jmp     short loc_5AE2
.text$mn:00005AD9 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00005ADB
.text$mn:00005ADB ; =============== S U B R O U T I N E =======================================
.text$mn:00005ADB
.text$mn:00005ADB
.text$mn:00005ADB $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_5ACCo
.text$mn:00005ADB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00005AE2
.text$mn:00005AE2 loc_5AE2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00005AE2                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00005AE6                 jbe     short loc_5B01
.text$mn:00005AE8                 mov     edx, [ebp+0Ch]
.text$mn:00005AEB                 push    edx             ; Size
.text$mn:00005AEC                 mov     ecx, [ebp-18h]
.text$mn:00005AEF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005AF4                 push    eax             ; Src
.text$mn:00005AF5                 mov     eax, [ebp-20h]
.text$mn:00005AF8                 push    eax             ; Dst
.text$mn:00005AF9                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00005AFE                 add     esp, 0Ch
.text$mn:00005B01
.text$mn:00005B01 loc_5B01:                               ; CODE XREF: $LN19+Bj
.text$mn:00005B01                 push    0               ; Size
.text$mn:00005B03                 push    1               ; char
.text$mn:00005B05                 mov     ecx, [ebp-18h]
.text$mn:00005B08                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00005B0D                 lea     ecx, [ebp-20h]
.text$mn:00005B10                 push    ecx             ; int
.text$mn:00005B11                 mov     edx, [ebp-18h]
.text$mn:00005B14                 add     edx, 4
.text$mn:00005B17                 push    edx             ; void *
.text$mn:00005B18                 lea     eax, [ebp-13h]
.text$mn:00005B1B                 push    eax
.text$mn:00005B1C                 mov     ecx, [ebp-18h]
.text$mn:00005B1F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005B24                 mov     ecx, eax
.text$mn:00005B26                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00005B2B                 mov     ecx, [ebp-18h]
.text$mn:00005B2E                 mov     edx, [ebp-1Ch]
.text$mn:00005B31                 mov     [ecx+18h], edx
.text$mn:00005B34                 mov     eax, [ebp+0Ch]
.text$mn:00005B37                 push    eax
.text$mn:00005B38                 mov     ecx, [ebp-18h]
.text$mn:00005B3B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005B40                 mov     ecx, [ebp-0Ch]
.text$mn:00005B43                 mov     large fs:0, ecx
.text$mn:00005B4A                 pop     ecx
.text$mn:00005B4B                 pop     edi
.text$mn:00005B4C                 pop     esi
.text$mn:00005B4D                 pop     ebx
.text$mn:00005B4E                 mov     esp, ebp
.text$mn:00005B50                 pop     ebp
.text$mn:00005B51                 retn    8
.text$mn:00005B51 $LN19           endp ; sp-analysis failed
.text$mn:00005B51
.text$mn:00005B51 _text$mn        ends
.text$mn:00005B51
.text$x:00005B54 ; ===========================================================================
.text$x:00005B54
.text$x:00005B54 ; Segment type: Pure code
.text$x:00005B54 ; Segment permissions: Read/Execute
.text$x:00005B54 _text$x         segment para public 'CODE' use32
.text$x:00005B54                 assume cs:_text$x
.text$x:00005B54                 ;org 5B54h
.text$x:00005B54 ; COMDAT (pick associative to section at 59B0)
.text$x:00005B54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005B54
.text$x:00005B54 ; =============== S U B R O U T I N E =======================================
.text$x:00005B54
.text$x:00005B54
.text$x:00005B54 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00005B54                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00005B54
.text$x:00005B54 arg_4           = dword ptr  8
.text$x:00005B54
.text$x:00005B54                 mov     edx, [esp+arg_4]
.text$x:00005B58                 lea     eax, [edx+0Ch]
.text$x:00005B5B                 mov     ecx, [edx-24h]
.text$x:00005B5E                 xor     ecx, eax
.text$x:00005B60                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B65                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00005B6A                 jmp     ___CxxFrameHandler3
.text$x:00005B6A __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00005B6A
.text$x:00005B6A ; ---------------------------------------------------------------------------
.text$x:00005B6F                 align 10h
.text$x:00005B6F _text$x         ends
.text$x:00005B6F
.text$mn:00005B70 ; ===========================================================================
.text$mn:00005B70
.text$mn:00005B70 ; Segment type: Pure code
.text$mn:00005B70 ; Segment permissions: Read/Execute
.text$mn:00005B70 _text$mn        segment para public 'CODE' use32
.text$mn:00005B70                 assume cs:_text$mn
.text$mn:00005B70                 ;org 5B70h
.text$mn:00005B70 ; COMDAT (pick any)
.text$mn:00005B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B70
.text$mn:00005B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B70
.text$mn:00005B70 ; Attributes: bp-based frame
.text$mn:00005B70
.text$mn:00005B70 ; struct std::_Facet_base *__thiscall std::locale::facet::_Decref(std::locale::facet *__hidden this)
.text$mn:00005B70                 public ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
.text$mn:00005B70 ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ proc near
.text$mn:00005B70                                         ; DATA XREF: .rdata:00008CF0o
.text$mn:00005B70                                         ; .rdata:00008DDCo ...
.text$mn:00005B70
.text$mn:00005B70 var_4           = dword ptr -4
.text$mn:00005B70
.text$mn:00005B70                 push    ebp
.text$mn:00005B71                 mov     ebp, esp
.text$mn:00005B73                 push    ecx
.text$mn:00005B74                 mov     [ebp+var_4], ecx
.text$mn:00005B77                 mov     eax, [ebp+var_4]
.text$mn:00005B7A                 add     eax, 4
.text$mn:00005B7D                 or      ecx, 0FFFFFFFFh
.text$mn:00005B80                 lock xadd [eax], ecx
.text$mn:00005B84                 dec     ecx
.text$mn:00005B85                 jnz     short loc_5B8E
.text$mn:00005B87                 mov     eax, [ebp+var_4]
.text$mn:00005B8A                 jmp     short loc_5B90
.text$mn:00005B8C ; ---------------------------------------------------------------------------
.text$mn:00005B8C                 jmp     short loc_5B90
.text$mn:00005B8E ; ---------------------------------------------------------------------------
.text$mn:00005B8E
.text$mn:00005B8E loc_5B8E:                               ; CODE XREF: std::locale::facet::_Decref(void)+15j
.text$mn:00005B8E                 xor     eax, eax
.text$mn:00005B90
.text$mn:00005B90 loc_5B90:                               ; CODE XREF: std::locale::facet::_Decref(void)+1Aj
.text$mn:00005B90                                         ; std::locale::facet::_Decref(void)+1Cj
.text$mn:00005B90                 mov     esp, ebp
.text$mn:00005B92                 pop     ebp
.text$mn:00005B93                 retn
.text$mn:00005B93 ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ endp
.text$mn:00005B93
.text$mn:00005B93 _text$mn        ends
.text$mn:00005B93
.text$mn:00005B94 ; ===========================================================================
.text$mn:00005B94
.text$mn:00005B94 ; Segment type: Pure code
.text$mn:00005B94 ; Segment permissions: Read/Execute
.text$mn:00005B94 _text$mn        segment para public 'CODE' use32
.text$mn:00005B94                 assume cs:_text$mn
.text$mn:00005B94                 ;org 5B94h
.text$mn:00005B94 ; COMDAT (pick any)
.text$mn:00005B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B94
.text$mn:00005B94 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B94
.text$mn:00005B94 ; Attributes: bp-based frame
.text$mn:00005B94
.text$mn:00005B94 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00005B94                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00005B94 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00005B94                                         ; CODE XREF: $LN19+60p
.text$mn:00005B94                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00005B94
.text$mn:00005B94 var_8           = dword ptr -8
.text$mn:00005B94 var_1           = byte ptr -1
.text$mn:00005B94 arg_0           = dword ptr  8
.text$mn:00005B94
.text$mn:00005B94                 push    ebp
.text$mn:00005B95                 mov     ebp, esp
.text$mn:00005B97                 sub     esp, 8
.text$mn:00005B9A                 mov     [ebp+var_8], ecx
.text$mn:00005B9D                 mov     [ebp+var_1], 0
.text$mn:00005BA1                 mov     eax, [ebp+var_8]
.text$mn:00005BA4                 mov     ecx, [ebp+arg_0]
.text$mn:00005BA7                 mov     [eax+14h], ecx
.text$mn:00005BAA                 lea     edx, [ebp+var_1]
.text$mn:00005BAD                 push    edx
.text$mn:00005BAE                 mov     ecx, [ebp+var_8]
.text$mn:00005BB1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005BB6                 add     eax, [ebp+arg_0]
.text$mn:00005BB9                 push    eax
.text$mn:00005BBA                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00005BBF                 add     esp, 8
.text$mn:00005BC2                 mov     esp, ebp
.text$mn:00005BC4                 pop     ebp
.text$mn:00005BC5                 retn    4
.text$mn:00005BC5 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00005BC5
.text$mn:00005BC5 _text$mn        ends
.text$mn:00005BC5
.text$mn:00005BC8 ; ===========================================================================
.text$mn:00005BC8
.text$mn:00005BC8 ; Segment type: Pure code
.text$mn:00005BC8 ; Segment permissions: Read/Execute
.text$mn:00005BC8 _text$mn        segment para public 'CODE' use32
.text$mn:00005BC8                 assume cs:_text$mn
.text$mn:00005BC8                 ;org 5BC8h
.text$mn:00005BC8 ; COMDAT (pick any)
.text$mn:00005BC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005BC8
.text$mn:00005BC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BC8
.text$mn:00005BC8 ; Attributes: bp-based frame
.text$mn:00005BC8
.text$mn:00005BC8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00005BC8                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00005BC8 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00005BC8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00005BC8
.text$mn:00005BC8 var_8           = dword ptr -8
.text$mn:00005BC8 var_1           = byte ptr -1
.text$mn:00005BC8
.text$mn:00005BC8                 push    ebp
.text$mn:00005BC9                 mov     ebp, esp
.text$mn:00005BCB                 sub     esp, 8
.text$mn:00005BCE                 mov     [ebp+var_8], ecx
.text$mn:00005BD1                 lea     ecx, [ebp+var_1]
.text$mn:00005BD4                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00005BD9                 mov     ecx, [ebp+var_8] ; this
.text$mn:00005BDC                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00005BE1                 mov     eax, [ebp+var_8]
.text$mn:00005BE4                 mov     ecx, [eax]
.text$mn:00005BE6                 push    ecx
.text$mn:00005BE7                 lea     ecx, [ebp+var_1]
.text$mn:00005BEA                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00005BEF                 push    1               ; int
.text$mn:00005BF1                 mov     edx, [ebp+var_8]
.text$mn:00005BF4                 mov     eax, [edx]
.text$mn:00005BF6                 push    eax             ; void *
.text$mn:00005BF7                 lea     ecx, [ebp+var_1]
.text$mn:00005BFA                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00005BFF                 mov     ecx, [ebp+var_8]
.text$mn:00005C02                 mov     dword ptr [ecx], 0
.text$mn:00005C08                 mov     esp, ebp
.text$mn:00005C0A                 pop     ebp
.text$mn:00005C0B                 retn
.text$mn:00005C0B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00005C0B
.text$mn:00005C0B _text$mn        ends
.text$mn:00005C0B
.text$mn:00005C0C ; ===========================================================================
.text$mn:00005C0C
.text$mn:00005C0C ; Segment type: Pure code
.text$mn:00005C0C ; Segment permissions: Read/Execute
.text$mn:00005C0C _text$mn        segment para public 'CODE' use32
.text$mn:00005C0C                 assume cs:_text$mn
.text$mn:00005C0C                 ;org 5C0Ch
.text$mn:00005C0C ; COMDAT (pick any)
.text$mn:00005C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C0C
.text$mn:00005C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C0C
.text$mn:00005C0C ; Attributes: bp-based frame
.text$mn:00005C0C
.text$mn:00005C0C ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00005C0C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00005C0C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00005C0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+2Fp
.text$mn:00005C0C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+33p ...
.text$mn:00005C0C
.text$mn:00005C0C var_4           = dword ptr -4
.text$mn:00005C0C arg_0           = dword ptr  8
.text$mn:00005C0C
.text$mn:00005C0C                 push    ebp
.text$mn:00005C0D                 mov     ebp, esp
.text$mn:00005C0F                 push    ecx
.text$mn:00005C10                 mov     [ebp+var_4], ecx
.text$mn:00005C13                 mov     ecx, [ebp+arg_0]
.text$mn:00005C16                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00005C1B                 mov     eax, [ebp+arg_0]
.text$mn:00005C1E                 mov     esp, ebp
.text$mn:00005C20                 pop     ebp
.text$mn:00005C21                 retn    4
.text$mn:00005C21 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00005C21
.text$mn:00005C21 _text$mn        ends
.text$mn:00005C21
.text$mn:00005C24 ; ===========================================================================
.text$mn:00005C24
.text$mn:00005C24 ; Segment type: Pure code
.text$mn:00005C24 ; Segment permissions: Read/Execute
.text$mn:00005C24 _text$mn        segment para public 'CODE' use32
.text$mn:00005C24                 assume cs:_text$mn
.text$mn:00005C24                 ;org 5C24h
.text$mn:00005C24 ; COMDAT (pick any)
.text$mn:00005C24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C24
.text$mn:00005C24 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C24
.text$mn:00005C24 ; Attributes: bp-based frame
.text$mn:00005C24
.text$mn:00005C24 ; int __cdecl std::ctype<char>::_Getcat(int, std::locale *)
.text$mn:00005C24                 public ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
.text$mn:00005C24 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z proc near
.text$mn:00005C24                                         ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+78p
.text$mn:00005C24
.text$mn:00005C24 var_5C          = byte ptr -5Ch
.text$mn:00005C24 var_28          = dword ptr -28h
.text$mn:00005C24 var_24          = dword ptr -24h
.text$mn:00005C24 var_20          = dword ptr -20h
.text$mn:00005C24 var_1C          = dword ptr -1Ch
.text$mn:00005C24 var_18          = dword ptr -18h
.text$mn:00005C24 var_14          = dword ptr -14h
.text$mn:00005C24 var_10          = dword ptr -10h
.text$mn:00005C24 var_C           = dword ptr -0Ch
.text$mn:00005C24 var_4           = dword ptr -4
.text$mn:00005C24 arg_0           = dword ptr  8
.text$mn:00005C24 arg_4           = dword ptr  0Ch
.text$mn:00005C24
.text$mn:00005C24                 push    ebp
.text$mn:00005C25                 mov     ebp, esp
.text$mn:00005C27                 push    0FFFFFFFFh
.text$mn:00005C29                 push    offset __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
.text$mn:00005C2E                 mov     eax, large fs:0
.text$mn:00005C34                 push    eax
.text$mn:00005C35                 sub     esp, 50h
.text$mn:00005C38                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005C3D                 xor     eax, ebp
.text$mn:00005C3F                 push    eax
.text$mn:00005C40                 lea     eax, [ebp+var_C]
.text$mn:00005C43                 mov     large fs:0, eax
.text$mn:00005C49                 mov     [ebp+var_10], 0
.text$mn:00005C50                 cmp     [ebp+arg_0], 0
.text$mn:00005C54                 jz      loc_5D07
.text$mn:00005C5A                 mov     eax, [ebp+arg_0]
.text$mn:00005C5D                 cmp     dword ptr [eax], 0
.text$mn:00005C60                 jnz     loc_5D07
.text$mn:00005C66                 call    ?_DebugHeapTag_func@std@@YAABU_DebugHeapTag_t@1@XZ ; std::_DebugHeapTag_func(void)
.text$mn:00005C6B                 mov     [ebp+var_1C], eax
.text$mn:00005C6E                 push    9A8h            ; int
.text$mn:00005C73                 push    offset ??_C@_0EH@EPAENFJM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005C78                 mov     ecx, [ebp+var_1C]
.text$mn:00005C7B                 push    ecx             ; struct std::_DebugHeapTag_t *
.text$mn:00005C7C                 push    18h             ; unsigned int
.text$mn:00005C7E                 call    ??2facet@locale@std@@SAPAXIABU_DebugHeapTag_t@2@PADH@Z ; std::locale::facet::operator new(uint,std::_DebugHeapTag_t const &,char *,int)
.text$mn:00005C83                 add     esp, 10h
.text$mn:00005C86                 mov     [ebp+var_14], eax
.text$mn:00005C89                 mov     [ebp+var_4], 0
.text$mn:00005C90                 cmp     [ebp+var_14], 0
.text$mn:00005C94                 jz      short loc_5CD0
.text$mn:00005C96                 push    0
.text$mn:00005C98                 mov     ecx, [ebp+arg_4] ; this
.text$mn:00005C9B                 call    ?c_str@locale@std@@QBEPBDXZ ; std::locale::c_str(void)
.text$mn:00005CA0                 push    eax             ; char *
.text$mn:00005CA1                 lea     ecx, [ebp+var_5C] ; this
.text$mn:00005CA4                 call    ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo(char const *)
.text$mn:00005CA9                 mov     [ebp+var_20], eax
.text$mn:00005CAC                 mov     edx, [ebp+var_20]
.text$mn:00005CAF                 mov     [ebp+var_24], edx
.text$mn:00005CB2                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005CB6                 mov     eax, [ebp+var_10]
.text$mn:00005CB9                 or      eax, 1
.text$mn:00005CBC                 mov     [ebp+var_10], eax
.text$mn:00005CBF                 mov     ecx, [ebp+var_24]
.text$mn:00005CC2                 push    ecx
.text$mn:00005CC3                 mov     ecx, [ebp+var_14]
.text$mn:00005CC6                 call    ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ; std::ctype<char>::ctype<char>(std::_Locinfo const &,uint)
.text$mn:00005CCB                 mov     [ebp+var_18], eax
.text$mn:00005CCE                 jmp     short loc_5CD7
.text$mn:00005CD0 ; ---------------------------------------------------------------------------
.text$mn:00005CD0
.text$mn:00005CD0 loc_5CD0:                               ; CODE XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+70j
.text$mn:00005CD0                 mov     [ebp+var_18], 0
.text$mn:00005CD7
.text$mn:00005CD7 loc_5CD7:                               ; CODE XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+AAj
.text$mn:00005CD7                 mov     edx, [ebp+var_18]
.text$mn:00005CDA                 mov     [ebp+var_28], edx
.text$mn:00005CDD                 mov     [ebp+var_4], 2
.text$mn:00005CE4                 mov     eax, [ebp+arg_0]
.text$mn:00005CE7                 mov     ecx, [ebp+var_28]
.text$mn:00005CEA                 mov     [eax], ecx
.text$mn:00005CEC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005CF3                 mov     edx, [ebp+var_10]
.text$mn:00005CF6                 and     edx, 1
.text$mn:00005CF9                 jz      short loc_5D07
.text$mn:00005CFB                 and     [ebp+var_10], 0FFFFFFFEh
.text$mn:00005CFF                 lea     ecx, [ebp+var_5C] ; this
.text$mn:00005D02                 call    ??1_Locinfo@std@@QAE@XZ ; std::_Locinfo::~_Locinfo(void)
.text$mn:00005D07
.text$mn:00005D07 loc_5D07:                               ; CODE XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+30j
.text$mn:00005D07                                         ; std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+3Cj ...
.text$mn:00005D07                 mov     eax, 2
.text$mn:00005D0C                 mov     ecx, [ebp+var_C]
.text$mn:00005D0F                 mov     large fs:0, ecx
.text$mn:00005D16                 pop     ecx
.text$mn:00005D17                 mov     esp, ebp
.text$mn:00005D19                 pop     ebp
.text$mn:00005D1A                 retn
.text$mn:00005D1A ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z endp
.text$mn:00005D1A
.text$mn:00005D1A ; ---------------------------------------------------------------------------
.text$mn:00005D1B                 align 4
.text$mn:00005D1B _text$mn        ends
.text$mn:00005D1B
.text$x:00005D1C ; ===========================================================================
.text$x:00005D1C
.text$x:00005D1C ; Segment type: Pure code
.text$x:00005D1C ; Segment permissions: Read/Execute
.text$x:00005D1C _text$x         segment para public 'CODE' use32
.text$x:00005D1C                 assume cs:_text$x
.text$x:00005D1C                 ;org 5D1Ch
.text$x:00005D1C ; COMDAT (pick associative to section at 5C24)
.text$x:00005D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005D1C
.text$x:00005D1C ; =============== S U B R O U T I N E =======================================
.text$x:00005D1C
.text$x:00005D1C
.text$x:00005D1C __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0 proc near
.text$x:00005D1C                                         ; DATA XREF: .xdata$x:000081D0o
.text$x:00005D1C                 push    9A8h
.text$x:00005D21                 push    offset ??_C@_0EH@EPAENFJM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$x:00005D26                 mov     eax, [ebp-1Ch]
.text$x:00005D29                 push    eax
.text$x:00005D2A                 mov     eax, [ebp-14h]
.text$x:00005D2D                 push    eax             ; Memory
.text$x:00005D2E                 call    ??3facet@locale@std@@SAXPAXABU_DebugHeapTag_t@2@PADH@Z ; std::locale::facet::operator delete(void *,std::_DebugHeapTag_t const &,char *,int)
.text$x:00005D33                 add     esp, 10h
.text$x:00005D36                 retn
.text$x:00005D36 __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0 endp
.text$x:00005D36
.text$x:00005D37
.text$x:00005D37 ; =============== S U B R O U T I N E =======================================
.text$x:00005D37
.text$x:00005D37
.text$x:00005D37 __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1 proc near
.text$x:00005D37                                         ; DATA XREF: .xdata$x:000081D8o
.text$x:00005D37                                         ; .xdata$x:000081E0o
.text$x:00005D37                 mov     eax, [ebp-10h]
.text$x:00005D3A                 and     eax, 1
.text$x:00005D3D                 jz      $LN8
.text$x:00005D43                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00005D47                 lea     ecx, [ebp-5Ch]  ; this
.text$x:00005D4A                 jmp     ??1_Locinfo@std@@QAE@XZ ; std::_Locinfo::~_Locinfo(void)
.text$x:00005D4F ; ---------------------------------------------------------------------------
.text$x:00005D4F
.text$x:00005D4F $LN8:                                   ; CODE XREF: __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1+6j
.text$x:00005D4F                 retn
.text$x:00005D4F __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1 endp
.text$x:00005D4F
.text$x:00005D50
.text$x:00005D50 ; =============== S U B R O U T I N E =======================================
.text$x:00005D50
.text$x:00005D50
.text$x:00005D50 __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z proc near
.text$x:00005D50                                         ; DATA XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+5o
.text$x:00005D50
.text$x:00005D50 arg_4           = dword ptr  8
.text$x:00005D50
.text$x:00005D50                 mov     edx, [esp+arg_4]
.text$x:00005D54                 lea     eax, [edx+0Ch]
.text$x:00005D57                 mov     ecx, [edx-54h]
.text$x:00005D5A                 xor     ecx, eax
.text$x:00005D5C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005D61                 mov     eax, offset __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
.text$x:00005D66                 jmp     ___CxxFrameHandler3
.text$x:00005D66 __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z endp
.text$x:00005D66
.text$x:00005D66 ; ---------------------------------------------------------------------------
.text$x:00005D6B                 align 4
.text$x:00005D6B _text$x         ends
.text$x:00005D6B
.text$mn:00005D6C ; ===========================================================================
.text$mn:00005D6C
.text$mn:00005D6C ; Segment type: Pure code
.text$mn:00005D6C ; Segment permissions: Read/Execute
.text$mn:00005D6C _text$mn        segment para public 'CODE' use32
.text$mn:00005D6C                 assume cs:_text$mn
.text$mn:00005D6C                 ;org 5D6Ch
.text$mn:00005D6C ; COMDAT (pick any)
.text$mn:00005D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D6C
.text$mn:00005D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00005D6C
.text$mn:00005D6C ; Attributes: bp-based frame
.text$mn:00005D6C
.text$mn:00005D6C ; public: struct _Ctypevec __thiscall std::_Locinfo::_Getctype(void)const
.text$mn:00005D6C                 public ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
.text$mn:00005D6C ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ proc near
.text$mn:00005D6C                                         ; CODE XREF: std::ctype<char>::_Init(std::_Locinfo const &)+10p
.text$mn:00005D6C
.text$mn:00005D6C var_24          = byte ptr -24h
.text$mn:00005D6C var_14          = dword ptr -14h
.text$mn:00005D6C var_10          = dword ptr -10h
.text$mn:00005D6C var_C           = dword ptr -0Ch
.text$mn:00005D6C var_8           = dword ptr -8
.text$mn:00005D6C var_4           = dword ptr -4
.text$mn:00005D6C arg_0           = dword ptr  8
.text$mn:00005D6C
.text$mn:00005D6C                 push    ebp
.text$mn:00005D6D                 mov     ebp, esp
.text$mn:00005D6F                 sub     esp, 24h
.text$mn:00005D72                 mov     [ebp+var_4], ecx
.text$mn:00005D75                 lea     eax, [ebp+var_24]
.text$mn:00005D78                 push    eax
.text$mn:00005D79                 call    __Getctype
.text$mn:00005D7E                 add     esp, 4
.text$mn:00005D81                 mov     ecx, [eax]
.text$mn:00005D83                 mov     [ebp+var_14], ecx
.text$mn:00005D86                 mov     edx, [eax+4]
.text$mn:00005D89                 mov     [ebp+var_10], edx
.text$mn:00005D8C                 mov     ecx, [eax+8]
.text$mn:00005D8F                 mov     [ebp+var_C], ecx
.text$mn:00005D92                 mov     edx, [eax+0Ch]
.text$mn:00005D95                 mov     [ebp+var_8], edx
.text$mn:00005D98                 mov     eax, [ebp+arg_0]
.text$mn:00005D9B                 mov     ecx, [ebp+var_14]
.text$mn:00005D9E                 mov     [eax], ecx
.text$mn:00005DA0                 mov     edx, [ebp+var_10]
.text$mn:00005DA3                 mov     [eax+4], edx
.text$mn:00005DA6                 mov     ecx, [ebp+var_C]
.text$mn:00005DA9                 mov     [eax+8], ecx
.text$mn:00005DAC                 mov     edx, [ebp+var_8]
.text$mn:00005DAF                 mov     [eax+0Ch], edx
.text$mn:00005DB2                 mov     eax, [ebp+arg_0]
.text$mn:00005DB5                 mov     esp, ebp
.text$mn:00005DB7                 pop     ebp
.text$mn:00005DB8                 retn    4
.text$mn:00005DB8 ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ endp
.text$mn:00005DB8
.text$mn:00005DB8 ; ---------------------------------------------------------------------------
.text$mn:00005DBB                 align 4
.text$mn:00005DBB _text$mn        ends
.text$mn:00005DBB
.text$mn:00005DBC ; ===========================================================================
.text$mn:00005DBC
.text$mn:00005DBC ; Segment type: Pure code
.text$mn:00005DBC ; Segment permissions: Read/Execute
.text$mn:00005DBC _text$mn        segment para public 'CODE' use32
.text$mn:00005DBC                 assume cs:_text$mn
.text$mn:00005DBC                 ;org 5DBCh
.text$mn:00005DBC ; COMDAT (pick any)
.text$mn:00005DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DBC
.text$mn:00005DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00005DBC
.text$mn:00005DBC ; Attributes: bp-based frame
.text$mn:00005DBC
.text$mn:00005DBC ; const struct std::locale::facet *__thiscall std::locale::_Getfacet(std::locale *this, unsigned int)
.text$mn:00005DBC                 public ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
.text$mn:00005DBC ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z proc near
.text$mn:00005DBC                                         ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+52p
.text$mn:00005DBC
.text$mn:00005DBC var_14          = dword ptr -14h
.text$mn:00005DBC var_10          = dword ptr -10h
.text$mn:00005DBC var_C           = dword ptr -0Ch
.text$mn:00005DBC var_8           = dword ptr -8
.text$mn:00005DBC var_4           = dword ptr -4
.text$mn:00005DBC arg_0           = dword ptr  8
.text$mn:00005DBC
.text$mn:00005DBC                 push    ebp
.text$mn:00005DBD                 mov     ebp, esp
.text$mn:00005DBF                 sub     esp, 14h
.text$mn:00005DC2                 mov     [ebp+var_4], ecx
.text$mn:00005DC5                 mov     eax, [ebp+var_4]
.text$mn:00005DC8                 mov     ecx, [eax]
.text$mn:00005DCA                 mov     edx, [ebp+arg_0]
.text$mn:00005DCD                 cmp     edx, [ecx+0Ch]
.text$mn:00005DD0                 jnb     short loc_5DE5
.text$mn:00005DD2                 mov     eax, [ebp+var_4]
.text$mn:00005DD5                 mov     ecx, [eax]
.text$mn:00005DD7                 mov     edx, [ecx+8]
.text$mn:00005DDA                 mov     eax, [ebp+arg_0]
.text$mn:00005DDD                 mov     ecx, [edx+eax*4]
.text$mn:00005DE0                 mov     [ebp+var_8], ecx
.text$mn:00005DE3                 jmp     short loc_5DEC
.text$mn:00005DE5 ; ---------------------------------------------------------------------------
.text$mn:00005DE5
.text$mn:00005DE5 loc_5DE5:                               ; CODE XREF: std::locale::_Getfacet(uint)+14j
.text$mn:00005DE5                 mov     [ebp+var_8], 0
.text$mn:00005DEC
.text$mn:00005DEC loc_5DEC:                               ; CODE XREF: std::locale::_Getfacet(uint)+27j
.text$mn:00005DEC                 mov     edx, [ebp+var_8]
.text$mn:00005DEF                 mov     [ebp+var_C], edx
.text$mn:00005DF2                 cmp     [ebp+var_C], 0
.text$mn:00005DF6                 jnz     short loc_5E05
.text$mn:00005DF8                 mov     eax, [ebp+var_4]
.text$mn:00005DFB                 mov     ecx, [eax]
.text$mn:00005DFD                 movzx   edx, byte ptr [ecx+14h]
.text$mn:00005E01                 test    edx, edx
.text$mn:00005E03                 jnz     short loc_5E0C
.text$mn:00005E05
.text$mn:00005E05 loc_5E05:                               ; CODE XREF: std::locale::_Getfacet(uint)+3Aj
.text$mn:00005E05                 mov     eax, [ebp+var_C]
.text$mn:00005E08                 jmp     short loc_5E3A
.text$mn:00005E0A ; ---------------------------------------------------------------------------
.text$mn:00005E0A                 jmp     short loc_5E3A
.text$mn:00005E0C ; ---------------------------------------------------------------------------
.text$mn:00005E0C
.text$mn:00005E0C loc_5E0C:                               ; CODE XREF: std::locale::_Getfacet(uint)+47j
.text$mn:00005E0C                 call    ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale(void)
.text$mn:00005E11                 mov     [ebp+var_10], eax
.text$mn:00005E14                 mov     eax, [ebp+var_10]
.text$mn:00005E17                 mov     ecx, [ebp+arg_0]
.text$mn:00005E1A                 cmp     ecx, [eax+0Ch]
.text$mn:00005E1D                 jnb     short loc_5E30
.text$mn:00005E1F                 mov     edx, [ebp+var_10]
.text$mn:00005E22                 mov     eax, [edx+8]
.text$mn:00005E25                 mov     ecx, [ebp+arg_0]
.text$mn:00005E28                 mov     edx, [eax+ecx*4]
.text$mn:00005E2B                 mov     [ebp+var_14], edx
.text$mn:00005E2E                 jmp     short loc_5E37
.text$mn:00005E30 ; ---------------------------------------------------------------------------
.text$mn:00005E30
.text$mn:00005E30 loc_5E30:                               ; CODE XREF: std::locale::_Getfacet(uint)+61j
.text$mn:00005E30                 mov     [ebp+var_14], 0
.text$mn:00005E37
.text$mn:00005E37 loc_5E37:                               ; CODE XREF: std::locale::_Getfacet(uint)+72j
.text$mn:00005E37                 mov     eax, [ebp+var_14]
.text$mn:00005E3A
.text$mn:00005E3A loc_5E3A:                               ; CODE XREF: std::locale::_Getfacet(uint)+4Cj
.text$mn:00005E3A                                         ; std::locale::_Getfacet(uint)+4Ej
.text$mn:00005E3A                 mov     esp, ebp
.text$mn:00005E3C                 pop     ebp
.text$mn:00005E3D                 retn    4
.text$mn:00005E3D ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z endp
.text$mn:00005E3D
.text$mn:00005E3D _text$mn        ends
.text$mn:00005E3D
.text$mn:00005E40 ; ===========================================================================
.text$mn:00005E40
.text$mn:00005E40 ; Segment type: Pure code
.text$mn:00005E40 ; Segment permissions: Read/Execute
.text$mn:00005E40 _text$mn        segment para public 'CODE' use32
.text$mn:00005E40                 assume cs:_text$mn
.text$mn:00005E40                 ;org 5E40h
.text$mn:00005E40 ; COMDAT (pick any)
.text$mn:00005E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E40
.text$mn:00005E40 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E40
.text$mn:00005E40 ; Attributes: bp-based frame
.text$mn:00005E40
.text$mn:00005E40 ; protected: __int64 __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::_Gnavail(void)const
.text$mn:00005E40                 public ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
.text$mn:00005E40 ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ proc near
.text$mn:00005E40                                         ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::sbumpc(void)+Cp
.text$mn:00005E40                                         ; std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)+Cp ...
.text$mn:00005E40
.text$mn:00005E40 var_8           = dword ptr -8
.text$mn:00005E40 var_4           = dword ptr -4
.text$mn:00005E40
.text$mn:00005E40                 push    ebp
.text$mn:00005E41                 mov     ebp, esp
.text$mn:00005E43                 sub     esp, 8
.text$mn:00005E46                 mov     [ebp+var_4], ecx
.text$mn:00005E49                 mov     eax, [ebp+var_4]
.text$mn:00005E4C                 mov     ecx, [eax+1Ch]
.text$mn:00005E4F                 cmp     dword ptr [ecx], 0
.text$mn:00005E52                 jz      short loc_5E61
.text$mn:00005E54                 mov     edx, [ebp+var_4]
.text$mn:00005E57                 mov     eax, [edx+2Ch]
.text$mn:00005E5A                 mov     ecx, [eax]
.text$mn:00005E5C                 mov     [ebp+var_8], ecx
.text$mn:00005E5F                 jmp     short loc_5E68
.text$mn:00005E61 ; ---------------------------------------------------------------------------
.text$mn:00005E61
.text$mn:00005E61 loc_5E61:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::_Gnavail(void)+12j
.text$mn:00005E61                 mov     [ebp+var_8], 0
.text$mn:00005E68
.text$mn:00005E68 loc_5E68:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::_Gnavail(void)+1Fj
.text$mn:00005E68                 mov     eax, [ebp+var_8]
.text$mn:00005E6B                 cdq
.text$mn:00005E6C                 mov     esp, ebp
.text$mn:00005E6E                 pop     ebp
.text$mn:00005E6F                 retn
.text$mn:00005E6F ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ endp
.text$mn:00005E6F
.text$mn:00005E6F _text$mn        ends
.text$mn:00005E6F
.text$mn:00005E70 ; ===========================================================================
.text$mn:00005E70
.text$mn:00005E70 ; Segment type: Pure code
.text$mn:00005E70 ; Segment permissions: Read/Execute
.text$mn:00005E70 _text$mn        segment para public 'CODE' use32
.text$mn:00005E70                 assume cs:_text$mn
.text$mn:00005E70                 ;org 5E70h
.text$mn:00005E70 ; COMDAT (pick any)
.text$mn:00005E70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E70
.text$mn:00005E70 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E70
.text$mn:00005E70 ; Attributes: bp-based frame
.text$mn:00005E70
.text$mn:00005E70 ; protected: char * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::_Gninc(void)
.text$mn:00005E70                 public ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
.text$mn:00005E70 ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ proc near
.text$mn:00005E70                                         ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::sbumpc(void)+28p
.text$mn:00005E70
.text$mn:00005E70 var_8           = dword ptr -8
.text$mn:00005E70 var_4           = dword ptr -4
.text$mn:00005E70
.text$mn:00005E70                 push    ebp
.text$mn:00005E71                 mov     ebp, esp
.text$mn:00005E73                 sub     esp, 8
.text$mn:00005E76                 mov     [ebp+var_4], ecx
.text$mn:00005E79                 mov     eax, [ebp+var_4]
.text$mn:00005E7C                 mov     ecx, [eax+2Ch]
.text$mn:00005E7F                 mov     edx, [ecx]
.text$mn:00005E81                 sub     edx, 1
.text$mn:00005E84                 mov     eax, [ebp+var_4]
.text$mn:00005E87                 mov     ecx, [eax+2Ch]
.text$mn:00005E8A                 mov     [ecx], edx
.text$mn:00005E8C                 mov     edx, [ebp+var_4]
.text$mn:00005E8F                 mov     eax, [edx+1Ch]
.text$mn:00005E92                 mov     ecx, [eax]
.text$mn:00005E94                 mov     [ebp+var_8], ecx
.text$mn:00005E97                 mov     edx, [ebp+var_4]
.text$mn:00005E9A                 mov     eax, [edx+1Ch]
.text$mn:00005E9D                 mov     ecx, [eax]
.text$mn:00005E9F                 add     ecx, 1
.text$mn:00005EA2                 mov     edx, [ebp+var_4]
.text$mn:00005EA5                 mov     eax, [edx+1Ch]
.text$mn:00005EA8                 mov     [eax], ecx
.text$mn:00005EAA                 mov     eax, [ebp+var_8]
.text$mn:00005EAD                 mov     esp, ebp
.text$mn:00005EAF                 pop     ebp
.text$mn:00005EB0                 retn
.text$mn:00005EB0 ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ endp
.text$mn:00005EB0
.text$mn:00005EB0 ; ---------------------------------------------------------------------------
.text$mn:00005EB1                 align 4
.text$mn:00005EB1 _text$mn        ends
.text$mn:00005EB1
.text$mn:00005EB4 ; ===========================================================================
.text$mn:00005EB4
.text$mn:00005EB4 ; Segment type: Pure code
.text$mn:00005EB4 ; Segment permissions: Read/Execute
.text$mn:00005EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00005EB4                 assume cs:_text$mn
.text$mn:00005EB4                 ;org 5EB4h
.text$mn:00005EB4 ; COMDAT (pick any)
.text$mn:00005EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EB4
.text$mn:00005EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EB4
.text$mn:00005EB4 ; Attributes: bp-based frame
.text$mn:00005EB4
.text$mn:00005EB4 ; protected: char * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::_Gnpreinc(void)
.text$mn:00005EB4                 public ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
.text$mn:00005EB4 ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ proc near
.text$mn:00005EB4                                         ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::snextc(void)+28p
.text$mn:00005EB4
.text$mn:00005EB4 var_8           = dword ptr -8
.text$mn:00005EB4 var_4           = dword ptr -4
.text$mn:00005EB4
.text$mn:00005EB4                 push    ebp
.text$mn:00005EB5                 mov     ebp, esp
.text$mn:00005EB7                 sub     esp, 8
.text$mn:00005EBA                 mov     [ebp+var_4], ecx
.text$mn:00005EBD                 mov     eax, [ebp+var_4]
.text$mn:00005EC0                 mov     ecx, [eax+2Ch]
.text$mn:00005EC3                 mov     edx, [ecx]
.text$mn:00005EC5                 sub     edx, 1
.text$mn:00005EC8                 mov     eax, [ebp+var_4]
.text$mn:00005ECB                 mov     ecx, [eax+2Ch]
.text$mn:00005ECE                 mov     [ecx], edx
.text$mn:00005ED0                 mov     edx, [ebp+var_4]
.text$mn:00005ED3                 mov     eax, [edx+1Ch]
.text$mn:00005ED6                 mov     ecx, [eax]
.text$mn:00005ED8                 add     ecx, 1
.text$mn:00005EDB                 mov     [ebp+var_8], ecx
.text$mn:00005EDE                 mov     edx, [ebp+var_4]
.text$mn:00005EE1                 mov     eax, [edx+1Ch]
.text$mn:00005EE4                 mov     ecx, [ebp+var_8]
.text$mn:00005EE7                 mov     [eax], ecx
.text$mn:00005EE9                 mov     eax, [ebp+var_8]
.text$mn:00005EEC                 mov     esp, ebp
.text$mn:00005EEE                 pop     ebp
.text$mn:00005EEF                 retn
.text$mn:00005EEF ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ endp
.text$mn:00005EEF
.text$mn:00005EEF _text$mn        ends
.text$mn:00005EEF
.text$mn:00005EF0 ; ===========================================================================
.text$mn:00005EF0
.text$mn:00005EF0 ; Segment type: Pure code
.text$mn:00005EF0 ; Segment permissions: Read/Execute
.text$mn:00005EF0 _text$mn        segment para public 'CODE' use32
.text$mn:00005EF0                 assume cs:_text$mn
.text$mn:00005EF0                 ;org 5EF0h
.text$mn:00005EF0 ; COMDAT (pick any)
.text$mn:00005EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EF0
.text$mn:00005EF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EF0
.text$mn:00005EF0 ; Attributes: bp-based frame
.text$mn:00005EF0
.text$mn:00005EF0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00005EF0                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00005EF0 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00005EF0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Dp
.text$mn:00005EF0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(uint,char)+3Dp ...
.text$mn:00005EF0
.text$mn:00005EF0 var_C           = dword ptr -0Ch
.text$mn:00005EF0 Size            = dword ptr -8
.text$mn:00005EF0 var_4           = dword ptr -4
.text$mn:00005EF0 arg_0           = dword ptr  8
.text$mn:00005EF0 arg_4           = byte ptr  0Ch
.text$mn:00005EF0
.text$mn:00005EF0                 push    ebp
.text$mn:00005EF1                 mov     ebp, esp
.text$mn:00005EF3                 sub     esp, 0Ch
.text$mn:00005EF6                 mov     [ebp+var_4], ecx
.text$mn:00005EF9                 mov     ecx, [ebp+var_4]
.text$mn:00005EFC                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00005F01                 cmp     eax, [ebp+arg_0]
.text$mn:00005F04                 jnb     short loc_5F0E
.text$mn:00005F06                 mov     ecx, [ebp+var_4]
.text$mn:00005F09                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00005F0E
.text$mn:00005F0E loc_5F0E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00005F0E                 mov     eax, [ebp+var_4]
.text$mn:00005F11                 mov     ecx, [eax+18h]
.text$mn:00005F14                 cmp     ecx, [ebp+arg_0]
.text$mn:00005F17                 jnb     short loc_5F2E
.text$mn:00005F19                 mov     edx, [ebp+var_4]
.text$mn:00005F1C                 mov     eax, [edx+14h]
.text$mn:00005F1F                 push    eax
.text$mn:00005F20                 mov     ecx, [ebp+arg_0]
.text$mn:00005F23                 push    ecx
.text$mn:00005F24                 mov     ecx, [ebp+var_4]
.text$mn:00005F27                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00005F2C                 jmp     short loc_5F78
.text$mn:00005F2E ; ---------------------------------------------------------------------------
.text$mn:00005F2E
.text$mn:00005F2E loc_5F2E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00005F2E                 movzx   edx, [ebp+arg_4]
.text$mn:00005F32                 test    edx, edx
.text$mn:00005F34                 jz      short loc_5F68
.text$mn:00005F36                 cmp     [ebp+arg_0], 10h
.text$mn:00005F3A                 jnb     short loc_5F68
.text$mn:00005F3C                 mov     eax, [ebp+var_4]
.text$mn:00005F3F                 mov     ecx, [ebp+arg_0]
.text$mn:00005F42                 cmp     ecx, [eax+14h]
.text$mn:00005F45                 jnb     short loc_5F4F
.text$mn:00005F47                 mov     edx, [ebp+arg_0]
.text$mn:00005F4A                 mov     [ebp+Size], edx
.text$mn:00005F4D                 jmp     short loc_5F58
.text$mn:00005F4F ; ---------------------------------------------------------------------------
.text$mn:00005F4F
.text$mn:00005F4F loc_5F4F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00005F4F                 mov     eax, [ebp+var_4]
.text$mn:00005F52                 mov     ecx, [eax+14h]
.text$mn:00005F55                 mov     [ebp+Size], ecx
.text$mn:00005F58
.text$mn:00005F58 loc_5F58:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00005F58                 mov     edx, [ebp+Size]
.text$mn:00005F5B                 push    edx             ; Size
.text$mn:00005F5C                 push    1               ; char
.text$mn:00005F5E                 mov     ecx, [ebp+var_4]
.text$mn:00005F61                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00005F66                 jmp     short loc_5F78
.text$mn:00005F68 ; ---------------------------------------------------------------------------
.text$mn:00005F68
.text$mn:00005F68 loc_5F68:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00005F68                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00005F68                 cmp     [ebp+arg_0], 0
.text$mn:00005F6C                 jnz     short loc_5F78
.text$mn:00005F6E                 push    0
.text$mn:00005F70                 mov     ecx, [ebp+var_4]
.text$mn:00005F73                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005F78
.text$mn:00005F78 loc_5F78:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00005F78                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00005F78                 cmp     [ebp+arg_0], 0
.text$mn:00005F7C                 jbe     short loc_5F87
.text$mn:00005F7E                 mov     [ebp+var_C], 1
.text$mn:00005F85                 jmp     short loc_5F8E
.text$mn:00005F87 ; ---------------------------------------------------------------------------
.text$mn:00005F87
.text$mn:00005F87 loc_5F87:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00005F87                 mov     [ebp+var_C], 0
.text$mn:00005F8E
.text$mn:00005F8E loc_5F8E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00005F8E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00005F91                 mov     esp, ebp
.text$mn:00005F93                 pop     ebp
.text$mn:00005F94                 retn    8
.text$mn:00005F94 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00005F94
.text$mn:00005F94 ; ---------------------------------------------------------------------------
.text$mn:00005F97                 align 4
.text$mn:00005F97 _text$mn        ends
.text$mn:00005F97
.text$mn:00005F98 ; ===========================================================================
.text$mn:00005F98
.text$mn:00005F98 ; Segment type: Pure code
.text$mn:00005F98 ; Segment permissions: Read/Execute
.text$mn:00005F98 _text$mn        segment para public 'CODE' use32
.text$mn:00005F98                 assume cs:_text$mn
.text$mn:00005F98                 ;org 5F98h
.text$mn:00005F98 ; COMDAT (pick any)
.text$mn:00005F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F98
.text$mn:00005F98 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F98
.text$mn:00005F98 ; Attributes: bp-based frame
.text$mn:00005F98
.text$mn:00005F98 ; void __thiscall std::locale::facet::_Incref(std::locale::facet *__hidden this)
.text$mn:00005F98                 public ?_Incref@facet@locale@std@@UAEXXZ
.text$mn:00005F98 ?_Incref@facet@locale@std@@UAEXXZ proc near ; DATA XREF: .rdata:00008CECo
.text$mn:00005F98                                         ; .rdata:00008DD8o ...
.text$mn:00005F98
.text$mn:00005F98 var_4           = dword ptr -4
.text$mn:00005F98
.text$mn:00005F98                 push    ebp
.text$mn:00005F99                 mov     ebp, esp
.text$mn:00005F9B                 push    ecx
.text$mn:00005F9C                 mov     [ebp+var_4], ecx
.text$mn:00005F9F                 mov     eax, [ebp+var_4]
.text$mn:00005FA2                 add     eax, 4
.text$mn:00005FA5                 mov     ecx, 1
.text$mn:00005FAA                 lock xadd [eax], ecx
.text$mn:00005FAE                 mov     esp, ebp
.text$mn:00005FB0                 pop     ebp
.text$mn:00005FB1                 retn
.text$mn:00005FB1 ?_Incref@facet@locale@std@@UAEXXZ endp
.text$mn:00005FB1
.text$mn:00005FB1 ; ---------------------------------------------------------------------------
.text$mn:00005FB2                 align 4
.text$mn:00005FB2 _text$mn        ends
.text$mn:00005FB2
.text$mn:00005FB4 ; ===========================================================================
.text$mn:00005FB4
.text$mn:00005FB4 ; Segment type: Pure code
.text$mn:00005FB4 ; Segment permissions: Read/Execute
.text$mn:00005FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00005FB4                 assume cs:_text$mn
.text$mn:00005FB4                 ;org 5FB4h
.text$mn:00005FB4 ; COMDAT (pick any)
.text$mn:00005FB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FB4
.text$mn:00005FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FB4
.text$mn:00005FB4 ; Attributes: bp-based frame
.text$mn:00005FB4
.text$mn:00005FB4 ; protected: void __thiscall std::ctype<char>::_Init(class std::_Locinfo const &)
.text$mn:00005FB4                 public ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
.text$mn:00005FB4 ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z proc near
.text$mn:00005FB4                                         ; CODE XREF: std::ctype<char>::ctype<char>(std::_Locinfo const &,uint)+49p
.text$mn:00005FB4
.text$mn:00005FB4 var_14          = byte ptr -14h
.text$mn:00005FB4 var_4           = dword ptr -4
.text$mn:00005FB4 arg_0           = dword ptr  8
.text$mn:00005FB4
.text$mn:00005FB4                 push    ebp
.text$mn:00005FB5                 mov     ebp, esp
.text$mn:00005FB7                 sub     esp, 14h
.text$mn:00005FBA                 mov     [ebp+var_4], ecx
.text$mn:00005FBD                 lea     eax, [ebp+var_14]
.text$mn:00005FC0                 push    eax
.text$mn:00005FC1                 mov     ecx, [ebp+arg_0]
.text$mn:00005FC4                 call    ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype(void)
.text$mn:00005FC9                 mov     ecx, [ebp+var_4]
.text$mn:00005FCC                 add     ecx, 8
.text$mn:00005FCF                 mov     edx, [eax]
.text$mn:00005FD1                 mov     [ecx], edx
.text$mn:00005FD3                 mov     edx, [eax+4]
.text$mn:00005FD6                 mov     [ecx+4], edx
.text$mn:00005FD9                 mov     edx, [eax+8]
.text$mn:00005FDC                 mov     [ecx+8], edx
.text$mn:00005FDF                 mov     eax, [eax+0Ch]
.text$mn:00005FE2                 mov     [ecx+0Ch], eax
.text$mn:00005FE5                 mov     esp, ebp
.text$mn:00005FE7                 pop     ebp
.text$mn:00005FE8                 retn    4
.text$mn:00005FE8 ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z endp
.text$mn:00005FE8
.text$mn:00005FE8 ; ---------------------------------------------------------------------------
.text$mn:00005FEB                 align 4
.text$mn:00005FEB _text$mn        ends
.text$mn:00005FEB
.text$mn:00005FEC ; ===========================================================================
.text$mn:00005FEC
.text$mn:00005FEC ; Segment type: Pure code
.text$mn:00005FEC ; Segment permissions: Read/Execute
.text$mn:00005FEC _text$mn        segment para public 'CODE' use32
.text$mn:00005FEC                 assume cs:_text$mn
.text$mn:00005FEC                 ;org 5FECh
.text$mn:00005FEC ; COMDAT (pick any)
.text$mn:00005FEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FEC
.text$mn:00005FEC ; =============== S U B R O U T I N E =======================================
.text$mn:00005FEC
.text$mn:00005FEC ; Attributes: bp-based frame
.text$mn:00005FEC
.text$mn:00005FEC ; void __cdecl std::_Init_atomic_counter(unsigned __int32 *, unsigned __int32)
.text$mn:00005FEC                 public ?_Init_atomic_counter@std@@YAXAAKK@Z
.text$mn:00005FEC ?_Init_atomic_counter@std@@YAXAAKK@Z proc near
.text$mn:00005FEC                                         ; CODE XREF: std::locale::facet::facet(uint)+49p
.text$mn:00005FEC
.text$mn:00005FEC arg_0           = dword ptr  8
.text$mn:00005FEC arg_4           = dword ptr  0Ch
.text$mn:00005FEC
.text$mn:00005FEC                 push    ebp
.text$mn:00005FED                 mov     ebp, esp
.text$mn:00005FEF                 mov     eax, [ebp+arg_0]
.text$mn:00005FF2                 mov     ecx, [ebp+arg_4]
.text$mn:00005FF5                 mov     [eax], ecx
.text$mn:00005FF7                 pop     ebp
.text$mn:00005FF8                 retn
.text$mn:00005FF8 ?_Init_atomic_counter@std@@YAXAAKK@Z endp
.text$mn:00005FF8
.text$mn:00005FF8 ; ---------------------------------------------------------------------------
.text$mn:00005FF9                 align 4
.text$mn:00005FF9 _text$mn        ends
.text$mn:00005FF9
.text$mn:00005FFC ; ===========================================================================
.text$mn:00005FFC
.text$mn:00005FFC ; Segment type: Pure code
.text$mn:00005FFC ; Segment permissions: Read/Execute
.text$mn:00005FFC _text$mn        segment para public 'CODE' use32
.text$mn:00005FFC                 assume cs:_text$mn
.text$mn:00005FFC                 ;org 5FFCh
.text$mn:00005FFC ; COMDAT (pick any)
.text$mn:00005FFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FFC
.text$mn:00005FFC ; =============== S U B R O U T I N E =======================================
.text$mn:00005FFC
.text$mn:00005FFC ; Attributes: bp-based frame
.text$mn:00005FFC
.text$mn:00005FFC ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00005FFC                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00005FFC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00005FFC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+2Cp
.text$mn:00005FFC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00005FFC
.text$mn:00005FFC var_4           = dword ptr -4
.text$mn:00005FFC arg_0           = dword ptr  8
.text$mn:00005FFC
.text$mn:00005FFC                 push    ebp
.text$mn:00005FFD                 mov     ebp, esp
.text$mn:00005FFF                 push    ecx
.text$mn:00006000                 mov     [ebp+var_4], ecx
.text$mn:00006003                 cmp     [ebp+arg_0], 0
.text$mn:00006007                 jz      short loc_6029
.text$mn:00006009                 mov     ecx, [ebp+var_4]
.text$mn:0000600C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006011                 cmp     [ebp+arg_0], eax
.text$mn:00006014                 jb      short loc_6029
.text$mn:00006016                 mov     ecx, [ebp+var_4]
.text$mn:00006019                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000601E                 mov     ecx, [ebp+var_4]
.text$mn:00006021                 add     eax, [ecx+14h]
.text$mn:00006024                 cmp     eax, [ebp+arg_0]
.text$mn:00006027                 ja      short loc_602F
.text$mn:00006029
.text$mn:00006029 loc_6029:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00006029                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00006029                 xor     al, al
.text$mn:0000602B                 jmp     short loc_6031
.text$mn:0000602D ; ---------------------------------------------------------------------------
.text$mn:0000602D                 jmp     short loc_6031
.text$mn:0000602F ; ---------------------------------------------------------------------------
.text$mn:0000602F
.text$mn:0000602F loc_602F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000602F                 mov     al, 1
.text$mn:00006031
.text$mn:00006031 loc_6031:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00006031                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00006031                 mov     esp, ebp
.text$mn:00006033                 pop     ebp
.text$mn:00006034                 retn    4
.text$mn:00006034 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00006034
.text$mn:00006034 ; ---------------------------------------------------------------------------
.text$mn:00006037                 align 4
.text$mn:00006037 _text$mn        ends
.text$mn:00006037
.text$mn:00006038 ; ===========================================================================
.text$mn:00006038
.text$mn:00006038 ; Segment type: Pure code
.text$mn:00006038 ; Segment permissions: Read/Execute
.text$mn:00006038 _text$mn        segment para public 'CODE' use32
.text$mn:00006038                 assume cs:_text$mn
.text$mn:00006038                 ;org 6038h
.text$mn:00006038 ; COMDAT (pick any)
.text$mn:00006038                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006038
.text$mn:00006038 ; =============== S U B R O U T I N E =======================================
.text$mn:00006038
.text$mn:00006038 ; Attributes: bp-based frame
.text$mn:00006038
.text$mn:00006038 ; public: bool __thiscall std::basic_istream<char, struct std::char_traits<char>>::_Ipfx(bool)
.text$mn:00006038                 public ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
.text$mn:00006038 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z proc near
.text$mn:00006038                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::sentry::sentry(std::basic_istream<char,std::char_traits<char>> &,bool)+43p
.text$mn:00006038
.text$mn:00006038 var_2C          = dword ptr -2Ch
.text$mn:00006038 var_28          = dword ptr -28h
.text$mn:00006038 var_24          = byte ptr -24h
.text$mn:00006038 var_20          = dword ptr -20h
.text$mn:00006038 var_1C          = dword ptr -1Ch
.text$mn:00006038 var_18          = dword ptr -18h
.text$mn:00006038 var_14          = dword ptr -14h
.text$mn:00006038 var_10          = dword ptr -10h
.text$mn:00006038 var_C           = dword ptr -0Ch
.text$mn:00006038 var_4           = dword ptr -4
.text$mn:00006038 arg_0           = byte ptr  8
.text$mn:00006038
.text$mn:00006038 ; FUNCTION CHUNK AT .text$mn:000061D1 SIZE 00000009 BYTES
.text$mn:00006038 ; FUNCTION CHUNK AT .text$mn:000061E1 SIZE 00000047 BYTES
.text$mn:00006038
.text$mn:00006038                 push    ebp
.text$mn:00006039                 mov     ebp, esp
.text$mn:0000603B                 push    0FFFFFFFFh
.text$mn:0000603D                 push    offset __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
.text$mn:00006042                 mov     eax, large fs:0
.text$mn:00006048                 push    eax
.text$mn:00006049                 push    ecx
.text$mn:0000604A                 sub     esp, 1Ch
.text$mn:0000604D                 push    ebx
.text$mn:0000604E                 push    esi
.text$mn:0000604F                 push    edi
.text$mn:00006050                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006055                 xor     eax, ebp
.text$mn:00006057                 push    eax
.text$mn:00006058                 lea     eax, [ebp+var_C]
.text$mn:0000605B                 mov     large fs:0, eax
.text$mn:00006061                 mov     [ebp+var_10], esp
.text$mn:00006064                 mov     [ebp+var_14], ecx
.text$mn:00006067                 mov     eax, [ebp+var_14]
.text$mn:0000606A                 mov     ecx, [eax]
.text$mn:0000606C                 mov     edx, [ebp+var_14]
.text$mn:0000606F                 add     edx, [ecx+4]
.text$mn:00006072                 mov     ecx, edx        ; this
.text$mn:00006074                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:00006079                 movzx   eax, al
.text$mn:0000607C                 test    eax, eax
.text$mn:0000607E                 jz      loc_61FE
.text$mn:00006084                 mov     ecx, [ebp+var_14]
.text$mn:00006087                 mov     edx, [ecx]
.text$mn:00006089                 mov     ecx, [ebp+var_14]
.text$mn:0000608C                 add     ecx, [edx+4]
.text$mn:0000608F                 call    ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
.text$mn:00006094                 test    eax, eax
.text$mn:00006096                 jz      short loc_60B1
.text$mn:00006098                 mov     eax, [ebp+var_14]
.text$mn:0000609B                 mov     ecx, [eax]
.text$mn:0000609D                 mov     edx, [ebp+var_14]
.text$mn:000060A0                 add     edx, [ecx+4]
.text$mn:000060A3                 mov     ecx, edx
.text$mn:000060A5                 call    ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::tie(void)
.text$mn:000060AA                 mov     ecx, eax
.text$mn:000060AC                 call    ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char>>::flush(void)
.text$mn:000060B1
.text$mn:000060B1 loc_60B1:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+5Ej
.text$mn:000060B1                 movzx   eax, [ebp+arg_0]
.text$mn:000060B5                 test    eax, eax
.text$mn:000060B7                 jnz     loc_61E1
.text$mn:000060BD                 mov     ecx, [ebp+var_14]
.text$mn:000060C0                 mov     edx, [ecx]
.text$mn:000060C2                 mov     ecx, [ebp+var_14]
.text$mn:000060C5                 add     ecx, [edx+4]    ; this
.text$mn:000060C8                 call    ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags(void)
.text$mn:000060CD                 and     eax, 1
.text$mn:000060D0                 jz      loc_61E1
.text$mn:000060D6                 lea     eax, [ebp+var_24]
.text$mn:000060D9                 push    eax
.text$mn:000060DA                 mov     ecx, [ebp+var_14]
.text$mn:000060DD                 mov     edx, [ecx]
.text$mn:000060DF                 mov     ecx, [ebp+var_14]
.text$mn:000060E2                 add     ecx, [edx+4]
.text$mn:000060E5                 call    ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc(void)
.text$mn:000060EA                 mov     [ebp+var_1C], eax
.text$mn:000060ED                 mov     eax, [ebp+var_1C]
.text$mn:000060F0                 mov     [ebp+var_20], eax
.text$mn:000060F3                 mov     [ebp+var_4], 0
.text$mn:000060FA                 mov     ecx, [ebp+var_20]
.text$mn:000060FD                 push    ecx             ; std::locale *
.text$mn:000060FE                 call    ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char>>(std::locale const &)
.text$mn:00006103                 add     esp, 4
.text$mn:00006106                 mov     [ebp+var_2C], eax
.text$mn:00006109                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006110                 lea     ecx, [ebp+var_24] ; this
.text$mn:00006113                 call    ??1locale@std@@QAE@XZ ; std::locale::~locale(void)
.text$mn:00006118                 mov     [ebp+var_4], 1
.text$mn:0000611F                 mov     edx, [ebp+var_14]
.text$mn:00006122                 mov     eax, [edx]
.text$mn:00006124                 mov     ecx, [ebp+var_14]
.text$mn:00006127                 add     ecx, [eax+4]
.text$mn:0000612A                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:0000612F                 mov     ecx, eax
.text$mn:00006131                 call    ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)
.text$mn:00006136                 mov     [ebp+var_18], eax
.text$mn:00006139                 jmp     short loc_6155
.text$mn:0000613B ; ---------------------------------------------------------------------------
.text$mn:0000613B
.text$mn:0000613B loc_613B:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool):loc_61B1j
.text$mn:0000613B                 mov     ecx, [ebp+var_14]
.text$mn:0000613E                 mov     edx, [ecx]
.text$mn:00006140                 mov     ecx, [ebp+var_14]
.text$mn:00006143                 add     ecx, [edx+4]
.text$mn:00006146                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:0000614B                 mov     ecx, eax
.text$mn:0000614D                 call    ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::snextc(void)
.text$mn:00006152                 mov     [ebp+var_18], eax
.text$mn:00006155
.text$mn:00006155 loc_6155:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+101j
.text$mn:00006155                 call    ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof(void)
.text$mn:0000615A                 mov     [ebp+var_28], eax
.text$mn:0000615D                 lea     eax, [ebp+var_18]
.text$mn:00006160                 push    eax
.text$mn:00006161                 lea     ecx, [ebp+var_28]
.text$mn:00006164                 push    ecx
.text$mn:00006165                 call    ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
.text$mn:0000616A                 add     esp, 8
.text$mn:0000616D                 movzx   edx, al
.text$mn:00006170                 test    edx, edx
.text$mn:00006172                 jz      short loc_618E
.text$mn:00006174                 push    0
.text$mn:00006176                 push    1
.text$mn:00006178                 mov     eax, [ebp+var_14]
.text$mn:0000617B                 mov     ecx, [eax]
.text$mn:0000617D                 mov     edx, [ebp+var_14]
.text$mn:00006180                 add     edx, [ecx+4]
.text$mn:00006183                 mov     ecx, edx
.text$mn:00006185                 call    ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
.text$mn:0000618A                 jmp     short loc_61B3
.text$mn:0000618C ; ---------------------------------------------------------------------------
.text$mn:0000618C                 jmp     short loc_61B1
.text$mn:0000618E ; ---------------------------------------------------------------------------
.text$mn:0000618E
.text$mn:0000618E loc_618E:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+13Aj
.text$mn:0000618E                 lea     eax, [ebp+var_18]
.text$mn:00006191                 push    eax
.text$mn:00006192                 call    ?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type(int const &)
.text$mn:00006197                 add     esp, 4
.text$mn:0000619A                 movzx   ecx, al
.text$mn:0000619D                 push    ecx
.text$mn:0000619E                 push    48h ; 'H'
.text$mn:000061A0                 mov     ecx, [ebp+var_2C]
.text$mn:000061A3                 call    ?is@?$ctype@D@std@@QBE_NFD@Z ; std::ctype<char>::is(short,char)
.text$mn:000061A8                 movzx   edx, al
.text$mn:000061AB                 test    edx, edx
.text$mn:000061AD                 jnz     short loc_61B1
.text$mn:000061AF                 jmp     short loc_61B3
.text$mn:000061B1 ; ---------------------------------------------------------------------------
.text$mn:000061B1
.text$mn:000061B1 loc_61B1:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+154j
.text$mn:000061B1                                         ; std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+175j
.text$mn:000061B1                 jmp     short loc_613B
.text$mn:000061B3 ; ---------------------------------------------------------------------------
.text$mn:000061B3
.text$mn:000061B3 loc_61B3:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+152j
.text$mn:000061B3                                         ; std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+177j
.text$mn:000061B3                 jmp     short loc_61D1
.text$mn:000061B3 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z endp
.text$mn:000061B3
.text$mn:000061B5
.text$mn:000061B5 ; =============== S U B R O U T I N E =======================================
.text$mn:000061B5
.text$mn:000061B5
.text$mn:000061B5 __catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0 proc near
.text$mn:000061B5                                         ; DATA XREF: .xdata$x:00008640o
.text$mn:000061B5                 push    1
.text$mn:000061B7                 push    4
.text$mn:000061B9                 mov     eax, [ebp-14h]
.text$mn:000061BC                 mov     ecx, [eax]
.text$mn:000061BE                 mov     edx, [ebp-14h]
.text$mn:000061C1                 add     edx, [ecx+4]
.text$mn:000061C4                 mov     ecx, edx
.text$mn:000061C6                 call    ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
.text$mn:000061CB                 mov     eax, offset $LN18
.text$mn:000061D0                 retn
.text$mn:000061D0 __catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0 endp
.text$mn:000061D0
.text$mn:000061D1 ; ---------------------------------------------------------------------------
.text$mn:000061D1 ; START OF FUNCTION CHUNK FOR ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
.text$mn:000061D1
.text$mn:000061D1 loc_61D1:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool):loc_61B3j
.text$mn:000061D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000061D8                 jmp     short loc_61E1
.text$mn:000061D8 ; END OF FUNCTION CHUNK FOR ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
.text$mn:000061DA
.text$mn:000061DA ; =============== S U B R O U T I N E =======================================
.text$mn:000061DA
.text$mn:000061DA
.text$mn:000061DA $LN18           proc near               ; DATA XREF: __catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0+16o
.text$mn:000061DA                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000061DA $LN18           endp ; sp-analysis failed
.text$mn:000061DA
.text$mn:000061E1 ; START OF FUNCTION CHUNK FOR ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
.text$mn:000061E1
.text$mn:000061E1 loc_61E1:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+7Fj
.text$mn:000061E1                                         ; std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+98j ...
.text$mn:000061E1                 mov     eax, [ebp+var_14]
.text$mn:000061E4                 mov     ecx, [eax]
.text$mn:000061E6                 mov     edx, [ebp+var_14]
.text$mn:000061E9                 add     edx, [ecx+4]
.text$mn:000061EC                 mov     ecx, edx        ; this
.text$mn:000061EE                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:000061F3                 movzx   eax, al
.text$mn:000061F6                 test    eax, eax
.text$mn:000061F8                 jz      short loc_61FE
.text$mn:000061FA                 mov     al, 1
.text$mn:000061FC                 jmp     short loc_6214
.text$mn:000061FE ; ---------------------------------------------------------------------------
.text$mn:000061FE
.text$mn:000061FE loc_61FE:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+46j
.text$mn:000061FE                                         ; std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+1C0j
.text$mn:000061FE                 push    0
.text$mn:00006200                 push    2
.text$mn:00006202                 mov     ecx, [ebp+var_14]
.text$mn:00006205                 mov     edx, [ecx]
.text$mn:00006207                 mov     ecx, [ebp+var_14]
.text$mn:0000620A                 add     ecx, [edx+4]
.text$mn:0000620D                 call    ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
.text$mn:00006212                 xor     al, al
.text$mn:00006214
.text$mn:00006214 loc_6214:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+1C4j
.text$mn:00006214                 mov     ecx, [ebp+var_C]
.text$mn:00006217                 mov     large fs:0, ecx
.text$mn:0000621E                 pop     ecx
.text$mn:0000621F                 pop     edi
.text$mn:00006220                 pop     esi
.text$mn:00006221                 pop     ebx
.text$mn:00006222                 mov     esp, ebp
.text$mn:00006224                 pop     ebp
.text$mn:00006225                 retn    4
.text$mn:00006225 ; END OF FUNCTION CHUNK FOR ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
.text$mn:00006225 _text$mn        ends
.text$mn:00006225
.text$x:00006228 ; ===========================================================================
.text$x:00006228
.text$x:00006228 ; Segment type: Pure code
.text$x:00006228 ; Segment permissions: Read/Execute
.text$x:00006228 _text$x         segment para public 'CODE' use32
.text$x:00006228                 assume cs:_text$x
.text$x:00006228                 ;org 6228h
.text$x:00006228 ; COMDAT (pick associative to section at 6038)
.text$x:00006228                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006228
.text$x:00006228 ; =============== S U B R O U T I N E =======================================
.text$x:00006228
.text$x:00006228
.text$x:00006228 __unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2 proc near
.text$x:00006228                                         ; DATA XREF: .xdata$x:0000865Co
.text$x:00006228                 lea     ecx, [ebp-24h]  ; this
.text$x:0000622B                 jmp     ??1locale@std@@QAE@XZ ; std::locale::~locale(void)
.text$x:0000622B __unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2 endp
.text$x:0000622B
.text$x:00006230
.text$x:00006230 ; =============== S U B R O U T I N E =======================================
.text$x:00006230
.text$x:00006230
.text$x:00006230 __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z proc near
.text$x:00006230                                         ; DATA XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+5o
.text$x:00006230
.text$x:00006230 arg_4           = dword ptr  8
.text$x:00006230
.text$x:00006230                 mov     edx, [esp+arg_4]
.text$x:00006234                 lea     eax, [edx+0Ch]
.text$x:00006237                 mov     ecx, [edx-30h]
.text$x:0000623A                 xor     ecx, eax
.text$x:0000623C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006241                 mov     eax, offset __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
.text$x:00006246                 jmp     ___CxxFrameHandler3
.text$x:00006246 __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z endp
.text$x:00006246
.text$x:00006246 ; ---------------------------------------------------------------------------
.text$x:0000624B                 align 4
.text$x:0000624B _text$x         ends
.text$x:0000624B
.text$mn:0000624C ; ===========================================================================
.text$mn:0000624C
.text$mn:0000624C ; Segment type: Pure code
.text$mn:0000624C ; Segment permissions: Read/Execute
.text$mn:0000624C _text$mn        segment para public 'CODE' use32
.text$mn:0000624C                 assume cs:_text$mn
.text$mn:0000624C                 ;org 624Ch
.text$mn:0000624C ; COMDAT (pick any)
.text$mn:0000624C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000624C
.text$mn:0000624C ; =============== S U B R O U T I N E =======================================
.text$mn:0000624C
.text$mn:0000624C ; Attributes: bp-based frame
.text$mn:0000624C
.text$mn:0000624C ; private: static class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __cdecl std::_System_error::_Makestr(class std::error_code, class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>)
.text$mn:0000624C                 public ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
.text$mn:0000624C ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z proc near
.text$mn:0000624C                                         ; CODE XREF: std::_System_error::_System_error(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Fp
.text$mn:0000624C
.text$mn:0000624C var_38          = dword ptr -38h
.text$mn:0000624C var_34          = dword ptr -34h
.text$mn:0000624C var_30          = dword ptr -30h
.text$mn:0000624C var_2C          = byte ptr -2Ch
.text$mn:0000624C var_10          = dword ptr -10h
.text$mn:0000624C var_C           = dword ptr -0Ch
.text$mn:0000624C var_4           = dword ptr -4
.text$mn:0000624C arg_0           = dword ptr  8
.text$mn:0000624C arg_4           = byte ptr  0Ch
.text$mn:0000624C arg_C           = byte ptr  14h
.text$mn:0000624C
.text$mn:0000624C                 push    ebp
.text$mn:0000624D                 mov     ebp, esp
.text$mn:0000624F                 push    0FFFFFFFFh
.text$mn:00006251                 push    offset __ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
.text$mn:00006256                 mov     eax, large fs:0
.text$mn:0000625C                 push    eax
.text$mn:0000625D                 sub     esp, 2Ch
.text$mn:00006260                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006265                 xor     eax, ebp
.text$mn:00006267                 mov     [ebp+var_10], eax
.text$mn:0000626A                 push    eax
.text$mn:0000626B                 lea     eax, [ebp+var_C]
.text$mn:0000626E                 mov     large fs:0, eax
.text$mn:00006274                 mov     [ebp+var_30], 0
.text$mn:0000627B                 mov     [ebp+var_4], 1
.text$mn:00006282                 lea     ecx, [ebp+arg_C]
.text$mn:00006285                 call    ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(void)
.text$mn:0000628A                 movzx   eax, al
.text$mn:0000628D                 test    eax, eax
.text$mn:0000628F                 jnz     short loc_629E
.text$mn:00006291                 push    offset ??_C@_02LMMGGCAJ@?3?5?$AA@ ; ": "
.text$mn:00006296                 lea     ecx, [ebp+arg_C]
.text$mn:00006299                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *)
.text$mn:0000629E
.text$mn:0000629E loc_629E:                               ; CODE XREF: std::_System_error::_Makestr(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>>)+43j
.text$mn:0000629E                 lea     ecx, [ebp+var_2C]
.text$mn:000062A1                 push    ecx
.text$mn:000062A2                 lea     ecx, [ebp+arg_4]
.text$mn:000062A5                 call    ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message(void)
.text$mn:000062AA                 mov     [ebp+var_34], eax
.text$mn:000062AD                 mov     edx, [ebp+var_34]
.text$mn:000062B0                 mov     [ebp+var_38], edx
.text$mn:000062B3                 mov     byte ptr [ebp+var_4], 2
.text$mn:000062B7                 mov     eax, [ebp+var_38]
.text$mn:000062BA                 push    eax
.text$mn:000062BB                 lea     ecx, [ebp+arg_C]
.text$mn:000062BE                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
.text$mn:000062C3                 mov     byte ptr [ebp+var_4], 1
.text$mn:000062C7                 lea     ecx, [ebp+var_2C]
.text$mn:000062CA                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000062CF                 lea     ecx, [ebp+arg_C]
.text$mn:000062D2                 push    ecx
.text$mn:000062D3                 mov     ecx, [ebp+arg_0]
.text$mn:000062D6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)
.text$mn:000062DB                 mov     edx, [ebp+var_30]
.text$mn:000062DE                 or      edx, 1
.text$mn:000062E1                 mov     [ebp+var_30], edx
.text$mn:000062E4                 mov     byte ptr [ebp+var_4], 0
.text$mn:000062E8                 lea     ecx, [ebp+arg_C]
.text$mn:000062EB                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000062F0                 mov     eax, [ebp+arg_0]
.text$mn:000062F3                 mov     ecx, [ebp+var_C]
.text$mn:000062F6                 mov     large fs:0, ecx
.text$mn:000062FD                 pop     ecx
.text$mn:000062FE                 mov     ecx, [ebp+var_10]
.text$mn:00006301                 xor     ecx, ebp
.text$mn:00006303                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00006308                 mov     esp, ebp
.text$mn:0000630A                 pop     ebp
.text$mn:0000630B                 retn
.text$mn:0000630B ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z endp
.text$mn:0000630B
.text$mn:0000630B _text$mn        ends
.text$mn:0000630B
.text$x:0000630C ; ===========================================================================
.text$x:0000630C
.text$x:0000630C ; Segment type: Pure code
.text$x:0000630C ; Segment permissions: Read/Execute
.text$x:0000630C _text$x         segment para public 'CODE' use32
.text$x:0000630C                 assume cs:_text$x
.text$x:0000630C                 ;org 630Ch
.text$x:0000630C ; COMDAT (pick associative to section at 624C)
.text$x:0000630C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000630C
.text$x:0000630C ; =============== S U B R O U T I N E =======================================
.text$x:0000630C
.text$x:0000630C
.text$x:0000630C __unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0 proc near
.text$x:0000630C                                         ; DATA XREF: .xdata$x:00008298o
.text$x:0000630C                 lea     ecx, [ebp+14h]
.text$x:0000630F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000630F __unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0 endp
.text$x:0000630F
.text$x:00006314
.text$x:00006314 ; =============== S U B R O U T I N E =======================================
.text$x:00006314
.text$x:00006314
.text$x:00006314 __unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1 proc near
.text$x:00006314                                         ; DATA XREF: .xdata$x:000082A0o
.text$x:00006314                 lea     ecx, [ebp-2Ch]
.text$x:00006317                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00006317 __unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1 endp
.text$x:00006317
.text$x:0000631C
.text$x:0000631C ; =============== S U B R O U T I N E =======================================
.text$x:0000631C
.text$x:0000631C
.text$x:0000631C __unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$2 proc near
.text$x:0000631C                                         ; DATA XREF: .xdata$x:00008290o
.text$x:0000631C                 mov     eax, [ebp-30h]
.text$x:0000631F                 and     eax, 1
.text$x:00006322                 jz      $LN7
.text$x:00006328                 and     dword ptr [ebp-30h], 0FFFFFFFEh
.text$x:0000632C                 mov     ecx, [ebp+8]
.text$x:0000632F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00006334 ; ---------------------------------------------------------------------------
.text$x:00006334
.text$x:00006334 $LN7:                                   ; CODE XREF: __unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$2+6j
.text$x:00006334                 retn
.text$x:00006334 __unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$2 endp
.text$x:00006334
.text$x:00006335
.text$x:00006335 ; =============== S U B R O U T I N E =======================================
.text$x:00006335
.text$x:00006335
.text$x:00006335 __ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z proc near
.text$x:00006335                                         ; DATA XREF: std::_System_error::_Makestr(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>>)+5o
.text$x:00006335
.text$x:00006335 arg_4           = dword ptr  8
.text$x:00006335
.text$x:00006335                 mov     edx, [esp+arg_4]
.text$x:00006339                 lea     eax, [edx+0Ch]
.text$x:0000633C                 mov     ecx, [edx-30h]
.text$x:0000633F                 xor     ecx, eax
.text$x:00006341                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006346                 mov     ecx, [edx-4]
.text$x:00006349                 xor     ecx, eax
.text$x:0000634B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006350                 mov     eax, offset __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
.text$x:00006355                 jmp     ___CxxFrameHandler3
.text$x:00006355 __ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z endp
.text$x:00006355
.text$x:00006355 ; ---------------------------------------------------------------------------
.text$x:0000635A                 align 4
.text$x:0000635A _text$x         ends
.text$x:0000635A
.text$mn:0000635C ; ===========================================================================
.text$mn:0000635C
.text$mn:0000635C ; Segment type: Pure code
.text$mn:0000635C ; Segment permissions: Read/Execute
.text$mn:0000635C _text$mn        segment para public 'CODE' use32
.text$mn:0000635C                 assume cs:_text$mn
.text$mn:0000635C                 ;org 635Ch
.text$mn:0000635C ; COMDAT (pick any)
.text$mn:0000635C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000635C
.text$mn:0000635C ; =============== S U B R O U T I N E =======================================
.text$mn:0000635C
.text$mn:0000635C ; Attributes: bp-based frame
.text$mn:0000635C
.text$mn:0000635C ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000635C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:0000635C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:0000635C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)+14p
.text$mn:0000635C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)+33p ...
.text$mn:0000635C
.text$mn:0000635C var_8           = dword ptr -8
.text$mn:0000635C var_4           = dword ptr -4
.text$mn:0000635C
.text$mn:0000635C                 push    ebp
.text$mn:0000635D                 mov     ebp, esp
.text$mn:0000635F                 sub     esp, 8
.text$mn:00006362                 mov     [ebp+var_4], ecx
.text$mn:00006365                 mov     eax, [ebp+var_4]
.text$mn:00006368                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000636C                 jb      short loc_6382
.text$mn:0000636E                 mov     ecx, [ebp+var_4]
.text$mn:00006371                 mov     edx, [ecx+4]
.text$mn:00006374                 push    edx
.text$mn:00006375                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000637A                 add     esp, 4
.text$mn:0000637D                 mov     [ebp+var_8], eax
.text$mn:00006380                 jmp     short loc_638B
.text$mn:00006382 ; ---------------------------------------------------------------------------
.text$mn:00006382
.text$mn:00006382 loc_6382:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00006382                 mov     eax, [ebp+var_4]
.text$mn:00006385                 add     eax, 4
.text$mn:00006388                 mov     [ebp+var_8], eax
.text$mn:0000638B
.text$mn:0000638B loc_638B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000638B                 mov     eax, [ebp+var_8]
.text$mn:0000638E                 mov     esp, ebp
.text$mn:00006390                 pop     ebp
.text$mn:00006391                 retn
.text$mn:00006391 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00006391
.text$mn:00006391 ; ---------------------------------------------------------------------------
.text$mn:00006392                 align 4
.text$mn:00006392 _text$mn        ends
.text$mn:00006392
.text$mn:00006394 ; ===========================================================================
.text$mn:00006394
.text$mn:00006394 ; Segment type: Pure code
.text$mn:00006394 ; Segment permissions: Read/Execute
.text$mn:00006394 _text$mn        segment para public 'CODE' use32
.text$mn:00006394                 assume cs:_text$mn
.text$mn:00006394                 ;org 6394h
.text$mn:00006394 ; COMDAT (pick any)
.text$mn:00006394                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006394
.text$mn:00006394 ; =============== S U B R O U T I N E =======================================
.text$mn:00006394
.text$mn:00006394 ; Attributes: bp-based frame
.text$mn:00006394
.text$mn:00006394 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00006394                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00006394 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00006394                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator[](uint)+2Cp
.text$mn:00006394                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+80p ...
.text$mn:00006394
.text$mn:00006394 var_8           = dword ptr -8
.text$mn:00006394 var_4           = dword ptr -4
.text$mn:00006394
.text$mn:00006394                 push    ebp
.text$mn:00006395                 mov     ebp, esp
.text$mn:00006397                 sub     esp, 8
.text$mn:0000639A                 mov     [ebp+var_4], ecx
.text$mn:0000639D                 mov     eax, [ebp+var_4]
.text$mn:000063A0                 cmp     dword ptr [eax+18h], 10h
.text$mn:000063A4                 jb      short loc_63BA
.text$mn:000063A6                 mov     ecx, [ebp+var_4]
.text$mn:000063A9                 mov     edx, [ecx+4]
.text$mn:000063AC                 push    edx
.text$mn:000063AD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000063B2                 add     esp, 4
.text$mn:000063B5                 mov     [ebp+var_8], eax
.text$mn:000063B8                 jmp     short loc_63C3
.text$mn:000063BA ; ---------------------------------------------------------------------------
.text$mn:000063BA
.text$mn:000063BA loc_63BA:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000063BA                 mov     eax, [ebp+var_4]
.text$mn:000063BD                 add     eax, 4
.text$mn:000063C0                 mov     [ebp+var_8], eax
.text$mn:000063C3
.text$mn:000063C3 loc_63C3:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000063C3                 mov     eax, [ebp+var_8]
.text$mn:000063C6                 mov     esp, ebp
.text$mn:000063C8                 pop     ebp
.text$mn:000063C9                 retn
.text$mn:000063C9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000063C9
.text$mn:000063C9 ; ---------------------------------------------------------------------------
.text$mn:000063CA                 align 4
.text$mn:000063CA _text$mn        ends
.text$mn:000063CA
.text$mn:000063CC ; ===========================================================================
.text$mn:000063CC
.text$mn:000063CC ; Segment type: Pure code
.text$mn:000063CC ; Segment permissions: Read/Execute
.text$mn:000063CC _text$mn        segment para public 'CODE' use32
.text$mn:000063CC                 assume cs:_text$mn
.text$mn:000063CC                 ;org 63CCh
.text$mn:000063CC ; COMDAT (pick any)
.text$mn:000063CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063CC
.text$mn:000063CC ; =============== S U B R O U T I N E =======================================
.text$mn:000063CC
.text$mn:000063CC ; Attributes: bp-based frame
.text$mn:000063CC
.text$mn:000063CC ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000063CC                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000063CC ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000063CC                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000063CC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:000063CC
.text$mn:000063CC var_18          = byte ptr -18h
.text$mn:000063CC var_14          = dword ptr -14h
.text$mn:000063CC var_10          = dword ptr -10h
.text$mn:000063CC var_C           = dword ptr -0Ch
.text$mn:000063CC var_4           = dword ptr -4
.text$mn:000063CC
.text$mn:000063CC                 push    ebp
.text$mn:000063CD                 mov     ebp, esp
.text$mn:000063CF                 push    0FFFFFFFFh
.text$mn:000063D1                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000063D6                 mov     eax, large fs:0
.text$mn:000063DC                 push    eax
.text$mn:000063DD                 sub     esp, 0Ch
.text$mn:000063E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000063E5                 xor     eax, ebp
.text$mn:000063E7                 push    eax
.text$mn:000063E8                 lea     eax, [ebp+var_C]
.text$mn:000063EB                 mov     large fs:0, eax
.text$mn:000063F1                 mov     [ebp+var_14], ecx
.text$mn:000063F4                 mov     eax, [ebp+var_14]
.text$mn:000063F7                 cmp     dword ptr [eax], 0
.text$mn:000063FA                 jz      short loc_6457
.text$mn:000063FC                 push    3               ; int
.text$mn:000063FE                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006401                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006406                 mov     [ebp+var_4], 0
.text$mn:0000640D                 mov     ecx, [ebp+var_14]
.text$mn:00006410                 mov     edx, [ecx]
.text$mn:00006412                 add     edx, 4
.text$mn:00006415                 mov     [ebp+var_10], edx
.text$mn:00006418                 jmp     short loc_6427
.text$mn:0000641A ; ---------------------------------------------------------------------------
.text$mn:0000641A
.text$mn:0000641A loc_641A:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000641A                 mov     eax, [ebp+var_10]
.text$mn:0000641D                 mov     ecx, [eax]
.text$mn:0000641F                 mov     edx, [ebp+var_10]
.text$mn:00006422                 mov     eax, [ecx+4]
.text$mn:00006425                 mov     [edx], eax
.text$mn:00006427
.text$mn:00006427 loc_6427:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00006427                 mov     ecx, [ebp+var_10]
.text$mn:0000642A                 cmp     dword ptr [ecx], 0
.text$mn:0000642D                 jz      short loc_643C
.text$mn:0000642F                 mov     edx, [ebp+var_10]
.text$mn:00006432                 mov     eax, [edx]
.text$mn:00006434                 mov     dword ptr [eax], 0
.text$mn:0000643A                 jmp     short loc_641A
.text$mn:0000643C ; ---------------------------------------------------------------------------
.text$mn:0000643C
.text$mn:0000643C loc_643C:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000643C                 mov     ecx, [ebp+var_14]
.text$mn:0000643F                 mov     edx, [ecx]
.text$mn:00006441                 mov     dword ptr [edx+4], 0
.text$mn:00006448                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000644F                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006452                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006457
.text$mn:00006457 loc_6457:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00006457                 mov     ecx, [ebp+var_C]
.text$mn:0000645A                 mov     large fs:0, ecx
.text$mn:00006461                 pop     ecx
.text$mn:00006462                 mov     esp, ebp
.text$mn:00006464                 pop     ebp
.text$mn:00006465                 retn
.text$mn:00006465 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00006465
.text$mn:00006465 ; ---------------------------------------------------------------------------
.text$mn:00006466                 align 4
.text$mn:00006466 _text$mn        ends
.text$mn:00006466
.text$x:00006468 ; ===========================================================================
.text$x:00006468
.text$x:00006468 ; Segment type: Pure code
.text$x:00006468 ; Segment permissions: Read/Execute
.text$x:00006468 _text$x         segment para public 'CODE' use32
.text$x:00006468                 assume cs:_text$x
.text$x:00006468                 ;org 6468h
.text$x:00006468 ; COMDAT (pick associative to section at 63CC)
.text$x:00006468                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006468
.text$x:00006468 ; =============== S U B R O U T I N E =======================================
.text$x:00006468
.text$x:00006468
.text$x:00006468 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00006468                                         ; DATA XREF: .xdata$x:00007D1Co
.text$x:00006468                 lea     ecx, [ebp-18h]  ; this
.text$x:0000646B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000646B __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000646B
.text$x:00006470
.text$x:00006470 ; =============== S U B R O U T I N E =======================================
.text$x:00006470
.text$x:00006470
.text$x:00006470 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00006470                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00006470
.text$x:00006470 arg_4           = dword ptr  8
.text$x:00006470
.text$x:00006470                 mov     edx, [esp+arg_4]
.text$x:00006474                 lea     eax, [edx+0Ch]
.text$x:00006477                 mov     ecx, [edx-10h]
.text$x:0000647A                 xor     ecx, eax
.text$x:0000647C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006481                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00006486                 jmp     ___CxxFrameHandler3
.text$x:00006486 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00006486
.text$x:00006486 ; ---------------------------------------------------------------------------
.text$x:0000648B                 align 4
.text$x:0000648B _text$x         ends
.text$x:0000648B
.text$mn:0000648C ; ===========================================================================
.text$mn:0000648C
.text$mn:0000648C ; Segment type: Pure code
.text$mn:0000648C ; Segment permissions: Read/Execute
.text$mn:0000648C _text$mn        segment para public 'CODE' use32
.text$mn:0000648C                 assume cs:_text$mn
.text$mn:0000648C                 ;org 648Ch
.text$mn:0000648C ; COMDAT (pick any)
.text$mn:0000648C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000648C
.text$mn:0000648C ; =============== S U B R O U T I N E =======================================
.text$mn:0000648C
.text$mn:0000648C ; Attributes: bp-based frame
.text$mn:0000648C
.text$mn:0000648C ; public: void __thiscall std::basic_ostream<char, struct std::char_traits<char>>::_Osfx(void)
.text$mn:0000648C                 public ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
.text$mn:0000648C ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ proc near
.text$mn:0000648C                                         ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+3Ep
.text$mn:0000648C
.text$mn:0000648C var_14          = dword ptr -14h
.text$mn:0000648C var_10          = dword ptr -10h
.text$mn:0000648C var_C           = byte ptr -0Ch
.text$mn:0000648C var_4           = dword ptr -4
.text$mn:0000648C
.text$mn:0000648C ; FUNCTION CHUNK AT .text$mn:0000652A SIZE 00000009 BYTES
.text$mn:0000648C
.text$mn:0000648C                 push    ebp
.text$mn:0000648D                 mov     ebp, esp
.text$mn:0000648F                 push    0FFFFFFFFh
.text$mn:00006491                 push    offset __ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
.text$mn:00006496                 mov     eax, large fs:0
.text$mn:0000649C                 push    eax
.text$mn:0000649D                 push    ecx
.text$mn:0000649E                 push    ecx
.text$mn:0000649F                 push    ebx
.text$mn:000064A0                 push    esi
.text$mn:000064A1                 push    edi
.text$mn:000064A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000064A7                 xor     eax, ebp
.text$mn:000064A9                 push    eax
.text$mn:000064AA                 lea     eax, [ebp+var_C]
.text$mn:000064AD                 mov     large fs:0, eax
.text$mn:000064B3                 mov     [ebp+var_10], esp
.text$mn:000064B6                 mov     [ebp+var_14], ecx
.text$mn:000064B9                 mov     [ebp+var_4], 0
.text$mn:000064C0                 mov     eax, [ebp+var_14]
.text$mn:000064C3                 mov     ecx, [eax]
.text$mn:000064C5                 mov     edx, [ebp+var_14]
.text$mn:000064C8                 add     edx, [ecx+4]
.text$mn:000064CB                 mov     ecx, edx        ; this
.text$mn:000064CD                 call    ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good(void)
.text$mn:000064D2                 movzx   eax, al
.text$mn:000064D5                 test    eax, eax
.text$mn:000064D7                 jz      short loc_6522
.text$mn:000064D9                 mov     ecx, [ebp+var_14]
.text$mn:000064DC                 mov     edx, [ecx]
.text$mn:000064DE                 mov     ecx, [ebp+var_14]
.text$mn:000064E1                 add     ecx, [edx+4]    ; this
.text$mn:000064E4                 call    ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags(void)
.text$mn:000064E9                 and     eax, 2
.text$mn:000064EC                 jz      short loc_6522
.text$mn:000064EE                 mov     eax, [ebp+var_14]
.text$mn:000064F1                 mov     ecx, [eax]
.text$mn:000064F3                 mov     edx, [ebp+var_14]
.text$mn:000064F6                 add     edx, [ecx+4]
.text$mn:000064F9                 mov     ecx, edx
.text$mn:000064FB                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00006500                 mov     ecx, eax
.text$mn:00006502                 call    ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::pubsync(void)
.text$mn:00006507                 cmp     eax, 0FFFFFFFFh
.text$mn:0000650A                 jnz     short loc_6522
.text$mn:0000650C                 push    0
.text$mn:0000650E                 push    4
.text$mn:00006510                 mov     eax, [ebp+var_14]
.text$mn:00006513                 mov     ecx, [eax]
.text$mn:00006515                 mov     edx, [ebp+var_14]
.text$mn:00006518                 add     edx, [ecx+4]
.text$mn:0000651B                 mov     ecx, edx
.text$mn:0000651D                 call    ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
.text$mn:00006522
.text$mn:00006522 loc_6522:                               ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::_Osfx(void)+4Bj
.text$mn:00006522                                         ; std::basic_ostream<char,std::char_traits<char>>::_Osfx(void)+60j ...
.text$mn:00006522                 jmp     short loc_652A
.text$mn:00006522 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ endp
.text$mn:00006522
.text$mn:00006524
.text$mn:00006524 ; =============== S U B R O U T I N E =======================================
.text$mn:00006524
.text$mn:00006524
.text$mn:00006524 __catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0 proc near
.text$mn:00006524                                         ; DATA XREF: .xdata$x:000087B8o
.text$mn:00006524                 mov     eax, offset $LN9
.text$mn:00006529                 retn
.text$mn:00006529 __catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0 endp
.text$mn:00006529
.text$mn:0000652A ; ---------------------------------------------------------------------------
.text$mn:0000652A ; START OF FUNCTION CHUNK FOR ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
.text$mn:0000652A
.text$mn:0000652A loc_652A:                               ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::_Osfx(void):loc_6522j
.text$mn:0000652A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006531                 jmp     short loc_653A
.text$mn:00006531 ; END OF FUNCTION CHUNK FOR ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
.text$mn:00006533
.text$mn:00006533 ; =============== S U B R O U T I N E =======================================
.text$mn:00006533
.text$mn:00006533
.text$mn:00006533 $LN9            proc near               ; DATA XREF: __catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0o
.text$mn:00006533                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000653A
.text$mn:0000653A loc_653A:                               ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::_Osfx(void)+A5j
.text$mn:0000653A                 mov     ecx, [ebp-0Ch]
.text$mn:0000653D                 mov     large fs:0, ecx
.text$mn:00006544                 pop     ecx
.text$mn:00006545                 pop     edi
.text$mn:00006546                 pop     esi
.text$mn:00006547                 pop     ebx
.text$mn:00006548                 mov     esp, ebp
.text$mn:0000654A                 pop     ebp
.text$mn:0000654B                 retn
.text$mn:0000654B $LN9            endp ; sp-analysis failed
.text$mn:0000654B
.text$mn:0000654B _text$mn        ends
.text$mn:0000654B
.text$x:0000654C ; ===========================================================================
.text$x:0000654C
.text$x:0000654C ; Segment type: Pure code
.text$x:0000654C ; Segment permissions: Read/Execute
.text$x:0000654C _text$x         segment para public 'CODE' use32
.text$x:0000654C                 assume cs:_text$x
.text$x:0000654C                 ;org 654Ch
.text$x:0000654C ; COMDAT (pick associative to section at 648C)
.text$x:0000654C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000654C
.text$x:0000654C ; =============== S U B R O U T I N E =======================================
.text$x:0000654C
.text$x:0000654C
.text$x:0000654C __ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ proc near
.text$x:0000654C                                         ; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::_Osfx(void)+5o
.text$x:0000654C
.text$x:0000654C arg_4           = dword ptr  8
.text$x:0000654C
.text$x:0000654C                 mov     edx, [esp+arg_4]
.text$x:00006550                 lea     eax, [edx+0Ch]
.text$x:00006553                 mov     ecx, [edx-18h]
.text$x:00006556                 xor     ecx, eax
.text$x:00006558                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000655D                 mov     eax, offset __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
.text$x:00006562                 jmp     ___CxxFrameHandler3
.text$x:00006562 __ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ endp
.text$x:00006562
.text$x:00006562 ; ---------------------------------------------------------------------------
.text$x:00006567                 align 4
.text$x:00006567 _text$x         ends
.text$x:00006567
.text$mn:00006568 ; ===========================================================================
.text$mn:00006568
.text$mn:00006568 ; Segment type: Pure code
.text$mn:00006568 ; Segment permissions: Read/Execute
.text$mn:00006568 _text$mn        segment para public 'CODE' use32
.text$mn:00006568                 assume cs:_text$mn
.text$mn:00006568                 ;org 6568h
.text$mn:00006568 ; COMDAT (pick any)
.text$mn:00006568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006568
.text$mn:00006568 ; =============== S U B R O U T I N E =======================================
.text$mn:00006568
.text$mn:00006568 ; Attributes: bp-based frame
.text$mn:00006568
.text$mn:00006568 ; private: void __thiscall std::_Yarn<char>::_Tidy(void)
.text$mn:00006568                 public ?_Tidy@?$_Yarn@D@std@@AAEXXZ
.text$mn:00006568 ?_Tidy@?$_Yarn@D@std@@AAEXXZ proc near  ; CODE XREF: std::_Yarn<char>::~_Yarn<char>(void)+Ap
.text$mn:00006568
.text$mn:00006568 var_4           = dword ptr -4
.text$mn:00006568
.text$mn:00006568                 push    ebp
.text$mn:00006569                 mov     ebp, esp
.text$mn:0000656B                 push    ecx
.text$mn:0000656C                 mov     [ebp+var_4], ecx
.text$mn:0000656F                 mov     eax, [ebp+var_4]
.text$mn:00006572                 cmp     dword ptr [eax], 0
.text$mn:00006575                 jz      short loc_6587
.text$mn:00006577                 push    2
.text$mn:00006579                 mov     ecx, [ebp+var_4]
.text$mn:0000657C                 mov     edx, [ecx]
.text$mn:0000657E                 push    edx
.text$mn:0000657F                 call    __free_dbg
.text$mn:00006584                 add     esp, 8
.text$mn:00006587
.text$mn:00006587 loc_6587:                               ; CODE XREF: std::_Yarn<char>::_Tidy(void)+Dj
.text$mn:00006587                 mov     eax, [ebp+var_4]
.text$mn:0000658A                 mov     dword ptr [eax], 0
.text$mn:00006590                 mov     esp, ebp
.text$mn:00006592                 pop     ebp
.text$mn:00006593                 retn
.text$mn:00006593 ?_Tidy@?$_Yarn@D@std@@AAEXXZ endp
.text$mn:00006593
.text$mn:00006593 _text$mn        ends
.text$mn:00006593
.text$mn:00006594 ; ===========================================================================
.text$mn:00006594
.text$mn:00006594 ; Segment type: Pure code
.text$mn:00006594 ; Segment permissions: Read/Execute
.text$mn:00006594 _text$mn        segment para public 'CODE' use32
.text$mn:00006594                 assume cs:_text$mn
.text$mn:00006594                 ;org 6594h
.text$mn:00006594 ; COMDAT (pick any)
.text$mn:00006594                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006594
.text$mn:00006594 ; =============== S U B R O U T I N E =======================================
.text$mn:00006594
.text$mn:00006594 ; Attributes: bp-based frame
.text$mn:00006594
.text$mn:00006594 ; private: void __thiscall std::_Yarn<wchar_t>::_Tidy(void)
.text$mn:00006594                 public ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
.text$mn:00006594 ?_Tidy@?$_Yarn@_W@std@@AAEXXZ proc near ; CODE XREF: std::_Yarn<wchar_t>::~_Yarn<wchar_t>(void)+Ap
.text$mn:00006594
.text$mn:00006594 var_4           = dword ptr -4
.text$mn:00006594
.text$mn:00006594                 push    ebp
.text$mn:00006595                 mov     ebp, esp
.text$mn:00006597                 push    ecx
.text$mn:00006598                 mov     [ebp+var_4], ecx
.text$mn:0000659B                 mov     eax, [ebp+var_4]
.text$mn:0000659E                 cmp     dword ptr [eax], 0
.text$mn:000065A1                 jz      short loc_65B3
.text$mn:000065A3                 push    2
.text$mn:000065A5                 mov     ecx, [ebp+var_4]
.text$mn:000065A8                 mov     edx, [ecx]
.text$mn:000065AA                 push    edx
.text$mn:000065AB                 call    __free_dbg
.text$mn:000065B0                 add     esp, 8
.text$mn:000065B3
.text$mn:000065B3 loc_65B3:                               ; CODE XREF: std::_Yarn<wchar_t>::_Tidy(void)+Dj
.text$mn:000065B3                 mov     eax, [ebp+var_4]
.text$mn:000065B6                 mov     dword ptr [eax], 0
.text$mn:000065BC                 mov     esp, ebp
.text$mn:000065BE                 pop     ebp
.text$mn:000065BF                 retn
.text$mn:000065BF ?_Tidy@?$_Yarn@_W@std@@AAEXXZ endp
.text$mn:000065BF
.text$mn:000065BF _text$mn        ends
.text$mn:000065BF
.text$mn:000065C0 ; ===========================================================================
.text$mn:000065C0
.text$mn:000065C0 ; Segment type: Pure code
.text$mn:000065C0 ; Segment permissions: Read/Execute
.text$mn:000065C0 _text$mn        segment para public 'CODE' use32
.text$mn:000065C0                 assume cs:_text$mn
.text$mn:000065C0                 ;org 65C0h
.text$mn:000065C0 ; COMDAT (pick any)
.text$mn:000065C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065C0
.text$mn:000065C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000065C0
.text$mn:000065C0 ; Attributes: bp-based frame
.text$mn:000065C0
.text$mn:000065C0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000065C0                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000065C0 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000065C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+4Bp
.text$mn:000065C0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+56p ...
.text$mn:000065C0
.text$mn:000065C0 var_C           = dword ptr -0Ch
.text$mn:000065C0 var_8           = dword ptr -8
.text$mn:000065C0 var_2           = byte ptr -2
.text$mn:000065C0 var_1           = byte ptr -1
.text$mn:000065C0 arg_0           = byte ptr  8
.text$mn:000065C0 Size            = dword ptr  0Ch
.text$mn:000065C0
.text$mn:000065C0                 push    ebp
.text$mn:000065C1                 mov     ebp, esp
.text$mn:000065C3                 sub     esp, 0Ch
.text$mn:000065C6                 mov     [ebp+var_8], ecx
.text$mn:000065C9                 movzx   eax, [ebp+arg_0]
.text$mn:000065CD                 test    eax, eax
.text$mn:000065CF                 jnz     short loc_65D3
.text$mn:000065D1                 jmp     short loc_6646
.text$mn:000065D3 ; ---------------------------------------------------------------------------
.text$mn:000065D3
.text$mn:000065D3 loc_65D3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:000065D3                 mov     ecx, [ebp+var_8]
.text$mn:000065D6                 cmp     dword ptr [ecx+18h], 10h
.text$mn:000065DA                 jb      short loc_6646
.text$mn:000065DC                 mov     edx, [ebp+var_8]
.text$mn:000065DF                 mov     eax, [edx+4]
.text$mn:000065E2                 mov     [ebp+var_C], eax
.text$mn:000065E5                 mov     ecx, [ebp+var_8]
.text$mn:000065E8                 add     ecx, 4
.text$mn:000065EB                 push    ecx
.text$mn:000065EC                 lea     edx, [ebp+var_1]
.text$mn:000065EF                 push    edx
.text$mn:000065F0                 mov     ecx, [ebp+var_8]
.text$mn:000065F3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000065F8                 mov     ecx, eax
.text$mn:000065FA                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000065FF                 cmp     [ebp+Size], 0
.text$mn:00006603                 jbe     short loc_6625
.text$mn:00006605                 mov     eax, [ebp+Size]
.text$mn:00006608                 push    eax             ; Size
.text$mn:00006609                 mov     ecx, [ebp+var_C]
.text$mn:0000660C                 push    ecx
.text$mn:0000660D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00006612                 add     esp, 4
.text$mn:00006615                 push    eax             ; Src
.text$mn:00006616                 mov     edx, [ebp+var_8]
.text$mn:00006619                 add     edx, 4
.text$mn:0000661C                 push    edx             ; Dst
.text$mn:0000661D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00006622                 add     esp, 0Ch
.text$mn:00006625
.text$mn:00006625 loc_6625:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00006625                 mov     eax, [ebp+var_8]
.text$mn:00006628                 mov     ecx, [eax+18h]
.text$mn:0000662B                 add     ecx, 1
.text$mn:0000662E                 push    ecx             ; int
.text$mn:0000662F                 mov     edx, [ebp+var_C]
.text$mn:00006632                 push    edx             ; void *
.text$mn:00006633                 lea     eax, [ebp+var_2]
.text$mn:00006636                 push    eax
.text$mn:00006637                 mov     ecx, [ebp+var_8]
.text$mn:0000663A                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000663F                 mov     ecx, eax
.text$mn:00006641                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00006646
.text$mn:00006646 loc_6646:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00006646                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00006646                 mov     ecx, [ebp+var_8]
.text$mn:00006649                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00006650                 mov     edx, [ebp+Size]
.text$mn:00006653                 push    edx
.text$mn:00006654                 mov     ecx, [ebp+var_8]
.text$mn:00006657                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000665C                 mov     esp, ebp
.text$mn:0000665E                 pop     ebp
.text$mn:0000665F                 retn    8
.text$mn:0000665F ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000665F
.text$mn:0000665F ; ---------------------------------------------------------------------------
.text$mn:00006662                 align 4
.text$mn:00006662 _text$mn        ends
.text$mn:00006662
.text$mn:00006664 ; ===========================================================================
.text$mn:00006664
.text$mn:00006664 ; Segment type: Pure code
.text$mn:00006664 ; Segment permissions: Read/Execute
.text$mn:00006664 _text$mn        segment para public 'CODE' use32
.text$mn:00006664                 assume cs:_text$mn
.text$mn:00006664                 ;org 6664h
.text$mn:00006664 ; COMDAT (pick any)
.text$mn:00006664                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006664
.text$mn:00006664 ; =============== S U B R O U T I N E =======================================
.text$mn:00006664
.text$mn:00006664 ; Attributes: bp-based frame
.text$mn:00006664
.text$mn:00006664 ; protected: void __thiscall std::ctype<char>::_Tidy(void)
.text$mn:00006664                 public ?_Tidy@?$ctype@D@std@@IAEXXZ
.text$mn:00006664 ?_Tidy@?$ctype@D@std@@IAEXXZ proc near  ; CODE XREF: std::ctype<char>::~ctype<char>(void)+39p
.text$mn:00006664
.text$mn:00006664 var_8           = dword ptr -8
.text$mn:00006664 var_4           = dword ptr -4
.text$mn:00006664
.text$mn:00006664                 push    ebp
.text$mn:00006665                 mov     ebp, esp
.text$mn:00006667                 sub     esp, 8
.text$mn:0000666A                 mov     [ebp+var_4], ecx
.text$mn:0000666D                 mov     eax, [ebp+var_4]
.text$mn:00006670                 cmp     dword ptr [eax+10h], 0
.text$mn:00006674                 jle     short loc_6687
.text$mn:00006676                 mov     ecx, [ebp+var_4]
.text$mn:00006679                 mov     edx, [ecx+0Ch]
.text$mn:0000667C                 push    edx             ; Memory
.text$mn:0000667D                 call    _free
.text$mn:00006682                 add     esp, 4
.text$mn:00006685                 jmp     short loc_66A5
.text$mn:00006687 ; ---------------------------------------------------------------------------
.text$mn:00006687
.text$mn:00006687 loc_6687:                               ; CODE XREF: std::ctype<char>::_Tidy(void)+10j
.text$mn:00006687                 mov     eax, [ebp+var_4]
.text$mn:0000668A                 cmp     dword ptr [eax+10h], 0
.text$mn:0000668E                 jge     short loc_66A5
.text$mn:00006690                 mov     ecx, [ebp+var_4]
.text$mn:00006693                 mov     edx, [ecx+0Ch]
.text$mn:00006696                 mov     [ebp+var_8], edx
.text$mn:00006699                 mov     eax, [ebp+var_8]
.text$mn:0000669C                 push    eax             ; void *
.text$mn:0000669D                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:000066A2                 add     esp, 4
.text$mn:000066A5
.text$mn:000066A5 loc_66A5:                               ; CODE XREF: std::ctype<char>::_Tidy(void)+21j
.text$mn:000066A5                                         ; std::ctype<char>::_Tidy(void)+2Aj
.text$mn:000066A5                 mov     ecx, [ebp+var_4]
.text$mn:000066A8                 mov     edx, [ecx+14h]
.text$mn:000066AB                 push    edx             ; Memory
.text$mn:000066AC                 call    _free
.text$mn:000066B1                 add     esp, 4
.text$mn:000066B4                 mov     esp, ebp
.text$mn:000066B6                 pop     ebp
.text$mn:000066B7                 retn
.text$mn:000066B7 ?_Tidy@?$ctype@D@std@@IAEXXZ endp
.text$mn:000066B7
.text$mn:000066B7 _text$mn        ends
.text$mn:000066B7
.text$mn:000066B8 ; ===========================================================================
.text$mn:000066B8
.text$mn:000066B8 ; Segment type: Pure code
.text$mn:000066B8 ; Segment permissions: Read/Execute
.text$mn:000066B8 _text$mn        segment para public 'CODE' use32
.text$mn:000066B8                 assume cs:_text$mn
.text$mn:000066B8                 ;org 66B8h
.text$mn:000066B8 ; COMDAT (pick any)
.text$mn:000066B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066B8
.text$mn:000066B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000066B8
.text$mn:000066B8 ; Attributes: bp-based frame
.text$mn:000066B8
.text$mn:000066B8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000066B8                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000066B8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000066B8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000066B8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Dp ...
.text$mn:000066B8
.text$mn:000066B8 var_4           = dword ptr -4
.text$mn:000066B8
.text$mn:000066B8                 push    ebp
.text$mn:000066B9                 mov     ebp, esp
.text$mn:000066BB                 push    ecx
.text$mn:000066BC                 mov     [ebp+var_4], ecx
.text$mn:000066BF                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000066C4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000066C9                 mov     esp, ebp
.text$mn:000066CB                 pop     ebp
.text$mn:000066CC                 retn
.text$mn:000066CC ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000066CC
.text$mn:000066CC ; ---------------------------------------------------------------------------
.text$mn:000066CD                 align 10h
.text$mn:000066CD _text$mn        ends
.text$mn:000066CD
.text$mn:000066D0 ; ===========================================================================
.text$mn:000066D0
.text$mn:000066D0 ; Segment type: Pure code
.text$mn:000066D0 ; Segment permissions: Read/Execute
.text$mn:000066D0 _text$mn        segment para public 'CODE' use32
.text$mn:000066D0                 assume cs:_text$mn
.text$mn:000066D0                 ;org 66D0h
.text$mn:000066D0 ; COMDAT (pick any)
.text$mn:000066D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066D0
.text$mn:000066D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000066D0
.text$mn:000066D0 ; Attributes: bp-based frame
.text$mn:000066D0
.text$mn:000066D0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000066D0                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000066D0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000066D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000066D0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p ...
.text$mn:000066D0
.text$mn:000066D0 var_4           = dword ptr -4
.text$mn:000066D0
.text$mn:000066D0                 push    ebp
.text$mn:000066D1                 mov     ebp, esp
.text$mn:000066D3                 push    ecx
.text$mn:000066D4                 mov     [ebp+var_4], ecx
.text$mn:000066D7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000066DC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000066E1                 mov     esp, ebp
.text$mn:000066E3                 pop     ebp
.text$mn:000066E4                 retn
.text$mn:000066E4 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000066E4
.text$mn:000066E4 ; ---------------------------------------------------------------------------
.text$mn:000066E5                 align 4
.text$mn:000066E5 _text$mn        ends
.text$mn:000066E5
.text$mn:000066E8 ; ===========================================================================
.text$mn:000066E8
.text$mn:000066E8 ; Segment type: Pure code
.text$mn:000066E8 ; Segment permissions: Read/Execute
.text$mn:000066E8 _text$mn        segment para public 'CODE' use32
.text$mn:000066E8                 assume cs:_text$mn
.text$mn:000066E8                 ;org 66E8h
.text$mn:000066E8 ; COMDAT (pick any)
.text$mn:000066E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066E8
.text$mn:000066E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000066E8
.text$mn:000066E8 ; Attributes: bp-based frame
.text$mn:000066E8
.text$mn:000066E8 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000066E8                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000066E8 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000066E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000066E8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000066E8
.text$mn:000066E8 var_4           = dword ptr -4
.text$mn:000066E8 arg_0           = dword ptr  8
.text$mn:000066E8
.text$mn:000066E8                 push    ebp
.text$mn:000066E9                 mov     ebp, esp
.text$mn:000066EB                 push    ecx
.text$mn:000066EC                 mov     [ebp+var_4], ecx
.text$mn:000066EF                 mov     eax, [ebp+arg_0]
.text$mn:000066F2                 push    eax
.text$mn:000066F3                 mov     ecx, [ebp+var_4]
.text$mn:000066F6                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000066FB                 mov     esp, ebp
.text$mn:000066FD                 pop     ebp
.text$mn:000066FE                 retn    4
.text$mn:000066FE ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000066FE
.text$mn:000066FE ; ---------------------------------------------------------------------------
.text$mn:00006701                 align 4
.text$mn:00006701 _text$mn        ends
.text$mn:00006701
.text$mn:00006704 ; ===========================================================================
.text$mn:00006704
.text$mn:00006704 ; Segment type: Pure code
.text$mn:00006704 ; Segment permissions: Read/Execute
.text$mn:00006704 _text$mn        segment para public 'CODE' use32
.text$mn:00006704                 assume cs:_text$mn
.text$mn:00006704                 ;org 6704h
.text$mn:00006704 ; COMDAT (pick any)
.text$mn:00006704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006704
.text$mn:00006704 ; =============== S U B R O U T I N E =======================================
.text$mn:00006704
.text$mn:00006704 ; Attributes: bp-based frame
.text$mn:00006704
.text$mn:00006704 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00006704                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00006704 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00006704                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00006704
.text$mn:00006704 var_4           = dword ptr -4
.text$mn:00006704 arg_0           = dword ptr  8
.text$mn:00006704
.text$mn:00006704                 push    ebp
.text$mn:00006705                 mov     ebp, esp
.text$mn:00006707                 push    ecx
.text$mn:00006708                 mov     [ebp+var_4], ecx
.text$mn:0000670B                 push    0
.text$mn:0000670D                 mov     eax, [ebp+arg_0]
.text$mn:00006710                 push    eax
.text$mn:00006711                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00006716                 add     esp, 8
.text$mn:00006719                 mov     esp, ebp
.text$mn:0000671B                 pop     ebp
.text$mn:0000671C                 retn    4
.text$mn:0000671C ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000671C
.text$mn:0000671C ; ---------------------------------------------------------------------------
.text$mn:0000671F                 align 10h
.text$mn:0000671F _text$mn        ends
.text$mn:0000671F
.text$mn:00006720 ; ===========================================================================
.text$mn:00006720
.text$mn:00006720 ; Segment type: Pure code
.text$mn:00006720 ; Segment permissions: Read/Execute
.text$mn:00006720 _text$mn        segment para public 'CODE' use32
.text$mn:00006720                 assume cs:_text$mn
.text$mn:00006720                 ;org 6720h
.text$mn:00006720 ; COMDAT (pick any)
.text$mn:00006720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006720
.text$mn:00006720 ; =============== S U B R O U T I N E =======================================
.text$mn:00006720
.text$mn:00006720 ; Attributes: bp-based frame
.text$mn:00006720
.text$mn:00006720 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00006720                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00006720 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00006720                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00006720
.text$mn:00006720 var_4           = dword ptr -4
.text$mn:00006720 arg_0           = dword ptr  8
.text$mn:00006720
.text$mn:00006720                 push    ebp
.text$mn:00006721                 mov     ebp, esp
.text$mn:00006723                 push    ecx
.text$mn:00006724                 mov     [ebp+var_4], ecx
.text$mn:00006727                 push    0
.text$mn:00006729                 mov     eax, [ebp+arg_0]
.text$mn:0000672C                 push    eax
.text$mn:0000672D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00006732                 add     esp, 8
.text$mn:00006735                 mov     esp, ebp
.text$mn:00006737                 pop     ebp
.text$mn:00006738                 retn    4
.text$mn:00006738 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00006738
.text$mn:00006738 ; ---------------------------------------------------------------------------
.text$mn:0000673B                 align 4
.text$mn:0000673B _text$mn        ends
.text$mn:0000673B
.text$mn:0000673C ; ===========================================================================
.text$mn:0000673C
.text$mn:0000673C ; Segment type: Pure code
.text$mn:0000673C ; Segment permissions: Read/Execute
.text$mn:0000673C _text$mn        segment para public 'CODE' use32
.text$mn:0000673C                 assume cs:_text$mn
.text$mn:0000673C                 ;org 673Ch
.text$mn:0000673C ; COMDAT (pick any)
.text$mn:0000673C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000673C
.text$mn:0000673C ; =============== S U B R O U T I N E =======================================
.text$mn:0000673C
.text$mn:0000673C ; Attributes: bp-based frame
.text$mn:0000673C
.text$mn:0000673C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::append(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
.text$mn:0000673C                 public ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:0000673C ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:0000673C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+Ep
.text$mn:0000673C                                         ; std::_System_error::_Makestr(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>>)+72p
.text$mn:0000673C
.text$mn:0000673C var_4           = dword ptr -4
.text$mn:0000673C arg_0           = dword ptr  8
.text$mn:0000673C
.text$mn:0000673C                 push    ebp
.text$mn:0000673D                 mov     ebp, esp
.text$mn:0000673F                 push    ecx
.text$mn:00006740                 mov     [ebp+var_4], ecx
.text$mn:00006743                 mov     eax, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:00006748                 push    eax             ; Size
.text$mn:00006749                 push    0               ; int
.text$mn:0000674B                 mov     ecx, [ebp+arg_0]
.text$mn:0000674E                 push    ecx             ; int
.text$mn:0000674F                 mov     ecx, [ebp+var_4]
.text$mn:00006752                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00006757                 mov     esp, ebp
.text$mn:00006759                 pop     ebp
.text$mn:0000675A                 retn    4
.text$mn:0000675A ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:0000675A
.text$mn:0000675A ; ---------------------------------------------------------------------------
.text$mn:0000675D                 align 10h
.text$mn:0000675D _text$mn        ends
.text$mn:0000675D
.text$mn:00006760 ; ===========================================================================
.text$mn:00006760
.text$mn:00006760 ; Segment type: Pure code
.text$mn:00006760 ; Segment permissions: Read/Execute
.text$mn:00006760 _text$mn        segment para public 'CODE' use32
.text$mn:00006760                 assume cs:_text$mn
.text$mn:00006760                 ;org 6760h
.text$mn:00006760 ; COMDAT (pick any)
.text$mn:00006760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006760
.text$mn:00006760 ; =============== S U B R O U T I N E =======================================
.text$mn:00006760
.text$mn:00006760 ; Attributes: bp-based frame
.text$mn:00006760
.text$mn:00006760 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(int, int, size_t Size)
.text$mn:00006760                 public ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00006760 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00006760                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+16p
.text$mn:00006760                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+51p
.text$mn:00006760
.text$mn:00006760 var_8           = dword ptr -8
.text$mn:00006760 var_4           = dword ptr -4
.text$mn:00006760 arg_0           = dword ptr  8
.text$mn:00006760 arg_4           = dword ptr  0Ch
.text$mn:00006760 Size            = dword ptr  10h
.text$mn:00006760
.text$mn:00006760                 push    ebp
.text$mn:00006761                 mov     ebp, esp
.text$mn:00006763                 sub     esp, 8
.text$mn:00006766                 mov     [ebp+var_4], ecx
.text$mn:00006769                 mov     ecx, [ebp+arg_0]
.text$mn:0000676C                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00006771                 cmp     eax, [ebp+arg_4]
.text$mn:00006774                 jnb     short loc_677E
.text$mn:00006776                 mov     ecx, [ebp+var_4]
.text$mn:00006779                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000677E
.text$mn:0000677E loc_677E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000677E                 mov     ecx, [ebp+arg_0]
.text$mn:00006781                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00006786                 sub     eax, [ebp+arg_4]
.text$mn:00006789                 mov     [ebp+var_8], eax
.text$mn:0000678C                 mov     eax, [ebp+var_8]
.text$mn:0000678F                 cmp     eax, [ebp+Size]
.text$mn:00006792                 jnb     short loc_679A
.text$mn:00006794                 mov     ecx, [ebp+var_8]
.text$mn:00006797                 mov     [ebp+Size], ecx
.text$mn:0000679A
.text$mn:0000679A loc_679A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000679A                 mov     edx, [ebp+var_4]
.text$mn:0000679D                 mov     eax, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:000067A2                 sub     eax, [edx+14h]
.text$mn:000067A5                 cmp     eax, [ebp+Size]
.text$mn:000067A8                 ja      short loc_67B2
.text$mn:000067AA                 mov     ecx, [ebp+var_4]
.text$mn:000067AD                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000067B2
.text$mn:000067B2 loc_67B2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+48j
.text$mn:000067B2                 cmp     [ebp+Size], 0
.text$mn:000067B6                 jbe     short loc_680C
.text$mn:000067B8                 mov     ecx, [ebp+var_4]
.text$mn:000067BB                 mov     edx, [ecx+14h]
.text$mn:000067BE                 add     edx, [ebp+Size]
.text$mn:000067C1                 mov     [ebp+var_8], edx
.text$mn:000067C4                 push    0
.text$mn:000067C6                 mov     eax, [ebp+var_8]
.text$mn:000067C9                 push    eax
.text$mn:000067CA                 mov     ecx, [ebp+var_4]
.text$mn:000067CD                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000067D2                 movzx   ecx, al
.text$mn:000067D5                 test    ecx, ecx
.text$mn:000067D7                 jz      short loc_680C
.text$mn:000067D9                 mov     edx, [ebp+Size]
.text$mn:000067DC                 push    edx             ; Size
.text$mn:000067DD                 mov     ecx, [ebp+arg_0]
.text$mn:000067E0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000067E5                 add     eax, [ebp+arg_4]
.text$mn:000067E8                 push    eax             ; Src
.text$mn:000067E9                 mov     ecx, [ebp+var_4]
.text$mn:000067EC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000067F1                 mov     ecx, [ebp+var_4]
.text$mn:000067F4                 add     eax, [ecx+14h]
.text$mn:000067F7                 push    eax             ; Dst
.text$mn:000067F8                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000067FD                 add     esp, 0Ch
.text$mn:00006800                 mov     edx, [ebp+var_8]
.text$mn:00006803                 push    edx
.text$mn:00006804                 mov     ecx, [ebp+var_4]
.text$mn:00006807                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000680C
.text$mn:0000680C loc_680C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+56j
.text$mn:0000680C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+77j
.text$mn:0000680C                 mov     eax, [ebp+var_4]
.text$mn:0000680F                 mov     esp, ebp
.text$mn:00006811                 pop     ebp
.text$mn:00006812                 retn    0Ch
.text$mn:00006812 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00006812
.text$mn:00006812 ; ---------------------------------------------------------------------------
.text$mn:00006815                 align 4
.text$mn:00006815 _text$mn        ends
.text$mn:00006815
.text$mn:00006818 ; ===========================================================================
.text$mn:00006818
.text$mn:00006818 ; Segment type: Pure code
.text$mn:00006818 ; Segment permissions: Read/Execute
.text$mn:00006818 _text$mn        segment para public 'CODE' use32
.text$mn:00006818                 assume cs:_text$mn
.text$mn:00006818                 ;org 6818h
.text$mn:00006818 ; COMDAT (pick any)
.text$mn:00006818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006818
.text$mn:00006818 ; =============== S U B R O U T I N E =======================================
.text$mn:00006818
.text$mn:00006818 ; Attributes: bp-based frame
.text$mn:00006818
.text$mn:00006818 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(size_t Size, char)
.text$mn:00006818                 public ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
.text$mn:00006818 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z proc near
.text$mn:00006818                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char)+11p
.text$mn:00006818
.text$mn:00006818 var_8           = dword ptr -8
.text$mn:00006818 var_4           = dword ptr -4
.text$mn:00006818 Size            = dword ptr  8
.text$mn:00006818 arg_4           = byte ptr  0Ch
.text$mn:00006818
.text$mn:00006818                 push    ebp
.text$mn:00006819                 mov     ebp, esp
.text$mn:0000681B                 sub     esp, 8
.text$mn:0000681E                 mov     [ebp+var_4], ecx
.text$mn:00006821                 mov     eax, [ebp+var_4]
.text$mn:00006824                 mov     ecx, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:0000682A                 sub     ecx, [eax+14h]
.text$mn:0000682D                 cmp     ecx, [ebp+Size]
.text$mn:00006830                 ja      short loc_683A
.text$mn:00006832                 mov     ecx, [ebp+var_4]
.text$mn:00006835                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000683A
.text$mn:0000683A loc_683A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(uint,char)+18j
.text$mn:0000683A                 cmp     [ebp+Size], 0
.text$mn:0000683E                 jbe     short loc_6885
.text$mn:00006840                 mov     edx, [ebp+var_4]
.text$mn:00006843                 mov     eax, [edx+14h]
.text$mn:00006846                 add     eax, [ebp+Size]
.text$mn:00006849                 mov     [ebp+var_8], eax
.text$mn:0000684C                 push    0
.text$mn:0000684E                 mov     ecx, [ebp+var_8]
.text$mn:00006851                 push    ecx
.text$mn:00006852                 mov     ecx, [ebp+var_4]
.text$mn:00006855                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000685A                 movzx   edx, al
.text$mn:0000685D                 test    edx, edx
.text$mn:0000685F                 jz      short loc_6885
.text$mn:00006861                 movzx   eax, [ebp+arg_4]
.text$mn:00006865                 push    eax             ; char
.text$mn:00006866                 mov     ecx, [ebp+Size]
.text$mn:00006869                 push    ecx             ; Size
.text$mn:0000686A                 mov     edx, [ebp+var_4]
.text$mn:0000686D                 mov     eax, [edx+14h]
.text$mn:00006870                 push    eax             ; int
.text$mn:00006871                 mov     ecx, [ebp+var_4]
.text$mn:00006874                 call    ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)
.text$mn:00006879                 mov     ecx, [ebp+var_8]
.text$mn:0000687C                 push    ecx
.text$mn:0000687D                 mov     ecx, [ebp+var_4]
.text$mn:00006880                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006885
.text$mn:00006885 loc_6885:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(uint,char)+26j
.text$mn:00006885                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(uint,char)+47j
.text$mn:00006885                 mov     eax, [ebp+var_4]
.text$mn:00006888                 mov     esp, ebp
.text$mn:0000688A                 pop     ebp
.text$mn:0000688B                 retn    8
.text$mn:0000688B ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z endp
.text$mn:0000688B
.text$mn:0000688B ; ---------------------------------------------------------------------------
.text$mn:0000688E                 align 10h
.text$mn:0000688E _text$mn        ends
.text$mn:0000688E
.text$mn:00006890 ; ===========================================================================
.text$mn:00006890
.text$mn:00006890 ; Segment type: Pure code
.text$mn:00006890 ; Segment permissions: Read/Execute
.text$mn:00006890 _text$mn        segment para public 'CODE' use32
.text$mn:00006890                 assume cs:_text$mn
.text$mn:00006890                 ;org 6890h
.text$mn:00006890 ; COMDAT (pick any)
.text$mn:00006890                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006890
.text$mn:00006890 ; =============== S U B R O U T I N E =======================================
.text$mn:00006890
.text$mn:00006890 ; Attributes: bp-based frame
.text$mn:00006890
.text$mn:00006890 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char *Str)
.text$mn:00006890                 public ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00006890 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00006890                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator+=(char const *)+Ep
.text$mn:00006890                                         ; std::_System_error::_Makestr(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>>)+4Dp
.text$mn:00006890
.text$mn:00006890 var_4           = dword ptr -4
.text$mn:00006890 Str             = dword ptr  8
.text$mn:00006890
.text$mn:00006890                 push    ebp
.text$mn:00006891                 mov     ebp, esp
.text$mn:00006893                 push    ecx
.text$mn:00006894                 mov     [ebp+var_4], ecx
.text$mn:00006897                 push    43Eh            ; unsigned int
.text$mn:0000689C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000068A1                 mov     eax, [ebp+Str]
.text$mn:000068A4                 push    eax             ; int
.text$mn:000068A5                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000068AA                 add     esp, 0Ch
.text$mn:000068AD                 mov     ecx, [ebp+Str]
.text$mn:000068B0                 push    ecx             ; Str
.text$mn:000068B1                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000068B6                 add     esp, 4
.text$mn:000068B9                 push    eax             ; Size
.text$mn:000068BA                 mov     edx, [ebp+Str]
.text$mn:000068BD                 push    edx             ; Src
.text$mn:000068BE                 mov     ecx, [ebp+var_4]
.text$mn:000068C1                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)
.text$mn:000068C6                 mov     esp, ebp
.text$mn:000068C8                 pop     ebp
.text$mn:000068C9                 retn    4
.text$mn:000068C9 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000068C9
.text$mn:000068C9 _text$mn        ends
.text$mn:000068C9
.text$mn:000068CC ; ===========================================================================
.text$mn:000068CC
.text$mn:000068CC ; Segment type: Pure code
.text$mn:000068CC ; Segment permissions: Read/Execute
.text$mn:000068CC _text$mn        segment para public 'CODE' use32
.text$mn:000068CC                 assume cs:_text$mn
.text$mn:000068CC                 ;org 68CCh
.text$mn:000068CC ; COMDAT (pick any)
.text$mn:000068CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000068CC
.text$mn:000068CC ; =============== S U B R O U T I N E =======================================
.text$mn:000068CC
.text$mn:000068CC ; Attributes: bp-based frame
.text$mn:000068CC
.text$mn:000068CC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(void *Src, size_t Size)
.text$mn:000068CC                 public ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:000068CC ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:000068CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *)+31p
.text$mn:000068CC
.text$mn:000068CC var_8           = dword ptr -8
.text$mn:000068CC var_4           = dword ptr -4
.text$mn:000068CC Src             = dword ptr  8
.text$mn:000068CC Size            = dword ptr  0Ch
.text$mn:000068CC
.text$mn:000068CC                 push    ebp
.text$mn:000068CD                 mov     ebp, esp
.text$mn:000068CF                 sub     esp, 8
.text$mn:000068D2                 mov     [ebp+var_4], ecx
.text$mn:000068D5                 cmp     [ebp+Size], 0
.text$mn:000068D9                 jz      short loc_68F1
.text$mn:000068DB                 push    42Ah            ; unsigned int
.text$mn:000068E0                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000068E5                 mov     eax, [ebp+Src]
.text$mn:000068E8                 push    eax             ; int
.text$mn:000068E9                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000068EE                 add     esp, 0Ch
.text$mn:000068F1
.text$mn:000068F1 loc_68F1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+Dj
.text$mn:000068F1                 mov     ecx, [ebp+Src]
.text$mn:000068F4                 push    ecx
.text$mn:000068F5                 mov     ecx, [ebp+var_4]
.text$mn:000068F8                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:000068FD                 movzx   edx, al
.text$mn:00006900                 test    edx, edx
.text$mn:00006902                 jz      short loc_6924
.text$mn:00006904                 mov     eax, [ebp+Size]
.text$mn:00006907                 push    eax             ; Size
.text$mn:00006908                 mov     ecx, [ebp+var_4]
.text$mn:0000690B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006910                 mov     ecx, [ebp+Src]
.text$mn:00006913                 sub     ecx, eax
.text$mn:00006915                 push    ecx             ; int
.text$mn:00006916                 mov     edx, [ebp+var_4]
.text$mn:00006919                 push    edx             ; int
.text$mn:0000691A                 mov     ecx, [ebp+var_4]
.text$mn:0000691D                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00006922                 jmp     short loc_6992
.text$mn:00006924 ; ---------------------------------------------------------------------------
.text$mn:00006924
.text$mn:00006924 loc_6924:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+36j
.text$mn:00006924                 mov     eax, [ebp+var_4]
.text$mn:00006927                 mov     ecx, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:0000692D                 sub     ecx, [eax+14h]
.text$mn:00006930                 cmp     ecx, [ebp+Size]
.text$mn:00006933                 ja      short loc_693D
.text$mn:00006935                 mov     ecx, [ebp+var_4]
.text$mn:00006938                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000693D
.text$mn:0000693D loc_693D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+67j
.text$mn:0000693D                 cmp     [ebp+Size], 0
.text$mn:00006941                 jbe     short loc_698F
.text$mn:00006943                 mov     edx, [ebp+var_4]
.text$mn:00006946                 mov     eax, [edx+14h]
.text$mn:00006949                 add     eax, [ebp+Size]
.text$mn:0000694C                 mov     [ebp+var_8], eax
.text$mn:0000694F                 push    0
.text$mn:00006951                 mov     ecx, [ebp+var_8]
.text$mn:00006954                 push    ecx
.text$mn:00006955                 mov     ecx, [ebp+var_4]
.text$mn:00006958                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000695D                 movzx   edx, al
.text$mn:00006960                 test    edx, edx
.text$mn:00006962                 jz      short loc_698F
.text$mn:00006964                 mov     eax, [ebp+Size]
.text$mn:00006967                 push    eax             ; Size
.text$mn:00006968                 mov     ecx, [ebp+Src]
.text$mn:0000696B                 push    ecx             ; Src
.text$mn:0000696C                 mov     ecx, [ebp+var_4]
.text$mn:0000696F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006974                 mov     edx, [ebp+var_4]
.text$mn:00006977                 add     eax, [edx+14h]
.text$mn:0000697A                 push    eax             ; Dst
.text$mn:0000697B                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00006980                 add     esp, 0Ch
.text$mn:00006983                 mov     eax, [ebp+var_8]
.text$mn:00006986                 push    eax
.text$mn:00006987                 mov     ecx, [ebp+var_4]
.text$mn:0000698A                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000698F
.text$mn:0000698F loc_698F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+75j
.text$mn:0000698F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+96j
.text$mn:0000698F                 mov     eax, [ebp+var_4]
.text$mn:00006992
.text$mn:00006992 loc_6992:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *,uint)+56j
.text$mn:00006992                 mov     esp, ebp
.text$mn:00006994                 pop     ebp
.text$mn:00006995                 retn    8
.text$mn:00006995 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00006995
.text$mn:00006995 _text$mn        ends
.text$mn:00006995
.text$mn:00006998 ; ===========================================================================
.text$mn:00006998
.text$mn:00006998 ; Segment type: Pure code
.text$mn:00006998 ; Segment permissions: Read/Execute
.text$mn:00006998 _text$mn        segment para public 'CODE' use32
.text$mn:00006998                 assume cs:_text$mn
.text$mn:00006998                 ;org 6998h
.text$mn:00006998 ; COMDAT (pick any)
.text$mn:00006998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006998
.text$mn:00006998 ; =============== S U B R O U T I N E =======================================
.text$mn:00006998
.text$mn:00006998 ; Attributes: bp-based frame
.text$mn:00006998
.text$mn:00006998 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00006998                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00006998 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00006998                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+6Bp
.text$mn:00006998                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00006998
.text$mn:00006998 Size            = dword ptr -8
.text$mn:00006998 var_4           = dword ptr -4
.text$mn:00006998 arg_0           = dword ptr  8
.text$mn:00006998 arg_4           = dword ptr  0Ch
.text$mn:00006998 arg_8           = dword ptr  10h
.text$mn:00006998
.text$mn:00006998                 push    ebp
.text$mn:00006999                 mov     ebp, esp
.text$mn:0000699B                 sub     esp, 8
.text$mn:0000699E                 mov     [ebp+var_4], ecx
.text$mn:000069A1                 mov     ecx, [ebp+arg_0]
.text$mn:000069A4                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000069A9                 cmp     eax, [ebp+arg_4]
.text$mn:000069AC                 jnb     short loc_69B6
.text$mn:000069AE                 mov     ecx, [ebp+var_4]
.text$mn:000069B1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000069B6
.text$mn:000069B6 loc_69B6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:000069B6                 mov     ecx, [ebp+arg_0]
.text$mn:000069B9                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000069BE                 sub     eax, [ebp+arg_4]
.text$mn:000069C1                 mov     [ebp+Size], eax
.text$mn:000069C4                 mov     eax, [ebp+arg_8]
.text$mn:000069C7                 cmp     eax, [ebp+Size]
.text$mn:000069CA                 jnb     short loc_69D2
.text$mn:000069CC                 mov     ecx, [ebp+arg_8]
.text$mn:000069CF                 mov     [ebp+Size], ecx
.text$mn:000069D2
.text$mn:000069D2 loc_69D2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000069D2                 mov     edx, [ebp+var_4]
.text$mn:000069D5                 cmp     edx, [ebp+arg_0]
.text$mn:000069D8                 jnz     short loc_69F9
.text$mn:000069DA                 mov     eax, [ebp+arg_4]
.text$mn:000069DD                 add     eax, [ebp+Size]
.text$mn:000069E0                 push    eax
.text$mn:000069E1                 mov     ecx, [ebp+var_4]
.text$mn:000069E4                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000069E9                 mov     ecx, [ebp+arg_4]
.text$mn:000069EC                 push    ecx
.text$mn:000069ED                 push    0
.text$mn:000069EF                 mov     ecx, [ebp+var_4]
.text$mn:000069F2                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000069F7                 jmp     short loc_6A3B
.text$mn:000069F9 ; ---------------------------------------------------------------------------
.text$mn:000069F9
.text$mn:000069F9 loc_69F9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000069F9                 push    0
.text$mn:000069FB                 mov     edx, [ebp+Size]
.text$mn:000069FE                 push    edx
.text$mn:000069FF                 mov     ecx, [ebp+var_4]
.text$mn:00006A02                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00006A07                 movzx   eax, al
.text$mn:00006A0A                 test    eax, eax
.text$mn:00006A0C                 jz      short loc_6A3B
.text$mn:00006A0E                 mov     ecx, [ebp+Size]
.text$mn:00006A11                 push    ecx             ; Size
.text$mn:00006A12                 mov     ecx, [ebp+arg_0]
.text$mn:00006A15                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006A1A                 add     eax, [ebp+arg_4]
.text$mn:00006A1D                 push    eax             ; Src
.text$mn:00006A1E                 mov     ecx, [ebp+var_4]
.text$mn:00006A21                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006A26                 push    eax             ; Dst
.text$mn:00006A27                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00006A2C                 add     esp, 0Ch
.text$mn:00006A2F                 mov     edx, [ebp+Size]
.text$mn:00006A32                 push    edx
.text$mn:00006A33                 mov     ecx, [ebp+var_4]
.text$mn:00006A36                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006A3B
.text$mn:00006A3B loc_6A3B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00006A3B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00006A3B                 mov     eax, [ebp+var_4]
.text$mn:00006A3E                 mov     esp, ebp
.text$mn:00006A40                 pop     ebp
.text$mn:00006A41                 retn    0Ch
.text$mn:00006A41 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00006A41
.text$mn:00006A41 _text$mn        ends
.text$mn:00006A41
.text$mn:00006A44 ; ===========================================================================
.text$mn:00006A44
.text$mn:00006A44 ; Segment type: Pure code
.text$mn:00006A44 ; Segment permissions: Read/Execute
.text$mn:00006A44 _text$mn        segment para public 'CODE' use32
.text$mn:00006A44                 assume cs:_text$mn
.text$mn:00006A44                 ;org 6A44h
.text$mn:00006A44 ; COMDAT (pick any)
.text$mn:00006A44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A44
.text$mn:00006A44 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A44
.text$mn:00006A44 ; Attributes: bp-based frame
.text$mn:00006A44
.text$mn:00006A44 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00006A44                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00006A44 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00006A44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00006A44                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)+Ep
.text$mn:00006A44
.text$mn:00006A44 var_4           = dword ptr -4
.text$mn:00006A44 Str             = dword ptr  8
.text$mn:00006A44
.text$mn:00006A44                 push    ebp
.text$mn:00006A45                 mov     ebp, esp
.text$mn:00006A47                 push    ecx
.text$mn:00006A48                 mov     [ebp+var_4], ecx
.text$mn:00006A4B                 push    490h            ; unsigned int
.text$mn:00006A50                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006A55                 mov     eax, [ebp+Str]
.text$mn:00006A58                 push    eax             ; int
.text$mn:00006A59                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00006A5E                 add     esp, 0Ch
.text$mn:00006A61                 mov     ecx, [ebp+Str]
.text$mn:00006A64                 push    ecx             ; Str
.text$mn:00006A65                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00006A6A                 add     esp, 4
.text$mn:00006A6D                 push    eax             ; Size
.text$mn:00006A6E                 mov     edx, [ebp+Str]
.text$mn:00006A71                 push    edx             ; Src
.text$mn:00006A72                 mov     ecx, [ebp+var_4]
.text$mn:00006A75                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00006A7A                 mov     esp, ebp
.text$mn:00006A7C                 pop     ebp
.text$mn:00006A7D                 retn    4
.text$mn:00006A7D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00006A7D
.text$mn:00006A7D _text$mn        ends
.text$mn:00006A7D
.text$mn:00006A80 ; ===========================================================================
.text$mn:00006A80
.text$mn:00006A80 ; Segment type: Pure code
.text$mn:00006A80 ; Segment permissions: Read/Execute
.text$mn:00006A80 _text$mn        segment para public 'CODE' use32
.text$mn:00006A80                 assume cs:_text$mn
.text$mn:00006A80                 ;org 6A80h
.text$mn:00006A80 ; COMDAT (pick any)
.text$mn:00006A80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A80
.text$mn:00006A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A80
.text$mn:00006A80 ; Attributes: bp-based frame
.text$mn:00006A80
.text$mn:00006A80 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00006A80                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00006A80 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00006A80                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00006A80
.text$mn:00006A80 var_4           = dword ptr -4
.text$mn:00006A80 Src             = dword ptr  8
.text$mn:00006A80 Size            = dword ptr  0Ch
.text$mn:00006A80
.text$mn:00006A80                 push    ebp
.text$mn:00006A81                 mov     ebp, esp
.text$mn:00006A83                 push    ecx
.text$mn:00006A84                 mov     [ebp+var_4], ecx
.text$mn:00006A87                 cmp     [ebp+Size], 0
.text$mn:00006A8B                 jz      short loc_6AA3
.text$mn:00006A8D                 push    47Fh            ; unsigned int
.text$mn:00006A92                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006A97                 mov     eax, [ebp+Src]
.text$mn:00006A9A                 push    eax             ; int
.text$mn:00006A9B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00006AA0                 add     esp, 0Ch
.text$mn:00006AA3
.text$mn:00006AA3 loc_6AA3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00006AA3                 mov     ecx, [ebp+Src]
.text$mn:00006AA6                 push    ecx
.text$mn:00006AA7                 mov     ecx, [ebp+var_4]
.text$mn:00006AAA                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00006AAF                 movzx   edx, al
.text$mn:00006AB2                 test    edx, edx
.text$mn:00006AB4                 jz      short loc_6AD6
.text$mn:00006AB6                 mov     eax, [ebp+Size]
.text$mn:00006AB9                 push    eax
.text$mn:00006ABA                 mov     ecx, [ebp+var_4]
.text$mn:00006ABD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006AC2                 mov     ecx, [ebp+Src]
.text$mn:00006AC5                 sub     ecx, eax
.text$mn:00006AC7                 push    ecx
.text$mn:00006AC8                 mov     edx, [ebp+var_4]
.text$mn:00006ACB                 push    edx
.text$mn:00006ACC                 mov     ecx, [ebp+var_4]
.text$mn:00006ACF                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00006AD4                 jmp     short loc_6B13
.text$mn:00006AD6 ; ---------------------------------------------------------------------------
.text$mn:00006AD6
.text$mn:00006AD6 loc_6AD6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00006AD6                 push    0
.text$mn:00006AD8                 mov     eax, [ebp+Size]
.text$mn:00006ADB                 push    eax
.text$mn:00006ADC                 mov     ecx, [ebp+var_4]
.text$mn:00006ADF                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00006AE4                 movzx   ecx, al
.text$mn:00006AE7                 test    ecx, ecx
.text$mn:00006AE9                 jz      short loc_6B10
.text$mn:00006AEB                 mov     edx, [ebp+Size]
.text$mn:00006AEE                 push    edx             ; Size
.text$mn:00006AEF                 mov     eax, [ebp+Src]
.text$mn:00006AF2                 push    eax             ; Src
.text$mn:00006AF3                 mov     ecx, [ebp+var_4]
.text$mn:00006AF6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006AFB                 push    eax             ; Dst
.text$mn:00006AFC                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00006B01                 add     esp, 0Ch
.text$mn:00006B04                 mov     ecx, [ebp+Size]
.text$mn:00006B07                 push    ecx
.text$mn:00006B08                 mov     ecx, [ebp+var_4]
.text$mn:00006B0B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006B10
.text$mn:00006B10 loc_6B10:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00006B10                 mov     eax, [ebp+var_4]
.text$mn:00006B13
.text$mn:00006B13 loc_6B13:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00006B13                 mov     esp, ebp
.text$mn:00006B15                 pop     ebp
.text$mn:00006B16                 retn    8
.text$mn:00006B16 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00006B16
.text$mn:00006B16 ; ---------------------------------------------------------------------------
.text$mn:00006B19                 align 4
.text$mn:00006B19 _text$mn        ends
.text$mn:00006B19
.text$mn:00006B1C ; ===========================================================================
.text$mn:00006B1C
.text$mn:00006B1C ; Segment type: Pure code
.text$mn:00006B1C ; Segment permissions: Read/Execute
.text$mn:00006B1C _text$mn        segment para public 'CODE' use32
.text$mn:00006B1C                 assume cs:_text$mn
.text$mn:00006B1C                 ;org 6B1Ch
.text$mn:00006B1C ; COMDAT (pick any)
.text$mn:00006B1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B1C
.text$mn:00006B1C ; =============== S U B R O U T I N E =======================================
.text$mn:00006B1C
.text$mn:00006B1C ; Attributes: bp-based frame
.text$mn:00006B1C
.text$mn:00006B1C ; int __cdecl std::char_traits<char>::assign(void *Dst, size_t Size, char)
.text$mn:00006B1C                 public ?assign@?$char_traits@D@std@@SAPADPADID@Z
.text$mn:00006B1C ?assign@?$char_traits@D@std@@SAPADPADID@Z proc near
.text$mn:00006B1C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)+3Cp
.text$mn:00006B1C
.text$mn:00006B1C Dst             = dword ptr  8
.text$mn:00006B1C Size            = dword ptr  0Ch
.text$mn:00006B1C arg_8           = byte ptr  10h
.text$mn:00006B1C
.text$mn:00006B1C                 push    ebp
.text$mn:00006B1D                 mov     ebp, esp
.text$mn:00006B1F                 mov     eax, [ebp+Size]
.text$mn:00006B22                 push    eax             ; Size
.text$mn:00006B23                 movsx   ecx, [ebp+arg_8]
.text$mn:00006B27                 push    ecx             ; Val
.text$mn:00006B28                 mov     edx, [ebp+Dst]
.text$mn:00006B2B                 push    edx             ; Dst
.text$mn:00006B2C                 call    _memset
.text$mn:00006B31                 add     esp, 0Ch
.text$mn:00006B34                 pop     ebp
.text$mn:00006B35                 retn
.text$mn:00006B35 ?assign@?$char_traits@D@std@@SAPADPADID@Z endp
.text$mn:00006B35
.text$mn:00006B35 ; ---------------------------------------------------------------------------
.text$mn:00006B36                 align 4
.text$mn:00006B36 _text$mn        ends
.text$mn:00006B36
.text$mn:00006B38 ; ===========================================================================
.text$mn:00006B38
.text$mn:00006B38 ; Segment type: Pure code
.text$mn:00006B38 ; Segment permissions: Read/Execute
.text$mn:00006B38 _text$mn        segment para public 'CODE' use32
.text$mn:00006B38                 assume cs:_text$mn
.text$mn:00006B38                 ;org 6B38h
.text$mn:00006B38 ; COMDAT (pick any)
.text$mn:00006B38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B38
.text$mn:00006B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B38
.text$mn:00006B38 ; Attributes: bp-based frame
.text$mn:00006B38
.text$mn:00006B38 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00006B38                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00006B38 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00006B38                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)+1Dp
.text$mn:00006B38                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00006B38
.text$mn:00006B38 arg_0           = dword ptr  8
.text$mn:00006B38 arg_4           = dword ptr  0Ch
.text$mn:00006B38
.text$mn:00006B38                 push    ebp
.text$mn:00006B39                 mov     ebp, esp
.text$mn:00006B3B                 mov     eax, [ebp+arg_0]
.text$mn:00006B3E                 mov     ecx, [ebp+arg_4]
.text$mn:00006B41                 mov     dl, [ecx]
.text$mn:00006B43                 mov     [eax], dl
.text$mn:00006B45                 pop     ebp
.text$mn:00006B46                 retn
.text$mn:00006B46 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00006B46
.text$mn:00006B46 ; ---------------------------------------------------------------------------
.text$mn:00006B47                 align 4
.text$mn:00006B47 _text$mn        ends
.text$mn:00006B47
.text$mn:00006B48 ; ===========================================================================
.text$mn:00006B48
.text$mn:00006B48 ; Segment type: Pure code
.text$mn:00006B48 ; Segment permissions: Read/Execute
.text$mn:00006B48 _text$mn        segment para public 'CODE' use32
.text$mn:00006B48                 assume cs:_text$mn
.text$mn:00006B48                 ;org 6B48h
.text$mn:00006B48 ; COMDAT (pick any)
.text$mn:00006B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B48
.text$mn:00006B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B48
.text$mn:00006B48 ; Attributes: bp-based frame
.text$mn:00006B48
.text$mn:00006B48 ; public: char & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::at(unsigned int)
.text$mn:00006B48                 public ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
.text$mn:00006B48 ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z proc near
.text$mn:00006B48                                         ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+87p
.text$mn:00006B48                                         ; TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+A3p ...
.text$mn:00006B48
.text$mn:00006B48 var_4           = dword ptr -4
.text$mn:00006B48 arg_0           = dword ptr  8
.text$mn:00006B48
.text$mn:00006B48                 push    ebp
.text$mn:00006B49                 mov     ebp, esp
.text$mn:00006B4B                 push    ecx
.text$mn:00006B4C                 mov     [ebp+var_4], ecx
.text$mn:00006B4F                 mov     eax, [ebp+var_4]
.text$mn:00006B52                 mov     ecx, [eax+14h]
.text$mn:00006B55                 cmp     ecx, [ebp+arg_0]
.text$mn:00006B58                 ja      short loc_6B62
.text$mn:00006B5A                 mov     ecx, [ebp+var_4]
.text$mn:00006B5D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00006B62
.text$mn:00006B62 loc_6B62:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)+10j
.text$mn:00006B62                 mov     ecx, [ebp+var_4]
.text$mn:00006B65                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006B6A                 add     eax, [ebp+arg_0]
.text$mn:00006B6D                 mov     esp, ebp
.text$mn:00006B6F                 pop     ebp
.text$mn:00006B70                 retn    4
.text$mn:00006B70 ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z endp
.text$mn:00006B70
.text$mn:00006B70 ; ---------------------------------------------------------------------------
.text$mn:00006B73                 align 4
.text$mn:00006B73 _text$mn        ends
.text$mn:00006B73
.text$mn:00006B74 ; ===========================================================================
.text$mn:00006B74
.text$mn:00006B74 ; Segment type: Pure code
.text$mn:00006B74 ; Segment permissions: Read/Execute
.text$mn:00006B74 _text$mn        segment para public 'CODE' use32
.text$mn:00006B74                 assume cs:_text$mn
.text$mn:00006B74                 ;org 6B74h
.text$mn:00006B74 ; COMDAT (pick any)
.text$mn:00006B74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B74
.text$mn:00006B74 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B74
.text$mn:00006B74 ; Attributes: bp-based frame
.text$mn:00006B74
.text$mn:00006B74 ; public: char const * __thiscall std::_Yarn<char>::c_str(void)const
.text$mn:00006B74                 public ?c_str@?$_Yarn@D@std@@QBEPBDXZ
.text$mn:00006B74 ?c_str@?$_Yarn@D@std@@QBEPBDXZ proc near
.text$mn:00006B74                                         ; CODE XREF: std::locale::c_str(void)+22p
.text$mn:00006B74
.text$mn:00006B74 var_8           = dword ptr -8
.text$mn:00006B74 var_4           = dword ptr -4
.text$mn:00006B74
.text$mn:00006B74                 push    ebp
.text$mn:00006B75                 mov     ebp, esp
.text$mn:00006B77                 sub     esp, 8
.text$mn:00006B7A                 mov     [ebp+var_4], ecx
.text$mn:00006B7D                 mov     eax, [ebp+var_4]
.text$mn:00006B80                 cmp     dword ptr [eax], 0
.text$mn:00006B83                 jz      short loc_6B8F
.text$mn:00006B85                 mov     ecx, [ebp+var_4]
.text$mn:00006B88                 mov     edx, [ecx]
.text$mn:00006B8A                 mov     [ebp+var_8], edx
.text$mn:00006B8D                 jmp     short loc_6B98
.text$mn:00006B8F ; ---------------------------------------------------------------------------
.text$mn:00006B8F
.text$mn:00006B8F loc_6B8F:                               ; CODE XREF: std::_Yarn<char>::c_str(void)+Fj
.text$mn:00006B8F                 mov     eax, [ebp+var_4]
.text$mn:00006B92                 add     eax, 4
.text$mn:00006B95                 mov     [ebp+var_8], eax
.text$mn:00006B98
.text$mn:00006B98 loc_6B98:                               ; CODE XREF: std::_Yarn<char>::c_str(void)+19j
.text$mn:00006B98                 mov     eax, [ebp+var_8]
.text$mn:00006B9B                 mov     esp, ebp
.text$mn:00006B9D                 pop     ebp
.text$mn:00006B9E                 retn
.text$mn:00006B9E ?c_str@?$_Yarn@D@std@@QBEPBDXZ endp
.text$mn:00006B9E
.text$mn:00006B9E ; ---------------------------------------------------------------------------
.text$mn:00006B9F                 align 10h
.text$mn:00006B9F _text$mn        ends
.text$mn:00006B9F
.text$mn:00006BA0 ; ===========================================================================
.text$mn:00006BA0
.text$mn:00006BA0 ; Segment type: Pure code
.text$mn:00006BA0 ; Segment permissions: Read/Execute
.text$mn:00006BA0 _text$mn        segment para public 'CODE' use32
.text$mn:00006BA0                 assume cs:_text$mn
.text$mn:00006BA0                 ;org 6BA0h
.text$mn:00006BA0 ; COMDAT (pick any)
.text$mn:00006BA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BA0
.text$mn:00006BA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BA0
.text$mn:00006BA0 ; Attributes: bp-based frame
.text$mn:00006BA0
.text$mn:00006BA0 ; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
.text$mn:00006BA0                 public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
.text$mn:00006BA0 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
.text$mn:00006BA0                                         ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+251p
.text$mn:00006BA0                                         ; TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+2A9p ...
.text$mn:00006BA0
.text$mn:00006BA0 var_4           = dword ptr -4
.text$mn:00006BA0
.text$mn:00006BA0                 push    ebp
.text$mn:00006BA1                 mov     ebp, esp
.text$mn:00006BA3                 push    ecx
.text$mn:00006BA4                 mov     [ebp+var_4], ecx
.text$mn:00006BA7                 mov     ecx, [ebp+var_4]
.text$mn:00006BAA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006BAF                 mov     esp, ebp
.text$mn:00006BB1                 pop     ebp
.text$mn:00006BB2                 retn
.text$mn:00006BB2 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp
.text$mn:00006BB2
.text$mn:00006BB2 ; ---------------------------------------------------------------------------
.text$mn:00006BB3                 align 4
.text$mn:00006BB3 _text$mn        ends
.text$mn:00006BB3
.text$mn:00006BB4 ; ===========================================================================
.text$mn:00006BB4
.text$mn:00006BB4 ; Segment type: Pure code
.text$mn:00006BB4 ; Segment permissions: Read/Execute
.text$mn:00006BB4 _text$mn        segment para public 'CODE' use32
.text$mn:00006BB4                 assume cs:_text$mn
.text$mn:00006BB4                 ;org 6BB4h
.text$mn:00006BB4 ; COMDAT (pick any)
.text$mn:00006BB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BB4
.text$mn:00006BB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BB4
.text$mn:00006BB4 ; Attributes: bp-based frame
.text$mn:00006BB4
.text$mn:00006BB4 ; const char *__thiscall std::locale::c_str(std::locale *__hidden this)
.text$mn:00006BB4                 public ?c_str@locale@std@@QBEPBDXZ
.text$mn:00006BB4 ?c_str@locale@std@@QBEPBDXZ proc near   ; CODE XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+77p
.text$mn:00006BB4
.text$mn:00006BB4 var_8           = dword ptr -8
.text$mn:00006BB4 var_4           = dword ptr -4
.text$mn:00006BB4
.text$mn:00006BB4                 push    ebp
.text$mn:00006BB5                 mov     ebp, esp
.text$mn:00006BB7                 sub     esp, 8
.text$mn:00006BBA                 mov     [ebp+var_4], ecx
.text$mn:00006BBD                 mov     eax, [ebp+var_4]
.text$mn:00006BC0                 cmp     dword ptr [eax], 0
.text$mn:00006BC3                 jnz     short loc_6BCE
.text$mn:00006BC5                 mov     [ebp+var_8], offset ??_C@_00CNPNBAHC@?$AA@ ; `string'
.text$mn:00006BCC                 jmp     short loc_6BDE
.text$mn:00006BCE ; ---------------------------------------------------------------------------
.text$mn:00006BCE
.text$mn:00006BCE loc_6BCE:                               ; CODE XREF: std::locale::c_str(void)+Fj
.text$mn:00006BCE                 mov     ecx, [ebp+var_4]
.text$mn:00006BD1                 mov     ecx, [ecx]
.text$mn:00006BD3                 add     ecx, 18h
.text$mn:00006BD6                 call    ?c_str@?$_Yarn@D@std@@QBEPBDXZ ; std::_Yarn<char>::c_str(void)
.text$mn:00006BDB                 mov     [ebp+var_8], eax
.text$mn:00006BDE
.text$mn:00006BDE loc_6BDE:                               ; CODE XREF: std::locale::c_str(void)+18j
.text$mn:00006BDE                 mov     eax, [ebp+var_8]
.text$mn:00006BE1                 mov     esp, ebp
.text$mn:00006BE3                 pop     ebp
.text$mn:00006BE4                 retn
.text$mn:00006BE4 ?c_str@locale@std@@QBEPBDXZ endp
.text$mn:00006BE4
.text$mn:00006BE4 ; ---------------------------------------------------------------------------
.text$mn:00006BE5                 align 4
.text$mn:00006BE5 _text$mn        ends
.text$mn:00006BE5
.text$mn:00006BE8 ; ===========================================================================
.text$mn:00006BE8
.text$mn:00006BE8 ; Segment type: Pure code
.text$mn:00006BE8 ; Segment permissions: Read/Execute
.text$mn:00006BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00006BE8                 assume cs:_text$mn
.text$mn:00006BE8                 ;org 6BE8h
.text$mn:00006BE8 ; COMDAT (pick any)
.text$mn:00006BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BE8
.text$mn:00006BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BE8
.text$mn:00006BE8 ; Attributes: bp-based frame
.text$mn:00006BE8
.text$mn:00006BE8 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00006BE8                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00006BE8 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00006BE8                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00006BE8                                         ; std::error_code::message(void)+32p
.text$mn:00006BE8
.text$mn:00006BE8 var_4           = dword ptr -4
.text$mn:00006BE8
.text$mn:00006BE8                 push    ebp
.text$mn:00006BE9                 mov     ebp, esp
.text$mn:00006BEB                 push    ecx
.text$mn:00006BEC                 mov     [ebp+var_4], ecx
.text$mn:00006BEF                 mov     eax, [ebp+var_4]
.text$mn:00006BF2                 mov     eax, [eax+4]
.text$mn:00006BF5                 mov     esp, ebp
.text$mn:00006BF7                 pop     ebp
.text$mn:00006BF8                 retn
.text$mn:00006BF8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00006BF8
.text$mn:00006BF8 ; ---------------------------------------------------------------------------
.text$mn:00006BF9                 align 4
.text$mn:00006BF9 _text$mn        ends
.text$mn:00006BF9
.text$mn:00006BFC ; ===========================================================================
.text$mn:00006BFC
.text$mn:00006BFC ; Segment type: Pure code
.text$mn:00006BFC ; Segment permissions: Read/Execute
.text$mn:00006BFC _text$mn        segment para public 'CODE' use32
.text$mn:00006BFC                 assume cs:_text$mn
.text$mn:00006BFC                 ;org 6BFCh
.text$mn:00006BFC ; COMDAT (pick any)
.text$mn:00006BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BFC
.text$mn:00006BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00006BFC
.text$mn:00006BFC ; Attributes: bp-based frame
.text$mn:00006BFC
.text$mn:00006BFC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00006BFC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00006BFC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00006BFC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00006BFC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00006BFC
.text$mn:00006BFC var_4           = dword ptr -4
.text$mn:00006BFC
.text$mn:00006BFC                 push    ebp
.text$mn:00006BFD                 mov     ebp, esp
.text$mn:00006BFF                 push    ecx
.text$mn:00006C00                 mov     [ebp+var_4], ecx
.text$mn:00006C03                 mov     eax, [ebp+var_4]
.text$mn:00006C06                 mov     eax, [eax+4]
.text$mn:00006C09                 mov     esp, ebp
.text$mn:00006C0B                 pop     ebp
.text$mn:00006C0C                 retn
.text$mn:00006C0C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00006C0C
.text$mn:00006C0C ; ---------------------------------------------------------------------------
.text$mn:00006C0D                 align 10h
.text$mn:00006C0D _text$mn        ends
.text$mn:00006C0D
.text$mn:00006C10 ; ===========================================================================
.text$mn:00006C10
.text$mn:00006C10 ; Segment type: Pure code
.text$mn:00006C10 ; Segment permissions: Read/Execute
.text$mn:00006C10 _text$mn        segment para public 'CODE' use32
.text$mn:00006C10                 assume cs:_text$mn
.text$mn:00006C10                 ;org 6C10h
.text$mn:00006C10 ; COMDAT (pick any)
.text$mn:00006C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C10
.text$mn:00006C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C10
.text$mn:00006C10 ; Attributes: bp-based frame
.text$mn:00006C10
.text$mn:00006C10 ; public: void __thiscall std::basic_ios<char, struct std::char_traits<char>>::clear(int, bool)
.text$mn:00006C10                 public ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
.text$mn:00006C10 ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z proc near
.text$mn:00006C10                                         ; CODE XREF: std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)+21p
.text$mn:00006C10
.text$mn:00006C10 var_8           = dword ptr -8
.text$mn:00006C10 var_4           = dword ptr -4
.text$mn:00006C10 arg_0           = dword ptr  8
.text$mn:00006C10 arg_4           = byte ptr  0Ch
.text$mn:00006C10
.text$mn:00006C10                 push    ebp
.text$mn:00006C11                 mov     ebp, esp
.text$mn:00006C13                 sub     esp, 8
.text$mn:00006C16                 mov     [ebp+var_8], ecx
.text$mn:00006C19                 mov     eax, [ebp+var_8]
.text$mn:00006C1C                 cmp     dword ptr [eax+38h], 0
.text$mn:00006C20                 jnz     short loc_6C2D
.text$mn:00006C22                 mov     ecx, [ebp+arg_0]
.text$mn:00006C25                 or      ecx, 4
.text$mn:00006C28                 mov     [ebp+var_4], ecx
.text$mn:00006C2B                 jmp     short loc_6C33
.text$mn:00006C2D ; ---------------------------------------------------------------------------
.text$mn:00006C2D
.text$mn:00006C2D loc_6C2D:                               ; CODE XREF: std::basic_ios<char,std::char_traits<char>>::clear(int,bool)+10j
.text$mn:00006C2D                 mov     edx, [ebp+arg_0]
.text$mn:00006C30                 mov     [ebp+var_4], edx
.text$mn:00006C33
.text$mn:00006C33 loc_6C33:                               ; CODE XREF: std::basic_ios<char,std::char_traits<char>>::clear(int,bool)+1Bj
.text$mn:00006C33                 movzx   eax, [ebp+arg_4]
.text$mn:00006C37                 push    eax             ; bool
.text$mn:00006C38                 mov     ecx, [ebp+var_4]
.text$mn:00006C3B                 push    ecx             ; int
.text$mn:00006C3C                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006C3F                 call    ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear(int,bool)
.text$mn:00006C44                 mov     esp, ebp
.text$mn:00006C46                 pop     ebp
.text$mn:00006C47                 retn    8
.text$mn:00006C47 ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z endp
.text$mn:00006C47
.text$mn:00006C47 ; ---------------------------------------------------------------------------
.text$mn:00006C4A                 align 4
.text$mn:00006C4A _text$mn        ends
.text$mn:00006C4A
.text$mn:00006C4C ; ===========================================================================
.text$mn:00006C4C
.text$mn:00006C4C ; Segment type: Pure code
.text$mn:00006C4C ; Segment permissions: Read/Execute
.text$mn:00006C4C _text$mn        segment para public 'CODE' use32
.text$mn:00006C4C                 assume cs:_text$mn
.text$mn:00006C4C                 ;org 6C4Ch
.text$mn:00006C4C ; COMDAT (pick any)
.text$mn:00006C4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C4C
.text$mn:00006C4C ; =============== S U B R O U T I N E =======================================
.text$mn:00006C4C
.text$mn:00006C4C ; Attributes: bp-based frame
.text$mn:00006C4C
.text$mn:00006C4C ; void __thiscall std::ios_base::clear(std::ios_base *this, int, bool)
.text$mn:00006C4C                 public ?clear@ios_base@std@@QAEXH_N@Z
.text$mn:00006C4C ?clear@ios_base@std@@QAEXH_N@Z proc near
.text$mn:00006C4C                                         ; CODE XREF: std::basic_ios<char,std::char_traits<char>>::clear(int,bool)+2Fp
.text$mn:00006C4C
.text$mn:00006C4C var_58          = byte ptr -58h
.text$mn:00006C4C var_44          = byte ptr -44h
.text$mn:00006C4C var_30          = byte ptr -30h
.text$mn:00006C4C var_1C          = byte ptr -1Ch
.text$mn:00006C4C var_14          = byte ptr -14h
.text$mn:00006C4C var_C           = byte ptr -0Ch
.text$mn:00006C4C var_4           = dword ptr -4
.text$mn:00006C4C arg_0           = dword ptr  8
.text$mn:00006C4C arg_4           = byte ptr  0Ch
.text$mn:00006C4C
.text$mn:00006C4C                 push    ebp
.text$mn:00006C4D                 mov     ebp, esp
.text$mn:00006C4F                 sub     esp, 58h
.text$mn:00006C52                 mov     [ebp+var_4], ecx
.text$mn:00006C55                 mov     eax, [ebp+arg_0]
.text$mn:00006C58                 and     eax, 17h
.text$mn:00006C5B                 mov     ecx, [ebp+var_4]
.text$mn:00006C5E                 mov     [ecx+0Ch], eax
.text$mn:00006C61                 mov     edx, [ebp+var_4]
.text$mn:00006C64                 mov     eax, [ebp+var_4]
.text$mn:00006C67                 mov     ecx, [edx+0Ch]
.text$mn:00006C6A                 and     ecx, [eax+10h]
.text$mn:00006C6D                 jnz     short loc_6C74
.text$mn:00006C6F                 jmp     loc_6D2E
.text$mn:00006C74 ; ---------------------------------------------------------------------------
.text$mn:00006C74
.text$mn:00006C74 loc_6C74:                               ; CODE XREF: std::ios_base::clear(int,bool)+21j
.text$mn:00006C74                 movzx   edx, [ebp+arg_4]
.text$mn:00006C78                 test    edx, edx
.text$mn:00006C7A                 jz      short loc_6C8A
.text$mn:00006C7C                 push    0
.text$mn:00006C7E                 push    0
.text$mn:00006C80                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006C85 ; ---------------------------------------------------------------------------
.text$mn:00006C85                 jmp     loc_6D2E
.text$mn:00006C8A ; ---------------------------------------------------------------------------
.text$mn:00006C8A
.text$mn:00006C8A loc_6C8A:                               ; CODE XREF: std::ios_base::clear(int,bool)+2Ej
.text$mn:00006C8A                 mov     eax, [ebp+var_4]
.text$mn:00006C8D                 mov     ecx, [ebp+var_4]
.text$mn:00006C90                 mov     edx, [eax+0Ch]
.text$mn:00006C93                 and     edx, [ecx+10h]
.text$mn:00006C96                 and     edx, 4
.text$mn:00006C99                 jz      short loc_6CC7
.text$mn:00006C9B                 push    1
.text$mn:00006C9D                 lea     eax, [ebp+var_C]
.text$mn:00006CA0                 push    eax
.text$mn:00006CA1                 call    ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code(std::io_errc)
.text$mn:00006CA6                 add     esp, 8
.text$mn:00006CA9                 push    eax             ; struct std::error_code *
.text$mn:00006CAA                 push    offset ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ ; "ios_base::badbit set"
.text$mn:00006CAF                 lea     ecx, [ebp+var_30] ; this
.text$mn:00006CB2                 call    ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure(char const *,std::error_code const &)
.text$mn:00006CB7                 push    offset __TI5?AVfailure@ios_base@std@@
.text$mn:00006CBC                 lea     ecx, [ebp+var_30]
.text$mn:00006CBF                 push    ecx
.text$mn:00006CC0                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006CC5 ; ---------------------------------------------------------------------------
.text$mn:00006CC5                 jmp     short loc_6D2E
.text$mn:00006CC7 ; ---------------------------------------------------------------------------
.text$mn:00006CC7
.text$mn:00006CC7 loc_6CC7:                               ; CODE XREF: std::ios_base::clear(int,bool)+4Dj
.text$mn:00006CC7                 mov     edx, [ebp+var_4]
.text$mn:00006CCA                 mov     eax, [ebp+var_4]
.text$mn:00006CCD                 mov     ecx, [edx+0Ch]
.text$mn:00006CD0                 and     ecx, [eax+10h]
.text$mn:00006CD3                 and     ecx, 2
.text$mn:00006CD6                 jz      short loc_6D04
.text$mn:00006CD8                 push    1
.text$mn:00006CDA                 lea     edx, [ebp+var_14]
.text$mn:00006CDD                 push    edx
.text$mn:00006CDE                 call    ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code(std::io_errc)
.text$mn:00006CE3                 add     esp, 8
.text$mn:00006CE6                 push    eax             ; struct std::error_code *
.text$mn:00006CE7                 push    offset ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; "ios_base::failbit set"
.text$mn:00006CEC                 lea     ecx, [ebp+var_44] ; this
.text$mn:00006CEF                 call    ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure(char const *,std::error_code const &)
.text$mn:00006CF4                 push    offset __TI5?AVfailure@ios_base@std@@
.text$mn:00006CF9                 lea     eax, [ebp+var_44]
.text$mn:00006CFC                 push    eax
.text$mn:00006CFD                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006D02 ; ---------------------------------------------------------------------------
.text$mn:00006D02                 jmp     short loc_6D2E
.text$mn:00006D04 ; ---------------------------------------------------------------------------
.text$mn:00006D04
.text$mn:00006D04 loc_6D04:                               ; CODE XREF: std::ios_base::clear(int,bool)+8Aj
.text$mn:00006D04                 push    1
.text$mn:00006D06                 lea     ecx, [ebp+var_1C]
.text$mn:00006D09                 push    ecx
.text$mn:00006D0A                 call    ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code(std::io_errc)
.text$mn:00006D0F                 add     esp, 8
.text$mn:00006D12                 push    eax             ; struct std::error_code *
.text$mn:00006D13                 push    offset ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ ; "ios_base::eofbit set"
.text$mn:00006D18                 lea     ecx, [ebp+var_58] ; this
.text$mn:00006D1B                 call    ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure(char const *,std::error_code const &)
.text$mn:00006D20                 push    offset __TI5?AVfailure@ios_base@std@@
.text$mn:00006D25                 lea     edx, [ebp+var_58]
.text$mn:00006D28                 push    edx
.text$mn:00006D29                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006D2E ; ---------------------------------------------------------------------------
.text$mn:00006D2E
.text$mn:00006D2E loc_6D2E:                               ; CODE XREF: std::ios_base::clear(int,bool)+23j
.text$mn:00006D2E                                         ; std::ios_base::clear(int,bool)+39j ...
.text$mn:00006D2E                 mov     esp, ebp
.text$mn:00006D30                 pop     ebp
.text$mn:00006D31                 retn    8
.text$mn:00006D31 ?clear@ios_base@std@@QAEXH_N@Z endp
.text$mn:00006D31
.text$mn:00006D31 _text$mn        ends
.text$mn:00006D31
.text$mn:00006D34 ; ===========================================================================
.text$mn:00006D34
.text$mn:00006D34 ; Segment type: Pure code
.text$mn:00006D34 ; Segment permissions: Read/Execute
.text$mn:00006D34 _text$mn        segment para public 'CODE' use32
.text$mn:00006D34                 assume cs:_text$mn
.text$mn:00006D34                 ;org 6D34h
.text$mn:00006D34 ; COMDAT (pick any)
.text$mn:00006D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D34
.text$mn:00006D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D34
.text$mn:00006D34 ; Attributes: bp-based frame
.text$mn:00006D34
.text$mn:00006D34 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00006D34                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00006D34 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00006D34                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00006D34
.text$mn:00006D34 var_4           = dword ptr -4
.text$mn:00006D34 Dst             = dword ptr  8
.text$mn:00006D34 Src             = dword ptr  0Ch
.text$mn:00006D34 Size            = dword ptr  10h
.text$mn:00006D34
.text$mn:00006D34                 push    ebp
.text$mn:00006D35                 mov     ebp, esp
.text$mn:00006D37                 push    ecx
.text$mn:00006D38                 cmp     [ebp+Size], 0
.text$mn:00006D3C                 jnz     short loc_6D46
.text$mn:00006D3E                 mov     eax, [ebp+Dst]
.text$mn:00006D41                 mov     [ebp+var_4], eax
.text$mn:00006D44                 jmp     short loc_6D5D
.text$mn:00006D46 ; ---------------------------------------------------------------------------
.text$mn:00006D46
.text$mn:00006D46 loc_6D46:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00006D46                 mov     ecx, [ebp+Size]
.text$mn:00006D49                 push    ecx             ; Size
.text$mn:00006D4A                 mov     edx, [ebp+Src]
.text$mn:00006D4D                 push    edx             ; Src
.text$mn:00006D4E                 mov     eax, [ebp+Dst]
.text$mn:00006D51                 push    eax             ; Dst
.text$mn:00006D52                 call    _memcpy
.text$mn:00006D57                 add     esp, 0Ch
.text$mn:00006D5A                 mov     [ebp+var_4], eax
.text$mn:00006D5D
.text$mn:00006D5D loc_6D5D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00006D5D                 mov     eax, [ebp+var_4]
.text$mn:00006D60                 mov     esp, ebp
.text$mn:00006D62                 pop     ebp
.text$mn:00006D63                 retn
.text$mn:00006D63 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00006D63
.text$mn:00006D63 _text$mn        ends
.text$mn:00006D63
.text$mn:00006D64 ; ===========================================================================
.text$mn:00006D64
.text$mn:00006D64 ; Segment type: Pure code
.text$mn:00006D64 ; Segment permissions: Read/Execute
.text$mn:00006D64 _text$mn        segment para public 'CODE' use32
.text$mn:00006D64                 assume cs:_text$mn
.text$mn:00006D64                 ;org 6D64h
.text$mn:00006D64 ; COMDAT (pick any)
.text$mn:00006D64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D64
.text$mn:00006D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D64
.text$mn:00006D64 ; Attributes: bp-based frame
.text$mn:00006D64
.text$mn:00006D64 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00006D64                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00006D64 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00006D64                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00006D64
.text$mn:00006D64 var_4           = dword ptr -4
.text$mn:00006D64 arg_0           = dword ptr  8
.text$mn:00006D64 arg_4           = dword ptr  0Ch
.text$mn:00006D64
.text$mn:00006D64                 push    ebp
.text$mn:00006D65                 mov     ebp, esp
.text$mn:00006D67                 push    ecx
.text$mn:00006D68                 mov     [ebp+var_4], ecx
.text$mn:00006D6B                 mov     eax, [ebp+arg_4]
.text$mn:00006D6E                 push    eax             ; int
.text$mn:00006D6F                 mov     ecx, [ebp+arg_0]
.text$mn:00006D72                 push    ecx             ; void *
.text$mn:00006D73                 mov     ecx, [ebp+var_4]
.text$mn:00006D76                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00006D7B                 mov     esp, ebp
.text$mn:00006D7D                 pop     ebp
.text$mn:00006D7E                 retn    8
.text$mn:00006D7E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00006D7E
.text$mn:00006D7E ; ---------------------------------------------------------------------------
.text$mn:00006D81                 align 4
.text$mn:00006D81 _text$mn        ends
.text$mn:00006D81
.text$mn:00006D84 ; ===========================================================================
.text$mn:00006D84
.text$mn:00006D84 ; Segment type: Pure code
.text$mn:00006D84 ; Segment permissions: Read/Execute
.text$mn:00006D84 _text$mn        segment para public 'CODE' use32
.text$mn:00006D84                 assume cs:_text$mn
.text$mn:00006D84                 ;org 6D84h
.text$mn:00006D84 ; COMDAT (pick any)
.text$mn:00006D84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D84
.text$mn:00006D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D84
.text$mn:00006D84 ; Attributes: bp-based frame
.text$mn:00006D84
.text$mn:00006D84 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00006D84                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00006D84 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00006D84                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00006D84
.text$mn:00006D84 var_4           = dword ptr -4
.text$mn:00006D84 arg_0           = dword ptr  8
.text$mn:00006D84
.text$mn:00006D84                 push    ebp
.text$mn:00006D85                 mov     ebp, esp
.text$mn:00006D87                 push    ecx
.text$mn:00006D88                 mov     [ebp+var_4], ecx
.text$mn:00006D8B                 mov     eax, [ebp+arg_0]
.text$mn:00006D8E                 push    eax             ; void *
.text$mn:00006D8F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006D94                 add     esp, 4
.text$mn:00006D97                 mov     esp, ebp
.text$mn:00006D99                 pop     ebp
.text$mn:00006D9A                 retn    8
.text$mn:00006D9A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00006D9A
.text$mn:00006D9A ; ---------------------------------------------------------------------------
.text$mn:00006D9D                 align 10h
.text$mn:00006D9D _text$mn        ends
.text$mn:00006D9D
.text$mn:00006DA0 ; ===========================================================================
.text$mn:00006DA0
.text$mn:00006DA0 ; Segment type: Pure code
.text$mn:00006DA0 ; Segment permissions: Read/Execute
.text$mn:00006DA0 _text$mn        segment para public 'CODE' use32
.text$mn:00006DA0                 assume cs:_text$mn
.text$mn:00006DA0                 ;org 6DA0h
.text$mn:00006DA0 ; COMDAT (pick any)
.text$mn:00006DA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006DA0
.text$mn:00006DA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006DA0
.text$mn:00006DA0 ; Attributes: bp-based frame
.text$mn:00006DA0
.text$mn:00006DA0 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00006DA0                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00006DA0 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00006DA0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00006DA0
.text$mn:00006DA0 var_4           = dword ptr -4
.text$mn:00006DA0 arg_0           = dword ptr  8
.text$mn:00006DA0
.text$mn:00006DA0                 push    ebp
.text$mn:00006DA1                 mov     ebp, esp
.text$mn:00006DA3                 push    ecx
.text$mn:00006DA4                 mov     [ebp+var_4], ecx
.text$mn:00006DA7                 mov     eax, [ebp+arg_0]
.text$mn:00006DAA                 push    eax             ; void *
.text$mn:00006DAB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006DB0                 add     esp, 4
.text$mn:00006DB3                 mov     esp, ebp
.text$mn:00006DB5                 pop     ebp
.text$mn:00006DB6                 retn    8
.text$mn:00006DB6 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00006DB6
.text$mn:00006DB6 ; ---------------------------------------------------------------------------
.text$mn:00006DB9                 align 4
.text$mn:00006DB9 _text$mn        ends
.text$mn:00006DB9
.text$mn:00006DBC ; ===========================================================================
.text$mn:00006DBC
.text$mn:00006DBC ; Segment type: Pure code
.text$mn:00006DBC ; Segment permissions: Read/Execute
.text$mn:00006DBC _text$mn        segment para public 'CODE' use32
.text$mn:00006DBC                 assume cs:_text$mn
.text$mn:00006DBC                 ;org 6DBCh
.text$mn:00006DBC ; COMDAT (pick any)
.text$mn:00006DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006DBC
.text$mn:00006DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00006DBC
.text$mn:00006DBC ; Attributes: bp-based frame
.text$mn:00006DBC
.text$mn:00006DBC ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00006DBC                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00006DBC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00006DBC                                         ; DATA XREF: .rdata:00008ECCo
.text$mn:00006DBC
.text$mn:00006DBC var_4           = dword ptr -4
.text$mn:00006DBC arg_0           = dword ptr  8
.text$mn:00006DBC arg_4           = dword ptr  0Ch
.text$mn:00006DBC
.text$mn:00006DBC                 push    ebp
.text$mn:00006DBD                 mov     ebp, esp
.text$mn:00006DBF                 push    ecx
.text$mn:00006DC0                 mov     [ebp+var_4], ecx
.text$mn:00006DC3                 mov     eax, [ebp+arg_4]
.text$mn:00006DC6                 push    eax             ; int
.text$mn:00006DC7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00006DCC                 add     esp, 4
.text$mn:00006DCF                 test    eax, eax
.text$mn:00006DD1                 jz      short loc_6DEC
.text$mn:00006DD3                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00006DD8                 push    eax             ; struct std::error_category *
.text$mn:00006DD9                 mov     ecx, [ebp+arg_4]
.text$mn:00006DDC                 push    ecx             ; int
.text$mn:00006DDD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006DE0                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00006DE5                 mov     eax, [ebp+arg_0]
.text$mn:00006DE8                 jmp     short loc_6E01
.text$mn:00006DEA ; ---------------------------------------------------------------------------
.text$mn:00006DEA                 jmp     short loc_6E01
.text$mn:00006DEC ; ---------------------------------------------------------------------------
.text$mn:00006DEC
.text$mn:00006DEC loc_6DEC:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00006DEC                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00006DF1                 push    eax             ; struct std::error_category *
.text$mn:00006DF2                 mov     edx, [ebp+arg_4]
.text$mn:00006DF5                 push    edx             ; int
.text$mn:00006DF6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006DF9                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00006DFE                 mov     eax, [ebp+arg_0]
.text$mn:00006E01
.text$mn:00006E01 loc_6E01:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00006E01                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00006E01                 mov     esp, ebp
.text$mn:00006E03                 pop     ebp
.text$mn:00006E04                 retn    8
.text$mn:00006E04 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00006E04
.text$mn:00006E04 ; ---------------------------------------------------------------------------
.text$mn:00006E07                 align 4
.text$mn:00006E07 _text$mn        ends
.text$mn:00006E07
.text$mn:00006E08 ; ===========================================================================
.text$mn:00006E08
.text$mn:00006E08 ; Segment type: Pure code
.text$mn:00006E08 ; Segment permissions: Read/Execute
.text$mn:00006E08 _text$mn        segment para public 'CODE' use32
.text$mn:00006E08                 assume cs:_text$mn
.text$mn:00006E08                 ;org 6E08h
.text$mn:00006E08 ; COMDAT (pick any)
.text$mn:00006E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E08
.text$mn:00006E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E08
.text$mn:00006E08 ; Attributes: bp-based frame
.text$mn:00006E08
.text$mn:00006E08 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00006E08                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00006E08 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00006E08                                         ; DATA XREF: .rdata:00008E20o
.text$mn:00006E08                                         ; .rdata:00008E58o ...
.text$mn:00006E08
.text$mn:00006E08 var_4           = dword ptr -4
.text$mn:00006E08 arg_0           = dword ptr  8
.text$mn:00006E08 arg_4           = dword ptr  0Ch
.text$mn:00006E08
.text$mn:00006E08                 push    ebp
.text$mn:00006E09                 mov     ebp, esp
.text$mn:00006E0B                 push    ecx
.text$mn:00006E0C                 mov     [ebp+var_4], ecx
.text$mn:00006E0F                 mov     eax, [ebp+var_4]
.text$mn:00006E12                 push    eax             ; struct std::error_category *
.text$mn:00006E13                 mov     ecx, [ebp+arg_4]
.text$mn:00006E16                 push    ecx             ; int
.text$mn:00006E17                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006E1A                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00006E1F                 mov     eax, [ebp+arg_0]
.text$mn:00006E22                 mov     esp, ebp
.text$mn:00006E24                 pop     ebp
.text$mn:00006E25                 retn    8
.text$mn:00006E25 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00006E25
.text$mn:00006E25 _text$mn        ends
.text$mn:00006E25
.text$mn:00006E28 ; ===========================================================================
.text$mn:00006E28
.text$mn:00006E28 ; Segment type: Pure code
.text$mn:00006E28 ; Segment permissions: Read/Execute
.text$mn:00006E28 _text$mn        segment para public 'CODE' use32
.text$mn:00006E28                 assume cs:_text$mn
.text$mn:00006E28                 ;org 6E28h
.text$mn:00006E28 ; COMDAT (pick any)
.text$mn:00006E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E28
.text$mn:00006E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E28
.text$mn:00006E28 ; Attributes: bp-based frame
.text$mn:00006E28
.text$mn:00006E28 ; protected: virtual char __thiscall std::ctype<char>::do_narrow(char, char)const
.text$mn:00006E28                 public ?do_narrow@?$ctype@D@std@@MBEDDD@Z
.text$mn:00006E28 ?do_narrow@?$ctype@D@std@@MBEDDD@Z proc near ; DATA XREF: .rdata:00008E0Co
.text$mn:00006E28
.text$mn:00006E28 var_4           = dword ptr -4
.text$mn:00006E28 arg_0           = byte ptr  8
.text$mn:00006E28
.text$mn:00006E28                 push    ebp
.text$mn:00006E29                 mov     ebp, esp
.text$mn:00006E2B                 push    ecx
.text$mn:00006E2C                 mov     [ebp+var_4], ecx
.text$mn:00006E2F                 mov     al, [ebp+arg_0]
.text$mn:00006E32                 mov     esp, ebp
.text$mn:00006E34                 pop     ebp
.text$mn:00006E35                 retn    8
.text$mn:00006E35 ?do_narrow@?$ctype@D@std@@MBEDDD@Z endp
.text$mn:00006E35
.text$mn:00006E35 _text$mn        ends
.text$mn:00006E35
.text$mn:00006E38 ; ===========================================================================
.text$mn:00006E38
.text$mn:00006E38 ; Segment type: Pure code
.text$mn:00006E38 ; Segment permissions: Read/Execute
.text$mn:00006E38 _text$mn        segment para public 'CODE' use32
.text$mn:00006E38                 assume cs:_text$mn
.text$mn:00006E38                 ;org 6E38h
.text$mn:00006E38 ; COMDAT (pick any)
.text$mn:00006E38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E38
.text$mn:00006E38 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E38
.text$mn:00006E38 ; Attributes: bp-based frame
.text$mn:00006E38
.text$mn:00006E38 ; int __stdcall std::ctype<char>::do_narrow(void *Src, int, int, void *Dst)
.text$mn:00006E38                 public ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
.text$mn:00006E38 ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z proc near
.text$mn:00006E38                                         ; DATA XREF: .rdata:00008E08o
.text$mn:00006E38
.text$mn:00006E38 var_4           = dword ptr -4
.text$mn:00006E38 Src             = dword ptr  8
.text$mn:00006E38 arg_4           = dword ptr  0Ch
.text$mn:00006E38 Dst             = dword ptr  14h
.text$mn:00006E38
.text$mn:00006E38                 push    ebp
.text$mn:00006E39                 mov     ebp, esp
.text$mn:00006E3B                 push    ecx
.text$mn:00006E3C                 mov     [ebp+var_4], ecx
.text$mn:00006E3F                 push    0A02h           ; unsigned int
.text$mn:00006E44                 push    offset ??_C@_1IO@OFOLDAJI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006E49                 mov     eax, [ebp+arg_4]
.text$mn:00006E4C                 push    eax             ; int
.text$mn:00006E4D                 mov     ecx, [ebp+Src]
.text$mn:00006E50                 push    ecx             ; int
.text$mn:00006E51                 call    ??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z ; std::_Debug_range<char const *>(char const *,char const *,wchar_t const *,uint)
.text$mn:00006E56                 add     esp, 10h
.text$mn:00006E59                 push    0A03h           ; unsigned int
.text$mn:00006E5E                 push    offset ??_C@_1IO@OFOLDAJI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006E63                 mov     edx, [ebp+Dst]
.text$mn:00006E66                 push    edx             ; int
.text$mn:00006E67                 call    ??$_Debug_pointer@D@std@@YAXPADPB_WI@Z ; std::_Debug_pointer<char>(char *,wchar_t const *,uint)
.text$mn:00006E6C                 add     esp, 0Ch
.text$mn:00006E6F                 mov     eax, [ebp+arg_4]
.text$mn:00006E72                 sub     eax, [ebp+Src]
.text$mn:00006E75                 push    eax             ; Size
.text$mn:00006E76                 mov     ecx, [ebp+Src]
.text$mn:00006E79                 push    ecx             ; Src
.text$mn:00006E7A                 mov     edx, [ebp+Dst]
.text$mn:00006E7D                 push    edx             ; Dst
.text$mn:00006E7E                 call    _memcpy
.text$mn:00006E83                 add     esp, 0Ch
.text$mn:00006E86                 mov     eax, [ebp+arg_4]
.text$mn:00006E89                 mov     esp, ebp
.text$mn:00006E8B                 pop     ebp
.text$mn:00006E8C                 retn    10h
.text$mn:00006E8C ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z endp
.text$mn:00006E8C
.text$mn:00006E8C ; ---------------------------------------------------------------------------
.text$mn:00006E8F                 align 10h
.text$mn:00006E8F _text$mn        ends
.text$mn:00006E8F
.text$mn:00006E90 ; ===========================================================================
.text$mn:00006E90
.text$mn:00006E90 ; Segment type: Pure code
.text$mn:00006E90 ; Segment permissions: Read/Execute
.text$mn:00006E90 _text$mn        segment para public 'CODE' use32
.text$mn:00006E90                 assume cs:_text$mn
.text$mn:00006E90                 ;org 6E90h
.text$mn:00006E90 ; COMDAT (pick any)
.text$mn:00006E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E90
.text$mn:00006E90 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E90
.text$mn:00006E90 ; Attributes: bp-based frame
.text$mn:00006E90
.text$mn:00006E90 ; protected: virtual char __thiscall std::ctype<char>::do_tolower(char)const
.text$mn:00006E90                 public ?do_tolower@?$ctype@D@std@@MBEDD@Z
.text$mn:00006E90 ?do_tolower@?$ctype@D@std@@MBEDD@Z proc near ; DATA XREF: .rdata:00008DF4o
.text$mn:00006E90
.text$mn:00006E90 var_4           = dword ptr -4
.text$mn:00006E90 arg_0           = byte ptr  8
.text$mn:00006E90
.text$mn:00006E90                 push    ebp
.text$mn:00006E91                 mov     ebp, esp
.text$mn:00006E93                 push    ecx
.text$mn:00006E94                 mov     [ebp+var_4], ecx
.text$mn:00006E97                 mov     eax, [ebp+var_4]
.text$mn:00006E9A                 add     eax, 8
.text$mn:00006E9D                 push    eax
.text$mn:00006E9E                 movzx   ecx, [ebp+arg_0]
.text$mn:00006EA2                 push    ecx
.text$mn:00006EA3                 call    __Tolower
.text$mn:00006EA8                 add     esp, 8
.text$mn:00006EAB                 mov     esp, ebp
.text$mn:00006EAD                 pop     ebp
.text$mn:00006EAE                 retn    4
.text$mn:00006EAE ?do_tolower@?$ctype@D@std@@MBEDD@Z endp
.text$mn:00006EAE
.text$mn:00006EAE ; ---------------------------------------------------------------------------
.text$mn:00006EB1                 align 4
.text$mn:00006EB1 _text$mn        ends
.text$mn:00006EB1
.text$mn:00006EB4 ; ===========================================================================
.text$mn:00006EB4
.text$mn:00006EB4 ; Segment type: Pure code
.text$mn:00006EB4 ; Segment permissions: Read/Execute
.text$mn:00006EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00006EB4                 assume cs:_text$mn
.text$mn:00006EB4                 ;org 6EB4h
.text$mn:00006EB4 ; COMDAT (pick any)
.text$mn:00006EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006EB4
.text$mn:00006EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006EB4
.text$mn:00006EB4 ; Attributes: bp-based frame
.text$mn:00006EB4
.text$mn:00006EB4 ; protected: virtual char const * __thiscall std::ctype<char>::do_tolower(char *, char const *)const
.text$mn:00006EB4                 public ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
.text$mn:00006EB4 ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z proc near
.text$mn:00006EB4                                         ; DATA XREF: .rdata:00008DF0o
.text$mn:00006EB4
.text$mn:00006EB4 var_4           = dword ptr -4
.text$mn:00006EB4 arg_0           = dword ptr  8
.text$mn:00006EB4 arg_4           = dword ptr  0Ch
.text$mn:00006EB4
.text$mn:00006EB4                 push    ebp
.text$mn:00006EB5                 mov     ebp, esp
.text$mn:00006EB7                 push    ecx
.text$mn:00006EB8                 mov     [ebp+var_4], ecx
.text$mn:00006EBB                 push    9D8h            ; unsigned int
.text$mn:00006EC0                 push    offset ??_C@_1IO@OFOLDAJI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006EC5                 mov     eax, [ebp+arg_4]
.text$mn:00006EC8                 push    eax             ; int
.text$mn:00006EC9                 mov     ecx, [ebp+arg_0]
.text$mn:00006ECC                 push    ecx             ; int
.text$mn:00006ECD                 call    ??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z ; std::_Debug_range<char const *>(char const *,char const *,wchar_t const *,uint)
.text$mn:00006ED2                 add     esp, 10h
.text$mn:00006ED5                 jmp     short loc_6EE0
.text$mn:00006ED7 ; ---------------------------------------------------------------------------
.text$mn:00006ED7
.text$mn:00006ED7 loc_6ED7:                               ; CODE XREF: std::ctype<char>::do_tolower(char *,char const *)+4Fj
.text$mn:00006ED7                 mov     edx, [ebp+arg_0]
.text$mn:00006EDA                 add     edx, 1
.text$mn:00006EDD                 mov     [ebp+arg_0], edx
.text$mn:00006EE0
.text$mn:00006EE0 loc_6EE0:                               ; CODE XREF: std::ctype<char>::do_tolower(char *,char const *)+21j
.text$mn:00006EE0                 mov     eax, [ebp+arg_0]
.text$mn:00006EE3                 cmp     eax, [ebp+arg_4]
.text$mn:00006EE6                 jz      short loc_6F05
.text$mn:00006EE8                 mov     ecx, [ebp+var_4]
.text$mn:00006EEB                 add     ecx, 8
.text$mn:00006EEE                 push    ecx
.text$mn:00006EEF                 mov     edx, [ebp+arg_0]
.text$mn:00006EF2                 movzx   eax, byte ptr [edx]
.text$mn:00006EF5                 push    eax
.text$mn:00006EF6                 call    __Tolower
.text$mn:00006EFB                 add     esp, 8
.text$mn:00006EFE                 mov     ecx, [ebp+arg_0]
.text$mn:00006F01                 mov     [ecx], al
.text$mn:00006F03                 jmp     short loc_6ED7
.text$mn:00006F05 ; ---------------------------------------------------------------------------
.text$mn:00006F05
.text$mn:00006F05 loc_6F05:                               ; CODE XREF: std::ctype<char>::do_tolower(char *,char const *)+32j
.text$mn:00006F05                 mov     eax, [ebp+arg_0]
.text$mn:00006F08                 mov     esp, ebp
.text$mn:00006F0A                 pop     ebp
.text$mn:00006F0B                 retn    8
.text$mn:00006F0B ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z endp
.text$mn:00006F0B
.text$mn:00006F0B ; ---------------------------------------------------------------------------
.text$mn:00006F0E                 align 10h
.text$mn:00006F0E _text$mn        ends
.text$mn:00006F0E
.text$mn:00006F10 ; ===========================================================================
.text$mn:00006F10
.text$mn:00006F10 ; Segment type: Pure code
.text$mn:00006F10 ; Segment permissions: Read/Execute
.text$mn:00006F10 _text$mn        segment para public 'CODE' use32
.text$mn:00006F10                 assume cs:_text$mn
.text$mn:00006F10                 ;org 6F10h
.text$mn:00006F10 ; COMDAT (pick any)
.text$mn:00006F10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F10
.text$mn:00006F10 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F10
.text$mn:00006F10 ; Attributes: bp-based frame
.text$mn:00006F10
.text$mn:00006F10 ; protected: virtual char __thiscall std::ctype<char>::do_toupper(char)const
.text$mn:00006F10                 public ?do_toupper@?$ctype@D@std@@MBEDD@Z
.text$mn:00006F10 ?do_toupper@?$ctype@D@std@@MBEDD@Z proc near ; DATA XREF: .rdata:00008DFCo
.text$mn:00006F10
.text$mn:00006F10 var_4           = dword ptr -4
.text$mn:00006F10 arg_0           = byte ptr  8
.text$mn:00006F10
.text$mn:00006F10                 push    ebp
.text$mn:00006F11                 mov     ebp, esp
.text$mn:00006F13                 push    ecx
.text$mn:00006F14                 mov     [ebp+var_4], ecx
.text$mn:00006F17                 mov     eax, [ebp+var_4]
.text$mn:00006F1A                 add     eax, 8
.text$mn:00006F1D                 push    eax
.text$mn:00006F1E                 movzx   ecx, [ebp+arg_0]
.text$mn:00006F22                 push    ecx
.text$mn:00006F23                 call    __Toupper
.text$mn:00006F28                 add     esp, 8
.text$mn:00006F2B                 mov     esp, ebp
.text$mn:00006F2D                 pop     ebp
.text$mn:00006F2E                 retn    4
.text$mn:00006F2E ?do_toupper@?$ctype@D@std@@MBEDD@Z endp
.text$mn:00006F2E
.text$mn:00006F2E ; ---------------------------------------------------------------------------
.text$mn:00006F31                 align 4
.text$mn:00006F31 _text$mn        ends
.text$mn:00006F31
.text$mn:00006F34 ; ===========================================================================
.text$mn:00006F34
.text$mn:00006F34 ; Segment type: Pure code
.text$mn:00006F34 ; Segment permissions: Read/Execute
.text$mn:00006F34 _text$mn        segment para public 'CODE' use32
.text$mn:00006F34                 assume cs:_text$mn
.text$mn:00006F34                 ;org 6F34h
.text$mn:00006F34 ; COMDAT (pick any)
.text$mn:00006F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F34
.text$mn:00006F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F34
.text$mn:00006F34 ; Attributes: bp-based frame
.text$mn:00006F34
.text$mn:00006F34 ; protected: virtual char const * __thiscall std::ctype<char>::do_toupper(char *, char const *)const
.text$mn:00006F34                 public ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
.text$mn:00006F34 ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z proc near
.text$mn:00006F34                                         ; DATA XREF: .rdata:00008DF8o
.text$mn:00006F34
.text$mn:00006F34 var_4           = dword ptr -4
.text$mn:00006F34 arg_0           = dword ptr  8
.text$mn:00006F34 arg_4           = dword ptr  0Ch
.text$mn:00006F34
.text$mn:00006F34                 push    ebp
.text$mn:00006F35                 mov     ebp, esp
.text$mn:00006F37                 push    ecx
.text$mn:00006F38                 mov     [ebp+var_4], ecx
.text$mn:00006F3B                 push    9E6h            ; unsigned int
.text$mn:00006F40                 push    offset ??_C@_1IO@OFOLDAJI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006F45                 mov     eax, [ebp+arg_4]
.text$mn:00006F48                 push    eax             ; int
.text$mn:00006F49                 mov     ecx, [ebp+arg_0]
.text$mn:00006F4C                 push    ecx             ; int
.text$mn:00006F4D                 call    ??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z ; std::_Debug_range<char const *>(char const *,char const *,wchar_t const *,uint)
.text$mn:00006F52                 add     esp, 10h
.text$mn:00006F55                 jmp     short loc_6F60
.text$mn:00006F57 ; ---------------------------------------------------------------------------
.text$mn:00006F57
.text$mn:00006F57 loc_6F57:                               ; CODE XREF: std::ctype<char>::do_toupper(char *,char const *)+4Fj
.text$mn:00006F57                 mov     edx, [ebp+arg_0]
.text$mn:00006F5A                 add     edx, 1
.text$mn:00006F5D                 mov     [ebp+arg_0], edx
.text$mn:00006F60
.text$mn:00006F60 loc_6F60:                               ; CODE XREF: std::ctype<char>::do_toupper(char *,char const *)+21j
.text$mn:00006F60                 mov     eax, [ebp+arg_0]
.text$mn:00006F63                 cmp     eax, [ebp+arg_4]
.text$mn:00006F66                 jz      short loc_6F85
.text$mn:00006F68                 mov     ecx, [ebp+var_4]
.text$mn:00006F6B                 add     ecx, 8
.text$mn:00006F6E                 push    ecx
.text$mn:00006F6F                 mov     edx, [ebp+arg_0]
.text$mn:00006F72                 movzx   eax, byte ptr [edx]
.text$mn:00006F75                 push    eax
.text$mn:00006F76                 call    __Toupper
.text$mn:00006F7B                 add     esp, 8
.text$mn:00006F7E                 mov     ecx, [ebp+arg_0]
.text$mn:00006F81                 mov     [ecx], al
.text$mn:00006F83                 jmp     short loc_6F57
.text$mn:00006F85 ; ---------------------------------------------------------------------------
.text$mn:00006F85
.text$mn:00006F85 loc_6F85:                               ; CODE XREF: std::ctype<char>::do_toupper(char *,char const *)+32j
.text$mn:00006F85                 mov     eax, [ebp+arg_0]
.text$mn:00006F88                 mov     esp, ebp
.text$mn:00006F8A                 pop     ebp
.text$mn:00006F8B                 retn    8
.text$mn:00006F8B ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z endp
.text$mn:00006F8B
.text$mn:00006F8B ; ---------------------------------------------------------------------------
.text$mn:00006F8E                 align 10h
.text$mn:00006F8E _text$mn        ends
.text$mn:00006F8E
.text$mn:00006F90 ; ===========================================================================
.text$mn:00006F90
.text$mn:00006F90 ; Segment type: Pure code
.text$mn:00006F90 ; Segment permissions: Read/Execute
.text$mn:00006F90 _text$mn        segment para public 'CODE' use32
.text$mn:00006F90                 assume cs:_text$mn
.text$mn:00006F90                 ;org 6F90h
.text$mn:00006F90 ; COMDAT (pick any)
.text$mn:00006F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F90
.text$mn:00006F90 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F90
.text$mn:00006F90 ; Attributes: bp-based frame
.text$mn:00006F90
.text$mn:00006F90 ; protected: virtual char __thiscall std::ctype<char>::do_widen(char)const
.text$mn:00006F90                 public ?do_widen@?$ctype@D@std@@MBEDD@Z
.text$mn:00006F90 ?do_widen@?$ctype@D@std@@MBEDD@Z proc near ; DATA XREF: .rdata:00008E04o
.text$mn:00006F90
.text$mn:00006F90 var_4           = dword ptr -4
.text$mn:00006F90 arg_0           = byte ptr  8
.text$mn:00006F90
.text$mn:00006F90                 push    ebp
.text$mn:00006F91                 mov     ebp, esp
.text$mn:00006F93                 push    ecx
.text$mn:00006F94                 mov     [ebp+var_4], ecx
.text$mn:00006F97                 mov     al, [ebp+arg_0]
.text$mn:00006F9A                 mov     esp, ebp
.text$mn:00006F9C                 pop     ebp
.text$mn:00006F9D                 retn    4
.text$mn:00006F9D ?do_widen@?$ctype@D@std@@MBEDD@Z endp
.text$mn:00006F9D
.text$mn:00006F9D _text$mn        ends
.text$mn:00006F9D
.text$mn:00006FA0 ; ===========================================================================
.text$mn:00006FA0
.text$mn:00006FA0 ; Segment type: Pure code
.text$mn:00006FA0 ; Segment permissions: Read/Execute
.text$mn:00006FA0 _text$mn        segment para public 'CODE' use32
.text$mn:00006FA0                 assume cs:_text$mn
.text$mn:00006FA0                 ;org 6FA0h
.text$mn:00006FA0 ; COMDAT (pick any)
.text$mn:00006FA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FA0
.text$mn:00006FA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FA0
.text$mn:00006FA0 ; Attributes: bp-based frame
.text$mn:00006FA0
.text$mn:00006FA0 ; int __stdcall std::ctype<char>::do_widen(void *Src, int, void *Dst)
.text$mn:00006FA0                 public ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
.text$mn:00006FA0 ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z proc near
.text$mn:00006FA0                                         ; DATA XREF: .rdata:00008E00o
.text$mn:00006FA0
.text$mn:00006FA0 var_4           = dword ptr -4
.text$mn:00006FA0 Src             = dword ptr  8
.text$mn:00006FA0 arg_4           = dword ptr  0Ch
.text$mn:00006FA0 Dst             = dword ptr  10h
.text$mn:00006FA0
.text$mn:00006FA0                 push    ebp
.text$mn:00006FA1                 mov     ebp, esp
.text$mn:00006FA3                 push    ecx
.text$mn:00006FA4                 mov     [ebp+var_4], ecx
.text$mn:00006FA7                 push    9F4h            ; unsigned int
.text$mn:00006FAC                 push    offset ??_C@_1IO@OFOLDAJI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006FB1                 mov     eax, [ebp+arg_4]
.text$mn:00006FB4                 push    eax             ; int
.text$mn:00006FB5                 mov     ecx, [ebp+Src]
.text$mn:00006FB8                 push    ecx             ; int
.text$mn:00006FB9                 call    ??$_Debug_range@PBD@std@@YAXPBD0PB_WI@Z ; std::_Debug_range<char const *>(char const *,char const *,wchar_t const *,uint)
.text$mn:00006FBE                 add     esp, 10h
.text$mn:00006FC1                 push    9F5h            ; unsigned int
.text$mn:00006FC6                 push    offset ??_C@_1IO@OFOLDAJI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006FCB                 mov     edx, [ebp+Dst]
.text$mn:00006FCE                 push    edx             ; int
.text$mn:00006FCF                 call    ??$_Debug_pointer@D@std@@YAXPADPB_WI@Z ; std::_Debug_pointer<char>(char *,wchar_t const *,uint)
.text$mn:00006FD4                 add     esp, 0Ch
.text$mn:00006FD7                 mov     eax, [ebp+arg_4]
.text$mn:00006FDA                 sub     eax, [ebp+Src]
.text$mn:00006FDD                 push    eax             ; Size
.text$mn:00006FDE                 mov     ecx, [ebp+Src]
.text$mn:00006FE1                 push    ecx             ; Src
.text$mn:00006FE2                 mov     edx, [ebp+Dst]
.text$mn:00006FE5                 push    edx             ; Dst
.text$mn:00006FE6                 call    _memcpy
.text$mn:00006FEB                 add     esp, 0Ch
.text$mn:00006FEE                 mov     eax, [ebp+arg_4]
.text$mn:00006FF1                 mov     esp, ebp
.text$mn:00006FF3                 pop     ebp
.text$mn:00006FF4                 retn    0Ch
.text$mn:00006FF4 ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z endp
.text$mn:00006FF4
.text$mn:00006FF4 ; ---------------------------------------------------------------------------
.text$mn:00006FF7                 align 4
.text$mn:00006FF7 _text$mn        ends
.text$mn:00006FF7
.text$mn:00006FF8 ; ===========================================================================
.text$mn:00006FF8
.text$mn:00006FF8 ; Segment type: Pure code
.text$mn:00006FF8 ; Segment permissions: Read/Execute
.text$mn:00006FF8 _text$mn        segment para public 'CODE' use32
.text$mn:00006FF8                 assume cs:_text$mn
.text$mn:00006FF8                 ;org 6FF8h
.text$mn:00006FF8 ; COMDAT (pick any)
.text$mn:00006FF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FF8
.text$mn:00006FF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FF8
.text$mn:00006FF8 ; Attributes: bp-based frame
.text$mn:00006FF8
.text$mn:00006FF8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::empty(void)const
.text$mn:00006FF8                 public ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
.text$mn:00006FF8 ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ proc near
.text$mn:00006FF8                                         ; CODE XREF: std::_System_error::_Makestr(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>>)+39p
.text$mn:00006FF8
.text$mn:00006FF8 var_8           = dword ptr -8
.text$mn:00006FF8 var_4           = dword ptr -4
.text$mn:00006FF8
.text$mn:00006FF8                 push    ebp
.text$mn:00006FF9                 mov     ebp, esp
.text$mn:00006FFB                 sub     esp, 8
.text$mn:00006FFE                 mov     [ebp+var_8], ecx
.text$mn:00007001                 mov     eax, [ebp+var_8]
.text$mn:00007004                 cmp     dword ptr [eax+14h], 0
.text$mn:00007008                 jnz     short loc_7013
.text$mn:0000700A                 mov     [ebp+var_4], 1
.text$mn:00007011                 jmp     short loc_701A
.text$mn:00007013 ; ---------------------------------------------------------------------------
.text$mn:00007013
.text$mn:00007013 loc_7013:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(void)+10j
.text$mn:00007013                 mov     [ebp+var_4], 0
.text$mn:0000701A
.text$mn:0000701A loc_701A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(void)+19j
.text$mn:0000701A                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000701D                 mov     esp, ebp
.text$mn:0000701F                 pop     ebp
.text$mn:00007020                 retn
.text$mn:00007020 ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ endp
.text$mn:00007020
.text$mn:00007020 ; ---------------------------------------------------------------------------
.text$mn:00007021                 align 4
.text$mn:00007021 _text$mn        ends
.text$mn:00007021
.text$mn:00007024 ; ===========================================================================
.text$mn:00007024
.text$mn:00007024 ; Segment type: Pure code
.text$mn:00007024 ; Segment permissions: Read/Execute
.text$mn:00007024 _text$mn        segment para public 'CODE' use32
.text$mn:00007024                 assume cs:_text$mn
.text$mn:00007024                 ;org 7024h
.text$mn:00007024 ; COMDAT (pick any)
.text$mn:00007024                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007024
.text$mn:00007024 ; =============== S U B R O U T I N E =======================================
.text$mn:00007024
.text$mn:00007024 ; Attributes: bp-based frame
.text$mn:00007024
.text$mn:00007024 ; public: static int __cdecl std::char_traits<char>::eof(void)
.text$mn:00007024                 public ?eof@?$char_traits@D@std@@SAHXZ
.text$mn:00007024 ?eof@?$char_traits@D@std@@SAHXZ proc near
.text$mn:00007024                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool):loc_6155p
.text$mn:00007024                                         ; std::basic_istream<char,std::char_traits<char>>::get(void)+72p ...
.text$mn:00007024                 push    ebp
.text$mn:00007025                 mov     ebp, esp
.text$mn:00007027                 or      eax, 0FFFFFFFFh
.text$mn:0000702A                 pop     ebp
.text$mn:0000702B                 retn
.text$mn:0000702B ?eof@?$char_traits@D@std@@SAHXZ endp
.text$mn:0000702B
.text$mn:0000702B _text$mn        ends
.text$mn:0000702B
.text$mn:0000702C ; ===========================================================================
.text$mn:0000702C
.text$mn:0000702C ; Segment type: Pure code
.text$mn:0000702C ; Segment permissions: Read/Execute
.text$mn:0000702C _text$mn        segment para public 'CODE' use32
.text$mn:0000702C                 assume cs:_text$mn
.text$mn:0000702C                 ;org 702Ch
.text$mn:0000702C ; COMDAT (pick any)
.text$mn:0000702C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000702C
.text$mn:0000702C ; =============== S U B R O U T I N E =======================================
.text$mn:0000702C
.text$mn:0000702C ; Attributes: bp-based frame
.text$mn:0000702C
.text$mn:0000702C ; public: static bool __cdecl std::char_traits<char>::eq_int_type(int const &, int const &)
.text$mn:0000702C                 public ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
.text$mn:0000702C ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z proc near
.text$mn:0000702C                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+12Dp
.text$mn:0000702C                                         ; std::basic_istream<char,std::char_traits<char>>::get(void)+AFp ...
.text$mn:0000702C
.text$mn:0000702C var_4           = dword ptr -4
.text$mn:0000702C arg_0           = dword ptr  8
.text$mn:0000702C arg_4           = dword ptr  0Ch
.text$mn:0000702C
.text$mn:0000702C                 push    ebp
.text$mn:0000702D                 mov     ebp, esp
.text$mn:0000702F                 push    ecx
.text$mn:00007030                 mov     eax, [ebp+arg_0]
.text$mn:00007033                 mov     ecx, [ebp+arg_4]
.text$mn:00007036                 mov     edx, [eax]
.text$mn:00007038                 cmp     edx, [ecx]
.text$mn:0000703A                 jnz     short loc_7045
.text$mn:0000703C                 mov     [ebp+var_4], 1
.text$mn:00007043                 jmp     short loc_704C
.text$mn:00007045 ; ---------------------------------------------------------------------------
.text$mn:00007045
.text$mn:00007045 loc_7045:                               ; CODE XREF: std::char_traits<char>::eq_int_type(int const &,int const &)+Ej
.text$mn:00007045                 mov     [ebp+var_4], 0
.text$mn:0000704C
.text$mn:0000704C loc_704C:                               ; CODE XREF: std::char_traits<char>::eq_int_type(int const &,int const &)+17j
.text$mn:0000704C                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000704F                 mov     esp, ebp
.text$mn:00007051                 pop     ebp
.text$mn:00007052                 retn
.text$mn:00007052 ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z endp
.text$mn:00007052
.text$mn:00007052 ; ---------------------------------------------------------------------------
.text$mn:00007053                 align 4
.text$mn:00007053 _text$mn        ends
.text$mn:00007053
.text$mn:00007054 ; ===========================================================================
.text$mn:00007054
.text$mn:00007054 ; Segment type: Pure code
.text$mn:00007054 ; Segment permissions: Read/Execute
.text$mn:00007054 _text$mn        segment para public 'CODE' use32
.text$mn:00007054                 assume cs:_text$mn
.text$mn:00007054                 ;org 7054h
.text$mn:00007054 ; COMDAT (pick any)
.text$mn:00007054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007054
.text$mn:00007054 ; =============== S U B R O U T I N E =======================================
.text$mn:00007054
.text$mn:00007054 ; Attributes: bp-based frame
.text$mn:00007054
.text$mn:00007054 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00007054                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00007054 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00007054                                         ; DATA XREF: .rdata:00008E24o
.text$mn:00007054                                         ; .rdata:00008E5Co ...
.text$mn:00007054
.text$mn:00007054 var_8           = dword ptr -8
.text$mn:00007054 var_4           = dword ptr -4
.text$mn:00007054 arg_0           = dword ptr  8
.text$mn:00007054 arg_4           = dword ptr  0Ch
.text$mn:00007054
.text$mn:00007054                 push    ebp
.text$mn:00007055                 mov     ebp, esp
.text$mn:00007057                 sub     esp, 8
.text$mn:0000705A                 mov     [ebp+var_8], ecx
.text$mn:0000705D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007060                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00007065                 push    eax
.text$mn:00007066                 mov     ecx, [ebp+var_8]
.text$mn:00007069                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000706E                 movzx   eax, al
.text$mn:00007071                 test    eax, eax
.text$mn:00007073                 jz      short loc_708B
.text$mn:00007075                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007078                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000707D                 cmp     eax, [ebp+arg_4]
.text$mn:00007080                 jnz     short loc_708B
.text$mn:00007082                 mov     [ebp+var_4], 1
.text$mn:00007089                 jmp     short loc_7092
.text$mn:0000708B ; ---------------------------------------------------------------------------
.text$mn:0000708B
.text$mn:0000708B loc_708B:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000708B                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000708B                 mov     [ebp+var_4], 0
.text$mn:00007092
.text$mn:00007092 loc_7092:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00007092                 mov     al, byte ptr [ebp+var_4]
.text$mn:00007095                 mov     esp, ebp
.text$mn:00007097                 pop     ebp
.text$mn:00007098                 retn    8
.text$mn:00007098 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00007098
.text$mn:00007098 ; ---------------------------------------------------------------------------
.text$mn:0000709B                 align 4
.text$mn:0000709B _text$mn        ends
.text$mn:0000709B
.text$mn:0000709C ; ===========================================================================
.text$mn:0000709C
.text$mn:0000709C ; Segment type: Pure code
.text$mn:0000709C ; Segment permissions: Read/Execute
.text$mn:0000709C _text$mn        segment para public 'CODE' use32
.text$mn:0000709C                 assume cs:_text$mn
.text$mn:0000709C                 ;org 709Ch
.text$mn:0000709C ; COMDAT (pick any)
.text$mn:0000709C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000709C
.text$mn:0000709C ; =============== S U B R O U T I N E =======================================
.text$mn:0000709C
.text$mn:0000709C ; Attributes: bp-based frame
.text$mn:0000709C
.text$mn:0000709C ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000709C                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000709C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000709C                                         ; DATA XREF: .rdata:00008E28o
.text$mn:0000709C                                         ; .rdata:00008E60o ...
.text$mn:0000709C
.text$mn:0000709C var_C           = byte ptr -0Ch
.text$mn:0000709C var_4           = dword ptr -4
.text$mn:0000709C arg_0           = dword ptr  8
.text$mn:0000709C arg_4           = dword ptr  0Ch
.text$mn:0000709C
.text$mn:0000709C                 push    ebp
.text$mn:0000709D                 mov     ebp, esp
.text$mn:0000709F                 sub     esp, 0Ch
.text$mn:000070A2                 mov     [ebp+var_4], ecx
.text$mn:000070A5                 mov     eax, [ebp+arg_4]
.text$mn:000070A8                 push    eax             ; std::error_condition *
.text$mn:000070A9                 mov     ecx, [ebp+arg_0]
.text$mn:000070AC                 push    ecx
.text$mn:000070AD                 lea     edx, [ebp+var_C]
.text$mn:000070B0                 push    edx
.text$mn:000070B1                 mov     eax, [ebp+var_4]
.text$mn:000070B4                 mov     edx, [eax]
.text$mn:000070B6                 mov     ecx, [ebp+var_4]
.text$mn:000070B9                 mov     eax, [edx+0Ch]
.text$mn:000070BC                 call    eax
.text$mn:000070BE                 mov     ecx, eax
.text$mn:000070C0                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000070C5                 mov     esp, ebp
.text$mn:000070C7                 pop     ebp
.text$mn:000070C8                 retn    8
.text$mn:000070C8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000070C8
.text$mn:000070C8 ; ---------------------------------------------------------------------------
.text$mn:000070CB                 align 4
.text$mn:000070CB _text$mn        ends
.text$mn:000070CB
.text$mn:000070CC ; ===========================================================================
.text$mn:000070CC
.text$mn:000070CC ; Segment type: Pure code
.text$mn:000070CC ; Segment permissions: Read/Execute
.text$mn:000070CC _text$mn        segment para public 'CODE' use32
.text$mn:000070CC                 assume cs:_text$mn
.text$mn:000070CC                 ;org 70CCh
.text$mn:000070CC ; COMDAT (pick any)
.text$mn:000070CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070CC
.text$mn:000070CC ; =============== S U B R O U T I N E =======================================
.text$mn:000070CC
.text$mn:000070CC ; Attributes: bp-based frame
.text$mn:000070CC
.text$mn:000070CC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000070CC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000070CC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000070CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000070CC
.text$mn:000070CC var_4           = dword ptr -4
.text$mn:000070CC arg_0           = dword ptr  8
.text$mn:000070CC
.text$mn:000070CC                 push    ebp
.text$mn:000070CD                 mov     ebp, esp
.text$mn:000070CF                 push    ecx
.text$mn:000070D0                 mov     [ebp+var_4], ecx
.text$mn:000070D3                 mov     eax, [ebp+var_4]
.text$mn:000070D6                 mov     ecx, [eax+14h]
.text$mn:000070D9                 cmp     ecx, [ebp+arg_0]
.text$mn:000070DC                 jnb     short loc_70E6
.text$mn:000070DE                 mov     ecx, [ebp+var_4]
.text$mn:000070E1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000070E6
.text$mn:000070E6 loc_70E6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000070E6                 mov     edx, [ebp+arg_0]
.text$mn:000070E9                 push    edx
.text$mn:000070EA                 mov     ecx, [ebp+var_4]
.text$mn:000070ED                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000070F2                 mov     eax, [ebp+var_4]
.text$mn:000070F5                 mov     esp, ebp
.text$mn:000070F7                 pop     ebp
.text$mn:000070F8                 retn    4
.text$mn:000070F8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000070F8
.text$mn:000070F8 ; ---------------------------------------------------------------------------
.text$mn:000070FB                 align 4
.text$mn:000070FB _text$mn        ends
.text$mn:000070FB
.text$mn:000070FC ; ===========================================================================
.text$mn:000070FC
.text$mn:000070FC ; Segment type: Pure code
.text$mn:000070FC ; Segment permissions: Read/Execute
.text$mn:000070FC _text$mn        segment para public 'CODE' use32
.text$mn:000070FC                 assume cs:_text$mn
.text$mn:000070FC                 ;org 70FCh
.text$mn:000070FC ; COMDAT (pick any)
.text$mn:000070FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070FC
.text$mn:000070FC ; =============== S U B R O U T I N E =======================================
.text$mn:000070FC
.text$mn:000070FC ; Attributes: bp-based frame
.text$mn:000070FC
.text$mn:000070FC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000070FC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000070FC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000070FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000070FC
.text$mn:000070FC var_C           = dword ptr -0Ch
.text$mn:000070FC Dst             = dword ptr -8
.text$mn:000070FC var_4           = dword ptr -4
.text$mn:000070FC arg_0           = dword ptr  8
.text$mn:000070FC arg_4           = dword ptr  0Ch
.text$mn:000070FC
.text$mn:000070FC                 push    ebp
.text$mn:000070FD                 mov     ebp, esp
.text$mn:000070FF                 sub     esp, 0Ch
.text$mn:00007102                 mov     [ebp+var_4], ecx
.text$mn:00007105                 mov     eax, [ebp+var_4]
.text$mn:00007108                 mov     ecx, [eax+14h]
.text$mn:0000710B                 cmp     ecx, [ebp+arg_0]
.text$mn:0000710E                 jnb     short loc_7118
.text$mn:00007110                 mov     ecx, [ebp+var_4]
.text$mn:00007113                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00007118
.text$mn:00007118 loc_7118:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00007118                 mov     edx, [ebp+var_4]
.text$mn:0000711B                 mov     eax, [edx+14h]
.text$mn:0000711E                 sub     eax, [ebp+arg_0]
.text$mn:00007121                 cmp     eax, [ebp+arg_4]
.text$mn:00007124                 ja      short loc_7134
.text$mn:00007126                 mov     ecx, [ebp+arg_0]
.text$mn:00007129                 push    ecx
.text$mn:0000712A                 mov     ecx, [ebp+var_4]
.text$mn:0000712D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007132                 jmp     short loc_717A
.text$mn:00007134 ; ---------------------------------------------------------------------------
.text$mn:00007134
.text$mn:00007134 loc_7134:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00007134                 cmp     [ebp+arg_4], 0
.text$mn:00007138                 jbe     short loc_717A
.text$mn:0000713A                 mov     ecx, [ebp+var_4]
.text$mn:0000713D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007142                 add     eax, [ebp+arg_0]
.text$mn:00007145                 mov     [ebp+Dst], eax
.text$mn:00007148                 mov     edx, [ebp+var_4]
.text$mn:0000714B                 mov     eax, [edx+14h]
.text$mn:0000714E                 sub     eax, [ebp+arg_4]
.text$mn:00007151                 mov     [ebp+var_C], eax
.text$mn:00007154                 mov     ecx, [ebp+var_C]
.text$mn:00007157                 sub     ecx, [ebp+arg_0]
.text$mn:0000715A                 push    ecx             ; Size
.text$mn:0000715B                 mov     edx, [ebp+Dst]
.text$mn:0000715E                 add     edx, [ebp+arg_4]
.text$mn:00007161                 push    edx             ; Src
.text$mn:00007162                 mov     eax, [ebp+Dst]
.text$mn:00007165                 push    eax             ; Dst
.text$mn:00007166                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000716B                 add     esp, 0Ch
.text$mn:0000716E                 mov     ecx, [ebp+var_C]
.text$mn:00007171                 push    ecx
.text$mn:00007172                 mov     ecx, [ebp+var_4]
.text$mn:00007175                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000717A
.text$mn:0000717A loc_717A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000717A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000717A                 mov     eax, [ebp+var_4]
.text$mn:0000717D                 mov     esp, ebp
.text$mn:0000717F                 pop     ebp
.text$mn:00007180                 retn    8
.text$mn:00007180 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00007180
.text$mn:00007180 ; ---------------------------------------------------------------------------
.text$mn:00007183                 align 4
.text$mn:00007183 _text$mn        ends
.text$mn:00007183
.text$mn:00007184 ; ===========================================================================
.text$mn:00007184
.text$mn:00007184 ; Segment type: Pure code
.text$mn:00007184 ; Segment permissions: Read/Execute
.text$mn:00007184 _text$mn        segment para public 'CODE' use32
.text$mn:00007184                 assume cs:_text$mn
.text$mn:00007184                 ;org 7184h
.text$mn:00007184 ; COMDAT (pick any)
.text$mn:00007184                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007184
.text$mn:00007184 ; =============== S U B R O U T I N E =======================================
.text$mn:00007184
.text$mn:00007184 ; Attributes: bp-based frame
.text$mn:00007184
.text$mn:00007184 ; int __thiscall std::ios_base::flags(std::ios_base *__hidden this)
.text$mn:00007184                 public ?flags@ios_base@std@@QBEHXZ
.text$mn:00007184 ?flags@ios_base@std@@QBEHXZ proc near   ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+90p
.text$mn:00007184                                         ; std::basic_ostream<char,std::char_traits<char>>::_Osfx(void)+58p
.text$mn:00007184
.text$mn:00007184 var_4           = dword ptr -4
.text$mn:00007184
.text$mn:00007184                 push    ebp
.text$mn:00007185                 mov     ebp, esp
.text$mn:00007187                 push    ecx
.text$mn:00007188                 mov     [ebp+var_4], ecx
.text$mn:0000718B                 mov     eax, [ebp+var_4]
.text$mn:0000718E                 mov     eax, [eax+14h]
.text$mn:00007191                 mov     esp, ebp
.text$mn:00007193                 pop     ebp
.text$mn:00007194                 retn
.text$mn:00007194 ?flags@ios_base@std@@QBEHXZ endp
.text$mn:00007194
.text$mn:00007194 ; ---------------------------------------------------------------------------
.text$mn:00007195                 align 4
.text$mn:00007195 _text$mn        ends
.text$mn:00007195
.text$mn:00007198 ; ===========================================================================
.text$mn:00007198
.text$mn:00007198 ; Segment type: Pure code
.text$mn:00007198 ; Segment permissions: Read/Execute
.text$mn:00007198 _text$mn        segment para public 'CODE' use32
.text$mn:00007198                 assume cs:_text$mn
.text$mn:00007198                 ;org 7198h
.text$mn:00007198 ; COMDAT (pick any)
.text$mn:00007198                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007198
.text$mn:00007198 ; =============== S U B R O U T I N E =======================================
.text$mn:00007198
.text$mn:00007198 ; Attributes: bp-based frame
.text$mn:00007198
.text$mn:00007198 ; public: class std::basic_ostream<char, struct std::char_traits<char>> & __thiscall std::basic_ostream<char, struct std::char_traits<char>>::flush(void)
.text$mn:00007198                 public ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
.text$mn:00007198 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ proc near
.text$mn:00007198                                         ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+8Fp
.text$mn:00007198                                         ; std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+74p
.text$mn:00007198
.text$mn:00007198 var_18          = byte ptr -18h
.text$mn:00007198 var_10          = dword ptr -10h
.text$mn:00007198 var_C           = dword ptr -0Ch
.text$mn:00007198 var_4           = dword ptr -4
.text$mn:00007198
.text$mn:00007198                 push    ebp
.text$mn:00007199                 mov     ebp, esp
.text$mn:0000719B                 push    0FFFFFFFFh
.text$mn:0000719D                 push    offset __ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
.text$mn:000071A2                 mov     eax, large fs:0
.text$mn:000071A8                 push    eax
.text$mn:000071A9                 sub     esp, 0Ch
.text$mn:000071AC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000071B1                 xor     eax, ebp
.text$mn:000071B3                 push    eax
.text$mn:000071B4                 lea     eax, [ebp+var_C]
.text$mn:000071B7                 mov     large fs:0, eax
.text$mn:000071BD                 mov     [ebp+var_10], ecx
.text$mn:000071C0                 mov     eax, [ebp+var_10]
.text$mn:000071C3                 mov     ecx, [eax]
.text$mn:000071C5                 mov     edx, [ebp+var_10]
.text$mn:000071C8                 add     edx, [ecx+4]
.text$mn:000071CB                 mov     ecx, edx
.text$mn:000071CD                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:000071D2                 test    eax, eax
.text$mn:000071D4                 jz      short loc_7237
.text$mn:000071D6                 mov     eax, [ebp+var_10]
.text$mn:000071D9                 push    eax
.text$mn:000071DA                 lea     ecx, [ebp+var_18]
.text$mn:000071DD                 call    ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)
.text$mn:000071E2                 mov     [ebp+var_4], 0
.text$mn:000071E9                 lea     ecx, [ebp+var_18]
.text$mn:000071EC                 call    ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char>>::sentry::operator bool(void)
.text$mn:000071F1                 movzx   ecx, al
.text$mn:000071F4                 test    ecx, ecx
.text$mn:000071F6                 jz      short loc_7228
.text$mn:000071F8                 mov     edx, [ebp+var_10]
.text$mn:000071FB                 mov     eax, [edx]
.text$mn:000071FD                 mov     ecx, [ebp+var_10]
.text$mn:00007200                 add     ecx, [eax+4]
.text$mn:00007203                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00007208                 mov     ecx, eax
.text$mn:0000720A                 call    ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::pubsync(void)
.text$mn:0000720F                 cmp     eax, 0FFFFFFFFh
.text$mn:00007212                 jnz     short loc_7228
.text$mn:00007214                 push    0
.text$mn:00007216                 push    4
.text$mn:00007218                 mov     ecx, [ebp+var_10]
.text$mn:0000721B                 mov     edx, [ecx]
.text$mn:0000721D                 mov     ecx, [ebp+var_10]
.text$mn:00007220                 add     ecx, [edx+4]
.text$mn:00007223                 call    ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
.text$mn:00007228
.text$mn:00007228 loc_7228:                               ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::flush(void)+5Ej
.text$mn:00007228                                         ; std::basic_ostream<char,std::char_traits<char>>::flush(void)+7Aj
.text$mn:00007228                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000722F                 lea     ecx, [ebp+var_18]
.text$mn:00007232                 call    ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)
.text$mn:00007237
.text$mn:00007237 loc_7237:                               ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::flush(void)+3Cj
.text$mn:00007237                 mov     eax, [ebp+var_10]
.text$mn:0000723A                 mov     ecx, [ebp+var_C]
.text$mn:0000723D                 mov     large fs:0, ecx
.text$mn:00007244                 pop     ecx
.text$mn:00007245                 mov     esp, ebp
.text$mn:00007247                 pop     ebp
.text$mn:00007248                 retn
.text$mn:00007248 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ endp
.text$mn:00007248
.text$mn:00007248 ; ---------------------------------------------------------------------------
.text$mn:00007249                 align 4
.text$mn:00007249 _text$mn        ends
.text$mn:00007249
.text$x:0000724C ; ===========================================================================
.text$x:0000724C
.text$x:0000724C ; Segment type: Pure code
.text$x:0000724C ; Segment permissions: Read/Execute
.text$x:0000724C _text$x         segment para public 'CODE' use32
.text$x:0000724C                 assume cs:_text$x
.text$x:0000724C                 ;org 724Ch
.text$x:0000724C ; COMDAT (pick associative to section at 7198)
.text$x:0000724C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000724C
.text$x:0000724C ; =============== S U B R O U T I N E =======================================
.text$x:0000724C
.text$x:0000724C
.text$x:0000724C __unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0 proc near
.text$x:0000724C                                         ; DATA XREF: .xdata$x:00008808o
.text$x:0000724C                 lea     ecx, [ebp-18h]
.text$x:0000724F                 jmp     ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)
.text$x:0000724F __unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0 endp
.text$x:0000724F
.text$x:00007254
.text$x:00007254 ; =============== S U B R O U T I N E =======================================
.text$x:00007254
.text$x:00007254
.text$x:00007254 __ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ proc near
.text$x:00007254                                         ; DATA XREF: std::basic_ostream<char,std::char_traits<char>>::flush(void)+5o
.text$x:00007254
.text$x:00007254 arg_4           = dword ptr  8
.text$x:00007254
.text$x:00007254                 mov     edx, [esp+arg_4]
.text$x:00007258                 lea     eax, [edx+0Ch]
.text$x:0000725B                 mov     ecx, [edx-10h]
.text$x:0000725E                 xor     ecx, eax
.text$x:00007260                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007265                 mov     eax, offset __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
.text$x:0000726A                 jmp     ___CxxFrameHandler3
.text$x:0000726A __ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ endp
.text$x:0000726A
.text$x:0000726A ; ---------------------------------------------------------------------------
.text$x:0000726F                 align 10h
.text$x:0000726F _text$x         ends
.text$x:0000726F
.text$mn:00007270 ; ===========================================================================
.text$mn:00007270
.text$mn:00007270 ; Segment type: Pure code
.text$mn:00007270 ; Segment permissions: Read/Execute
.text$mn:00007270 _text$mn        segment para public 'CODE' use32
.text$mn:00007270                 assume cs:_text$mn
.text$mn:00007270                 ;org 7270h
.text$mn:00007270 ; COMDAT (pick any)
.text$mn:00007270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007270
.text$mn:00007270 ; =============== S U B R O U T I N E =======================================
.text$mn:00007270
.text$mn:00007270 ; Attributes: bp-based frame
.text$mn:00007270
.text$mn:00007270 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00007270                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00007270 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00007270                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00007270                 push    ebp
.text$mn:00007271                 mov     ebp, esp
.text$mn:00007273                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00007278                 pop     ebp
.text$mn:00007279                 retn
.text$mn:00007279 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00007279
.text$mn:00007279 ; ---------------------------------------------------------------------------
.text$mn:0000727A                 align 4
.text$mn:0000727A _text$mn        ends
.text$mn:0000727A
.text$mn:0000727C ; ===========================================================================
.text$mn:0000727C
.text$mn:0000727C ; Segment type: Pure code
.text$mn:0000727C ; Segment permissions: Read/Execute
.text$mn:0000727C _text$mn        segment para public 'CODE' use32
.text$mn:0000727C                 assume cs:_text$mn
.text$mn:0000727C                 ;org 727Ch
.text$mn:0000727C ; COMDAT (pick any)
.text$mn:0000727C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000727C
.text$mn:0000727C ; =============== S U B R O U T I N E =======================================
.text$mn:0000727C
.text$mn:0000727C ; Attributes: bp-based frame
.text$mn:0000727C
.text$mn:0000727C ; public: int __thiscall std::basic_istream<char, struct std::char_traits<char>>::get(void)
.text$mn:0000727C                 public ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:0000727C ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ proc near
.text$mn:0000727C                                         ; CODE XREF: TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+46p
.text$mn:0000727C                                         ; TiXmlBaseA::StreamTo(std::basic_istream<char,std::char_traits<char>> *,int,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+37p ...
.text$mn:0000727C
.text$mn:0000727C var_2C          = byte ptr -2Ch
.text$mn:0000727C var_24          = dword ptr -24h
.text$mn:0000727C var_20          = dword ptr -20h
.text$mn:0000727C var_1C          = dword ptr -1Ch
.text$mn:0000727C var_18          = dword ptr -18h
.text$mn:0000727C var_14          = dword ptr -14h
.text$mn:0000727C var_10          = dword ptr -10h
.text$mn:0000727C var_C           = dword ptr -0Ch
.text$mn:0000727C var_4           = dword ptr -4
.text$mn:0000727C
.text$mn:0000727C ; FUNCTION CHUNK AT .text$mn:00007390 SIZE 00000009 BYTES
.text$mn:0000727C ; FUNCTION CHUNK AT .text$mn:000073A0 SIZE 00000040 BYTES
.text$mn:0000727C
.text$mn:0000727C                 push    ebp
.text$mn:0000727D                 mov     ebp, esp
.text$mn:0000727F                 push    0FFFFFFFFh
.text$mn:00007281                 push    offset __ehhandler$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007286                 mov     eax, large fs:0
.text$mn:0000728C                 push    eax
.text$mn:0000728D                 push    ecx
.text$mn:0000728E                 sub     esp, 1Ch
.text$mn:00007291                 push    ebx
.text$mn:00007292                 push    esi
.text$mn:00007293                 push    edi
.text$mn:00007294                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007299                 xor     eax, ebp
.text$mn:0000729B                 push    eax
.text$mn:0000729C                 lea     eax, [ebp+var_C]
.text$mn:0000729F                 mov     large fs:0, eax
.text$mn:000072A5                 mov     [ebp+var_10], esp
.text$mn:000072A8                 mov     [ebp+var_14], ecx
.text$mn:000072AB                 mov     [ebp+var_18], 0
.text$mn:000072B2                 mov     [ebp+var_1C], 0
.text$mn:000072B9                 mov     eax, [ebp+var_14]
.text$mn:000072BC                 mov     dword ptr [eax+8], 0
.text$mn:000072C3                 mov     dword ptr [eax+0Ch], 0
.text$mn:000072CA                 push    1
.text$mn:000072CC                 mov     ecx, [ebp+var_14]
.text$mn:000072CF                 push    ecx
.text$mn:000072D0                 lea     ecx, [ebp+var_2C]
.text$mn:000072D3                 call    ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char>>::sentry::sentry(std::basic_istream<char,std::char_traits<char>> &,bool)
.text$mn:000072D8                 mov     [ebp+var_4], 0
.text$mn:000072DF                 lea     ecx, [ebp+var_2C]
.text$mn:000072E2                 call    ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char>>::sentry::operator bool(void)
.text$mn:000072E7                 movzx   edx, al
.text$mn:000072EA                 test    edx, edx
.text$mn:000072EC                 jnz     short loc_72FB
.text$mn:000072EE                 call    ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof(void)
.text$mn:000072F3                 mov     [ebp+var_18], eax
.text$mn:000072F6                 jmp     loc_73A0
.text$mn:000072FB ; ---------------------------------------------------------------------------
.text$mn:000072FB
.text$mn:000072FB loc_72FB:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::get(void)+70j
.text$mn:000072FB                 mov     byte ptr [ebp+var_4], 1
.text$mn:000072FF                 mov     eax, [ebp+var_14]
.text$mn:00007302                 mov     ecx, [eax]
.text$mn:00007304                 mov     edx, [ebp+var_14]
.text$mn:00007307                 add     edx, [ecx+4]
.text$mn:0000730A                 mov     ecx, edx
.text$mn:0000730C                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00007311                 mov     ecx, eax
.text$mn:00007313                 call    ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)
.text$mn:00007318                 mov     [ebp+var_18], eax
.text$mn:0000731B                 call    ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof(void)
.text$mn:00007320                 mov     [ebp+var_20], eax
.text$mn:00007323                 lea     eax, [ebp+var_18]
.text$mn:00007326                 push    eax
.text$mn:00007327                 lea     ecx, [ebp+var_20]
.text$mn:0000732A                 push    ecx
.text$mn:0000732B                 call    ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
.text$mn:00007330                 add     esp, 8
.text$mn:00007333                 movzx   edx, al
.text$mn:00007336                 test    edx, edx
.text$mn:00007338                 jz      short loc_7345
.text$mn:0000733A                 mov     eax, [ebp+var_1C]
.text$mn:0000733D                 or      eax, 3
.text$mn:00007340                 mov     [ebp+var_1C], eax
.text$mn:00007343                 jmp     short loc_7374
.text$mn:00007345 ; ---------------------------------------------------------------------------
.text$mn:00007345
.text$mn:00007345 loc_7345:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::get(void)+BCj
.text$mn:00007345                 mov     ecx, [ebp+var_14]
.text$mn:00007348                 mov     edx, [ecx]
.text$mn:0000734A                 mov     ecx, [ebp+var_14]
.text$mn:0000734D                 add     ecx, [edx+4]
.text$mn:00007350                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:00007355                 mov     ecx, eax
.text$mn:00007357                 call    ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::sbumpc(void)
.text$mn:0000735C                 mov     eax, [ebp+var_14]
.text$mn:0000735F                 mov     ecx, [eax+8]
.text$mn:00007362                 add     ecx, 1
.text$mn:00007365                 mov     edx, [eax+0Ch]
.text$mn:00007368                 adc     edx, 0
.text$mn:0000736B                 mov     eax, [ebp+var_14]
.text$mn:0000736E                 mov     [eax+8], ecx
.text$mn:00007371                 mov     [eax+0Ch], edx
.text$mn:00007374
.text$mn:00007374 loc_7374:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::get(void)+C7j
.text$mn:00007374                 jmp     short loc_7390
.text$mn:00007374 ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ endp
.text$mn:00007374
.text$mn:00007376
.text$mn:00007376 ; =============== S U B R O U T I N E =======================================
.text$mn:00007376
.text$mn:00007376
.text$mn:00007376 __catch$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$0 proc near
.text$mn:00007376                                         ; DATA XREF: .xdata$x:000086A0o
.text$mn:00007376                 push    1
.text$mn:00007378                 push    4
.text$mn:0000737A                 mov     ecx, [ebp-14h]
.text$mn:0000737D                 mov     edx, [ecx]
.text$mn:0000737F                 mov     ecx, [ebp-14h]
.text$mn:00007382                 add     ecx, [edx+4]
.text$mn:00007385                 call    ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
.text$mn:0000738A                 mov     eax, offset $LN12
.text$mn:0000738F                 retn
.text$mn:0000738F __catch$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$0 endp
.text$mn:0000738F
.text$mn:00007390 ; ---------------------------------------------------------------------------
.text$mn:00007390 ; START OF FUNCTION CHUNK FOR ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007390
.text$mn:00007390 loc_7390:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::get(void):loc_7374j
.text$mn:00007390                 mov     [ebp+var_4], 0
.text$mn:00007397                 jmp     short loc_73A0
.text$mn:00007397 ; END OF FUNCTION CHUNK FOR ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007399
.text$mn:00007399 ; =============== S U B R O U T I N E =======================================
.text$mn:00007399
.text$mn:00007399
.text$mn:00007399 $LN12           proc near               ; DATA XREF: __catch$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$0+14o
.text$mn:00007399                 mov     dword ptr [ebp-4], 0
.text$mn:00007399 $LN12           endp ; sp-analysis failed
.text$mn:00007399
.text$mn:000073A0 ; START OF FUNCTION CHUNK FOR ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:000073A0
.text$mn:000073A0 loc_73A0:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::get(void)+7Aj
.text$mn:000073A0                                         ; std::basic_istream<char,std::char_traits<char>>::get(void)+11Bj
.text$mn:000073A0                 push    0
.text$mn:000073A2                 mov     eax, [ebp+var_1C]
.text$mn:000073A5                 push    eax
.text$mn:000073A6                 mov     ecx, [ebp+var_14]
.text$mn:000073A9                 mov     edx, [ecx]
.text$mn:000073AB                 mov     ecx, [ebp+var_14]
.text$mn:000073AE                 add     ecx, [edx+4]
.text$mn:000073B1                 call    ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
.text$mn:000073B6                 mov     eax, [ebp+var_18]
.text$mn:000073B9                 mov     [ebp+var_24], eax
.text$mn:000073BC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000073C3                 lea     ecx, [ebp+var_2C]
.text$mn:000073C6                 call    ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char>>::sentry::~sentry(void)
.text$mn:000073CB                 mov     eax, [ebp+var_24]
.text$mn:000073CE                 mov     ecx, [ebp+var_C]
.text$mn:000073D1                 mov     large fs:0, ecx
.text$mn:000073D8                 pop     ecx
.text$mn:000073D9                 pop     edi
.text$mn:000073DA                 pop     esi
.text$mn:000073DB                 pop     ebx
.text$mn:000073DC                 mov     esp, ebp
.text$mn:000073DE                 pop     ebp
.text$mn:000073DF                 retn
.text$mn:000073DF ; END OF FUNCTION CHUNK FOR ?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:000073DF _text$mn        ends
.text$mn:000073DF
.text$x:000073E0 ; ===========================================================================
.text$x:000073E0
.text$x:000073E0 ; Segment type: Pure code
.text$x:000073E0 ; Segment permissions: Read/Execute
.text$x:000073E0 _text$x         segment para public 'CODE' use32
.text$x:000073E0                 assume cs:_text$x
.text$x:000073E0                 ;org 73E0h
.text$x:000073E0 ; COMDAT (pick associative to section at 727C)
.text$x:000073E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000073E0
.text$x:000073E0 ; =============== S U B R O U T I N E =======================================
.text$x:000073E0
.text$x:000073E0
.text$x:000073E0 __unwindfunclet$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$2 proc near
.text$x:000073E0                                         ; DATA XREF: .xdata$x:000086BCo
.text$x:000073E0                 lea     ecx, [ebp-2Ch]
.text$x:000073E3                 jmp     ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char>>::sentry::~sentry(void)
.text$x:000073E3 __unwindfunclet$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$2 endp
.text$x:000073E3
.text$x:000073E8
.text$x:000073E8 ; =============== S U B R O U T I N E =======================================
.text$x:000073E8
.text$x:000073E8
.text$x:000073E8 __ehhandler$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ proc near
.text$x:000073E8                                         ; DATA XREF: std::basic_istream<char,std::char_traits<char>>::get(void)+5o
.text$x:000073E8
.text$x:000073E8 arg_4           = dword ptr  8
.text$x:000073E8
.text$x:000073E8                 mov     edx, [esp+arg_4]
.text$x:000073EC                 lea     eax, [edx+0Ch]
.text$x:000073EF                 mov     ecx, [edx-30h]
.text$x:000073F2                 xor     ecx, eax
.text$x:000073F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000073F9                 mov     eax, offset __ehfuncinfo$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$x:000073FE                 jmp     ___CxxFrameHandler3
.text$x:000073FE __ehhandler$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ endp
.text$x:000073FE
.text$x:000073FE ; ---------------------------------------------------------------------------
.text$x:00007403                 align 4
.text$x:00007403 _text$x         ends
.text$x:00007403
.text$mn:00007404 ; ===========================================================================
.text$mn:00007404
.text$mn:00007404 ; Segment type: Pure code
.text$mn:00007404 ; Segment permissions: Read/Execute
.text$mn:00007404 _text$mn        segment para public 'CODE' use32
.text$mn:00007404                 assume cs:_text$mn
.text$mn:00007404                 ;org 7404h
.text$mn:00007404 ; COMDAT (pick any)
.text$mn:00007404                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007404
.text$mn:00007404 ; =============== S U B R O U T I N E =======================================
.text$mn:00007404
.text$mn:00007404 ; Attributes: bp-based frame
.text$mn:00007404
.text$mn:00007404 ; public: class std::locale __thiscall std::ios_base::getloc(void)const
.text$mn:00007404                 public ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
.text$mn:00007404 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ proc near
.text$mn:00007404                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+ADp
.text$mn:00007404
.text$mn:00007404 var_14          = dword ptr -14h
.text$mn:00007404 var_10          = dword ptr -10h
.text$mn:00007404 var_C           = dword ptr -0Ch
.text$mn:00007404 var_4           = dword ptr -4
.text$mn:00007404 arg_0           = dword ptr  8
.text$mn:00007404
.text$mn:00007404                 push    ebp
.text$mn:00007405                 mov     ebp, esp
.text$mn:00007407                 push    0FFFFFFFFh
.text$mn:00007409                 push    offset __ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
.text$mn:0000740E                 mov     eax, large fs:0
.text$mn:00007414                 push    eax
.text$mn:00007415                 sub     esp, 8
.text$mn:00007418                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000741D                 xor     eax, ebp
.text$mn:0000741F                 push    eax
.text$mn:00007420                 lea     eax, [ebp+var_C]
.text$mn:00007423                 mov     large fs:0, eax
.text$mn:00007429                 mov     [ebp+var_14], ecx
.text$mn:0000742C                 mov     [ebp+var_10], 0
.text$mn:00007433                 mov     eax, [ebp+var_14]
.text$mn:00007436                 mov     ecx, [eax+30h]
.text$mn:00007439                 push    ecx             ; struct std::locale *
.text$mn:0000743A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000743D                 call    ??0locale@std@@QAE@ABV01@@Z ; std::locale::locale(std::locale const &)
.text$mn:00007442                 mov     [ebp+var_4], 0
.text$mn:00007449                 mov     edx, [ebp+var_10]
.text$mn:0000744C                 or      edx, 1
.text$mn:0000744F                 mov     [ebp+var_10], edx
.text$mn:00007452                 mov     eax, [ebp+arg_0]
.text$mn:00007455                 mov     ecx, [ebp+var_C]
.text$mn:00007458                 mov     large fs:0, ecx
.text$mn:0000745F                 pop     ecx
.text$mn:00007460                 mov     esp, ebp
.text$mn:00007462                 pop     ebp
.text$mn:00007463                 retn    4
.text$mn:00007463 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ endp
.text$mn:00007463
.text$mn:00007463 ; ---------------------------------------------------------------------------
.text$mn:00007466                 align 4
.text$mn:00007466 _text$mn        ends
.text$mn:00007466
.text$x:00007468 ; ===========================================================================
.text$x:00007468
.text$x:00007468 ; Segment type: Pure code
.text$x:00007468 ; Segment permissions: Read/Execute
.text$x:00007468 _text$x         segment para public 'CODE' use32
.text$x:00007468                 assume cs:_text$x
.text$x:00007468                 ;org 7468h
.text$x:00007468 ; COMDAT (pick associative to section at 7404)
.text$x:00007468                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007468
.text$x:00007468 ; =============== S U B R O U T I N E =======================================
.text$x:00007468
.text$x:00007468
.text$x:00007468 __unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$0 proc near
.text$x:00007468                                         ; DATA XREF: .xdata$x:0000860Co
.text$x:00007468                 mov     eax, [ebp-10h]
.text$x:0000746B                 and     eax, 1
.text$x:0000746E                 jz      $LN4_0
.text$x:00007474                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00007478                 mov     ecx, [ebp+8]    ; this
.text$x:0000747B                 jmp     ??1locale@std@@QAE@XZ ; std::locale::~locale(void)
.text$x:00007480 ; ---------------------------------------------------------------------------
.text$x:00007480
.text$x:00007480 $LN4_0:                                 ; CODE XREF: __unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$0+6j
.text$x:00007480                 retn
.text$x:00007480 __unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$0 endp
.text$x:00007480
.text$x:00007481
.text$x:00007481 ; =============== S U B R O U T I N E =======================================
.text$x:00007481
.text$x:00007481
.text$x:00007481 __ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ proc near
.text$x:00007481                                         ; DATA XREF: std::ios_base::getloc(void)+5o
.text$x:00007481
.text$x:00007481 arg_4           = dword ptr  8
.text$x:00007481
.text$x:00007481                 mov     edx, [esp+arg_4]
.text$x:00007485                 lea     eax, [edx+0Ch]
.text$x:00007488                 mov     ecx, [edx-0Ch]
.text$x:0000748B                 xor     ecx, eax
.text$x:0000748D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007492                 mov     eax, offset __ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
.text$x:00007497                 jmp     ___CxxFrameHandler3
.text$x:00007497 __ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ endp
.text$x:00007497
.text$x:00007497 _text$x         ends
.text$x:00007497
.text$mn:0000749C ; ===========================================================================
.text$mn:0000749C
.text$mn:0000749C ; Segment type: Pure code
.text$mn:0000749C ; Segment permissions: Read/Execute
.text$mn:0000749C _text$mn        segment para public 'CODE' use32
.text$mn:0000749C                 assume cs:_text$mn
.text$mn:0000749C                 ;org 749Ch
.text$mn:0000749C ; COMDAT (pick any)
.text$mn:0000749C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000749C
.text$mn:0000749C ; =============== S U B R O U T I N E =======================================
.text$mn:0000749C
.text$mn:0000749C ; Attributes: bp-based frame
.text$mn:0000749C
.text$mn:0000749C ; bool __thiscall std::ios_base::good(std::ios_base *__hidden this)
.text$mn:0000749C                 public ?good@ios_base@std@@QBE_NXZ
.text$mn:0000749C ?good@ios_base@std@@QBE_NXZ proc near   ; CODE XREF: TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+11p
.text$mn:0000749C                                         ; TiXmlBaseA::StreamTo(std::basic_istream<char,std::char_traits<char>> *,int,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+11p ...
.text$mn:0000749C
.text$mn:0000749C var_8           = dword ptr -8
.text$mn:0000749C var_4           = dword ptr -4
.text$mn:0000749C
.text$mn:0000749C                 push    ebp
.text$mn:0000749D                 mov     ebp, esp
.text$mn:0000749F                 sub     esp, 8
.text$mn:000074A2                 mov     [ebp+var_8], ecx
.text$mn:000074A5                 mov     ecx, [ebp+var_8] ; this
.text$mn:000074A8                 call    ?rdstate@ios_base@std@@QBEHXZ ; std::ios_base::rdstate(void)
.text$mn:000074AD                 test    eax, eax
.text$mn:000074AF                 jnz     short loc_74BA
.text$mn:000074B1                 mov     [ebp+var_4], 1
.text$mn:000074B8                 jmp     short loc_74C1
.text$mn:000074BA ; ---------------------------------------------------------------------------
.text$mn:000074BA
.text$mn:000074BA loc_74BA:                               ; CODE XREF: std::ios_base::good(void)+13j
.text$mn:000074BA                 mov     [ebp+var_4], 0
.text$mn:000074C1
.text$mn:000074C1 loc_74C1:                               ; CODE XREF: std::ios_base::good(void)+1Cj
.text$mn:000074C1                 mov     al, byte ptr [ebp+var_4]
.text$mn:000074C4                 mov     esp, ebp
.text$mn:000074C6                 pop     ebp
.text$mn:000074C7                 retn
.text$mn:000074C7 ?good@ios_base@std@@QBE_NXZ endp
.text$mn:000074C7
.text$mn:000074C7 _text$mn        ends
.text$mn:000074C7
.text$mn:000074C8 ; ===========================================================================
.text$mn:000074C8
.text$mn:000074C8 ; Segment type: Pure code
.text$mn:000074C8 ; Segment permissions: Read/Execute
.text$mn:000074C8 _text$mn        segment para public 'CODE' use32
.text$mn:000074C8                 assume cs:_text$mn
.text$mn:000074C8                 ;org 74C8h
.text$mn:000074C8 ; COMDAT (pick any)
.text$mn:000074C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074C8
.text$mn:000074C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000074C8
.text$mn:000074C8 ; Attributes: bp-based frame
.text$mn:000074C8
.text$mn:000074C8 ; protected: char * __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::gptr(void)const
.text$mn:000074C8                 public ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
.text$mn:000074C8 ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ proc near
.text$mn:000074C8                                         ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)+28p
.text$mn:000074C8
.text$mn:000074C8 var_4           = dword ptr -4
.text$mn:000074C8
.text$mn:000074C8                 push    ebp
.text$mn:000074C9                 mov     ebp, esp
.text$mn:000074CB                 push    ecx
.text$mn:000074CC                 mov     [ebp+var_4], ecx
.text$mn:000074CF                 mov     eax, [ebp+var_4]
.text$mn:000074D2                 mov     ecx, [eax+1Ch]
.text$mn:000074D5                 mov     eax, [ecx]
.text$mn:000074D7                 mov     esp, ebp
.text$mn:000074D9                 pop     ebp
.text$mn:000074DA                 retn
.text$mn:000074DA ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ endp
.text$mn:000074DA
.text$mn:000074DA ; ---------------------------------------------------------------------------
.text$mn:000074DB                 align 4
.text$mn:000074DB _text$mn        ends
.text$mn:000074DB
.text$mn:000074DC ; ===========================================================================
.text$mn:000074DC
.text$mn:000074DC ; Segment type: Pure code
.text$mn:000074DC ; Segment permissions: Read/Execute
.text$mn:000074DC _text$mn        segment para public 'CODE' use32
.text$mn:000074DC                 assume cs:_text$mn
.text$mn:000074DC                 ;org 74DCh
.text$mn:000074DC ; COMDAT (pick any)
.text$mn:000074DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074DC
.text$mn:000074DC ; =============== S U B R O U T I N E =======================================
.text$mn:000074DC
.text$mn:000074DC ; Attributes: bp-based frame
.text$mn:000074DC
.text$mn:000074DC ; const struct std::error_category *__cdecl std::iostream_category()
.text$mn:000074DC                 public ?iostream_category@std@@YAABVerror_category@1@XZ
.text$mn:000074DC ?iostream_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000074DC                                         ; CODE XREF: std::make_error_code(std::io_errc)+3p
.text$mn:000074DC                 push    ebp
.text$mn:000074DD                 mov     ebp, esp
.text$mn:000074DF                 mov     eax, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.text$mn:000074E4                 pop     ebp
.text$mn:000074E5                 retn
.text$mn:000074E5 ?iostream_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000074E5
.text$mn:000074E5 ; ---------------------------------------------------------------------------
.text$mn:000074E6                 align 4
.text$mn:000074E6 _text$mn        ends
.text$mn:000074E6
.text$mn:000074E8 ; ===========================================================================
.text$mn:000074E8
.text$mn:000074E8 ; Segment type: Pure code
.text$mn:000074E8 ; Segment permissions: Read/Execute
.text$mn:000074E8 _text$mn        segment para public 'CODE' use32
.text$mn:000074E8                 assume cs:_text$mn
.text$mn:000074E8                 ;org 74E8h
.text$mn:000074E8 ; COMDAT (pick any)
.text$mn:000074E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074E8
.text$mn:000074E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000074E8
.text$mn:000074E8 ; Attributes: bp-based frame
.text$mn:000074E8
.text$mn:000074E8 ; public: bool __thiscall std::ctype<char>::is(short, char)const
.text$mn:000074E8                 public ?is@?$ctype@D@std@@QBE_NFD@Z
.text$mn:000074E8 ?is@?$ctype@D@std@@QBE_NFD@Z proc near  ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+16Bp
.text$mn:000074E8
.text$mn:000074E8 var_8           = dword ptr -8
.text$mn:000074E8 var_4           = dword ptr -4
.text$mn:000074E8 arg_0           = word ptr  8
.text$mn:000074E8 arg_4           = byte ptr  0Ch
.text$mn:000074E8
.text$mn:000074E8                 push    ebp
.text$mn:000074E9                 mov     ebp, esp
.text$mn:000074EB                 sub     esp, 8
.text$mn:000074EE                 mov     [ebp+var_8], ecx
.text$mn:000074F1                 movzx   eax, [ebp+arg_4]
.text$mn:000074F5                 mov     ecx, [ebp+var_8]
.text$mn:000074F8                 mov     edx, [ecx+0Ch]
.text$mn:000074FB                 movsx   eax, word ptr [edx+eax*2]
.text$mn:000074FF                 movsx   ecx, [ebp+arg_0]
.text$mn:00007503                 and     eax, ecx
.text$mn:00007505                 jz      short loc_7510
.text$mn:00007507                 mov     [ebp+var_4], 1
.text$mn:0000750E                 jmp     short loc_7517
.text$mn:00007510 ; ---------------------------------------------------------------------------
.text$mn:00007510
.text$mn:00007510 loc_7510:                               ; CODE XREF: std::ctype<char>::is(short,char)+1Dj
.text$mn:00007510                 mov     [ebp+var_4], 0
.text$mn:00007517
.text$mn:00007517 loc_7517:                               ; CODE XREF: std::ctype<char>::is(short,char)+26j
.text$mn:00007517                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000751A                 mov     esp, ebp
.text$mn:0000751C                 pop     ebp
.text$mn:0000751D                 retn    8
.text$mn:0000751D ?is@?$ctype@D@std@@QBE_NFD@Z endp
.text$mn:0000751D
.text$mn:0000751D _text$mn        ends
.text$mn:0000751D
.text$mn:00007520 ; ===========================================================================
.text$mn:00007520
.text$mn:00007520 ; Segment type: Pure code
.text$mn:00007520 ; Segment permissions: Read/Execute
.text$mn:00007520 _text$mn        segment para public 'CODE' use32
.text$mn:00007520                 assume cs:_text$mn
.text$mn:00007520                 ;org 7520h
.text$mn:00007520 ; COMDAT (pick any)
.text$mn:00007520                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007520
.text$mn:00007520 ; =============== S U B R O U T I N E =======================================
.text$mn:00007520
.text$mn:00007520 ; Attributes: bp-based frame
.text$mn:00007520
.text$mn:00007520 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::length(void)const
.text$mn:00007520                 public ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00007520 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00007520                                         ; CODE XREF: TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+69p
.text$mn:00007520                                         ; TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+7Bp ...
.text$mn:00007520
.text$mn:00007520 var_4           = dword ptr -4
.text$mn:00007520
.text$mn:00007520                 push    ebp
.text$mn:00007521                 mov     ebp, esp
.text$mn:00007523                 push    ecx
.text$mn:00007524                 mov     [ebp+var_4], ecx
.text$mn:00007527                 mov     eax, [ebp+var_4]
.text$mn:0000752A                 mov     eax, [eax+14h]
.text$mn:0000752D                 mov     esp, ebp
.text$mn:0000752F                 pop     ebp
.text$mn:00007530                 retn
.text$mn:00007530 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00007530
.text$mn:00007530 ; ---------------------------------------------------------------------------
.text$mn:00007531                 align 4
.text$mn:00007531 _text$mn        ends
.text$mn:00007531
.text$mn:00007534 ; ===========================================================================
.text$mn:00007534
.text$mn:00007534 ; Segment type: Pure code
.text$mn:00007534 ; Segment permissions: Read/Execute
.text$mn:00007534 _text$mn        segment para public 'CODE' use32
.text$mn:00007534                 assume cs:_text$mn
.text$mn:00007534                 ;org 7534h
.text$mn:00007534 ; COMDAT (pick any)
.text$mn:00007534                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007534
.text$mn:00007534 ; =============== S U B R O U T I N E =======================================
.text$mn:00007534
.text$mn:00007534 ; Attributes: bp-based frame
.text$mn:00007534
.text$mn:00007534 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00007534                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00007534 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00007534                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *)+21p
.text$mn:00007534                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00007534
.text$mn:00007534 var_4           = dword ptr -4
.text$mn:00007534 Str             = dword ptr  8
.text$mn:00007534
.text$mn:00007534                 push    ebp
.text$mn:00007535                 mov     ebp, esp
.text$mn:00007537                 push    ecx
.text$mn:00007538                 mov     eax, [ebp+Str]
.text$mn:0000753B                 movsx   ecx, byte ptr [eax]
.text$mn:0000753E                 test    ecx, ecx
.text$mn:00007540                 jnz     short loc_754B
.text$mn:00007542                 mov     [ebp+var_4], 0
.text$mn:00007549                 jmp     short loc_755A
.text$mn:0000754B ; ---------------------------------------------------------------------------
.text$mn:0000754B
.text$mn:0000754B loc_754B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000754B                 mov     edx, [ebp+Str]
.text$mn:0000754E                 push    edx             ; Str
.text$mn:0000754F                 call    _strlen
.text$mn:00007554                 add     esp, 4
.text$mn:00007557                 mov     [ebp+var_4], eax
.text$mn:0000755A
.text$mn:0000755A loc_755A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000755A                 mov     eax, [ebp+var_4]
.text$mn:0000755D                 mov     esp, ebp
.text$mn:0000755F                 pop     ebp
.text$mn:00007560                 retn
.text$mn:00007560 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00007560
.text$mn:00007560 ; ---------------------------------------------------------------------------
.text$mn:00007561                 align 4
.text$mn:00007561 _text$mn        ends
.text$mn:00007561
.text$mn:00007564 ; ===========================================================================
.text$mn:00007564
.text$mn:00007564 ; Segment type: Pure code
.text$mn:00007564 ; Segment permissions: Read/Execute
.text$mn:00007564 _text$mn        segment para public 'CODE' use32
.text$mn:00007564                 assume cs:_text$mn
.text$mn:00007564                 ;org 7564h
.text$mn:00007564 ; COMDAT (pick any)
.text$mn:00007564                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007564
.text$mn:00007564 ; =============== S U B R O U T I N E =======================================
.text$mn:00007564
.text$mn:00007564 ; Attributes: bp-based frame
.text$mn:00007564
.text$mn:00007564 ; class std::error_code __cdecl std::make_error_code(enum  std::io_errc)
.text$mn:00007564                 public ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
.text$mn:00007564 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z proc near
.text$mn:00007564                                         ; CODE XREF: std::ios_base::clear(int,bool)+55p
.text$mn:00007564                                         ; std::ios_base::clear(int,bool)+92p ...
.text$mn:00007564
.text$mn:00007564 arg_0           = dword ptr  8
.text$mn:00007564 arg_4           = dword ptr  0Ch
.text$mn:00007564
.text$mn:00007564                 push    ebp
.text$mn:00007565                 mov     ebp, esp
.text$mn:00007567                 call    ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category(void)
.text$mn:0000756C                 push    eax             ; struct std::error_category *
.text$mn:0000756D                 mov     eax, [ebp+arg_4]
.text$mn:00007570                 push    eax             ; int
.text$mn:00007571                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007574                 call    ??0error_code@std@@QAE@HABVerror_category@1@@Z ; std::error_code::error_code(int,std::error_category const &)
.text$mn:00007579                 mov     eax, [ebp+arg_0]
.text$mn:0000757C                 pop     ebp
.text$mn:0000757D                 retn
.text$mn:0000757D ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z endp
.text$mn:0000757D
.text$mn:0000757D ; ---------------------------------------------------------------------------
.text$mn:0000757E                 align 10h
.text$mn:0000757E _text$mn        ends
.text$mn:0000757E
.text$mn:00007580 ; ===========================================================================
.text$mn:00007580
.text$mn:00007580 ; Segment type: Pure code
.text$mn:00007580 ; Segment permissions: Read/Execute
.text$mn:00007580 _text$mn        segment para public 'CODE' use32
.text$mn:00007580                 assume cs:_text$mn
.text$mn:00007580                 ;org 7580h
.text$mn:00007580 ; COMDAT (pick any)
.text$mn:00007580                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007580
.text$mn:00007580 ; =============== S U B R O U T I N E =======================================
.text$mn:00007580
.text$mn:00007580 ; Attributes: bp-based frame
.text$mn:00007580
.text$mn:00007580 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00007580                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00007580 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00007580                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00007580
.text$mn:00007580 var_4           = dword ptr -4
.text$mn:00007580
.text$mn:00007580                 push    ebp
.text$mn:00007581                 mov     ebp, esp
.text$mn:00007583                 push    ecx
.text$mn:00007584                 mov     [ebp+var_4], ecx
.text$mn:00007587                 mov     eax, [ebp+var_4]
.text$mn:0000758A                 push    eax
.text$mn:0000758B                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00007590                 add     esp, 4
.text$mn:00007593                 mov     esp, ebp
.text$mn:00007595                 pop     ebp
.text$mn:00007596                 retn
.text$mn:00007596 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00007596
.text$mn:00007596 ; ---------------------------------------------------------------------------
.text$mn:00007597                 align 4
.text$mn:00007597 _text$mn        ends
.text$mn:00007597
.text$mn:00007598 ; ===========================================================================
.text$mn:00007598
.text$mn:00007598 ; Segment type: Pure code
.text$mn:00007598 ; Segment permissions: Read/Execute
.text$mn:00007598 _text$mn        segment para public 'CODE' use32
.text$mn:00007598                 assume cs:_text$mn
.text$mn:00007598                 ;org 7598h
.text$mn:00007598 ; COMDAT (pick any)
.text$mn:00007598                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007598
.text$mn:00007598 ; =============== S U B R O U T I N E =======================================
.text$mn:00007598
.text$mn:00007598 ; Attributes: bp-based frame
.text$mn:00007598
.text$mn:00007598 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00007598                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00007598 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00007598                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00007598
.text$mn:00007598 var_4           = dword ptr -4
.text$mn:00007598
.text$mn:00007598                 push    ebp
.text$mn:00007599                 mov     ebp, esp
.text$mn:0000759B                 push    ecx
.text$mn:0000759C                 mov     [ebp+var_4], ecx
.text$mn:0000759F                 or      eax, 0FFFFFFFFh
.text$mn:000075A2                 mov     esp, ebp
.text$mn:000075A4                 pop     ebp
.text$mn:000075A5                 retn
.text$mn:000075A5 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000075A5
.text$mn:000075A5 ; ---------------------------------------------------------------------------
.text$mn:000075A6                 align 4
.text$mn:000075A6 _text$mn        ends
.text$mn:000075A6
.text$mn:000075A8 ; ===========================================================================
.text$mn:000075A8
.text$mn:000075A8 ; Segment type: Pure code
.text$mn:000075A8 ; Segment permissions: Read/Execute
.text$mn:000075A8 _text$mn        segment para public 'CODE' use32
.text$mn:000075A8                 assume cs:_text$mn
.text$mn:000075A8                 ;org 75A8h
.text$mn:000075A8 ; COMDAT (pick any)
.text$mn:000075A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075A8
.text$mn:000075A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000075A8
.text$mn:000075A8 ; Attributes: bp-based frame
.text$mn:000075A8
.text$mn:000075A8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000075A8                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000075A8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000075A8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000075A8
.text$mn:000075A8 arg_0           = dword ptr  8
.text$mn:000075A8
.text$mn:000075A8                 push    ebp
.text$mn:000075A9                 mov     ebp, esp
.text$mn:000075AB                 mov     ecx, [ebp+arg_0]
.text$mn:000075AE                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000075B3                 pop     ebp
.text$mn:000075B4                 retn
.text$mn:000075B4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000075B4
.text$mn:000075B4 ; ---------------------------------------------------------------------------
.text$mn:000075B5                 align 4
.text$mn:000075B5 _text$mn        ends
.text$mn:000075B5
.text$mn:000075B8 ; ===========================================================================
.text$mn:000075B8
.text$mn:000075B8 ; Segment type: Pure code
.text$mn:000075B8 ; Segment permissions: Read/Execute
.text$mn:000075B8 _text$mn        segment para public 'CODE' use32
.text$mn:000075B8                 assume cs:_text$mn
.text$mn:000075B8                 ;org 75B8h
.text$mn:000075B8 ; COMDAT (pick any)
.text$mn:000075B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075B8
.text$mn:000075B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000075B8
.text$mn:000075B8 ; Attributes: bp-based frame
.text$mn:000075B8
.text$mn:000075B8 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000075B8                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000075B8 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000075B8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000075B8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000075B8
.text$mn:000075B8 var_10          = dword ptr -10h
.text$mn:000075B8 var_C           = dword ptr -0Ch
.text$mn:000075B8 var_8           = dword ptr -8
.text$mn:000075B8 var_1           = byte ptr -1
.text$mn:000075B8
.text$mn:000075B8                 push    ebp
.text$mn:000075B9                 mov     ebp, esp
.text$mn:000075BB                 sub     esp, 10h
.text$mn:000075BE                 mov     [ebp+var_10], ecx
.text$mn:000075C1                 lea     eax, [ebp+var_1]
.text$mn:000075C4                 push    eax
.text$mn:000075C5                 mov     ecx, [ebp+var_10]
.text$mn:000075C8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000075CD                 mov     ecx, eax
.text$mn:000075CF                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000075D4                 mov     [ebp+var_8], eax
.text$mn:000075D7                 cmp     [ebp+var_8], 1
.text$mn:000075DB                 ja      short loc_75E6
.text$mn:000075DD                 mov     [ebp+var_C], 1
.text$mn:000075E4                 jmp     short loc_75EF
.text$mn:000075E6 ; ---------------------------------------------------------------------------
.text$mn:000075E6
.text$mn:000075E6 loc_75E6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000075E6                 mov     ecx, [ebp+var_8]
.text$mn:000075E9                 sub     ecx, 1
.text$mn:000075EC                 mov     [ebp+var_C], ecx
.text$mn:000075EF
.text$mn:000075EF loc_75EF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000075EF                 mov     eax, [ebp+var_C]
.text$mn:000075F2                 mov     esp, ebp
.text$mn:000075F4                 pop     ebp
.text$mn:000075F5                 retn
.text$mn:000075F5 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000075F5
.text$mn:000075F5 ; ---------------------------------------------------------------------------
.text$mn:000075F6                 align 4
.text$mn:000075F6 _text$mn        ends
.text$mn:000075F6
.text$mn:000075F8 ; ===========================================================================
.text$mn:000075F8
.text$mn:000075F8 ; Segment type: Pure code
.text$mn:000075F8 ; Segment permissions: Read/Execute
.text$mn:000075F8 _text$mn        segment para public 'CODE' use32
.text$mn:000075F8                 assume cs:_text$mn
.text$mn:000075F8                 ;org 75F8h
.text$mn:000075F8 ; COMDAT (pick any)
.text$mn:000075F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075F8
.text$mn:000075F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000075F8
.text$mn:000075F8 ; Attributes: bp-based frame
.text$mn:000075F8
.text$mn:000075F8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000075F8                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000075F8 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000075F8                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000075F8                                         ; DATA XREF: .rdata:00008E54o
.text$mn:000075F8
.text$mn:000075F8 var_1C          = dword ptr -1Ch
.text$mn:000075F8 var_18          = dword ptr -18h
.text$mn:000075F8 Str             = dword ptr -14h
.text$mn:000075F8 var_10          = dword ptr -10h
.text$mn:000075F8 var_C           = dword ptr -0Ch
.text$mn:000075F8 var_4           = dword ptr -4
.text$mn:000075F8 arg_0           = dword ptr  8
.text$mn:000075F8 arg_4           = dword ptr  0Ch
.text$mn:000075F8
.text$mn:000075F8                 push    ebp
.text$mn:000075F9                 mov     ebp, esp
.text$mn:000075FB                 push    0FFFFFFFFh
.text$mn:000075FD                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00007602                 mov     eax, large fs:0
.text$mn:00007608                 push    eax
.text$mn:00007609                 sub     esp, 10h
.text$mn:0000760C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007611                 xor     eax, ebp
.text$mn:00007613                 push    eax
.text$mn:00007614                 lea     eax, [ebp+var_C]
.text$mn:00007617                 mov     large fs:0, eax
.text$mn:0000761D                 mov     [ebp+var_1C], ecx
.text$mn:00007620                 mov     [ebp+var_18], 0
.text$mn:00007627                 mov     eax, [ebp+arg_4]
.text$mn:0000762A                 push    eax             ; int
.text$mn:0000762B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00007630                 add     esp, 4
.text$mn:00007633                 mov     [ebp+var_10], eax
.text$mn:00007636                 cmp     [ebp+var_10], 0
.text$mn:0000763A                 jz      short loc_7644
.text$mn:0000763C                 mov     ecx, [ebp+var_10]
.text$mn:0000763F                 mov     [ebp+Str], ecx
.text$mn:00007642                 jmp     short loc_764B
.text$mn:00007644 ; ---------------------------------------------------------------------------
.text$mn:00007644
.text$mn:00007644 loc_7644:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00007644                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000764B
.text$mn:0000764B loc_764B:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000764B                 mov     edx, [ebp+Str]
.text$mn:0000764E                 push    edx             ; Str
.text$mn:0000764F                 mov     ecx, [ebp+arg_0]
.text$mn:00007652                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00007657                 mov     [ebp+var_4], 0
.text$mn:0000765E                 mov     eax, [ebp+var_18]
.text$mn:00007661                 or      eax, 1
.text$mn:00007664                 mov     [ebp+var_18], eax
.text$mn:00007667                 mov     eax, [ebp+arg_0]
.text$mn:0000766A                 mov     ecx, [ebp+var_C]
.text$mn:0000766D                 mov     large fs:0, ecx
.text$mn:00007674                 pop     ecx
.text$mn:00007675                 mov     esp, ebp
.text$mn:00007677                 pop     ebp
.text$mn:00007678                 retn    8
.text$mn:00007678 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00007678
.text$mn:00007678 ; ---------------------------------------------------------------------------
.text$mn:0000767B                 align 4
.text$mn:0000767B _text$mn        ends
.text$mn:0000767B
.text$x:0000767C ; ===========================================================================
.text$x:0000767C
.text$x:0000767C ; Segment type: Pure code
.text$x:0000767C ; Segment permissions: Read/Execute
.text$x:0000767C _text$x         segment para public 'CODE' use32
.text$x:0000767C                 assume cs:_text$x
.text$x:0000767C                 ;org 767Ch
.text$x:0000767C ; COMDAT (pick associative to section at 75F8)
.text$x:0000767C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000767C
.text$x:0000767C ; =============== S U B R O U T I N E =======================================
.text$x:0000767C
.text$x:0000767C
.text$x:0000767C __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000767C                                         ; DATA XREF: .xdata$x:00008428o
.text$x:0000767C                 mov     eax, [ebp-18h]
.text$x:0000767F                 and     eax, 1
.text$x:00007682                 jz      $LN6
.text$x:00007688                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000768C                 mov     ecx, [ebp+8]
.text$x:0000768F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00007694 ; ---------------------------------------------------------------------------
.text$x:00007694
.text$x:00007694 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00007694                 retn
.text$x:00007694 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00007694
.text$x:00007695
.text$x:00007695 ; =============== S U B R O U T I N E =======================================
.text$x:00007695
.text$x:00007695
.text$x:00007695 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00007695                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00007695
.text$x:00007695 arg_4           = dword ptr  8
.text$x:00007695
.text$x:00007695                 mov     edx, [esp+arg_4]
.text$x:00007699                 lea     eax, [edx+0Ch]
.text$x:0000769C                 mov     ecx, [edx-14h]
.text$x:0000769F                 xor     ecx, eax
.text$x:000076A1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000076A6                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000076AB                 jmp     ___CxxFrameHandler3
.text$x:000076AB __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000076AB
.text$x:000076AB _text$x         ends
.text$x:000076AB
.text$mn:000076B0 ; ===========================================================================
.text$mn:000076B0
.text$mn:000076B0 ; Segment type: Pure code
.text$mn:000076B0 ; Segment permissions: Read/Execute
.text$mn:000076B0 _text$mn        segment para public 'CODE' use32
.text$mn:000076B0                 assume cs:_text$mn
.text$mn:000076B0                 ;org 76B0h
.text$mn:000076B0 ; COMDAT (pick any)
.text$mn:000076B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000076B0
.text$mn:000076B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000076B0
.text$mn:000076B0 ; Attributes: bp-based frame
.text$mn:000076B0
.text$mn:000076B0 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:000076B0                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000076B0 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000076B0                                         ; DATA XREF: .rdata:00008E88o
.text$mn:000076B0
.text$mn:000076B0 var_14          = dword ptr -14h
.text$mn:000076B0 var_10          = dword ptr -10h
.text$mn:000076B0 var_C           = dword ptr -0Ch
.text$mn:000076B0 var_4           = dword ptr -4
.text$mn:000076B0 arg_0           = dword ptr  8
.text$mn:000076B0 arg_4           = dword ptr  0Ch
.text$mn:000076B0
.text$mn:000076B0                 push    ebp
.text$mn:000076B1                 mov     ebp, esp
.text$mn:000076B3                 push    0FFFFFFFFh
.text$mn:000076B5                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000076BA                 mov     eax, large fs:0
.text$mn:000076C0                 push    eax
.text$mn:000076C1                 sub     esp, 8
.text$mn:000076C4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000076C9                 xor     eax, ebp
.text$mn:000076CB                 push    eax
.text$mn:000076CC                 lea     eax, [ebp+var_C]
.text$mn:000076CF                 mov     large fs:0, eax
.text$mn:000076D5                 mov     [ebp+var_14], ecx
.text$mn:000076D8                 mov     [ebp+var_10], 0
.text$mn:000076DF                 cmp     [ebp+arg_4], 1
.text$mn:000076E3                 jnz     short loc_7709
.text$mn:000076E5                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000076EA                 mov     ecx, [ebp+arg_0]
.text$mn:000076ED                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000076F2                 mov     [ebp+var_4], 0
.text$mn:000076F9                 mov     eax, [ebp+var_10]
.text$mn:000076FC                 or      eax, 1
.text$mn:000076FF                 mov     [ebp+var_10], eax
.text$mn:00007702                 mov     eax, [ebp+arg_0]
.text$mn:00007705                 jmp     short loc_772C
.text$mn:00007707 ; ---------------------------------------------------------------------------
.text$mn:00007707                 jmp     short loc_772C
.text$mn:00007709 ; ---------------------------------------------------------------------------
.text$mn:00007709
.text$mn:00007709 loc_7709:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00007709                 mov     ecx, [ebp+arg_4]
.text$mn:0000770C                 push    ecx
.text$mn:0000770D                 mov     edx, [ebp+arg_0]
.text$mn:00007710                 push    edx
.text$mn:00007711                 mov     ecx, [ebp+var_14]
.text$mn:00007714                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00007719                 mov     [ebp+var_4], 0
.text$mn:00007720                 mov     eax, [ebp+var_10]
.text$mn:00007723                 or      eax, 1
.text$mn:00007726                 mov     [ebp+var_10], eax
.text$mn:00007729                 mov     eax, [ebp+arg_0]
.text$mn:0000772C
.text$mn:0000772C loc_772C:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:0000772C                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:0000772C                 mov     ecx, [ebp+var_C]
.text$mn:0000772F                 mov     large fs:0, ecx
.text$mn:00007736                 pop     ecx
.text$mn:00007737                 mov     esp, ebp
.text$mn:00007739                 pop     ebp
.text$mn:0000773A                 retn    8
.text$mn:0000773A ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000773A
.text$mn:0000773A ; ---------------------------------------------------------------------------
.text$mn:0000773D                 align 10h
.text$mn:0000773D _text$mn        ends
.text$mn:0000773D
.text$x:00007740 ; ===========================================================================
.text$x:00007740
.text$x:00007740 ; Segment type: Pure code
.text$x:00007740 ; Segment permissions: Read/Execute
.text$x:00007740 _text$x         segment para public 'CODE' use32
.text$x:00007740                 assume cs:_text$x
.text$x:00007740                 ;org 7740h
.text$x:00007740 ; COMDAT (pick associative to section at 76B0)
.text$x:00007740                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007740
.text$x:00007740 ; =============== S U B R O U T I N E =======================================
.text$x:00007740
.text$x:00007740
.text$x:00007740 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00007740                                         ; DATA XREF: .xdata$x:000084ACo
.text$x:00007740                 mov     eax, [ebp-10h]
.text$x:00007743                 and     eax, 1
.text$x:00007746                 jz      $LN6_0
.text$x:0000774C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00007750                 mov     ecx, [ebp+8]
.text$x:00007753                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00007758 ; ---------------------------------------------------------------------------
.text$x:00007758
.text$x:00007758 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00007758                 retn
.text$x:00007758 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00007758
.text$x:00007759
.text$x:00007759 ; =============== S U B R O U T I N E =======================================
.text$x:00007759
.text$x:00007759
.text$x:00007759 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00007759                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00007759
.text$x:00007759 arg_4           = dword ptr  8
.text$x:00007759
.text$x:00007759                 mov     edx, [esp+arg_4]
.text$x:0000775D                 lea     eax, [edx+0Ch]
.text$x:00007760                 mov     ecx, [edx-0Ch]
.text$x:00007763                 xor     ecx, eax
.text$x:00007765                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000776A                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000776F                 jmp     ___CxxFrameHandler3
.text$x:0000776F __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000776F
.text$x:0000776F _text$x         ends
.text$x:0000776F
.text$mn:00007774 ; ===========================================================================
.text$mn:00007774
.text$mn:00007774 ; Segment type: Pure code
.text$mn:00007774 ; Segment permissions: Read/Execute
.text$mn:00007774 _text$mn        segment para public 'CODE' use32
.text$mn:00007774                 assume cs:_text$mn
.text$mn:00007774                 ;org 7774h
.text$mn:00007774 ; COMDAT (pick any)
.text$mn:00007774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007774
.text$mn:00007774 ; =============== S U B R O U T I N E =======================================
.text$mn:00007774
.text$mn:00007774 ; Attributes: bp-based frame
.text$mn:00007774
.text$mn:00007774 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00007774                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00007774 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00007774                                         ; DATA XREF: .rdata:00008EC8o
.text$mn:00007774
.text$mn:00007774 var_1C          = dword ptr -1Ch
.text$mn:00007774 var_18          = dword ptr -18h
.text$mn:00007774 Str             = dword ptr -14h
.text$mn:00007774 var_10          = dword ptr -10h
.text$mn:00007774 var_C           = dword ptr -0Ch
.text$mn:00007774 var_4           = dword ptr -4
.text$mn:00007774 arg_0           = dword ptr  8
.text$mn:00007774 arg_4           = dword ptr  0Ch
.text$mn:00007774
.text$mn:00007774                 push    ebp
.text$mn:00007775                 mov     ebp, esp
.text$mn:00007777                 push    0FFFFFFFFh
.text$mn:00007779                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000777E                 mov     eax, large fs:0
.text$mn:00007784                 push    eax
.text$mn:00007785                 sub     esp, 10h
.text$mn:00007788                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000778D                 xor     eax, ebp
.text$mn:0000778F                 push    eax
.text$mn:00007790                 lea     eax, [ebp+var_C]
.text$mn:00007793                 mov     large fs:0, eax
.text$mn:00007799                 mov     [ebp+var_1C], ecx
.text$mn:0000779C                 mov     [ebp+var_18], 0
.text$mn:000077A3                 mov     eax, [ebp+arg_4]
.text$mn:000077A6                 push    eax             ; int
.text$mn:000077A7                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:000077AC                 add     esp, 4
.text$mn:000077AF                 mov     [ebp+var_10], eax
.text$mn:000077B2                 cmp     [ebp+var_10], 0
.text$mn:000077B6                 jz      short loc_77C0
.text$mn:000077B8                 mov     ecx, [ebp+var_10]
.text$mn:000077BB                 mov     [ebp+Str], ecx
.text$mn:000077BE                 jmp     short loc_77C7
.text$mn:000077C0 ; ---------------------------------------------------------------------------
.text$mn:000077C0
.text$mn:000077C0 loc_77C0:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:000077C0                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000077C7
.text$mn:000077C7 loc_77C7:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:000077C7                 mov     edx, [ebp+Str]
.text$mn:000077CA                 push    edx             ; Str
.text$mn:000077CB                 mov     ecx, [ebp+arg_0]
.text$mn:000077CE                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000077D3                 mov     [ebp+var_4], 0
.text$mn:000077DA                 mov     eax, [ebp+var_18]
.text$mn:000077DD                 or      eax, 1
.text$mn:000077E0                 mov     [ebp+var_18], eax
.text$mn:000077E3                 mov     eax, [ebp+arg_0]
.text$mn:000077E6                 mov     ecx, [ebp+var_C]
.text$mn:000077E9                 mov     large fs:0, ecx
.text$mn:000077F0                 pop     ecx
.text$mn:000077F1                 mov     esp, ebp
.text$mn:000077F3                 pop     ebp
.text$mn:000077F4                 retn    8
.text$mn:000077F4 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000077F4
.text$mn:000077F4 ; ---------------------------------------------------------------------------
.text$mn:000077F7                 align 4
.text$mn:000077F7 _text$mn        ends
.text$mn:000077F7
.text$x:000077F8 ; ===========================================================================
.text$x:000077F8
.text$x:000077F8 ; Segment type: Pure code
.text$x:000077F8 ; Segment permissions: Read/Execute
.text$x:000077F8 _text$x         segment para public 'CODE' use32
.text$x:000077F8                 assume cs:_text$x
.text$x:000077F8                 ;org 77F8h
.text$x:000077F8 ; COMDAT (pick associative to section at 7774)
.text$x:000077F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000077F8
.text$x:000077F8 ; =============== S U B R O U T I N E =======================================
.text$x:000077F8
.text$x:000077F8
.text$x:000077F8 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000077F8                                         ; DATA XREF: .xdata$x:00008530o
.text$x:000077F8                 mov     eax, [ebp-18h]
.text$x:000077FB                 and     eax, 1
.text$x:000077FE                 jz      $LN6_1
.text$x:00007804                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00007808                 mov     ecx, [ebp+8]
.text$x:0000780B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00007810 ; ---------------------------------------------------------------------------
.text$x:00007810
.text$x:00007810 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00007810                 retn
.text$x:00007810 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00007810
.text$x:00007811
.text$x:00007811 ; =============== S U B R O U T I N E =======================================
.text$x:00007811
.text$x:00007811
.text$x:00007811 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00007811                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00007811
.text$x:00007811 arg_4           = dword ptr  8
.text$x:00007811
.text$x:00007811                 mov     edx, [esp+arg_4]
.text$x:00007815                 lea     eax, [edx+0Ch]
.text$x:00007818                 mov     ecx, [edx-14h]
.text$x:0000781B                 xor     ecx, eax
.text$x:0000781D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007822                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00007827                 jmp     ___CxxFrameHandler3
.text$x:00007827 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00007827
.text$x:00007827 _text$x         ends
.text$x:00007827
.text$mn:0000782C ; ===========================================================================
.text$mn:0000782C
.text$mn:0000782C ; Segment type: Pure code
.text$mn:0000782C ; Segment permissions: Read/Execute
.text$mn:0000782C _text$mn        segment para public 'CODE' use32
.text$mn:0000782C                 assume cs:_text$mn
.text$mn:0000782C                 ;org 782Ch
.text$mn:0000782C ; COMDAT (pick any)
.text$mn:0000782C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000782C
.text$mn:0000782C ; =============== S U B R O U T I N E =======================================
.text$mn:0000782C
.text$mn:0000782C ; Attributes: bp-based frame
.text$mn:0000782C
.text$mn:0000782C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::error_code::message(void)const
.text$mn:0000782C                 public ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
.text$mn:0000782C ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ proc near
.text$mn:0000782C                                         ; CODE XREF: std::_System_error::_Makestr(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>>)+59p
.text$mn:0000782C
.text$mn:0000782C var_18          = dword ptr -18h
.text$mn:0000782C var_14          = dword ptr -14h
.text$mn:0000782C var_10          = dword ptr -10h
.text$mn:0000782C var_C           = dword ptr -0Ch
.text$mn:0000782C var_4           = dword ptr -4
.text$mn:0000782C arg_0           = dword ptr  8
.text$mn:0000782C
.text$mn:0000782C                 push    ebp
.text$mn:0000782D                 mov     ebp, esp
.text$mn:0000782F                 push    0FFFFFFFFh
.text$mn:00007831                 push    offset __ehhandler$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
.text$mn:00007836                 mov     eax, large fs:0
.text$mn:0000783C                 push    eax
.text$mn:0000783D                 sub     esp, 0Ch
.text$mn:00007840                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007845                 xor     eax, ebp
.text$mn:00007847                 push    eax
.text$mn:00007848                 lea     eax, [ebp+var_C]
.text$mn:0000784B                 mov     large fs:0, eax
.text$mn:00007851                 mov     [ebp+var_10], ecx
.text$mn:00007854                 mov     [ebp+var_18], 0
.text$mn:0000785B                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000785E                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00007863                 mov     [ebp+var_14], eax
.text$mn:00007866                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007869                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000786E                 push    eax
.text$mn:0000786F                 mov     eax, [ebp+arg_0]
.text$mn:00007872                 push    eax
.text$mn:00007873                 mov     ecx, [ebp+var_14]
.text$mn:00007876                 mov     edx, [ecx]
.text$mn:00007878                 mov     ecx, [ebp+var_14]
.text$mn:0000787B                 mov     eax, [edx+8]
.text$mn:0000787E                 call    eax
.text$mn:00007880                 mov     [ebp+var_4], 0
.text$mn:00007887                 mov     ecx, [ebp+var_18]
.text$mn:0000788A                 or      ecx, 1
.text$mn:0000788D                 mov     [ebp+var_18], ecx
.text$mn:00007890                 mov     eax, [ebp+arg_0]
.text$mn:00007893                 mov     ecx, [ebp+var_C]
.text$mn:00007896                 mov     large fs:0, ecx
.text$mn:0000789D                 pop     ecx
.text$mn:0000789E                 mov     esp, ebp
.text$mn:000078A0                 pop     ebp
.text$mn:000078A1                 retn    4
.text$mn:000078A1 ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ endp
.text$mn:000078A1
.text$mn:000078A1 _text$mn        ends
.text$mn:000078A1
.text$x:000078A4 ; ===========================================================================
.text$x:000078A4
.text$x:000078A4 ; Segment type: Pure code
.text$x:000078A4 ; Segment permissions: Read/Execute
.text$x:000078A4 _text$x         segment para public 'CODE' use32
.text$x:000078A4                 assume cs:_text$x
.text$x:000078A4                 ;org 78A4h
.text$x:000078A4 ; COMDAT (pick associative to section at 782C)
.text$x:000078A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000078A4
.text$x:000078A4 ; =============== S U B R O U T I N E =======================================
.text$x:000078A4
.text$x:000078A4
.text$x:000078A4 __unwindfunclet$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0 proc near
.text$x:000078A4                                         ; DATA XREF: .xdata$x:00008264o
.text$x:000078A4                 mov     eax, [ebp-18h]
.text$x:000078A7                 and     eax, 1
.text$x:000078AA                 jz      $LN4
.text$x:000078B0                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000078B4                 mov     ecx, [ebp+8]
.text$x:000078B7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000078BC ; ---------------------------------------------------------------------------
.text$x:000078BC
.text$x:000078BC $LN4:                                   ; CODE XREF: __unwindfunclet$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0+6j
.text$x:000078BC                 retn
.text$x:000078BC __unwindfunclet$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0 endp
.text$x:000078BC
.text$x:000078BD
.text$x:000078BD ; =============== S U B R O U T I N E =======================================
.text$x:000078BD
.text$x:000078BD
.text$x:000078BD __ehhandler$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ proc near
.text$x:000078BD                                         ; DATA XREF: std::error_code::message(void)+5o
.text$x:000078BD
.text$x:000078BD arg_4           = dword ptr  8
.text$x:000078BD
.text$x:000078BD                 mov     edx, [esp+arg_4]
.text$x:000078C1                 lea     eax, [edx+0Ch]
.text$x:000078C4                 mov     ecx, [edx-10h]
.text$x:000078C7                 xor     ecx, eax
.text$x:000078C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000078CE                 mov     eax, offset __ehfuncinfo$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
.text$x:000078D3                 jmp     ___CxxFrameHandler3
.text$x:000078D3 __ehhandler$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ endp
.text$x:000078D3
.text$x:000078D3 _text$x         ends
.text$x:000078D3
.text$mn:000078D8 ; ===========================================================================
.text$mn:000078D8
.text$mn:000078D8 ; Segment type: Pure code
.text$mn:000078D8 ; Segment permissions: Read/Execute
.text$mn:000078D8 _text$mn        segment para public 'CODE' use32
.text$mn:000078D8                 assume cs:_text$mn
.text$mn:000078D8                 ;org 78D8h
.text$mn:000078D8 ; COMDAT (pick any)
.text$mn:000078D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078D8
.text$mn:000078D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000078D8
.text$mn:000078D8 ; Attributes: bp-based frame
.text$mn:000078D8
.text$mn:000078D8 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000078D8                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000078D8 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000078D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Assign_rv(std::basic_string<char,std::char_traits<char>,std::allocator<char>> &&)+2Ap
.text$mn:000078D8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000078D8
.text$mn:000078D8 var_4           = dword ptr -4
.text$mn:000078D8 Dst             = dword ptr  8
.text$mn:000078D8 Src             = dword ptr  0Ch
.text$mn:000078D8 Size            = dword ptr  10h
.text$mn:000078D8
.text$mn:000078D8                 push    ebp
.text$mn:000078D9                 mov     ebp, esp
.text$mn:000078DB                 push    ecx
.text$mn:000078DC                 cmp     [ebp+Size], 0
.text$mn:000078E0                 jnz     short loc_78EA
.text$mn:000078E2                 mov     eax, [ebp+Dst]
.text$mn:000078E5                 mov     [ebp+var_4], eax
.text$mn:000078E8                 jmp     short loc_7901
.text$mn:000078EA ; ---------------------------------------------------------------------------
.text$mn:000078EA
.text$mn:000078EA loc_78EA:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000078EA                 mov     ecx, [ebp+Size]
.text$mn:000078ED                 push    ecx             ; Size
.text$mn:000078EE                 mov     edx, [ebp+Src]
.text$mn:000078F1                 push    edx             ; Src
.text$mn:000078F2                 mov     eax, [ebp+Dst]
.text$mn:000078F5                 push    eax             ; Dst
.text$mn:000078F6                 call    _memmove
.text$mn:000078FB                 add     esp, 0Ch
.text$mn:000078FE                 mov     [ebp+var_4], eax
.text$mn:00007901
.text$mn:00007901 loc_7901:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00007901                 mov     eax, [ebp+var_4]
.text$mn:00007904                 mov     esp, ebp
.text$mn:00007906                 pop     ebp
.text$mn:00007907                 retn
.text$mn:00007907 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00007907
.text$mn:00007907 _text$mn        ends
.text$mn:00007907
.text$mn:00007908 ; ===========================================================================
.text$mn:00007908
.text$mn:00007908 ; Segment type: Pure code
.text$mn:00007908 ; Segment permissions: Read/Execute
.text$mn:00007908 _text$mn        segment para public 'CODE' use32
.text$mn:00007908                 assume cs:_text$mn
.text$mn:00007908                 ;org 7908h
.text$mn:00007908 ; COMDAT (pick any)
.text$mn:00007908                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007908
.text$mn:00007908 ; =============== S U B R O U T I N E =======================================
.text$mn:00007908
.text$mn:00007908 ; Attributes: bp-based frame
.text$mn:00007908
.text$mn:00007908 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00007908                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00007908 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00007908                                         ; DATA XREF: .rdata:00008E50o
.text$mn:00007908
.text$mn:00007908 var_4           = dword ptr -4
.text$mn:00007908
.text$mn:00007908                 push    ebp
.text$mn:00007909                 mov     ebp, esp
.text$mn:0000790B                 push    ecx
.text$mn:0000790C                 mov     [ebp+var_4], ecx
.text$mn:0000790F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00007914                 mov     esp, ebp
.text$mn:00007916                 pop     ebp
.text$mn:00007917                 retn
.text$mn:00007917 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00007917
.text$mn:00007917 _text$mn        ends
.text$mn:00007917
.text$mn:00007918 ; ===========================================================================
.text$mn:00007918
.text$mn:00007918 ; Segment type: Pure code
.text$mn:00007918 ; Segment permissions: Read/Execute
.text$mn:00007918 _text$mn        segment para public 'CODE' use32
.text$mn:00007918                 assume cs:_text$mn
.text$mn:00007918                 ;org 7918h
.text$mn:00007918 ; COMDAT (pick any)
.text$mn:00007918                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007918
.text$mn:00007918 ; =============== S U B R O U T I N E =======================================
.text$mn:00007918
.text$mn:00007918 ; Attributes: bp-based frame
.text$mn:00007918
.text$mn:00007918 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00007918                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00007918 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00007918                                         ; DATA XREF: .rdata:00008E84o
.text$mn:00007918
.text$mn:00007918 var_4           = dword ptr -4
.text$mn:00007918
.text$mn:00007918                 push    ebp
.text$mn:00007919                 mov     ebp, esp
.text$mn:0000791B                 push    ecx
.text$mn:0000791C                 mov     [ebp+var_4], ecx
.text$mn:0000791F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00007924                 mov     esp, ebp
.text$mn:00007926                 pop     ebp
.text$mn:00007927                 retn
.text$mn:00007927 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00007927
.text$mn:00007927 _text$mn        ends
.text$mn:00007927
.text$mn:00007928 ; ===========================================================================
.text$mn:00007928
.text$mn:00007928 ; Segment type: Pure code
.text$mn:00007928 ; Segment permissions: Read/Execute
.text$mn:00007928 _text$mn        segment para public 'CODE' use32
.text$mn:00007928                 assume cs:_text$mn
.text$mn:00007928                 ;org 7928h
.text$mn:00007928 ; COMDAT (pick any)
.text$mn:00007928                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007928
.text$mn:00007928 ; =============== S U B R O U T I N E =======================================
.text$mn:00007928
.text$mn:00007928 ; Attributes: bp-based frame
.text$mn:00007928
.text$mn:00007928 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00007928                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00007928 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00007928                                         ; DATA XREF: .rdata:00008EC4o
.text$mn:00007928
.text$mn:00007928 var_4           = dword ptr -4
.text$mn:00007928
.text$mn:00007928                 push    ebp
.text$mn:00007929                 mov     ebp, esp
.text$mn:0000792B                 push    ecx
.text$mn:0000792C                 mov     [ebp+var_4], ecx
.text$mn:0000792F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00007934                 mov     esp, ebp
.text$mn:00007936                 pop     ebp
.text$mn:00007937                 retn
.text$mn:00007937 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00007937
.text$mn:00007937 _text$mn        ends
.text$mn:00007937
.text$mn:00007938 ; ===========================================================================
.text$mn:00007938
.text$mn:00007938 ; Segment type: Pure code
.text$mn:00007938 ; Segment permissions: Read/Execute
.text$mn:00007938 _text$mn        segment para public 'CODE' use32
.text$mn:00007938                 assume cs:_text$mn
.text$mn:00007938                 ;org 7938h
.text$mn:00007938 ; COMDAT (pick any)
.text$mn:00007938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007938
.text$mn:00007938 ; =============== S U B R O U T I N E =======================================
.text$mn:00007938
.text$mn:00007938 ; Attributes: bp-based frame
.text$mn:00007938
.text$mn:00007938 ; public: int __thiscall std::basic_istream<char, struct std::char_traits<char>>::peek(void)
.text$mn:00007938                 public ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007938 ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ proc near
.text$mn:00007938                                         ; CODE XREF: TiXmlBaseA::StreamWhiteSpace(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+24p
.text$mn:00007938                                         ; TiXmlBaseA::StreamTo(std::basic_istream<char,std::char_traits<char>> *,int,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+20p ...
.text$mn:00007938
.text$mn:00007938 var_2C          = byte ptr -2Ch
.text$mn:00007938 var_24          = dword ptr -24h
.text$mn:00007938 var_20          = dword ptr -20h
.text$mn:00007938 var_1C          = dword ptr -1Ch
.text$mn:00007938 var_18          = dword ptr -18h
.text$mn:00007938 var_14          = dword ptr -14h
.text$mn:00007938 var_10          = dword ptr -10h
.text$mn:00007938 var_C           = dword ptr -0Ch
.text$mn:00007938 var_4           = dword ptr -4
.text$mn:00007938
.text$mn:00007938 ; FUNCTION CHUNK AT .text$mn:00007A18 SIZE 00000009 BYTES
.text$mn:00007938 ; FUNCTION CHUNK AT .text$mn:00007A28 SIZE 00000040 BYTES
.text$mn:00007938
.text$mn:00007938                 push    ebp
.text$mn:00007939                 mov     ebp, esp
.text$mn:0000793B                 push    0FFFFFFFFh
.text$mn:0000793D                 push    offset __ehhandler$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007942                 mov     eax, large fs:0
.text$mn:00007948                 push    eax
.text$mn:00007949                 push    ecx
.text$mn:0000794A                 sub     esp, 1Ch
.text$mn:0000794D                 push    ebx
.text$mn:0000794E                 push    esi
.text$mn:0000794F                 push    edi
.text$mn:00007950                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007955                 xor     eax, ebp
.text$mn:00007957                 push    eax
.text$mn:00007958                 lea     eax, [ebp+var_C]
.text$mn:0000795B                 mov     large fs:0, eax
.text$mn:00007961                 mov     [ebp+var_10], esp
.text$mn:00007964                 mov     [ebp+var_14], ecx
.text$mn:00007967                 mov     [ebp+var_1C], 0
.text$mn:0000796E                 mov     eax, [ebp+var_14]
.text$mn:00007971                 mov     dword ptr [eax+8], 0
.text$mn:00007978                 mov     dword ptr [eax+0Ch], 0
.text$mn:0000797F                 mov     [ebp+var_18], 0
.text$mn:00007986                 push    1
.text$mn:00007988                 mov     ecx, [ebp+var_14]
.text$mn:0000798B                 push    ecx
.text$mn:0000798C                 lea     ecx, [ebp+var_2C]
.text$mn:0000798F                 call    ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char>>::sentry::sentry(std::basic_istream<char,std::char_traits<char>> &,bool)
.text$mn:00007994                 mov     [ebp+var_4], 0
.text$mn:0000799B                 lea     ecx, [ebp+var_2C]
.text$mn:0000799E                 call    ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char>>::sentry::operator bool(void)
.text$mn:000079A3                 movzx   edx, al
.text$mn:000079A6                 test    edx, edx
.text$mn:000079A8                 jnz     short loc_79B4
.text$mn:000079AA                 call    ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof(void)
.text$mn:000079AF                 mov     [ebp+var_18], eax
.text$mn:000079B2                 jmp     short loc_7A28
.text$mn:000079B4 ; ---------------------------------------------------------------------------
.text$mn:000079B4
.text$mn:000079B4 loc_79B4:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::peek(void)+70j
.text$mn:000079B4                 mov     byte ptr [ebp+var_4], 1
.text$mn:000079B8                 mov     eax, [ebp+var_14]
.text$mn:000079BB                 mov     ecx, [eax]
.text$mn:000079BD                 mov     edx, [ebp+var_14]
.text$mn:000079C0                 add     edx, [ecx+4]
.text$mn:000079C3                 mov     ecx, edx
.text$mn:000079C5                 call    ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char>>::rdbuf(void)
.text$mn:000079CA                 mov     ecx, eax
.text$mn:000079CC                 call    ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)
.text$mn:000079D1                 mov     [ebp+var_18], eax
.text$mn:000079D4                 call    ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof(void)
.text$mn:000079D9                 mov     [ebp+var_20], eax
.text$mn:000079DC                 lea     eax, [ebp+var_18]
.text$mn:000079DF                 push    eax
.text$mn:000079E0                 lea     ecx, [ebp+var_20]
.text$mn:000079E3                 push    ecx
.text$mn:000079E4                 call    ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
.text$mn:000079E9                 add     esp, 8
.text$mn:000079EC                 movzx   edx, al
.text$mn:000079EF                 test    edx, edx
.text$mn:000079F1                 jz      short loc_79FC
.text$mn:000079F3                 mov     eax, [ebp+var_1C]
.text$mn:000079F6                 or      eax, 1
.text$mn:000079F9                 mov     [ebp+var_1C], eax
.text$mn:000079FC
.text$mn:000079FC loc_79FC:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::peek(void)+B9j
.text$mn:000079FC                 jmp     short loc_7A18
.text$mn:000079FC ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ endp
.text$mn:000079FC
.text$mn:000079FE
.text$mn:000079FE ; =============== S U B R O U T I N E =======================================
.text$mn:000079FE
.text$mn:000079FE
.text$mn:000079FE __catch$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$0 proc near
.text$mn:000079FE                                         ; DATA XREF: .xdata$x:00008700o
.text$mn:000079FE                 push    1
.text$mn:00007A00                 push    4
.text$mn:00007A02                 mov     ecx, [ebp-14h]
.text$mn:00007A05                 mov     edx, [ecx]
.text$mn:00007A07                 mov     ecx, [ebp-14h]
.text$mn:00007A0A                 add     ecx, [edx+4]
.text$mn:00007A0D                 call    ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
.text$mn:00007A12                 mov     eax, offset $LN11
.text$mn:00007A17                 retn
.text$mn:00007A17 __catch$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$0 endp
.text$mn:00007A17
.text$mn:00007A18 ; ---------------------------------------------------------------------------
.text$mn:00007A18 ; START OF FUNCTION CHUNK FOR ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007A18
.text$mn:00007A18 loc_7A18:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::peek(void):loc_79FCj
.text$mn:00007A18                 mov     [ebp+var_4], 0
.text$mn:00007A1F                 jmp     short loc_7A28
.text$mn:00007A1F ; END OF FUNCTION CHUNK FOR ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007A21
.text$mn:00007A21 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A21
.text$mn:00007A21
.text$mn:00007A21 $LN11           proc near               ; DATA XREF: __catch$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$0+14o
.text$mn:00007A21                 mov     dword ptr [ebp-4], 0
.text$mn:00007A21 $LN11           endp ; sp-analysis failed
.text$mn:00007A21
.text$mn:00007A28 ; START OF FUNCTION CHUNK FOR ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007A28
.text$mn:00007A28 loc_7A28:                               ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::peek(void)+7Aj
.text$mn:00007A28                                         ; std::basic_istream<char,std::char_traits<char>>::peek(void)+E7j
.text$mn:00007A28                 push    0
.text$mn:00007A2A                 mov     eax, [ebp+var_1C]
.text$mn:00007A2D                 push    eax
.text$mn:00007A2E                 mov     ecx, [ebp+var_14]
.text$mn:00007A31                 mov     edx, [ecx]
.text$mn:00007A33                 mov     ecx, [ebp+var_14]
.text$mn:00007A36                 add     ecx, [edx+4]
.text$mn:00007A39                 call    ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)
.text$mn:00007A3E                 mov     eax, [ebp+var_18]
.text$mn:00007A41                 mov     [ebp+var_24], eax
.text$mn:00007A44                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007A4B                 lea     ecx, [ebp+var_2C]
.text$mn:00007A4E                 call    ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char>>::sentry::~sentry(void)
.text$mn:00007A53                 mov     eax, [ebp+var_24]
.text$mn:00007A56                 mov     ecx, [ebp+var_C]
.text$mn:00007A59                 mov     large fs:0, ecx
.text$mn:00007A60                 pop     ecx
.text$mn:00007A61                 pop     edi
.text$mn:00007A62                 pop     esi
.text$mn:00007A63                 pop     ebx
.text$mn:00007A64                 mov     esp, ebp
.text$mn:00007A66                 pop     ebp
.text$mn:00007A67                 retn
.text$mn:00007A67 ; END OF FUNCTION CHUNK FOR ?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007A67 _text$mn        ends
.text$mn:00007A67
.text$x:00007A68 ; ===========================================================================
.text$x:00007A68
.text$x:00007A68 ; Segment type: Pure code
.text$x:00007A68 ; Segment permissions: Read/Execute
.text$x:00007A68 _text$x         segment para public 'CODE' use32
.text$x:00007A68                 assume cs:_text$x
.text$x:00007A68                 ;org 7A68h
.text$x:00007A68 ; COMDAT (pick associative to section at 7938)
.text$x:00007A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007A68
.text$x:00007A68 ; =============== S U B R O U T I N E =======================================
.text$x:00007A68
.text$x:00007A68
.text$x:00007A68 __unwindfunclet$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$2 proc near
.text$x:00007A68                                         ; DATA XREF: .xdata$x:0000871Co
.text$x:00007A68                 lea     ecx, [ebp-2Ch]
.text$x:00007A6B                 jmp     ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char>>::sentry::~sentry(void)
.text$x:00007A6B __unwindfunclet$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$2 endp
.text$x:00007A6B
.text$x:00007A70
.text$x:00007A70 ; =============== S U B R O U T I N E =======================================
.text$x:00007A70
.text$x:00007A70
.text$x:00007A70 __ehhandler$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ proc near
.text$x:00007A70                                         ; DATA XREF: std::basic_istream<char,std::char_traits<char>>::peek(void)+5o
.text$x:00007A70
.text$x:00007A70 arg_4           = dword ptr  8
.text$x:00007A70
.text$x:00007A70                 mov     edx, [esp+arg_4]
.text$x:00007A74                 lea     eax, [edx+0Ch]
.text$x:00007A77                 mov     ecx, [edx-30h]
.text$x:00007A7A                 xor     ecx, eax
.text$x:00007A7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007A81                 mov     eax, offset __ehfuncinfo$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$x:00007A86                 jmp     ___CxxFrameHandler3
.text$x:00007A86 __ehhandler$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ endp
.text$x:00007A86
.text$x:00007A86 ; ---------------------------------------------------------------------------
.text$x:00007A8B                 align 4
.text$x:00007A8B _text$x         ends
.text$x:00007A8B
.text$mn:00007A8C ; ===========================================================================
.text$mn:00007A8C
.text$mn:00007A8C ; Segment type: Pure code
.text$mn:00007A8C ; Segment permissions: Read/Execute
.text$mn:00007A8C _text$mn        segment para public 'CODE' use32
.text$mn:00007A8C                 assume cs:_text$mn
.text$mn:00007A8C                 ;org 7A8Ch
.text$mn:00007A8C ; COMDAT (pick any)
.text$mn:00007A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A8C
.text$mn:00007A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00007A8C
.text$mn:00007A8C ; Attributes: bp-based frame
.text$mn:00007A8C
.text$mn:00007A8C ; public: int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::pubsync(void)
.text$mn:00007A8C                 public ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007A8C ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ proc near
.text$mn:00007A8C                                         ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::_Osfx(void)+76p
.text$mn:00007A8C                                         ; std::basic_ostream<char,std::char_traits<char>>::flush(void)+72p
.text$mn:00007A8C
.text$mn:00007A8C var_4           = dword ptr -4
.text$mn:00007A8C
.text$mn:00007A8C                 push    ebp
.text$mn:00007A8D                 mov     ebp, esp
.text$mn:00007A8F                 push    ecx
.text$mn:00007A90                 mov     [ebp+var_4], ecx
.text$mn:00007A93                 mov     eax, [ebp+var_4]
.text$mn:00007A96                 mov     edx, [eax]
.text$mn:00007A98                 mov     ecx, [ebp+var_4]
.text$mn:00007A9B                 mov     eax, [edx+34h]
.text$mn:00007A9E                 call    eax
.text$mn:00007AA0                 mov     esp, ebp
.text$mn:00007AA2                 pop     ebp
.text$mn:00007AA3                 retn
.text$mn:00007AA3 ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ endp
.text$mn:00007AA3
.text$mn:00007AA3 _text$mn        ends
.text$mn:00007AA3
.text$mn:00007AA4 ; ===========================================================================
.text$mn:00007AA4
.text$mn:00007AA4 ; Segment type: Pure code
.text$mn:00007AA4 ; Segment permissions: Read/Execute
.text$mn:00007AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00007AA4                 assume cs:_text$mn
.text$mn:00007AA4                 ;org 7AA4h
.text$mn:00007AA4 ; COMDAT (pick any)
.text$mn:00007AA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AA4
.text$mn:00007AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AA4
.text$mn:00007AA4 ; Attributes: bp-based frame
.text$mn:00007AA4
.text$mn:00007AA4 ; public: class std::basic_streambuf<char, struct std::char_traits<char>> * __thiscall std::basic_ios<char, struct std::char_traits<char>>::rdbuf(void)const
.text$mn:00007AA4                 public ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
.text$mn:00007AA4 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ proc near
.text$mn:00007AA4                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_istream<char,std::char_traits<char>> &)+24p
.text$mn:00007AA4                                         ; std::basic_istream<char,std::char_traits<char>>::_Sentry_base::_Sentry_base(std::basic_istream<char,std::char_traits<char>> &)+40p ...
.text$mn:00007AA4
.text$mn:00007AA4 var_4           = dword ptr -4
.text$mn:00007AA4
.text$mn:00007AA4                 push    ebp
.text$mn:00007AA5                 mov     ebp, esp
.text$mn:00007AA7                 push    ecx
.text$mn:00007AA8                 mov     [ebp+var_4], ecx
.text$mn:00007AAB                 mov     eax, [ebp+var_4]
.text$mn:00007AAE                 mov     eax, [eax+38h]
.text$mn:00007AB1                 mov     esp, ebp
.text$mn:00007AB3                 pop     ebp
.text$mn:00007AB4                 retn
.text$mn:00007AB4 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ endp
.text$mn:00007AB4
.text$mn:00007AB4 ; ---------------------------------------------------------------------------
.text$mn:00007AB5                 align 4
.text$mn:00007AB5 _text$mn        ends
.text$mn:00007AB5
.text$mn:00007AB8 ; ===========================================================================
.text$mn:00007AB8
.text$mn:00007AB8 ; Segment type: Pure code
.text$mn:00007AB8 ; Segment permissions: Read/Execute
.text$mn:00007AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00007AB8                 assume cs:_text$mn
.text$mn:00007AB8                 ;org 7AB8h
.text$mn:00007AB8 ; COMDAT (pick any)
.text$mn:00007AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AB8
.text$mn:00007AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AB8
.text$mn:00007AB8 ; Attributes: bp-based frame
.text$mn:00007AB8
.text$mn:00007AB8 ; int __thiscall std::ios_base::rdstate(std::ios_base *__hidden this)
.text$mn:00007AB8                 public ?rdstate@ios_base@std@@QBEHXZ
.text$mn:00007AB8 ?rdstate@ios_base@std@@QBEHXZ proc near ; CODE XREF: std::ios_base::good(void)+Cp
.text$mn:00007AB8                                         ; std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)+15p
.text$mn:00007AB8
.text$mn:00007AB8 var_4           = dword ptr -4
.text$mn:00007AB8
.text$mn:00007AB8                 push    ebp
.text$mn:00007AB9                 mov     ebp, esp
.text$mn:00007ABB                 push    ecx
.text$mn:00007ABC                 mov     [ebp+var_4], ecx
.text$mn:00007ABF                 mov     eax, [ebp+var_4]
.text$mn:00007AC2                 mov     eax, [eax+0Ch]
.text$mn:00007AC5                 mov     esp, ebp
.text$mn:00007AC7                 pop     ebp
.text$mn:00007AC8                 retn
.text$mn:00007AC8 ?rdstate@ios_base@std@@QBEHXZ endp
.text$mn:00007AC8
.text$mn:00007AC8 ; ---------------------------------------------------------------------------
.text$mn:00007AC9                 align 4
.text$mn:00007AC9 _text$mn        ends
.text$mn:00007AC9
.text$mn:00007ACC ; ===========================================================================
.text$mn:00007ACC
.text$mn:00007ACC ; Segment type: Pure code
.text$mn:00007ACC ; Segment permissions: Read/Execute
.text$mn:00007ACC _text$mn        segment para public 'CODE' use32
.text$mn:00007ACC                 assume cs:_text$mn
.text$mn:00007ACC                 ;org 7ACCh
.text$mn:00007ACC ; COMDAT (pick any)
.text$mn:00007ACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007ACC
.text$mn:00007ACC ; =============== S U B R O U T I N E =======================================
.text$mn:00007ACC
.text$mn:00007ACC ; Attributes: bp-based frame
.text$mn:00007ACC
.text$mn:00007ACC ; public: int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::sbumpc(void)
.text$mn:00007ACC                 public ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007ACC ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ proc near
.text$mn:00007ACC                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::get(void)+DBp
.text$mn:00007ACC                                         ; std::basic_streambuf<char,std::char_traits<char>>::snextc(void)+3Ep
.text$mn:00007ACC
.text$mn:00007ACC var_10          = dword ptr -10h
.text$mn:00007ACC var_C           = dword ptr -0Ch
.text$mn:00007ACC var_8           = dword ptr -8
.text$mn:00007ACC var_4           = dword ptr -4
.text$mn:00007ACC
.text$mn:00007ACC                 push    ebp
.text$mn:00007ACD                 mov     ebp, esp
.text$mn:00007ACF                 sub     esp, 10h
.text$mn:00007AD2                 mov     [ebp+var_4], ecx
.text$mn:00007AD5                 mov     ecx, [ebp+var_4]
.text$mn:00007AD8                 call    ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Gnavail(void)
.text$mn:00007ADD                 mov     [ebp+var_10], eax
.text$mn:00007AE0                 mov     [ebp+var_C], edx
.text$mn:00007AE3                 cmp     [ebp+var_C], 0
.text$mn:00007AE7                 jl      short loc_7B07
.text$mn:00007AE9                 jg      short loc_7AF1
.text$mn:00007AEB                 cmp     [ebp+var_10], 0
.text$mn:00007AEF                 jbe     short loc_7B07
.text$mn:00007AF1
.text$mn:00007AF1 loc_7AF1:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::sbumpc(void)+1Dj
.text$mn:00007AF1                 mov     ecx, [ebp+var_4]
.text$mn:00007AF4                 call    ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Gninc(void)
.text$mn:00007AF9                 push    eax
.text$mn:00007AFA                 call    ?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type(char const &)
.text$mn:00007AFF                 add     esp, 4
.text$mn:00007B02                 mov     [ebp+var_8], eax
.text$mn:00007B05                 jmp     short loc_7B17
.text$mn:00007B07 ; ---------------------------------------------------------------------------
.text$mn:00007B07
.text$mn:00007B07 loc_7B07:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::sbumpc(void)+1Bj
.text$mn:00007B07                                         ; std::basic_streambuf<char,std::char_traits<char>>::sbumpc(void)+23j
.text$mn:00007B07                 mov     eax, [ebp+var_4]
.text$mn:00007B0A                 mov     edx, [eax]
.text$mn:00007B0C                 mov     ecx, [ebp+var_4]
.text$mn:00007B0F                 mov     eax, [edx+1Ch]
.text$mn:00007B12                 call    eax
.text$mn:00007B14                 mov     [ebp+var_8], eax
.text$mn:00007B17
.text$mn:00007B17 loc_7B17:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::sbumpc(void)+39j
.text$mn:00007B17                 mov     eax, [ebp+var_8]
.text$mn:00007B1A                 mov     esp, ebp
.text$mn:00007B1C                 pop     ebp
.text$mn:00007B1D                 retn
.text$mn:00007B1D ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ endp
.text$mn:00007B1D
.text$mn:00007B1D ; ---------------------------------------------------------------------------
.text$mn:00007B1E                 align 10h
.text$mn:00007B1E _text$mn        ends
.text$mn:00007B1E
.text$mn:00007B20 ; ===========================================================================
.text$mn:00007B20
.text$mn:00007B20 ; Segment type: Pure code
.text$mn:00007B20 ; Segment permissions: Read/Execute
.text$mn:00007B20 _text$mn        segment para public 'CODE' use32
.text$mn:00007B20                 assume cs:_text$mn
.text$mn:00007B20                 ;org 7B20h
.text$mn:00007B20 ; COMDAT (pick any)
.text$mn:00007B20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B20
.text$mn:00007B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B20
.text$mn:00007B20 ; Attributes: bp-based frame
.text$mn:00007B20
.text$mn:00007B20 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_Wrap_alloc<class std::allocator<char>>::select_on_container_copy_construction(void)const
.text$mn:00007B20                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ
.text$mn:00007B20 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00007B20                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+3Ap
.text$mn:00007B20
.text$mn:00007B20 var_8           = dword ptr -8
.text$mn:00007B20 var_1           = byte ptr -1
.text$mn:00007B20 arg_0           = dword ptr  8
.text$mn:00007B20
.text$mn:00007B20                 push    ebp
.text$mn:00007B21                 mov     ebp, esp
.text$mn:00007B23                 sub     esp, 8
.text$mn:00007B26                 mov     [ebp+var_8], ecx
.text$mn:00007B29                 mov     eax, [ebp+var_8]
.text$mn:00007B2C                 push    eax
.text$mn:00007B2D                 lea     ecx, [ebp+var_1]
.text$mn:00007B30                 push    ecx
.text$mn:00007B31                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char>>::select_on_container_copy_construction(std::allocator<char> const &)
.text$mn:00007B36                 add     esp, 8
.text$mn:00007B39                 push    eax
.text$mn:00007B3A                 mov     ecx, [ebp+arg_0]
.text$mn:00007B3D                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(std::allocator<char> const &)
.text$mn:00007B42                 mov     eax, [ebp+arg_0]
.text$mn:00007B45                 mov     esp, ebp
.text$mn:00007B47                 pop     ebp
.text$mn:00007B48                 retn    4
.text$mn:00007B48 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ endp
.text$mn:00007B48
.text$mn:00007B48 ; ---------------------------------------------------------------------------
.text$mn:00007B4B                 align 4
.text$mn:00007B4B _text$mn        ends
.text$mn:00007B4B
.text$mn:00007B4C ; ===========================================================================
.text$mn:00007B4C
.text$mn:00007B4C ; Segment type: Pure code
.text$mn:00007B4C ; Segment permissions: Read/Execute
.text$mn:00007B4C _text$mn        segment para public 'CODE' use32
.text$mn:00007B4C                 assume cs:_text$mn
.text$mn:00007B4C                 ;org 7B4Ch
.text$mn:00007B4C ; COMDAT (pick any)
.text$mn:00007B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B4C
.text$mn:00007B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00007B4C
.text$mn:00007B4C ; Attributes: bp-based frame
.text$mn:00007B4C
.text$mn:00007B4C ; public: class std::allocator<char> __thiscall std::allocator<char>::select_on_container_copy_construction(void)const
.text$mn:00007B4C                 public ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ
.text$mn:00007B4C ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ proc near
.text$mn:00007B4C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::select_on_container_copy_construction(std::allocator<char> const &)+Ap
.text$mn:00007B4C
.text$mn:00007B4C var_4           = dword ptr -4
.text$mn:00007B4C arg_0           = dword ptr  8
.text$mn:00007B4C
.text$mn:00007B4C                 push    ebp
.text$mn:00007B4D                 mov     ebp, esp
.text$mn:00007B4F                 push    ecx
.text$mn:00007B50                 mov     [ebp+var_4], ecx
.text$mn:00007B53                 mov     eax, [ebp+var_4]
.text$mn:00007B56                 push    eax
.text$mn:00007B57                 mov     ecx, [ebp+arg_0]
.text$mn:00007B5A                 call    ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>(std::allocator<char> const &)
.text$mn:00007B5F                 mov     eax, [ebp+arg_0]
.text$mn:00007B62                 mov     esp, ebp
.text$mn:00007B64                 pop     ebp
.text$mn:00007B65                 retn    4
.text$mn:00007B65 ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ endp
.text$mn:00007B65
.text$mn:00007B65 _text$mn        ends
.text$mn:00007B65
.text$mn:00007B68 ; ===========================================================================
.text$mn:00007B68
.text$mn:00007B68 ; Segment type: Pure code
.text$mn:00007B68 ; Segment permissions: Read/Execute
.text$mn:00007B68 _text$mn        segment para public 'CODE' use32
.text$mn:00007B68                 assume cs:_text$mn
.text$mn:00007B68                 ;org 7B68h
.text$mn:00007B68 ; COMDAT (pick any)
.text$mn:00007B68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B68
.text$mn:00007B68 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B68
.text$mn:00007B68 ; Attributes: bp-based frame
.text$mn:00007B68
.text$mn:00007B68 ; public: static class std::allocator<char> __cdecl std::allocator_traits<class std::allocator<char>>::select_on_container_copy_construction(class std::allocator<char> const &)
.text$mn:00007B68                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
.text$mn:00007B68 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z proc near
.text$mn:00007B68                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::select_on_container_copy_construction(void)+11p
.text$mn:00007B68
.text$mn:00007B68 arg_0           = dword ptr  8
.text$mn:00007B68 arg_4           = dword ptr  0Ch
.text$mn:00007B68
.text$mn:00007B68                 push    ebp
.text$mn:00007B69                 mov     ebp, esp
.text$mn:00007B6B                 mov     eax, [ebp+arg_0]
.text$mn:00007B6E                 push    eax
.text$mn:00007B6F                 mov     ecx, [ebp+arg_4]
.text$mn:00007B72                 call    ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction(void)
.text$mn:00007B77                 mov     eax, [ebp+arg_0]
.text$mn:00007B7A                 pop     ebp
.text$mn:00007B7B                 retn
.text$mn:00007B7B ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z endp
.text$mn:00007B7B
.text$mn:00007B7B _text$mn        ends
.text$mn:00007B7B
.text$mn:00007B7C ; ===========================================================================
.text$mn:00007B7C
.text$mn:00007B7C ; Segment type: Pure code
.text$mn:00007B7C ; Segment permissions: Read/Execute
.text$mn:00007B7C _text$mn        segment para public 'CODE' use32
.text$mn:00007B7C                 assume cs:_text$mn
.text$mn:00007B7C                 ;org 7B7Ch
.text$mn:00007B7C ; COMDAT (pick any)
.text$mn:00007B7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B7C
.text$mn:00007B7C ; =============== S U B R O U T I N E =======================================
.text$mn:00007B7C
.text$mn:00007B7C ; Attributes: bp-based frame
.text$mn:00007B7C
.text$mn:00007B7C ; public: void __thiscall std::basic_ios<char, struct std::char_traits<char>>::setstate(int, bool)
.text$mn:00007B7C                 public ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
.text$mn:00007B7C ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z proc near
.text$mn:00007B7C                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+14Dp
.text$mn:00007B7C                                         ; __catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0+11p ...
.text$mn:00007B7C
.text$mn:00007B7C var_4           = dword ptr -4
.text$mn:00007B7C arg_0           = dword ptr  8
.text$mn:00007B7C arg_4           = byte ptr  0Ch
.text$mn:00007B7C
.text$mn:00007B7C                 push    ebp
.text$mn:00007B7D                 mov     ebp, esp
.text$mn:00007B7F                 push    ecx
.text$mn:00007B80                 mov     [ebp+var_4], ecx
.text$mn:00007B83                 cmp     [ebp+arg_0], 0
.text$mn:00007B87                 jz      short loc_7BA2
.text$mn:00007B89                 movzx   eax, [ebp+arg_4]
.text$mn:00007B8D                 push    eax
.text$mn:00007B8E                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007B91                 call    ?rdstate@ios_base@std@@QBEHXZ ; std::ios_base::rdstate(void)
.text$mn:00007B96                 or      eax, [ebp+arg_0]
.text$mn:00007B99                 push    eax
.text$mn:00007B9A                 mov     ecx, [ebp+var_4]
.text$mn:00007B9D                 call    ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char>>::clear(int,bool)
.text$mn:00007BA2
.text$mn:00007BA2 loc_7BA2:                               ; CODE XREF: std::basic_ios<char,std::char_traits<char>>::setstate(int,bool)+Bj
.text$mn:00007BA2                 mov     esp, ebp
.text$mn:00007BA4                 pop     ebp
.text$mn:00007BA5                 retn    8
.text$mn:00007BA5 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z endp
.text$mn:00007BA5
.text$mn:00007BA5 _text$mn        ends
.text$mn:00007BA5
.text$mn:00007BA8 ; ===========================================================================
.text$mn:00007BA8
.text$mn:00007BA8 ; Segment type: Pure code
.text$mn:00007BA8 ; Segment permissions: Read/Execute
.text$mn:00007BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00007BA8                 assume cs:_text$mn
.text$mn:00007BA8                 ;org 7BA8h
.text$mn:00007BA8 ; COMDAT (pick any)
.text$mn:00007BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BA8
.text$mn:00007BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BA8
.text$mn:00007BA8 ; Attributes: bp-based frame
.text$mn:00007BA8
.text$mn:00007BA8 ; public: int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::sgetc(void)
.text$mn:00007BA8                 public ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007BA8 ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ proc near
.text$mn:00007BA8                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+F9p
.text$mn:00007BA8                                         ; std::basic_istream<char,std::char_traits<char>>::get(void)+97p ...
.text$mn:00007BA8
.text$mn:00007BA8 var_10          = dword ptr -10h
.text$mn:00007BA8 var_C           = dword ptr -0Ch
.text$mn:00007BA8 var_8           = dword ptr -8
.text$mn:00007BA8 var_4           = dword ptr -4
.text$mn:00007BA8
.text$mn:00007BA8                 push    ebp
.text$mn:00007BA9                 mov     ebp, esp
.text$mn:00007BAB                 sub     esp, 10h
.text$mn:00007BAE                 mov     [ebp+var_4], ecx
.text$mn:00007BB1                 mov     ecx, [ebp+var_4]
.text$mn:00007BB4                 call    ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Gnavail(void)
.text$mn:00007BB9                 mov     [ebp+var_10], eax
.text$mn:00007BBC                 mov     [ebp+var_C], edx
.text$mn:00007BBF                 cmp     [ebp+var_C], 0
.text$mn:00007BC3                 jl      short loc_7BE3
.text$mn:00007BC5                 jg      short loc_7BCD
.text$mn:00007BC7                 cmp     [ebp+var_10], 0
.text$mn:00007BCB                 jbe     short loc_7BE3
.text$mn:00007BCD
.text$mn:00007BCD loc_7BCD:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)+1Dj
.text$mn:00007BCD                 mov     ecx, [ebp+var_4]
.text$mn:00007BD0                 call    ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::gptr(void)
.text$mn:00007BD5                 push    eax
.text$mn:00007BD6                 call    ?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type(char const &)
.text$mn:00007BDB                 add     esp, 4
.text$mn:00007BDE                 mov     [ebp+var_8], eax
.text$mn:00007BE1                 jmp     short loc_7BF3
.text$mn:00007BE3 ; ---------------------------------------------------------------------------
.text$mn:00007BE3
.text$mn:00007BE3 loc_7BE3:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)+1Bj
.text$mn:00007BE3                                         ; std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)+23j
.text$mn:00007BE3                 mov     eax, [ebp+var_4]
.text$mn:00007BE6                 mov     edx, [eax]
.text$mn:00007BE8                 mov     ecx, [ebp+var_4]
.text$mn:00007BEB                 mov     eax, [edx+18h]
.text$mn:00007BEE                 call    eax
.text$mn:00007BF0                 mov     [ebp+var_8], eax
.text$mn:00007BF3
.text$mn:00007BF3 loc_7BF3:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)+39j
.text$mn:00007BF3                 mov     eax, [ebp+var_8]
.text$mn:00007BF6                 mov     esp, ebp
.text$mn:00007BF8                 pop     ebp
.text$mn:00007BF9                 retn
.text$mn:00007BF9 ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ endp
.text$mn:00007BF9
.text$mn:00007BF9 ; ---------------------------------------------------------------------------
.text$mn:00007BFA                 align 4
.text$mn:00007BFA _text$mn        ends
.text$mn:00007BFA
.text$mn:00007BFC ; ===========================================================================
.text$mn:00007BFC
.text$mn:00007BFC ; Segment type: Pure code
.text$mn:00007BFC ; Segment permissions: Read/Execute
.text$mn:00007BFC _text$mn        segment para public 'CODE' use32
.text$mn:00007BFC                 assume cs:_text$mn
.text$mn:00007BFC                 ;org 7BFCh
.text$mn:00007BFC ; COMDAT (pick any)
.text$mn:00007BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BFC
.text$mn:00007BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00007BFC
.text$mn:00007BFC ; Attributes: bp-based frame
.text$mn:00007BFC
.text$mn:00007BFC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00007BFC                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00007BFC ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00007BFC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00007BFC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p ...
.text$mn:00007BFC
.text$mn:00007BFC var_4           = dword ptr -4
.text$mn:00007BFC
.text$mn:00007BFC                 push    ebp
.text$mn:00007BFD                 mov     ebp, esp
.text$mn:00007BFF                 push    ecx
.text$mn:00007C00                 mov     [ebp+var_4], ecx
.text$mn:00007C03                 mov     eax, [ebp+var_4]
.text$mn:00007C06                 mov     eax, [eax+14h]
.text$mn:00007C09                 mov     esp, ebp
.text$mn:00007C0B                 pop     ebp
.text$mn:00007C0C                 retn
.text$mn:00007C0C ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00007C0C
.text$mn:00007C0C ; ---------------------------------------------------------------------------
.text$mn:00007C0D                 align 10h
.text$mn:00007C0D _text$mn        ends
.text$mn:00007C0D
.text$mn:00007C10 ; ===========================================================================
.text$mn:00007C10
.text$mn:00007C10 ; Segment type: Pure code
.text$mn:00007C10 ; Segment permissions: Read/Execute
.text$mn:00007C10 _text$mn        segment para public 'CODE' use32
.text$mn:00007C10                 assume cs:_text$mn
.text$mn:00007C10                 ;org 7C10h
.text$mn:00007C10 ; COMDAT (pick any)
.text$mn:00007C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C10
.text$mn:00007C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C10
.text$mn:00007C10 ; Attributes: bp-based frame
.text$mn:00007C10
.text$mn:00007C10 ; public: int __thiscall std::basic_streambuf<char, struct std::char_traits<char>>::snextc(void)
.text$mn:00007C10                 public ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
.text$mn:00007C10 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ proc near
.text$mn:00007C10                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+115p
.text$mn:00007C10
.text$mn:00007C10 var_1C          = dword ptr -1Ch
.text$mn:00007C10 var_18          = dword ptr -18h
.text$mn:00007C10 var_14          = dword ptr -14h
.text$mn:00007C10 var_10          = dword ptr -10h
.text$mn:00007C10 var_C           = dword ptr -0Ch
.text$mn:00007C10 var_8           = dword ptr -8
.text$mn:00007C10 var_4           = dword ptr -4
.text$mn:00007C10
.text$mn:00007C10                 push    ebp
.text$mn:00007C11                 mov     ebp, esp
.text$mn:00007C13                 sub     esp, 1Ch
.text$mn:00007C16                 mov     [ebp+var_4], ecx
.text$mn:00007C19                 mov     ecx, [ebp+var_4]
.text$mn:00007C1C                 call    ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Gnavail(void)
.text$mn:00007C21                 mov     [ebp+var_1C], eax
.text$mn:00007C24                 mov     [ebp+var_18], edx
.text$mn:00007C27                 cmp     [ebp+var_18], 0
.text$mn:00007C2B                 jl      short loc_7C4B
.text$mn:00007C2D                 jg      short loc_7C35
.text$mn:00007C2F                 cmp     [ebp+var_1C], 1
.text$mn:00007C33                 jbe     short loc_7C4B
.text$mn:00007C35
.text$mn:00007C35 loc_7C35:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::snextc(void)+1Dj
.text$mn:00007C35                 mov     ecx, [ebp+var_4]
.text$mn:00007C38                 call    ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char>>::_Gnpreinc(void)
.text$mn:00007C3D                 push    eax
.text$mn:00007C3E                 call    ?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type(char const &)
.text$mn:00007C43                 add     esp, 4
.text$mn:00007C46                 mov     [ebp+var_C], eax
.text$mn:00007C49                 jmp     short loc_7C90
.text$mn:00007C4B ; ---------------------------------------------------------------------------
.text$mn:00007C4B
.text$mn:00007C4B loc_7C4B:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::snextc(void)+1Bj
.text$mn:00007C4B                                         ; std::basic_streambuf<char,std::char_traits<char>>::snextc(void)+23j
.text$mn:00007C4B                 mov     ecx, [ebp+var_4]
.text$mn:00007C4E                 call    ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::sbumpc(void)
.text$mn:00007C53                 mov     [ebp+var_10], eax
.text$mn:00007C56                 call    ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof(void)
.text$mn:00007C5B                 mov     [ebp+var_14], eax
.text$mn:00007C5E                 lea     eax, [ebp+var_10]
.text$mn:00007C61                 push    eax
.text$mn:00007C62                 lea     ecx, [ebp+var_14]
.text$mn:00007C65                 push    ecx
.text$mn:00007C66                 call    ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type(int const &,int const &)
.text$mn:00007C6B                 add     esp, 8
.text$mn:00007C6E                 movzx   edx, al
.text$mn:00007C71                 test    edx, edx
.text$mn:00007C73                 jz      short loc_7C7F
.text$mn:00007C75                 call    ?eof@?$char_traits@D@std@@SAHXZ ; std::char_traits<char>::eof(void)
.text$mn:00007C7A                 mov     [ebp+var_8], eax
.text$mn:00007C7D                 jmp     short loc_7C8A
.text$mn:00007C7F ; ---------------------------------------------------------------------------
.text$mn:00007C7F
.text$mn:00007C7F loc_7C7F:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::snextc(void)+63j
.text$mn:00007C7F                 mov     ecx, [ebp+var_4]
.text$mn:00007C82                 call    ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)
.text$mn:00007C87                 mov     [ebp+var_8], eax
.text$mn:00007C8A
.text$mn:00007C8A loc_7C8A:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::snextc(void)+6Dj
.text$mn:00007C8A                 mov     eax, [ebp+var_8]
.text$mn:00007C8D                 mov     [ebp+var_C], eax
.text$mn:00007C90
.text$mn:00007C90 loc_7C90:                               ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::snextc(void)+39j
.text$mn:00007C90                 mov     eax, [ebp+var_C]
.text$mn:00007C93                 mov     esp, ebp
.text$mn:00007C95                 pop     ebp
.text$mn:00007C96                 retn
.text$mn:00007C96 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ endp
.text$mn:00007C96
.text$mn:00007C96 ; ---------------------------------------------------------------------------
.text$mn:00007C97                 align 4
.text$mn:00007C97 _text$mn        ends
.text$mn:00007C97
.text$mn:00007C98 ; ===========================================================================
.text$mn:00007C98
.text$mn:00007C98 ; Segment type: Pure code
.text$mn:00007C98 ; Segment permissions: Read/Execute
.text$mn:00007C98 _text$mn        segment para public 'CODE' use32
.text$mn:00007C98                 assume cs:_text$mn
.text$mn:00007C98                 ;org 7C98h
.text$mn:00007C98 ; COMDAT (pick any)
.text$mn:00007C98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C98
.text$mn:00007C98 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C98
.text$mn:00007C98 ; Attributes: bp-based frame
.text$mn:00007C98
.text$mn:00007C98 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00007C98                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00007C98 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00007C98                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_6DECp
.text$mn:00007C98                 push    ebp
.text$mn:00007C99                 mov     ebp, esp
.text$mn:00007C9B                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00007CA0                 pop     ebp
.text$mn:00007CA1                 retn
.text$mn:00007CA1 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00007CA1
.text$mn:00007CA1 ; ---------------------------------------------------------------------------
.text$mn:00007CA2                 align 4
.text$mn:00007CA2 _text$mn        ends
.text$mn:00007CA2
.text$mn:00007CA4 ; ===========================================================================
.text$mn:00007CA4
.text$mn:00007CA4 ; Segment type: Pure code
.text$mn:00007CA4 ; Segment permissions: Read/Execute
.text$mn:00007CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00007CA4                 assume cs:_text$mn
.text$mn:00007CA4                 ;org 7CA4h
.text$mn:00007CA4 ; COMDAT (pick any)
.text$mn:00007CA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CA4
.text$mn:00007CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CA4
.text$mn:00007CA4 ; Attributes: bp-based frame
.text$mn:00007CA4
.text$mn:00007CA4 ; public: class std::basic_ostream<char, struct std::char_traits<char>> * __thiscall std::basic_ios<char, struct std::char_traits<char>>::tie(void)const
.text$mn:00007CA4                 public ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
.text$mn:00007CA4 ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ proc near
.text$mn:00007CA4                                         ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+5Bp
.text$mn:00007CA4                                         ; std::basic_ostream<char,std::char_traits<char>>::sentry::sentry(std::basic_ostream<char,std::char_traits<char>> &)+71p ...
.text$mn:00007CA4
.text$mn:00007CA4 var_4           = dword ptr -4
.text$mn:00007CA4
.text$mn:00007CA4                 push    ebp
.text$mn:00007CA5                 mov     ebp, esp
.text$mn:00007CA7                 push    ecx
.text$mn:00007CA8                 mov     [ebp+var_4], ecx
.text$mn:00007CAB                 mov     eax, [ebp+var_4]
.text$mn:00007CAE                 mov     eax, [eax+3Ch]
.text$mn:00007CB1                 mov     esp, ebp
.text$mn:00007CB3                 pop     ebp
.text$mn:00007CB4                 retn
.text$mn:00007CB4 ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ endp
.text$mn:00007CB4
.text$mn:00007CB4 ; ---------------------------------------------------------------------------
.text$mn:00007CB5                 align 4
.text$mn:00007CB5 _text$mn        ends
.text$mn:00007CB5
.text$mn:00007CB8 ; ===========================================================================
.text$mn:00007CB8
.text$mn:00007CB8 ; Segment type: Pure code
.text$mn:00007CB8 ; Segment permissions: Read/Execute
.text$mn:00007CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00007CB8                 assume cs:_text$mn
.text$mn:00007CB8                 ;org 7CB8h
.text$mn:00007CB8 ; COMDAT (pick any)
.text$mn:00007CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CB8
.text$mn:00007CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CB8
.text$mn:00007CB8 ; Attributes: bp-based frame
.text$mn:00007CB8
.text$mn:00007CB8 ; public: static char __cdecl std::char_traits<char>::to_char_type(int const &)
.text$mn:00007CB8                 public ?to_char_type@?$char_traits@D@std@@SADABH@Z
.text$mn:00007CB8 ?to_char_type@?$char_traits@D@std@@SADABH@Z proc near
.text$mn:00007CB8                                         ; CODE XREF: std::basic_istream<char,std::char_traits<char>>::_Ipfx(bool)+15Ap
.text$mn:00007CB8
.text$mn:00007CB8 arg_0           = dword ptr  8
.text$mn:00007CB8
.text$mn:00007CB8                 push    ebp
.text$mn:00007CB9                 mov     ebp, esp
.text$mn:00007CBB                 mov     eax, [ebp+arg_0]
.text$mn:00007CBE                 mov     al, [eax]
.text$mn:00007CC0                 pop     ebp
.text$mn:00007CC1                 retn
.text$mn:00007CC1 ?to_char_type@?$char_traits@D@std@@SADABH@Z endp
.text$mn:00007CC1
.text$mn:00007CC1 ; ---------------------------------------------------------------------------
.text$mn:00007CC2                 align 4
.text$mn:00007CC2 _text$mn        ends
.text$mn:00007CC2
.text$mn:00007CC4 ; ===========================================================================
.text$mn:00007CC4
.text$mn:00007CC4 ; Segment type: Pure code
.text$mn:00007CC4 ; Segment permissions: Read/Execute
.text$mn:00007CC4 _text$mn        segment para public 'CODE' use32
.text$mn:00007CC4                 assume cs:_text$mn
.text$mn:00007CC4                 ;org 7CC4h
.text$mn:00007CC4 ; COMDAT (pick any)
.text$mn:00007CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CC4
.text$mn:00007CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CC4
.text$mn:00007CC4 ; Attributes: bp-based frame
.text$mn:00007CC4
.text$mn:00007CC4 ; public: static int __cdecl std::char_traits<char>::to_int_type(char const &)
.text$mn:00007CC4                 public ?to_int_type@?$char_traits@D@std@@SAHABD@Z
.text$mn:00007CC4 ?to_int_type@?$char_traits@D@std@@SAHABD@Z proc near
.text$mn:00007CC4                                         ; CODE XREF: std::basic_streambuf<char,std::char_traits<char>>::sbumpc(void)+2Ep
.text$mn:00007CC4                                         ; std::basic_streambuf<char,std::char_traits<char>>::sgetc(void)+2Ep ...
.text$mn:00007CC4
.text$mn:00007CC4 arg_0           = dword ptr  8
.text$mn:00007CC4
.text$mn:00007CC4                 push    ebp
.text$mn:00007CC5                 mov     ebp, esp
.text$mn:00007CC7                 mov     eax, [ebp+arg_0]
.text$mn:00007CCA                 movzx   eax, byte ptr [eax]
.text$mn:00007CCD                 pop     ebp
.text$mn:00007CCE                 retn
.text$mn:00007CCE ?to_int_type@?$char_traits@D@std@@SAHABD@Z endp
.text$mn:00007CCE
.text$mn:00007CCE ; ---------------------------------------------------------------------------
.text$mn:00007CCF                 align 10h
.text$mn:00007CCF _text$mn        ends
.text$mn:00007CCF
.text$mn:00007CD0 ; ===========================================================================
.text$mn:00007CD0
.text$mn:00007CD0 ; Segment type: Pure code
.text$mn:00007CD0 ; Segment permissions: Read/Execute
.text$mn:00007CD0 _text$mn        segment para public 'CODE' use32
.text$mn:00007CD0                 assume cs:_text$mn
.text$mn:00007CD0                 ;org 7CD0h
.text$mn:00007CD0 ; COMDAT (pick any)
.text$mn:00007CD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CD0
.text$mn:00007CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CD0
.text$mn:00007CD0 ; Attributes: bp-based frame
.text$mn:00007CD0
.text$mn:00007CD0 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00007CD0                 public ?value@error_code@std@@QBEHXZ
.text$mn:00007CD0 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00007CD0                                         ; std::error_code::message(void)+3Dp
.text$mn:00007CD0
.text$mn:00007CD0 var_4           = dword ptr -4
.text$mn:00007CD0
.text$mn:00007CD0                 push    ebp
.text$mn:00007CD1                 mov     ebp, esp
.text$mn:00007CD3                 push    ecx
.text$mn:00007CD4                 mov     [ebp+var_4], ecx
.text$mn:00007CD7                 mov     eax, [ebp+var_4]
.text$mn:00007CDA                 mov     eax, [eax]
.text$mn:00007CDC                 mov     esp, ebp
.text$mn:00007CDE                 pop     ebp
.text$mn:00007CDF                 retn
.text$mn:00007CDF ?value@error_code@std@@QBEHXZ endp
.text$mn:00007CDF
.text$mn:00007CDF _text$mn        ends
.text$mn:00007CDF
.text$mn:00007CE0 ; ===========================================================================
.text$mn:00007CE0
.text$mn:00007CE0 ; Segment type: Pure code
.text$mn:00007CE0 ; Segment permissions: Read/Execute
.text$mn:00007CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00007CE0                 assume cs:_text$mn
.text$mn:00007CE0                 ;org 7CE0h
.text$mn:00007CE0 ; COMDAT (pick any)
.text$mn:00007CE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CE0
.text$mn:00007CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CE0
.text$mn:00007CE0 ; Attributes: bp-based frame
.text$mn:00007CE0
.text$mn:00007CE0 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00007CE0                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00007CE0 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00007CE0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00007CE0                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00007CE0
.text$mn:00007CE0 var_4           = dword ptr -4
.text$mn:00007CE0
.text$mn:00007CE0                 push    ebp
.text$mn:00007CE1                 mov     ebp, esp
.text$mn:00007CE3                 push    ecx
.text$mn:00007CE4                 mov     [ebp+var_4], ecx
.text$mn:00007CE7                 mov     eax, [ebp+var_4]
.text$mn:00007CEA                 mov     eax, [eax]
.text$mn:00007CEC                 mov     esp, ebp
.text$mn:00007CEE                 pop     ebp
.text$mn:00007CEF                 retn
.text$mn:00007CEF ?value@error_condition@std@@QBEHXZ endp
.text$mn:00007CEF
.text$mn:00007CEF _text$mn        ends
.text$mn:00007CEF
.text$mn:00007CF0 ; ===========================================================================
.text$mn:00007CF0
.text$mn:00007CF0 ; Segment type: Pure code
.text$mn:00007CF0 ; Segment permissions: Read/Execute
.text$mn:00007CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00007CF0                 assume cs:_text$mn
.text$mn:00007CF0                 ;org 7CF0h
.text$mn:00007CF0 ; COMDAT (pick any)
.text$mn:00007CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CF0
.text$mn:00007CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CF0
.text$mn:00007CF0 ; Attributes: bp-based frame
.text$mn:00007CF0
.text$mn:00007CF0                 public _hypot
.text$mn:00007CF0 _hypot          proc near
.text$mn:00007CF0
.text$mn:00007CF0 var_10          = qword ptr -10h
.text$mn:00007CF0 var_8           = qword ptr -8
.text$mn:00007CF0 arg_0           = qword ptr  8
.text$mn:00007CF0 arg_8           = qword ptr  10h
.text$mn:00007CF0
.text$mn:00007CF0                 push    ebp
.text$mn:00007CF1                 mov     ebp, esp
.text$mn:00007CF3                 sub     esp, 8
.text$mn:00007CF6                 movsd   xmm0, [ebp+arg_8]
.text$mn:00007CFB                 movsd   [esp+8+var_8], xmm0
.text$mn:00007D00                 sub     esp, 8
.text$mn:00007D03                 movsd   xmm0, [ebp+arg_0]
.text$mn:00007D08                 movsd   [esp+10h+var_10], xmm0
.text$mn:00007D0D                 call    __hypot
.text$mn:00007D12                 add     esp, 10h
.text$mn:00007D15                 pop     ebp
.text$mn:00007D16                 retn
.text$mn:00007D16 _hypot          endp
.text$mn:00007D16
.text$mn:00007D16 ; ---------------------------------------------------------------------------
.text$mn:00007D17                 align 4
.text$mn:00007D17 _text$mn        ends
.text$mn:00007D17
.xdata$x:00007D18 ; ===========================================================================
.xdata$x:00007D18
.xdata$x:00007D18 ; Segment type: Pure data
.xdata$x:00007D18 ; Segment permissions: Read
.xdata$x:00007D18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007D18                 assume cs:_xdata$x
.xdata$x:00007D18                 ;org 7D18h
.xdata$x:00007D18 ; COMDAT (pick associative to section at 63CC)
.xdata$x:00007D18 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00007D18                                         ; DATA XREF: .xdata$x:00007D28o
.xdata$x:00007D19                 db 0FFh
.xdata$x:00007D1A                 db 0FFh
.xdata$x:00007D1B                 db 0FFh
.xdata$x:00007D1C                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00007D20 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00007D20                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00007D21                 db    5
.xdata$x:00007D22                 db  93h ; Ã´
.xdata$x:00007D23                 db  19h
.xdata$x:00007D24                 db    1
.xdata$x:00007D25                 db    0
.xdata$x:00007D26                 db    0
.xdata$x:00007D27                 db    0
.xdata$x:00007D28                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00007D2C                 db    0
.xdata$x:00007D2D                 db    0
.xdata$x:00007D2E                 db    0
.xdata$x:00007D2F                 db    0
.xdata$x:00007D30                 db    0
.xdata$x:00007D31                 db    0
.xdata$x:00007D32                 db    0
.xdata$x:00007D33                 db    0
.xdata$x:00007D34                 db    0
.xdata$x:00007D35                 db    0
.xdata$x:00007D36                 db    0
.xdata$x:00007D37                 db    0
.xdata$x:00007D38                 db    0
.xdata$x:00007D39                 db    0
.xdata$x:00007D3A                 db    0
.xdata$x:00007D3B                 db    0
.xdata$x:00007D3C                 db    0
.xdata$x:00007D3D                 db    0
.xdata$x:00007D3E                 db    0
.xdata$x:00007D3F                 db    0
.xdata$x:00007D40                 db    0
.xdata$x:00007D41                 db    0
.xdata$x:00007D42                 db    0
.xdata$x:00007D43                 db    0
.xdata$x:00007D43 _xdata$x        ends
.xdata$x:00007D43
.xdata$x:00007D44 ; ===========================================================================
.xdata$x:00007D44
.xdata$x:00007D44 ; Segment type: Pure data
.xdata$x:00007D44 ; Segment permissions: Read
.xdata$x:00007D44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007D44                 assume cs:_xdata$x
.xdata$x:00007D44                 ;org 7D44h
.xdata$x:00007D44 ; COMDAT (pick associative to section at 2FAC)
.xdata$x:00007D44 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007D44                                         ; DATA XREF: .xdata$x:00007D54o
.xdata$x:00007D45                 db 0FFh
.xdata$x:00007D46                 db 0FFh
.xdata$x:00007D47                 db 0FFh
.xdata$x:00007D48                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00007D4C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007D4C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00007D4D                 db    5
.xdata$x:00007D4E                 db  93h ; Ã´
.xdata$x:00007D4F                 db  19h
.xdata$x:00007D50                 db    1
.xdata$x:00007D51                 db    0
.xdata$x:00007D52                 db    0
.xdata$x:00007D53                 db    0
.xdata$x:00007D54                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00007D58                 db    0
.xdata$x:00007D59                 db    0
.xdata$x:00007D5A                 db    0
.xdata$x:00007D5B                 db    0
.xdata$x:00007D5C                 db    0
.xdata$x:00007D5D                 db    0
.xdata$x:00007D5E                 db    0
.xdata$x:00007D5F                 db    0
.xdata$x:00007D60                 db    0
.xdata$x:00007D61                 db    0
.xdata$x:00007D62                 db    0
.xdata$x:00007D63                 db    0
.xdata$x:00007D64                 db    0
.xdata$x:00007D65                 db    0
.xdata$x:00007D66                 db    0
.xdata$x:00007D67                 db    0
.xdata$x:00007D68                 db    0
.xdata$x:00007D69                 db    0
.xdata$x:00007D6A                 db    0
.xdata$x:00007D6B                 db    0
.xdata$x:00007D6C                 db    0
.xdata$x:00007D6D                 db    0
.xdata$x:00007D6E                 db    0
.xdata$x:00007D6F                 db    0
.xdata$x:00007D6F _xdata$x        ends
.xdata$x:00007D6F
.xdata$x:00007D70 ; ===========================================================================
.xdata$x:00007D70
.xdata$x:00007D70 ; Segment type: Pure data
.xdata$x:00007D70 ; Segment permissions: Read
.xdata$x:00007D70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007D70                 assume cs:_xdata$x
.xdata$x:00007D70                 ;org 7D70h
.xdata$x:00007D70 ; COMDAT (pick associative to section at 44A8)
.xdata$x:00007D70 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007D70                                         ; DATA XREF: .xdata$x:00007D80o
.xdata$x:00007D71                 db 0FFh
.xdata$x:00007D72                 db 0FFh
.xdata$x:00007D73                 db 0FFh
.xdata$x:00007D74                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00007D78 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007D78                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00007D79                 db    5
.xdata$x:00007D7A                 db  93h ; Ã´
.xdata$x:00007D7B                 db  19h
.xdata$x:00007D7C                 db    1
.xdata$x:00007D7D                 db    0
.xdata$x:00007D7E                 db    0
.xdata$x:00007D7F                 db    0
.xdata$x:00007D80                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00007D84                 db    0
.xdata$x:00007D85                 db    0
.xdata$x:00007D86                 db    0
.xdata$x:00007D87                 db    0
.xdata$x:00007D88                 db    0
.xdata$x:00007D89                 db    0
.xdata$x:00007D8A                 db    0
.xdata$x:00007D8B                 db    0
.xdata$x:00007D8C                 db    0
.xdata$x:00007D8D                 db    0
.xdata$x:00007D8E                 db    0
.xdata$x:00007D8F                 db    0
.xdata$x:00007D90                 db    0
.xdata$x:00007D91                 db    0
.xdata$x:00007D92                 db    0
.xdata$x:00007D93                 db    0
.xdata$x:00007D94                 db    0
.xdata$x:00007D95                 db    0
.xdata$x:00007D96                 db    0
.xdata$x:00007D97                 db    0
.xdata$x:00007D98                 db    0
.xdata$x:00007D99                 db    0
.xdata$x:00007D9A                 db    0
.xdata$x:00007D9B                 db    0
.xdata$x:00007D9B _xdata$x        ends
.xdata$x:00007D9B
.xdata$x:00007D9C ; ===========================================================================
.xdata$x:00007D9C
.xdata$x:00007D9C ; Segment type: Pure data
.xdata$x:00007D9C ; Segment permissions: Read
.xdata$x:00007D9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007D9C                 assume cs:_xdata$x
.xdata$x:00007D9C                 ;org 7D9Ch
.xdata$x:00007D9C ; COMDAT (pick associative to section at 2F30)
.xdata$x:00007D9C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00007D9C                                         ; DATA XREF: .xdata$x:00007DACo
.xdata$x:00007D9D                 db 0FFh
.xdata$x:00007D9E                 db 0FFh
.xdata$x:00007D9F                 db 0FFh
.xdata$x:00007DA0                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00007DA4 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00007DA4                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00007DA5                 db    5
.xdata$x:00007DA6                 db  93h ; Ã´
.xdata$x:00007DA7                 db  19h
.xdata$x:00007DA8                 db    1
.xdata$x:00007DA9                 db    0
.xdata$x:00007DAA                 db    0
.xdata$x:00007DAB                 db    0
.xdata$x:00007DAC                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00007DB0                 db    0
.xdata$x:00007DB1                 db    0
.xdata$x:00007DB2                 db    0
.xdata$x:00007DB3                 db    0
.xdata$x:00007DB4                 db    0
.xdata$x:00007DB5                 db    0
.xdata$x:00007DB6                 db    0
.xdata$x:00007DB7                 db    0
.xdata$x:00007DB8                 db    0
.xdata$x:00007DB9                 db    0
.xdata$x:00007DBA                 db    0
.xdata$x:00007DBB                 db    0
.xdata$x:00007DBC                 db    0
.xdata$x:00007DBD                 db    0
.xdata$x:00007DBE                 db    0
.xdata$x:00007DBF                 db    0
.xdata$x:00007DC0                 db    0
.xdata$x:00007DC1                 db    0
.xdata$x:00007DC2                 db    0
.xdata$x:00007DC3                 db    0
.xdata$x:00007DC4                 db    0
.xdata$x:00007DC5                 db    0
.xdata$x:00007DC6                 db    0
.xdata$x:00007DC7                 db    0
.xdata$x:00007DC7 _xdata$x        ends
.xdata$x:00007DC7
.xdata$x:00007DC8 ; ===========================================================================
.xdata$x:00007DC8
.xdata$x:00007DC8 ; Segment type: Pure data
.xdata$x:00007DC8 ; Segment permissions: Read
.xdata$x:00007DC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007DC8                 assume cs:_xdata$x
.xdata$x:00007DC8                 ;org 7DC8h
.xdata$x:00007DC8 ; COMDAT (pick associative to section at 4430)
.xdata$x:00007DC8 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007DC8                                         ; DATA XREF: .xdata$x:00007DD8o
.xdata$x:00007DC9                 db 0FFh
.xdata$x:00007DCA                 db 0FFh
.xdata$x:00007DCB                 db 0FFh
.xdata$x:00007DCC                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00007DD0 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007DD0                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00007DD1                 db    5
.xdata$x:00007DD2                 db  93h ; Ã´
.xdata$x:00007DD3                 db  19h
.xdata$x:00007DD4                 db    1
.xdata$x:00007DD5                 db    0
.xdata$x:00007DD6                 db    0
.xdata$x:00007DD7                 db    0
.xdata$x:00007DD8                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00007DDC                 db    0
.xdata$x:00007DDD                 db    0
.xdata$x:00007DDE                 db    0
.xdata$x:00007DDF                 db    0
.xdata$x:00007DE0                 db    0
.xdata$x:00007DE1                 db    0
.xdata$x:00007DE2                 db    0
.xdata$x:00007DE3                 db    0
.xdata$x:00007DE4                 db    0
.xdata$x:00007DE5                 db    0
.xdata$x:00007DE6                 db    0
.xdata$x:00007DE7                 db    0
.xdata$x:00007DE8                 db    0
.xdata$x:00007DE9                 db    0
.xdata$x:00007DEA                 db    0
.xdata$x:00007DEB                 db    0
.xdata$x:00007DEC                 db    0
.xdata$x:00007DED                 db    0
.xdata$x:00007DEE                 db    0
.xdata$x:00007DEF                 db    0
.xdata$x:00007DF0                 db    0
.xdata$x:00007DF1                 db    0
.xdata$x:00007DF2                 db    0
.xdata$x:00007DF3                 db    0
.xdata$x:00007DF3 _xdata$x        ends
.xdata$x:00007DF3
.xdata$x:00007DF4 ; ===========================================================================
.xdata$x:00007DF4
.xdata$x:00007DF4 ; Segment type: Pure data
.xdata$x:00007DF4 ; Segment permissions: Read
.xdata$x:00007DF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007DF4                 assume cs:_xdata$x
.xdata$x:00007DF4                 ;org 7DF4h
.xdata$x:00007DF4 ; COMDAT (pick associative to section at 317C)
.xdata$x:00007DF4 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00007DF4                                         ; DATA XREF: .xdata$x:00007E04o
.xdata$x:00007DF5                 db 0FFh
.xdata$x:00007DF6                 db 0FFh
.xdata$x:00007DF7                 db 0FFh
.xdata$x:00007DF8                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
.xdata$x:00007DFC __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00007DFC                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:00007DFD                 db    5
.xdata$x:00007DFE                 db  93h ; Ã´
.xdata$x:00007DFF                 db  19h
.xdata$x:00007E00                 db    1
.xdata$x:00007E01                 db    0
.xdata$x:00007E02                 db    0
.xdata$x:00007E03                 db    0
.xdata$x:00007E04                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
.xdata$x:00007E08                 align 20h
.xdata$x:00007E08 _xdata$x        ends
.xdata$x:00007E08
.xdata$x:00007E20 ; ===========================================================================
.xdata$x:00007E20
.xdata$x:00007E20 ; Segment type: Pure data
.xdata$x:00007E20 ; Segment permissions: Read
.xdata$x:00007E20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007E20                 assume cs:_xdata$x
.xdata$x:00007E20                 ;org 7E20h
.xdata$x:00007E20 ; COMDAT (pick associative to section at 32C4)
.xdata$x:00007E20 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00007E20                                         ; DATA XREF: .xdata$x:00007E30o
.xdata$x:00007E21                 db 0FFh
.xdata$x:00007E22                 db 0FFh
.xdata$x:00007E23                 db 0FFh
.xdata$x:00007E24                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00007E28 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00007E28                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00007E29                 db    5
.xdata$x:00007E2A                 db  93h ; Ã´
.xdata$x:00007E2B                 db  19h
.xdata$x:00007E2C                 db    1
.xdata$x:00007E2D                 db    0
.xdata$x:00007E2E                 db    0
.xdata$x:00007E2F                 db    0
.xdata$x:00007E30                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00007E34                 db    0
.xdata$x:00007E35                 db    0
.xdata$x:00007E36                 db    0
.xdata$x:00007E37                 db    0
.xdata$x:00007E38                 db    0
.xdata$x:00007E39                 db    0
.xdata$x:00007E3A                 db    0
.xdata$x:00007E3B                 db    0
.xdata$x:00007E3C                 db    0
.xdata$x:00007E3D                 db    0
.xdata$x:00007E3E                 db    0
.xdata$x:00007E3F                 db    0
.xdata$x:00007E40                 db    0
.xdata$x:00007E41                 db    0
.xdata$x:00007E42                 db    0
.xdata$x:00007E43                 db    0
.xdata$x:00007E44                 db    0
.xdata$x:00007E45                 db    0
.xdata$x:00007E46                 db    0
.xdata$x:00007E47                 db    0
.xdata$x:00007E48                 db    0
.xdata$x:00007E49                 db    0
.xdata$x:00007E4A                 db    0
.xdata$x:00007E4B                 db    0
.xdata$x:00007E4B _xdata$x        ends
.xdata$x:00007E4B
.xdata$x:00007E4C ; ===========================================================================
.xdata$x:00007E4C
.xdata$x:00007E4C ; Segment type: Pure data
.xdata$x:00007E4C ; Segment permissions: Read
.xdata$x:00007E4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007E4C                 assume cs:_xdata$x
.xdata$x:00007E4C                 ;org 7E4Ch
.xdata$x:00007E4C ; COMDAT (pick associative to section at 322C)
.xdata$x:00007E4C __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00007E4C                                         ; DATA XREF: .xdata$x:00007E5Co
.xdata$x:00007E4D                 db 0FFh
.xdata$x:00007E4E                 db 0FFh
.xdata$x:00007E4F                 db 0FFh
.xdata$x:00007E50                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00007E54 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00007E54                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00007E55                 db    5
.xdata$x:00007E56                 db  93h ; Ã´
.xdata$x:00007E57                 db  19h
.xdata$x:00007E58                 db    1
.xdata$x:00007E59                 db    0
.xdata$x:00007E5A                 db    0
.xdata$x:00007E5B                 db    0
.xdata$x:00007E5C                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00007E60                 db    0
.xdata$x:00007E61                 db    0
.xdata$x:00007E62                 db    0
.xdata$x:00007E63                 db    0
.xdata$x:00007E64                 db    0
.xdata$x:00007E65                 db    0
.xdata$x:00007E66                 db    0
.xdata$x:00007E67                 db    0
.xdata$x:00007E68                 db    0
.xdata$x:00007E69                 db    0
.xdata$x:00007E6A                 db    0
.xdata$x:00007E6B                 db    0
.xdata$x:00007E6C                 db    0
.xdata$x:00007E6D                 db    0
.xdata$x:00007E6E                 db    0
.xdata$x:00007E6F                 db    0
.xdata$x:00007E70                 db    0
.xdata$x:00007E71                 db    0
.xdata$x:00007E72                 db    0
.xdata$x:00007E73                 db    0
.xdata$x:00007E74                 db    0
.xdata$x:00007E75                 db    0
.xdata$x:00007E76                 db    0
.xdata$x:00007E77                 db    0
.xdata$x:00007E77 _xdata$x        ends
.xdata$x:00007E77
.xdata$x:00007E78 ; ===========================================================================
.xdata$x:00007E78
.xdata$x:00007E78 ; Segment type: Pure data
.xdata$x:00007E78 ; Segment permissions: Read
.xdata$x:00007E78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007E78                 assume cs:_xdata$x
.xdata$x:00007E78                 ;org 7E78h
.xdata$x:00007E78 ; COMDAT (pick associative to section at 30D8)
.xdata$x:00007E78 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:00007E78                                         ; DATA XREF: .xdata$x:00007E88o
.xdata$x:00007E79                 db 0FFh
.xdata$x:00007E7A                 db 0FFh
.xdata$x:00007E7B                 db 0FFh
.xdata$x:00007E7C                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0
.xdata$x:00007E80 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:00007E80                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:00007E81                 db    5
.xdata$x:00007E82                 db  93h ; Ã´
.xdata$x:00007E83                 db  19h
.xdata$x:00007E84                 db    1
.xdata$x:00007E85                 db    0
.xdata$x:00007E86                 db    0
.xdata$x:00007E87                 db    0
.xdata$x:00007E88                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
.xdata$x:00007E8C                 db    0
.xdata$x:00007E8D                 db    0
.xdata$x:00007E8E                 db    0
.xdata$x:00007E8F                 db    0
.xdata$x:00007E90                 db    0
.xdata$x:00007E91                 db    0
.xdata$x:00007E92                 db    0
.xdata$x:00007E93                 db    0
.xdata$x:00007E94                 db    0
.xdata$x:00007E95                 db    0
.xdata$x:00007E96                 db    0
.xdata$x:00007E97                 db    0
.xdata$x:00007E98                 db    0
.xdata$x:00007E99                 db    0
.xdata$x:00007E9A                 db    0
.xdata$x:00007E9B                 db    0
.xdata$x:00007E9C                 db    0
.xdata$x:00007E9D                 db    0
.xdata$x:00007E9E                 db    0
.xdata$x:00007E9F                 db    0
.xdata$x:00007EA0                 db    0
.xdata$x:00007EA1                 db    0
.xdata$x:00007EA2                 db    0
.xdata$x:00007EA3                 db    0
.xdata$x:00007EA3 _xdata$x        ends
.xdata$x:00007EA3
.xdata$x:00007EA4 ; ===========================================================================
.xdata$x:00007EA4
.xdata$x:00007EA4 ; Segment type: Pure data
.xdata$x:00007EA4 ; Segment permissions: Read
.xdata$x:00007EA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007EA4                 assume cs:_xdata$x
.xdata$x:00007EA4                 ;org 7EA4h
.xdata$x:00007EA4 ; COMDAT (pick associative to section at 4540)
.xdata$x:00007EA4 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00007EA4                                         ; DATA XREF: .xdata$x:00007EB4o
.xdata$x:00007EA5                 db 0FFh
.xdata$x:00007EA6                 db 0FFh
.xdata$x:00007EA7                 db 0FFh
.xdata$x:00007EA8                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00007EAC __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00007EAC                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00007EAD                 db    5
.xdata$x:00007EAE                 db  93h ; Ã´
.xdata$x:00007EAF                 db  19h
.xdata$x:00007EB0                 db    1
.xdata$x:00007EB1                 db    0
.xdata$x:00007EB2                 db    0
.xdata$x:00007EB3                 db    0
.xdata$x:00007EB4                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00007EB8                 db    0
.xdata$x:00007EB9                 db    0
.xdata$x:00007EBA                 db    0
.xdata$x:00007EBB                 db    0
.xdata$x:00007EBC                 db    0
.xdata$x:00007EBD                 db    0
.xdata$x:00007EBE                 db    0
.xdata$x:00007EBF                 db    0
.xdata$x:00007EC0                 db    0
.xdata$x:00007EC1                 db    0
.xdata$x:00007EC2                 db    0
.xdata$x:00007EC3                 db    0
.xdata$x:00007EC4                 db    0
.xdata$x:00007EC5                 db    0
.xdata$x:00007EC6                 db    0
.xdata$x:00007EC7                 db    0
.xdata$x:00007EC8                 db    0
.xdata$x:00007EC9                 db    0
.xdata$x:00007ECA                 db    0
.xdata$x:00007ECB                 db    0
.xdata$x:00007ECC                 db    0
.xdata$x:00007ECD                 db    0
.xdata$x:00007ECE                 db    0
.xdata$x:00007ECF                 db    0
.xdata$x:00007ECF _xdata$x        ends
.xdata$x:00007ECF
.xdata$x:00007ED0 ; ===========================================================================
.xdata$x:00007ED0
.xdata$x:00007ED0 ; Segment type: Pure data
.xdata$x:00007ED0 ; Segment permissions: Read
.xdata$x:00007ED0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007ED0                 assume cs:_xdata$x
.xdata$x:00007ED0                 ;org 7ED0h
.xdata$x:00007ED0 ; COMDAT (pick associative to section at 59B0)
.xdata$x:00007ED0 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00007ED0                                         ; DATA XREF: .xdata$x:00007F58o
.xdata$x:00007ED1                 db    0
.xdata$x:00007ED2                 db    0
.xdata$x:00007ED3                 db    0
.xdata$x:00007ED4                 db    0
.xdata$x:00007ED5                 db    0
.xdata$x:00007ED6                 db    0
.xdata$x:00007ED7                 db    0
.xdata$x:00007ED8                 db    0
.xdata$x:00007ED9                 db    0
.xdata$x:00007EDA                 db    0
.xdata$x:00007EDB                 db    0
.xdata$x:00007EDC                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00007EE0 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00007EE0                                         ; DATA XREF: .xdata$x:00007F44o
.xdata$x:00007EE1                 db    0
.xdata$x:00007EE2                 db    0
.xdata$x:00007EE3                 db    0
.xdata$x:00007EE4                 db    0
.xdata$x:00007EE5                 db    0
.xdata$x:00007EE6                 db    0
.xdata$x:00007EE7                 db    0
.xdata$x:00007EE8                 db    0
.xdata$x:00007EE9                 db    0
.xdata$x:00007EEA                 db    0
.xdata$x:00007EEB                 db    0
.xdata$x:00007EEC                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00007EF0 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00007EF0                                         ; DATA XREF: .xdata$x:00007F18o
.xdata$x:00007EF1                 db 0FFh
.xdata$x:00007EF2                 db 0FFh
.xdata$x:00007EF3                 db 0FFh
.xdata$x:00007EF4                 db    0
.xdata$x:00007EF5                 db    0
.xdata$x:00007EF6                 db    0
.xdata$x:00007EF7                 db    0
.xdata$x:00007EF8                 db 0FFh
.xdata$x:00007EF9                 db 0FFh
.xdata$x:00007EFA                 db 0FFh
.xdata$x:00007EFB                 db 0FFh
.xdata$x:00007EFC                 db    0
.xdata$x:00007EFD                 db    0
.xdata$x:00007EFE                 db    0
.xdata$x:00007EFF                 db    0
.xdata$x:00007F00                 db    1
.xdata$x:00007F01                 db    0
.xdata$x:00007F02                 db    0
.xdata$x:00007F03                 db    0
.xdata$x:00007F04                 db    0
.xdata$x:00007F05                 db    0
.xdata$x:00007F06                 db    0
.xdata$x:00007F07                 db    0
.xdata$x:00007F08                 db    1
.xdata$x:00007F09                 db    0
.xdata$x:00007F0A                 db    0
.xdata$x:00007F0B                 db    0
.xdata$x:00007F0C                 db    0
.xdata$x:00007F0D                 db    0
.xdata$x:00007F0E                 db    0
.xdata$x:00007F0F                 db    0
.xdata$x:00007F10 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00007F10                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00007F11                 db    5
.xdata$x:00007F12                 db  93h ; Ã´
.xdata$x:00007F13                 db  19h
.xdata$x:00007F14                 db    4
.xdata$x:00007F15                 db    0
.xdata$x:00007F16                 db    0
.xdata$x:00007F17                 db    0
.xdata$x:00007F18                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00007F1C                 db    2
.xdata$x:00007F1D                 db    0
.xdata$x:00007F1E                 db    0
.xdata$x:00007F1F                 db    0
.xdata$x:00007F20                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00007F24                 db    0
.xdata$x:00007F25                 db    0
.xdata$x:00007F26                 db    0
.xdata$x:00007F27                 db    0
.xdata$x:00007F28                 db    0
.xdata$x:00007F29                 db    0
.xdata$x:00007F2A                 db    0
.xdata$x:00007F2B                 db    0
.xdata$x:00007F2C                 db    0
.xdata$x:00007F2D                 db    0
.xdata$x:00007F2E                 db    0
.xdata$x:00007F2F                 db    0
.xdata$x:00007F30                 db    0
.xdata$x:00007F31                 db    0
.xdata$x:00007F32                 db    0
.xdata$x:00007F33                 db    0
.xdata$x:00007F34 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00007F34                                         ; DATA XREF: .xdata$x:00007F20o
.xdata$x:00007F35                 db    0
.xdata$x:00007F36                 db    0
.xdata$x:00007F37                 db    0
.xdata$x:00007F38                 db    2
.xdata$x:00007F39                 db    0
.xdata$x:00007F3A                 db    0
.xdata$x:00007F3B                 db    0
.xdata$x:00007F3C                 db    3
.xdata$x:00007F3D                 db    0
.xdata$x:00007F3E                 db    0
.xdata$x:00007F3F                 db    0
.xdata$x:00007F40                 db    1
.xdata$x:00007F41                 db    0
.xdata$x:00007F42                 db    0
.xdata$x:00007F43                 db    0
.xdata$x:00007F44                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00007F48                 align 10h
.xdata$x:00007F50                 db    3
.xdata$x:00007F51                 db    0
.xdata$x:00007F52                 db    0
.xdata$x:00007F53                 db    0
.xdata$x:00007F54                 db    1
.xdata$x:00007F55                 db    0
.xdata$x:00007F56                 db    0
.xdata$x:00007F57                 db    0
.xdata$x:00007F58                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00007F58 _xdata$x        ends
.xdata$x:00007F58
.xdata$x:00007F5C ; ===========================================================================
.xdata$x:00007F5C
.xdata$x:00007F5C ; Segment type: Pure data
.xdata$x:00007F5C ; Segment permissions: Read
.xdata$x:00007F5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007F5C                 assume cs:_xdata$x
.xdata$x:00007F5C                 ;org 7F5Ch
.xdata$x:00007F5C ; COMDAT (pick associative to section at 4058)
.xdata$x:00007F5C __unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z db 0FFh
.xdata$x:00007F5C                                         ; DATA XREF: .xdata$x:00007F6Co
.xdata$x:00007F5D                 db 0FFh
.xdata$x:00007F5E                 db 0FFh
.xdata$x:00007F5F                 db 0FFh
.xdata$x:00007F60                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
.xdata$x:00007F64 __ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z db  22h ; "
.xdata$x:00007F64                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z+11o
.xdata$x:00007F65                 db    5
.xdata$x:00007F66                 db  93h ; Ã´
.xdata$x:00007F67                 db  19h
.xdata$x:00007F68                 db    1
.xdata$x:00007F69                 db    0
.xdata$x:00007F6A                 db    0
.xdata$x:00007F6B                 db    0
.xdata$x:00007F6C                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
.xdata$x:00007F70                 db    0
.xdata$x:00007F71                 db    0
.xdata$x:00007F72                 db    0
.xdata$x:00007F73                 db    0
.xdata$x:00007F74                 db    0
.xdata$x:00007F75                 db    0
.xdata$x:00007F76                 db    0
.xdata$x:00007F77                 db    0
.xdata$x:00007F78                 db    0
.xdata$x:00007F79                 db    0
.xdata$x:00007F7A                 db    0
.xdata$x:00007F7B                 db    0
.xdata$x:00007F7C                 db    0
.xdata$x:00007F7D                 db    0
.xdata$x:00007F7E                 db    0
.xdata$x:00007F7F                 db    0
.xdata$x:00007F80                 db    0
.xdata$x:00007F81                 db    0
.xdata$x:00007F82                 db    0
.xdata$x:00007F83                 db    0
.xdata$x:00007F84                 db    0
.xdata$x:00007F85                 db    0
.xdata$x:00007F86                 db    0
.xdata$x:00007F87                 db    0
.xdata$x:00007F87 _xdata$x        ends
.xdata$x:00007F87
.xdata$x:00007F88 ; ===========================================================================
.xdata$x:00007F88
.xdata$x:00007F88 ; Segment type: Pure data
.xdata$x:00007F88 ; Segment permissions: Read
.xdata$x:00007F88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007F88                 assume cs:_xdata$x
.xdata$x:00007F88                 ;org 7F88h
.xdata$x:00007F88 ; COMDAT (pick associative to section at 40E8)
.xdata$x:00007F88 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00007F88                                         ; DATA XREF: .xdata$x:00007F98o
.xdata$x:00007F89                 db 0FFh
.xdata$x:00007F8A                 db 0FFh
.xdata$x:00007F8B                 db 0FFh
.xdata$x:00007F8C                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:00007F90 __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00007F90                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:00007F91                 db    5
.xdata$x:00007F92                 db  93h ; Ã´
.xdata$x:00007F93                 db  19h
.xdata$x:00007F94                 db    1
.xdata$x:00007F95                 db    0
.xdata$x:00007F96                 db    0
.xdata$x:00007F97                 db    0
.xdata$x:00007F98                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00007F9C                 db    0
.xdata$x:00007F9D                 db    0
.xdata$x:00007F9E                 db    0
.xdata$x:00007F9F                 db    0
.xdata$x:00007FA0                 db    0
.xdata$x:00007FA1                 db    0
.xdata$x:00007FA2                 db    0
.xdata$x:00007FA3                 db    0
.xdata$x:00007FA4                 db    0
.xdata$x:00007FA5                 db    0
.xdata$x:00007FA6                 db    0
.xdata$x:00007FA7                 db    0
.xdata$x:00007FA8                 db    0
.xdata$x:00007FA9                 db    0
.xdata$x:00007FAA                 db    0
.xdata$x:00007FAB                 db    0
.xdata$x:00007FAC                 db    0
.xdata$x:00007FAD                 db    0
.xdata$x:00007FAE                 db    0
.xdata$x:00007FAF                 db    0
.xdata$x:00007FB0                 db    0
.xdata$x:00007FB1                 db    0
.xdata$x:00007FB2                 db    0
.xdata$x:00007FB3                 db    0
.xdata$x:00007FB3 _xdata$x        ends
.xdata$x:00007FB3
.xdata$x:00007FB4 ; ===========================================================================
.xdata$x:00007FB4
.xdata$x:00007FB4 ; Segment type: Pure data
.xdata$x:00007FB4 ; Segment permissions: Read
.xdata$x:00007FB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007FB4                 assume cs:_xdata$x
.xdata$x:00007FB4                 ;org 7FB4h
.xdata$x:00007FB4 ; COMDAT (pick associative to section at 4E78)
.xdata$x:00007FB4 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:00007FB4                                         ; DATA XREF: .xdata$x:00007FC4o
.xdata$x:00007FB5                 db 0FFh
.xdata$x:00007FB6                 db 0FFh
.xdata$x:00007FB7                 db 0FFh
.xdata$x:00007FB8                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00007FBC __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00007FBC                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00007FBD                 db    5
.xdata$x:00007FBE                 db  93h ; Ã´
.xdata$x:00007FBF                 db  19h
.xdata$x:00007FC0                 db    1
.xdata$x:00007FC1                 db    0
.xdata$x:00007FC2                 db    0
.xdata$x:00007FC3                 db    0
.xdata$x:00007FC4                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:00007FC8                 align 20h
.xdata$x:00007FC8 _xdata$x        ends
.xdata$x:00007FC8
.xdata$x:00007FE0 ; ===========================================================================
.xdata$x:00007FE0
.xdata$x:00007FE0 ; Segment type: Pure data
.xdata$x:00007FE0 ; Segment permissions: Read
.xdata$x:00007FE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007FE0                 assume cs:_xdata$x
.xdata$x:00007FE0                 ;org 7FE0h
.xdata$x:00007FE0 ; COMDAT (pick associative to section at 3FD4)
.xdata$x:00007FE0 __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00007FE0                                         ; DATA XREF: .xdata$x:00007FF0o
.xdata$x:00007FE1                 db 0FFh
.xdata$x:00007FE2                 db 0FFh
.xdata$x:00007FE3                 db 0FFh
.xdata$x:00007FE4                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:00007FE8 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00007FE8                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:00007FE9                 db    5
.xdata$x:00007FEA                 db  93h ; Ã´
.xdata$x:00007FEB                 db  19h
.xdata$x:00007FEC                 db    1
.xdata$x:00007FED                 db    0
.xdata$x:00007FEE                 db    0
.xdata$x:00007FEF                 db    0
.xdata$x:00007FF0                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:00007FF4                 db    0
.xdata$x:00007FF5                 db    0
.xdata$x:00007FF6                 db    0
.xdata$x:00007FF7                 db    0
.xdata$x:00007FF8                 db    0
.xdata$x:00007FF9                 db    0
.xdata$x:00007FFA                 db    0
.xdata$x:00007FFB                 db    0
.xdata$x:00007FFC                 db    0
.xdata$x:00007FFD                 db    0
.xdata$x:00007FFE                 db    0
.xdata$x:00007FFF                 db    0
.xdata$x:00008000                 db    0
.xdata$x:00008001                 db    0
.xdata$x:00008002                 db    0
.xdata$x:00008003                 db    0
.xdata$x:00008004                 db    0
.xdata$x:00008005                 db    0
.xdata$x:00008006                 db    0
.xdata$x:00008007                 db    0
.xdata$x:00008008                 db    0
.xdata$x:00008009                 db    0
.xdata$x:0000800A                 db    0
.xdata$x:0000800B                 db    0
.xdata$x:0000800B _xdata$x        ends
.xdata$x:0000800B
.xdata$x:0000800C ; ===========================================================================
.xdata$x:0000800C
.xdata$x:0000800C ; Segment type: Pure data
.xdata$x:0000800C ; Segment permissions: Read
.xdata$x:0000800C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000800C                 assume cs:_xdata$x
.xdata$x:0000800C                 ;org 800Ch
.xdata$x:0000800C ; COMDAT (pick associative to section at 38E8)
.xdata$x:0000800C __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000800C                                         ; DATA XREF: __ehhandler$??0_Locinfo@std@@QAE@PBD@Z+11o
.xdata$x:0000800D                 db    5
.xdata$x:0000800E                 db  93h ; Ã´
.xdata$x:0000800F                 db  19h
.xdata$x:00008010                 db    7
.xdata$x:00008011                 db    0
.xdata$x:00008012                 db    0
.xdata$x:00008013                 db    0
.xdata$x:00008014                 dd offset __unwindtable$??0_Locinfo@std@@QAE@PBD@Z
.xdata$x:00008018                 db    0
.xdata$x:00008019                 db    0
.xdata$x:0000801A                 db    0
.xdata$x:0000801B                 db    0
.xdata$x:0000801C                 db    0
.xdata$x:0000801D                 db    0
.xdata$x:0000801E                 db    0
.xdata$x:0000801F                 db    0
.xdata$x:00008020                 db    0
.xdata$x:00008021                 db    0
.xdata$x:00008022                 db    0
.xdata$x:00008023                 db    0
.xdata$x:00008024                 db    0
.xdata$x:00008025                 db    0
.xdata$x:00008026                 db    0
.xdata$x:00008027                 db    0
.xdata$x:00008028                 db    0
.xdata$x:00008029                 db    0
.xdata$x:0000802A                 db    0
.xdata$x:0000802B                 db    0
.xdata$x:0000802C                 db    0
.xdata$x:0000802D                 db    0
.xdata$x:0000802E                 db    0
.xdata$x:0000802F                 db    0
.xdata$x:00008030 __unwindtable$??0_Locinfo@std@@QAE@PBD@Z db 0FFh
.xdata$x:00008030                                         ; DATA XREF: .xdata$x:00008014o
.xdata$x:00008031                 db 0FFh
.xdata$x:00008032                 db 0FFh
.xdata$x:00008033                 db 0FFh
.xdata$x:00008034                 dd offset __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
.xdata$x:00008038                 db    0
.xdata$x:00008039                 db    0
.xdata$x:0000803A                 db    0
.xdata$x:0000803B                 db    0
.xdata$x:0000803C                 dd offset __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
.xdata$x:00008040                 db    1
.xdata$x:00008041                 db    0
.xdata$x:00008042                 db    0
.xdata$x:00008043                 db    0
.xdata$x:00008044                 dd offset __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
.xdata$x:00008048                 db    2
.xdata$x:00008049                 db    0
.xdata$x:0000804A                 db    0
.xdata$x:0000804B                 db    0
.xdata$x:0000804C                 dd offset __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
.xdata$x:00008050                 db    3
.xdata$x:00008051                 db    0
.xdata$x:00008052                 db    0
.xdata$x:00008053                 db    0
.xdata$x:00008054                 dd offset __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
.xdata$x:00008058                 db    4
.xdata$x:00008059                 db    0
.xdata$x:0000805A                 db    0
.xdata$x:0000805B                 db    0
.xdata$x:0000805C                 dd offset __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
.xdata$x:00008060                 db    5
.xdata$x:00008061                 db    0
.xdata$x:00008062                 db    0
.xdata$x:00008063                 db    0
.xdata$x:00008064                 dd offset __unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
.xdata$x:00008064 _xdata$x        ends
.xdata$x:00008064
.xdata$x:00008068 ; ===========================================================================
.xdata$x:00008068
.xdata$x:00008068 ; Segment type: Pure data
.xdata$x:00008068 ; Segment permissions: Read
.xdata$x:00008068 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008068                 assume cs:_xdata$x
.xdata$x:00008068                 ;org 8068h
.xdata$x:00008068 ; COMDAT (pick associative to section at 4A30)
.xdata$x:00008068 __ehfuncinfo$??1_Locinfo@std@@QAE@XZ db  22h ; "
.xdata$x:00008068                                         ; DATA XREF: __ehhandler$??1_Locinfo@std@@QAE@XZ+11o
.xdata$x:00008069                 db    5
.xdata$x:0000806A                 db  93h ; Ã´
.xdata$x:0000806B                 db  19h
.xdata$x:0000806C                 db    7
.xdata$x:0000806D                 db    0
.xdata$x:0000806E                 db    0
.xdata$x:0000806F                 db    0
.xdata$x:00008070                 dd offset __unwindtable$??1_Locinfo@std@@QAE@XZ
.xdata$x:00008074                 db    0
.xdata$x:00008075                 db    0
.xdata$x:00008076                 db    0
.xdata$x:00008077                 db    0
.xdata$x:00008078                 db    0
.xdata$x:00008079                 db    0
.xdata$x:0000807A                 db    0
.xdata$x:0000807B                 db    0
.xdata$x:0000807C                 db    0
.xdata$x:0000807D                 db    0
.xdata$x:0000807E                 db    0
.xdata$x:0000807F                 db    0
.xdata$x:00008080                 db    0
.xdata$x:00008081                 db    0
.xdata$x:00008082                 db    0
.xdata$x:00008083                 db    0
.xdata$x:00008084                 db    0
.xdata$x:00008085                 db    0
.xdata$x:00008086                 db    0
.xdata$x:00008087                 db    0
.xdata$x:00008088                 db    0
.xdata$x:00008089                 db    0
.xdata$x:0000808A                 db    0
.xdata$x:0000808B                 db    0
.xdata$x:0000808C __unwindtable$??1_Locinfo@std@@QAE@XZ db 0FFh
.xdata$x:0000808C                                         ; DATA XREF: .xdata$x:00008070o
.xdata$x:0000808D                 db 0FFh
.xdata$x:0000808E                 db 0FFh
.xdata$x:0000808F                 db 0FFh
.xdata$x:00008090                 dd offset __unwindfunclet$??1_Locinfo@std@@QAE@XZ$0
.xdata$x:00008094                 align 8
.xdata$x:00008098                 dd offset __unwindfunclet$??1_Locinfo@std@@QAE@XZ$1
.xdata$x:0000809C                 db    1
.xdata$x:0000809D                 db    0
.xdata$x:0000809E                 db    0
.xdata$x:0000809F                 db    0
.xdata$x:000080A0                 dd offset __unwindfunclet$??1_Locinfo@std@@QAE@XZ$2
.xdata$x:000080A4                 db    2
.xdata$x:000080A5                 db    0
.xdata$x:000080A6                 db    0
.xdata$x:000080A7                 db    0
.xdata$x:000080A8                 dd offset __unwindfunclet$??1_Locinfo@std@@QAE@XZ$3
.xdata$x:000080AC                 db    3
.xdata$x:000080AD                 db    0
.xdata$x:000080AE                 db    0
.xdata$x:000080AF                 db    0
.xdata$x:000080B0                 dd offset __unwindfunclet$??1_Locinfo@std@@QAE@XZ$4
.xdata$x:000080B4                 db    4
.xdata$x:000080B5                 db    0
.xdata$x:000080B6                 db    0
.xdata$x:000080B7                 db    0
.xdata$x:000080B8                 dd offset __unwindfunclet$??1_Locinfo@std@@QAE@XZ$5
.xdata$x:000080BC                 db    5
.xdata$x:000080BD                 db    0
.xdata$x:000080BE                 db    0
.xdata$x:000080BF                 db    0
.xdata$x:000080C0                 dd offset __unwindfunclet$??1_Locinfo@std@@QAE@XZ$6
.xdata$x:000080C0 _xdata$x        ends
.xdata$x:000080C0
.xdata$x:000080C4 ; ===========================================================================
.xdata$x:000080C4
.xdata$x:000080C4 ; Segment type: Pure data
.xdata$x:000080C4 ; Segment permissions: Read
.xdata$x:000080C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000080C4                 assume cs:_xdata$x
.xdata$x:000080C4                 ;org 80C4h
.xdata$x:000080C4 ; COMDAT (pick associative to section at 5188)
.xdata$x:000080C4 __unwindtable$??Bid@locale@std@@QAEIXZ db 0FFh
.xdata$x:000080C4                                         ; DATA XREF: .xdata$x:000080D4o
.xdata$x:000080C5                 db 0FFh
.xdata$x:000080C6                 db 0FFh
.xdata$x:000080C7                 db 0FFh
.xdata$x:000080C8                 dd offset __unwindfunclet$??Bid@locale@std@@QAEIXZ$0
.xdata$x:000080CC __ehfuncinfo$??Bid@locale@std@@QAEIXZ db  22h ; "
.xdata$x:000080CC                                         ; DATA XREF: __ehhandler$??Bid@locale@std@@QAEIXZ+11o
.xdata$x:000080CD                 db    5
.xdata$x:000080CE                 db  93h ; Ã´
.xdata$x:000080CF                 db  19h
.xdata$x:000080D0                 db    1
.xdata$x:000080D1                 db    0
.xdata$x:000080D2                 db    0
.xdata$x:000080D3                 db    0
.xdata$x:000080D4                 dd offset __unwindtable$??Bid@locale@std@@QAEIXZ
.xdata$x:000080D8                 db    0
.xdata$x:000080D9                 db    0
.xdata$x:000080DA                 db    0
.xdata$x:000080DB                 db    0
.xdata$x:000080DC                 db    0
.xdata$x:000080DD                 db    0
.xdata$x:000080DE                 db    0
.xdata$x:000080DF                 db    0
.xdata$x:000080E0                 db    0
.xdata$x:000080E1                 db    0
.xdata$x:000080E2                 db    0
.xdata$x:000080E3                 db    0
.xdata$x:000080E4                 db    0
.xdata$x:000080E5                 db    0
.xdata$x:000080E6                 db    0
.xdata$x:000080E7                 db    0
.xdata$x:000080E8                 db    0
.xdata$x:000080E9                 db    0
.xdata$x:000080EA                 db    0
.xdata$x:000080EB                 db    0
.xdata$x:000080EC                 db    0
.xdata$x:000080ED                 db    0
.xdata$x:000080EE                 db    0
.xdata$x:000080EF                 db    0
.xdata$x:000080EF _xdata$x        ends
.xdata$x:000080EF
.xdata$x:000080F0 ; ===========================================================================
.xdata$x:000080F0
.xdata$x:000080F0 ; Segment type: Pure data
.xdata$x:000080F0 ; Segment permissions: Read
.xdata$x:000080F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000080F0                 assume cs:_xdata$x
.xdata$x:000080F0                 ;org 80F0h
.xdata$x:000080F0 ; COMDAT (pick associative to section at 3DF0)
.xdata$x:000080F0 __unwindtable$??0facet@locale@std@@IAE@I@Z db 0FFh
.xdata$x:000080F0                                         ; DATA XREF: .xdata$x:00008100o
.xdata$x:000080F1                 db 0FFh
.xdata$x:000080F2                 db 0FFh
.xdata$x:000080F3                 db 0FFh
.xdata$x:000080F4                 dd offset __unwindfunclet$??0facet@locale@std@@IAE@I@Z$0
.xdata$x:000080F8 __ehfuncinfo$??0facet@locale@std@@IAE@I@Z db  22h ; "
.xdata$x:000080F8                                         ; DATA XREF: __ehhandler$??0facet@locale@std@@IAE@I@Z+11o
.xdata$x:000080F9                 db    5
.xdata$x:000080FA                 db  93h ; Ã´
.xdata$x:000080FB                 db  19h
.xdata$x:000080FC                 db    1
.xdata$x:000080FD                 db    0
.xdata$x:000080FE                 db    0
.xdata$x:000080FF                 db    0
.xdata$x:00008100                 dd offset __unwindtable$??0facet@locale@std@@IAE@I@Z
.xdata$x:00008104                 db    0
.xdata$x:00008105                 db    0
.xdata$x:00008106                 db    0
.xdata$x:00008107                 db    0
.xdata$x:00008108                 db    0
.xdata$x:00008109                 db    0
.xdata$x:0000810A                 db    0
.xdata$x:0000810B                 db    0
.xdata$x:0000810C                 db    0
.xdata$x:0000810D                 db    0
.xdata$x:0000810E                 db    0
.xdata$x:0000810F                 db    0
.xdata$x:00008110                 db    0
.xdata$x:00008111                 db    0
.xdata$x:00008112                 db    0
.xdata$x:00008113                 db    0
.xdata$x:00008114                 db    0
.xdata$x:00008115                 db    0
.xdata$x:00008116                 db    0
.xdata$x:00008117                 db    0
.xdata$x:00008118                 db    0
.xdata$x:00008119                 db    0
.xdata$x:0000811A                 db    0
.xdata$x:0000811B                 db    0
.xdata$x:0000811B _xdata$x        ends
.xdata$x:0000811B
.xdata$x:0000811C ; ===========================================================================
.xdata$x:0000811C
.xdata$x:0000811C ; Segment type: Pure data
.xdata$x:0000811C ; Segment permissions: Read
.xdata$x:0000811C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000811C                 assume cs:_xdata$x
.xdata$x:0000811C                 ;org 811Ch
.xdata$x:0000811C ; COMDAT (pick associative to section at 4D60)
.xdata$x:0000811C __unwindtable$??1facet@locale@std@@MAE@XZ db 0FFh
.xdata$x:0000811C                                         ; DATA XREF: .xdata$x:0000812Co
.xdata$x:0000811D                 db 0FFh
.xdata$x:0000811E                 db 0FFh
.xdata$x:0000811F                 db 0FFh
.xdata$x:00008120                 dd offset __unwindfunclet$??1facet@locale@std@@MAE@XZ$0
.xdata$x:00008124 __ehfuncinfo$??1facet@locale@std@@MAE@XZ db  22h ; "
.xdata$x:00008124                                         ; DATA XREF: __ehhandler$??1facet@locale@std@@MAE@XZ+11o
.xdata$x:00008125                 db    5
.xdata$x:00008126                 db  93h ; Ã´
.xdata$x:00008127                 db  19h
.xdata$x:00008128                 db    1
.xdata$x:00008129                 db    0
.xdata$x:0000812A                 db    0
.xdata$x:0000812B                 db    0
.xdata$x:0000812C                 dd offset __unwindtable$??1facet@locale@std@@MAE@XZ
.xdata$x:00008130                 db    0
.xdata$x:00008131                 db    0
.xdata$x:00008132                 db    0
.xdata$x:00008133                 db    0
.xdata$x:00008134                 db    0
.xdata$x:00008135                 db    0
.xdata$x:00008136                 db    0
.xdata$x:00008137                 db    0
.xdata$x:00008138                 db    0
.xdata$x:00008139                 db    0
.xdata$x:0000813A                 db    0
.xdata$x:0000813B                 db    0
.xdata$x:0000813C                 db    0
.xdata$x:0000813D                 db    0
.xdata$x:0000813E                 db    0
.xdata$x:0000813F                 db    0
.xdata$x:00008140                 db    0
.xdata$x:00008141                 db    0
.xdata$x:00008142                 db    0
.xdata$x:00008143                 db    0
.xdata$x:00008144                 db    0
.xdata$x:00008145                 db    0
.xdata$x:00008146                 db    0
.xdata$x:00008147                 db    0
.xdata$x:00008147 _xdata$x        ends
.xdata$x:00008147
.xdata$x:00008148 ; ===========================================================================
.xdata$x:00008148
.xdata$x:00008148 ; Segment type: Pure data
.xdata$x:00008148 ; Segment permissions: Read
.xdata$x:00008148 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008148                 assume cs:_xdata$x
.xdata$x:00008148                 ;org 8148h
.xdata$x:00008148 ; COMDAT (pick associative to section at 3D0C)
.xdata$x:00008148 __unwindtable$??0ctype_base@std@@QAE@I@Z db 0FFh
.xdata$x:00008148                                         ; DATA XREF: .xdata$x:00008158o
.xdata$x:00008149                 db 0FFh
.xdata$x:0000814A                 db 0FFh
.xdata$x:0000814B                 db 0FFh
.xdata$x:0000814C                 dd offset __unwindfunclet$??0ctype_base@std@@QAE@I@Z$0
.xdata$x:00008150 __ehfuncinfo$??0ctype_base@std@@QAE@I@Z db  22h ; "
.xdata$x:00008150                                         ; DATA XREF: __ehhandler$??0ctype_base@std@@QAE@I@Z+11o
.xdata$x:00008151                 db    5
.xdata$x:00008152                 db  93h ; Ã´
.xdata$x:00008153                 db  19h
.xdata$x:00008154                 db    1
.xdata$x:00008155                 db    0
.xdata$x:00008156                 db    0
.xdata$x:00008157                 db    0
.xdata$x:00008158                 dd offset __unwindtable$??0ctype_base@std@@QAE@I@Z
.xdata$x:0000815C                 db    0
.xdata$x:0000815D                 db    0
.xdata$x:0000815E                 db    0
.xdata$x:0000815F                 db    0
.xdata$x:00008160                 db    0
.xdata$x:00008161                 db    0
.xdata$x:00008162                 db    0
.xdata$x:00008163                 db    0
.xdata$x:00008164                 db    0
.xdata$x:00008165                 db    0
.xdata$x:00008166                 db    0
.xdata$x:00008167                 db    0
.xdata$x:00008168                 db    0
.xdata$x:00008169                 db    0
.xdata$x:0000816A                 db    0
.xdata$x:0000816B                 db    0
.xdata$x:0000816C                 db    0
.xdata$x:0000816D                 db    0
.xdata$x:0000816E                 db    0
.xdata$x:0000816F                 db    0
.xdata$x:00008170                 db    0
.xdata$x:00008171                 db    0
.xdata$x:00008172                 db    0
.xdata$x:00008173                 db    0
.xdata$x:00008173 _xdata$x        ends
.xdata$x:00008173
.xdata$x:00008174 ; ===========================================================================
.xdata$x:00008174
.xdata$x:00008174 ; Segment type: Pure data
.xdata$x:00008174 ; Segment permissions: Read
.xdata$x:00008174 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008174                 assume cs:_xdata$x
.xdata$x:00008174                 ;org 8174h
.xdata$x:00008174 ; COMDAT (pick associative to section at 4CD4)
.xdata$x:00008174 __unwindtable$??1ctype_base@std@@UAE@XZ db 0FFh
.xdata$x:00008174                                         ; DATA XREF: .xdata$x:00008184o
.xdata$x:00008175                 db 0FFh
.xdata$x:00008176                 db 0FFh
.xdata$x:00008177                 db 0FFh
.xdata$x:00008178                 dd offset __unwindfunclet$??1ctype_base@std@@UAE@XZ$0
.xdata$x:0000817C __ehfuncinfo$??1ctype_base@std@@UAE@XZ db  22h ; "
.xdata$x:0000817C                                         ; DATA XREF: __ehhandler$??1ctype_base@std@@UAE@XZ+11o
.xdata$x:0000817D                 db    5
.xdata$x:0000817E                 db  93h ; Ã´
.xdata$x:0000817F                 db  19h
.xdata$x:00008180                 db    1
.xdata$x:00008181                 db    0
.xdata$x:00008182                 db    0
.xdata$x:00008183                 db    0
.xdata$x:00008184                 dd offset __unwindtable$??1ctype_base@std@@UAE@XZ
.xdata$x:00008188                 align 20h
.xdata$x:00008188 _xdata$x        ends
.xdata$x:00008188
.xdata$x:000081A0 ; ===========================================================================
.xdata$x:000081A0
.xdata$x:000081A0 ; Segment type: Pure data
.xdata$x:000081A0 ; Segment permissions: Read
.xdata$x:000081A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000081A0                 assume cs:_xdata$x
.xdata$x:000081A0                 ;org 81A0h
.xdata$x:000081A0 ; COMDAT (pick associative to section at 3350)
.xdata$x:000081A0 __unwindtable$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z db 0FFh
.xdata$x:000081A0                                         ; DATA XREF: .xdata$x:000081B0o
.xdata$x:000081A1                 db 0FFh
.xdata$x:000081A2                 db 0FFh
.xdata$x:000081A3                 db 0FFh
.xdata$x:000081A4                 dd offset __unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0
.xdata$x:000081A8 __ehfuncinfo$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z db  22h ; "
.xdata$x:000081A8                                         ; DATA XREF: __ehhandler$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z+11o
.xdata$x:000081A9                 db    5
.xdata$x:000081AA                 db  93h ; Ã´
.xdata$x:000081AB                 db  19h
.xdata$x:000081AC                 db    1
.xdata$x:000081AD                 db    0
.xdata$x:000081AE                 db    0
.xdata$x:000081AF                 db    0
.xdata$x:000081B0                 dd offset __unwindtable$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
.xdata$x:000081B4                 db    0
.xdata$x:000081B5                 db    0
.xdata$x:000081B6                 db    0
.xdata$x:000081B7                 db    0
.xdata$x:000081B8                 db    0
.xdata$x:000081B9                 db    0
.xdata$x:000081BA                 db    0
.xdata$x:000081BB                 db    0
.xdata$x:000081BC                 db    0
.xdata$x:000081BD                 db    0
.xdata$x:000081BE                 db    0
.xdata$x:000081BF                 db    0
.xdata$x:000081C0                 db    0
.xdata$x:000081C1                 db    0
.xdata$x:000081C2                 db    0
.xdata$x:000081C3                 db    0
.xdata$x:000081C4                 db    0
.xdata$x:000081C5                 db    0
.xdata$x:000081C6                 db    0
.xdata$x:000081C7                 db    0
.xdata$x:000081C8                 db    0
.xdata$x:000081C9                 db    0
.xdata$x:000081CA                 db    0
.xdata$x:000081CB                 db    0
.xdata$x:000081CB _xdata$x        ends
.xdata$x:000081CB
.xdata$x:000081CC ; ===========================================================================
.xdata$x:000081CC
.xdata$x:000081CC ; Segment type: Pure data
.xdata$x:000081CC ; Segment permissions: Read
.xdata$x:000081CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000081CC                 assume cs:_xdata$x
.xdata$x:000081CC                 ;org 81CCh
.xdata$x:000081CC ; COMDAT (pick associative to section at 5C24)
.xdata$x:000081CC __unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z db 0FFh
.xdata$x:000081CC                                         ; DATA XREF: .xdata$x:000081ECo
.xdata$x:000081CD                 db 0FFh
.xdata$x:000081CE                 db 0FFh
.xdata$x:000081CF                 db 0FFh
.xdata$x:000081D0                 dd offset __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
.xdata$x:000081D4                 align 8
.xdata$x:000081D8                 dd offset __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
.xdata$x:000081DC                 db 0FFh
.xdata$x:000081DD                 db 0FFh
.xdata$x:000081DE                 db 0FFh
.xdata$x:000081DF                 db 0FFh
.xdata$x:000081E0                 dd offset __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
.xdata$x:000081E4 __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z db  22h ; "
.xdata$x:000081E4                                         ; DATA XREF: __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z+11o
.xdata$x:000081E5                 db    5
.xdata$x:000081E6                 db  93h ; Ã´
.xdata$x:000081E7                 db  19h
.xdata$x:000081E8                 db    3
.xdata$x:000081E9                 db    0
.xdata$x:000081EA                 db    0
.xdata$x:000081EB                 db    0
.xdata$x:000081EC                 dd offset __unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
.xdata$x:000081F0                 db    0
.xdata$x:000081F1                 db    0
.xdata$x:000081F2                 db    0
.xdata$x:000081F3                 db    0
.xdata$x:000081F4                 db    0
.xdata$x:000081F5                 db    0
.xdata$x:000081F6                 db    0
.xdata$x:000081F7                 db    0
.xdata$x:000081F8                 db    0
.xdata$x:000081F9                 db    0
.xdata$x:000081FA                 db    0
.xdata$x:000081FB                 db    0
.xdata$x:000081FC                 db    0
.xdata$x:000081FD                 db    0
.xdata$x:000081FE                 db    0
.xdata$x:000081FF                 db    0
.xdata$x:00008200                 db    0
.xdata$x:00008201                 db    0
.xdata$x:00008202                 db    0
.xdata$x:00008203                 db    0
.xdata$x:00008204                 db    0
.xdata$x:00008205                 db    0
.xdata$x:00008206                 db    0
.xdata$x:00008207                 db    0
.xdata$x:00008207 _xdata$x        ends
.xdata$x:00008207
.xdata$x:00008208 ; ===========================================================================
.xdata$x:00008208
.xdata$x:00008208 ; Segment type: Pure data
.xdata$x:00008208 ; Segment permissions: Read
.xdata$x:00008208 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008208                 assume cs:_xdata$x
.xdata$x:00008208                 ;org 8208h
.xdata$x:00008208 ; COMDAT (pick associative to section at 45BC)
.xdata$x:00008208 __unwindtable$??1?$ctype@D@std@@MAE@XZ db 0FFh
.xdata$x:00008208                                         ; DATA XREF: .xdata$x:00008218o
.xdata$x:00008209                 db 0FFh
.xdata$x:0000820A                 db 0FFh
.xdata$x:0000820B                 db 0FFh
.xdata$x:0000820C                 dd offset __unwindfunclet$??1?$ctype@D@std@@MAE@XZ$0
.xdata$x:00008210 __ehfuncinfo$??1?$ctype@D@std@@MAE@XZ db  22h ; "
.xdata$x:00008210                                         ; DATA XREF: __ehhandler$??1?$ctype@D@std@@MAE@XZ+11o
.xdata$x:00008211                 db    5
.xdata$x:00008212                 db  93h ; Ã´
.xdata$x:00008213                 db  19h
.xdata$x:00008214                 db    1
.xdata$x:00008215                 db    0
.xdata$x:00008216                 db    0
.xdata$x:00008217                 db    0
.xdata$x:00008218                 dd offset __unwindtable$??1?$ctype@D@std@@MAE@XZ
.xdata$x:0000821C                 db    0
.xdata$x:0000821D                 db    0
.xdata$x:0000821E                 db    0
.xdata$x:0000821F                 db    0
.xdata$x:00008220                 db    0
.xdata$x:00008221                 db    0
.xdata$x:00008222                 db    0
.xdata$x:00008223                 db    0
.xdata$x:00008224                 db    0
.xdata$x:00008225                 db    0
.xdata$x:00008226                 db    0
.xdata$x:00008227                 db    0
.xdata$x:00008228                 db    0
.xdata$x:00008229                 db    0
.xdata$x:0000822A                 db    0
.xdata$x:0000822B                 db    0
.xdata$x:0000822C                 db    0
.xdata$x:0000822D                 db    0
.xdata$x:0000822E                 db    0
.xdata$x:0000822F                 db    0
.xdata$x:00008230                 db    0
.xdata$x:00008231                 db    0
.xdata$x:00008232                 db    0
.xdata$x:00008233                 db    0
.xdata$x:00008233 _xdata$x        ends
.xdata$x:00008233
.xdata$x:00008234 ; ===========================================================================
.xdata$x:00008234
.xdata$x:00008234 ; Segment type: Pure data
.xdata$x:00008234 ; Segment permissions: Read
.xdata$x:00008234 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008234                 assume cs:_xdata$x
.xdata$x:00008234                 ;org 8234h
.xdata$x:00008234 ; COMDAT (pick associative to section at 2E14)
.xdata$x:00008234 __unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z db 0FFh
.xdata$x:00008234                                         ; DATA XREF: .xdata$x:00008244o
.xdata$x:00008235                 db 0FFh
.xdata$x:00008236                 db 0FFh
.xdata$x:00008237                 db 0FFh
.xdata$x:00008238                 dd offset __unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
.xdata$x:0000823C __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z db  22h ; "
.xdata$x:0000823C                                         ; DATA XREF: __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z+11o
.xdata$x:0000823D                 db    5
.xdata$x:0000823E                 db  93h ; Ã´
.xdata$x:0000823F                 db  19h
.xdata$x:00008240                 db    1
.xdata$x:00008241                 db    0
.xdata$x:00008242                 db    0
.xdata$x:00008243                 db    0
.xdata$x:00008244                 dd offset __unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
.xdata$x:00008248                 align 20h
.xdata$x:00008248 _xdata$x        ends
.xdata$x:00008248
.xdata$x:00008260 ; ===========================================================================
.xdata$x:00008260
.xdata$x:00008260 ; Segment type: Pure data
.xdata$x:00008260 ; Segment permissions: Read
.xdata$x:00008260 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008260                 assume cs:_xdata$x
.xdata$x:00008260                 ;org 8260h
.xdata$x:00008260 ; COMDAT (pick associative to section at 782C)
.xdata$x:00008260 __unwindtable$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ db 0FFh
.xdata$x:00008260                                         ; DATA XREF: .xdata$x:00008270o
.xdata$x:00008261                 db 0FFh
.xdata$x:00008262                 db 0FFh
.xdata$x:00008263                 db 0FFh
.xdata$x:00008264                 dd offset __unwindfunclet$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ$0
.xdata$x:00008268 __ehfuncinfo$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ db  22h ; "
.xdata$x:00008268                                         ; DATA XREF: __ehhandler$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ+11o
.xdata$x:00008269                 db    5
.xdata$x:0000826A                 db  93h ; Ã´
.xdata$x:0000826B                 db  19h
.xdata$x:0000826C                 db    1
.xdata$x:0000826D                 db    0
.xdata$x:0000826E                 db    0
.xdata$x:0000826F                 db    0
.xdata$x:00008270                 dd offset __unwindtable$?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
.xdata$x:00008274                 db    0
.xdata$x:00008275                 db    0
.xdata$x:00008276                 db    0
.xdata$x:00008277                 db    0
.xdata$x:00008278                 db    0
.xdata$x:00008279                 db    0
.xdata$x:0000827A                 db    0
.xdata$x:0000827B                 db    0
.xdata$x:0000827C                 db    0
.xdata$x:0000827D                 db    0
.xdata$x:0000827E                 db    0
.xdata$x:0000827F                 db    0
.xdata$x:00008280                 db    0
.xdata$x:00008281                 db    0
.xdata$x:00008282                 db    0
.xdata$x:00008283                 db    0
.xdata$x:00008284                 db    0
.xdata$x:00008285                 db    0
.xdata$x:00008286                 db    0
.xdata$x:00008287                 db    0
.xdata$x:00008288                 db    0
.xdata$x:00008289                 db    0
.xdata$x:0000828A                 db    0
.xdata$x:0000828B                 db    0
.xdata$x:0000828B _xdata$x        ends
.xdata$x:0000828B
.xdata$x:0000828C ; ===========================================================================
.xdata$x:0000828C
.xdata$x:0000828C ; Segment type: Pure data
.xdata$x:0000828C ; Segment permissions: Read
.xdata$x:0000828C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000828C                 assume cs:_xdata$x
.xdata$x:0000828C                 ;org 828Ch
.xdata$x:0000828C ; COMDAT (pick associative to section at 624C)
.xdata$x:0000828C __unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z db 0FFh
.xdata$x:0000828C                                         ; DATA XREF: .xdata$x:000082ACo
.xdata$x:0000828D                 db 0FFh
.xdata$x:0000828E                 db 0FFh
.xdata$x:0000828F                 db 0FFh
.xdata$x:00008290                 dd offset __unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$2
.xdata$x:00008294                 align 8
.xdata$x:00008298                 dd offset __unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
.xdata$x:0000829C                 db    1
.xdata$x:0000829D                 db    0
.xdata$x:0000829E                 db    0
.xdata$x:0000829F                 db    0
.xdata$x:000082A0                 dd offset __unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
.xdata$x:000082A4 __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z db  22h ; "
.xdata$x:000082A4                                         ; DATA XREF: __ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z+1Bo
.xdata$x:000082A5                 db    5
.xdata$x:000082A6                 db  93h ; Ã´
.xdata$x:000082A7                 db  19h
.xdata$x:000082A8                 db    3
.xdata$x:000082A9                 db    0
.xdata$x:000082AA                 db    0
.xdata$x:000082AB                 db    0
.xdata$x:000082AC                 dd offset __unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
.xdata$x:000082B0                 db    0
.xdata$x:000082B1                 db    0
.xdata$x:000082B2                 db    0
.xdata$x:000082B3                 db    0
.xdata$x:000082B4                 db    0
.xdata$x:000082B5                 db    0
.xdata$x:000082B6                 db    0
.xdata$x:000082B7                 db    0
.xdata$x:000082B8                 db    0
.xdata$x:000082B9                 db    0
.xdata$x:000082BA                 db    0
.xdata$x:000082BB                 db    0
.xdata$x:000082BC                 db    0
.xdata$x:000082BD                 db    0
.xdata$x:000082BE                 db    0
.xdata$x:000082BF                 db    0
.xdata$x:000082C0                 db    0
.xdata$x:000082C1                 db    0
.xdata$x:000082C2                 db    0
.xdata$x:000082C3                 db    0
.xdata$x:000082C4                 db    0
.xdata$x:000082C5                 db    0
.xdata$x:000082C6                 db    0
.xdata$x:000082C7                 db    0
.xdata$x:000082C7 _xdata$x        ends
.xdata$x:000082C7
.xdata$x:000082C8 ; ===========================================================================
.xdata$x:000082C8
.xdata$x:000082C8 ; Segment type: Pure data
.xdata$x:000082C8 ; Segment permissions: Read
.xdata$x:000082C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000082C8                 assume cs:_xdata$x
.xdata$x:000082C8                 ;org 82C8h
.xdata$x:000082C8 ; COMDAT (pick associative to section at 3AF0)
.xdata$x:000082C8 __unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z db 0FFh
.xdata$x:000082C8                                         ; DATA XREF: .xdata$x:000082F0o
.xdata$x:000082C9                 db 0FFh
.xdata$x:000082CA                 db 0FFh
.xdata$x:000082CB                 db 0FFh
.xdata$x:000082CC                 dd offset __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
.xdata$x:000082D0                 db 0FFh
.xdata$x:000082D1                 db 0FFh
.xdata$x:000082D2                 db 0FFh
.xdata$x:000082D3                 db 0FFh
.xdata$x:000082D4                 dd offset __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
.xdata$x:000082D8                 db    1
.xdata$x:000082D9                 db    0
.xdata$x:000082DA                 db    0
.xdata$x:000082DB                 db    0
.xdata$x:000082DC                 dd offset __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2
.xdata$x:000082E0                 db 0FFh
.xdata$x:000082E1                 db 0FFh
.xdata$x:000082E2                 db 0FFh
.xdata$x:000082E3                 db 0FFh
.xdata$x:000082E4                 dd offset __unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2
.xdata$x:000082E8 __ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z db  22h ; "
.xdata$x:000082E8                                         ; DATA XREF: __ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z+1Bo
.xdata$x:000082E9                 db    5
.xdata$x:000082EA                 db  93h ; Ã´
.xdata$x:000082EB                 db  19h
.xdata$x:000082EC                 db    4
.xdata$x:000082ED                 db    0
.xdata$x:000082EE                 db    0
.xdata$x:000082EF                 db    0
.xdata$x:000082F0                 dd offset __unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
.xdata$x:000082F4                 db    0
.xdata$x:000082F5                 db    0
.xdata$x:000082F6                 db    0
.xdata$x:000082F7                 db    0
.xdata$x:000082F8                 db    0
.xdata$x:000082F9                 db    0
.xdata$x:000082FA                 db    0
.xdata$x:000082FB                 db    0
.xdata$x:000082FC                 db    0
.xdata$x:000082FD                 db    0
.xdata$x:000082FE                 db    0
.xdata$x:000082FF                 db    0
.xdata$x:00008300                 db    0
.xdata$x:00008301                 db    0
.xdata$x:00008302                 db    0
.xdata$x:00008303                 db    0
.xdata$x:00008304                 db    0
.xdata$x:00008305                 db    0
.xdata$x:00008306                 db    0
.xdata$x:00008307                 db    0
.xdata$x:00008308                 db    0
.xdata$x:00008309                 db    0
.xdata$x:0000830A                 db    0
.xdata$x:0000830B                 db    0
.xdata$x:0000830B _xdata$x        ends
.xdata$x:0000830B
.xdata$x:0000830C ; ===========================================================================
.xdata$x:0000830C
.xdata$x:0000830C ; Segment type: Pure data
.xdata$x:0000830C ; Segment permissions: Read
.xdata$x:0000830C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000830C                 assume cs:_xdata$x
.xdata$x:0000830C                 ;org 830Ch
.xdata$x:0000830C ; COMDAT (pick associative to section at 4BF4)
.xdata$x:0000830C __unwindtable$??1_System_error@std@@UAE@XZ db 0FFh
.xdata$x:0000830C                                         ; DATA XREF: .xdata$x:0000831Co
.xdata$x:0000830D                 db 0FFh
.xdata$x:0000830E                 db 0FFh
.xdata$x:0000830F                 db 0FFh
.xdata$x:00008310                 dd offset __unwindfunclet$??1_System_error@std@@UAE@XZ$0
.xdata$x:00008314 __ehfuncinfo$??1_System_error@std@@UAE@XZ db  22h ; "
.xdata$x:00008314                                         ; DATA XREF: __ehhandler$??1_System_error@std@@UAE@XZ+11o
.xdata$x:00008315                 db    5
.xdata$x:00008316                 db  93h ; Ã´
.xdata$x:00008317                 db  19h
.xdata$x:00008318                 db    1
.xdata$x:00008319                 db    0
.xdata$x:0000831A                 db    0
.xdata$x:0000831B                 db    0
.xdata$x:0000831C                 dd offset __unwindtable$??1_System_error@std@@UAE@XZ
.xdata$x:00008320                 db    0
.xdata$x:00008321                 db    0
.xdata$x:00008322                 db    0
.xdata$x:00008323                 db    0
.xdata$x:00008324                 db    0
.xdata$x:00008325                 db    0
.xdata$x:00008326                 db    0
.xdata$x:00008327                 db    0
.xdata$x:00008328                 db    0
.xdata$x:00008329                 db    0
.xdata$x:0000832A                 db    0
.xdata$x:0000832B                 db    0
.xdata$x:0000832C                 db    0
.xdata$x:0000832D                 db    0
.xdata$x:0000832E                 db    0
.xdata$x:0000832F                 db    0
.xdata$x:00008330                 db    0
.xdata$x:00008331                 db    0
.xdata$x:00008332                 db    0
.xdata$x:00008333                 db    0
.xdata$x:00008334                 db    0
.xdata$x:00008335                 db    0
.xdata$x:00008336                 db    0
.xdata$x:00008337                 db    0
.xdata$x:00008337 _xdata$x        ends
.xdata$x:00008337
.xdata$x:00008338 ; ===========================================================================
.xdata$x:00008338
.xdata$x:00008338 ; Segment type: Pure data
.xdata$x:00008338 ; Segment permissions: Read
.xdata$x:00008338 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008338                 assume cs:_xdata$x
.xdata$x:00008338                 ;org 8338h
.xdata$x:00008338 ; COMDAT (pick associative to section at 3BFC)
.xdata$x:00008338 __unwindtable$??0_System_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00008338                                         ; DATA XREF: .xdata$x:00008348o
.xdata$x:00008339                 db 0FFh
.xdata$x:0000833A                 db 0FFh
.xdata$x:0000833B                 db 0FFh
.xdata$x:0000833C                 dd offset __unwindfunclet$??0_System_error@std@@QAE@ABV01@@Z$0
.xdata$x:00008340 __ehfuncinfo$??0_System_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00008340                                         ; DATA XREF: __ehhandler$??0_System_error@std@@QAE@ABV01@@Z+11o
.xdata$x:00008341                 db    5
.xdata$x:00008342                 db  93h ; Ã´
.xdata$x:00008343                 db  19h
.xdata$x:00008344                 db    1
.xdata$x:00008345                 db    0
.xdata$x:00008346                 db    0
.xdata$x:00008347                 db    0
.xdata$x:00008348                 dd offset __unwindtable$??0_System_error@std@@QAE@ABV01@@Z
.xdata$x:0000834C                 db    0
.xdata$x:0000834D                 db    0
.xdata$x:0000834E                 db    0
.xdata$x:0000834F                 db    0
.xdata$x:00008350                 db    0
.xdata$x:00008351                 db    0
.xdata$x:00008352                 db    0
.xdata$x:00008353                 db    0
.xdata$x:00008354                 db    0
.xdata$x:00008355                 db    0
.xdata$x:00008356                 db    0
.xdata$x:00008357                 db    0
.xdata$x:00008358                 db    0
.xdata$x:00008359                 db    0
.xdata$x:0000835A                 db    0
.xdata$x:0000835B                 db    0
.xdata$x:0000835C                 db    0
.xdata$x:0000835D                 db    0
.xdata$x:0000835E                 db    0
.xdata$x:0000835F                 db    0
.xdata$x:00008360                 db    0
.xdata$x:00008361                 db    0
.xdata$x:00008362                 db    0
.xdata$x:00008363                 db    0
.xdata$x:00008363 _xdata$x        ends
.xdata$x:00008363
.xdata$x:00008364 ; ===========================================================================
.xdata$x:00008364
.xdata$x:00008364 ; Segment type: Pure data
.xdata$x:00008364 ; Segment permissions: Read
.xdata$x:00008364 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008364                 assume cs:_xdata$x
.xdata$x:00008364                 ;org 8364h
.xdata$x:00008364 ; COMDAT (pick associative to section at 436C)
.xdata$x:00008364 __unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z db 0FFh
.xdata$x:00008364                                         ; DATA XREF: .xdata$x:00008384o
.xdata$x:00008365                 db 0FFh
.xdata$x:00008366                 db 0FFh
.xdata$x:00008367                 db 0FFh
.xdata$x:00008368                 dd offset __unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
.xdata$x:0000836C                 db    0
.xdata$x:0000836D                 db    0
.xdata$x:0000836E                 db    0
.xdata$x:0000836F                 db    0
.xdata$x:00008370                 dd offset __unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$1
.xdata$x:00008374                 db 0FFh
.xdata$x:00008375                 db 0FFh
.xdata$x:00008376                 db 0FFh
.xdata$x:00008377                 db 0FFh
.xdata$x:00008378                 dd offset __unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$1
.xdata$x:0000837C __ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z db  22h ; "
.xdata$x:0000837C                                         ; DATA XREF: __ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z+1Bo
.xdata$x:0000837D                 db    5
.xdata$x:0000837E                 db  93h ; Ã´
.xdata$x:0000837F                 db  19h
.xdata$x:00008380                 db    3
.xdata$x:00008381                 db    0
.xdata$x:00008382                 db    0
.xdata$x:00008383                 db    0
.xdata$x:00008384                 dd offset __unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
.xdata$x:00008388                 align 20h
.xdata$x:00008388 _xdata$x        ends
.xdata$x:00008388
.xdata$x:000083A0 ; ===========================================================================
.xdata$x:000083A0
.xdata$x:000083A0 ; Segment type: Pure data
.xdata$x:000083A0 ; Segment permissions: Read
.xdata$x:000083A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000083A0                 assume cs:_xdata$x
.xdata$x:000083A0                 ;org 83A0h
.xdata$x:000083A0 ; COMDAT (pick associative to section at 4FE0)
.xdata$x:000083A0 __unwindtable$??1system_error@std@@UAE@XZ db 0FFh
.xdata$x:000083A0                                         ; DATA XREF: .xdata$x:000083B0o
.xdata$x:000083A1                 db 0FFh
.xdata$x:000083A2                 db 0FFh
.xdata$x:000083A3                 db 0FFh
.xdata$x:000083A4                 dd offset __unwindfunclet$??1system_error@std@@UAE@XZ$0
.xdata$x:000083A8 __ehfuncinfo$??1system_error@std@@UAE@XZ db  22h ; "
.xdata$x:000083A8                                         ; DATA XREF: __ehhandler$??1system_error@std@@UAE@XZ+11o
.xdata$x:000083A9                 db    5
.xdata$x:000083AA                 db  93h ; Ã´
.xdata$x:000083AB                 db  19h
.xdata$x:000083AC                 db    1
.xdata$x:000083AD                 db    0
.xdata$x:000083AE                 db    0
.xdata$x:000083AF                 db    0
.xdata$x:000083B0                 dd offset __unwindtable$??1system_error@std@@UAE@XZ
.xdata$x:000083B4                 db    0
.xdata$x:000083B5                 db    0
.xdata$x:000083B6                 db    0
.xdata$x:000083B7                 db    0
.xdata$x:000083B8                 db    0
.xdata$x:000083B9                 db    0
.xdata$x:000083BA                 db    0
.xdata$x:000083BB                 db    0
.xdata$x:000083BC                 db    0
.xdata$x:000083BD                 db    0
.xdata$x:000083BE                 db    0
.xdata$x:000083BF                 db    0
.xdata$x:000083C0                 db    0
.xdata$x:000083C1                 db    0
.xdata$x:000083C2                 db    0
.xdata$x:000083C3                 db    0
.xdata$x:000083C4                 db    0
.xdata$x:000083C5                 db    0
.xdata$x:000083C6                 db    0
.xdata$x:000083C7                 db    0
.xdata$x:000083C8                 db    0
.xdata$x:000083C9                 db    0
.xdata$x:000083CA                 db    0
.xdata$x:000083CB                 db    0
.xdata$x:000083CB _xdata$x        ends
.xdata$x:000083CB
.xdata$x:000083CC ; ===========================================================================
.xdata$x:000083CC
.xdata$x:000083CC ; Segment type: Pure data
.xdata$x:000083CC ; Segment permissions: Read
.xdata$x:000083CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000083CC                 assume cs:_xdata$x
.xdata$x:000083CC                 ;org 83CCh
.xdata$x:000083CC ; COMDAT (pick associative to section at 42E8)
.xdata$x:000083CC __unwindtable$??0system_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000083CC                                         ; DATA XREF: .xdata$x:000083DCo
.xdata$x:000083CD                 db 0FFh
.xdata$x:000083CE                 db 0FFh
.xdata$x:000083CF                 db 0FFh
.xdata$x:000083D0                 dd offset __unwindfunclet$??0system_error@std@@QAE@ABV01@@Z$0
.xdata$x:000083D4 __ehfuncinfo$??0system_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000083D4                                         ; DATA XREF: __ehhandler$??0system_error@std@@QAE@ABV01@@Z+11o
.xdata$x:000083D5                 db    5
.xdata$x:000083D6                 db  93h ; Ã´
.xdata$x:000083D7                 db  19h
.xdata$x:000083D8                 db    1
.xdata$x:000083D9                 db    0
.xdata$x:000083DA                 db    0
.xdata$x:000083DB                 db    0
.xdata$x:000083DC                 dd offset __unwindtable$??0system_error@std@@QAE@ABV01@@Z
.xdata$x:000083E0                 db    0
.xdata$x:000083E1                 db    0
.xdata$x:000083E2                 db    0
.xdata$x:000083E3                 db    0
.xdata$x:000083E4                 db    0
.xdata$x:000083E5                 db    0
.xdata$x:000083E6                 db    0
.xdata$x:000083E7                 db    0
.xdata$x:000083E8                 db    0
.xdata$x:000083E9                 db    0
.xdata$x:000083EA                 db    0
.xdata$x:000083EB                 db    0
.xdata$x:000083EC                 db    0
.xdata$x:000083ED                 db    0
.xdata$x:000083EE                 db    0
.xdata$x:000083EF                 db    0
.xdata$x:000083F0                 db    0
.xdata$x:000083F1                 db    0
.xdata$x:000083F2                 db    0
.xdata$x:000083F3                 db    0
.xdata$x:000083F4                 db    0
.xdata$x:000083F5                 db    0
.xdata$x:000083F6                 db    0
.xdata$x:000083F7                 db    0
.xdata$x:000083F7 _xdata$x        ends
.xdata$x:000083F7
.xdata$x:000083F8 ; ===========================================================================
.xdata$x:000083F8
.xdata$x:000083F8 ; Segment type: Pure data
.xdata$x:000083F8 ; Segment permissions: Read
.xdata$x:000083F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000083F8                 assume cs:_xdata$x
.xdata$x:000083F8                 ;org 83F8h
.xdata$x:000083F8 ; COMDAT (pick associative to section at 37F0)
.xdata$x:000083F8 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000083F8                                         ; DATA XREF: .xdata$x:00008408o
.xdata$x:000083F9                 db 0FFh
.xdata$x:000083FA                 db 0FFh
.xdata$x:000083FB                 db 0FFh
.xdata$x:000083FC                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00008400 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00008400                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00008401                 db    5
.xdata$x:00008402                 db  93h ; Ã´
.xdata$x:00008403                 db  19h
.xdata$x:00008404                 db    1
.xdata$x:00008405                 db    0
.xdata$x:00008406                 db    0
.xdata$x:00008407                 db    0
.xdata$x:00008408                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000840C                 db    0
.xdata$x:0000840D                 db    0
.xdata$x:0000840E                 db    0
.xdata$x:0000840F                 db    0
.xdata$x:00008410                 db    0
.xdata$x:00008411                 db    0
.xdata$x:00008412                 db    0
.xdata$x:00008413                 db    0
.xdata$x:00008414                 db    0
.xdata$x:00008415                 db    0
.xdata$x:00008416                 db    0
.xdata$x:00008417                 db    0
.xdata$x:00008418                 db    0
.xdata$x:00008419                 db    0
.xdata$x:0000841A                 db    0
.xdata$x:0000841B                 db    0
.xdata$x:0000841C                 db    0
.xdata$x:0000841D                 db    0
.xdata$x:0000841E                 db    0
.xdata$x:0000841F                 db    0
.xdata$x:00008420                 db    0
.xdata$x:00008421                 db    0
.xdata$x:00008422                 db    0
.xdata$x:00008423                 db    0
.xdata$x:00008423 _xdata$x        ends
.xdata$x:00008423
.xdata$x:00008424 ; ===========================================================================
.xdata$x:00008424
.xdata$x:00008424 ; Segment type: Pure data
.xdata$x:00008424 ; Segment permissions: Read
.xdata$x:00008424 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008424                 assume cs:_xdata$x
.xdata$x:00008424                 ;org 8424h
.xdata$x:00008424 ; COMDAT (pick associative to section at 75F8)
.xdata$x:00008424 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00008424                                         ; DATA XREF: .xdata$x:00008434o
.xdata$x:00008425                 db 0FFh
.xdata$x:00008426                 db 0FFh
.xdata$x:00008427                 db 0FFh
.xdata$x:00008428                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000842C __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000842C                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000842D                 db    5
.xdata$x:0000842E                 db  93h ; Ã´
.xdata$x:0000842F                 db  19h
.xdata$x:00008430                 db    1
.xdata$x:00008431                 db    0
.xdata$x:00008432                 db    0
.xdata$x:00008433                 db    0
.xdata$x:00008434                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00008438                 db    0
.xdata$x:00008439                 db    0
.xdata$x:0000843A                 db    0
.xdata$x:0000843B                 db    0
.xdata$x:0000843C                 db    0
.xdata$x:0000843D                 db    0
.xdata$x:0000843E                 db    0
.xdata$x:0000843F                 db    0
.xdata$x:00008440                 db    0
.xdata$x:00008441                 db    0
.xdata$x:00008442                 db    0
.xdata$x:00008443                 db    0
.xdata$x:00008444                 db    0
.xdata$x:00008445                 db    0
.xdata$x:00008446                 db    0
.xdata$x:00008447                 db    0
.xdata$x:00008448                 db    0
.xdata$x:00008449                 db    0
.xdata$x:0000844A                 db    0
.xdata$x:0000844B                 db    0
.xdata$x:0000844C                 db    0
.xdata$x:0000844D                 db    0
.xdata$x:0000844E                 db    0
.xdata$x:0000844F                 db    0
.xdata$x:0000844F _xdata$x        ends
.xdata$x:0000844F
.xdata$x:00008450 ; ===========================================================================
.xdata$x:00008450
.xdata$x:00008450 ; Segment type: Pure data
.xdata$x:00008450 ; Segment permissions: Read
.xdata$x:00008450 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008450                 assume cs:_xdata$x
.xdata$x:00008450                 ;org 8450h
.xdata$x:00008450 ; COMDAT (pick associative to section at 4950)
.xdata$x:00008450 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00008450                                         ; DATA XREF: .xdata$x:00008460o
.xdata$x:00008451                 db 0FFh
.xdata$x:00008452                 db 0FFh
.xdata$x:00008453                 db 0FFh
.xdata$x:00008454                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00008458 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00008458                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00008459                 db    5
.xdata$x:0000845A                 db  93h ; Ã´
.xdata$x:0000845B                 db  19h
.xdata$x:0000845C                 db    1
.xdata$x:0000845D                 db    0
.xdata$x:0000845E                 db    0
.xdata$x:0000845F                 db    0
.xdata$x:00008460                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00008464                 db    0
.xdata$x:00008465                 db    0
.xdata$x:00008466                 db    0
.xdata$x:00008467                 db    0
.xdata$x:00008468                 db    0
.xdata$x:00008469                 db    0
.xdata$x:0000846A                 db    0
.xdata$x:0000846B                 db    0
.xdata$x:0000846C                 db    0
.xdata$x:0000846D                 db    0
.xdata$x:0000846E                 db    0
.xdata$x:0000846F                 db    0
.xdata$x:00008470                 db    0
.xdata$x:00008471                 db    0
.xdata$x:00008472                 db    0
.xdata$x:00008473                 db    0
.xdata$x:00008474                 db    0
.xdata$x:00008475                 db    0
.xdata$x:00008476                 db    0
.xdata$x:00008477                 db    0
.xdata$x:00008478                 db    0
.xdata$x:00008479                 db    0
.xdata$x:0000847A                 db    0
.xdata$x:0000847B                 db    0
.xdata$x:0000847B _xdata$x        ends
.xdata$x:0000847B
.xdata$x:0000847C ; ===========================================================================
.xdata$x:0000847C
.xdata$x:0000847C ; Segment type: Pure data
.xdata$x:0000847C ; Segment permissions: Read
.xdata$x:0000847C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000847C                 assume cs:_xdata$x
.xdata$x:0000847C                 ;org 847Ch
.xdata$x:0000847C ; COMDAT (pick associative to section at 386C)
.xdata$x:0000847C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000847C                                         ; DATA XREF: .xdata$x:0000848Co
.xdata$x:0000847D                 db 0FFh
.xdata$x:0000847E                 db 0FFh
.xdata$x:0000847F                 db 0FFh
.xdata$x:00008480                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00008484 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00008484                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00008485                 db    5
.xdata$x:00008486                 db  93h ; Ã´
.xdata$x:00008487                 db  19h
.xdata$x:00008488                 db    1
.xdata$x:00008489                 db    0
.xdata$x:0000848A                 db    0
.xdata$x:0000848B                 db    0
.xdata$x:0000848C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00008490                 db    0
.xdata$x:00008491                 db    0
.xdata$x:00008492                 db    0
.xdata$x:00008493                 db    0
.xdata$x:00008494                 db    0
.xdata$x:00008495                 db    0
.xdata$x:00008496                 db    0
.xdata$x:00008497                 db    0
.xdata$x:00008498                 db    0
.xdata$x:00008499                 db    0
.xdata$x:0000849A                 db    0
.xdata$x:0000849B                 db    0
.xdata$x:0000849C                 db    0
.xdata$x:0000849D                 db    0
.xdata$x:0000849E                 db    0
.xdata$x:0000849F                 db    0
.xdata$x:000084A0                 db    0
.xdata$x:000084A1                 db    0
.xdata$x:000084A2                 db    0
.xdata$x:000084A3                 db    0
.xdata$x:000084A4                 db    0
.xdata$x:000084A5                 db    0
.xdata$x:000084A6                 db    0
.xdata$x:000084A7                 db    0
.xdata$x:000084A7 _xdata$x        ends
.xdata$x:000084A7
.xdata$x:000084A8 ; ===========================================================================
.xdata$x:000084A8
.xdata$x:000084A8 ; Segment type: Pure data
.xdata$x:000084A8 ; Segment permissions: Read
.xdata$x:000084A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000084A8                 assume cs:_xdata$x
.xdata$x:000084A8                 ;org 84A8h
.xdata$x:000084A8 ; COMDAT (pick associative to section at 76B0)
.xdata$x:000084A8 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000084A8                                         ; DATA XREF: .xdata$x:000084B8o
.xdata$x:000084A9                 db 0FFh
.xdata$x:000084AA                 db 0FFh
.xdata$x:000084AB                 db 0FFh
.xdata$x:000084AC                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000084B0 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000084B0                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000084B1                 db    5
.xdata$x:000084B2                 db  93h ; Ã´
.xdata$x:000084B3                 db  19h
.xdata$x:000084B4                 db    1
.xdata$x:000084B5                 db    0
.xdata$x:000084B6                 db    0
.xdata$x:000084B7                 db    0
.xdata$x:000084B8                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000084BC                 db    0
.xdata$x:000084BD                 db    0
.xdata$x:000084BE                 db    0
.xdata$x:000084BF                 db    0
.xdata$x:000084C0                 db    0
.xdata$x:000084C1                 db    0
.xdata$x:000084C2                 db    0
.xdata$x:000084C3                 db    0
.xdata$x:000084C4                 db    0
.xdata$x:000084C5                 db    0
.xdata$x:000084C6                 db    0
.xdata$x:000084C7                 db    0
.xdata$x:000084C8                 db    0
.xdata$x:000084C9                 db    0
.xdata$x:000084CA                 db    0
.xdata$x:000084CB                 db    0
.xdata$x:000084CC                 db    0
.xdata$x:000084CD                 db    0
.xdata$x:000084CE                 db    0
.xdata$x:000084CF                 db    0
.xdata$x:000084D0                 db    0
.xdata$x:000084D1                 db    0
.xdata$x:000084D2                 db    0
.xdata$x:000084D3                 db    0
.xdata$x:000084D3 _xdata$x        ends
.xdata$x:000084D3
.xdata$x:000084D4 ; ===========================================================================
.xdata$x:000084D4
.xdata$x:000084D4 ; Segment type: Pure data
.xdata$x:000084D4 ; Segment permissions: Read
.xdata$x:000084D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000084D4                 assume cs:_xdata$x
.xdata$x:000084D4                 ;org 84D4h
.xdata$x:000084D4 ; COMDAT (pick associative to section at 49C0)
.xdata$x:000084D4 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000084D4                                         ; DATA XREF: .xdata$x:000084E4o
.xdata$x:000084D5                 db 0FFh
.xdata$x:000084D6                 db 0FFh
.xdata$x:000084D7                 db 0FFh
.xdata$x:000084D8                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000084DC __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000084DC                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000084DD                 db    5
.xdata$x:000084DE                 db  93h ; Ã´
.xdata$x:000084DF                 db  19h
.xdata$x:000084E0                 db    1
.xdata$x:000084E1                 db    0
.xdata$x:000084E2                 db    0
.xdata$x:000084E3                 db    0
.xdata$x:000084E4                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000084E8                 align 20h
.xdata$x:000084E8 _xdata$x        ends
.xdata$x:000084E8
.xdata$x:00008500 ; ===========================================================================
.xdata$x:00008500
.xdata$x:00008500 ; Segment type: Pure data
.xdata$x:00008500 ; Segment permissions: Read
.xdata$x:00008500 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008500                 assume cs:_xdata$x
.xdata$x:00008500                 ;org 8500h
.xdata$x:00008500 ; COMDAT (pick associative to section at 3C90)
.xdata$x:00008500 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00008500                                         ; DATA XREF: .xdata$x:00008510o
.xdata$x:00008501                 db 0FFh
.xdata$x:00008502                 db 0FFh
.xdata$x:00008503                 db 0FFh
.xdata$x:00008504                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00008508 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00008508                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00008509                 db    5
.xdata$x:0000850A                 db  93h ; Ã´
.xdata$x:0000850B                 db  19h
.xdata$x:0000850C                 db    1
.xdata$x:0000850D                 db    0
.xdata$x:0000850E                 db    0
.xdata$x:0000850F                 db    0
.xdata$x:00008510                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00008514                 db    0
.xdata$x:00008515                 db    0
.xdata$x:00008516                 db    0
.xdata$x:00008517                 db    0
.xdata$x:00008518                 db    0
.xdata$x:00008519                 db    0
.xdata$x:0000851A                 db    0
.xdata$x:0000851B                 db    0
.xdata$x:0000851C                 db    0
.xdata$x:0000851D                 db    0
.xdata$x:0000851E                 db    0
.xdata$x:0000851F                 db    0
.xdata$x:00008520                 db    0
.xdata$x:00008521                 db    0
.xdata$x:00008522                 db    0
.xdata$x:00008523                 db    0
.xdata$x:00008524                 db    0
.xdata$x:00008525                 db    0
.xdata$x:00008526                 db    0
.xdata$x:00008527                 db    0
.xdata$x:00008528                 db    0
.xdata$x:00008529                 db    0
.xdata$x:0000852A                 db    0
.xdata$x:0000852B                 db    0
.xdata$x:0000852B _xdata$x        ends
.xdata$x:0000852B
.xdata$x:0000852C ; ===========================================================================
.xdata$x:0000852C
.xdata$x:0000852C ; Segment type: Pure data
.xdata$x:0000852C ; Segment permissions: Read
.xdata$x:0000852C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000852C                 assume cs:_xdata$x
.xdata$x:0000852C                 ;org 852Ch
.xdata$x:0000852C ; COMDAT (pick associative to section at 7774)
.xdata$x:0000852C __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000852C                                         ; DATA XREF: .xdata$x:0000853Co
.xdata$x:0000852D                 db 0FFh
.xdata$x:0000852E                 db 0FFh
.xdata$x:0000852F                 db 0FFh
.xdata$x:00008530                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00008534 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00008534                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00008535                 db    5
.xdata$x:00008536                 db  93h ; Ã´
.xdata$x:00008537                 db  19h
.xdata$x:00008538                 db    1
.xdata$x:00008539                 db    0
.xdata$x:0000853A                 db    0
.xdata$x:0000853B                 db    0
.xdata$x:0000853C                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00008540                 db    0
.xdata$x:00008541                 db    0
.xdata$x:00008542                 db    0
.xdata$x:00008543                 db    0
.xdata$x:00008544                 db    0
.xdata$x:00008545                 db    0
.xdata$x:00008546                 db    0
.xdata$x:00008547                 db    0
.xdata$x:00008548                 db    0
.xdata$x:00008549                 db    0
.xdata$x:0000854A                 db    0
.xdata$x:0000854B                 db    0
.xdata$x:0000854C                 db    0
.xdata$x:0000854D                 db    0
.xdata$x:0000854E                 db    0
.xdata$x:0000854F                 db    0
.xdata$x:00008550                 db    0
.xdata$x:00008551                 db    0
.xdata$x:00008552                 db    0
.xdata$x:00008553                 db    0
.xdata$x:00008554                 db    0
.xdata$x:00008555                 db    0
.xdata$x:00008556                 db    0
.xdata$x:00008557                 db    0
.xdata$x:00008557 _xdata$x        ends
.xdata$x:00008557
.xdata$x:00008558 ; ===========================================================================
.xdata$x:00008558
.xdata$x:00008558 ; Segment type: Pure data
.xdata$x:00008558 ; Segment permissions: Read
.xdata$x:00008558 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008558                 assume cs:_xdata$x
.xdata$x:00008558                 ;org 8558h
.xdata$x:00008558 ; COMDAT (pick associative to section at 4C64)
.xdata$x:00008558 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00008558                                         ; DATA XREF: .xdata$x:00008568o
.xdata$x:00008559                 db 0FFh
.xdata$x:0000855A                 db 0FFh
.xdata$x:0000855B                 db 0FFh
.xdata$x:0000855C                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00008560 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00008560                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00008561                 db    5
.xdata$x:00008562                 db  93h ; Ã´
.xdata$x:00008563                 db  19h
.xdata$x:00008564                 db    1
.xdata$x:00008565                 db    0
.xdata$x:00008566                 db    0
.xdata$x:00008567                 db    0
.xdata$x:00008568                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000856C                 db    0
.xdata$x:0000856D                 db    0
.xdata$x:0000856E                 db    0
.xdata$x:0000856F                 db    0
.xdata$x:00008570                 db    0
.xdata$x:00008571                 db    0
.xdata$x:00008572                 db    0
.xdata$x:00008573                 db    0
.xdata$x:00008574                 db    0
.xdata$x:00008575                 db    0
.xdata$x:00008576                 db    0
.xdata$x:00008577                 db    0
.xdata$x:00008578                 db    0
.xdata$x:00008579                 db    0
.xdata$x:0000857A                 db    0
.xdata$x:0000857B                 db    0
.xdata$x:0000857C                 db    0
.xdata$x:0000857D                 db    0
.xdata$x:0000857E                 db    0
.xdata$x:0000857F                 db    0
.xdata$x:00008580                 db    0
.xdata$x:00008581                 db    0
.xdata$x:00008582                 db    0
.xdata$x:00008583                 db    0
.xdata$x:00008583 _xdata$x        ends
.xdata$x:00008583
.xdata$x:00008584 ; ===========================================================================
.xdata$x:00008584
.xdata$x:00008584 ; Segment type: Pure data
.xdata$x:00008584 ; Segment permissions: Read
.xdata$x:00008584 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008584                 assume cs:_xdata$x
.xdata$x:00008584                 ;org 8584h
.xdata$x:00008584 ; COMDAT (pick associative to section at 3F04)
.xdata$x:00008584 __unwindtable$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z db 0FFh
.xdata$x:00008584                                         ; DATA XREF: .xdata$x:00008594o
.xdata$x:00008585                 db 0FFh
.xdata$x:00008586                 db 0FFh
.xdata$x:00008587                 db 0FFh
.xdata$x:00008588                 dd offset __unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$0
.xdata$x:0000858C __ehfuncinfo$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z db  22h ; "
.xdata$x:0000858C                                         ; DATA XREF: __ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z+11o
.xdata$x:0000858D                 db    5
.xdata$x:0000858E                 db  93h ; Ã´
.xdata$x:0000858F                 db  19h
.xdata$x:00008590                 db    1
.xdata$x:00008591                 db    0
.xdata$x:00008592                 db    0
.xdata$x:00008593                 db    0
.xdata$x:00008594                 dd offset __unwindtable$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
.xdata$x:00008598                 db    0
.xdata$x:00008599                 db    0
.xdata$x:0000859A                 db    0
.xdata$x:0000859B                 db    0
.xdata$x:0000859C                 db    0
.xdata$x:0000859D                 db    0
.xdata$x:0000859E                 db    0
.xdata$x:0000859F                 db    0
.xdata$x:000085A0                 db    0
.xdata$x:000085A1                 db    0
.xdata$x:000085A2                 db    0
.xdata$x:000085A3                 db    0
.xdata$x:000085A4                 db    0
.xdata$x:000085A5                 db    0
.xdata$x:000085A6                 db    0
.xdata$x:000085A7                 db    0
.xdata$x:000085A8                 db    0
.xdata$x:000085A9                 db    0
.xdata$x:000085AA                 db    0
.xdata$x:000085AB                 db    0
.xdata$x:000085AC                 db    0
.xdata$x:000085AD                 db    0
.xdata$x:000085AE                 db    0
.xdata$x:000085AF                 db    0
.xdata$x:000085AF _xdata$x        ends
.xdata$x:000085AF
.xdata$x:000085B0 ; ===========================================================================
.xdata$x:000085B0
.xdata$x:000085B0 ; Segment type: Pure data
.xdata$x:000085B0 ; Segment permissions: Read
.xdata$x:000085B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000085B0                 assume cs:_xdata$x
.xdata$x:000085B0                 ;org 85B0h
.xdata$x:000085B0 ; COMDAT (pick associative to section at 4DD8)
.xdata$x:000085B0 __unwindtable$??1failure@ios_base@std@@UAE@XZ db 0FFh
.xdata$x:000085B0                                         ; DATA XREF: .xdata$x:000085C0o
.xdata$x:000085B1                 db 0FFh
.xdata$x:000085B2                 db 0FFh
.xdata$x:000085B3                 db 0FFh
.xdata$x:000085B4                 dd offset __unwindfunclet$??1failure@ios_base@std@@UAE@XZ$0
.xdata$x:000085B8 __ehfuncinfo$??1failure@ios_base@std@@UAE@XZ db  22h ; "
.xdata$x:000085B8                                         ; DATA XREF: __ehhandler$??1failure@ios_base@std@@UAE@XZ+11o
.xdata$x:000085B9                 db    5
.xdata$x:000085BA                 db  93h ; Ã´
.xdata$x:000085BB                 db  19h
.xdata$x:000085BC                 db    1
.xdata$x:000085BD                 db    0
.xdata$x:000085BE                 db    0
.xdata$x:000085BF                 db    0
.xdata$x:000085C0                 dd offset __unwindtable$??1failure@ios_base@std@@UAE@XZ
.xdata$x:000085C4                 db    0
.xdata$x:000085C5                 db    0
.xdata$x:000085C6                 db    0
.xdata$x:000085C7                 db    0
.xdata$x:000085C8                 db    0
.xdata$x:000085C9                 db    0
.xdata$x:000085CA                 db    0
.xdata$x:000085CB                 db    0
.xdata$x:000085CC                 db    0
.xdata$x:000085CD                 db    0
.xdata$x:000085CE                 db    0
.xdata$x:000085CF                 db    0
.xdata$x:000085D0                 db    0
.xdata$x:000085D1                 db    0
.xdata$x:000085D2                 db    0
.xdata$x:000085D3                 db    0
.xdata$x:000085D4                 db    0
.xdata$x:000085D5                 db    0
.xdata$x:000085D6                 db    0
.xdata$x:000085D7                 db    0
.xdata$x:000085D8                 db    0
.xdata$x:000085D9                 db    0
.xdata$x:000085DA                 db    0
.xdata$x:000085DB                 db    0
.xdata$x:000085DB _xdata$x        ends
.xdata$x:000085DB
.xdata$x:000085DC ; ===========================================================================
.xdata$x:000085DC
.xdata$x:000085DC ; Segment type: Pure data
.xdata$x:000085DC ; Segment permissions: Read
.xdata$x:000085DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000085DC                 assume cs:_xdata$x
.xdata$x:000085DC                 ;org 85DCh
.xdata$x:000085DC ; COMDAT (pick associative to section at 3E80)
.xdata$x:000085DC __unwindtable$??0failure@ios_base@std@@QAE@ABV012@@Z db 0FFh
.xdata$x:000085DC                                         ; DATA XREF: .xdata$x:000085ECo
.xdata$x:000085DD                 db 0FFh
.xdata$x:000085DE                 db 0FFh
.xdata$x:000085DF                 db 0FFh
.xdata$x:000085E0                 dd offset __unwindfunclet$??0failure@ios_base@std@@QAE@ABV012@@Z$0
.xdata$x:000085E4 __ehfuncinfo$??0failure@ios_base@std@@QAE@ABV012@@Z db  22h ; "
.xdata$x:000085E4                                         ; DATA XREF: __ehhandler$??0failure@ios_base@std@@QAE@ABV012@@Z+11o
.xdata$x:000085E5                 db    5
.xdata$x:000085E6                 db  93h ; Ã´
.xdata$x:000085E7                 db  19h
.xdata$x:000085E8                 db    1
.xdata$x:000085E9                 db    0
.xdata$x:000085EA                 db    0
.xdata$x:000085EB                 db    0
.xdata$x:000085EC                 dd offset __unwindtable$??0failure@ios_base@std@@QAE@ABV012@@Z
.xdata$x:000085F0                 db    0
.xdata$x:000085F1                 db    0
.xdata$x:000085F2                 db    0
.xdata$x:000085F3                 db    0
.xdata$x:000085F4                 db    0
.xdata$x:000085F5                 db    0
.xdata$x:000085F6                 db    0
.xdata$x:000085F7                 db    0
.xdata$x:000085F8                 db    0
.xdata$x:000085F9                 db    0
.xdata$x:000085FA                 db    0
.xdata$x:000085FB                 db    0
.xdata$x:000085FC                 db    0
.xdata$x:000085FD                 db    0
.xdata$x:000085FE                 db    0
.xdata$x:000085FF                 db    0
.xdata$x:00008600                 db    0
.xdata$x:00008601                 db    0
.xdata$x:00008602                 db    0
.xdata$x:00008603                 db    0
.xdata$x:00008604                 db    0
.xdata$x:00008605                 db    0
.xdata$x:00008606                 db    0
.xdata$x:00008607                 db    0
.xdata$x:00008607 _xdata$x        ends
.xdata$x:00008607
.xdata$x:00008608 ; ===========================================================================
.xdata$x:00008608
.xdata$x:00008608 ; Segment type: Pure data
.xdata$x:00008608 ; Segment permissions: Read
.xdata$x:00008608 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008608                 assume cs:_xdata$x
.xdata$x:00008608                 ;org 8608h
.xdata$x:00008608 ; COMDAT (pick associative to section at 7404)
.xdata$x:00008608 __unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ db 0FFh
.xdata$x:00008608                                         ; DATA XREF: .xdata$x:00008618o
.xdata$x:00008609                 db 0FFh
.xdata$x:0000860A                 db 0FFh
.xdata$x:0000860B                 db 0FFh
.xdata$x:0000860C                 dd offset __unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$0
.xdata$x:00008610 __ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ db  22h ; "
.xdata$x:00008610                                         ; DATA XREF: __ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ+11o
.xdata$x:00008611                 db    5
.xdata$x:00008612                 db  93h ; Ã´
.xdata$x:00008613                 db  19h
.xdata$x:00008614                 db    1
.xdata$x:00008615                 db    0
.xdata$x:00008616                 db    0
.xdata$x:00008617                 db    0
.xdata$x:00008618                 dd offset __unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
.xdata$x:0000861C                 db    0
.xdata$x:0000861D                 db    0
.xdata$x:0000861E                 db    0
.xdata$x:0000861F                 db    0
.xdata$x:00008620                 db    0
.xdata$x:00008621                 db    0
.xdata$x:00008622                 db    0
.xdata$x:00008623                 db    0
.xdata$x:00008624                 db    0
.xdata$x:00008625                 db    0
.xdata$x:00008626                 db    0
.xdata$x:00008627                 db    0
.xdata$x:00008628                 db    0
.xdata$x:00008629                 db    0
.xdata$x:0000862A                 db    0
.xdata$x:0000862B                 db    0
.xdata$x:0000862C                 db    0
.xdata$x:0000862D                 db    0
.xdata$x:0000862E                 db    0
.xdata$x:0000862F                 db    0
.xdata$x:00008630                 db    0
.xdata$x:00008631                 db    0
.xdata$x:00008632                 db    0
.xdata$x:00008633                 db    0
.xdata$x:00008633 _xdata$x        ends
.xdata$x:00008633
.xdata$x:00008634 ; ===========================================================================
.xdata$x:00008634
.xdata$x:00008634 ; Segment type: Pure data
.xdata$x:00008634 ; Segment permissions: Read
.xdata$x:00008634 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008634                 assume cs:_xdata$x
.xdata$x:00008634                 ;org 8634h
.xdata$x:00008634 ; COMDAT (pick associative to section at 6038)
.xdata$x:00008634 __catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$3 db    0
.xdata$x:00008634                                         ; DATA XREF: .xdata$x:00008654o
.xdata$x:00008635                 db    0
.xdata$x:00008636                 db    0
.xdata$x:00008637                 db    0
.xdata$x:00008638                 db    0
.xdata$x:00008639                 db    0
.xdata$x:0000863A                 db    0
.xdata$x:0000863B                 db    0
.xdata$x:0000863C                 db    0
.xdata$x:0000863D                 db    0
.xdata$x:0000863E                 db    0
.xdata$x:0000863F                 db    0
.xdata$x:00008640                 dd offset __catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
.xdata$x:00008644 __tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z db    1
.xdata$x:00008644                                         ; DATA XREF: .xdata$x:00008680o
.xdata$x:00008645                 db    0
.xdata$x:00008646                 db    0
.xdata$x:00008647                 db    0
.xdata$x:00008648                 db    1
.xdata$x:00008649                 db    0
.xdata$x:0000864A                 db    0
.xdata$x:0000864B                 db    0
.xdata$x:0000864C                 db    2
.xdata$x:0000864D                 db    0
.xdata$x:0000864E                 db    0
.xdata$x:0000864F                 db    0
.xdata$x:00008650                 db    1
.xdata$x:00008651                 db    0
.xdata$x:00008652                 db    0
.xdata$x:00008653                 db    0
.xdata$x:00008654                 dd offset __catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$3
.xdata$x:00008658 __unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z db 0FFh
.xdata$x:00008658                                         ; DATA XREF: .xdata$x:00008678o
.xdata$x:00008659                 db 0FFh
.xdata$x:0000865A                 db 0FFh
.xdata$x:0000865B                 db 0FFh
.xdata$x:0000865C                 dd offset __unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
.xdata$x:00008660                 db 0FFh
.xdata$x:00008661                 db 0FFh
.xdata$x:00008662                 db 0FFh
.xdata$x:00008663                 db 0FFh
.xdata$x:00008664                 db    0
.xdata$x:00008665                 db    0
.xdata$x:00008666                 db    0
.xdata$x:00008667                 db    0
.xdata$x:00008668                 db 0FFh
.xdata$x:00008669                 db 0FFh
.xdata$x:0000866A                 db 0FFh
.xdata$x:0000866B                 db 0FFh
.xdata$x:0000866C                 db    0
.xdata$x:0000866D                 db    0
.xdata$x:0000866E                 db    0
.xdata$x:0000866F                 db    0
.xdata$x:00008670 __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z db  22h ; "
.xdata$x:00008670                                         ; DATA XREF: __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z+11o
.xdata$x:00008671                 db    5
.xdata$x:00008672                 db  93h ; Ã´
.xdata$x:00008673                 db  19h
.xdata$x:00008674                 db    3
.xdata$x:00008675                 db    0
.xdata$x:00008676                 db    0
.xdata$x:00008677                 db    0
.xdata$x:00008678                 dd offset __unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
.xdata$x:0000867C                 db    1
.xdata$x:0000867D                 db    0
.xdata$x:0000867E                 db    0
.xdata$x:0000867F                 db    0
.xdata$x:00008680                 dd offset __tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
.xdata$x:00008684                 db    0
.xdata$x:00008685                 db    0
.xdata$x:00008686                 db    0
.xdata$x:00008687                 db    0
.xdata$x:00008688                 db    0
.xdata$x:00008689                 db    0
.xdata$x:0000868A                 db    0
.xdata$x:0000868B                 db    0
.xdata$x:0000868C                 db    0
.xdata$x:0000868D                 db    0
.xdata$x:0000868E                 db    0
.xdata$x:0000868F                 db    0
.xdata$x:00008690                 db    0
.xdata$x:00008691                 db    0
.xdata$x:00008692                 db    0
.xdata$x:00008693                 db    0
.xdata$x:00008693 _xdata$x        ends
.xdata$x:00008693
.xdata$x:00008694 ; ===========================================================================
.xdata$x:00008694
.xdata$x:00008694 ; Segment type: Pure data
.xdata$x:00008694 ; Segment permissions: Read
.xdata$x:00008694 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008694                 assume cs:_xdata$x
.xdata$x:00008694                 ;org 8694h
.xdata$x:00008694 ; COMDAT (pick associative to section at 727C)
.xdata$x:00008694 __catchsym$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$3 db    0
.xdata$x:00008694                                         ; DATA XREF: .xdata$x:000086B4o
.xdata$x:00008695                 db    0
.xdata$x:00008696                 db    0
.xdata$x:00008697                 db    0
.xdata$x:00008698                 db    0
.xdata$x:00008699                 db    0
.xdata$x:0000869A                 db    0
.xdata$x:0000869B                 db    0
.xdata$x:0000869C                 db    0
.xdata$x:0000869D                 db    0
.xdata$x:0000869E                 db    0
.xdata$x:0000869F                 db    0
.xdata$x:000086A0                 dd offset __catch$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$0
.xdata$x:000086A4 __tryblocktable$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ db    1
.xdata$x:000086A4                                         ; DATA XREF: .xdata$x:000086E0o
.xdata$x:000086A5                 db    0
.xdata$x:000086A6                 db    0
.xdata$x:000086A7                 db    0
.xdata$x:000086A8                 db    1
.xdata$x:000086A9                 db    0
.xdata$x:000086AA                 db    0
.xdata$x:000086AB                 db    0
.xdata$x:000086AC                 db    2
.xdata$x:000086AD                 db    0
.xdata$x:000086AE                 db    0
.xdata$x:000086AF                 db    0
.xdata$x:000086B0                 db    1
.xdata$x:000086B1                 db    0
.xdata$x:000086B2                 db    0
.xdata$x:000086B3                 db    0
.xdata$x:000086B4                 dd offset __catchsym$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$3
.xdata$x:000086B8 __unwindtable$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ db 0FFh
.xdata$x:000086B8                                         ; DATA XREF: .xdata$x:000086D8o
.xdata$x:000086B9                 db 0FFh
.xdata$x:000086BA                 db 0FFh
.xdata$x:000086BB                 db 0FFh
.xdata$x:000086BC                 dd offset __unwindfunclet$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$2
.xdata$x:000086C0                 db    0
.xdata$x:000086C1                 db    0
.xdata$x:000086C2                 db    0
.xdata$x:000086C3                 db    0
.xdata$x:000086C4                 db    0
.xdata$x:000086C5                 db    0
.xdata$x:000086C6                 db    0
.xdata$x:000086C7                 db    0
.xdata$x:000086C8                 db    0
.xdata$x:000086C9                 db    0
.xdata$x:000086CA                 db    0
.xdata$x:000086CB                 db    0
.xdata$x:000086CC                 db    0
.xdata$x:000086CD                 db    0
.xdata$x:000086CE                 db    0
.xdata$x:000086CF                 db    0
.xdata$x:000086D0 __ehfuncinfo$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ db  22h ; "
.xdata$x:000086D0                                         ; DATA XREF: __ehhandler$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ+11o
.xdata$x:000086D1                 db    5
.xdata$x:000086D2                 db  93h ; Ã´
.xdata$x:000086D3                 db  19h
.xdata$x:000086D4                 db    3
.xdata$x:000086D5                 db    0
.xdata$x:000086D6                 db    0
.xdata$x:000086D7                 db    0
.xdata$x:000086D8                 dd offset __unwindtable$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.xdata$x:000086DC                 db    1
.xdata$x:000086DD                 db    0
.xdata$x:000086DE                 db    0
.xdata$x:000086DF                 db    0
.xdata$x:000086E0                 dd offset __tryblocktable$?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.xdata$x:000086E4                 db    0
.xdata$x:000086E5                 db    0
.xdata$x:000086E6                 db    0
.xdata$x:000086E7                 db    0
.xdata$x:000086E8                 db    0
.xdata$x:000086E9                 db    0
.xdata$x:000086EA                 db    0
.xdata$x:000086EB                 db    0
.xdata$x:000086EC                 db    0
.xdata$x:000086ED                 db    0
.xdata$x:000086EE                 db    0
.xdata$x:000086EF                 db    0
.xdata$x:000086F0                 db    0
.xdata$x:000086F1                 db    0
.xdata$x:000086F2                 db    0
.xdata$x:000086F3                 db    0
.xdata$x:000086F3 _xdata$x        ends
.xdata$x:000086F3
.xdata$x:000086F4 ; ===========================================================================
.xdata$x:000086F4
.xdata$x:000086F4 ; Segment type: Pure data
.xdata$x:000086F4 ; Segment permissions: Read
.xdata$x:000086F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000086F4                 assume cs:_xdata$x
.xdata$x:000086F4                 ;org 86F4h
.xdata$x:000086F4 ; COMDAT (pick associative to section at 7938)
.xdata$x:000086F4 __catchsym$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$3 db    0
.xdata$x:000086F4                                         ; DATA XREF: .xdata$x:00008714o
.xdata$x:000086F5                 db    0
.xdata$x:000086F6                 db    0
.xdata$x:000086F7                 db    0
.xdata$x:000086F8                 db    0
.xdata$x:000086F9                 db    0
.xdata$x:000086FA                 db    0
.xdata$x:000086FB                 db    0
.xdata$x:000086FC                 db    0
.xdata$x:000086FD                 db    0
.xdata$x:000086FE                 db    0
.xdata$x:000086FF                 db    0
.xdata$x:00008700                 dd offset __catch$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$0
.xdata$x:00008704 __tryblocktable$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ db    1
.xdata$x:00008704                                         ; DATA XREF: .xdata$x:00008740o
.xdata$x:00008705                 db    0
.xdata$x:00008706                 db    0
.xdata$x:00008707                 db    0
.xdata$x:00008708                 db    1
.xdata$x:00008709                 db    0
.xdata$x:0000870A                 db    0
.xdata$x:0000870B                 db    0
.xdata$x:0000870C                 db    2
.xdata$x:0000870D                 db    0
.xdata$x:0000870E                 db    0
.xdata$x:0000870F                 db    0
.xdata$x:00008710                 db    1
.xdata$x:00008711                 db    0
.xdata$x:00008712                 db    0
.xdata$x:00008713                 db    0
.xdata$x:00008714                 dd offset __catchsym$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$3
.xdata$x:00008718 __unwindtable$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ db 0FFh
.xdata$x:00008718                                         ; DATA XREF: .xdata$x:00008738o
.xdata$x:00008719                 db 0FFh
.xdata$x:0000871A                 db 0FFh
.xdata$x:0000871B                 db 0FFh
.xdata$x:0000871C                 dd offset __unwindfunclet$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ$2
.xdata$x:00008720                 db    0
.xdata$x:00008721                 db    0
.xdata$x:00008722                 db    0
.xdata$x:00008723                 db    0
.xdata$x:00008724                 db    0
.xdata$x:00008725                 db    0
.xdata$x:00008726                 db    0
.xdata$x:00008727                 db    0
.xdata$x:00008728                 db    0
.xdata$x:00008729                 db    0
.xdata$x:0000872A                 db    0
.xdata$x:0000872B                 db    0
.xdata$x:0000872C                 db    0
.xdata$x:0000872D                 db    0
.xdata$x:0000872E                 db    0
.xdata$x:0000872F                 db    0
.xdata$x:00008730 __ehfuncinfo$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ db  22h ; "
.xdata$x:00008730                                         ; DATA XREF: __ehhandler$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ+11o
.xdata$x:00008731                 db    5
.xdata$x:00008732                 db  93h ; Ã´
.xdata$x:00008733                 db  19h
.xdata$x:00008734                 db    3
.xdata$x:00008735                 db    0
.xdata$x:00008736                 db    0
.xdata$x:00008737                 db    0
.xdata$x:00008738                 dd offset __unwindtable$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.xdata$x:0000873C                 db    1
.xdata$x:0000873D                 db    0
.xdata$x:0000873E                 db    0
.xdata$x:0000873F                 db    0
.xdata$x:00008740                 dd offset __tryblocktable$?peek@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
.xdata$x:00008744                 db    0
.xdata$x:00008745                 db    0
.xdata$x:00008746                 db    0
.xdata$x:00008747                 db    0
.xdata$x:00008748                 db    0
.xdata$x:00008749                 db    0
.xdata$x:0000874A                 db    0
.xdata$x:0000874B                 db    0
.xdata$x:0000874C                 db    0
.xdata$x:0000874D                 db    0
.xdata$x:0000874E                 db    0
.xdata$x:0000874F                 db    0
.xdata$x:00008750                 db    0
.xdata$x:00008751                 db    0
.xdata$x:00008752                 db    0
.xdata$x:00008753                 db    0
.xdata$x:00008753 _xdata$x        ends
.xdata$x:00008753
.xdata$x:00008754 ; ===========================================================================
.xdata$x:00008754
.xdata$x:00008754 ; Segment type: Pure data
.xdata$x:00008754 ; Segment permissions: Read
.xdata$x:00008754 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008754                 assume cs:_xdata$x
.xdata$x:00008754                 ;org 8754h
.xdata$x:00008754 ; COMDAT (pick associative to section at 416C)
.xdata$x:00008754 __unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z db 0FFh
.xdata$x:00008754                                         ; DATA XREF: .xdata$x:00008764o
.xdata$x:00008755                 db 0FFh
.xdata$x:00008756                 db 0FFh
.xdata$x:00008757                 db 0FFh
.xdata$x:00008758                 dd offset __unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
.xdata$x:0000875C __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z db  22h ; "
.xdata$x:0000875C                                         ; DATA XREF: __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z+11o
.xdata$x:0000875D                 db    5
.xdata$x:0000875E                 db  93h ; Ã´
.xdata$x:0000875F                 db  19h
.xdata$x:00008760                 db    1
.xdata$x:00008761                 db    0
.xdata$x:00008762                 db    0
.xdata$x:00008763                 db    0
.xdata$x:00008764                 dd offset __unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
.xdata$x:00008768                 align 20h
.xdata$x:00008768 _xdata$x        ends
.xdata$x:00008768
.xdata$x:00008780 ; ===========================================================================
.xdata$x:00008780
.xdata$x:00008780 ; Segment type: Pure data
.xdata$x:00008780 ; Segment permissions: Read
.xdata$x:00008780 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008780                 assume cs:_xdata$x
.xdata$x:00008780                 ;org 8780h
.xdata$x:00008780 ; COMDAT (pick associative to section at 4EE8)
.xdata$x:00008780 __unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008780                                         ; DATA XREF: .xdata$x:00008790o
.xdata$x:00008781                 db 0FFh
.xdata$x:00008782                 db 0FFh
.xdata$x:00008783                 db 0FFh
.xdata$x:00008784                 dd offset __unwindfunclet$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
.xdata$x:00008788 __ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008788                                         ; DATA XREF: __ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ+11o
.xdata$x:00008789                 db    5
.xdata$x:0000878A                 db  93h ; Ã´
.xdata$x:0000878B                 db  19h
.xdata$x:0000878C                 db    1
.xdata$x:0000878D                 db    0
.xdata$x:0000878E                 db    0
.xdata$x:0000878F                 db    0
.xdata$x:00008790                 dd offset __unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
.xdata$x:00008794                 db    0
.xdata$x:00008795                 db    0
.xdata$x:00008796                 db    0
.xdata$x:00008797                 db    0
.xdata$x:00008798                 db    0
.xdata$x:00008799                 db    0
.xdata$x:0000879A                 db    0
.xdata$x:0000879B                 db    0
.xdata$x:0000879C                 db    0
.xdata$x:0000879D                 db    0
.xdata$x:0000879E                 db    0
.xdata$x:0000879F                 db    0
.xdata$x:000087A0                 db    0
.xdata$x:000087A1                 db    0
.xdata$x:000087A2                 db    0
.xdata$x:000087A3                 db    0
.xdata$x:000087A4                 db    0
.xdata$x:000087A5                 db    0
.xdata$x:000087A6                 db    0
.xdata$x:000087A7                 db    0
.xdata$x:000087A8                 db    0
.xdata$x:000087A9                 db    0
.xdata$x:000087AA                 db    0
.xdata$x:000087AB                 db    0
.xdata$x:000087AB _xdata$x        ends
.xdata$x:000087AB
.xdata$x:000087AC ; ===========================================================================
.xdata$x:000087AC
.xdata$x:000087AC ; Segment type: Pure data
.xdata$x:000087AC ; Segment permissions: Read
.xdata$x:000087AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000087AC                 assume cs:_xdata$x
.xdata$x:000087AC                 ;org 87ACh
.xdata$x:000087AC ; COMDAT (pick associative to section at 648C)
.xdata$x:000087AC __catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 db    0
.xdata$x:000087AC                                         ; DATA XREF: .xdata$x:000087DCo
.xdata$x:000087AD                 db    0
.xdata$x:000087AE                 db    0
.xdata$x:000087AF                 db    0
.xdata$x:000087B0                 db    0
.xdata$x:000087B1                 db    0
.xdata$x:000087B2                 db    0
.xdata$x:000087B3                 db    0
.xdata$x:000087B4                 db    0
.xdata$x:000087B5                 db    0
.xdata$x:000087B6                 db    0
.xdata$x:000087B7                 db    0
.xdata$x:000087B8                 dd offset __catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
.xdata$x:000087BC __unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ db 0FFh
.xdata$x:000087BC                                         ; DATA XREF: .xdata$x:000087E8o
.xdata$x:000087BD                 db 0FFh
.xdata$x:000087BE                 db 0FFh
.xdata$x:000087BF                 db 0FFh
.xdata$x:000087C0                 db    0
.xdata$x:000087C1                 db    0
.xdata$x:000087C2                 db    0
.xdata$x:000087C3                 db    0
.xdata$x:000087C4                 db 0FFh
.xdata$x:000087C5                 db 0FFh
.xdata$x:000087C6                 db 0FFh
.xdata$x:000087C7                 db 0FFh
.xdata$x:000087C8                 db    0
.xdata$x:000087C9                 db    0
.xdata$x:000087CA                 db    0
.xdata$x:000087CB                 db    0
.xdata$x:000087CC __tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ db    0
.xdata$x:000087CC                                         ; DATA XREF: .xdata$x:000087F0o
.xdata$x:000087CD                 db    0
.xdata$x:000087CE                 db    0
.xdata$x:000087CF                 db    0
.xdata$x:000087D0                 db    0
.xdata$x:000087D1                 db    0
.xdata$x:000087D2                 db    0
.xdata$x:000087D3                 db    0
.xdata$x:000087D4                 db    1
.xdata$x:000087D5                 db    0
.xdata$x:000087D6                 db    0
.xdata$x:000087D7                 db    0
.xdata$x:000087D8                 db    1
.xdata$x:000087D9                 db    0
.xdata$x:000087DA                 db    0
.xdata$x:000087DB                 db    0
.xdata$x:000087DC                 dd offset __catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
.xdata$x:000087E0 __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ db  22h ; "
.xdata$x:000087E0                                         ; DATA XREF: __ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ+11o
.xdata$x:000087E1                 db    5
.xdata$x:000087E2                 db  93h ; Ã´
.xdata$x:000087E3                 db  19h
.xdata$x:000087E4                 db    2
.xdata$x:000087E5                 db    0
.xdata$x:000087E6                 db    0
.xdata$x:000087E7                 db    0
.xdata$x:000087E8                 dd offset __unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
.xdata$x:000087EC                 db    1
.xdata$x:000087ED                 db    0
.xdata$x:000087EE                 db    0
.xdata$x:000087EF                 db    0
.xdata$x:000087F0                 dd offset __tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
.xdata$x:000087F4                 db    0
.xdata$x:000087F5                 db    0
.xdata$x:000087F6                 db    0
.xdata$x:000087F7                 db    0
.xdata$x:000087F8                 db    0
.xdata$x:000087F9                 db    0
.xdata$x:000087FA                 db    0
.xdata$x:000087FB                 db    0
.xdata$x:000087FC                 db    0
.xdata$x:000087FD                 db    0
.xdata$x:000087FE                 db    0
.xdata$x:000087FF                 db    0
.xdata$x:00008800                 db    0
.xdata$x:00008801                 db    0
.xdata$x:00008802                 db    0
.xdata$x:00008803                 db    0
.xdata$x:00008803 _xdata$x        ends
.xdata$x:00008803
.xdata$x:00008804 ; ===========================================================================
.xdata$x:00008804
.xdata$x:00008804 ; Segment type: Pure data
.xdata$x:00008804 ; Segment permissions: Read
.xdata$x:00008804 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008804                 assume cs:_xdata$x
.xdata$x:00008804                 ;org 8804h
.xdata$x:00008804 ; COMDAT (pick associative to section at 7198)
.xdata$x:00008804 __unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ db 0FFh
.xdata$x:00008804                                         ; DATA XREF: .xdata$x:00008814o
.xdata$x:00008805                 db 0FFh
.xdata$x:00008806                 db 0FFh
.xdata$x:00008807                 db 0FFh
.xdata$x:00008808                 dd offset __unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
.xdata$x:0000880C __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ db  22h ; "
.xdata$x:0000880C                                         ; DATA XREF: __ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ+11o
.xdata$x:0000880D                 db    5
.xdata$x:0000880E                 db  93h ; Ã´
.xdata$x:0000880F                 db  19h
.xdata$x:00008810                 db    1
.xdata$x:00008811                 db    0
.xdata$x:00008812                 db    0
.xdata$x:00008813                 db    0
.xdata$x:00008814                 dd offset __unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
.xdata$x:00008818                 db    0
.xdata$x:00008819                 db    0
.xdata$x:0000881A                 db    0
.xdata$x:0000881B                 db    0
.xdata$x:0000881C                 db    0
.xdata$x:0000881D                 db    0
.xdata$x:0000881E                 db    0
.xdata$x:0000881F                 db    0
.xdata$x:00008820                 db    0
.xdata$x:00008821                 db    0
.xdata$x:00008822                 db    0
.xdata$x:00008823                 db    0
.xdata$x:00008824                 db    0
.xdata$x:00008825                 db    0
.xdata$x:00008826                 db    0
.xdata$x:00008827                 db    0
.xdata$x:00008828                 db    0
.xdata$x:00008829                 db    0
.xdata$x:0000882A                 db    0
.xdata$x:0000882B                 db    0
.xdata$x:0000882C                 db    0
.xdata$x:0000882D                 db    0
.xdata$x:0000882E                 db    0
.xdata$x:0000882F                 db    0
.xdata$x:0000882F _xdata$x        ends
.xdata$x:0000882F
.xdata$x:00008830 ; ===========================================================================
.xdata$x:00008830
.xdata$x:00008830 ; Segment type: Pure data
.xdata$x:00008830 ; Segment permissions: Read
.xdata$x:00008830 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008830                 assume cs:_xdata$x
.xdata$x:00008830                 ;org 8830h
.xdata$x:00008830 __unwindtable$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z db 0FFh
.xdata$x:00008830                                         ; DATA XREF: .xdata$x:000088BCo
.xdata$x:00008831                 db 0FFh
.xdata$x:00008832                 db 0FFh
.xdata$x:00008833                 db 0FFh
.xdata$x:00008834                 dd offset __unwindfunclet$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z$0
.xdata$x:00008838 __unwindtable$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z db 0FFh
.xdata$x:00008838                                         ; DATA XREF: .xdata$x:00008904o
.xdata$x:00008839                 db 0FFh
.xdata$x:0000883A                 db 0FFh
.xdata$x:0000883B                 db 0FFh
.xdata$x:0000883C                 dd offset __unwindfunclet$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$0
.xdata$x:00008840 __unwindtable$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z db 0FFh
.xdata$x:00008840                                         ; DATA XREF: .xdata$x:0000894Co
.xdata$x:00008841                 db 0FFh
.xdata$x:00008842                 db 0FFh
.xdata$x:00008843                 db 0FFh
.xdata$x:00008844                 dd offset __unwindfunclet$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z$0
.xdata$x:00008848 __unwindtable$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z db 0FFh
.xdata$x:00008848                                         ; DATA XREF: .xdata$x:000088E0o
.xdata$x:00008849                 db 0FFh
.xdata$x:0000884A                 db 0FFh
.xdata$x:0000884B                 db 0FFh
.xdata$x:0000884C                 dd offset __unwindfunclet$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$0
.xdata$x:00008850                 db    0
.xdata$x:00008851                 db    0
.xdata$x:00008852                 db    0
.xdata$x:00008853                 db    0
.xdata$x:00008854                 dd offset __unwindfunclet$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$1
.xdata$x:00008858 __unwindtable$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z db 0FFh
.xdata$x:00008858                                         ; DATA XREF: .xdata$x:00008898o
.xdata$x:00008859                 db 0FFh
.xdata$x:0000885A                 db 0FFh
.xdata$x:0000885B                 db 0FFh
.xdata$x:0000885C                 dd offset __unwindfunclet$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$0
.xdata$x:00008860                 db 0FFh
.xdata$x:00008861                 db 0FFh
.xdata$x:00008862                 db 0FFh
.xdata$x:00008863                 db 0FFh
.xdata$x:00008864                 dd offset __unwindfunclet$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$1
.xdata$x:00008868                 db 0FFh
.xdata$x:00008869                 db 0FFh
.xdata$x:0000886A                 db 0FFh
.xdata$x:0000886B                 db 0FFh
.xdata$x:0000886C                 dd offset __unwindfunclet$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z$2
.xdata$x:00008870 __unwindtable$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z db 0FFh
.xdata$x:00008870                                         ; DATA XREF: .xdata$x:00008928o
.xdata$x:00008871                 db 0FFh
.xdata$x:00008872                 db 0FFh
.xdata$x:00008873                 db 0FFh
.xdata$x:00008874                 dd offset __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$0
.xdata$x:00008878                 db 0FFh
.xdata$x:00008879                 db 0FFh
.xdata$x:0000887A                 db 0FFh
.xdata$x:0000887B                 db 0FFh
.xdata$x:0000887C                 dd offset __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$1
.xdata$x:00008880                 db 0FFh
.xdata$x:00008881                 db 0FFh
.xdata$x:00008882                 db 0FFh
.xdata$x:00008883                 db 0FFh
.xdata$x:00008884                 dd offset __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$2
.xdata$x:00008888                 db 0FFh
.xdata$x:00008889                 db 0FFh
.xdata$x:0000888A                 db 0FFh
.xdata$x:0000888B                 db 0FFh
.xdata$x:0000888C                 dd offset __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$3
.xdata$x:00008890 __ehfuncinfo$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z db  22h ; "
.xdata$x:00008890                                         ; DATA XREF: __ehhandler$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z+1Eo
.xdata$x:00008891                 db    5
.xdata$x:00008892                 db  93h ; Ã´
.xdata$x:00008893                 db  19h
.xdata$x:00008894                 db    3
.xdata$x:00008895                 db    0
.xdata$x:00008896                 db    0
.xdata$x:00008897                 db    0
.xdata$x:00008898                 dd offset __unwindtable$?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.xdata$x:0000889C                 db    0
.xdata$x:0000889D                 db    0
.xdata$x:0000889E                 db    0
.xdata$x:0000889F                 db    0
.xdata$x:000088A0                 db    0
.xdata$x:000088A1                 db    0
.xdata$x:000088A2                 db    0
.xdata$x:000088A3                 db    0
.xdata$x:000088A4                 db    0
.xdata$x:000088A5                 db    0
.xdata$x:000088A6                 db    0
.xdata$x:000088A7                 db    0
.xdata$x:000088A8                 db    0
.xdata$x:000088A9                 db    0
.xdata$x:000088AA                 db    0
.xdata$x:000088AB                 db    0
.xdata$x:000088AC                 db    0
.xdata$x:000088AD                 db    0
.xdata$x:000088AE                 db    0
.xdata$x:000088AF                 db    0
.xdata$x:000088B0                 db    0
.xdata$x:000088B1                 db    0
.xdata$x:000088B2                 db    0
.xdata$x:000088B3                 db    0
.xdata$x:000088B4 __ehfuncinfo$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z db  22h ; "
.xdata$x:000088B4                                         ; DATA XREF: __ehhandler$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z+11o
.xdata$x:000088B5                 db    5
.xdata$x:000088B6                 db  93h ; Ã´
.xdata$x:000088B7                 db  19h
.xdata$x:000088B8                 db    1
.xdata$x:000088B9                 db    0
.xdata$x:000088BA                 db    0
.xdata$x:000088BB                 db    0
.xdata$x:000088BC                 dd offset __unwindtable$?ReadValue@TiXmlElementA@@IAEPBDPBDPAVTiXmlParsingDataA@@@Z
.xdata$x:000088C0                 db    0
.xdata$x:000088C1                 db    0
.xdata$x:000088C2                 db    0
.xdata$x:000088C3                 db    0
.xdata$x:000088C4                 db    0
.xdata$x:000088C5                 db    0
.xdata$x:000088C6                 db    0
.xdata$x:000088C7                 db    0
.xdata$x:000088C8                 db    0
.xdata$x:000088C9                 db    0
.xdata$x:000088CA                 db    0
.xdata$x:000088CB                 db    0
.xdata$x:000088CC                 db    0
.xdata$x:000088CD                 db    0
.xdata$x:000088CE                 db    0
.xdata$x:000088CF                 db    0
.xdata$x:000088D0                 db    0
.xdata$x:000088D1                 db    0
.xdata$x:000088D2                 db    0
.xdata$x:000088D3                 db    0
.xdata$x:000088D4                 db    0
.xdata$x:000088D5                 db    0
.xdata$x:000088D6                 db    0
.xdata$x:000088D7                 db    0
.xdata$x:000088D8 __ehfuncinfo$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z db  22h ; "
.xdata$x:000088D8                                         ; DATA XREF: __ehhandler$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z+1Eo
.xdata$x:000088D9                 db    5
.xdata$x:000088DA                 db  93h ; Ã´
.xdata$x:000088DB                 db  19h
.xdata$x:000088DC                 db    2
.xdata$x:000088DD                 db    0
.xdata$x:000088DE                 db    0
.xdata$x:000088DF                 db    0
.xdata$x:000088E0                 dd offset __unwindtable$?Parse@TiXmlElementA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z
.xdata$x:000088E4                 db    0
.xdata$x:000088E5                 db    0
.xdata$x:000088E6                 db    0
.xdata$x:000088E7                 db    0
.xdata$x:000088E8                 db    0
.xdata$x:000088E9                 db    0
.xdata$x:000088EA                 db    0
.xdata$x:000088EB                 db    0
.xdata$x:000088EC                 db    0
.xdata$x:000088ED                 db    0
.xdata$x:000088EE                 db    0
.xdata$x:000088EF                 db    0
.xdata$x:000088F0                 db    0
.xdata$x:000088F1                 db    0
.xdata$x:000088F2                 db    0
.xdata$x:000088F3                 db    0
.xdata$x:000088F4                 db    0
.xdata$x:000088F5                 db    0
.xdata$x:000088F6                 db    0
.xdata$x:000088F7                 db    0
.xdata$x:000088F8                 db    0
.xdata$x:000088F9                 db    0
.xdata$x:000088FA                 db    0
.xdata$x:000088FB                 db    0
.xdata$x:000088FC __ehfuncinfo$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z db  22h ; "
.xdata$x:000088FC                                         ; DATA XREF: __ehhandler$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z+1Bo
.xdata$x:000088FD                 db    5
.xdata$x:000088FE                 db  93h ; Ã´
.xdata$x:000088FF                 db  19h
.xdata$x:00008900                 db    1
.xdata$x:00008901                 db    0
.xdata$x:00008902                 db    0
.xdata$x:00008903                 db    0
.xdata$x:00008904                 dd offset __unwindtable$?StreamIn@TiXmlElementA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
.xdata$x:00008908                 align 20h
.xdata$x:00008920 __ehfuncinfo$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z db  22h ; "
.xdata$x:00008920                                         ; DATA XREF: __ehhandler$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z+11o
.xdata$x:00008921                 db    5
.xdata$x:00008922                 db  93h ; Ã´
.xdata$x:00008923                 db  19h
.xdata$x:00008924                 db    4
.xdata$x:00008925                 db    0
.xdata$x:00008926                 db    0
.xdata$x:00008927                 db    0
.xdata$x:00008928                 dd offset __unwindtable$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z
.xdata$x:0000892C                 db    0
.xdata$x:0000892D                 db    0
.xdata$x:0000892E                 db    0
.xdata$x:0000892F                 db    0
.xdata$x:00008930                 db    0
.xdata$x:00008931                 db    0
.xdata$x:00008932                 db    0
.xdata$x:00008933                 db    0
.xdata$x:00008934                 db    0
.xdata$x:00008935                 db    0
.xdata$x:00008936                 db    0
.xdata$x:00008937                 db    0
.xdata$x:00008938                 db    0
.xdata$x:00008939                 db    0
.xdata$x:0000893A                 db    0
.xdata$x:0000893B                 db    0
.xdata$x:0000893C                 db    0
.xdata$x:0000893D                 db    0
.xdata$x:0000893E                 db    0
.xdata$x:0000893F                 db    0
.xdata$x:00008940                 db    0
.xdata$x:00008941                 db    0
.xdata$x:00008942                 db    0
.xdata$x:00008943                 db    0
.xdata$x:00008944 __ehfuncinfo$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z db  22h ; "
.xdata$x:00008944                                         ; DATA XREF: __ehhandler$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z+1Bo
.xdata$x:00008945                 db    5
.xdata$x:00008946                 db  93h ; Ã´
.xdata$x:00008947                 db  19h
.xdata$x:00008948                 db    1
.xdata$x:00008949                 db    0
.xdata$x:0000894A                 db    0
.xdata$x:0000894B                 db    0
.xdata$x:0000894C                 dd offset __unwindtable$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z
.xdata$x:00008950                 db    0
.xdata$x:00008951                 db    0
.xdata$x:00008952                 db    0
.xdata$x:00008953                 db    0
.xdata$x:00008954                 db    0
.xdata$x:00008955                 db    0
.xdata$x:00008956                 db    0
.xdata$x:00008957                 db    0
.xdata$x:00008958                 db    0
.xdata$x:00008959                 db    0
.xdata$x:0000895A                 db    0
.xdata$x:0000895B                 db    0
.xdata$x:0000895C                 db    0
.xdata$x:0000895D                 db    0
.xdata$x:0000895E                 db    0
.xdata$x:0000895F                 db    0
.xdata$x:00008960                 db    0
.xdata$x:00008961                 db    0
.xdata$x:00008962                 db    0
.xdata$x:00008963                 db    0
.xdata$x:00008964                 db    0
.xdata$x:00008965                 db    0
.xdata$x:00008966                 db    0
.xdata$x:00008967                 db    0
.xdata$x:00008967 _xdata$x        ends
.xdata$x:00008967
.xdata$x:00008968 ; ===========================================================================
.xdata$x:00008968
.xdata$x:00008968 ; Segment type: Pure data
.xdata$x:00008968 ; Segment permissions: Read
.xdata$x:00008968 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008968                 assume cs:_xdata$x
.xdata$x:00008968                 ;org 8968h
.xdata$x:00008968 ; COMDAT (pick associative to section at 33E0)
.xdata$x:00008968 __unwindtable$??0TiXmlAttributeA@@QAE@XZ db 0FFh
.xdata$x:00008968                                         ; DATA XREF: .xdata$x:00008988o
.xdata$x:00008969                 db 0FFh
.xdata$x:0000896A                 db 0FFh
.xdata$x:0000896B                 db 0FFh
.xdata$x:0000896C                 dd offset __unwindfunclet$??0TiXmlAttributeA@@QAE@XZ$0
.xdata$x:00008970                 db    0
.xdata$x:00008971                 db    0
.xdata$x:00008972                 db    0
.xdata$x:00008973                 db    0
.xdata$x:00008974                 dd offset __unwindfunclet$??0TiXmlAttributeA@@QAE@XZ$1
.xdata$x:00008978                 db    1
.xdata$x:00008979                 db    0
.xdata$x:0000897A                 db    0
.xdata$x:0000897B                 db    0
.xdata$x:0000897C                 dd offset __unwindfunclet$??0TiXmlAttributeA@@QAE@XZ$2
.xdata$x:00008980 __ehfuncinfo$??0TiXmlAttributeA@@QAE@XZ db  22h ; "
.xdata$x:00008980                                         ; DATA XREF: __ehhandler$??0TiXmlAttributeA@@QAE@XZ+11o
.xdata$x:00008981                 db    5
.xdata$x:00008982                 db  93h ; Ã´
.xdata$x:00008983                 db  19h
.xdata$x:00008984                 db    3
.xdata$x:00008985                 db    0
.xdata$x:00008986                 db    0
.xdata$x:00008987                 db    0
.xdata$x:00008988                 dd offset __unwindtable$??0TiXmlAttributeA@@QAE@XZ
.xdata$x:0000898C                 db    0
.xdata$x:0000898D                 db    0
.xdata$x:0000898E                 db    0
.xdata$x:0000898F                 db    0
.xdata$x:00008990                 db    0
.xdata$x:00008991                 db    0
.xdata$x:00008992                 db    0
.xdata$x:00008993                 db    0
.xdata$x:00008994                 db    0
.xdata$x:00008995                 db    0
.xdata$x:00008996                 db    0
.xdata$x:00008997                 db    0
.xdata$x:00008998                 db    0
.xdata$x:00008999                 db    0
.xdata$x:0000899A                 db    0
.xdata$x:0000899B                 db    0
.xdata$x:0000899C                 db    0
.xdata$x:0000899D                 db    0
.xdata$x:0000899E                 db    0
.xdata$x:0000899F                 db    0
.xdata$x:000089A0                 db    0
.xdata$x:000089A1                 db    0
.xdata$x:000089A2                 db    0
.xdata$x:000089A3                 db    0
.xdata$x:000089A3 _xdata$x        ends
.xdata$x:000089A3
.xdata$x:000089A4 ; ===========================================================================
.xdata$x:000089A4
.xdata$x:000089A4 ; Segment type: Pure data
.xdata$x:000089A4 ; Segment permissions: Read
.xdata$x:000089A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000089A4                 assume cs:_xdata$x
.xdata$x:000089A4                 ;org 89A4h
.xdata$x:000089A4 ; COMDAT (pick associative to section at 463C)
.xdata$x:000089A4 __unwindtable$??1TiXmlAttributeA@@UAE@XZ db 0FFh
.xdata$x:000089A4                                         ; DATA XREF: .xdata$x:000089C4o
.xdata$x:000089A5                 db 0FFh
.xdata$x:000089A6                 db 0FFh
.xdata$x:000089A7                 db 0FFh
.xdata$x:000089A8                 dd offset __unwindfunclet$??1TiXmlAttributeA@@UAE@XZ$0
.xdata$x:000089AC                 align 10h
.xdata$x:000089B0                 dd offset __unwindfunclet$??1TiXmlAttributeA@@UAE@XZ$1
.xdata$x:000089B4                 db    1
.xdata$x:000089B5                 db    0
.xdata$x:000089B6                 db    0
.xdata$x:000089B7                 db    0
.xdata$x:000089B8                 dd offset __unwindfunclet$??1TiXmlAttributeA@@UAE@XZ$2
.xdata$x:000089BC __ehfuncinfo$??1TiXmlAttributeA@@UAE@XZ db  22h ; "
.xdata$x:000089BC                                         ; DATA XREF: __ehhandler$??1TiXmlAttributeA@@UAE@XZ+11o
.xdata$x:000089BD                 db    5
.xdata$x:000089BE                 db  93h ; Ã´
.xdata$x:000089BF                 db  19h
.xdata$x:000089C0                 db    3
.xdata$x:000089C1                 db    0
.xdata$x:000089C2                 db    0
.xdata$x:000089C3                 db    0
.xdata$x:000089C4                 dd offset __unwindtable$??1TiXmlAttributeA@@UAE@XZ
.xdata$x:000089C8                 align 20h
.xdata$x:000089C8 _xdata$x        ends
.xdata$x:000089C8
.xdata$x:000089E0 ; ===========================================================================
.xdata$x:000089E0
.xdata$x:000089E0 ; Segment type: Pure data
.xdata$x:000089E0 ; Segment permissions: Read
.xdata$x:000089E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000089E0                 assume cs:_xdata$x
.xdata$x:000089E0                 ;org 89E0h
.xdata$x:000089E0 ; COMDAT (pick associative to section at 34D4)
.xdata$x:000089E0 __unwindtable$??0TiXmlCommentA@@QAE@XZ db 0FFh
.xdata$x:000089E0                                         ; DATA XREF: .xdata$x:000089F0o
.xdata$x:000089E1                 db 0FFh
.xdata$x:000089E2                 db 0FFh
.xdata$x:000089E3                 db 0FFh
.xdata$x:000089E4                 dd offset __unwindfunclet$??0TiXmlCommentA@@QAE@XZ$0
.xdata$x:000089E8 __ehfuncinfo$??0TiXmlCommentA@@QAE@XZ db  22h ; "
.xdata$x:000089E8                                         ; DATA XREF: __ehhandler$??0TiXmlCommentA@@QAE@XZ+11o
.xdata$x:000089E9                 db    5
.xdata$x:000089EA                 db  93h ; Ã´
.xdata$x:000089EB                 db  19h
.xdata$x:000089EC                 db    1
.xdata$x:000089ED                 db    0
.xdata$x:000089EE                 db    0
.xdata$x:000089EF                 db    0
.xdata$x:000089F0                 dd offset __unwindtable$??0TiXmlCommentA@@QAE@XZ
.xdata$x:000089F4                 db    0
.xdata$x:000089F5                 db    0
.xdata$x:000089F6                 db    0
.xdata$x:000089F7                 db    0
.xdata$x:000089F8                 db    0
.xdata$x:000089F9                 db    0
.xdata$x:000089FA                 db    0
.xdata$x:000089FB                 db    0
.xdata$x:000089FC                 db    0
.xdata$x:000089FD                 db    0
.xdata$x:000089FE                 db    0
.xdata$x:000089FF                 db    0
.xdata$x:00008A00                 db    0
.xdata$x:00008A01                 db    0
.xdata$x:00008A02                 db    0
.xdata$x:00008A03                 db    0
.xdata$x:00008A04                 db    0
.xdata$x:00008A05                 db    0
.xdata$x:00008A06                 db    0
.xdata$x:00008A07                 db    0
.xdata$x:00008A08                 db    0
.xdata$x:00008A09                 db    0
.xdata$x:00008A0A                 db    0
.xdata$x:00008A0B                 db    0
.xdata$x:00008A0B _xdata$x        ends
.xdata$x:00008A0B
.xdata$x:00008A0C ; ===========================================================================
.xdata$x:00008A0C
.xdata$x:00008A0C ; Segment type: Pure data
.xdata$x:00008A0C ; Segment permissions: Read
.xdata$x:00008A0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008A0C                 assume cs:_xdata$x
.xdata$x:00008A0C                 ;org 8A0Ch
.xdata$x:00008A0C ; COMDAT (pick associative to section at 46F8)
.xdata$x:00008A0C __unwindtable$??1TiXmlCommentA@@UAE@XZ db 0FFh
.xdata$x:00008A0C                                         ; DATA XREF: .xdata$x:00008A1Co
.xdata$x:00008A0D                 db 0FFh
.xdata$x:00008A0E                 db 0FFh
.xdata$x:00008A0F                 db 0FFh
.xdata$x:00008A10                 dd offset __unwindfunclet$??1TiXmlCommentA@@UAE@XZ$0
.xdata$x:00008A14 __ehfuncinfo$??1TiXmlCommentA@@UAE@XZ db  22h ; "
.xdata$x:00008A14                                         ; DATA XREF: __ehhandler$??1TiXmlCommentA@@UAE@XZ+11o
.xdata$x:00008A15                 db    5
.xdata$x:00008A16                 db  93h ; Ã´
.xdata$x:00008A17                 db  19h
.xdata$x:00008A18                 db    1
.xdata$x:00008A19                 db    0
.xdata$x:00008A1A                 db    0
.xdata$x:00008A1B                 db    0
.xdata$x:00008A1C                 dd offset __unwindtable$??1TiXmlCommentA@@UAE@XZ
.xdata$x:00008A20                 db    0
.xdata$x:00008A21                 db    0
.xdata$x:00008A22                 db    0
.xdata$x:00008A23                 db    0
.xdata$x:00008A24                 db    0
.xdata$x:00008A25                 db    0
.xdata$x:00008A26                 db    0
.xdata$x:00008A27                 db    0
.xdata$x:00008A28                 db    0
.xdata$x:00008A29                 db    0
.xdata$x:00008A2A                 db    0
.xdata$x:00008A2B                 db    0
.xdata$x:00008A2C                 db    0
.xdata$x:00008A2D                 db    0
.xdata$x:00008A2E                 db    0
.xdata$x:00008A2F                 db    0
.xdata$x:00008A30                 db    0
.xdata$x:00008A31                 db    0
.xdata$x:00008A32                 db    0
.xdata$x:00008A33                 db    0
.xdata$x:00008A34                 db    0
.xdata$x:00008A35                 db    0
.xdata$x:00008A36                 db    0
.xdata$x:00008A37                 db    0
.xdata$x:00008A37 _xdata$x        ends
.xdata$x:00008A37
.xdata$x:00008A38 ; ===========================================================================
.xdata$x:00008A38
.xdata$x:00008A38 ; Segment type: Pure data
.xdata$x:00008A38 ; Segment permissions: Read
.xdata$x:00008A38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008A38                 assume cs:_xdata$x
.xdata$x:00008A38                 ;org 8A38h
.xdata$x:00008A38 ; COMDAT (pick associative to section at 3690)
.xdata$x:00008A38 __unwindtable$??0TiXmlTextA@@QAE@PBD@Z db 0FFh
.xdata$x:00008A38                                         ; DATA XREF: .xdata$x:00008A48o
.xdata$x:00008A39                 db 0FFh
.xdata$x:00008A3A                 db 0FFh
.xdata$x:00008A3B                 db 0FFh
.xdata$x:00008A3C                 dd offset __unwindfunclet$??0TiXmlTextA@@QAE@PBD@Z$0
.xdata$x:00008A40 __ehfuncinfo$??0TiXmlTextA@@QAE@PBD@Z db  22h ; "
.xdata$x:00008A40                                         ; DATA XREF: __ehhandler$??0TiXmlTextA@@QAE@PBD@Z+11o
.xdata$x:00008A41                 db    5
.xdata$x:00008A42                 db  93h ; Ã´
.xdata$x:00008A43                 db  19h
.xdata$x:00008A44                 db    1
.xdata$x:00008A45                 db    0
.xdata$x:00008A46                 db    0
.xdata$x:00008A47                 db    0
.xdata$x:00008A48                 dd offset __unwindtable$??0TiXmlTextA@@QAE@PBD@Z
.xdata$x:00008A4C                 db    0
.xdata$x:00008A4D                 db    0
.xdata$x:00008A4E                 db    0
.xdata$x:00008A4F                 db    0
.xdata$x:00008A50                 db    0
.xdata$x:00008A51                 db    0
.xdata$x:00008A52                 db    0
.xdata$x:00008A53                 db    0
.xdata$x:00008A54                 db    0
.xdata$x:00008A55                 db    0
.xdata$x:00008A56                 db    0
.xdata$x:00008A57                 db    0
.xdata$x:00008A58                 db    0
.xdata$x:00008A59                 db    0
.xdata$x:00008A5A                 db    0
.xdata$x:00008A5B                 db    0
.xdata$x:00008A5C                 db    0
.xdata$x:00008A5D                 db    0
.xdata$x:00008A5E                 db    0
.xdata$x:00008A5F                 db    0
.xdata$x:00008A60                 db    0
.xdata$x:00008A61                 db    0
.xdata$x:00008A62                 db    0
.xdata$x:00008A63                 db    0
.xdata$x:00008A63 _xdata$x        ends
.xdata$x:00008A63
.xdata$x:00008A64 ; ===========================================================================
.xdata$x:00008A64
.xdata$x:00008A64 ; Segment type: Pure data
.xdata$x:00008A64 ; Segment permissions: Read
.xdata$x:00008A64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008A64                 assume cs:_xdata$x
.xdata$x:00008A64                 ;org 8A64h
.xdata$x:00008A64 ; COMDAT (pick associative to section at 4838)
.xdata$x:00008A64 __unwindtable$??1TiXmlTextA@@UAE@XZ db 0FFh
.xdata$x:00008A64                                         ; DATA XREF: .xdata$x:00008A74o
.xdata$x:00008A65                 db 0FFh
.xdata$x:00008A66                 db 0FFh
.xdata$x:00008A67                 db 0FFh
.xdata$x:00008A68                 dd offset __unwindfunclet$??1TiXmlTextA@@UAE@XZ$0
.xdata$x:00008A6C __ehfuncinfo$??1TiXmlTextA@@UAE@XZ db  22h ; "
.xdata$x:00008A6C                                         ; DATA XREF: __ehhandler$??1TiXmlTextA@@UAE@XZ+11o
.xdata$x:00008A6D                 db    5
.xdata$x:00008A6E                 db  93h ; Ã´
.xdata$x:00008A6F                 db  19h
.xdata$x:00008A70                 db    1
.xdata$x:00008A71                 db    0
.xdata$x:00008A72                 db    0
.xdata$x:00008A73                 db    0
.xdata$x:00008A74                 dd offset __unwindtable$??1TiXmlTextA@@UAE@XZ
.xdata$x:00008A78                 db    0
.xdata$x:00008A79                 db    0
.xdata$x:00008A7A                 db    0
.xdata$x:00008A7B                 db    0
.xdata$x:00008A7C                 db    0
.xdata$x:00008A7D                 db    0
.xdata$x:00008A7E                 db    0
.xdata$x:00008A7F                 db    0
.xdata$x:00008A80                 db    0
.xdata$x:00008A81                 db    0
.xdata$x:00008A82                 db    0
.xdata$x:00008A83                 db    0
.xdata$x:00008A84                 db    0
.xdata$x:00008A85                 db    0
.xdata$x:00008A86                 db    0
.xdata$x:00008A87                 db    0
.xdata$x:00008A88                 db    0
.xdata$x:00008A89                 db    0
.xdata$x:00008A8A                 db    0
.xdata$x:00008A8B                 db    0
.xdata$x:00008A8C                 db    0
.xdata$x:00008A8D                 db    0
.xdata$x:00008A8E                 db    0
.xdata$x:00008A8F                 db    0
.xdata$x:00008A8F _xdata$x        ends
.xdata$x:00008A8F
.xdata$x:00008A90 ; ===========================================================================
.xdata$x:00008A90
.xdata$x:00008A90 ; Segment type: Pure data
.xdata$x:00008A90 ; Segment permissions: Read
.xdata$x:00008A90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008A90                 assume cs:_xdata$x
.xdata$x:00008A90                 ;org 8A90h
.xdata$x:00008A90 ; COMDAT (pick associative to section at 356C)
.xdata$x:00008A90 __unwindtable$??0TiXmlDeclarationA@@QAE@XZ db 0FFh
.xdata$x:00008A90                                         ; DATA XREF: .xdata$x:00008AB8o
.xdata$x:00008A91                 db 0FFh
.xdata$x:00008A92                 db 0FFh
.xdata$x:00008A93                 db 0FFh
.xdata$x:00008A94                 dd offset __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$0
.xdata$x:00008A98                 db    0
.xdata$x:00008A99                 db    0
.xdata$x:00008A9A                 db    0
.xdata$x:00008A9B                 db    0
.xdata$x:00008A9C                 dd offset __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$1
.xdata$x:00008AA0                 db    1
.xdata$x:00008AA1                 db    0
.xdata$x:00008AA2                 db    0
.xdata$x:00008AA3                 db    0
.xdata$x:00008AA4                 dd offset __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$2
.xdata$x:00008AA8                 db    2
.xdata$x:00008AA9                 db    0
.xdata$x:00008AAA                 db    0
.xdata$x:00008AAB                 db    0
.xdata$x:00008AAC                 dd offset __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$3
.xdata$x:00008AB0 __ehfuncinfo$??0TiXmlDeclarationA@@QAE@XZ db  22h ; "
.xdata$x:00008AB0                                         ; DATA XREF: __ehhandler$??0TiXmlDeclarationA@@QAE@XZ+11o
.xdata$x:00008AB1                 db    5
.xdata$x:00008AB2                 db  93h ; Ã´
.xdata$x:00008AB3                 db  19h
.xdata$x:00008AB4                 db    4
.xdata$x:00008AB5                 db    0
.xdata$x:00008AB6                 db    0
.xdata$x:00008AB7                 db    0
.xdata$x:00008AB8                 dd offset __unwindtable$??0TiXmlDeclarationA@@QAE@XZ
.xdata$x:00008ABC                 db    0
.xdata$x:00008ABD                 db    0
.xdata$x:00008ABE                 db    0
.xdata$x:00008ABF                 db    0
.xdata$x:00008AC0                 db    0
.xdata$x:00008AC1                 db    0
.xdata$x:00008AC2                 db    0
.xdata$x:00008AC3                 db    0
.xdata$x:00008AC4                 db    0
.xdata$x:00008AC5                 db    0
.xdata$x:00008AC6                 db    0
.xdata$x:00008AC7                 db    0
.xdata$x:00008AC8                 db    0
.xdata$x:00008AC9                 db    0
.xdata$x:00008ACA                 db    0
.xdata$x:00008ACB                 db    0
.xdata$x:00008ACC                 db    0
.xdata$x:00008ACD                 db    0
.xdata$x:00008ACE                 db    0
.xdata$x:00008ACF                 db    0
.xdata$x:00008AD0                 db    0
.xdata$x:00008AD1                 db    0
.xdata$x:00008AD2                 db    0
.xdata$x:00008AD3                 db    0
.xdata$x:00008AD3 _xdata$x        ends
.xdata$x:00008AD3
.xdata$x:00008AD4 ; ===========================================================================
.xdata$x:00008AD4
.xdata$x:00008AD4 ; Segment type: Pure data
.xdata$x:00008AD4 ; Segment permissions: Read
.xdata$x:00008AD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008AD4                 assume cs:_xdata$x
.xdata$x:00008AD4                 ;org 8AD4h
.xdata$x:00008AD4 ; COMDAT (pick associative to section at 4770)
.xdata$x:00008AD4 __unwindtable$??1TiXmlDeclarationA@@UAE@XZ db 0FFh
.xdata$x:00008AD4                                         ; DATA XREF: .xdata$x:00008AFCo
.xdata$x:00008AD5                 db 0FFh
.xdata$x:00008AD6                 db 0FFh
.xdata$x:00008AD7                 db 0FFh
.xdata$x:00008AD8                 dd offset __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$0
.xdata$x:00008ADC                 align 10h
.xdata$x:00008AE0                 dd offset __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$1
.xdata$x:00008AE4                 db    1
.xdata$x:00008AE5                 db    0
.xdata$x:00008AE6                 db    0
.xdata$x:00008AE7                 db    0
.xdata$x:00008AE8                 dd offset __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$2
.xdata$x:00008AEC                 db    2
.xdata$x:00008AED                 db    0
.xdata$x:00008AEE                 db    0
.xdata$x:00008AEF                 db    0
.xdata$x:00008AF0                 dd offset __unwindfunclet$??1TiXmlDeclarationA@@UAE@XZ$3
.xdata$x:00008AF4 __ehfuncinfo$??1TiXmlDeclarationA@@UAE@XZ db  22h ; "
.xdata$x:00008AF4                                         ; DATA XREF: __ehhandler$??1TiXmlDeclarationA@@UAE@XZ+11o
.xdata$x:00008AF5                 db    5
.xdata$x:00008AF6                 db  93h ; Ã´
.xdata$x:00008AF7                 db  19h
.xdata$x:00008AF8                 db    4
.xdata$x:00008AF9                 db    0
.xdata$x:00008AFA                 db    0
.xdata$x:00008AFB                 db    0
.xdata$x:00008AFC                 dd offset __unwindtable$??1TiXmlDeclarationA@@UAE@XZ
.xdata$x:00008B00                 db    0
.xdata$x:00008B01                 db    0
.xdata$x:00008B02                 db    0
.xdata$x:00008B03                 db    0
.xdata$x:00008B04                 db    0
.xdata$x:00008B05                 db    0
.xdata$x:00008B06                 db    0
.xdata$x:00008B07                 db    0
.xdata$x:00008B08                 db    0
.xdata$x:00008B09                 db    0
.xdata$x:00008B0A                 db    0
.xdata$x:00008B0B                 db    0
.xdata$x:00008B0C                 db    0
.xdata$x:00008B0D                 db    0
.xdata$x:00008B0E                 db    0
.xdata$x:00008B0F                 db    0
.xdata$x:00008B10                 db    0
.xdata$x:00008B11                 db    0
.xdata$x:00008B12                 db    0
.xdata$x:00008B13                 db    0
.xdata$x:00008B14                 db    0
.xdata$x:00008B15                 db    0
.xdata$x:00008B16                 db    0
.xdata$x:00008B17                 db    0
.xdata$x:00008B17 _xdata$x        ends
.xdata$x:00008B17
.xdata$x:00008B18 ; ===========================================================================
.xdata$x:00008B18
.xdata$x:00008B18 ; Segment type: Pure data
.xdata$x:00008B18 ; Segment permissions: Read
.xdata$x:00008B18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008B18                 assume cs:_xdata$x
.xdata$x:00008B18                 ;org 8B18h
.xdata$x:00008B18 ; COMDAT (pick associative to section at 371C)
.xdata$x:00008B18 __unwindtable$??0TiXmlUnknownA@@QAE@XZ db 0FFh
.xdata$x:00008B18                                         ; DATA XREF: .xdata$x:00008B28o
.xdata$x:00008B19                 db 0FFh
.xdata$x:00008B1A                 db 0FFh
.xdata$x:00008B1B                 db 0FFh
.xdata$x:00008B1C                 dd offset __unwindfunclet$??0TiXmlUnknownA@@QAE@XZ$0
.xdata$x:00008B20 __ehfuncinfo$??0TiXmlUnknownA@@QAE@XZ db  22h ; "
.xdata$x:00008B20                                         ; DATA XREF: __ehhandler$??0TiXmlUnknownA@@QAE@XZ+11o
.xdata$x:00008B21                 db    5
.xdata$x:00008B22                 db  93h ; Ã´
.xdata$x:00008B23                 db  19h
.xdata$x:00008B24                 db    1
.xdata$x:00008B25                 db    0
.xdata$x:00008B26                 db    0
.xdata$x:00008B27                 db    0
.xdata$x:00008B28                 dd offset __unwindtable$??0TiXmlUnknownA@@QAE@XZ
.xdata$x:00008B2C                 db    0
.xdata$x:00008B2D                 db    0
.xdata$x:00008B2E                 db    0
.xdata$x:00008B2F                 db    0
.xdata$x:00008B30                 db    0
.xdata$x:00008B31                 db    0
.xdata$x:00008B32                 db    0
.xdata$x:00008B33                 db    0
.xdata$x:00008B34                 db    0
.xdata$x:00008B35                 db    0
.xdata$x:00008B36                 db    0
.xdata$x:00008B37                 db    0
.xdata$x:00008B38                 db    0
.xdata$x:00008B39                 db    0
.xdata$x:00008B3A                 db    0
.xdata$x:00008B3B                 db    0
.xdata$x:00008B3C                 db    0
.xdata$x:00008B3D                 db    0
.xdata$x:00008B3E                 db    0
.xdata$x:00008B3F                 db    0
.xdata$x:00008B40                 db    0
.xdata$x:00008B41                 db    0
.xdata$x:00008B42                 db    0
.xdata$x:00008B43                 db    0
.xdata$x:00008B43 _xdata$x        ends
.xdata$x:00008B43
.xdata$x:00008B44 ; ===========================================================================
.xdata$x:00008B44
.xdata$x:00008B44 ; Segment type: Pure data
.xdata$x:00008B44 ; Segment permissions: Read
.xdata$x:00008B44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008B44                 assume cs:_xdata$x
.xdata$x:00008B44                 ;org 8B44h
.xdata$x:00008B44 ; COMDAT (pick associative to section at 48B0)
.xdata$x:00008B44 __unwindtable$??1TiXmlUnknownA@@UAE@XZ db 0FFh
.xdata$x:00008B44                                         ; DATA XREF: .xdata$x:00008B54o
.xdata$x:00008B45                 db 0FFh
.xdata$x:00008B46                 db 0FFh
.xdata$x:00008B47                 db 0FFh
.xdata$x:00008B48                 dd offset __unwindfunclet$??1TiXmlUnknownA@@UAE@XZ$0
.xdata$x:00008B4C __ehfuncinfo$??1TiXmlUnknownA@@UAE@XZ db  22h ; "
.xdata$x:00008B4C                                         ; DATA XREF: __ehhandler$??1TiXmlUnknownA@@UAE@XZ+11o
.xdata$x:00008B4D                 db    5
.xdata$x:00008B4E                 db  93h ; Ã´
.xdata$x:00008B4F                 db  19h
.xdata$x:00008B50                 db    1
.xdata$x:00008B51                 db    0
.xdata$x:00008B52                 db    0
.xdata$x:00008B53                 db    0
.xdata$x:00008B54                 dd offset __unwindtable$??1TiXmlUnknownA@@UAE@XZ
.xdata$x:00008B58                 db    0
.xdata$x:00008B59                 db    0
.xdata$x:00008B5A                 db    0
.xdata$x:00008B5B                 db    0
.xdata$x:00008B5C                 db    0
.xdata$x:00008B5D                 db    0
.xdata$x:00008B5E                 db    0
.xdata$x:00008B5F                 db    0
.xdata$x:00008B60                 db    0
.xdata$x:00008B61                 db    0
.xdata$x:00008B62                 db    0
.xdata$x:00008B63                 db    0
.xdata$x:00008B64                 db    0
.xdata$x:00008B65                 db    0
.xdata$x:00008B66                 db    0
.xdata$x:00008B67                 db    0
.xdata$x:00008B68                 db    0
.xdata$x:00008B69                 db    0
.xdata$x:00008B6A                 db    0
.xdata$x:00008B6B                 db    0
.xdata$x:00008B6C                 db    0
.xdata$x:00008B6D                 db    0
.xdata$x:00008B6E                 db    0
.xdata$x:00008B6F                 db    0
.xdata$x:00008B6F _xdata$x        ends
.xdata$x:00008B6F
.xdata$x:00008B70 ; ===========================================================================
.xdata$x:00008B70
.xdata$x:00008B70 ; Segment type: Pure data
.xdata$x:00008B70 ; Segment permissions: Read
.xdata$x:00008B70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008B70                 assume cs:_xdata$x
.xdata$x:00008B70                 ;org 8B70h
.xdata$x:00008B70 ; COMDAT (pick associative to section at 2CF0)
.xdata$x:00008B70 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00008B70                                         ; DATA XREF: .xdata$x:00008B80o
.xdata$x:00008B71                 db 0FFh
.xdata$x:00008B72                 db 0FFh
.xdata$x:00008B73                 db 0FFh
.xdata$x:00008B74                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00008B78 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00008B78                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00008B79                 db    5
.xdata$x:00008B7A                 db  93h ; Ã´
.xdata$x:00008B7B                 db  19h
.xdata$x:00008B7C                 db    1
.xdata$x:00008B7D                 db    0
.xdata$x:00008B7E                 db    0
.xdata$x:00008B7F                 db    0
.xdata$x:00008B80                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00008B84                 db    0
.xdata$x:00008B85                 db    0
.xdata$x:00008B86                 db    0
.xdata$x:00008B87                 db    0
.xdata$x:00008B88                 db    0
.xdata$x:00008B89                 db    0
.xdata$x:00008B8A                 db    0
.xdata$x:00008B8B                 db    0
.xdata$x:00008B8C                 db    0
.xdata$x:00008B8D                 db    0
.xdata$x:00008B8E                 db    0
.xdata$x:00008B8F                 db    0
.xdata$x:00008B90                 db    0
.xdata$x:00008B91                 db    0
.xdata$x:00008B92                 db    0
.xdata$x:00008B93                 db    0
.xdata$x:00008B94                 db    0
.xdata$x:00008B95                 db    0
.xdata$x:00008B96                 db    0
.xdata$x:00008B97                 db    0
.xdata$x:00008B98                 db    0
.xdata$x:00008B99                 db    0
.xdata$x:00008B9A                 db    0
.xdata$x:00008B9B                 db    0
.xdata$x:00008B9B _xdata$x        ends
.xdata$x:00008B9B
.xdata$x:00008B9C ; ===========================================================================
.xdata$x:00008B9C
.xdata$x:00008B9C ; Segment type: Pure data
.xdata$x:00008B9C ; Segment permissions: Read
.xdata$x:00008B9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008B9C                 assume cs:_xdata$x
.xdata$x:00008B9C                 ;org 8B9Ch
.xdata$x:00008B9C ; COMDAT (pick associative to section at 41FC)
.xdata$x:00008B9C __unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z db 0FFh
.xdata$x:00008B9C                                         ; DATA XREF: .xdata$x:00008BACo
.xdata$x:00008B9D                 db 0FFh
.xdata$x:00008B9E                 db 0FFh
.xdata$x:00008B9F                 db 0FFh
.xdata$x:00008BA0                 dd offset __unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
.xdata$x:00008BA4 __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z db  22h ; "
.xdata$x:00008BA4                                         ; DATA XREF: __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z+11o
.xdata$x:00008BA5                 db    5
.xdata$x:00008BA6                 db  93h ; Ã´
.xdata$x:00008BA7                 db  19h
.xdata$x:00008BA8                 db    1
.xdata$x:00008BA9                 db    0
.xdata$x:00008BAA                 db    0
.xdata$x:00008BAB                 db    0
.xdata$x:00008BAC                 dd offset __unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
.xdata$x:00008BB0                 db    0
.xdata$x:00008BB1                 db    0
.xdata$x:00008BB2                 db    0
.xdata$x:00008BB3                 db    0
.xdata$x:00008BB4                 db    0
.xdata$x:00008BB5                 db    0
.xdata$x:00008BB6                 db    0
.xdata$x:00008BB7                 db    0
.xdata$x:00008BB8                 db    0
.xdata$x:00008BB9                 db    0
.xdata$x:00008BBA                 db    0
.xdata$x:00008BBB                 db    0
.xdata$x:00008BBC                 db    0
.xdata$x:00008BBD                 db    0
.xdata$x:00008BBE                 db    0
.xdata$x:00008BBF                 db    0
.xdata$x:00008BC0                 db    0
.xdata$x:00008BC1                 db    0
.xdata$x:00008BC2                 db    0
.xdata$x:00008BC3                 db    0
.xdata$x:00008BC4                 db    0
.xdata$x:00008BC5                 db    0
.xdata$x:00008BC6                 db    0
.xdata$x:00008BC7                 db    0
.xdata$x:00008BC7 _xdata$x        ends
.xdata$x:00008BC7
.xdata$x:00008BC8 ; ===========================================================================
.xdata$x:00008BC8
.xdata$x:00008BC8 ; Segment type: Pure data
.xdata$x:00008BC8 ; Segment permissions: Read
.xdata$x:00008BC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008BC8                 assume cs:_xdata$x
.xdata$x:00008BC8                 ;org 8BC8h
.xdata$x:00008BC8 ; COMDAT (pick associative to section at 4F58)
.xdata$x:00008BC8 __unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008BC8                                         ; DATA XREF: .xdata$x:00008BD8o
.xdata$x:00008BC9                 db 0FFh
.xdata$x:00008BCA                 db 0FFh
.xdata$x:00008BCB                 db 0FFh
.xdata$x:00008BCC                 dd offset __unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
.xdata$x:00008BD0 __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008BD0                                         ; DATA XREF: __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ+11o
.xdata$x:00008BD1                 db    5
.xdata$x:00008BD2                 db  93h ; Ã´
.xdata$x:00008BD3                 db  19h
.xdata$x:00008BD4                 db    1
.xdata$x:00008BD5                 db    0
.xdata$x:00008BD6                 db    0
.xdata$x:00008BD7                 db    0
.xdata$x:00008BD8                 dd offset __unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
.xdata$x:00008BDC                 db    0
.xdata$x:00008BDD                 db    0
.xdata$x:00008BDE                 db    0
.xdata$x:00008BDF                 db    0
.xdata$x:00008BE0                 db    0
.xdata$x:00008BE1                 db    0
.xdata$x:00008BE2                 db    0
.xdata$x:00008BE3                 db    0
.xdata$x:00008BE4                 db    0
.xdata$x:00008BE5                 db    0
.xdata$x:00008BE6                 db    0
.xdata$x:00008BE7                 db    0
.xdata$x:00008BE8                 db    0
.xdata$x:00008BE9                 db    0
.xdata$x:00008BEA                 db    0
.xdata$x:00008BEB                 db    0
.xdata$x:00008BEC                 db    0
.xdata$x:00008BED                 db    0
.xdata$x:00008BEE                 db    0
.xdata$x:00008BEF                 db    0
.xdata$x:00008BF0                 db    0
.xdata$x:00008BF1                 db    0
.xdata$x:00008BF2                 db    0
.xdata$x:00008BF3                 db    0
.xdata$x:00008BF3 _xdata$x        ends
.xdata$x:00008BF3
.xdata$x:00008BF4 ; ===========================================================================
.xdata$x:00008BF4
.xdata$x:00008BF4 ; Segment type: Pure data
.xdata$x:00008BF4 ; Segment permissions: Read
.xdata$x:00008BF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008BF4                 assume cs:_xdata$x
.xdata$x:00008BF4                 ;org 8BF4h
.xdata$x:00008BF4 ; COMDAT (pick associative to section at 2C1C)
.xdata$x:00008BF4 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00008BF4                                         ; DATA XREF: .xdata$x:00008C04o
.xdata$x:00008BF5                 db 0FFh
.xdata$x:00008BF6                 db 0FFh
.xdata$x:00008BF7                 db 0FFh
.xdata$x:00008BF8                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00008BFC __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00008BFC                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00008BFD                 db    5
.xdata$x:00008BFE                 db  93h ; Ã´
.xdata$x:00008BFF                 db  19h
.xdata$x:00008C00                 db    1
.xdata$x:00008C01                 db    0
.xdata$x:00008C02                 db    0
.xdata$x:00008C03                 db    0
.xdata$x:00008C04                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00008C08                 align 20h
.xdata$x:00008C08 _xdata$x        ends
.xdata$x:00008C08
.bss:00008C20 ; ===========================================================================
.bss:00008C20
.bss:00008C20 ; Segment type: Uninitialized
.bss:00008C20 ; Segment permissions: Read/Write
.bss:00008C20 _bss            segment byte public 'BSS' use32
.bss:00008C20                 assume cs:_bss
.bss:00008C20                 ;org 8C20h
.bss:00008C20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00008C20 _allocator_arg  db    ? ;
.bss:00008C21 _piecewise_construct db    ? ;
.bss:00008C22                 align 4
.bss:00008C22 _bss            ends
.bss:00008C22
.rdata:00008C24 ; ===========================================================================
.rdata:00008C24
.rdata:00008C24 ; Segment type: Pure data
.rdata:00008C24 ; Segment permissions: Read
.rdata:00008C24 _rdata          segment dword public 'DATA' use32
.rdata:00008C24                 assume cs:_rdata
.rdata:00008C24                 ;org 8C24h
.rdata:00008C24 ; COMDAT (pick any)
.rdata:00008C24                 public ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
.rdata:00008C24 ; size_t std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.rdata:00008C24 ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB dd 0FFFFFFFFh
.rdata:00008C24                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+5Br
.rdata:00008C24                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+7r ...
.rdata:00008C24 _rdata          ends
.rdata:00008C24
.rdata:00008C28 ; ===========================================================================
.rdata:00008C28
.rdata:00008C28 ; Segment type: Pure data
.rdata:00008C28 ; Segment permissions: Read
.rdata:00008C28 _rdata          segment dword public 'DATA' use32
.rdata:00008C28                 assume cs:_rdata
.rdata:00008C28                 ;org 8C28h
.rdata:00008C28 ; COMDAT (pick largest)
.rdata:00008C28                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:00008C2C                 public ??_7runtime_error@std@@6B@
.rdata:00008C2C ; const std::runtime_error::`vftable'
.rdata:00008C2C ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:00008C2C                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:00008C2C                                         ; std::runtime_error::runtime_error(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+49o ...
.rdata:00008C2C                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:00008C30                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00008C30 _rdata          ends
.rdata:00008C30
.xdata$x:00008C34 ; ===========================================================================
.xdata$x:00008C34
.xdata$x:00008C34 ; Segment type: Pure data
.xdata$x:00008C34 ; Segment permissions: Read
.xdata$x:00008C34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008C34                 assume cs:_xdata$x
.xdata$x:00008C34                 ;org 8C34h
.xdata$x:00008C34 ; COMDAT (pick any)
.xdata$x:00008C34                 public __TI2?AVruntime_error@std@@
.xdata$x:00008C34 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: std::_Locinfo::_Locinfo(char const *)+A6o
.xdata$x:00008C35                 db    0
.xdata$x:00008C36                 db    0
.xdata$x:00008C37                 db    0
.xdata$x:00008C38                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:00008C3C                 align 10h
.xdata$x:00008C40                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:00008C40 _xdata$x        ends
.xdata$x:00008C40
.xdata$x:00008C44 ; ===========================================================================
.xdata$x:00008C44
.xdata$x:00008C44 ; Segment type: Pure data
.xdata$x:00008C44 ; Segment permissions: Read
.xdata$x:00008C44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008C44                 assume cs:_xdata$x
.xdata$x:00008C44                 ;org 8C44h
.xdata$x:00008C44 ; COMDAT (pick any)
.xdata$x:00008C44                 public __CTA2?AVruntime_error@std@@
.xdata$x:00008C44 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:00008C40o
.xdata$x:00008C45                 db    0
.xdata$x:00008C46                 db    0
.xdata$x:00008C47                 db    0
.xdata$x:00008C48                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00008C4C                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00008C4C _xdata$x        ends
.xdata$x:00008C4C
.data$r:00008C50 ; ===========================================================================
.data$r:00008C50
.data$r:00008C50 ; Segment type: Pure data
.data$r:00008C50 ; Segment permissions: Read/Write
.data$r:00008C50 _data$r         segment dword public 'DATA' use32
.data$r:00008C50                 assume cs:_data$r
.data$r:00008C50                 ;org 8C50h
.data$r:00008C50 ; COMDAT (pick any)
.data$r:00008C50                 public ??_R0?AVruntime_error@std@@@8
.data$r:00008C50 ; class std::runtime_error `RTTI Type Descriptor'
.data$r:00008C50 ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00008C50                                         ; DATA XREF: .xdata$x:00008C74o
.data$r:00008C50                                         ; .rdata$r:000093DCo ...
.data$r:00008C50                                         ; const type_info::`vftable'
.data$r:00008C54                 align 8
.data$r:00008C58 a_?avruntime_er db '.?AVruntime_error@std@@',0
.data$r:00008C58 _data$r         ends
.data$r:00008C58
.xdata$x:00008C70 ; ===========================================================================
.xdata$x:00008C70
.xdata$x:00008C70 ; Segment type: Pure data
.xdata$x:00008C70 ; Segment permissions: Read
.xdata$x:00008C70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008C70                 assume cs:_xdata$x
.xdata$x:00008C70                 ;org 8C70h
.xdata$x:00008C70 ; COMDAT (pick any)
.xdata$x:00008C70                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00008C70 __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00008C70                                         ; DATA XREF: .xdata$x:00008C48o
.xdata$x:00008C70                                         ; .xdata$x:00008F18o
.xdata$x:00008C71                 db    0
.xdata$x:00008C72                 db    0
.xdata$x:00008C73                 db    0
.xdata$x:00008C74                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:00008C78                 db    0
.xdata$x:00008C79                 db    0
.xdata$x:00008C7A                 db    0
.xdata$x:00008C7B                 db    0
.xdata$x:00008C7C                 db 0FFh
.xdata$x:00008C7D                 db 0FFh
.xdata$x:00008C7E                 db 0FFh
.xdata$x:00008C7F                 db 0FFh
.xdata$x:00008C80                 db    0
.xdata$x:00008C81                 db    0
.xdata$x:00008C82                 db    0
.xdata$x:00008C83                 db    0
.xdata$x:00008C84                 db  0Ch
.xdata$x:00008C85                 db    0
.xdata$x:00008C86                 db    0
.xdata$x:00008C87                 db    0
.xdata$x:00008C88                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:00008C88 _xdata$x        ends
.xdata$x:00008C88
.data$r:00008C8C ; ===========================================================================
.data$r:00008C8C
.data$r:00008C8C ; Segment type: Pure data
.data$r:00008C8C ; Segment permissions: Read/Write
.data$r:00008C8C _data$r         segment dword public 'DATA' use32
.data$r:00008C8C                 assume cs:_data$r
.data$r:00008C8C                 ;org 8C8Ch
.data$r:00008C8C ; COMDAT (pick any)
.data$r:00008C8C                 public ??_R0?AVexception@std@@@8
.data$r:00008C8C ; class std::exception `RTTI Type Descriptor'
.data$r:00008C8C ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00008C8C                                         ; DATA XREF: .xdata$x:00008CACo
.data$r:00008C8C                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00008C8C                                         ; const type_info::`vftable'
.data$r:00008C90                 db    0
.data$r:00008C91                 db    0
.data$r:00008C92                 db    0
.data$r:00008C93                 db    0
.data$r:00008C94                 db  2Eh ; .
.data$r:00008C95                 db  3Fh ; ?
.data$r:00008C96                 db  41h ; A
.data$r:00008C97                 db  56h ; V
.data$r:00008C98                 db  65h ; e
.data$r:00008C99                 db  78h ; x
.data$r:00008C9A                 db  63h ; c
.data$r:00008C9B                 db  65h ; e
.data$r:00008C9C                 db  70h ; p
.data$r:00008C9D                 db  74h ; t
.data$r:00008C9E                 db  69h ; i
.data$r:00008C9F                 db  6Fh ; o
.data$r:00008CA0                 db  6Eh ; n
.data$r:00008CA1                 db  40h ; @
.data$r:00008CA2                 db  73h ; s
.data$r:00008CA3                 db  74h ; t
.data$r:00008CA4                 db  64h ; d
.data$r:00008CA5                 db  40h ; @
.data$r:00008CA6                 db  40h ; @
.data$r:00008CA7                 db    0
.data$r:00008CA7 _data$r         ends
.data$r:00008CA7
.xdata$x:00008CA8 ; ===========================================================================
.xdata$x:00008CA8
.xdata$x:00008CA8 ; Segment type: Pure data
.xdata$x:00008CA8 ; Segment permissions: Read
.xdata$x:00008CA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008CA8                 assume cs:_xdata$x
.xdata$x:00008CA8                 ;org 8CA8h
.xdata$x:00008CA8 ; COMDAT (pick any)
.xdata$x:00008CA8                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00008CA8 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00008CA8                                         ; DATA XREF: .xdata$x:00008C4Co
.xdata$x:00008CA8                                         ; .xdata$x:00008F1Co ...
.xdata$x:00008CA9                 db    0
.xdata$x:00008CAA                 db    0
.xdata$x:00008CAB                 db    0
.xdata$x:00008CAC                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:00008CB0                 db    0
.xdata$x:00008CB1                 db    0
.xdata$x:00008CB2                 db    0
.xdata$x:00008CB3                 db    0
.xdata$x:00008CB4                 db 0FFh
.xdata$x:00008CB5                 db 0FFh
.xdata$x:00008CB6                 db 0FFh
.xdata$x:00008CB7                 db 0FFh
.xdata$x:00008CB8                 db    0
.xdata$x:00008CB9                 db    0
.xdata$x:00008CBA                 db    0
.xdata$x:00008CBB                 db    0
.xdata$x:00008CBC                 db  0Ch
.xdata$x:00008CBD                 db    0
.xdata$x:00008CBE                 db    0
.xdata$x:00008CBF                 db    0
.xdata$x:00008CC0                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00008CC0 _xdata$x        ends
.xdata$x:00008CC0
.rdata:00008CC4 ; ===========================================================================
.rdata:00008CC4
.rdata:00008CC4 ; Segment type: Pure data
.rdata:00008CC4 ; Segment permissions: Read
.rdata:00008CC4 _rdata          segment dword public 'DATA' use32
.rdata:00008CC4                 assume cs:_rdata
.rdata:00008CC4                 ;org 8CC4h
.rdata:00008CC4 ; COMDAT (pick any)
.rdata:00008CC4                 public ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
.rdata:00008CC4 ; char `string'[]
.rdata:00008CC4 ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ db 'bad locale name',0
.rdata:00008CC4                                         ; DATA XREF: std::_Locinfo::_Locinfo(char const *)+99o
.rdata:00008CC4 _rdata          ends
.rdata:00008CC4
.rdata:00008CD4 ; ===========================================================================
.rdata:00008CD4
.rdata:00008CD4 ; Segment type: Pure data
.rdata:00008CD4 ; Segment permissions: Read
.rdata:00008CD4 _rdata          segment dword public 'DATA' use32
.rdata:00008CD4                 assume cs:_rdata
.rdata:00008CD4                 ;org 8CD4h
.rdata:00008CD4 ; COMDAT (pick largest)
.rdata:00008CD4                 dd offset ??_R4_Facet_base@std@@6B@ ; const std::_Facet_base::`RTTI Complete Object Locator'
.rdata:00008CD8                 public ??_7_Facet_base@std@@6B@
.rdata:00008CD8 ; const std::_Facet_base::`vftable'
.rdata:00008CD8 ??_7_Facet_base@std@@6B@ dd offset ??_E_Facet_base@std@@UAEPAXI@Z
.rdata:00008CD8                                         ; DATA XREF: std::_Facet_base::_Facet_base(void)+Ao
.rdata:00008CD8                                         ; std::_Facet_base::~_Facet_base(void)+Ao
.rdata:00008CD8                                         ; std::_Facet_base::`vector deleting destructor'(uint)
.rdata:00008CDC                 dd offset __purecall
.rdata:00008CE0                 dd offset __purecall
.rdata:00008CE0 _rdata          ends
.rdata:00008CE0
.rdata:00008CE4 ; ===========================================================================
.rdata:00008CE4
.rdata:00008CE4 ; Segment type: Pure data
.rdata:00008CE4 ; Segment permissions: Read
.rdata:00008CE4 _rdata          segment dword public 'DATA' use32
.rdata:00008CE4                 assume cs:_rdata
.rdata:00008CE4                 ;org 8CE4h
.rdata:00008CE4 ; COMDAT (pick largest)
.rdata:00008CE4                 dd offset ??_R4facet@locale@std@@6B@ ; const std::locale::facet::`RTTI Complete Object Locator'
.rdata:00008CE8                 public ??_7facet@locale@std@@6B@
.rdata:00008CE8 ; const std::locale::facet::`vftable'
.rdata:00008CE8 ??_7facet@locale@std@@6B@ dd offset ??_Efacet@locale@std@@MAEPAXI@Z
.rdata:00008CE8                                         ; DATA XREF: std::locale::facet::facet(uint)+38o
.rdata:00008CE8                                         ; std::locale::facet::~facet(void)+29o
.rdata:00008CE8                                         ; std::locale::facet::`vector deleting destructor'(uint)
.rdata:00008CEC                 dd offset ?_Incref@facet@locale@std@@UAEXXZ ; std::locale::facet::_Incref(void)
.rdata:00008CF0                 dd offset ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref(void)
.rdata:00008CF0 _rdata          ends
.rdata:00008CF0
.rdata:00008CF4 ; ===========================================================================
.rdata:00008CF4
.rdata:00008CF4 ; Segment type: Pure data
.rdata:00008CF4 ; Segment permissions: Read
.rdata:00008CF4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008CF4 _rdata          segment para public 'DATA' use32
.rdata:00008CF4                 assume cs:_rdata
.rdata:00008CF4                 ;org 8CF4h
.rdata:00008CF4 ; COMDAT (pick any)
.rdata:00008CF4                 public ??_C@_0EH@EPAENFJM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
.rdata:00008CF4 ; char `string'[]
.rdata:00008CF4 ??_C@_0EH@EPAENFJM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@ db 'C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include\xl'
.rdata:00008CF4                                         ; DATA XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+4Fo
.rdata:00008CF4                                         ; __unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0+5o
.rdata:00008CF4                 db 'ocale',0
.rdata:00008D3B                 align 4
.rdata:00008D3B _rdata          ends
.rdata:00008D3B
.rdata:00008D3C ; ===========================================================================
.rdata:00008D3C
.rdata:00008D3C ; Segment type: Pure data
.rdata:00008D3C ; Segment permissions: Read
.rdata:00008D3C _rdata          segment byte public 'DATA' use32
.rdata:00008D3C                 assume cs:_rdata
.rdata:00008D3C                 ;org 8D3Ch
.rdata:00008D3C ; COMDAT (pick any)
.rdata:00008D3C                 public ??_C@_00CNPNBAHC@?$AA@
.rdata:00008D3C ; char `string'
.rdata:00008D3C ??_C@_00CNPNBAHC@?$AA@ db 0             ; DATA XREF: TiXmlDocumentA::ClearError(void)+18o
.rdata:00008D3C                                         ; std::locale::c_str(void)+11o
.rdata:00008D3D                 align 10h
.rdata:00008D3D _rdata          ends
.rdata:00008D3D
.rdata:00008D40 ; ===========================================================================
.rdata:00008D40
.rdata:00008D40 ; Segment type: Pure data
.rdata:00008D40 ; Segment permissions: Read
.rdata:00008D40 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008D40 _rdata          segment para public 'DATA' use32
.rdata:00008D40                 assume cs:_rdata
.rdata:00008D40                 ;org 8D40h
.rdata:00008D40 ; COMDAT (pick any)
.rdata:00008D40                 public ??_C@_1IO@OFOLDAJI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00008D40 ; wchar_t `string'
.rdata:00008D40 ??_C@_1IO@OFOLDAJI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00008D40                                         ; DATA XREF: std::ctype<char>::do_narrow(char const *,char const *,char,char *)+Co
.rdata:00008D40                                         ; std::ctype<char>::do_narrow(char const *,char const *,char,char *)+26o ...
.rdata:00008D40                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00008D40                 unicode 0, <clude\xlocale>,0
.rdata:00008DCE                 align 10h
.rdata:00008DCE _rdata          ends
.rdata:00008DCE
.rdata:00008DD0 ; ===========================================================================
.rdata:00008DD0
.rdata:00008DD0 ; Segment type: Pure data
.rdata:00008DD0 ; Segment permissions: Read
.rdata:00008DD0 _rdata          segment dword public 'DATA' use32
.rdata:00008DD0                 assume cs:_rdata
.rdata:00008DD0                 ;org 8DD0h
.rdata:00008DD0 ; COMDAT (pick largest)
.rdata:00008DD0                 dd offset ??_R4ctype_base@std@@6B@ ; const std::ctype_base::`RTTI Complete Object Locator'
.rdata:00008DD4                 public ??_7ctype_base@std@@6B@
.rdata:00008DD4 ; const std::ctype_base::`vftable'
.rdata:00008DD4 ??_7ctype_base@std@@6B@ dd offset ??_Ectype_base@std@@UAEPAXI@Z
.rdata:00008DD4                                         ; DATA XREF: std::ctype_base::ctype_base(uint)+3Co
.rdata:00008DD4                                         ; std::ctype_base::~ctype_base(void)+29o
.rdata:00008DD4                                         ; std::ctype_base::`vector deleting destructor'(uint)
.rdata:00008DD8                 dd offset ?_Incref@facet@locale@std@@UAEXXZ ; std::locale::facet::_Incref(void)
.rdata:00008DDC                 dd offset ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref(void)
.rdata:00008DDC _rdata          ends
.rdata:00008DDC
.rdata:00008DE0 ; ===========================================================================
.rdata:00008DE0
.rdata:00008DE0 ; Segment type: Pure data
.rdata:00008DE0 ; Segment permissions: Read
.rdata:00008DE0 _rdata          segment dword public 'DATA' use32
.rdata:00008DE0                 assume cs:_rdata
.rdata:00008DE0                 ;org 8DE0h
.rdata:00008DE0 ; COMDAT (pick largest)
.rdata:00008DE0                 dd offset ??_R4?$ctype@D@std@@6B@ ; const std::ctype<char>::`RTTI Complete Object Locator'
.rdata:00008DE4                 public ??_7?$ctype@D@std@@6B@
.rdata:00008DE4 ; const std::ctype<char>::`vftable'
.rdata:00008DE4 ??_7?$ctype@D@std@@6B@ dd offset ??_E?$ctype@D@std@@MAEPAXI@Z
.rdata:00008DE4                                         ; DATA XREF: std::ctype<char>::ctype<char>(std::_Locinfo const &,uint)+3Co
.rdata:00008DE4                                         ; std::ctype<char>::~ctype<char>(void)+29o
.rdata:00008DE4                                         ; std::ctype<char>::`vector deleting destructor'(uint)
.rdata:00008DE8                 dd offset ?_Incref@facet@locale@std@@UAEXXZ ; std::locale::facet::_Incref(void)
.rdata:00008DEC                 dd offset ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref(void)
.rdata:00008DF0                 dd offset ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ; std::ctype<char>::do_tolower(char *,char const *)
.rdata:00008DF4                 dd offset ?do_tolower@?$ctype@D@std@@MBEDD@Z ; std::ctype<char>::do_tolower(char)
.rdata:00008DF8                 dd offset ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ; std::ctype<char>::do_toupper(char *,char const *)
.rdata:00008DFC                 dd offset ?do_toupper@?$ctype@D@std@@MBEDD@Z ; std::ctype<char>::do_toupper(char)
.rdata:00008E00                 dd offset ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ; std::ctype<char>::do_widen(char const *,char const *,char *)
.rdata:00008E04                 dd offset ?do_widen@?$ctype@D@std@@MBEDD@Z ; std::ctype<char>::do_widen(char)
.rdata:00008E08                 dd offset ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ; std::ctype<char>::do_narrow(char const *,char const *,char,char *)
.rdata:00008E0C                 dd offset ?do_narrow@?$ctype@D@std@@MBEDDD@Z ; std::ctype<char>::do_narrow(char,char)
.rdata:00008E0C _rdata          ends
.rdata:00008E0C
.rdata:00008E10 ; ===========================================================================
.rdata:00008E10
.rdata:00008E10 ; Segment type: Pure data
.rdata:00008E10 ; Segment permissions: Read
.rdata:00008E10 _rdata          segment dword public 'DATA' use32
.rdata:00008E10                 assume cs:_rdata
.rdata:00008E10                 ;org 8E10h
.rdata:00008E10 ; COMDAT (pick largest)
.rdata:00008E10                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00008E14                 public ??_7error_category@std@@6B@
.rdata:00008E14 ; const std::error_category::`vftable'
.rdata:00008E14 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00008E14                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00008E14                                         ; std::error_category::~error_category(void)+Ao
.rdata:00008E14                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00008E18                 dd offset __purecall
.rdata:00008E1C                 dd offset __purecall
.rdata:00008E20                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00008E24                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00008E28                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00008E28 _rdata          ends
.rdata:00008E28
.rdata:00008E2C ; ===========================================================================
.rdata:00008E2C
.rdata:00008E2C ; Segment type: Pure data
.rdata:00008E2C ; Segment permissions: Read
.rdata:00008E2C _rdata          segment dword public 'DATA' use32
.rdata:00008E2C                 assume cs:_rdata
.rdata:00008E2C                 ;org 8E2Ch
.rdata:00008E2C ; COMDAT (pick largest)
.rdata:00008E2C                 dd offset ??_R4_System_error@std@@6B@ ; const std::_System_error::`RTTI Complete Object Locator'
.rdata:00008E30                 public ??_7_System_error@std@@6B@
.rdata:00008E30 ; const std::_System_error::`vftable'
.rdata:00008E30 ??_7_System_error@std@@6B@ dd offset ??_E_System_error@std@@UAEPAXI@Z
.rdata:00008E30                                         ; DATA XREF: std::_System_error::_System_error(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+92o
.rdata:00008E30                                         ; std::_System_error::_System_error(std::_System_error const &)+3Co
.rdata:00008E30                                         ; std::_System_error::`vector deleting destructor'(uint)
.rdata:00008E34                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00008E34 _rdata          ends
.rdata:00008E34
.rdata:00008E38 ; ===========================================================================
.rdata:00008E38
.rdata:00008E38 ; Segment type: Pure data
.rdata:00008E38 ; Segment permissions: Read
.rdata:00008E38 _rdata          segment dword public 'DATA' use32
.rdata:00008E38                 assume cs:_rdata
.rdata:00008E38                 ;org 8E38h
.rdata:00008E38 ; COMDAT (pick any)
.rdata:00008E38                 public ??_C@_02LMMGGCAJ@?3?5?$AA@
.rdata:00008E38 ; char `string'[3]
.rdata:00008E38 ??_C@_02LMMGGCAJ@?3?5?$AA@ db ': ',0    ; DATA XREF: std::_System_error::_Makestr(std::error_code,std::basic_string<char,std::char_traits<char>,std::allocator<char>>)+45o
.rdata:00008E3B                 align 4
.rdata:00008E3B _rdata          ends
.rdata:00008E3B
.rdata:00008E3C ; ===========================================================================
.rdata:00008E3C
.rdata:00008E3C ; Segment type: Pure data
.rdata:00008E3C ; Segment permissions: Read
.rdata:00008E3C _rdata          segment dword public 'DATA' use32
.rdata:00008E3C                 assume cs:_rdata
.rdata:00008E3C                 ;org 8E3Ch
.rdata:00008E3C ; COMDAT (pick largest)
.rdata:00008E3C                 dd offset ??_R4system_error@std@@6B@ ; const std::system_error::`RTTI Complete Object Locator'
.rdata:00008E40                 public ??_7system_error@std@@6B@
.rdata:00008E40 ; const std::system_error::`vftable'
.rdata:00008E40 ??_7system_error@std@@6B@ dd offset ??_Esystem_error@std@@UAEPAXI@Z
.rdata:00008E40                                         ; DATA XREF: std::system_error::system_error(std::system_error const &)+3Co
.rdata:00008E40                                         ; std::system_error::system_error(std::error_code,char const *)+61o
.rdata:00008E40                                         ; std::system_error::`vector deleting destructor'(uint)
.rdata:00008E44                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00008E44 _rdata          ends
.rdata:00008E44
.rdata:00008E48 ; ===========================================================================
.rdata:00008E48
.rdata:00008E48 ; Segment type: Pure data
.rdata:00008E48 ; Segment permissions: Read
.rdata:00008E48 _rdata          segment dword public 'DATA' use32
.rdata:00008E48                 assume cs:_rdata
.rdata:00008E48                 ;org 8E48h
.rdata:00008E48 ; COMDAT (pick largest)
.rdata:00008E48                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00008E4C                 public ??_7_Generic_error_category@std@@6B@
.rdata:00008E4C ; const std::_Generic_error_category::`vftable'
.rdata:00008E4C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00008E4C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00008E4C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00008E50                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00008E54                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00008E58                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00008E5C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00008E60                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00008E60 _rdata          ends
.rdata:00008E60
.rdata:00008E64 ; ===========================================================================
.rdata:00008E64
.rdata:00008E64 ; Segment type: Pure data
.rdata:00008E64 ; Segment permissions: Read
.rdata:00008E64 _rdata          segment dword public 'DATA' use32
.rdata:00008E64                 assume cs:_rdata
.rdata:00008E64                 ;org 8E64h
.rdata:00008E64 ; COMDAT (pick any)
.rdata:00008E64                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00008E64 ; `string'
.rdata:00008E64 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00008E64                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00008E64 _rdata          ends
.rdata:00008E64
.rdata:00008E6C ; ===========================================================================
.rdata:00008E6C
.rdata:00008E6C ; Segment type: Pure data
.rdata:00008E6C ; Segment permissions: Read
.rdata:00008E6C _rdata          segment dword public 'DATA' use32
.rdata:00008E6C                 assume cs:_rdata
.rdata:00008E6C                 ;org 8E6Ch
.rdata:00008E6C ; COMDAT (pick any)
.rdata:00008E6C                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00008E6C ; `string'
.rdata:00008E6C ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00008E6C                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_7644o
.rdata:00008E6C                                         ; std::_System_error_category::message(int):loc_77C0o
.rdata:00008E7A                 align 4
.rdata:00008E7A _rdata          ends
.rdata:00008E7A
.rdata:00008E7C ; ===========================================================================
.rdata:00008E7C
.rdata:00008E7C ; Segment type: Pure data
.rdata:00008E7C ; Segment permissions: Read
.rdata:00008E7C _rdata          segment dword public 'DATA' use32
.rdata:00008E7C                 assume cs:_rdata
.rdata:00008E7C                 ;org 8E7Ch
.rdata:00008E7C ; COMDAT (pick largest)
.rdata:00008E7C                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00008E80                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00008E80 ; const std::_Iostream_error_category::`vftable'
.rdata:00008E80 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00008E80                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00008E80                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00008E84                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00008E88                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00008E8C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00008E90                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00008E94                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00008E94 _rdata          ends
.rdata:00008E94
.rdata:00008E98 ; ===========================================================================
.rdata:00008E98
.rdata:00008E98 ; Segment type: Pure data
.rdata:00008E98 ; Segment permissions: Read
.rdata:00008E98 _rdata          segment dword public 'DATA' use32
.rdata:00008E98                 assume cs:_rdata
.rdata:00008E98                 ;org 8E98h
.rdata:00008E98 ; COMDAT (pick any)
.rdata:00008E98                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00008E98 ; `string'
.rdata:00008E98 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00008E98                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00008EA1                 align 4
.rdata:00008EA1 _rdata          ends
.rdata:00008EA1
.rdata:00008EA4 ; ===========================================================================
.rdata:00008EA4
.rdata:00008EA4 ; Segment type: Pure data
.rdata:00008EA4 ; Segment permissions: Read
.rdata:00008EA4 _rdata          segment dword public 'DATA' use32
.rdata:00008EA4                 assume cs:_rdata
.rdata:00008EA4                 ;org 8EA4h
.rdata:00008EA4 ; COMDAT (pick any)
.rdata:00008EA4                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00008EA4 ; char `string'[]
.rdata:00008EA4 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00008EA4                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00008EBA                 align 4
.rdata:00008EBA _rdata          ends
.rdata:00008EBA
.rdata:00008EBC ; ===========================================================================
.rdata:00008EBC
.rdata:00008EBC ; Segment type: Pure data
.rdata:00008EBC ; Segment permissions: Read
.rdata:00008EBC _rdata          segment dword public 'DATA' use32
.rdata:00008EBC                 assume cs:_rdata
.rdata:00008EBC                 ;org 8EBCh
.rdata:00008EBC ; COMDAT (pick largest)
.rdata:00008EBC                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00008EC0                 public ??_7_System_error_category@std@@6B@
.rdata:00008EC0 ; const std::_System_error_category::`vftable'
.rdata:00008EC0 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00008EC0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00008EC0                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00008EC4                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00008EC8                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00008ECC                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00008ED0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00008ED4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00008ED4 _rdata          ends
.rdata:00008ED4
.rdata:00008ED8 ; ===========================================================================
.rdata:00008ED8
.rdata:00008ED8 ; Segment type: Pure data
.rdata:00008ED8 ; Segment permissions: Read
.rdata:00008ED8 _rdata          segment dword public 'DATA' use32
.rdata:00008ED8                 assume cs:_rdata
.rdata:00008ED8                 ;org 8ED8h
.rdata:00008ED8 ; COMDAT (pick any)
.rdata:00008ED8                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00008ED8 ; `string'
.rdata:00008ED8 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00008ED8                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00008EDF                 align 10h
.rdata:00008EDF _rdata          ends
.rdata:00008EDF
.bss:00008EE0 ; ===========================================================================
.bss:00008EE0
.bss:00008EE0 ; Segment type: Uninitialized
.bss:00008EE0 ; Segment permissions: Read/Write
.bss:00008EE0 _bss            segment dword public 'BSS' use32
.bss:00008EE0                 assume cs:_bss
.bss:00008EE0                 ;org 8EE0h
.bss:00008EE0 ; COMDAT (pick any)
.bss:00008EE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00008EE0                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00008EE0 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00008EE0 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00008EE0                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00008EE0                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00008EE1                 db    ? ;
.bss:00008EE2                 db    ? ;
.bss:00008EE3                 db    ? ;
.bss:00008EE3 _bss            ends
.bss:00008EE3
.bss:00008EE4 ; ===========================================================================
.bss:00008EE4
.bss:00008EE4 ; Segment type: Uninitialized
.bss:00008EE4 ; Segment permissions: Read/Write
.bss:00008EE4 _bss            segment dword public 'BSS' use32
.bss:00008EE4                 assume cs:_bss
.bss:00008EE4                 ;org 8EE4h
.bss:00008EE4 ; COMDAT (pick any)
.bss:00008EE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00008EE4                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00008EE4 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00008EE4 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00008EE4                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00008EE4                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o ...
.bss:00008EE5                 db    ? ;
.bss:00008EE6                 db    ? ;
.bss:00008EE7                 db    ? ;
.bss:00008EE7 _bss            ends
.bss:00008EE7
.bss:00008EE8 ; ===========================================================================
.bss:00008EE8
.bss:00008EE8 ; Segment type: Uninitialized
.bss:00008EE8 ; Segment permissions: Read/Write
.bss:00008EE8 _bss            segment dword public 'BSS' use32
.bss:00008EE8                 assume cs:_bss
.bss:00008EE8                 ;org 8EE8h
.bss:00008EE8 ; COMDAT (pick any)
.bss:00008EE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00008EE8                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00008EE8 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00008EE8 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00008EE8                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00008EE8                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00008EE9                 db    ? ;
.bss:00008EEA                 db    ? ;
.bss:00008EEB                 db    ? ;
.bss:00008EEB _bss            ends
.bss:00008EEB
.rdata:00008EEC ; ===========================================================================
.rdata:00008EEC
.rdata:00008EEC ; Segment type: Pure data
.rdata:00008EEC ; Segment permissions: Read
.rdata:00008EEC _rdata          segment dword public 'DATA' use32
.rdata:00008EEC                 assume cs:_rdata
.rdata:00008EEC                 ;org 8EECh
.rdata:00008EEC ; COMDAT (pick largest)
.rdata:00008EEC                 dd offset ??_R4failure@ios_base@std@@6B@ ; const std::ios_base::failure::`RTTI Complete Object Locator'
.rdata:00008EF0                 public ??_7failure@ios_base@std@@6B@
.rdata:00008EF0 ; const std::ios_base::failure::`vftable'
.rdata:00008EF0 ??_7failure@ios_base@std@@6B@ dd offset ??_Efailure@ios_base@std@@UAEPAXI@Z
.rdata:00008EF0                                         ; DATA XREF: std::ios_base::failure::failure(std::ios_base::failure const &)+3Co
.rdata:00008EF0                                         ; std::ios_base::failure::failure(char const *,std::error_code const &)+46o
.rdata:00008EF0                                         ; std::ios_base::failure::`vector deleting destructor'(uint)
.rdata:00008EF4                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00008EF4 _rdata          ends
.rdata:00008EF4
.xdata$x:00008EF8 ; ===========================================================================
.xdata$x:00008EF8
.xdata$x:00008EF8 ; Segment type: Pure data
.xdata$x:00008EF8 ; Segment permissions: Read
.xdata$x:00008EF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008EF8                 assume cs:_xdata$x
.xdata$x:00008EF8                 ;org 8EF8h
.xdata$x:00008EF8 ; COMDAT (pick any)
.xdata$x:00008EF8                 public __TI5?AVfailure@ios_base@std@@
.xdata$x:00008EF8 __TI5?AVfailure@ios_base@std@@ db    0  ; DATA XREF: std::ios_base::clear(int,bool)+6Bo
.xdata$x:00008EF8                                         ; std::ios_base::clear(int,bool)+A8o ...
.xdata$x:00008EF9                 db    0
.xdata$x:00008EFA                 db    0
.xdata$x:00008EFB                 db    0
.xdata$x:00008EFC                 dd offset ??1failure@ios_base@std@@UAE@XZ ; std::ios_base::failure::~failure(void)
.xdata$x:00008F00                 db    0
.xdata$x:00008F01                 db    0
.xdata$x:00008F02                 db    0
.xdata$x:00008F03                 db    0
.xdata$x:00008F04                 dd offset __CTA5?AVfailure@ios_base@std@@
.xdata$x:00008F04 _xdata$x        ends
.xdata$x:00008F04
.xdata$x:00008F08 ; ===========================================================================
.xdata$x:00008F08
.xdata$x:00008F08 ; Segment type: Pure data
.xdata$x:00008F08 ; Segment permissions: Read
.xdata$x:00008F08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F08                 assume cs:_xdata$x
.xdata$x:00008F08                 ;org 8F08h
.xdata$x:00008F08 ; COMDAT (pick any)
.xdata$x:00008F08                 public __CTA5?AVfailure@ios_base@std@@
.xdata$x:00008F08 __CTA5?AVfailure@ios_base@std@@ db    5 ; DATA XREF: .xdata$x:00008F04o
.xdata$x:00008F09                 db    0
.xdata$x:00008F0A                 db    0
.xdata$x:00008F0B                 db    0
.xdata$x:00008F0C                 dd offset __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
.xdata$x:00008F10                 dd offset __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
.xdata$x:00008F14                 dd offset __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
.xdata$x:00008F18                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00008F1C                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00008F1C _xdata$x        ends
.xdata$x:00008F1C
.data$r:00008F20 ; ===========================================================================
.data$r:00008F20
.data$r:00008F20 ; Segment type: Pure data
.data$r:00008F20 ; Segment permissions: Read/Write
.data$r:00008F20 _data$r         segment dword public 'DATA' use32
.data$r:00008F20                 assume cs:_data$r
.data$r:00008F20                 ;org 8F20h
.data$r:00008F20 ; COMDAT (pick any)
.data$r:00008F20                 public ??_R0?AVfailure@ios_base@std@@@8
.data$r:00008F20 ; class std::ios_base::failure `RTTI Type Descriptor'
.data$r:00008F20 ??_R0?AVfailure@ios_base@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00008F20                                         ; DATA XREF: .xdata$x:00008F48o
.data$r:00008F20                                         ; .rdata$r:0000985Co ...
.data$r:00008F20                                         ; const type_info::`vftable'
.data$r:00008F24                 align 8
.data$r:00008F28 a_?avfailure@io db '.?AVfailure@ios_base@std@@',0
.data$r:00008F43                 align 4
.data$r:00008F43 _data$r         ends
.data$r:00008F43
.xdata$x:00008F44 ; ===========================================================================
.xdata$x:00008F44
.xdata$x:00008F44 ; Segment type: Pure data
.xdata$x:00008F44 ; Segment permissions: Read
.xdata$x:00008F44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F44                 assume cs:_xdata$x
.xdata$x:00008F44                 ;org 8F44h
.xdata$x:00008F44 ; COMDAT (pick any)
.xdata$x:00008F44                 public __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
.xdata$x:00008F44 __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 db    0
.xdata$x:00008F44                                         ; DATA XREF: .xdata$x:00008F0Co
.xdata$x:00008F45                 db    0
.xdata$x:00008F46                 db    0
.xdata$x:00008F47                 db    0
.xdata$x:00008F48                 dd offset ??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure `RTTI Type Descriptor'
.xdata$x:00008F4C                 align 10h
.xdata$x:00008F50                 db 0FFh
.xdata$x:00008F51                 db 0FFh
.xdata$x:00008F52                 db 0FFh
.xdata$x:00008F53                 db 0FFh
.xdata$x:00008F54                 db    0
.xdata$x:00008F55                 db    0
.xdata$x:00008F56                 db    0
.xdata$x:00008F57                 db    0
.xdata$x:00008F58                 db  14h
.xdata$x:00008F59                 db    0
.xdata$x:00008F5A                 db    0
.xdata$x:00008F5B                 db    0
.xdata$x:00008F5C                 dd offset ??0failure@ios_base@std@@QAE@ABV012@@Z ; std::ios_base::failure::failure(std::ios_base::failure const &)
.xdata$x:00008F5C _xdata$x        ends
.xdata$x:00008F5C
.data$r:00008F60 ; ===========================================================================
.data$r:00008F60
.data$r:00008F60 ; Segment type: Pure data
.data$r:00008F60 ; Segment permissions: Read/Write
.data$r:00008F60 _data$r         segment dword public 'DATA' use32
.data$r:00008F60                 assume cs:_data$r
.data$r:00008F60                 ;org 8F60h
.data$r:00008F60 ; COMDAT (pick any)
.data$r:00008F60                 public ??_R0?AVsystem_error@std@@@8
.data$r:00008F60 ; class std::system_error `RTTI Type Descriptor'
.data$r:00008F60 ??_R0?AVsystem_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00008F60                                         ; DATA XREF: .xdata$x:00008F84o
.data$r:00008F60                                         ; .rdata$r:00009698o ...
.data$r:00008F60                                         ; const type_info::`vftable'
.data$r:00008F64                 align 8
.data$r:00008F68 a_?avsystem_err db '.?AVsystem_error@std@@',0
.data$r:00008F7F                 align 10h
.data$r:00008F7F _data$r         ends
.data$r:00008F7F
.xdata$x:00008F80 ; ===========================================================================
.xdata$x:00008F80
.xdata$x:00008F80 ; Segment type: Pure data
.xdata$x:00008F80 ; Segment permissions: Read
.xdata$x:00008F80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F80                 assume cs:_xdata$x
.xdata$x:00008F80                 ;org 8F80h
.xdata$x:00008F80 ; COMDAT (pick any)
.xdata$x:00008F80                 public __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
.xdata$x:00008F80 __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 db    0
.xdata$x:00008F80                                         ; DATA XREF: .xdata$x:00008F10o
.xdata$x:00008F81                 db    0
.xdata$x:00008F82                 db    0
.xdata$x:00008F83                 db    0
.xdata$x:00008F84                 dd offset ??_R0?AVsystem_error@std@@@8 ; std::system_error `RTTI Type Descriptor'
.xdata$x:00008F88                 db    0
.xdata$x:00008F89                 db    0
.xdata$x:00008F8A                 db    0
.xdata$x:00008F8B                 db    0
.xdata$x:00008F8C                 db 0FFh
.xdata$x:00008F8D                 db 0FFh
.xdata$x:00008F8E                 db 0FFh
.xdata$x:00008F8F                 db 0FFh
.xdata$x:00008F90                 db    0
.xdata$x:00008F91                 db    0
.xdata$x:00008F92                 db    0
.xdata$x:00008F93                 db    0
.xdata$x:00008F94                 db  14h
.xdata$x:00008F95                 db    0
.xdata$x:00008F96                 db    0
.xdata$x:00008F97                 db    0
.xdata$x:00008F98                 dd offset ??0system_error@std@@QAE@ABV01@@Z ; std::system_error::system_error(std::system_error const &)
.xdata$x:00008F98 _xdata$x        ends
.xdata$x:00008F98
.data$r:00008F9C ; ===========================================================================
.data$r:00008F9C
.data$r:00008F9C ; Segment type: Pure data
.data$r:00008F9C ; Segment permissions: Read/Write
.data$r:00008F9C _data$r         segment dword public 'DATA' use32
.data$r:00008F9C                 assume cs:_data$r
.data$r:00008F9C                 ;org 8F9Ch
.data$r:00008F9C ; COMDAT (pick any)
.data$r:00008F9C                 public ??_R0?AV_System_error@std@@@8
.data$r:00008F9C ; class std::_System_error `RTTI Type Descriptor'
.data$r:00008F9C ??_R0?AV_System_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00008F9C                                         ; DATA XREF: .xdata$x:00008FC0o
.data$r:00008F9C                                         ; .rdata$r:00009648o ...
.data$r:00008F9C                                         ; const type_info::`vftable'
.data$r:00008FA0                 db    0
.data$r:00008FA1                 db    0
.data$r:00008FA2                 db    0
.data$r:00008FA3                 db    0
.data$r:00008FA4                 db  2Eh ; .
.data$r:00008FA5                 db  3Fh ; ?
.data$r:00008FA6                 db  41h ; A
.data$r:00008FA7                 db  56h ; V
.data$r:00008FA8                 db  5Fh ; _
.data$r:00008FA9                 db  53h ; S
.data$r:00008FAA                 db  79h ; y
.data$r:00008FAB                 db  73h ; s
.data$r:00008FAC                 db  74h ; t
.data$r:00008FAD                 db  65h ; e
.data$r:00008FAE                 db  6Dh ; m
.data$r:00008FAF                 db  5Fh ; _
.data$r:00008FB0                 db  65h ; e
.data$r:00008FB1                 db  72h ; r
.data$r:00008FB2                 db  72h ; r
.data$r:00008FB3                 db  6Fh ; o
.data$r:00008FB4                 db  72h ; r
.data$r:00008FB5                 db  40h ; @
.data$r:00008FB6                 db  73h ; s
.data$r:00008FB7                 db  74h ; t
.data$r:00008FB8                 db  64h ; d
.data$r:00008FB9                 db  40h ; @
.data$r:00008FBA                 db  40h ; @
.data$r:00008FBB                 db    0
.data$r:00008FBB _data$r         ends
.data$r:00008FBB
.xdata$x:00008FBC ; ===========================================================================
.xdata$x:00008FBC
.xdata$x:00008FBC ; Segment type: Pure data
.xdata$x:00008FBC ; Segment permissions: Read
.xdata$x:00008FBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008FBC                 assume cs:_xdata$x
.xdata$x:00008FBC                 ;org 8FBCh
.xdata$x:00008FBC ; COMDAT (pick any)
.xdata$x:00008FBC                 public __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
.xdata$x:00008FBC __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 db    0
.xdata$x:00008FBC                                         ; DATA XREF: .xdata$x:00008F14o
.xdata$x:00008FBD                 db    0
.xdata$x:00008FBE                 db    0
.xdata$x:00008FBF                 db    0
.xdata$x:00008FC0                 dd offset ??_R0?AV_System_error@std@@@8 ; std::_System_error `RTTI Type Descriptor'
.xdata$x:00008FC4                 align 8
.xdata$x:00008FC8                 db 0FFh
.xdata$x:00008FC9                 db 0FFh
.xdata$x:00008FCA                 db 0FFh
.xdata$x:00008FCB                 db 0FFh
.xdata$x:00008FCC                 db    0
.xdata$x:00008FCD                 db    0
.xdata$x:00008FCE                 db    0
.xdata$x:00008FCF                 db    0
.xdata$x:00008FD0                 db  14h
.xdata$x:00008FD1                 db    0
.xdata$x:00008FD2                 db    0
.xdata$x:00008FD3                 db    0
.xdata$x:00008FD4                 dd offset ??0_System_error@std@@QAE@ABV01@@Z ; std::_System_error::_System_error(std::_System_error const &)
.xdata$x:00008FD4 _xdata$x        ends
.xdata$x:00008FD4
.rdata:00008FD8 ; ===========================================================================
.rdata:00008FD8
.rdata:00008FD8 ; Segment type: Pure data
.rdata:00008FD8 ; Segment permissions: Read
.rdata:00008FD8 _rdata          segment dword public 'DATA' use32
.rdata:00008FD8                 assume cs:_rdata
.rdata:00008FD8                 ;org 8FD8h
.rdata:00008FD8 ; COMDAT (pick any)
.rdata:00008FD8                 public ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
.rdata:00008FD8 ; char `string'[]
.rdata:00008FD8 ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ db 'ios_base::badbit set',0
.rdata:00008FD8                                         ; DATA XREF: std::ios_base::clear(int,bool)+5Eo
.rdata:00008FED                 align 10h
.rdata:00008FED _rdata          ends
.rdata:00008FED
.rdata:00008FF0 ; ===========================================================================
.rdata:00008FF0
.rdata:00008FF0 ; Segment type: Pure data
.rdata:00008FF0 ; Segment permissions: Read
.rdata:00008FF0 _rdata          segment dword public 'DATA' use32
.rdata:00008FF0                 assume cs:_rdata
.rdata:00008FF0                 ;org 8FF0h
.rdata:00008FF0 ; COMDAT (pick any)
.rdata:00008FF0                 public ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
.rdata:00008FF0 ; char `string'[]
.rdata:00008FF0 ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ db 'ios_base::failbit set',0
.rdata:00008FF0                                         ; DATA XREF: std::ios_base::clear(int,bool)+9Bo
.rdata:00009006                 align 4
.rdata:00009006 _rdata          ends
.rdata:00009006
.rdata:00009008 ; ===========================================================================
.rdata:00009008
.rdata:00009008 ; Segment type: Pure data
.rdata:00009008 ; Segment permissions: Read
.rdata:00009008 _rdata          segment dword public 'DATA' use32
.rdata:00009008                 assume cs:_rdata
.rdata:00009008                 ;org 9008h
.rdata:00009008 ; COMDAT (pick any)
.rdata:00009008                 public ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
.rdata:00009008 ; char `string'[]
.rdata:00009008 ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ db 'ios_base::eofbit set',0
.rdata:00009008                                         ; DATA XREF: std::ios_base::clear(int,bool)+C7o
.rdata:0000901D                 align 10h
.rdata:0000901D _rdata          ends
.rdata:0000901D
.bss:00009020 ; ===========================================================================
.bss:00009020
.bss:00009020 ; Segment type: Uninitialized
.bss:00009020 ; Segment permissions: Read/Write
.bss:00009020 _bss            segment dword public 'BSS' use32
.bss:00009020                 assume cs:_bss
.bss:00009020                 ;org 9020h
.bss:00009020 ; COMDAT (pick any)
.bss:00009020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009020                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00009020 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00009020 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00009020                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00009021                 db    ? ;
.bss:00009022                 db    ? ;
.bss:00009023                 db    ? ;
.bss:00009023 _bss            ends
.bss:00009023
.bss:00009024 ; ===========================================================================
.bss:00009024
.bss:00009024 ; Segment type: Uninitialized
.bss:00009024 ; Segment permissions: Read/Write
.bss:00009024 _bss            segment dword public 'BSS' use32
.bss:00009024                 assume cs:_bss
.bss:00009024                 ;org 9024h
.bss:00009024 ; COMDAT (pick any)
.bss:00009024                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009024                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00009024 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00009024 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00009024                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00009025                 db    ? ;
.bss:00009026                 db    ? ;
.bss:00009027                 db    ? ;
.bss:00009027 _bss            ends
.bss:00009027
.rdata:00009028 ; ===========================================================================
.rdata:00009028
.rdata:00009028 ; Segment type: Pure data
.rdata:00009028 ; Segment permissions: Read
.rdata:00009028 _rdata          segment dword public 'DATA' use32
.rdata:00009028                 assume cs:_rdata
.rdata:00009028                 ;org 9028h
.rdata:00009028 ; COMDAT (pick largest)
.rdata:00009028                 dd offset ??_R4TiXmlBaseA@@6B@ ; const TiXmlBaseA::`RTTI Complete Object Locator'
.rdata:0000902C                 public ??_7TiXmlBaseA@@6B@
.rdata:0000902C ; const TiXmlBaseA::`vftable'
.rdata:0000902C ??_7TiXmlBaseA@@6B@ dd offset ??_ETiXmlBaseA@@UAEPAXI@Z
.rdata:0000902C                                         ; DATA XREF: TiXmlBaseA::TiXmlBaseA(void)+Ao
.rdata:0000902C                                         ; TiXmlBaseA::~TiXmlBaseA(void)+Ao
.rdata:0000902C                                         ; TiXmlBaseA::`vector deleting destructor'(uint)
.rdata:00009030                 dd offset __purecall
.rdata:00009034                 dd offset __purecall
.rdata:00009038                 dd offset __purecall
.rdata:00009038 _rdata          ends
.rdata:00009038
.rdata:0000903C ; ===========================================================================
.rdata:0000903C
.rdata:0000903C ; Segment type: Pure data
.rdata:0000903C ; Segment permissions: Read
.rdata:0000903C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000903C _rdata          segment para public 'DATA' use32
.rdata:0000903C                 assume cs:_rdata
.rdata:0000903C                 ;org 903Ch
.rdata:0000903C ; COMDAT (pick any)
.rdata:0000903C                 public ??_C@_1KG@IIGNAHLC@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@
.rdata:0000903C ; wchar_t `string'
.rdata:0000903C ??_C@_1KG@IIGNAHLC@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@:
.rdata:0000903C                                         ; DATA XREF: TiXmlBaseA::GetChar(char const *,char *)+Eo
.rdata:0000903C                 unicode 0, <c:\workspace\notepad-plus-plus-6.7.9.2\powereditor\src\ti>
.rdata:0000903C                 unicode 0, <nyxml\tinyxmla\tinyxmlA.h>,0
.rdata:000090E2                 align 4
.rdata:000090E2 _rdata          ends
.rdata:000090E2
.rdata:000090E4 ; ===========================================================================
.rdata:000090E4
.rdata:000090E4 ; Segment type: Pure data
.rdata:000090E4 ; Segment permissions: Read
.rdata:000090E4 _rdata          segment dword public 'DATA' use32
.rdata:000090E4                 assume cs:_rdata
.rdata:000090E4                 ;org 90E4h
.rdata:000090E4 ; COMDAT (pick any)
.rdata:000090E4                 public ??_C@_13LFIEIAHP@?$AAp?$AA?$AA@
.rdata:000090E4 ; wchar_t `string'
.rdata:000090E4 ??_C@_13LFIEIAHP@?$AAp?$AA?$AA@ dd offset $SG94463+48h
.rdata:000090E4                                         ; DATA XREF: TiXmlBaseA::GetChar(char const *,char *)+13o
.rdata:000090E4 _rdata          ends                    ; "rA.cpp"
.rdata:000090E4
.rdata:000090E8 ; ===========================================================================
.rdata:000090E8
.rdata:000090E8 ; Segment type: Pure data
.rdata:000090E8 ; Segment permissions: Read
.rdata:000090E8 _rdata          segment dword public 'DATA' use32
.rdata:000090E8                 assume cs:_rdata
.rdata:000090E8                 ;org 90E8h
.rdata:000090E8 ; COMDAT (pick largest)
.rdata:000090E8                 dd offset ??_R4TiXmlAttributeA@@6B@ ; const TiXmlAttributeA::`RTTI Complete Object Locator'
.rdata:000090EC                 public ??_7TiXmlAttributeA@@6B@
.rdata:000090EC ; const TiXmlAttributeA::`vftable'
.rdata:000090EC ??_7TiXmlAttributeA@@6B@ dd offset ??_ETiXmlAttributeA@@UAEPAXI@Z
.rdata:000090EC                                         ; DATA XREF: TiXmlAttributeA::TiXmlAttributeA(void)+38o
.rdata:000090EC                                         ; TiXmlAttributeA::`vector deleting destructor'(uint)
.rdata:000090F0                 dd offset ?Print@TiXmlAttributeA@@UBEXPAU_iobuf@@H@Z ; TiXmlAttributeA::Print(_iobuf *,int)
.rdata:000090F4                 dd offset ?StreamOut@TiXmlAttributeA@@UBEXPAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z ; TiXmlAttributeA::StreamOut(std::basic_ostream<char,std::char_traits<char>> *)
.rdata:000090F8                 dd offset ?Parse@TiXmlAttributeA@@UAEPBDPBDPAVTiXmlParsingDataA@@@Z ; TiXmlAttributeA::Parse(char const *,TiXmlParsingDataA *)
.rdata:000090F8 _rdata          ends
.rdata:000090F8
.rdata:000090FC ; ===========================================================================
.rdata:000090FC
.rdata:000090FC ; Segment type: Pure data
.rdata:000090FC ; Segment permissions: Read
.rdata:000090FC _rdata          segment dword public 'DATA' use32
.rdata:000090FC                 assume cs:_rdata
.rdata:000090FC                 ;org 90FCh
.rdata:000090FC ; COMDAT (pick largest)
.rdata:000090FC                 dd offset ??_R4TiXmlCommentA@@6B@ ; const TiXmlCommentA::`RTTI Complete Object Locator'
.rdata:00009100                 public ??_7TiXmlCommentA@@6B@
.rdata:00009100 ; const TiXmlCommentA::`vftable'
.rdata:00009100 ??_7TiXmlCommentA@@6B@ dd offset ??_ETiXmlCommentA@@UAEPAXI@Z
.rdata:00009100                                         ; DATA XREF: TiXmlCommentA::TiXmlCommentA(void)+3Ao
.rdata:00009100                                         ; TiXmlCommentA::~TiXmlCommentA(void)+29o
.rdata:00009100                                         ; TiXmlCommentA::`vector deleting destructor'(uint)
.rdata:00009104                 dd offset ?Print@TiXmlCommentA@@UBEXPAU_iobuf@@H@Z ; TiXmlCommentA::Print(_iobuf *,int)
.rdata:00009108                 dd offset ?StreamOut@TiXmlCommentA@@MBEXPAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z ; TiXmlCommentA::StreamOut(std::basic_ostream<char,std::char_traits<char>> *)
.rdata:0000910C                 dd offset ?Parse@TiXmlCommentA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z ; TiXmlCommentA::Parse(char const *,TiXmlParsingDataA *)
.rdata:00009110                 dd offset ?Type@TiXmlNodeA@@UBEHXZ ; TiXmlNodeA::Type(void)
.rdata:00009114                 dd offset ?Clone@TiXmlCommentA@@UBEPAVTiXmlNodeA@@XZ ; TiXmlCommentA::Clone(void)
.rdata:00009118                 dd offset ?StreamIn@TiXmlCommentA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; TiXmlCommentA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)
.rdata:00009118 _rdata          ends
.rdata:00009118
.rdata:0000911C ; ===========================================================================
.rdata:0000911C
.rdata:0000911C ; Segment type: Pure data
.rdata:0000911C ; Segment permissions: Read
.rdata:0000911C _rdata          segment dword public 'DATA' use32
.rdata:0000911C                 assume cs:_rdata
.rdata:0000911C                 ;org 911Ch
.rdata:0000911C ; COMDAT (pick largest)
.rdata:0000911C                 dd offset ??_R4TiXmlTextA@@6B@ ; const TiXmlTextA::`RTTI Complete Object Locator'
.rdata:00009120                 public ??_7TiXmlTextA@@6B@
.rdata:00009120 ; const TiXmlTextA::`vftable'
.rdata:00009120 ??_7TiXmlTextA@@6B@ dd offset ??_ETiXmlTextA@@UAEPAXI@Z
.rdata:00009120                                         ; DATA XREF: TiXmlTextA::TiXmlTextA(char const *)+3Ao
.rdata:00009120                                         ; TiXmlTextA::~TiXmlTextA(void)+29o
.rdata:00009120                                         ; TiXmlTextA::`vector deleting destructor'(uint)
.rdata:00009124                 dd offset ?Print@TiXmlTextA@@UBEXPAU_iobuf@@H@Z ; TiXmlTextA::Print(_iobuf *,int)
.rdata:00009128                 dd offset ?StreamOut@TiXmlTextA@@MBEXPAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z ; TiXmlTextA::StreamOut(std::basic_ostream<char,std::char_traits<char>> *)
.rdata:0000912C                 dd offset ?Parse@TiXmlTextA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z ; TiXmlTextA::Parse(char const *,TiXmlParsingDataA *)
.rdata:00009130                 dd offset ?Type@TiXmlNodeA@@UBEHXZ ; TiXmlNodeA::Type(void)
.rdata:00009134                 dd offset ?Clone@TiXmlTextA@@MBEPAVTiXmlNodeA@@XZ ; TiXmlTextA::Clone(void)
.rdata:00009138                 dd offset ?StreamIn@TiXmlTextA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; TiXmlTextA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)
.rdata:00009138 _rdata          ends
.rdata:00009138
.rdata:0000913C ; ===========================================================================
.rdata:0000913C
.rdata:0000913C ; Segment type: Pure data
.rdata:0000913C ; Segment permissions: Read
.rdata:0000913C _rdata          segment dword public 'DATA' use32
.rdata:0000913C                 assume cs:_rdata
.rdata:0000913C                 ;org 913Ch
.rdata:0000913C ; COMDAT (pick largest)
.rdata:0000913C                 dd offset ??_R4TiXmlDeclarationA@@6B@ ; const TiXmlDeclarationA::`RTTI Complete Object Locator'
.rdata:00009140                 public ??_7TiXmlDeclarationA@@6B@
.rdata:00009140 ; const TiXmlDeclarationA::`vftable'
.rdata:00009140 ??_7TiXmlDeclarationA@@6B@ dd offset ??_ETiXmlDeclarationA@@UAEPAXI@Z
.rdata:00009140                                         ; DATA XREF: TiXmlDeclarationA::TiXmlDeclarationA(void)+3Ao
.rdata:00009140                                         ; TiXmlDeclarationA::~TiXmlDeclarationA(void)+29o
.rdata:00009140                                         ; TiXmlDeclarationA::`vector deleting destructor'(uint)
.rdata:00009144                 dd offset ?Print@TiXmlDeclarationA@@UBEXPAU_iobuf@@H@Z ; TiXmlDeclarationA::Print(_iobuf *,int)
.rdata:00009148                 dd offset ?StreamOut@TiXmlDeclarationA@@MBEXPAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z ; TiXmlDeclarationA::StreamOut(std::basic_ostream<char,std::char_traits<char>> *)
.rdata:0000914C                 dd offset ?Parse@TiXmlDeclarationA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z ; TiXmlDeclarationA::Parse(char const *,TiXmlParsingDataA *)
.rdata:00009150                 dd offset ?Type@TiXmlNodeA@@UBEHXZ ; TiXmlNodeA::Type(void)
.rdata:00009154                 dd offset ?Clone@TiXmlDeclarationA@@UBEPAVTiXmlNodeA@@XZ ; TiXmlDeclarationA::Clone(void)
.rdata:00009158                 dd offset ?StreamIn@TiXmlDeclarationA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; TiXmlDeclarationA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)
.rdata:00009158 _rdata          ends
.rdata:00009158
.rdata:0000915C ; ===========================================================================
.rdata:0000915C
.rdata:0000915C ; Segment type: Pure data
.rdata:0000915C ; Segment permissions: Read
.rdata:0000915C _rdata          segment dword public 'DATA' use32
.rdata:0000915C                 assume cs:_rdata
.rdata:0000915C                 ;org 915Ch
.rdata:0000915C ; COMDAT (pick largest)
.rdata:0000915C                 dd offset ??_R4TiXmlUnknownA@@6B@ ; const TiXmlUnknownA::`RTTI Complete Object Locator'
.rdata:00009160                 public ??_7TiXmlUnknownA@@6B@
.rdata:00009160 ; const TiXmlUnknownA::`vftable'
.rdata:00009160 ??_7TiXmlUnknownA@@6B@ dd offset ??_ETiXmlUnknownA@@UAEPAXI@Z
.rdata:00009160                                         ; DATA XREF: TiXmlUnknownA::TiXmlUnknownA(void)+3Ao
.rdata:00009160                                         ; TiXmlUnknownA::~TiXmlUnknownA(void)+29o
.rdata:00009160                                         ; TiXmlUnknownA::`vector deleting destructor'(uint)
.rdata:00009164                 dd offset ?Print@TiXmlUnknownA@@UBEXPAU_iobuf@@H@Z ; TiXmlUnknownA::Print(_iobuf *,int)
.rdata:00009168                 dd offset ?StreamOut@TiXmlUnknownA@@MBEXPAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z ; TiXmlUnknownA::StreamOut(std::basic_ostream<char,std::char_traits<char>> *)
.rdata:0000916C                 dd offset ?Parse@TiXmlUnknownA@@MAEPBDPBDPAVTiXmlParsingDataA@@@Z ; TiXmlUnknownA::Parse(char const *,TiXmlParsingDataA *)
.rdata:00009170                 dd offset ?Type@TiXmlNodeA@@UBEHXZ ; TiXmlNodeA::Type(void)
.rdata:00009174                 dd offset ?Clone@TiXmlUnknownA@@UBEPAVTiXmlNodeA@@XZ ; TiXmlUnknownA::Clone(void)
.rdata:00009178                 dd offset ?StreamIn@TiXmlUnknownA@@MAEXPAV?$basic_istream@DU?$char_traits@D@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; TiXmlUnknownA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)
.rdata:00009178 _rdata          ends
.rdata:00009178
.rdata:0000917C ; ===========================================================================
.rdata:0000917C
.rdata:0000917C ; Segment type: Pure data
.rdata:0000917C ; Segment permissions: Read
.rdata:0000917C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000917C _rdata          segment para public 'DATA' use32
.rdata:0000917C                 assume cs:_rdata
.rdata:0000917C                 ;org 917Ch
.rdata:0000917C ; COMDAT (pick any)
.rdata:0000917C                 public ??_C@_1FG@OIOOBCOF@?$AA?4?$AA?4?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAT?$AAi?$AAn?$AAy?$AAX?$AAm?$AAl?$AA?2?$AAt?$AAi?$AAn?$AAy?$AAX?$AAm?$AAl?$AAA?$AA?2?$AAt?$AAi?$AAn?$AAy?$AAx?$AAm?$AAl?$AAp@
.rdata:0000917C ; wchar_t `string'
.rdata:0000917C ??_C@_1FG@OIOOBCOF@?$AA?4?$AA?4?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAT?$AAi?$AAn?$AAy?$AAX?$AAm?$AAl?$AA?2?$AAt?$AAi?$AAn?$AAy?$AAX?$AAm?$AAl?$AAA?$AA?2?$AAt?$AAi?$AAn?$AAy?$AAx?$AAm?$AAl?$AAp@:
.rdata:0000917C                                         ; DATA XREF: TiXmlParsingDataA::TiXmlParsingDataA(char const *,int,int,int)+17o
.rdata:0000917C                 unicode 0, <..\src\TinyXml\tinyXmlA\tinyxmlparserA.cpp>,0
.rdata:000091D2                 align 4
.rdata:000091D2 _rdata          ends
.rdata:000091D2
.rdata:000091D4 ; ===========================================================================
.rdata:000091D4
.rdata:000091D4 ; Segment type: Pure data
.rdata:000091D4 ; Segment permissions: Read
.rdata:000091D4 _rdata          segment dword public 'DATA' use32
.rdata:000091D4                 assume cs:_rdata
.rdata:000091D4                 ;org 91D4h
.rdata:000091D4 ; COMDAT (pick any)
.rdata:000091D4                 public ??_C@_1M@JGKKHEFC@?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?$AA@
.rdata:000091D4 ; wchar_t `string'
.rdata:000091D4 ??_C@_1M@JGKKHEFC@?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?$AA@:
.rdata:000091D4                                         ; DATA XREF: TiXmlParsingDataA::TiXmlParsingDataA(char const *,int,int,int)+1Co
.rdata:000091D4                 unicode 0, <start>,0
.rdata:000091D4 _rdata          ends
.rdata:000091D4
.rdata:000091E0 ; ===========================================================================
.rdata:000091E0
.rdata:000091E0 ; Segment type: Pure data
.rdata:000091E0 ; Segment permissions: Read
.rdata:000091E0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000091E0 _rdata          segment para public 'DATA' use32
.rdata:000091E0                 assume cs:_rdata
.rdata:000091E0                 ;org 91E0h
.rdata:000091E0 ; COMDAT (pick any)
.rdata:000091E0                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000091E0 ; wchar_t `string'
.rdata:000091E0 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000091E0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator[](uint)+17o
.rdata:000091E0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(char const *)+Co ...
.rdata:000091E0                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000091E0                 unicode 0, <clude\xstring>,0
.rdata:0000926E                 align 10h
.rdata:0000926E _rdata          ends
.rdata:0000926E
.rdata:00009270 ; ===========================================================================
.rdata:00009270
.rdata:00009270 ; Segment type: Pure data
.rdata:00009270 ; Segment permissions: Read
.rdata:00009270 _rdata          segment dword public 'DATA' use32
.rdata:00009270                 assume cs:_rdata
.rdata:00009270                 ;org 9270h
.rdata:00009270 ; COMDAT (pick any)
.rdata:00009270                 public ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00009270 ; wchar_t `string'
.rdata:00009270 ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00009270                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator[](uint)+1Co
.rdata:00009270                 unicode 0, <string subscript out of range>,0
.rdata:00009270 _rdata          ends
.rdata:00009270
.bss:000092AC ; ===========================================================================
.bss:000092AC
.bss:000092AC ; Segment type: Uninitialized
.bss:000092AC ; Segment permissions: Read/Write
.bss:000092AC _bss            segment dword public 'BSS' use32
.bss:000092AC                 assume cs:_bss
.bss:000092AC                 ;org 92ACh
.bss:000092AC ; COMDAT (pick any)
.bss:000092AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000092AC                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:000092AC ; std::locale::id std::numpunct<char>::id
.bss:000092AC ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:000092AC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:000092AD                 db    ? ;
.bss:000092AE                 db    ? ;
.bss:000092AF                 db    ? ;
.bss:000092AF _bss            ends
.bss:000092AF
.bss:000092B0 ; ===========================================================================
.bss:000092B0
.bss:000092B0 ; Segment type: Uninitialized
.bss:000092B0 ; Segment permissions: Read/Write
.bss:000092B0 _bss            segment dword public 'BSS' use32
.bss:000092B0                 assume cs:_bss
.bss:000092B0                 ;org 92B0h
.bss:000092B0 ; COMDAT (pick any)
.bss:000092B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000092B0                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:000092B0 ; std::locale::id std::numpunct<wchar_t>::id
.bss:000092B0 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:000092B0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:000092B1                 db    ? ;
.bss:000092B2                 db    ? ;
.bss:000092B3                 db    ? ;
.bss:000092B3 _bss            ends
.bss:000092B3
.rdata:000092B4 ; ===========================================================================
.rdata:000092B4
.rdata:000092B4 ; Segment type: Pure data
.rdata:000092B4 ; Segment permissions: Read
.rdata:000092B4 _rdata          segment dword public 'DATA' use32
.rdata:000092B4                 assume cs:_rdata
.rdata:000092B4                 ;org 92B4h
.rdata:000092B4 ; COMDAT (pick any)
.rdata:000092B4                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:000092B4 ; char `string'[]
.rdata:000092B4 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:000092B4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:000092B4 _rdata          ends
.rdata:000092B4
.rdata:000092CC ; ===========================================================================
.rdata:000092CC
.rdata:000092CC ; Segment type: Pure data
.rdata:000092CC ; Segment permissions: Read
.rdata:000092CC _rdata          segment dword public 'DATA' use32
.rdata:000092CC                 assume cs:_rdata
.rdata:000092CC                 ;org 92CCh
.rdata:000092CC ; COMDAT (pick any)
.rdata:000092CC                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:000092CC ; char `string'[]
.rdata:000092CC ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:000092CC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:000092CC _rdata          ends
.rdata:000092CC
.rdata:000092DC ; ===========================================================================
.rdata:000092DC
.rdata:000092DC ; Segment type: Pure data
.rdata:000092DC ; Segment permissions: Read
.rdata:000092DC _rdata          segment dword public 'DATA' use32
.rdata:000092DC                 assume cs:_rdata
.rdata:000092DC                 ;org 92DCh
.rdata:000092DC ; COMDAT (pick any)
.rdata:000092DC                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:000092DC ; wchar_t `string'
.rdata:000092DC ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:000092DC                                         ; DATA XREF: std::_Debug_pointer<char>(char *,wchar_t const *,uint)+11o
.rdata:000092DC                                         ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:000092DC                 unicode 0, <invalid null pointer>,0
.rdata:00009306                 align 4
.rdata:00009306 _rdata          ends
.rdata:00009306
.bss:00009308 ; ===========================================================================
.bss:00009308
.bss:00009308 ; Segment type: Uninitialized
.bss:00009308 ; Segment permissions: Read/Write
.bss:00009308 _bss            segment dword public 'BSS' use32
.bss:00009308                 assume cs:_bss
.bss:00009308                 ;org 9308h
.bss:00009308 ; COMDAT (pick any)
.bss:00009308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009308                 public ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
.bss:00009308 ; public: static class std::locale::facet const * const std::_Facetptr<class std::ctype<char>>::_Psave
.bss:00009308 ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B dd ?
.bss:00009308                                         ; DATA XREF: std::use_facet<std::ctype<char>>(std::locale const &)+36r
.bss:00009308                                         ; std::use_facet<std::ctype<char>>(std::locale const &)+ABw
.bss:00009308 _bss            ends
.bss:00009308
.xdata$x:0000930C ; ===========================================================================
.xdata$x:0000930C
.xdata$x:0000930C ; Segment type: Pure data
.xdata$x:0000930C ; Segment permissions: Read
.xdata$x:0000930C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000930C                 assume cs:_xdata$x
.xdata$x:0000930C                 ;org 930Ch
.xdata$x:0000930C ; COMDAT (pick any)
.xdata$x:0000930C                 public __TI2?AVbad_cast@std@@
.xdata$x:0000930C __TI2?AVbad_cast@std@@ db    0          ; DATA XREF: std::use_facet<std::ctype<char>>(std::locale const &)+92o
.xdata$x:0000930D                 db    0
.xdata$x:0000930E                 db    0
.xdata$x:0000930F                 db    0
.xdata$x:00009310                 dd offset ??1bad_cast@std@@UAE@XZ ; std::bad_cast::~bad_cast(void)
.xdata$x:00009314                 align 8
.xdata$x:00009318                 dd offset __CTA2?AVbad_cast@std@@
.xdata$x:00009318 _xdata$x        ends
.xdata$x:00009318
.xdata$x:0000931C ; ===========================================================================
.xdata$x:0000931C
.xdata$x:0000931C ; Segment type: Pure data
.xdata$x:0000931C ; Segment permissions: Read
.xdata$x:0000931C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000931C                 assume cs:_xdata$x
.xdata$x:0000931C                 ;org 931Ch
.xdata$x:0000931C ; COMDAT (pick any)
.xdata$x:0000931C                 public __CTA2?AVbad_cast@std@@
.xdata$x:0000931C __CTA2?AVbad_cast@std@@ db    2         ; DATA XREF: .xdata$x:00009318o
.xdata$x:0000931D                 db    0
.xdata$x:0000931E                 db    0
.xdata$x:0000931F                 db    0
.xdata$x:00009320                 dd offset __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
.xdata$x:00009324                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00009324 _xdata$x        ends
.xdata$x:00009324
.data$r:00009328 ; ===========================================================================
.data$r:00009328
.data$r:00009328 ; Segment type: Pure data
.data$r:00009328 ; Segment permissions: Read/Write
.data$r:00009328 _data$r         segment dword public 'DATA' use32
.data$r:00009328                 assume cs:_data$r
.data$r:00009328                 ;org 9328h
.data$r:00009328 ; COMDAT (pick any)
.data$r:00009328                 public ??_R0?AVbad_cast@std@@@8
.data$r:00009328 ; class std::bad_cast `RTTI Type Descriptor'
.data$r:00009328 ??_R0?AVbad_cast@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00009328                                         ; DATA XREF: .xdata$x:00009348o
.data$r:00009328                                         ; const type_info::`vftable'
.data$r:0000932C                 align 10h
.data$r:00009330 a_?avbad_cast@s db '.?AVbad_cast@std@@',0
.data$r:00009343                 align 4
.data$r:00009343 _data$r         ends
.data$r:00009343
.xdata$x:00009344 ; ===========================================================================
.xdata$x:00009344
.xdata$x:00009344 ; Segment type: Pure data
.xdata$x:00009344 ; Segment permissions: Read
.xdata$x:00009344 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009344                 assume cs:_xdata$x
.xdata$x:00009344                 ;org 9344h
.xdata$x:00009344 ; COMDAT (pick any)
.xdata$x:00009344                 public __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
.xdata$x:00009344 __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00009344                                         ; DATA XREF: .xdata$x:00009320o
.xdata$x:00009345                 db    0
.xdata$x:00009346                 db    0
.xdata$x:00009347                 db    0
.xdata$x:00009348                 dd offset ??_R0?AVbad_cast@std@@@8 ; std::bad_cast `RTTI Type Descriptor'
.xdata$x:0000934C                 align 10h
.xdata$x:00009350                 db 0FFh
.xdata$x:00009351                 db 0FFh
.xdata$x:00009352                 db 0FFh
.xdata$x:00009353                 db 0FFh
.xdata$x:00009354                 db    0
.xdata$x:00009355                 db    0
.xdata$x:00009356                 db    0
.xdata$x:00009357                 db    0
.xdata$x:00009358                 db  0Ch
.xdata$x:00009359                 db    0
.xdata$x:0000935A                 db    0
.xdata$x:0000935B                 db    0
.xdata$x:0000935C                 dd offset ??0bad_cast@std@@QAE@ABV01@@Z ; std::bad_cast::bad_cast(std::bad_cast const &)
.xdata$x:0000935C _xdata$x        ends
.xdata$x:0000935C
.rdata:00009360 ; ===========================================================================
.rdata:00009360
.rdata:00009360 ; Segment type: Pure data
.rdata:00009360 ; Segment permissions: Read
.rdata:00009360 _rdata          segment dword public 'DATA' use32
.rdata:00009360                 assume cs:_rdata
.rdata:00009360                 ;org 9360h
.rdata:00009360 ; COMDAT (pick any)
.rdata:00009360                 public ??_C@_08EPJLHIJG@bad?5cast?$AA@
.rdata:00009360 ; char `string'[]
.rdata:00009360 ??_C@_08EPJLHIJG@bad?5cast?$AA@ db 'bad cast',0
.rdata:00009360                                         ; DATA XREF: std::use_facet<std::ctype<char>>(std::locale const &)+85o
.rdata:00009369                 align 4
.rdata:00009369 _rdata          ends
.rdata:00009369
.rdata:0000936C ; ===========================================================================
.rdata:0000936C
.rdata:0000936C ; Segment type: Pure data
.rdata:0000936C ; Segment permissions: Read
.rdata:0000936C _rdata          segment dword public 'DATA' use32
.rdata:0000936C                 assume cs:_rdata
.rdata:0000936C                 ;org 936Ch
.rdata:0000936C ; COMDAT (pick any)
.rdata:0000936C                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000936C ; wchar_t `string'
.rdata:0000936C ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000936C                                         ; DATA XREF: std::_Debug_range2<char const *>(char const *,char const *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000936C                 unicode 0, <invalid iterator range>,0
.rdata:0000939A                 align 4
.rdata:0000939A _rdata          ends
.rdata:0000939A
.rdata$r:0000939C ; ===========================================================================
.rdata$r:0000939C
.rdata$r:0000939C ; Segment type: Pure data
.rdata$r:0000939C ; Segment permissions: Read
.rdata$r:0000939C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000939C                 assume cs:_rdata$r
.rdata$r:0000939C                 ;org 939Ch
.rdata$r:0000939C ; COMDAT (pick any)
.rdata$r:0000939C                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:0000939C ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000939C ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:0000939C                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:0000939C                                         ; .rdata$r:000093F8o ...
.rdata$r:0000939C                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:000093A0                 db    0
.rdata$r:000093A1                 db    0
.rdata$r:000093A2                 db    0
.rdata$r:000093A3                 db    0
.rdata$r:000093A4                 db    0
.rdata$r:000093A5                 db    0
.rdata$r:000093A6                 db    0
.rdata$r:000093A7                 db    0
.rdata$r:000093A8                 db 0FFh
.rdata$r:000093A9                 db 0FFh
.rdata$r:000093AA                 db 0FFh
.rdata$r:000093AB                 db 0FFh
.rdata$r:000093AC                 db    0
.rdata$r:000093AD                 db    0
.rdata$r:000093AE                 db    0
.rdata$r:000093AF                 db    0
.rdata$r:000093B0                 db  40h ; @
.rdata$r:000093B1                 db    0
.rdata$r:000093B2                 db    0
.rdata$r:000093B3                 db    0
.rdata$r:000093B4                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:000093B4 _rdata$r        ends
.rdata$r:000093B4
.rdata$r:000093B8 ; ===========================================================================
.rdata$r:000093B8
.rdata$r:000093B8 ; Segment type: Pure data
.rdata$r:000093B8 ; Segment permissions: Read
.rdata$r:000093B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000093B8                 assume cs:_rdata$r
.rdata$r:000093B8                 ;org 93B8h
.rdata$r:000093B8 ; COMDAT (pick any)
.rdata$r:000093B8                 public ??_R3exception@std@@8
.rdata$r:000093B8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:000093B8 ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:000093B4o
.rdata$r:000093B9                 db    0
.rdata$r:000093BA                 db    0
.rdata$r:000093BB                 db    0
.rdata$r:000093BC                 db    0
.rdata$r:000093BD                 db    0
.rdata$r:000093BE                 db    0
.rdata$r:000093BF                 db    0
.rdata$r:000093C0                 db    1
.rdata$r:000093C1                 db    0
.rdata$r:000093C2                 db    0
.rdata$r:000093C3                 db    0
.rdata$r:000093C4                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:000093C4 _rdata$r        ends
.rdata$r:000093C4
.rdata$r:000093C8 ; ===========================================================================
.rdata$r:000093C8
.rdata$r:000093C8 ; Segment type: Pure data
.rdata$r:000093C8 ; Segment permissions: Read
.rdata$r:000093C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000093C8                 assume cs:_rdata$r
.rdata$r:000093C8                 ;org 93C8h
.rdata$r:000093C8 ; COMDAT (pick any)
.rdata$r:000093C8                 public ??_R2exception@std@@8
.rdata$r:000093C8 ; std::exception::`RTTI Base Class Array'
.rdata$r:000093C8 ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:000093C8                                         ; DATA XREF: .rdata$r:000093C4o
.rdata$r:000093C8                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000093CC                 db    0
.rdata$r:000093CD                 align 10h
.rdata$r:000093CD _rdata$r        ends
.rdata$r:000093CD
.rdata$r:000093D0 ; ===========================================================================
.rdata$r:000093D0
.rdata$r:000093D0 ; Segment type: Pure data
.rdata$r:000093D0 ; Segment permissions: Read
.rdata$r:000093D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000093D0                 assume cs:_rdata$r
.rdata$r:000093D0                 ;org 93D0h
.rdata$r:000093D0 ; COMDAT (pick any)
.rdata$r:000093D0                 public ??_R4runtime_error@std@@6B@
.rdata$r:000093D0 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:000093D0 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:00008C28o
.rdata$r:000093D1                 db    0
.rdata$r:000093D2                 db    0
.rdata$r:000093D3                 db    0
.rdata$r:000093D4                 db    0
.rdata$r:000093D5                 db    0
.rdata$r:000093D6                 db    0
.rdata$r:000093D7                 db    0
.rdata$r:000093D8                 db    0
.rdata$r:000093D9                 db    0
.rdata$r:000093DA                 db    0
.rdata$r:000093DB                 db    0
.rdata$r:000093DC                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:000093E0                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000093E0 _rdata$r        ends
.rdata$r:000093E0
.rdata$r:000093E4 ; ===========================================================================
.rdata$r:000093E4
.rdata$r:000093E4 ; Segment type: Pure data
.rdata$r:000093E4 ; Segment permissions: Read
.rdata$r:000093E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000093E4                 assume cs:_rdata$r
.rdata$r:000093E4                 ;org 93E4h
.rdata$r:000093E4 ; COMDAT (pick any)
.rdata$r:000093E4                 public ??_R3runtime_error@std@@8
.rdata$r:000093E4 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000093E4 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:000093E0o
.rdata$r:000093E4                                         ; .rdata$r:00009418o
.rdata$r:000093E5                 db    0
.rdata$r:000093E6                 db    0
.rdata$r:000093E7                 db    0
.rdata$r:000093E8                 db    0
.rdata$r:000093E9                 db    0
.rdata$r:000093EA                 db    0
.rdata$r:000093EB                 db    0
.rdata$r:000093EC                 db    2
.rdata$r:000093ED                 db    0
.rdata$r:000093EE                 db    0
.rdata$r:000093EF                 db    0
.rdata$r:000093F0                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:000093F0 _rdata$r        ends
.rdata$r:000093F0
.rdata$r:000093F4 ; ===========================================================================
.rdata$r:000093F4
.rdata$r:000093F4 ; Segment type: Pure data
.rdata$r:000093F4 ; Segment permissions: Read
.rdata$r:000093F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000093F4                 assume cs:_rdata$r
.rdata$r:000093F4                 ;org 93F4h
.rdata$r:000093F4 ; COMDAT (pick any)
.rdata$r:000093F4                 public ??_R2runtime_error@std@@8
.rdata$r:000093F4 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:000093F4 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:000093F4                                         ; DATA XREF: .rdata$r:000093F0o
.rdata$r:000093F4                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000093F8                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000093FC                 db    0
.rdata$r:000093FD                 align 10h
.rdata$r:000093FD _rdata$r        ends
.rdata$r:000093FD
.rdata$r:00009400 ; ===========================================================================
.rdata$r:00009400
.rdata$r:00009400 ; Segment type: Pure data
.rdata$r:00009400 ; Segment permissions: Read
.rdata$r:00009400 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009400                 assume cs:_rdata$r
.rdata$r:00009400                 ;org 9400h
.rdata$r:00009400 ; COMDAT (pick any)
.rdata$r:00009400                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00009400 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009400 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00009400                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00009400                                         ; .rdata$r:00009664o ...
.rdata$r:00009400                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00009404                 db    1
.rdata$r:00009405                 db    0
.rdata$r:00009406                 db    0
.rdata$r:00009407                 db    0
.rdata$r:00009408                 db    0
.rdata$r:00009409                 db    0
.rdata$r:0000940A                 db    0
.rdata$r:0000940B                 db    0
.rdata$r:0000940C                 db 0FFh
.rdata$r:0000940D                 db 0FFh
.rdata$r:0000940E                 db 0FFh
.rdata$r:0000940F                 db 0FFh
.rdata$r:00009410                 db    0
.rdata$r:00009411                 db    0
.rdata$r:00009412                 db    0
.rdata$r:00009413                 db    0
.rdata$r:00009414                 db  40h ; @
.rdata$r:00009415                 db    0
.rdata$r:00009416                 db    0
.rdata$r:00009417                 db    0
.rdata$r:00009418                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009418 _rdata$r        ends
.rdata$r:00009418
.rdata$r:0000941C ; ===========================================================================
.rdata$r:0000941C
.rdata$r:0000941C ; Segment type: Pure data
.rdata$r:0000941C ; Segment permissions: Read
.rdata$r:0000941C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000941C                 assume cs:_rdata$r
.rdata$r:0000941C                 ;org 941Ch
.rdata$r:0000941C ; COMDAT (pick any)
.rdata$r:0000941C                 public ??_R4_Facet_base@std@@6B@
.rdata$r:0000941C ; const std::_Facet_base::`RTTI Complete Object Locator'
.rdata$r:0000941C ??_R4_Facet_base@std@@6B@ db    0       ; DATA XREF: .rdata:00008CD4o
.rdata$r:0000941D                 db    0
.rdata$r:0000941E                 db    0
.rdata$r:0000941F                 db    0
.rdata$r:00009420                 db    0
.rdata$r:00009421                 db    0
.rdata$r:00009422                 db    0
.rdata$r:00009423                 db    0
.rdata$r:00009424                 db    0
.rdata$r:00009425                 db    0
.rdata$r:00009426                 db    0
.rdata$r:00009427                 db    0
.rdata$r:00009428                 dd offset ??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base `RTTI Type Descriptor'
.rdata$r:0000942C                 dd offset ??_R3_Facet_base@std@@8 ; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000942C _rdata$r        ends
.rdata$r:0000942C
.data$r:00009430 ; ===========================================================================
.data$r:00009430
.data$r:00009430 ; Segment type: Pure data
.data$r:00009430 ; Segment permissions: Read/Write
.data$r:00009430 _data$r         segment dword public 'DATA' use32
.data$r:00009430                 assume cs:_data$r
.data$r:00009430                 ;org 9430h
.data$r:00009430 ; COMDAT (pick any)
.data$r:00009430                 public ??_R0?AV_Facet_base@std@@@8
.data$r:00009430 ; class std::_Facet_base `RTTI Type Descriptor'
.data$r:00009430 ??_R0?AV_Facet_base@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00009430                                         ; DATA XREF: .rdata$r:00009428o
.data$r:00009430                                         ; .rdata$r:std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009430                                         ; const type_info::`vftable'
.data$r:00009434                 align 8
.data$r:00009438 a_?av_facet_bas db '.?AV_Facet_base@std@@',0
.data$r:0000944E                 align 10h
.data$r:0000944E _data$r         ends
.data$r:0000944E
.rdata$r:00009450 ; ===========================================================================
.rdata$r:00009450
.rdata$r:00009450 ; Segment type: Pure data
.rdata$r:00009450 ; Segment permissions: Read
.rdata$r:00009450 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009450                 assume cs:_rdata$r
.rdata$r:00009450                 ;org 9450h
.rdata$r:00009450 ; COMDAT (pick any)
.rdata$r:00009450                 public ??_R3_Facet_base@std@@8
.rdata$r:00009450 ; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009450 ??_R3_Facet_base@std@@8 db    0         ; DATA XREF: .rdata$r:0000942Co
.rdata$r:00009450                                         ; .rdata$r:00009480o
.rdata$r:00009451                 db    0
.rdata$r:00009452                 db    0
.rdata$r:00009453                 db    0
.rdata$r:00009454                 db    0
.rdata$r:00009455                 db    0
.rdata$r:00009456                 db    0
.rdata$r:00009457                 db    0
.rdata$r:00009458                 db    1
.rdata$r:00009459                 db    0
.rdata$r:0000945A                 db    0
.rdata$r:0000945B                 db    0
.rdata$r:0000945C                 dd offset ??_R2_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
.rdata$r:0000945C _rdata$r        ends
.rdata$r:0000945C
.rdata$r:00009460 ; ===========================================================================
.rdata$r:00009460
.rdata$r:00009460 ; Segment type: Pure data
.rdata$r:00009460 ; Segment permissions: Read
.rdata$r:00009460 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009460                 assume cs:_rdata$r
.rdata$r:00009460                 ;org 9460h
.rdata$r:00009460 ; COMDAT (pick any)
.rdata$r:00009460                 public ??_R2_Facet_base@std@@8
.rdata$r:00009460 ; std::_Facet_base::`RTTI Base Class Array'
.rdata$r:00009460 ??_R2_Facet_base@std@@8 dd offset ??_R1A@?0A@EA@_Facet_base@std@@8
.rdata$r:00009460                                         ; DATA XREF: .rdata$r:0000945Co
.rdata$r:00009460                                         ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009464                 db    0
.rdata$r:00009465                 align 4
.rdata$r:00009465 _rdata$r        ends
.rdata$r:00009465
.rdata$r:00009468 ; ===========================================================================
.rdata$r:00009468
.rdata$r:00009468 ; Segment type: Pure data
.rdata$r:00009468 ; Segment permissions: Read
.rdata$r:00009468 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009468                 assume cs:_rdata$r
.rdata$r:00009468                 ;org 9468h
.rdata$r:00009468 ; COMDAT (pick any)
.rdata$r:00009468                 public ??_R1A@?0A@EA@_Facet_base@std@@8
.rdata$r:00009468 ; std::_Facet_base::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009468 ??_R1A@?0A@EA@_Facet_base@std@@8 dd offset ??_R0?AV_Facet_base@std@@@8
.rdata$r:00009468                                         ; DATA XREF: .rdata$r:std::_Facet_base::`RTTI Base Class Array'o
.rdata$r:00009468                                         ; .rdata$r:000094D4o ...
.rdata$r:00009468                                         ; std::_Facet_base `RTTI Type Descriptor'
.rdata$r:0000946C                 db    0
.rdata$r:0000946D                 db    0
.rdata$r:0000946E                 db    0
.rdata$r:0000946F                 db    0
.rdata$r:00009470                 db    0
.rdata$r:00009471                 db    0
.rdata$r:00009472                 db    0
.rdata$r:00009473                 db    0
.rdata$r:00009474                 db 0FFh
.rdata$r:00009475                 db 0FFh
.rdata$r:00009476                 db 0FFh
.rdata$r:00009477                 db 0FFh
.rdata$r:00009478                 db    0
.rdata$r:00009479                 db    0
.rdata$r:0000947A                 db    0
.rdata$r:0000947B                 db    0
.rdata$r:0000947C                 db  40h ; @
.rdata$r:0000947D                 db    0
.rdata$r:0000947E                 db    0
.rdata$r:0000947F                 db    0
.rdata$r:00009480                 dd offset ??_R3_Facet_base@std@@8 ; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009480 _rdata$r        ends
.rdata$r:00009480
.rdata$r:00009484 ; ===========================================================================
.rdata$r:00009484
.rdata$r:00009484 ; Segment type: Pure data
.rdata$r:00009484 ; Segment permissions: Read
.rdata$r:00009484 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009484                 assume cs:_rdata$r
.rdata$r:00009484                 ;org 9484h
.rdata$r:00009484 ; COMDAT (pick any)
.rdata$r:00009484                 public ??_R1A@?0A@EA@facet@locale@std@@8
.rdata$r:00009484 ; std::locale::facet::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009484 ??_R1A@?0A@EA@facet@locale@std@@8 dd offset ??_R0?AVfacet@locale@std@@@8
.rdata$r:00009484                                         ; DATA XREF: .rdata$r:std::locale::facet::`RTTI Base Class Array'o
.rdata$r:00009484                                         ; .rdata$r:00009538o ...
.rdata$r:00009484                                         ; std::locale::facet `RTTI Type Descriptor'
.rdata$r:00009488                 db    1
.rdata$r:00009489                 db    0
.rdata$r:0000948A                 db    0
.rdata$r:0000948B                 db    0
.rdata$r:0000948C                 db    0
.rdata$r:0000948D                 db    0
.rdata$r:0000948E                 db    0
.rdata$r:0000948F                 db    0
.rdata$r:00009490                 db 0FFh
.rdata$r:00009491                 db 0FFh
.rdata$r:00009492                 db 0FFh
.rdata$r:00009493                 db 0FFh
.rdata$r:00009494                 db    0
.rdata$r:00009495                 db    0
.rdata$r:00009496                 db    0
.rdata$r:00009497                 db    0
.rdata$r:00009498                 db  40h ; @
.rdata$r:00009499                 db    0
.rdata$r:0000949A                 db    0
.rdata$r:0000949B                 db    0
.rdata$r:0000949C                 dd offset ??_R3facet@locale@std@@8 ; std::locale::facet::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000949C _rdata$r        ends
.rdata$r:0000949C
.data$r:000094A0 ; ===========================================================================
.data$r:000094A0
.data$r:000094A0 ; Segment type: Pure data
.data$r:000094A0 ; Segment permissions: Read/Write
.data$r:000094A0 _data$r         segment dword public 'DATA' use32
.data$r:000094A0                 assume cs:_data$r
.data$r:000094A0                 ;org 94A0h
.data$r:000094A0 ; COMDAT (pick any)
.data$r:000094A0                 public ??_R0?AVfacet@locale@std@@@8
.data$r:000094A0 ; class std::locale::facet `RTTI Type Descriptor'
.data$r:000094A0 ??_R0?AVfacet@locale@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000094A0                                         ; DATA XREF: .rdata$r:std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000094A0                                         ; .rdata$r:000094E8o
.data$r:000094A0                                         ; const type_info::`vftable'
.data$r:000094A4                 align 8
.data$r:000094A8 a_?avfacet@loca db '.?AVfacet@locale@std@@',0
.data$r:000094BF                 align 10h
.data$r:000094BF _data$r         ends
.data$r:000094BF
.rdata$r:000094C0 ; ===========================================================================
.rdata$r:000094C0
.rdata$r:000094C0 ; Segment type: Pure data
.rdata$r:000094C0 ; Segment permissions: Read
.rdata$r:000094C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000094C0                 assume cs:_rdata$r
.rdata$r:000094C0                 ;org 94C0h
.rdata$r:000094C0 ; COMDAT (pick any)
.rdata$r:000094C0                 public ??_R3facet@locale@std@@8
.rdata$r:000094C0 ; std::locale::facet::`RTTI Class Hierarchy Descriptor'
.rdata$r:000094C0 ??_R3facet@locale@std@@8 db    0        ; DATA XREF: .rdata$r:0000949Co
.rdata$r:000094C0                                         ; .rdata$r:000094ECo
.rdata$r:000094C1                 db    0
.rdata$r:000094C2                 db    0
.rdata$r:000094C3                 db    0
.rdata$r:000094C4                 db    0
.rdata$r:000094C5                 db    0
.rdata$r:000094C6                 db    0
.rdata$r:000094C7                 db    0
.rdata$r:000094C8                 db    2
.rdata$r:000094C9                 db    0
.rdata$r:000094CA                 db    0
.rdata$r:000094CB                 db    0
.rdata$r:000094CC                 dd offset ??_R2facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
.rdata$r:000094CC _rdata$r        ends
.rdata$r:000094CC
.rdata$r:000094D0 ; ===========================================================================
.rdata$r:000094D0
.rdata$r:000094D0 ; Segment type: Pure data
.rdata$r:000094D0 ; Segment permissions: Read
.rdata$r:000094D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000094D0                 assume cs:_rdata$r
.rdata$r:000094D0                 ;org 94D0h
.rdata$r:000094D0 ; COMDAT (pick any)
.rdata$r:000094D0                 public ??_R2facet@locale@std@@8
.rdata$r:000094D0 ; std::locale::facet::`RTTI Base Class Array'
.rdata$r:000094D0 ??_R2facet@locale@std@@8 dd offset ??_R1A@?0A@EA@facet@locale@std@@8
.rdata$r:000094D0                                         ; DATA XREF: .rdata$r:000094CCo
.rdata$r:000094D0                                         ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000094D4                 dd offset ??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000094D8                 db    0
.rdata$r:000094D9                 align 4
.rdata$r:000094D9 _rdata$r        ends
.rdata$r:000094D9
.rdata$r:000094DC ; ===========================================================================
.rdata$r:000094DC
.rdata$r:000094DC ; Segment type: Pure data
.rdata$r:000094DC ; Segment permissions: Read
.rdata$r:000094DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000094DC                 assume cs:_rdata$r
.rdata$r:000094DC                 ;org 94DCh
.rdata$r:000094DC ; COMDAT (pick any)
.rdata$r:000094DC                 public ??_R4facet@locale@std@@6B@
.rdata$r:000094DC ; const std::locale::facet::`RTTI Complete Object Locator'
.rdata$r:000094DC ??_R4facet@locale@std@@6B@ db    0      ; DATA XREF: .rdata:00008CE4o
.rdata$r:000094DD                 db    0
.rdata$r:000094DE                 db    0
.rdata$r:000094DF                 db    0
.rdata$r:000094E0                 db    0
.rdata$r:000094E1                 db    0
.rdata$r:000094E2                 db    0
.rdata$r:000094E3                 db    0
.rdata$r:000094E4                 db    0
.rdata$r:000094E5                 db    0
.rdata$r:000094E6                 db    0
.rdata$r:000094E7                 db    0
.rdata$r:000094E8                 dd offset ??_R0?AVfacet@locale@std@@@8 ; std::locale::facet `RTTI Type Descriptor'
.rdata$r:000094EC                 dd offset ??_R3facet@locale@std@@8 ; std::locale::facet::`RTTI Class Hierarchy Descriptor'
.rdata$r:000094EC _rdata$r        ends
.rdata$r:000094EC
.rdata$r:000094F0 ; ===========================================================================
.rdata$r:000094F0
.rdata$r:000094F0 ; Segment type: Pure data
.rdata$r:000094F0 ; Segment permissions: Read
.rdata$r:000094F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000094F0                 assume cs:_rdata$r
.rdata$r:000094F0                 ;org 94F0h
.rdata$r:000094F0 ; COMDAT (pick any)
.rdata$r:000094F0                 public ??_R4ctype_base@std@@6B@
.rdata$r:000094F0 ; const std::ctype_base::`RTTI Complete Object Locator'
.rdata$r:000094F0 ??_R4ctype_base@std@@6B@ db    0        ; DATA XREF: .rdata:00008DD0o
.rdata$r:000094F1                 db    0
.rdata$r:000094F2                 db    0
.rdata$r:000094F3                 db    0
.rdata$r:000094F4                 db    0
.rdata$r:000094F5                 db    0
.rdata$r:000094F6                 db    0
.rdata$r:000094F7                 db    0
.rdata$r:000094F8                 db    0
.rdata$r:000094F9                 db    0
.rdata$r:000094FA                 db    0
.rdata$r:000094FB                 db    0
.rdata$r:000094FC                 dd offset ??_R0?AUctype_base@std@@@8 ; std::ctype_base `RTTI Type Descriptor'
.rdata$r:00009500                 dd offset ??_R3ctype_base@std@@8 ; std::ctype_base::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009500 _rdata$r        ends
.rdata$r:00009500
.data$r:00009504 ; ===========================================================================
.data$r:00009504
.data$r:00009504 ; Segment type: Pure data
.data$r:00009504 ; Segment permissions: Read/Write
.data$r:00009504 _data$r         segment dword public 'DATA' use32
.data$r:00009504                 assume cs:_data$r
.data$r:00009504                 ;org 9504h
.data$r:00009504 ; COMDAT (pick any)
.data$r:00009504                 public ??_R0?AUctype_base@std@@@8
.data$r:00009504 ; struct std::ctype_base `RTTI Type Descriptor'
.data$r:00009504 ??_R0?AUctype_base@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00009504                                         ; DATA XREF: .rdata$r:000094FCo
.data$r:00009504                                         ; .rdata$r:std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009504                                         ; const type_info::`vftable'
.data$r:00009508                 db    0
.data$r:00009509                 db    0
.data$r:0000950A                 db    0
.data$r:0000950B                 db    0
.data$r:0000950C                 db  2Eh ; .
.data$r:0000950D                 db  3Fh ; ?
.data$r:0000950E                 db  41h ; A
.data$r:0000950F                 db  55h ; U
.data$r:00009510                 db  63h ; c
.data$r:00009511                 db  74h ; t
.data$r:00009512                 db  79h ; y
.data$r:00009513                 db  70h ; p
.data$r:00009514                 db  65h ; e
.data$r:00009515                 db  5Fh ; _
.data$r:00009516                 db  62h ; b
.data$r:00009517                 db  61h ; a
.data$r:00009518                 db  73h ; s
.data$r:00009519                 db  65h ; e
.data$r:0000951A                 db  40h ; @
.data$r:0000951B                 db  73h ; s
.data$r:0000951C                 db  74h ; t
.data$r:0000951D                 db  64h ; d
.data$r:0000951E                 db  40h ; @
.data$r:0000951F                 db  40h ; @
.data$r:00009520                 db    0
.data$r:00009521                 align 4
.data$r:00009521 _data$r         ends
.data$r:00009521
.rdata$r:00009524 ; ===========================================================================
.rdata$r:00009524
.rdata$r:00009524 ; Segment type: Pure data
.rdata$r:00009524 ; Segment permissions: Read
.rdata$r:00009524 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009524                 assume cs:_rdata$r
.rdata$r:00009524                 ;org 9524h
.rdata$r:00009524 ; COMDAT (pick any)
.rdata$r:00009524                 public ??_R3ctype_base@std@@8
.rdata$r:00009524 ; std::ctype_base::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009524 ??_R3ctype_base@std@@8 db    0          ; DATA XREF: .rdata$r:00009500o
.rdata$r:00009524                                         ; .rdata$r:0000955Co
.rdata$r:00009525                 db    0
.rdata$r:00009526                 db    0
.rdata$r:00009527                 db    0
.rdata$r:00009528                 db    0
.rdata$r:00009529                 db    0
.rdata$r:0000952A                 db    0
.rdata$r:0000952B                 db    0
.rdata$r:0000952C                 db    3
.rdata$r:0000952D                 db    0
.rdata$r:0000952E                 db    0
.rdata$r:0000952F                 db    0
.rdata$r:00009530                 dd offset ??_R2ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
.rdata$r:00009530 _rdata$r        ends
.rdata$r:00009530
.rdata$r:00009534 ; ===========================================================================
.rdata$r:00009534
.rdata$r:00009534 ; Segment type: Pure data
.rdata$r:00009534 ; Segment permissions: Read
.rdata$r:00009534 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009534                 assume cs:_rdata$r
.rdata$r:00009534                 ;org 9534h
.rdata$r:00009534 ; COMDAT (pick any)
.rdata$r:00009534                 public ??_R2ctype_base@std@@8
.rdata$r:00009534 ; std::ctype_base::`RTTI Base Class Array'
.rdata$r:00009534 ??_R2ctype_base@std@@8 dd offset ??_R1A@?0A@EA@ctype_base@std@@8
.rdata$r:00009534                                         ; DATA XREF: .rdata$r:00009530o
.rdata$r:00009534                                         ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009538                 dd offset ??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000953C                 dd offset ??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009540                 db    0
.rdata$r:00009541                 align 4
.rdata$r:00009541 _rdata$r        ends
.rdata$r:00009541
.rdata$r:00009544 ; ===========================================================================
.rdata$r:00009544
.rdata$r:00009544 ; Segment type: Pure data
.rdata$r:00009544 ; Segment permissions: Read
.rdata$r:00009544 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009544                 assume cs:_rdata$r
.rdata$r:00009544                 ;org 9544h
.rdata$r:00009544 ; COMDAT (pick any)
.rdata$r:00009544                 public ??_R1A@?0A@EA@ctype_base@std@@8
.rdata$r:00009544 ; std::ctype_base::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009544 ??_R1A@?0A@EA@ctype_base@std@@8 dd offset ??_R0?AUctype_base@std@@@8
.rdata$r:00009544                                         ; DATA XREF: .rdata$r:std::ctype_base::`RTTI Base Class Array'o
.rdata$r:00009544                                         ; .rdata$r:000095A4o
.rdata$r:00009544                                         ; std::ctype_base `RTTI Type Descriptor'
.rdata$r:00009548                 db    2
.rdata$r:00009549                 db    0
.rdata$r:0000954A                 db    0
.rdata$r:0000954B                 db    0
.rdata$r:0000954C                 db    0
.rdata$r:0000954D                 db    0
.rdata$r:0000954E                 db    0
.rdata$r:0000954F                 db    0
.rdata$r:00009550                 db 0FFh
.rdata$r:00009551                 db 0FFh
.rdata$r:00009552                 db 0FFh
.rdata$r:00009553                 db 0FFh
.rdata$r:00009554                 db    0
.rdata$r:00009555                 db    0
.rdata$r:00009556                 db    0
.rdata$r:00009557                 db    0
.rdata$r:00009558                 db  40h ; @
.rdata$r:00009559                 db    0
.rdata$r:0000955A                 db    0
.rdata$r:0000955B                 db    0
.rdata$r:0000955C                 dd offset ??_R3ctype_base@std@@8 ; std::ctype_base::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000955C _rdata$r        ends
.rdata$r:0000955C
.rdata$r:00009560 ; ===========================================================================
.rdata$r:00009560
.rdata$r:00009560 ; Segment type: Pure data
.rdata$r:00009560 ; Segment permissions: Read
.rdata$r:00009560 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009560                 assume cs:_rdata$r
.rdata$r:00009560                 ;org 9560h
.rdata$r:00009560 ; COMDAT (pick any)
.rdata$r:00009560                 public ??_R4?$ctype@D@std@@6B@
.rdata$r:00009560 ; const std::ctype<char>::`RTTI Complete Object Locator'
.rdata$r:00009560 ??_R4?$ctype@D@std@@6B@ db    0         ; DATA XREF: .rdata:00008DE0o
.rdata$r:00009561                 db    0
.rdata$r:00009562                 db    0
.rdata$r:00009563                 db    0
.rdata$r:00009564                 db    0
.rdata$r:00009565                 db    0
.rdata$r:00009566                 db    0
.rdata$r:00009567                 db    0
.rdata$r:00009568                 db    0
.rdata$r:00009569                 db    0
.rdata$r:0000956A                 db    0
.rdata$r:0000956B                 db    0
.rdata$r:0000956C                 dd offset ??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char> `RTTI Type Descriptor'
.rdata$r:00009570                 dd offset ??_R3?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009570 _rdata$r        ends
.rdata$r:00009570
.data$r:00009574 ; ===========================================================================
.data$r:00009574
.data$r:00009574 ; Segment type: Pure data
.data$r:00009574 ; Segment permissions: Read/Write
.data$r:00009574 _data$r         segment dword public 'DATA' use32
.data$r:00009574                 assume cs:_data$r
.data$r:00009574                 ;org 9574h
.data$r:00009574 ; COMDAT (pick any)
.data$r:00009574                 public ??_R0?AV?$ctype@D@std@@@8
.data$r:00009574 ; class std::ctype<char> `RTTI Type Descriptor'
.data$r:00009574 ??_R0?AV?$ctype@D@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00009574                                         ; DATA XREF: .rdata$r:0000956Co
.data$r:00009574                                         ; .rdata$r:std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009574                                         ; const type_info::`vftable'
.data$r:00009578                 db    0
.data$r:00009579                 db    0
.data$r:0000957A                 db    0
.data$r:0000957B                 db    0
.data$r:0000957C                 db  2Eh ; .
.data$r:0000957D                 db  3Fh ; ?
.data$r:0000957E                 db  41h ; A
.data$r:0000957F                 db  56h ; V
.data$r:00009580                 db  3Fh ; ?
.data$r:00009581                 db  24h ; $
.data$r:00009582                 db  63h ; c
.data$r:00009583                 db  74h ; t
.data$r:00009584                 db  79h ; y
.data$r:00009585                 db  70h ; p
.data$r:00009586                 db  65h ; e
.data$r:00009587                 db  40h ; @
.data$r:00009588                 db  44h ; D
.data$r:00009589                 db  40h ; @
.data$r:0000958A                 db  73h ; s
.data$r:0000958B                 db  74h ; t
.data$r:0000958C                 db  64h ; d
.data$r:0000958D                 db  40h ; @
.data$r:0000958E                 db  40h ; @
.data$r:0000958F                 db    0
.data$r:0000958F _data$r         ends
.data$r:0000958F
.rdata$r:00009590 ; ===========================================================================
.rdata$r:00009590
.rdata$r:00009590 ; Segment type: Pure data
.rdata$r:00009590 ; Segment permissions: Read
.rdata$r:00009590 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009590                 assume cs:_rdata$r
.rdata$r:00009590                 ;org 9590h
.rdata$r:00009590 ; COMDAT (pick any)
.rdata$r:00009590                 public ??_R3?$ctype@D@std@@8
.rdata$r:00009590 ; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009590 ??_R3?$ctype@D@std@@8 db    0           ; DATA XREF: .rdata$r:00009570o
.rdata$r:00009590                                         ; .rdata$r:000095CCo
.rdata$r:00009591                 db    0
.rdata$r:00009592                 db    0
.rdata$r:00009593                 db    0
.rdata$r:00009594                 db    0
.rdata$r:00009595                 db    0
.rdata$r:00009596                 db    0
.rdata$r:00009597                 db    0
.rdata$r:00009598                 db    4
.rdata$r:00009599                 db    0
.rdata$r:0000959A                 db    0
.rdata$r:0000959B                 db    0
.rdata$r:0000959C                 dd offset ??_R2?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
.rdata$r:0000959C _rdata$r        ends
.rdata$r:0000959C
.rdata$r:000095A0 ; ===========================================================================
.rdata$r:000095A0
.rdata$r:000095A0 ; Segment type: Pure data
.rdata$r:000095A0 ; Segment permissions: Read
.rdata$r:000095A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000095A0                 assume cs:_rdata$r
.rdata$r:000095A0                 ;org 95A0h
.rdata$r:000095A0 ; COMDAT (pick any)
.rdata$r:000095A0                 public ??_R2?$ctype@D@std@@8
.rdata$r:000095A0 ; std::ctype<char>::`RTTI Base Class Array'
.rdata$r:000095A0 ??_R2?$ctype@D@std@@8 dd offset ??_R1A@?0A@EA@?$ctype@D@std@@8
.rdata$r:000095A0                                         ; DATA XREF: .rdata$r:0000959Co
.rdata$r:000095A0                                         ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000095A4                 dd offset ??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000095A8                 dd offset ??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000095AC                 dd offset ??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000095B0                 db    0
.rdata$r:000095B1                 align 4
.rdata$r:000095B1 _rdata$r        ends
.rdata$r:000095B1
.rdata$r:000095B4 ; ===========================================================================
.rdata$r:000095B4
.rdata$r:000095B4 ; Segment type: Pure data
.rdata$r:000095B4 ; Segment permissions: Read
.rdata$r:000095B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000095B4                 assume cs:_rdata$r
.rdata$r:000095B4                 ;org 95B4h
.rdata$r:000095B4 ; COMDAT (pick any)
.rdata$r:000095B4                 public ??_R1A@?0A@EA@?$ctype@D@std@@8
.rdata$r:000095B4 ; std::ctype<char>::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000095B4 ??_R1A@?0A@EA@?$ctype@D@std@@8 dd offset ??_R0?AV?$ctype@D@std@@@8
.rdata$r:000095B4                                         ; DATA XREF: .rdata$r:std::ctype<char>::`RTTI Base Class Array'o
.rdata$r:000095B4                                         ; std::ctype<char> `RTTI Type Descriptor'
.rdata$r:000095B8                 db    3
.rdata$r:000095B9                 db    0
.rdata$r:000095BA                 db    0
.rdata$r:000095BB                 db    0
.rdata$r:000095BC                 db    0
.rdata$r:000095BD                 db    0
.rdata$r:000095BE                 db    0
.rdata$r:000095BF                 db    0
.rdata$r:000095C0                 db 0FFh
.rdata$r:000095C1                 db 0FFh
.rdata$r:000095C2                 db 0FFh
.rdata$r:000095C3                 db 0FFh
.rdata$r:000095C4                 db    0
.rdata$r:000095C5                 db    0
.rdata$r:000095C6                 db    0
.rdata$r:000095C7                 db    0
.rdata$r:000095C8                 db  40h ; @
.rdata$r:000095C9                 db    0
.rdata$r:000095CA                 db    0
.rdata$r:000095CB                 db    0
.rdata$r:000095CC                 dd offset ??_R3?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
.rdata$r:000095CC _rdata$r        ends
.rdata$r:000095CC
.rdata$r:000095D0 ; ===========================================================================
.rdata$r:000095D0
.rdata$r:000095D0 ; Segment type: Pure data
.rdata$r:000095D0 ; Segment permissions: Read
.rdata$r:000095D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000095D0                 assume cs:_rdata$r
.rdata$r:000095D0                 ;org 95D0h
.rdata$r:000095D0 ; COMDAT (pick any)
.rdata$r:000095D0                 public ??_R4error_category@std@@6B@
.rdata$r:000095D0 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000095D0 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00008E10o
.rdata$r:000095D1                 db    0
.rdata$r:000095D2                 db    0
.rdata$r:000095D3                 db    0
.rdata$r:000095D4                 db    0
.rdata$r:000095D5                 db    0
.rdata$r:000095D6                 db    0
.rdata$r:000095D7                 db    0
.rdata$r:000095D8                 db    0
.rdata$r:000095D9                 db    0
.rdata$r:000095DA                 db    0
.rdata$r:000095DB                 db    0
.rdata$r:000095DC                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000095E0                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000095E0 _rdata$r        ends
.rdata$r:000095E0
.data$r:000095E4 ; ===========================================================================
.data$r:000095E4
.data$r:000095E4 ; Segment type: Pure data
.data$r:000095E4 ; Segment permissions: Read/Write
.data$r:000095E4 _data$r         segment dword public 'DATA' use32
.data$r:000095E4                 assume cs:_data$r
.data$r:000095E4                 ;org 95E4h
.data$r:000095E4 ; COMDAT (pick any)
.data$r:000095E4                 public ??_R0?AVerror_category@std@@@8
.data$r:000095E4 ; class std::error_category `RTTI Type Descriptor'
.data$r:000095E4 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000095E4                                         ; DATA XREF: .rdata$r:000095DCo
.data$r:000095E4                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000095E4                                         ; const type_info::`vftable'
.data$r:000095E8                 db    0
.data$r:000095E9                 db    0
.data$r:000095EA                 db    0
.data$r:000095EB                 db    0
.data$r:000095EC                 db  2Eh ; .
.data$r:000095ED                 db  3Fh ; ?
.data$r:000095EE                 db  41h ; A
.data$r:000095EF                 db  56h ; V
.data$r:000095F0                 db  65h ; e
.data$r:000095F1                 db  72h ; r
.data$r:000095F2                 db  72h ; r
.data$r:000095F3                 db  6Fh ; o
.data$r:000095F4                 db  72h ; r
.data$r:000095F5                 db  5Fh ; _
.data$r:000095F6                 db  63h ; c
.data$r:000095F7                 db  61h ; a
.data$r:000095F8                 db  74h ; t
.data$r:000095F9                 db  65h ; e
.data$r:000095FA                 db  67h ; g
.data$r:000095FB                 db  6Fh ; o
.data$r:000095FC                 db  72h ; r
.data$r:000095FD                 db  79h ; y
.data$r:000095FE                 db  40h ; @
.data$r:000095FF                 db  73h ; s
.data$r:00009600                 db  74h ; t
.data$r:00009601                 db  64h ; d
.data$r:00009602                 db  40h ; @
.data$r:00009603                 db  40h ; @
.data$r:00009604                 db    0
.data$r:00009605                 align 4
.data$r:00009605 _data$r         ends
.data$r:00009605
.rdata$r:00009608 ; ===========================================================================
.rdata$r:00009608
.rdata$r:00009608 ; Segment type: Pure data
.rdata$r:00009608 ; Segment permissions: Read
.rdata$r:00009608 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009608                 assume cs:_rdata$r
.rdata$r:00009608                 ;org 9608h
.rdata$r:00009608 ; COMDAT (pick any)
.rdata$r:00009608                 public ??_R3error_category@std@@8
.rdata$r:00009608 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009608 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000095E0o
.rdata$r:00009608                                         ; .rdata$r:00009638o
.rdata$r:00009609                 db    0
.rdata$r:0000960A                 db    0
.rdata$r:0000960B                 db    0
.rdata$r:0000960C                 db    0
.rdata$r:0000960D                 db    0
.rdata$r:0000960E                 db    0
.rdata$r:0000960F                 db    0
.rdata$r:00009610                 db    1
.rdata$r:00009611                 db    0
.rdata$r:00009612                 db    0
.rdata$r:00009613                 db    0
.rdata$r:00009614                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00009614 _rdata$r        ends
.rdata$r:00009614
.rdata$r:00009618 ; ===========================================================================
.rdata$r:00009618
.rdata$r:00009618 ; Segment type: Pure data
.rdata$r:00009618 ; Segment permissions: Read
.rdata$r:00009618 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009618                 assume cs:_rdata$r
.rdata$r:00009618                 ;org 9618h
.rdata$r:00009618 ; COMDAT (pick any)
.rdata$r:00009618                 public ??_R2error_category@std@@8
.rdata$r:00009618 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00009618 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00009618                                         ; DATA XREF: .rdata$r:00009614o
.rdata$r:00009618                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000961C                 db    0
.rdata$r:0000961D                 align 10h
.rdata$r:0000961D _rdata$r        ends
.rdata$r:0000961D
.rdata$r:00009620 ; ===========================================================================
.rdata$r:00009620
.rdata$r:00009620 ; Segment type: Pure data
.rdata$r:00009620 ; Segment permissions: Read
.rdata$r:00009620 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009620                 assume cs:_rdata$r
.rdata$r:00009620                 ;org 9620h
.rdata$r:00009620 ; COMDAT (pick any)
.rdata$r:00009620                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00009620 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009620 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00009620                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00009620                                         ; .rdata$r:00009734o ...
.rdata$r:00009620                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00009624                 db    0
.rdata$r:00009625                 db    0
.rdata$r:00009626                 db    0
.rdata$r:00009627                 db    0
.rdata$r:00009628                 db    0
.rdata$r:00009629                 db    0
.rdata$r:0000962A                 db    0
.rdata$r:0000962B                 db    0
.rdata$r:0000962C                 db 0FFh
.rdata$r:0000962D                 db 0FFh
.rdata$r:0000962E                 db 0FFh
.rdata$r:0000962F                 db 0FFh
.rdata$r:00009630                 db    0
.rdata$r:00009631                 db    0
.rdata$r:00009632                 db    0
.rdata$r:00009633                 db    0
.rdata$r:00009634                 db  40h ; @
.rdata$r:00009635                 db    0
.rdata$r:00009636                 db    0
.rdata$r:00009637                 db    0
.rdata$r:00009638                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009638 _rdata$r        ends
.rdata$r:00009638
.rdata$r:0000963C ; ===========================================================================
.rdata$r:0000963C
.rdata$r:0000963C ; Segment type: Pure data
.rdata$r:0000963C ; Segment permissions: Read
.rdata$r:0000963C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000963C                 assume cs:_rdata$r
.rdata$r:0000963C                 ;org 963Ch
.rdata$r:0000963C ; COMDAT (pick any)
.rdata$r:0000963C                 public ??_R4_System_error@std@@6B@
.rdata$r:0000963C ; const std::_System_error::`RTTI Complete Object Locator'
.rdata$r:0000963C ??_R4_System_error@std@@6B@ db    0     ; DATA XREF: .rdata:00008E2Co
.rdata$r:0000963D                 db    0
.rdata$r:0000963E                 db    0
.rdata$r:0000963F                 db    0
.rdata$r:00009640                 db    0
.rdata$r:00009641                 db    0
.rdata$r:00009642                 db    0
.rdata$r:00009643                 db    0
.rdata$r:00009644                 db    0
.rdata$r:00009645                 db    0
.rdata$r:00009646                 db    0
.rdata$r:00009647                 db    0
.rdata$r:00009648                 dd offset ??_R0?AV_System_error@std@@@8 ; std::_System_error `RTTI Type Descriptor'
.rdata$r:0000964C                 dd offset ??_R3_System_error@std@@8 ; std::_System_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000964C _rdata$r        ends
.rdata$r:0000964C
.rdata$r:00009650 ; ===========================================================================
.rdata$r:00009650
.rdata$r:00009650 ; Segment type: Pure data
.rdata$r:00009650 ; Segment permissions: Read
.rdata$r:00009650 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009650                 assume cs:_rdata$r
.rdata$r:00009650                 ;org 9650h
.rdata$r:00009650 ; COMDAT (pick any)
.rdata$r:00009650                 public ??_R3_System_error@std@@8
.rdata$r:00009650 ; std::_System_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009650 ??_R3_System_error@std@@8 db    0       ; DATA XREF: .rdata$r:0000964Co
.rdata$r:00009650                                         ; .rdata$r:00009688o
.rdata$r:00009651                 db    0
.rdata$r:00009652                 db    0
.rdata$r:00009653                 db    0
.rdata$r:00009654                 db    0
.rdata$r:00009655                 db    0
.rdata$r:00009656                 db    0
.rdata$r:00009657                 db    0
.rdata$r:00009658                 db    3
.rdata$r:00009659                 db    0
.rdata$r:0000965A                 db    0
.rdata$r:0000965B                 db    0
.rdata$r:0000965C                 dd offset ??_R2_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
.rdata$r:0000965C _rdata$r        ends
.rdata$r:0000965C
.rdata$r:00009660 ; ===========================================================================
.rdata$r:00009660
.rdata$r:00009660 ; Segment type: Pure data
.rdata$r:00009660 ; Segment permissions: Read
.rdata$r:00009660 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009660                 assume cs:_rdata$r
.rdata$r:00009660                 ;org 9660h
.rdata$r:00009660 ; COMDAT (pick any)
.rdata$r:00009660                 public ??_R2_System_error@std@@8
.rdata$r:00009660 ; std::_System_error::`RTTI Base Class Array'
.rdata$r:00009660 ??_R2_System_error@std@@8 dd offset ??_R1A@?0A@EA@_System_error@std@@8
.rdata$r:00009660                                         ; DATA XREF: .rdata$r:0000965Co
.rdata$r:00009660                                         ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009664                 dd offset ??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009668                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000966C                 db    0
.rdata$r:0000966D                 align 10h
.rdata$r:0000966D _rdata$r        ends
.rdata$r:0000966D
.rdata$r:00009670 ; ===========================================================================
.rdata$r:00009670
.rdata$r:00009670 ; Segment type: Pure data
.rdata$r:00009670 ; Segment permissions: Read
.rdata$r:00009670 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009670                 assume cs:_rdata$r
.rdata$r:00009670                 ;org 9670h
.rdata$r:00009670 ; COMDAT (pick any)
.rdata$r:00009670                 public ??_R1A@?0A@EA@_System_error@std@@8
.rdata$r:00009670 ; std::_System_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009670 ??_R1A@?0A@EA@_System_error@std@@8 dd offset ??_R0?AV_System_error@std@@@8
.rdata$r:00009670                                         ; DATA XREF: .rdata$r:std::_System_error::`RTTI Base Class Array'o
.rdata$r:00009670                                         ; .rdata$r:000096B4o ...
.rdata$r:00009670                                         ; std::_System_error `RTTI Type Descriptor'
.rdata$r:00009674                 db    2
.rdata$r:00009675                 db    0
.rdata$r:00009676                 db    0
.rdata$r:00009677                 db    0
.rdata$r:00009678                 db    0
.rdata$r:00009679                 db    0
.rdata$r:0000967A                 db    0
.rdata$r:0000967B                 db    0
.rdata$r:0000967C                 db 0FFh
.rdata$r:0000967D                 db 0FFh
.rdata$r:0000967E                 db 0FFh
.rdata$r:0000967F                 db 0FFh
.rdata$r:00009680                 db    0
.rdata$r:00009681                 db    0
.rdata$r:00009682                 db    0
.rdata$r:00009683                 db    0
.rdata$r:00009684                 db  40h ; @
.rdata$r:00009685                 db    0
.rdata$r:00009686                 db    0
.rdata$r:00009687                 db    0
.rdata$r:00009688                 dd offset ??_R3_System_error@std@@8 ; std::_System_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009688 _rdata$r        ends
.rdata$r:00009688
.rdata$r:0000968C ; ===========================================================================
.rdata$r:0000968C
.rdata$r:0000968C ; Segment type: Pure data
.rdata$r:0000968C ; Segment permissions: Read
.rdata$r:0000968C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000968C                 assume cs:_rdata$r
.rdata$r:0000968C                 ;org 968Ch
.rdata$r:0000968C ; COMDAT (pick any)
.rdata$r:0000968C                 public ??_R4system_error@std@@6B@
.rdata$r:0000968C ; const std::system_error::`RTTI Complete Object Locator'
.rdata$r:0000968C ??_R4system_error@std@@6B@ db    0      ; DATA XREF: .rdata:00008E3Co
.rdata$r:0000968D                 db    0
.rdata$r:0000968E                 db    0
.rdata$r:0000968F                 db    0
.rdata$r:00009690                 db    0
.rdata$r:00009691                 db    0
.rdata$r:00009692                 db    0
.rdata$r:00009693                 db    0
.rdata$r:00009694                 db    0
.rdata$r:00009695                 db    0
.rdata$r:00009696                 db    0
.rdata$r:00009697                 db    0
.rdata$r:00009698                 dd offset ??_R0?AVsystem_error@std@@@8 ; std::system_error `RTTI Type Descriptor'
.rdata$r:0000969C                 dd offset ??_R3system_error@std@@8 ; std::system_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000969C _rdata$r        ends
.rdata$r:0000969C
.rdata$r:000096A0 ; ===========================================================================
.rdata$r:000096A0
.rdata$r:000096A0 ; Segment type: Pure data
.rdata$r:000096A0 ; Segment permissions: Read
.rdata$r:000096A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000096A0                 assume cs:_rdata$r
.rdata$r:000096A0                 ;org 96A0h
.rdata$r:000096A0 ; COMDAT (pick any)
.rdata$r:000096A0                 public ??_R3system_error@std@@8
.rdata$r:000096A0 ; std::system_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000096A0 ??_R3system_error@std@@8 db    0        ; DATA XREF: .rdata$r:0000969Co
.rdata$r:000096A0                                         ; .rdata$r:000096DCo
.rdata$r:000096A1                 db    0
.rdata$r:000096A2                 db    0
.rdata$r:000096A3                 db    0
.rdata$r:000096A4                 db    0
.rdata$r:000096A5                 db    0
.rdata$r:000096A6                 db    0
.rdata$r:000096A7                 db    0
.rdata$r:000096A8                 db    4
.rdata$r:000096A9                 db    0
.rdata$r:000096AA                 db    0
.rdata$r:000096AB                 db    0
.rdata$r:000096AC                 dd offset ??_R2system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
.rdata$r:000096AC _rdata$r        ends
.rdata$r:000096AC
.rdata$r:000096B0 ; ===========================================================================
.rdata$r:000096B0
.rdata$r:000096B0 ; Segment type: Pure data
.rdata$r:000096B0 ; Segment permissions: Read
.rdata$r:000096B0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000096B0                 assume cs:_rdata$r
.rdata$r:000096B0                 ;org 96B0h
.rdata$r:000096B0 ; COMDAT (pick any)
.rdata$r:000096B0                 public ??_R2system_error@std@@8
.rdata$r:000096B0 ; std::system_error::`RTTI Base Class Array'
.rdata$r:000096B0 ??_R2system_error@std@@8 dd offset ??_R1A@?0A@EA@system_error@std@@8
.rdata$r:000096B0                                         ; DATA XREF: .rdata$r:000096ACo
.rdata$r:000096B0                                         ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000096B4                 dd offset ??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000096B8                 dd offset ??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000096BC                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000096C0                 db    0
.rdata$r:000096C1                 align 4
.rdata$r:000096C1 _rdata$r        ends
.rdata$r:000096C1
.rdata$r:000096C4 ; ===========================================================================
.rdata$r:000096C4
.rdata$r:000096C4 ; Segment type: Pure data
.rdata$r:000096C4 ; Segment permissions: Read
.rdata$r:000096C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000096C4                 assume cs:_rdata$r
.rdata$r:000096C4                 ;org 96C4h
.rdata$r:000096C4 ; COMDAT (pick any)
.rdata$r:000096C4                 public ??_R1A@?0A@EA@system_error@std@@8
.rdata$r:000096C4 ; std::system_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000096C4 ??_R1A@?0A@EA@system_error@std@@8 dd offset ??_R0?AVsystem_error@std@@@8
.rdata$r:000096C4                                         ; DATA XREF: .rdata$r:std::system_error::`RTTI Base Class Array'o
.rdata$r:000096C4                                         ; .rdata$r:00009878o
.rdata$r:000096C4                                         ; std::system_error `RTTI Type Descriptor'
.rdata$r:000096C8                 db    3
.rdata$r:000096C9                 db    0
.rdata$r:000096CA                 db    0
.rdata$r:000096CB                 db    0
.rdata$r:000096CC                 db    0
.rdata$r:000096CD                 db    0
.rdata$r:000096CE                 db    0
.rdata$r:000096CF                 db    0
.rdata$r:000096D0                 db 0FFh
.rdata$r:000096D1                 db 0FFh
.rdata$r:000096D2                 db 0FFh
.rdata$r:000096D3                 db 0FFh
.rdata$r:000096D4                 db    0
.rdata$r:000096D5                 db    0
.rdata$r:000096D6                 db    0
.rdata$r:000096D7                 db    0
.rdata$r:000096D8                 db  40h ; @
.rdata$r:000096D9                 db    0
.rdata$r:000096DA                 db    0
.rdata$r:000096DB                 db    0
.rdata$r:000096DC                 dd offset ??_R3system_error@std@@8 ; std::system_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000096DC _rdata$r        ends
.rdata$r:000096DC
.rdata$r:000096E0 ; ===========================================================================
.rdata$r:000096E0
.rdata$r:000096E0 ; Segment type: Pure data
.rdata$r:000096E0 ; Segment permissions: Read
.rdata$r:000096E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000096E0                 assume cs:_rdata$r
.rdata$r:000096E0                 ;org 96E0h
.rdata$r:000096E0 ; COMDAT (pick any)
.rdata$r:000096E0                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:000096E0 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:000096E0 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:000096E0                                         ; DATA XREF: .rdata:00008E48o
.rdata$r:000096E1                 db    0
.rdata$r:000096E2                 db    0
.rdata$r:000096E3                 db    0
.rdata$r:000096E4                 db    0
.rdata$r:000096E5                 db    0
.rdata$r:000096E6                 db    0
.rdata$r:000096E7                 db    0
.rdata$r:000096E8                 db    0
.rdata$r:000096E9                 db    0
.rdata$r:000096EA                 db    0
.rdata$r:000096EB                 db    0
.rdata$r:000096EC                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000096F0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000096F0 _rdata$r        ends
.rdata$r:000096F0
.data$r:000096F4 ; ===========================================================================
.data$r:000096F4
.data$r:000096F4 ; Segment type: Pure data
.data$r:000096F4 ; Segment permissions: Read/Write
.data$r:000096F4 _data$r         segment dword public 'DATA' use32
.data$r:000096F4                 assume cs:_data$r
.data$r:000096F4                 ;org 96F4h
.data$r:000096F4 ; COMDAT (pick any)
.data$r:000096F4                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:000096F4 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:000096F4 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000096F4                                         ; DATA XREF: .rdata$r:000096ECo
.data$r:000096F4                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000096F4                                         ; const type_info::`vftable'
.data$r:000096F8                 db    0
.data$r:000096F9                 db    0
.data$r:000096FA                 db    0
.data$r:000096FB                 db    0
.data$r:000096FC                 db  2Eh ; .
.data$r:000096FD                 db  3Fh ; ?
.data$r:000096FE                 db  41h ; A
.data$r:000096FF                 db  56h ; V
.data$r:00009700                 db  5Fh ; _
.data$r:00009701                 db  47h ; G
.data$r:00009702                 db  65h ; e
.data$r:00009703                 db  6Eh ; n
.data$r:00009704                 db  65h ; e
.data$r:00009705                 db  72h ; r
.data$r:00009706                 db  69h ; i
.data$r:00009707                 db  63h ; c
.data$r:00009708                 db  5Fh ; _
.data$r:00009709                 db  65h ; e
.data$r:0000970A                 db  72h ; r
.data$r:0000970B                 db  72h ; r
.data$r:0000970C                 db  6Fh ; o
.data$r:0000970D                 db  72h ; r
.data$r:0000970E                 db  5Fh ; _
.data$r:0000970F                 db  63h ; c
.data$r:00009710                 db  61h ; a
.data$r:00009711                 db  74h ; t
.data$r:00009712                 db  65h ; e
.data$r:00009713                 db  67h ; g
.data$r:00009714                 db  6Fh ; o
.data$r:00009715                 db  72h ; r
.data$r:00009716                 db  79h ; y
.data$r:00009717                 db  40h ; @
.data$r:00009718                 db  73h ; s
.data$r:00009719                 db  74h ; t
.data$r:0000971A                 db  64h ; d
.data$r:0000971B                 db  40h ; @
.data$r:0000971C                 db  40h ; @
.data$r:0000971D                 db    0
.data$r:0000971E                 align 10h
.data$r:0000971E _data$r         ends
.data$r:0000971E
.rdata$r:00009720 ; ===========================================================================
.rdata$r:00009720
.rdata$r:00009720 ; Segment type: Pure data
.rdata$r:00009720 ; Segment permissions: Read
.rdata$r:00009720 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009720                 assume cs:_rdata$r
.rdata$r:00009720                 ;org 9720h
.rdata$r:00009720 ; COMDAT (pick any)
.rdata$r:00009720                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00009720 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009720 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00009720                                         ; DATA XREF: .rdata$r:000096F0o
.rdata$r:00009720                                         ; .rdata$r:00009754o
.rdata$r:00009721                 db    0
.rdata$r:00009722                 db    0
.rdata$r:00009723                 db    0
.rdata$r:00009724                 db    0
.rdata$r:00009725                 db    0
.rdata$r:00009726                 db    0
.rdata$r:00009727                 db    0
.rdata$r:00009728                 db    2
.rdata$r:00009729                 db    0
.rdata$r:0000972A                 db    0
.rdata$r:0000972B                 db    0
.rdata$r:0000972C                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000972C _rdata$r        ends
.rdata$r:0000972C
.rdata$r:00009730 ; ===========================================================================
.rdata$r:00009730
.rdata$r:00009730 ; Segment type: Pure data
.rdata$r:00009730 ; Segment permissions: Read
.rdata$r:00009730 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009730                 assume cs:_rdata$r
.rdata$r:00009730                 ;org 9730h
.rdata$r:00009730 ; COMDAT (pick any)
.rdata$r:00009730                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00009730 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00009730 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00009730                                         ; DATA XREF: .rdata$r:0000972Co
.rdata$r:00009730                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009734                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009738                 db    0
.rdata$r:00009739                 align 4
.rdata$r:00009739 _rdata$r        ends
.rdata$r:00009739
.rdata$r:0000973C ; ===========================================================================
.rdata$r:0000973C
.rdata$r:0000973C ; Segment type: Pure data
.rdata$r:0000973C ; Segment permissions: Read
.rdata$r:0000973C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000973C                 assume cs:_rdata$r
.rdata$r:0000973C                 ;org 973Ch
.rdata$r:0000973C ; COMDAT (pick any)
.rdata$r:0000973C                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000973C ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000973C ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000973C                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000973C                                         ; .rdata$r:000097ACo ...
.rdata$r:0000973C                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00009740                 db    1
.rdata$r:00009741                 db    0
.rdata$r:00009742                 db    0
.rdata$r:00009743                 db    0
.rdata$r:00009744                 db    0
.rdata$r:00009745                 db    0
.rdata$r:00009746                 db    0
.rdata$r:00009747                 db    0
.rdata$r:00009748                 db 0FFh
.rdata$r:00009749                 db 0FFh
.rdata$r:0000974A                 db 0FFh
.rdata$r:0000974B                 db 0FFh
.rdata$r:0000974C                 db    0
.rdata$r:0000974D                 db    0
.rdata$r:0000974E                 db    0
.rdata$r:0000974F                 db    0
.rdata$r:00009750                 db  40h ; @
.rdata$r:00009751                 db    0
.rdata$r:00009752                 db    0
.rdata$r:00009753                 db    0
.rdata$r:00009754                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009754 _rdata$r        ends
.rdata$r:00009754
.rdata$r:00009758 ; ===========================================================================
.rdata$r:00009758
.rdata$r:00009758 ; Segment type: Pure data
.rdata$r:00009758 ; Segment permissions: Read
.rdata$r:00009758 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009758                 assume cs:_rdata$r
.rdata$r:00009758                 ;org 9758h
.rdata$r:00009758 ; COMDAT (pick any)
.rdata$r:00009758                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00009758 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00009758 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00009758                                         ; DATA XREF: .rdata:00008E7Co
.rdata$r:00009759                 db    0
.rdata$r:0000975A                 db    0
.rdata$r:0000975B                 db    0
.rdata$r:0000975C                 db    0
.rdata$r:0000975D                 db    0
.rdata$r:0000975E                 db    0
.rdata$r:0000975F                 db    0
.rdata$r:00009760                 db    0
.rdata$r:00009761                 db    0
.rdata$r:00009762                 db    0
.rdata$r:00009763                 db    0
.rdata$r:00009764                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00009768                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009768 _rdata$r        ends
.rdata$r:00009768
.data$r:0000976C ; ===========================================================================
.data$r:0000976C
.data$r:0000976C ; Segment type: Pure data
.data$r:0000976C ; Segment permissions: Read/Write
.data$r:0000976C _data$r         segment dword public 'DATA' use32
.data$r:0000976C                 assume cs:_data$r
.data$r:0000976C                 ;org 976Ch
.data$r:0000976C ; COMDAT (pick any)
.data$r:0000976C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000976C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000976C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000976C                                         ; DATA XREF: .rdata$r:00009764o
.data$r:0000976C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000976C                                         ; const type_info::`vftable'
.data$r:00009770                 db    0
.data$r:00009771                 db    0
.data$r:00009772                 db    0
.data$r:00009773                 db    0
.data$r:00009774                 db  2Eh ; .
.data$r:00009775                 db  3Fh ; ?
.data$r:00009776                 db  41h ; A
.data$r:00009777                 db  56h ; V
.data$r:00009778                 db  5Fh ; _
.data$r:00009779                 db  49h ; I
.data$r:0000977A                 db  6Fh ; o
.data$r:0000977B                 db  73h ; s
.data$r:0000977C                 db  74h ; t
.data$r:0000977D                 db  72h ; r
.data$r:0000977E                 db  65h ; e
.data$r:0000977F                 db  61h ; a
.data$r:00009780                 db  6Dh ; m
.data$r:00009781                 db  5Fh ; _
.data$r:00009782                 db  65h ; e
.data$r:00009783                 db  72h ; r
.data$r:00009784                 db  72h ; r
.data$r:00009785                 db  6Fh ; o
.data$r:00009786                 db  72h ; r
.data$r:00009787                 db  5Fh ; _
.data$r:00009788                 db  63h ; c
.data$r:00009789                 db  61h ; a
.data$r:0000978A                 db  74h ; t
.data$r:0000978B                 db  65h ; e
.data$r:0000978C                 db  67h ; g
.data$r:0000978D                 db  6Fh ; o
.data$r:0000978E                 db  72h ; r
.data$r:0000978F                 db  79h ; y
.data$r:00009790                 db  40h ; @
.data$r:00009791                 db  73h ; s
.data$r:00009792                 db  74h ; t
.data$r:00009793                 db  64h ; d
.data$r:00009794                 db  40h ; @
.data$r:00009795                 db  40h ; @
.data$r:00009796                 db    0
.data$r:00009797                 align 4
.data$r:00009797 _data$r         ends
.data$r:00009797
.rdata$r:00009798 ; ===========================================================================
.rdata$r:00009798
.rdata$r:00009798 ; Segment type: Pure data
.rdata$r:00009798 ; Segment permissions: Read
.rdata$r:00009798 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009798                 assume cs:_rdata$r
.rdata$r:00009798                 ;org 9798h
.rdata$r:00009798 ; COMDAT (pick any)
.rdata$r:00009798                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00009798 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009798 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00009798                                         ; DATA XREF: .rdata$r:00009768o
.rdata$r:00009798                                         ; .rdata$r:000097D0o
.rdata$r:00009799                 db    0
.rdata$r:0000979A                 db    0
.rdata$r:0000979B                 db    0
.rdata$r:0000979C                 db    0
.rdata$r:0000979D                 db    0
.rdata$r:0000979E                 db    0
.rdata$r:0000979F                 db    0
.rdata$r:000097A0                 db    3
.rdata$r:000097A1                 db    0
.rdata$r:000097A2                 db    0
.rdata$r:000097A3                 db    0
.rdata$r:000097A4                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000097A4 _rdata$r        ends
.rdata$r:000097A4
.rdata$r:000097A8 ; ===========================================================================
.rdata$r:000097A8
.rdata$r:000097A8 ; Segment type: Pure data
.rdata$r:000097A8 ; Segment permissions: Read
.rdata$r:000097A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000097A8                 assume cs:_rdata$r
.rdata$r:000097A8                 ;org 97A8h
.rdata$r:000097A8 ; COMDAT (pick any)
.rdata$r:000097A8                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000097A8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000097A8 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000097A8                                         ; DATA XREF: .rdata$r:000097A4o
.rdata$r:000097A8                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000097AC                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000097B0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000097B4                 db    0
.rdata$r:000097B5                 align 4
.rdata$r:000097B5 _rdata$r        ends
.rdata$r:000097B5
.rdata$r:000097B8 ; ===========================================================================
.rdata$r:000097B8
.rdata$r:000097B8 ; Segment type: Pure data
.rdata$r:000097B8 ; Segment permissions: Read
.rdata$r:000097B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000097B8                 assume cs:_rdata$r
.rdata$r:000097B8                 ;org 97B8h
.rdata$r:000097B8 ; COMDAT (pick any)
.rdata$r:000097B8                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000097B8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000097B8 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:000097B8                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:000097B8                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000097BC                 db    2
.rdata$r:000097BD                 db    0
.rdata$r:000097BE                 db    0
.rdata$r:000097BF                 db    0
.rdata$r:000097C0                 db    0
.rdata$r:000097C1                 db    0
.rdata$r:000097C2                 db    0
.rdata$r:000097C3                 db    0
.rdata$r:000097C4                 db 0FFh
.rdata$r:000097C5                 db 0FFh
.rdata$r:000097C6                 db 0FFh
.rdata$r:000097C7                 db 0FFh
.rdata$r:000097C8                 db    0
.rdata$r:000097C9                 db    0
.rdata$r:000097CA                 db    0
.rdata$r:000097CB                 db    0
.rdata$r:000097CC                 db  40h ; @
.rdata$r:000097CD                 db    0
.rdata$r:000097CE                 db    0
.rdata$r:000097CF                 db    0
.rdata$r:000097D0                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000097D0 _rdata$r        ends
.rdata$r:000097D0
.rdata$r:000097D4 ; ===========================================================================
.rdata$r:000097D4
.rdata$r:000097D4 ; Segment type: Pure data
.rdata$r:000097D4 ; Segment permissions: Read
.rdata$r:000097D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000097D4                 assume cs:_rdata$r
.rdata$r:000097D4                 ;org 97D4h
.rdata$r:000097D4 ; COMDAT (pick any)
.rdata$r:000097D4                 public ??_R4_System_error_category@std@@6B@
.rdata$r:000097D4 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:000097D4 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00008EBCo
.rdata$r:000097D5                 db    0
.rdata$r:000097D6                 db    0
.rdata$r:000097D7                 db    0
.rdata$r:000097D8                 db    0
.rdata$r:000097D9                 db    0
.rdata$r:000097DA                 db    0
.rdata$r:000097DB                 db    0
.rdata$r:000097DC                 db    0
.rdata$r:000097DD                 db    0
.rdata$r:000097DE                 db    0
.rdata$r:000097DF                 db    0
.rdata$r:000097E0                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000097E4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000097E4 _rdata$r        ends
.rdata$r:000097E4
.data$r:000097E8 ; ===========================================================================
.data$r:000097E8
.data$r:000097E8 ; Segment type: Pure data
.data$r:000097E8 ; Segment permissions: Read/Write
.data$r:000097E8 _data$r         segment dword public 'DATA' use32
.data$r:000097E8                 assume cs:_data$r
.data$r:000097E8                 ;org 97E8h
.data$r:000097E8 ; COMDAT (pick any)
.data$r:000097E8                 public ??_R0?AV_System_error_category@std@@@8
.data$r:000097E8 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:000097E8 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000097E8                                         ; DATA XREF: .rdata$r:000097E0o
.data$r:000097E8                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000097E8                                         ; const type_info::`vftable'
.data$r:000097EC                 align 10h
.data$r:000097F0 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00009811                 align 4
.data$r:00009811 _data$r         ends
.data$r:00009811
.rdata$r:00009814 ; ===========================================================================
.rdata$r:00009814
.rdata$r:00009814 ; Segment type: Pure data
.rdata$r:00009814 ; Segment permissions: Read
.rdata$r:00009814 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009814                 assume cs:_rdata$r
.rdata$r:00009814                 ;org 9814h
.rdata$r:00009814 ; COMDAT (pick any)
.rdata$r:00009814                 public ??_R3_System_error_category@std@@8
.rdata$r:00009814 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009814 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:000097E4o
.rdata$r:00009814                                         ; .rdata$r:0000984Co
.rdata$r:00009815                 db    0
.rdata$r:00009816                 db    0
.rdata$r:00009817                 db    0
.rdata$r:00009818                 db    0
.rdata$r:00009819                 db    0
.rdata$r:0000981A                 db    0
.rdata$r:0000981B                 db    0
.rdata$r:0000981C                 db    3
.rdata$r:0000981D                 db    0
.rdata$r:0000981E                 db    0
.rdata$r:0000981F                 db    0
.rdata$r:00009820                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00009820 _rdata$r        ends
.rdata$r:00009820
.rdata$r:00009824 ; ===========================================================================
.rdata$r:00009824
.rdata$r:00009824 ; Segment type: Pure data
.rdata$r:00009824 ; Segment permissions: Read
.rdata$r:00009824 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009824                 assume cs:_rdata$r
.rdata$r:00009824                 ;org 9824h
.rdata$r:00009824 ; COMDAT (pick any)
.rdata$r:00009824                 public ??_R2_System_error_category@std@@8
.rdata$r:00009824 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00009824 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00009824                                         ; DATA XREF: .rdata$r:00009820o
.rdata$r:00009824                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009828                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000982C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009830                 db    0
.rdata$r:00009831                 align 4
.rdata$r:00009831 _rdata$r        ends
.rdata$r:00009831
.rdata$r:00009834 ; ===========================================================================
.rdata$r:00009834
.rdata$r:00009834 ; Segment type: Pure data
.rdata$r:00009834 ; Segment permissions: Read
.rdata$r:00009834 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009834                 assume cs:_rdata$r
.rdata$r:00009834                 ;org 9834h
.rdata$r:00009834 ; COMDAT (pick any)
.rdata$r:00009834                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00009834 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009834 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00009834                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00009834                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00009838                 db    2
.rdata$r:00009839                 db    0
.rdata$r:0000983A                 db    0
.rdata$r:0000983B                 db    0
.rdata$r:0000983C                 db    0
.rdata$r:0000983D                 db    0
.rdata$r:0000983E                 db    0
.rdata$r:0000983F                 db    0
.rdata$r:00009840                 db 0FFh
.rdata$r:00009841                 db 0FFh
.rdata$r:00009842                 db 0FFh
.rdata$r:00009843                 db 0FFh
.rdata$r:00009844                 db    0
.rdata$r:00009845                 db    0
.rdata$r:00009846                 db    0
.rdata$r:00009847                 db    0
.rdata$r:00009848                 db  40h ; @
.rdata$r:00009849                 db    0
.rdata$r:0000984A                 db    0
.rdata$r:0000984B                 db    0
.rdata$r:0000984C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000984C _rdata$r        ends
.rdata$r:0000984C
.rdata$r:00009850 ; ===========================================================================
.rdata$r:00009850
.rdata$r:00009850 ; Segment type: Pure data
.rdata$r:00009850 ; Segment permissions: Read
.rdata$r:00009850 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009850                 assume cs:_rdata$r
.rdata$r:00009850                 ;org 9850h
.rdata$r:00009850 ; COMDAT (pick any)
.rdata$r:00009850                 public ??_R4failure@ios_base@std@@6B@
.rdata$r:00009850 ; const std::ios_base::failure::`RTTI Complete Object Locator'
.rdata$r:00009850 ??_R4failure@ios_base@std@@6B@ db    0  ; DATA XREF: .rdata:00008EECo
.rdata$r:00009851                 db    0
.rdata$r:00009852                 db    0
.rdata$r:00009853                 db    0
.rdata$r:00009854                 db    0
.rdata$r:00009855                 db    0
.rdata$r:00009856                 db    0
.rdata$r:00009857                 db    0
.rdata$r:00009858                 db    0
.rdata$r:00009859                 db    0
.rdata$r:0000985A                 db    0
.rdata$r:0000985B                 db    0
.rdata$r:0000985C                 dd offset ??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure `RTTI Type Descriptor'
.rdata$r:00009860                 dd offset ??_R3failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009860 _rdata$r        ends
.rdata$r:00009860
.rdata$r:00009864 ; ===========================================================================
.rdata$r:00009864
.rdata$r:00009864 ; Segment type: Pure data
.rdata$r:00009864 ; Segment permissions: Read
.rdata$r:00009864 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009864                 assume cs:_rdata$r
.rdata$r:00009864                 ;org 9864h
.rdata$r:00009864 ; COMDAT (pick any)
.rdata$r:00009864                 public ??_R3failure@ios_base@std@@8
.rdata$r:00009864 ; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009864 ??_R3failure@ios_base@std@@8 db    0    ; DATA XREF: .rdata$r:00009860o
.rdata$r:00009864                                         ; .rdata$r:000098A4o
.rdata$r:00009865                 db    0
.rdata$r:00009866                 db    0
.rdata$r:00009867                 db    0
.rdata$r:00009868                 db    0
.rdata$r:00009869                 db    0
.rdata$r:0000986A                 db    0
.rdata$r:0000986B                 db    0
.rdata$r:0000986C                 db    5
.rdata$r:0000986D                 db    0
.rdata$r:0000986E                 db    0
.rdata$r:0000986F                 db    0
.rdata$r:00009870                 dd offset ??_R2failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
.rdata$r:00009870 _rdata$r        ends
.rdata$r:00009870
.rdata$r:00009874 ; ===========================================================================
.rdata$r:00009874
.rdata$r:00009874 ; Segment type: Pure data
.rdata$r:00009874 ; Segment permissions: Read
.rdata$r:00009874 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009874                 assume cs:_rdata$r
.rdata$r:00009874                 ;org 9874h
.rdata$r:00009874 ; COMDAT (pick any)
.rdata$r:00009874                 public ??_R2failure@ios_base@std@@8
.rdata$r:00009874 ; std::ios_base::failure::`RTTI Base Class Array'
.rdata$r:00009874 ??_R2failure@ios_base@std@@8 dd offset ??_R1A@?0A@EA@failure@ios_base@std@@8
.rdata$r:00009874                                         ; DATA XREF: .rdata$r:00009870o
.rdata$r:00009874                                         ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009878                 dd offset ??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000987C                 dd offset ??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009880                 dd offset ??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009884                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009888                 db    0
.rdata$r:00009889                 align 4
.rdata$r:00009889 _rdata$r        ends
.rdata$r:00009889
.rdata$r:0000988C ; ===========================================================================
.rdata$r:0000988C
.rdata$r:0000988C ; Segment type: Pure data
.rdata$r:0000988C ; Segment permissions: Read
.rdata$r:0000988C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000988C                 assume cs:_rdata$r
.rdata$r:0000988C                 ;org 988Ch
.rdata$r:0000988C ; COMDAT (pick any)
.rdata$r:0000988C                 public ??_R1A@?0A@EA@failure@ios_base@std@@8
.rdata$r:0000988C ; std::ios_base::failure::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000988C ??_R1A@?0A@EA@failure@ios_base@std@@8 dd offset ??_R0?AVfailure@ios_base@std@@@8
.rdata$r:0000988C                                         ; DATA XREF: .rdata$r:std::ios_base::failure::`RTTI Base Class Array'o
.rdata$r:0000988C                                         ; std::ios_base::failure `RTTI Type Descriptor'
.rdata$r:00009890                 db    4
.rdata$r:00009891                 db    0
.rdata$r:00009892                 db    0
.rdata$r:00009893                 db    0
.rdata$r:00009894                 db    0
.rdata$r:00009895                 db    0
.rdata$r:00009896                 db    0
.rdata$r:00009897                 db    0
.rdata$r:00009898                 db 0FFh
.rdata$r:00009899                 db 0FFh
.rdata$r:0000989A                 db 0FFh
.rdata$r:0000989B                 db 0FFh
.rdata$r:0000989C                 db    0
.rdata$r:0000989D                 db    0
.rdata$r:0000989E                 db    0
.rdata$r:0000989F                 db    0
.rdata$r:000098A0                 db  40h ; @
.rdata$r:000098A1                 db    0
.rdata$r:000098A2                 db    0
.rdata$r:000098A3                 db    0
.rdata$r:000098A4                 dd offset ??_R3failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
.rdata$r:000098A4 _rdata$r        ends
.rdata$r:000098A4
.rdata$r:000098A8 ; ===========================================================================
.rdata$r:000098A8
.rdata$r:000098A8 ; Segment type: Pure data
.rdata$r:000098A8 ; Segment permissions: Read
.rdata$r:000098A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000098A8                 assume cs:_rdata$r
.rdata$r:000098A8                 ;org 98A8h
.rdata$r:000098A8 ; COMDAT (pick any)
.rdata$r:000098A8                 public ??_R1A@?0A@EA@TiXmlNodeA@@8
.rdata$r:000098A8 ; TiXmlNodeA::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000098A8 ??_R1A@?0A@EA@TiXmlNodeA@@8 dd offset ??_R0?AVTiXmlNodeA@@@8
.rdata$r:000098A8                                         ; DATA XREF: .rdata$r:TiXmlNodeA::`RTTI Base Class Array'o
.rdata$r:000098A8                                         ; .rdata$r:00009990o ...
.rdata$r:000098A8                                         ; TiXmlNodeA `RTTI Type Descriptor'
.rdata$r:000098AC                 db    1
.rdata$r:000098AD                 db    0
.rdata$r:000098AE                 db    0
.rdata$r:000098AF                 db    0
.rdata$r:000098B0                 db    0
.rdata$r:000098B1                 db    0
.rdata$r:000098B2                 db    0
.rdata$r:000098B3                 db    0
.rdata$r:000098B4                 db 0FFh
.rdata$r:000098B5                 db 0FFh
.rdata$r:000098B6                 db 0FFh
.rdata$r:000098B7                 db 0FFh
.rdata$r:000098B8                 db    0
.rdata$r:000098B9                 db    0
.rdata$r:000098BA                 db    0
.rdata$r:000098BB                 db    0
.rdata$r:000098BC                 db  40h ; @
.rdata$r:000098BD                 db    0
.rdata$r:000098BE                 db    0
.rdata$r:000098BF                 db    0
.rdata$r:000098C0                 dd offset ??_R3TiXmlNodeA@@8 ; TiXmlNodeA::`RTTI Class Hierarchy Descriptor'
.rdata$r:000098C0 _rdata$r        ends
.rdata$r:000098C0
.data$r:000098C4 ; ===========================================================================
.data$r:000098C4
.data$r:000098C4 ; Segment type: Pure data
.data$r:000098C4 ; Segment permissions: Read/Write
.data$r:000098C4 _data$r         segment dword public 'DATA' use32
.data$r:000098C4                 assume cs:_data$r
.data$r:000098C4                 ;org 98C4h
.data$r:000098C4 ; COMDAT (pick any)
.data$r:000098C4                 public ??_R0?AVTiXmlNodeA@@@8
.data$r:000098C4 ; class TiXmlNodeA `RTTI Type Descriptor'
.data$r:000098C4 ??_R0?AVTiXmlNodeA@@@8 dd offset ??_7type_info@@6B@
.data$r:000098C4                                         ; DATA XREF: .rdata$r:TiXmlNodeA::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000098C4                                         ; const type_info::`vftable'
.data$r:000098C8                 db    0
.data$r:000098C9                 db    0
.data$r:000098CA                 db    0
.data$r:000098CB                 db    0
.data$r:000098CC                 db  2Eh ; .
.data$r:000098CD                 db  3Fh ; ?
.data$r:000098CE                 db  41h ; A
.data$r:000098CF                 db  56h ; V
.data$r:000098D0                 db  54h ; T
.data$r:000098D1                 db  69h ; i
.data$r:000098D2                 db  58h ; X
.data$r:000098D3                 db  6Dh ; m
.data$r:000098D4                 db  6Ch ; l
.data$r:000098D5                 db  4Eh ; N
.data$r:000098D6                 db  6Fh ; o
.data$r:000098D7                 db  64h ; d
.data$r:000098D8                 db  65h ; e
.data$r:000098D9                 db  41h ; A
.data$r:000098DA                 db  40h ; @
.data$r:000098DB                 db  40h ; @
.data$r:000098DC                 db    0
.data$r:000098DD                 align 10h
.data$r:000098DD _data$r         ends
.data$r:000098DD
.rdata$r:000098E0 ; ===========================================================================
.rdata$r:000098E0
.rdata$r:000098E0 ; Segment type: Pure data
.rdata$r:000098E0 ; Segment permissions: Read
.rdata$r:000098E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000098E0                 assume cs:_rdata$r
.rdata$r:000098E0                 ;org 98E0h
.rdata$r:000098E0 ; COMDAT (pick any)
.rdata$r:000098E0                 public ??_R3TiXmlNodeA@@8
.rdata$r:000098E0 ; TiXmlNodeA::`RTTI Class Hierarchy Descriptor'
.rdata$r:000098E0 ??_R3TiXmlNodeA@@8 db    0              ; DATA XREF: .rdata$r:000098C0o
.rdata$r:000098E1                 db    0
.rdata$r:000098E2                 db    0
.rdata$r:000098E3                 db    0
.rdata$r:000098E4                 db    0
.rdata$r:000098E5                 db    0
.rdata$r:000098E6                 db    0
.rdata$r:000098E7                 db    0
.rdata$r:000098E8                 db    2
.rdata$r:000098E9                 db    0
.rdata$r:000098EA                 db    0
.rdata$r:000098EB                 db    0
.rdata$r:000098EC                 dd offset ??_R2TiXmlNodeA@@8 ; TiXmlNodeA::`RTTI Base Class Array'
.rdata$r:000098EC _rdata$r        ends
.rdata$r:000098EC
.rdata$r:000098F0 ; ===========================================================================
.rdata$r:000098F0
.rdata$r:000098F0 ; Segment type: Pure data
.rdata$r:000098F0 ; Segment permissions: Read
.rdata$r:000098F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000098F0                 assume cs:_rdata$r
.rdata$r:000098F0                 ;org 98F0h
.rdata$r:000098F0 ; COMDAT (pick any)
.rdata$r:000098F0                 public ??_R2TiXmlNodeA@@8
.rdata$r:000098F0 ; TiXmlNodeA::`RTTI Base Class Array'
.rdata$r:000098F0 ??_R2TiXmlNodeA@@8 dd offset ??_R1A@?0A@EA@TiXmlNodeA@@8
.rdata$r:000098F0                                         ; DATA XREF: .rdata$r:000098ECo
.rdata$r:000098F0                                         ; TiXmlNodeA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000098F4                 dd offset ??_R1A@?0A@EA@TiXmlBaseA@@8 ; TiXmlBaseA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000098F8                 db    0
.rdata$r:000098F9                 align 4
.rdata$r:000098F9 _rdata$r        ends
.rdata$r:000098F9
.rdata$r:000098FC ; ===========================================================================
.rdata$r:000098FC
.rdata$r:000098FC ; Segment type: Pure data
.rdata$r:000098FC ; Segment permissions: Read
.rdata$r:000098FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000098FC                 assume cs:_rdata$r
.rdata$r:000098FC                 ;org 98FCh
.rdata$r:000098FC ; COMDAT (pick any)
.rdata$r:000098FC                 public ??_R1A@?0A@EA@TiXmlBaseA@@8
.rdata$r:000098FC ; TiXmlBaseA::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000098FC ??_R1A@?0A@EA@TiXmlBaseA@@8 dd offset ??_R0?AVTiXmlBaseA@@@8
.rdata$r:000098FC                                         ; DATA XREF: .rdata$r:000098F4o
.rdata$r:000098FC                                         ; .rdata$r:TiXmlBaseA::`RTTI Base Class Array'o ...
.rdata$r:000098FC                                         ; TiXmlBaseA `RTTI Type Descriptor'
.rdata$r:00009900                 db    0
.rdata$r:00009901                 db    0
.rdata$r:00009902                 db    0
.rdata$r:00009903                 db    0
.rdata$r:00009904                 db    0
.rdata$r:00009905                 db    0
.rdata$r:00009906                 db    0
.rdata$r:00009907                 db    0
.rdata$r:00009908                 db 0FFh
.rdata$r:00009909                 db 0FFh
.rdata$r:0000990A                 db 0FFh
.rdata$r:0000990B                 db 0FFh
.rdata$r:0000990C                 db    0
.rdata$r:0000990D                 db    0
.rdata$r:0000990E                 db    0
.rdata$r:0000990F                 db    0
.rdata$r:00009910                 db  40h ; @
.rdata$r:00009911                 db    0
.rdata$r:00009912                 db    0
.rdata$r:00009913                 db    0
.rdata$r:00009914                 dd offset ??_R3TiXmlBaseA@@8 ; TiXmlBaseA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009914 _rdata$r        ends
.rdata$r:00009914
.data$r:00009918 ; ===========================================================================
.data$r:00009918
.data$r:00009918 ; Segment type: Pure data
.data$r:00009918 ; Segment permissions: Read/Write
.data$r:00009918 _data$r         segment dword public 'DATA' use32
.data$r:00009918                 assume cs:_data$r
.data$r:00009918                 ;org 9918h
.data$r:00009918 ; COMDAT (pick any)
.data$r:00009918                 public ??_R0?AVTiXmlBaseA@@@8
.data$r:00009918 ; class TiXmlBaseA `RTTI Type Descriptor'
.data$r:00009918 ??_R0?AVTiXmlBaseA@@@8 dd offset ??_7type_info@@6B@
.data$r:00009918                                         ; DATA XREF: .rdata$r:TiXmlBaseA::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009918                                         ; .rdata$r:00009B78o
.data$r:00009918                                         ; const type_info::`vftable'
.data$r:0000991C                 align 10h
.data$r:00009920 a_?avtixmlbasea db '.?AVTiXmlBaseA@@',0
.data$r:00009931                 align 4
.data$r:00009931 _data$r         ends
.data$r:00009931
.rdata$r:00009934 ; ===========================================================================
.rdata$r:00009934
.rdata$r:00009934 ; Segment type: Pure data
.rdata$r:00009934 ; Segment permissions: Read
.rdata$r:00009934 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009934                 assume cs:_rdata$r
.rdata$r:00009934                 ;org 9934h
.rdata$r:00009934 ; COMDAT (pick any)
.rdata$r:00009934                 public ??_R3TiXmlBaseA@@8
.rdata$r:00009934 ; TiXmlBaseA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009934 ??_R3TiXmlBaseA@@8 db    0              ; DATA XREF: .rdata$r:00009914o
.rdata$r:00009934                                         ; .rdata$r:00009B7Co
.rdata$r:00009935                 db    0
.rdata$r:00009936                 db    0
.rdata$r:00009937                 db    0
.rdata$r:00009938                 db    0
.rdata$r:00009939                 db    0
.rdata$r:0000993A                 db    0
.rdata$r:0000993B                 db    0
.rdata$r:0000993C                 db    1
.rdata$r:0000993D                 db    0
.rdata$r:0000993E                 db    0
.rdata$r:0000993F                 db    0
.rdata$r:00009940                 dd offset ??_R2TiXmlBaseA@@8 ; TiXmlBaseA::`RTTI Base Class Array'
.rdata$r:00009940 _rdata$r        ends
.rdata$r:00009940
.rdata$r:00009944 ; ===========================================================================
.rdata$r:00009944
.rdata$r:00009944 ; Segment type: Pure data
.rdata$r:00009944 ; Segment permissions: Read
.rdata$r:00009944 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009944                 assume cs:_rdata$r
.rdata$r:00009944                 ;org 9944h
.rdata$r:00009944 ; COMDAT (pick any)
.rdata$r:00009944                 public ??_R2TiXmlBaseA@@8
.rdata$r:00009944 ; TiXmlBaseA::`RTTI Base Class Array'
.rdata$r:00009944 ??_R2TiXmlBaseA@@8 dd offset ??_R1A@?0A@EA@TiXmlBaseA@@8
.rdata$r:00009944                                         ; DATA XREF: .rdata$r:00009940o
.rdata$r:00009944                                         ; TiXmlBaseA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009948                 db    0
.rdata$r:00009949                 align 4
.rdata$r:00009949 _rdata$r        ends
.rdata$r:00009949
.rdata$r:0000994C ; ===========================================================================
.rdata$r:0000994C
.rdata$r:0000994C ; Segment type: Pure data
.rdata$r:0000994C ; Segment permissions: Read
.rdata$r:0000994C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000994C                 assume cs:_rdata$r
.rdata$r:0000994C                 ;org 994Ch
.rdata$r:0000994C ; COMDAT (pick any)
.rdata$r:0000994C                 public ??_R4TiXmlCommentA@@6B@
.rdata$r:0000994C ; const TiXmlCommentA::`RTTI Complete Object Locator'
.rdata$r:0000994C ??_R4TiXmlCommentA@@6B@ db    0         ; DATA XREF: .rdata:000090FCo
.rdata$r:0000994D                 db    0
.rdata$r:0000994E                 db    0
.rdata$r:0000994F                 db    0
.rdata$r:00009950                 db    0
.rdata$r:00009951                 db    0
.rdata$r:00009952                 db    0
.rdata$r:00009953                 db    0
.rdata$r:00009954                 db    0
.rdata$r:00009955                 db    0
.rdata$r:00009956                 db    0
.rdata$r:00009957                 db    0
.rdata$r:00009958                 dd offset ??_R0?AVTiXmlCommentA@@@8 ; TiXmlCommentA `RTTI Type Descriptor'
.rdata$r:0000995C                 dd offset ??_R3TiXmlCommentA@@8 ; TiXmlCommentA::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000995C _rdata$r        ends
.rdata$r:0000995C
.data$r:00009960 ; ===========================================================================
.data$r:00009960
.data$r:00009960 ; Segment type: Pure data
.data$r:00009960 ; Segment permissions: Read/Write
.data$r:00009960 _data$r         segment dword public 'DATA' use32
.data$r:00009960                 assume cs:_data$r
.data$r:00009960                 ;org 9960h
.data$r:00009960 ; COMDAT (pick any)
.data$r:00009960                 public ??_R0?AVTiXmlCommentA@@@8
.data$r:00009960 ; class TiXmlCommentA `RTTI Type Descriptor'
.data$r:00009960 ??_R0?AVTiXmlCommentA@@@8 dd offset ??_7type_info@@6B@
.data$r:00009960                                         ; DATA XREF: .rdata$r:00009958o
.data$r:00009960                                         ; .rdata$r:TiXmlCommentA::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009960                                         ; const type_info::`vftable'
.data$r:00009964                 align 8
.data$r:00009968 a_?avtixmlcomme db '.?AVTiXmlCommentA@@',0
.data$r:00009968 _data$r         ends
.data$r:00009968
.rdata$r:0000997C ; ===========================================================================
.rdata$r:0000997C
.rdata$r:0000997C ; Segment type: Pure data
.rdata$r:0000997C ; Segment permissions: Read
.rdata$r:0000997C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000997C                 assume cs:_rdata$r
.rdata$r:0000997C                 ;org 997Ch
.rdata$r:0000997C ; COMDAT (pick any)
.rdata$r:0000997C                 public ??_R3TiXmlCommentA@@8
.rdata$r:0000997C ; TiXmlCommentA::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000997C ??_R3TiXmlCommentA@@8 db    0           ; DATA XREF: .rdata$r:0000995Co
.rdata$r:0000997C                                         ; .rdata$r:000099B4o
.rdata$r:0000997D                 db    0
.rdata$r:0000997E                 db    0
.rdata$r:0000997F                 db    0
.rdata$r:00009980                 db    0
.rdata$r:00009981                 db    0
.rdata$r:00009982                 db    0
.rdata$r:00009983                 db    0
.rdata$r:00009984                 db    3
.rdata$r:00009985                 db    0
.rdata$r:00009986                 db    0
.rdata$r:00009987                 db    0
.rdata$r:00009988                 dd offset ??_R2TiXmlCommentA@@8 ; TiXmlCommentA::`RTTI Base Class Array'
.rdata$r:00009988 _rdata$r        ends
.rdata$r:00009988
.rdata$r:0000998C ; ===========================================================================
.rdata$r:0000998C
.rdata$r:0000998C ; Segment type: Pure data
.rdata$r:0000998C ; Segment permissions: Read
.rdata$r:0000998C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000998C                 assume cs:_rdata$r
.rdata$r:0000998C                 ;org 998Ch
.rdata$r:0000998C ; COMDAT (pick any)
.rdata$r:0000998C                 public ??_R2TiXmlCommentA@@8
.rdata$r:0000998C ; TiXmlCommentA::`RTTI Base Class Array'
.rdata$r:0000998C ??_R2TiXmlCommentA@@8 dd offset ??_R1A@?0A@EA@TiXmlCommentA@@8
.rdata$r:0000998C                                         ; DATA XREF: .rdata$r:00009988o
.rdata$r:0000998C                                         ; TiXmlCommentA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009990                 dd offset ??_R1A@?0A@EA@TiXmlNodeA@@8 ; TiXmlNodeA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009994                 dd offset ??_R1A@?0A@EA@TiXmlBaseA@@8 ; TiXmlBaseA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009998                 db    0
.rdata$r:00009999                 align 4
.rdata$r:00009999 _rdata$r        ends
.rdata$r:00009999
.rdata$r:0000999C ; ===========================================================================
.rdata$r:0000999C
.rdata$r:0000999C ; Segment type: Pure data
.rdata$r:0000999C ; Segment permissions: Read
.rdata$r:0000999C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000999C                 assume cs:_rdata$r
.rdata$r:0000999C                 ;org 999Ch
.rdata$r:0000999C ; COMDAT (pick any)
.rdata$r:0000999C                 public ??_R1A@?0A@EA@TiXmlCommentA@@8
.rdata$r:0000999C ; TiXmlCommentA::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000999C ??_R1A@?0A@EA@TiXmlCommentA@@8 dd offset ??_R0?AVTiXmlCommentA@@@8
.rdata$r:0000999C                                         ; DATA XREF: .rdata$r:TiXmlCommentA::`RTTI Base Class Array'o
.rdata$r:0000999C                                         ; TiXmlCommentA `RTTI Type Descriptor'
.rdata$r:000099A0                 db    2
.rdata$r:000099A1                 db    0
.rdata$r:000099A2                 db    0
.rdata$r:000099A3                 db    0
.rdata$r:000099A4                 db    0
.rdata$r:000099A5                 db    0
.rdata$r:000099A6                 db    0
.rdata$r:000099A7                 db    0
.rdata$r:000099A8                 db 0FFh
.rdata$r:000099A9                 db 0FFh
.rdata$r:000099AA                 db 0FFh
.rdata$r:000099AB                 db 0FFh
.rdata$r:000099AC                 db    0
.rdata$r:000099AD                 db    0
.rdata$r:000099AE                 db    0
.rdata$r:000099AF                 db    0
.rdata$r:000099B0                 db  40h ; @
.rdata$r:000099B1                 db    0
.rdata$r:000099B2                 db    0
.rdata$r:000099B3                 db    0
.rdata$r:000099B4                 dd offset ??_R3TiXmlCommentA@@8 ; TiXmlCommentA::`RTTI Class Hierarchy Descriptor'
.rdata$r:000099B4 _rdata$r        ends
.rdata$r:000099B4
.rdata$r:000099B8 ; ===========================================================================
.rdata$r:000099B8
.rdata$r:000099B8 ; Segment type: Pure data
.rdata$r:000099B8 ; Segment permissions: Read
.rdata$r:000099B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000099B8                 assume cs:_rdata$r
.rdata$r:000099B8                 ;org 99B8h
.rdata$r:000099B8 ; COMDAT (pick any)
.rdata$r:000099B8                 public ??_R4TiXmlUnknownA@@6B@
.rdata$r:000099B8 ; const TiXmlUnknownA::`RTTI Complete Object Locator'
.rdata$r:000099B8 ??_R4TiXmlUnknownA@@6B@ db    0         ; DATA XREF: .rdata:0000915Co
.rdata$r:000099B9                 db    0
.rdata$r:000099BA                 db    0
.rdata$r:000099BB                 db    0
.rdata$r:000099BC                 db    0
.rdata$r:000099BD                 db    0
.rdata$r:000099BE                 db    0
.rdata$r:000099BF                 db    0
.rdata$r:000099C0                 db    0
.rdata$r:000099C1                 db    0
.rdata$r:000099C2                 db    0
.rdata$r:000099C3                 db    0
.rdata$r:000099C4                 dd offset ??_R0?AVTiXmlUnknownA@@@8 ; TiXmlUnknownA `RTTI Type Descriptor'
.rdata$r:000099C8                 dd offset ??_R3TiXmlUnknownA@@8 ; TiXmlUnknownA::`RTTI Class Hierarchy Descriptor'
.rdata$r:000099C8 _rdata$r        ends
.rdata$r:000099C8
.data$r:000099CC ; ===========================================================================
.data$r:000099CC
.data$r:000099CC ; Segment type: Pure data
.data$r:000099CC ; Segment permissions: Read/Write
.data$r:000099CC _data$r         segment dword public 'DATA' use32
.data$r:000099CC                 assume cs:_data$r
.data$r:000099CC                 ;org 99CCh
.data$r:000099CC ; COMDAT (pick any)
.data$r:000099CC                 public ??_R0?AVTiXmlUnknownA@@@8
.data$r:000099CC ; class TiXmlUnknownA `RTTI Type Descriptor'
.data$r:000099CC ??_R0?AVTiXmlUnknownA@@@8 dd offset ??_7type_info@@6B@
.data$r:000099CC                                         ; DATA XREF: .rdata$r:000099C4o
.data$r:000099CC                                         ; .rdata$r:TiXmlUnknownA::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000099CC                                         ; const type_info::`vftable'
.data$r:000099D0                 db    0
.data$r:000099D1                 db    0
.data$r:000099D2                 db    0
.data$r:000099D3                 db    0
.data$r:000099D4                 db  2Eh ; .
.data$r:000099D5                 db  3Fh ; ?
.data$r:000099D6                 db  41h ; A
.data$r:000099D7                 db  56h ; V
.data$r:000099D8                 db  54h ; T
.data$r:000099D9                 db  69h ; i
.data$r:000099DA                 db  58h ; X
.data$r:000099DB                 db  6Dh ; m
.data$r:000099DC                 db  6Ch ; l
.data$r:000099DD                 db  55h ; U
.data$r:000099DE                 db  6Eh ; n
.data$r:000099DF                 db  6Bh ; k
.data$r:000099E0                 db  6Eh ; n
.data$r:000099E1                 db  6Fh ; o
.data$r:000099E2                 db  77h ; w
.data$r:000099E3                 db  6Eh ; n
.data$r:000099E4                 db  41h ; A
.data$r:000099E5                 db  40h ; @
.data$r:000099E6                 db  40h ; @
.data$r:000099E7                 db    0
.data$r:000099E7 _data$r         ends
.data$r:000099E7
.rdata$r:000099E8 ; ===========================================================================
.rdata$r:000099E8
.rdata$r:000099E8 ; Segment type: Pure data
.rdata$r:000099E8 ; Segment permissions: Read
.rdata$r:000099E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000099E8                 assume cs:_rdata$r
.rdata$r:000099E8                 ;org 99E8h
.rdata$r:000099E8 ; COMDAT (pick any)
.rdata$r:000099E8                 public ??_R3TiXmlUnknownA@@8
.rdata$r:000099E8 ; TiXmlUnknownA::`RTTI Class Hierarchy Descriptor'
.rdata$r:000099E8 ??_R3TiXmlUnknownA@@8 db    0           ; DATA XREF: .rdata$r:000099C8o
.rdata$r:000099E8                                         ; .rdata$r:00009A20o
.rdata$r:000099E9                 db    0
.rdata$r:000099EA                 db    0
.rdata$r:000099EB                 db    0
.rdata$r:000099EC                 db    0
.rdata$r:000099ED                 db    0
.rdata$r:000099EE                 db    0
.rdata$r:000099EF                 db    0
.rdata$r:000099F0                 db    3
.rdata$r:000099F1                 db    0
.rdata$r:000099F2                 db    0
.rdata$r:000099F3                 db    0
.rdata$r:000099F4                 dd offset ??_R2TiXmlUnknownA@@8 ; TiXmlUnknownA::`RTTI Base Class Array'
.rdata$r:000099F4 _rdata$r        ends
.rdata$r:000099F4
.rdata$r:000099F8 ; ===========================================================================
.rdata$r:000099F8
.rdata$r:000099F8 ; Segment type: Pure data
.rdata$r:000099F8 ; Segment permissions: Read
.rdata$r:000099F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000099F8                 assume cs:_rdata$r
.rdata$r:000099F8                 ;org 99F8h
.rdata$r:000099F8 ; COMDAT (pick any)
.rdata$r:000099F8                 public ??_R2TiXmlUnknownA@@8
.rdata$r:000099F8 ; TiXmlUnknownA::`RTTI Base Class Array'
.rdata$r:000099F8 ??_R2TiXmlUnknownA@@8 dd offset ??_R1A@?0A@EA@TiXmlUnknownA@@8
.rdata$r:000099F8                                         ; DATA XREF: .rdata$r:000099F4o
.rdata$r:000099F8                                         ; TiXmlUnknownA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000099FC                 dd offset ??_R1A@?0A@EA@TiXmlNodeA@@8 ; TiXmlNodeA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009A00                 dd offset ??_R1A@?0A@EA@TiXmlBaseA@@8 ; TiXmlBaseA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009A04                 db    0
.rdata$r:00009A05                 align 4
.rdata$r:00009A05 _rdata$r        ends
.rdata$r:00009A05
.rdata$r:00009A08 ; ===========================================================================
.rdata$r:00009A08
.rdata$r:00009A08 ; Segment type: Pure data
.rdata$r:00009A08 ; Segment permissions: Read
.rdata$r:00009A08 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009A08                 assume cs:_rdata$r
.rdata$r:00009A08                 ;org 9A08h
.rdata$r:00009A08 ; COMDAT (pick any)
.rdata$r:00009A08                 public ??_R1A@?0A@EA@TiXmlUnknownA@@8
.rdata$r:00009A08 ; TiXmlUnknownA::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009A08 ??_R1A@?0A@EA@TiXmlUnknownA@@8 dd offset ??_R0?AVTiXmlUnknownA@@@8
.rdata$r:00009A08                                         ; DATA XREF: .rdata$r:TiXmlUnknownA::`RTTI Base Class Array'o
.rdata$r:00009A08                                         ; TiXmlUnknownA `RTTI Type Descriptor'
.rdata$r:00009A0C                 db    2
.rdata$r:00009A0D                 db    0
.rdata$r:00009A0E                 db    0
.rdata$r:00009A0F                 db    0
.rdata$r:00009A10                 db    0
.rdata$r:00009A11                 db    0
.rdata$r:00009A12                 db    0
.rdata$r:00009A13                 db    0
.rdata$r:00009A14                 db 0FFh
.rdata$r:00009A15                 db 0FFh
.rdata$r:00009A16                 db 0FFh
.rdata$r:00009A17                 db 0FFh
.rdata$r:00009A18                 db    0
.rdata$r:00009A19                 db    0
.rdata$r:00009A1A                 db    0
.rdata$r:00009A1B                 db    0
.rdata$r:00009A1C                 db  40h ; @
.rdata$r:00009A1D                 db    0
.rdata$r:00009A1E                 db    0
.rdata$r:00009A1F                 db    0
.rdata$r:00009A20                 dd offset ??_R3TiXmlUnknownA@@8 ; TiXmlUnknownA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009A20 _rdata$r        ends
.rdata$r:00009A20
.rdata$r:00009A24 ; ===========================================================================
.rdata$r:00009A24
.rdata$r:00009A24 ; Segment type: Pure data
.rdata$r:00009A24 ; Segment permissions: Read
.rdata$r:00009A24 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009A24                 assume cs:_rdata$r
.rdata$r:00009A24                 ;org 9A24h
.rdata$r:00009A24 ; COMDAT (pick any)
.rdata$r:00009A24                 public ??_R4TiXmlAttributeA@@6B@
.rdata$r:00009A24 ; const TiXmlAttributeA::`RTTI Complete Object Locator'
.rdata$r:00009A24 ??_R4TiXmlAttributeA@@6B@ db    0       ; DATA XREF: .rdata:000090E8o
.rdata$r:00009A25                 db    0
.rdata$r:00009A26                 db    0
.rdata$r:00009A27                 db    0
.rdata$r:00009A28                 db    0
.rdata$r:00009A29                 db    0
.rdata$r:00009A2A                 db    0
.rdata$r:00009A2B                 db    0
.rdata$r:00009A2C                 db    0
.rdata$r:00009A2D                 db    0
.rdata$r:00009A2E                 db    0
.rdata$r:00009A2F                 db    0
.rdata$r:00009A30                 dd offset ??_R0?AVTiXmlAttributeA@@@8 ; TiXmlAttributeA `RTTI Type Descriptor'
.rdata$r:00009A34                 dd offset ??_R3TiXmlAttributeA@@8 ; TiXmlAttributeA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009A34 _rdata$r        ends
.rdata$r:00009A34
.data$r:00009A38 ; ===========================================================================
.data$r:00009A38
.data$r:00009A38 ; Segment type: Pure data
.data$r:00009A38 ; Segment permissions: Read/Write
.data$r:00009A38 _data$r         segment dword public 'DATA' use32
.data$r:00009A38                 assume cs:_data$r
.data$r:00009A38                 ;org 9A38h
.data$r:00009A38 ; COMDAT (pick any)
.data$r:00009A38                 public ??_R0?AVTiXmlAttributeA@@@8
.data$r:00009A38 ; class TiXmlAttributeA `RTTI Type Descriptor'
.data$r:00009A38 ??_R0?AVTiXmlAttributeA@@@8 dd offset ??_7type_info@@6B@
.data$r:00009A38                                         ; DATA XREF: .rdata$r:00009A30o
.data$r:00009A38                                         ; .rdata$r:TiXmlAttributeA::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009A38                                         ; const type_info::`vftable'
.data$r:00009A3C                 align 10h
.data$r:00009A40 a_?avtixmlattri db '.?AVTiXmlAttributeA@@',0
.data$r:00009A56                 align 4
.data$r:00009A56 _data$r         ends
.data$r:00009A56
.rdata$r:00009A58 ; ===========================================================================
.rdata$r:00009A58
.rdata$r:00009A58 ; Segment type: Pure data
.rdata$r:00009A58 ; Segment permissions: Read
.rdata$r:00009A58 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009A58                 assume cs:_rdata$r
.rdata$r:00009A58                 ;org 9A58h
.rdata$r:00009A58 ; COMDAT (pick any)
.rdata$r:00009A58                 public ??_R3TiXmlAttributeA@@8
.rdata$r:00009A58 ; TiXmlAttributeA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009A58 ??_R3TiXmlAttributeA@@8 db    0         ; DATA XREF: .rdata$r:00009A34o
.rdata$r:00009A58                                         ; .rdata$r:00009A8Co
.rdata$r:00009A59                 db    0
.rdata$r:00009A5A                 db    0
.rdata$r:00009A5B                 db    0
.rdata$r:00009A5C                 db    0
.rdata$r:00009A5D                 db    0
.rdata$r:00009A5E                 db    0
.rdata$r:00009A5F                 db    0
.rdata$r:00009A60                 db    2
.rdata$r:00009A61                 db    0
.rdata$r:00009A62                 db    0
.rdata$r:00009A63                 db    0
.rdata$r:00009A64                 dd offset ??_R2TiXmlAttributeA@@8 ; TiXmlAttributeA::`RTTI Base Class Array'
.rdata$r:00009A64 _rdata$r        ends
.rdata$r:00009A64
.rdata$r:00009A68 ; ===========================================================================
.rdata$r:00009A68
.rdata$r:00009A68 ; Segment type: Pure data
.rdata$r:00009A68 ; Segment permissions: Read
.rdata$r:00009A68 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009A68                 assume cs:_rdata$r
.rdata$r:00009A68                 ;org 9A68h
.rdata$r:00009A68 ; COMDAT (pick any)
.rdata$r:00009A68                 public ??_R2TiXmlAttributeA@@8
.rdata$r:00009A68 ; TiXmlAttributeA::`RTTI Base Class Array'
.rdata$r:00009A68 ??_R2TiXmlAttributeA@@8 dd offset ??_R1A@?0A@EA@TiXmlAttributeA@@8
.rdata$r:00009A68                                         ; DATA XREF: .rdata$r:00009A64o
.rdata$r:00009A68                                         ; TiXmlAttributeA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009A6C                 dd offset ??_R1A@?0A@EA@TiXmlBaseA@@8 ; TiXmlBaseA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009A70                 db    0
.rdata$r:00009A71                 align 4
.rdata$r:00009A71 _rdata$r        ends
.rdata$r:00009A71
.rdata$r:00009A74 ; ===========================================================================
.rdata$r:00009A74
.rdata$r:00009A74 ; Segment type: Pure data
.rdata$r:00009A74 ; Segment permissions: Read
.rdata$r:00009A74 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009A74                 assume cs:_rdata$r
.rdata$r:00009A74                 ;org 9A74h
.rdata$r:00009A74 ; COMDAT (pick any)
.rdata$r:00009A74                 public ??_R1A@?0A@EA@TiXmlAttributeA@@8
.rdata$r:00009A74 ; TiXmlAttributeA::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009A74 ??_R1A@?0A@EA@TiXmlAttributeA@@8 dd offset ??_R0?AVTiXmlAttributeA@@@8
.rdata$r:00009A74                                         ; DATA XREF: .rdata$r:TiXmlAttributeA::`RTTI Base Class Array'o
.rdata$r:00009A74                                         ; TiXmlAttributeA `RTTI Type Descriptor'
.rdata$r:00009A78                 db    1
.rdata$r:00009A79                 db    0
.rdata$r:00009A7A                 db    0
.rdata$r:00009A7B                 db    0
.rdata$r:00009A7C                 db    0
.rdata$r:00009A7D                 db    0
.rdata$r:00009A7E                 db    0
.rdata$r:00009A7F                 db    0
.rdata$r:00009A80                 db 0FFh
.rdata$r:00009A81                 db 0FFh
.rdata$r:00009A82                 db 0FFh
.rdata$r:00009A83                 db 0FFh
.rdata$r:00009A84                 db    0
.rdata$r:00009A85                 db    0
.rdata$r:00009A86                 db    0
.rdata$r:00009A87                 db    0
.rdata$r:00009A88                 db  40h ; @
.rdata$r:00009A89                 db    0
.rdata$r:00009A8A                 db    0
.rdata$r:00009A8B                 db    0
.rdata$r:00009A8C                 dd offset ??_R3TiXmlAttributeA@@8 ; TiXmlAttributeA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009A8C _rdata$r        ends
.rdata$r:00009A8C
.rdata$r:00009A90 ; ===========================================================================
.rdata$r:00009A90
.rdata$r:00009A90 ; Segment type: Pure data
.rdata$r:00009A90 ; Segment permissions: Read
.rdata$r:00009A90 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009A90                 assume cs:_rdata$r
.rdata$r:00009A90                 ;org 9A90h
.rdata$r:00009A90 ; COMDAT (pick any)
.rdata$r:00009A90                 public ??_R4TiXmlTextA@@6B@
.rdata$r:00009A90 ; const TiXmlTextA::`RTTI Complete Object Locator'
.rdata$r:00009A90 ??_R4TiXmlTextA@@6B@ db    0            ; DATA XREF: .rdata:0000911Co
.rdata$r:00009A91                 db    0
.rdata$r:00009A92                 db    0
.rdata$r:00009A93                 db    0
.rdata$r:00009A94                 db    0
.rdata$r:00009A95                 db    0
.rdata$r:00009A96                 db    0
.rdata$r:00009A97                 db    0
.rdata$r:00009A98                 db    0
.rdata$r:00009A99                 db    0
.rdata$r:00009A9A                 db    0
.rdata$r:00009A9B                 db    0
.rdata$r:00009A9C                 dd offset ??_R0?AVTiXmlTextA@@@8 ; TiXmlTextA `RTTI Type Descriptor'
.rdata$r:00009AA0                 dd offset ??_R3TiXmlTextA@@8 ; TiXmlTextA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009AA0 _rdata$r        ends
.rdata$r:00009AA0
.data$r:00009AA4 ; ===========================================================================
.data$r:00009AA4
.data$r:00009AA4 ; Segment type: Pure data
.data$r:00009AA4 ; Segment permissions: Read/Write
.data$r:00009AA4 _data$r         segment dword public 'DATA' use32
.data$r:00009AA4                 assume cs:_data$r
.data$r:00009AA4                 ;org 9AA4h
.data$r:00009AA4 ; COMDAT (pick any)
.data$r:00009AA4                 public ??_R0?AVTiXmlTextA@@@8
.data$r:00009AA4 ; class TiXmlTextA `RTTI Type Descriptor'
.data$r:00009AA4 ??_R0?AVTiXmlTextA@@@8 dd offset ??_7type_info@@6B@
.data$r:00009AA4                                         ; DATA XREF: .rdata$r:00009A9Co
.data$r:00009AA4                                         ; .rdata$r:TiXmlTextA::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009AA4                                         ; const type_info::`vftable'
.data$r:00009AA8                 db    0
.data$r:00009AA9                 db    0
.data$r:00009AAA                 db    0
.data$r:00009AAB                 db    0
.data$r:00009AAC                 db  2Eh ; .
.data$r:00009AAD                 db  3Fh ; ?
.data$r:00009AAE                 db  41h ; A
.data$r:00009AAF                 db  56h ; V
.data$r:00009AB0                 db  54h ; T
.data$r:00009AB1                 db  69h ; i
.data$r:00009AB2                 db  58h ; X
.data$r:00009AB3                 db  6Dh ; m
.data$r:00009AB4                 db  6Ch ; l
.data$r:00009AB5                 db  54h ; T
.data$r:00009AB6                 db  65h ; e
.data$r:00009AB7                 db  78h ; x
.data$r:00009AB8                 db  74h ; t
.data$r:00009AB9                 db  41h ; A
.data$r:00009ABA                 db  40h ; @
.data$r:00009ABB                 db  40h ; @
.data$r:00009ABC                 db    0
.data$r:00009ABD                 align 10h
.data$r:00009ABD _data$r         ends
.data$r:00009ABD
.rdata$r:00009AC0 ; ===========================================================================
.rdata$r:00009AC0
.rdata$r:00009AC0 ; Segment type: Pure data
.rdata$r:00009AC0 ; Segment permissions: Read
.rdata$r:00009AC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009AC0                 assume cs:_rdata$r
.rdata$r:00009AC0                 ;org 9AC0h
.rdata$r:00009AC0 ; COMDAT (pick any)
.rdata$r:00009AC0                 public ??_R3TiXmlTextA@@8
.rdata$r:00009AC0 ; TiXmlTextA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009AC0 ??_R3TiXmlTextA@@8 db    0              ; DATA XREF: .rdata$r:00009AA0o
.rdata$r:00009AC0                                         ; .rdata$r:00009AF8o
.rdata$r:00009AC1                 db    0
.rdata$r:00009AC2                 db    0
.rdata$r:00009AC3                 db    0
.rdata$r:00009AC4                 db    0
.rdata$r:00009AC5                 db    0
.rdata$r:00009AC6                 db    0
.rdata$r:00009AC7                 db    0
.rdata$r:00009AC8                 db    3
.rdata$r:00009AC9                 db    0
.rdata$r:00009ACA                 db    0
.rdata$r:00009ACB                 db    0
.rdata$r:00009ACC                 dd offset ??_R2TiXmlTextA@@8 ; TiXmlTextA::`RTTI Base Class Array'
.rdata$r:00009ACC _rdata$r        ends
.rdata$r:00009ACC
.rdata$r:00009AD0 ; ===========================================================================
.rdata$r:00009AD0
.rdata$r:00009AD0 ; Segment type: Pure data
.rdata$r:00009AD0 ; Segment permissions: Read
.rdata$r:00009AD0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009AD0                 assume cs:_rdata$r
.rdata$r:00009AD0                 ;org 9AD0h
.rdata$r:00009AD0 ; COMDAT (pick any)
.rdata$r:00009AD0                 public ??_R2TiXmlTextA@@8
.rdata$r:00009AD0 ; TiXmlTextA::`RTTI Base Class Array'
.rdata$r:00009AD0 ??_R2TiXmlTextA@@8 dd offset ??_R1A@?0A@EA@TiXmlTextA@@8
.rdata$r:00009AD0                                         ; DATA XREF: .rdata$r:00009ACCo
.rdata$r:00009AD0                                         ; TiXmlTextA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009AD4                 dd offset ??_R1A@?0A@EA@TiXmlNodeA@@8 ; TiXmlNodeA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009AD8                 dd offset ??_R1A@?0A@EA@TiXmlBaseA@@8 ; TiXmlBaseA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009ADC                 db    0
.rdata$r:00009ADD                 align 10h
.rdata$r:00009ADD _rdata$r        ends
.rdata$r:00009ADD
.rdata$r:00009AE0 ; ===========================================================================
.rdata$r:00009AE0
.rdata$r:00009AE0 ; Segment type: Pure data
.rdata$r:00009AE0 ; Segment permissions: Read
.rdata$r:00009AE0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009AE0                 assume cs:_rdata$r
.rdata$r:00009AE0                 ;org 9AE0h
.rdata$r:00009AE0 ; COMDAT (pick any)
.rdata$r:00009AE0                 public ??_R1A@?0A@EA@TiXmlTextA@@8
.rdata$r:00009AE0 ; TiXmlTextA::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009AE0 ??_R1A@?0A@EA@TiXmlTextA@@8 dd offset ??_R0?AVTiXmlTextA@@@8
.rdata$r:00009AE0                                         ; DATA XREF: .rdata$r:TiXmlTextA::`RTTI Base Class Array'o
.rdata$r:00009AE0                                         ; TiXmlTextA `RTTI Type Descriptor'
.rdata$r:00009AE4                 db    2
.rdata$r:00009AE5                 db    0
.rdata$r:00009AE6                 db    0
.rdata$r:00009AE7                 db    0
.rdata$r:00009AE8                 db    0
.rdata$r:00009AE9                 db    0
.rdata$r:00009AEA                 db    0
.rdata$r:00009AEB                 db    0
.rdata$r:00009AEC                 db 0FFh
.rdata$r:00009AED                 db 0FFh
.rdata$r:00009AEE                 db 0FFh
.rdata$r:00009AEF                 db 0FFh
.rdata$r:00009AF0                 db    0
.rdata$r:00009AF1                 db    0
.rdata$r:00009AF2                 db    0
.rdata$r:00009AF3                 db    0
.rdata$r:00009AF4                 db  40h ; @
.rdata$r:00009AF5                 db    0
.rdata$r:00009AF6                 db    0
.rdata$r:00009AF7                 db    0
.rdata$r:00009AF8                 dd offset ??_R3TiXmlTextA@@8 ; TiXmlTextA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009AF8 _rdata$r        ends
.rdata$r:00009AF8
.rdata$r:00009AFC ; ===========================================================================
.rdata$r:00009AFC
.rdata$r:00009AFC ; Segment type: Pure data
.rdata$r:00009AFC ; Segment permissions: Read
.rdata$r:00009AFC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009AFC                 assume cs:_rdata$r
.rdata$r:00009AFC                 ;org 9AFCh
.rdata$r:00009AFC ; COMDAT (pick any)
.rdata$r:00009AFC                 public ??_R4TiXmlDeclarationA@@6B@
.rdata$r:00009AFC ; const TiXmlDeclarationA::`RTTI Complete Object Locator'
.rdata$r:00009AFC ??_R4TiXmlDeclarationA@@6B@ db    0     ; DATA XREF: .rdata:0000913Co
.rdata$r:00009AFD                 db    0
.rdata$r:00009AFE                 db    0
.rdata$r:00009AFF                 db    0
.rdata$r:00009B00                 db    0
.rdata$r:00009B01                 db    0
.rdata$r:00009B02                 db    0
.rdata$r:00009B03                 db    0
.rdata$r:00009B04                 db    0
.rdata$r:00009B05                 db    0
.rdata$r:00009B06                 db    0
.rdata$r:00009B07                 db    0
.rdata$r:00009B08                 dd offset ??_R0?AVTiXmlDeclarationA@@@8 ; TiXmlDeclarationA `RTTI Type Descriptor'
.rdata$r:00009B0C                 dd offset ??_R3TiXmlDeclarationA@@8 ; TiXmlDeclarationA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009B0C _rdata$r        ends
.rdata$r:00009B0C
.data$r:00009B10 ; ===========================================================================
.data$r:00009B10
.data$r:00009B10 ; Segment type: Pure data
.data$r:00009B10 ; Segment permissions: Read/Write
.data$r:00009B10 _data$r         segment dword public 'DATA' use32
.data$r:00009B10                 assume cs:_data$r
.data$r:00009B10                 ;org 9B10h
.data$r:00009B10 ; COMDAT (pick any)
.data$r:00009B10                 public ??_R0?AVTiXmlDeclarationA@@@8
.data$r:00009B10 ; class TiXmlDeclarationA `RTTI Type Descriptor'
.data$r:00009B10 ??_R0?AVTiXmlDeclarationA@@@8 dd offset ??_7type_info@@6B@
.data$r:00009B10                                         ; DATA XREF: .rdata$r:00009B08o
.data$r:00009B10                                         ; .rdata$r:TiXmlDeclarationA::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009B10                                         ; const type_info::`vftable'
.data$r:00009B14                 align 8
.data$r:00009B18 a_?avtixmldecla db '.?AVTiXmlDeclarationA@@',0
.data$r:00009B18 _data$r         ends
.data$r:00009B18
.rdata$r:00009B30 ; ===========================================================================
.rdata$r:00009B30
.rdata$r:00009B30 ; Segment type: Pure data
.rdata$r:00009B30 ; Segment permissions: Read
.rdata$r:00009B30 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009B30                 assume cs:_rdata$r
.rdata$r:00009B30                 ;org 9B30h
.rdata$r:00009B30 ; COMDAT (pick any)
.rdata$r:00009B30                 public ??_R3TiXmlDeclarationA@@8
.rdata$r:00009B30 ; TiXmlDeclarationA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009B30 ??_R3TiXmlDeclarationA@@8 db    0       ; DATA XREF: .rdata$r:00009B0Co
.rdata$r:00009B30                                         ; .rdata$r:00009B68o
.rdata$r:00009B31                 db    0
.rdata$r:00009B32                 db    0
.rdata$r:00009B33                 db    0
.rdata$r:00009B34                 db    0
.rdata$r:00009B35                 db    0
.rdata$r:00009B36                 db    0
.rdata$r:00009B37                 db    0
.rdata$r:00009B38                 db    3
.rdata$r:00009B39                 db    0
.rdata$r:00009B3A                 db    0
.rdata$r:00009B3B                 db    0
.rdata$r:00009B3C                 dd offset ??_R2TiXmlDeclarationA@@8 ; TiXmlDeclarationA::`RTTI Base Class Array'
.rdata$r:00009B3C _rdata$r        ends
.rdata$r:00009B3C
.rdata$r:00009B40 ; ===========================================================================
.rdata$r:00009B40
.rdata$r:00009B40 ; Segment type: Pure data
.rdata$r:00009B40 ; Segment permissions: Read
.rdata$r:00009B40 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009B40                 assume cs:_rdata$r
.rdata$r:00009B40                 ;org 9B40h
.rdata$r:00009B40 ; COMDAT (pick any)
.rdata$r:00009B40                 public ??_R2TiXmlDeclarationA@@8
.rdata$r:00009B40 ; TiXmlDeclarationA::`RTTI Base Class Array'
.rdata$r:00009B40 ??_R2TiXmlDeclarationA@@8 dd offset ??_R1A@?0A@EA@TiXmlDeclarationA@@8
.rdata$r:00009B40                                         ; DATA XREF: .rdata$r:00009B3Co
.rdata$r:00009B40                                         ; TiXmlDeclarationA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009B44                 dd offset ??_R1A@?0A@EA@TiXmlNodeA@@8 ; TiXmlNodeA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009B48                 dd offset ??_R1A@?0A@EA@TiXmlBaseA@@8 ; TiXmlBaseA::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009B4C                 db    0
.rdata$r:00009B4D                 align 10h
.rdata$r:00009B4D _rdata$r        ends
.rdata$r:00009B4D
.rdata$r:00009B50 ; ===========================================================================
.rdata$r:00009B50
.rdata$r:00009B50 ; Segment type: Pure data
.rdata$r:00009B50 ; Segment permissions: Read
.rdata$r:00009B50 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009B50                 assume cs:_rdata$r
.rdata$r:00009B50                 ;org 9B50h
.rdata$r:00009B50 ; COMDAT (pick any)
.rdata$r:00009B50                 public ??_R1A@?0A@EA@TiXmlDeclarationA@@8
.rdata$r:00009B50 ; TiXmlDeclarationA::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009B50 ??_R1A@?0A@EA@TiXmlDeclarationA@@8 dd offset ??_R0?AVTiXmlDeclarationA@@@8
.rdata$r:00009B50                                         ; DATA XREF: .rdata$r:TiXmlDeclarationA::`RTTI Base Class Array'o
.rdata$r:00009B50                                         ; TiXmlDeclarationA `RTTI Type Descriptor'
.rdata$r:00009B54                 db    2
.rdata$r:00009B55                 db    0
.rdata$r:00009B56                 db    0
.rdata$r:00009B57                 db    0
.rdata$r:00009B58                 db    0
.rdata$r:00009B59                 db    0
.rdata$r:00009B5A                 db    0
.rdata$r:00009B5B                 db    0
.rdata$r:00009B5C                 db 0FFh
.rdata$r:00009B5D                 db 0FFh
.rdata$r:00009B5E                 db 0FFh
.rdata$r:00009B5F                 db 0FFh
.rdata$r:00009B60                 db    0
.rdata$r:00009B61                 db    0
.rdata$r:00009B62                 db    0
.rdata$r:00009B63                 db    0
.rdata$r:00009B64                 db  40h ; @
.rdata$r:00009B65                 db    0
.rdata$r:00009B66                 db    0
.rdata$r:00009B67                 db    0
.rdata$r:00009B68                 dd offset ??_R3TiXmlDeclarationA@@8 ; TiXmlDeclarationA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009B68 _rdata$r        ends
.rdata$r:00009B68
.rdata$r:00009B6C ; ===========================================================================
.rdata$r:00009B6C
.rdata$r:00009B6C ; Segment type: Pure data
.rdata$r:00009B6C ; Segment permissions: Read
.rdata$r:00009B6C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009B6C                 assume cs:_rdata$r
.rdata$r:00009B6C                 ;org 9B6Ch
.rdata$r:00009B6C ; COMDAT (pick any)
.rdata$r:00009B6C                 public ??_R4TiXmlBaseA@@6B@
.rdata$r:00009B6C ; const TiXmlBaseA::`RTTI Complete Object Locator'
.rdata$r:00009B6C ??_R4TiXmlBaseA@@6B@ db    0            ; DATA XREF: .rdata:00009028o
.rdata$r:00009B6D                 db    0
.rdata$r:00009B6E                 db    0
.rdata$r:00009B6F                 db    0
.rdata$r:00009B70                 db    0
.rdata$r:00009B71                 db    0
.rdata$r:00009B72                 db    0
.rdata$r:00009B73                 db    0
.rdata$r:00009B74                 db    0
.rdata$r:00009B75                 db    0
.rdata$r:00009B76                 db    0
.rdata$r:00009B77                 db    0
.rdata$r:00009B78                 dd offset ??_R0?AVTiXmlBaseA@@@8 ; TiXmlBaseA `RTTI Type Descriptor'
.rdata$r:00009B7C                 dd offset ??_R3TiXmlBaseA@@8 ; TiXmlBaseA::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009B7C _rdata$r        ends
.rdata$r:00009B7C
.CRT$XCU:00009B80 ; ===========================================================================
.CRT$XCU:00009B80
.CRT$XCU:00009B80 ; Segment type: Pure data
.CRT$XCU:00009B80 ; Segment permissions: Read
.CRT$XCU:00009B80 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009B80                 assume cs:_CRT$XCU
.CRT$XCU:00009B80                 ;org 9B80h
.CRT$XCU:00009B80 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00009B84 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00009B84 _CRT$XCU        ends
.CRT$XCU:00009B84
.CRT$XCU:00009B88 ; ===========================================================================
.CRT$XCU:00009B88
.CRT$XCU:00009B88 ; Segment type: Pure data
.CRT$XCU:00009B88 ; Segment permissions: Read
.CRT$XCU:00009B88 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009B88                 assume cs:_CRT$XCU
.CRT$XCU:00009B88                 ;org 9B88h
.CRT$XCU:00009B88 ; COMDAT (pick associative to section at 8EE0)
.CRT$XCU:00009B88 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00009B88 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00009B88 _CRT$XCU        ends
.CRT$XCU:00009B88
.CRT$XCU:00009B8C ; ===========================================================================
.CRT$XCU:00009B8C
.CRT$XCU:00009B8C ; Segment type: Pure data
.CRT$XCU:00009B8C ; Segment permissions: Read
.CRT$XCU:00009B8C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009B8C                 assume cs:_CRT$XCU
.CRT$XCU:00009B8C                 ;org 9B8Ch
.CRT$XCU:00009B8C ; COMDAT (pick associative to section at 8EE4)
.CRT$XCU:00009B8C ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00009B8C ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00009B8C _CRT$XCU        ends
.CRT$XCU:00009B8C
.CRT$XCU:00009B90 ; ===========================================================================
.CRT$XCU:00009B90
.CRT$XCU:00009B90 ; Segment type: Pure data
.CRT$XCU:00009B90 ; Segment permissions: Read
.CRT$XCU:00009B90 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009B90                 assume cs:_CRT$XCU
.CRT$XCU:00009B90                 ;org 9B90h
.CRT$XCU:00009B90 ; COMDAT (pick associative to section at 8EE8)
.CRT$XCU:00009B90 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00009B90 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00009B90 _CRT$XCU        ends
.CRT$XCU:00009B90
.CRT$XCU:00009B94 ; ===========================================================================
.CRT$XCU:00009B94
.CRT$XCU:00009B94 ; Segment type: Pure data
.CRT$XCU:00009B94 ; Segment permissions: Read
.CRT$XCU:00009B94 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009B94                 assume cs:_CRT$XCU
.CRT$XCU:00009B94                 ;org 9B94h
.CRT$XCU:00009B94 ; COMDAT (pick associative to section at 9020)
.CRT$XCU:00009B94 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00009B94 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00009B94 _CRT$XCU        ends
.CRT$XCU:00009B94
.CRT$XCU:00009B98 ; ===========================================================================
.CRT$XCU:00009B98
.CRT$XCU:00009B98 ; Segment type: Pure data
.CRT$XCU:00009B98 ; Segment permissions: Read
.CRT$XCU:00009B98 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009B98                 assume cs:_CRT$XCU
.CRT$XCU:00009B98                 ;org 9B98h
.CRT$XCU:00009B98 ; COMDAT (pick associative to section at 9024)
.CRT$XCU:00009B98 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00009B98 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00009B98 _CRT$XCU        ends
.CRT$XCU:00009B98
.CRT$XCU:00009B9C ; ===========================================================================
.CRT$XCU:00009B9C
.CRT$XCU:00009B9C ; Segment type: Pure data
.CRT$XCU:00009B9C ; Segment permissions: Read
.CRT$XCU:00009B9C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009B9C                 assume cs:_CRT$XCU
.CRT$XCU:00009B9C                 ;org 9B9Ch
.CRT$XCU:00009B9C ; COMDAT (pick associative to section at 92AC)
.CRT$XCU:00009B9C ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00009B9C ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00009B9C _CRT$XCU        ends
.CRT$XCU:00009B9C
.CRT$XCU:00009BA0 ; ===========================================================================
.CRT$XCU:00009BA0
.CRT$XCU:00009BA0 ; Segment type: Pure data
.CRT$XCU:00009BA0 ; Segment permissions: Read
.CRT$XCU:00009BA0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009BA0                 assume cs:_CRT$XCU
.CRT$XCU:00009BA0                 ;org 9BA0h
.CRT$XCU:00009BA0 ; COMDAT (pick associative to section at 92B0)
.CRT$XCU:00009BA0 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00009BA0 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00009BA0 _CRT$XCU        ends
.CRT$XCU:00009BA0
UNDEF:00009BB0 ; ===========================================================================
UNDEF:00009BB0
UNDEF:00009BB0 ; Segment type: Externs
UNDEF:00009BB0 ; UNDEF
UNDEF:00009BB0                 extrn __purecall:near   ; DATA XREF: .rdata:00008CDCo
UNDEF:00009BB0                                         ; .rdata:00008CE0o ...
UNDEF:00009BB4 ; void *__cdecl operator new(unsigned int)
UNDEF:00009BB4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: TiXmlNodeA::Identify(char const *)+BDp
UNDEF:00009BB4                                         ; TiXmlNodeA::Identify(char const *)+126p ...
UNDEF:00009BB8 ; void __cdecl operator delete(void *)
UNDEF:00009BB8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$0+4p
UNDEF:00009BB8                                         ; __unwindfunclet$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z$1+4p ...
UNDEF:00009BBC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00009BBC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00009BBC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00009BC0 ; int __cdecl isalpha(int C)
UNDEF:00009BC0                 extrn _isalpha:near     ; CODE XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+4Cp
UNDEF:00009BC0                                         ; TiXmlBaseA::GetEntity(char const *,char *)+A6p ...
UNDEF:00009BC4 ; int __cdecl isspace(int C)
UNDEF:00009BC4                 extrn _isspace:near     ; CODE XREF: TiXmlBaseA::SkipWhiteSpace(char const *)+2Ep
UNDEF:00009BC4                                         ; TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+EEp ...
UNDEF:00009BC8 ; int __cdecl isalnum(int C)
UNDEF:00009BC8                 extrn _isalnum:near     ; CODE XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+7Ap
UNDEF:00009BCC ; int __cdecl tolower(int C)
UNDEF:00009BCC                 extrn _tolower:near     ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+BAp
UNDEF:00009BCC                                         ; TiXmlBaseA::GetEntity(char const *,char *)+12Dp ...
UNDEF:00009BD0 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00009BD0                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00009BD0                                         ; std::ctype<char>::do_narrow(char const *,char const *,char,char *)+46p ...
UNDEF:00009BD4 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:00009BD4                 extrn _memset:near      ; CODE XREF: std::char_traits<char>::assign(char *,uint,char)+10p
UNDEF:00009BD8 ; size_t __cdecl strlen(const char *Str)
UNDEF:00009BD8                 extrn _strlen:near      ; CODE XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+148p
UNDEF:00009BD8                                         ; TiXmlBaseA::GetEntity(char const *,char *)+222p ...
UNDEF:00009BDC ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00009BDC                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00009BE0 ; int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount)
UNDEF:00009BE0                 extrn _strncmp:near     ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+42p
UNDEF:00009BE0                                         ; TiXmlBaseA::GetEntity(char const *,char *)+20Bp
UNDEF:00009BE4 ; void __cdecl free(void *Memory)
UNDEF:00009BE4                 extrn _free:near        ; CODE XREF: std::_DebugHeapDelete<std::_Facet_base>(std::_Facet_base *)+1Bp
UNDEF:00009BE4                                         ; std::_DebugHeapDelete<std::locale::facet>(std::locale::facet *)+1Bp ...
UNDEF:00009BE8 ; void __cdecl _wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
UNDEF:00009BE8                 extrn __wassert:near    ; CODE XREF: TiXmlBaseA::ReadName(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+25p
UNDEF:00009BE8                                         ; TiXmlBaseA::GetEntity(char const *,char *)+245p ...
UNDEF:00009BEC ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00009BEC                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00009BEC                                         ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+2Ap
UNDEF:00009BEC                                         ; std::_Locinfo::_Locinfo(char const *)+2Dp ...
UNDEF:00009BF0 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00009BF0                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00009BF0                                         ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+E0p
UNDEF:00009BF0                                         ; __unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0+3j ...
UNDEF:00009BF4                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00009BF8 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00009BF8                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00009BF8                                         ; CODE XREF: std::runtime_error::runtime_error(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+3Ap
UNDEF:00009BF8                                         ; std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00009BFC ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00009BFC                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00009BFC                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00009BFC                                         ; DATA XREF: .xdata$x:00008CC0o
UNDEF:00009C00 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00009C00                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00009C00                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00009C00                                         ; __unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0+3j ...
UNDEF:00009C04 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00009C04                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00009C04                                         ; DATA XREF: .rdata:00008C30o
UNDEF:00009C04                                         ; .rdata:00008E34o ...
UNDEF:00009C08 ; bool __cdecl std::uncaught_exception()
UNDEF:00009C08                 extrn ?uncaught_exception@std@@YA_NXZ:near
UNDEF:00009C08                                         ; CODE XREF: std::basic_ostream<char,std::char_traits<char>>::sentry::~sentry(void)+2Dp
UNDEF:00009C0C ; void __cdecl operator delete[](void *)
UNDEF:00009C0C                 extrn ??_V@YAXPAX@Z:near
UNDEF:00009C0C                                         ; CODE XREF: std::ctype<char>::_Tidy(void)+39p
UNDEF:00009C10                 extrn __free_dbg:near   ; CODE XREF: std::_Yarn<char>::_Tidy(void)+17p
UNDEF:00009C10                                         ; std::_Yarn<wchar_t>::_Tidy(void)+17p
UNDEF:00009C14 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00009C14                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00009C14                                         ; CODE XREF: std::_Debug_pointer<char>(char *,wchar_t const *,uint)+16p
UNDEF:00009C14                                         ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p ...
UNDEF:00009C18 ; void __cdecl std::_Xbad_alloc()
UNDEF:00009C18                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00009C18                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_2A6Ap
UNDEF:00009C18                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_2AACp
UNDEF:00009C1C ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00009C1C                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00009C1C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00009C20 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00009C20                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00009C20                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00009C24 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00009C24                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00009C24                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:00009C28 ; _DWORD __thiscall std::bad_cast::bad_cast(std::bad_cast *__hidden this, const char *)
UNDEF:00009C28                 extrn ??0bad_cast@std@@QAE@PBD@Z:near
UNDEF:00009C28                                         ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+8Dp
UNDEF:00009C2C ; public: __thiscall std::bad_cast::bad_cast(class std::bad_cast const &)
UNDEF:00009C2C                 extrn ??0bad_cast@std@@QAE@ABV01@@Z:near
UNDEF:00009C2C                                         ; DATA XREF: .xdata$x:0000935Co
UNDEF:00009C30 ; public: virtual __thiscall std::bad_cast::~bad_cast(void)
UNDEF:00009C30                 extrn ??1bad_cast@std@@UAE@XZ:near
UNDEF:00009C30                                         ; DATA XREF: .xdata$x:00009310o
UNDEF:00009C34                 extrn __Getctype:near   ; CODE XREF: std::_Locinfo::_Getctype(void)+Dp
UNDEF:00009C38                 extrn __Tolower:near    ; CODE XREF: std::ctype<char>::do_tolower(char)+13p
UNDEF:00009C38                                         ; std::ctype<char>::do_tolower(char *,char const *)+42p
UNDEF:00009C3C                 extrn __Toupper:near    ; CODE XREF: std::ctype<char>::do_toupper(char)+13p
UNDEF:00009C3C                                         ; std::ctype<char>::do_toupper(char *,char const *)+42p
UNDEF:00009C40 ; void __cdecl static std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, const char *)
UNDEF:00009C40                 extrn ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:near
UNDEF:00009C40                                         ; CODE XREF: std::_Locinfo::_Locinfo(char const *)+BCp
UNDEF:00009C44 ; void __cdecl static std::_Locinfo::_Locinfo_dtor(struct std::_Locinfo *)
UNDEF:00009C44                 extrn ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:near
UNDEF:00009C44                                         ; CODE XREF: std::_Locinfo::~_Locinfo(void)+31p
UNDEF:00009C48 ; void *__cdecl operator new(unsigned int, const struct std::_DebugHeapTag_t *, char *, int)
UNDEF:00009C48                 extrn ??2@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z:near
UNDEF:00009C48                                         ; CODE XREF: std::locale::facet::operator new(uint,std::_DebugHeapTag_t const &,char *,int)+13p
UNDEF:00009C4C ; const struct std::_DebugHeapTag_t *__cdecl std::_DebugHeapTag_func()
UNDEF:00009C4C                 extrn ?_DebugHeapTag_func@std@@YAABU_DebugHeapTag_t@1@XZ:near
UNDEF:00009C4C                                         ; CODE XREF: std::ctype<char>::_Getcat(std::locale::facet const * *,std::locale const *)+42p
UNDEF:00009C50 ; public: virtual void * __thiscall std::_Facet_base::`vector deleting destructor'(unsigned int)
UNDEF:00009C50                 extrn ??_E_Facet_base@std@@UAEPAXI@Z:near ; weak
UNDEF:00009C50                                         ; DATA XREF: .rdata:const std::_Facet_base::`vftable'o
UNDEF:00009C54 ; void __cdecl std::_Facet_Register(struct std::_Facet_base *)
UNDEF:00009C54                 extrn ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:near
UNDEF:00009C54                                         ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+C8p
UNDEF:00009C58 ; protected: virtual void * __thiscall std::locale::facet::`vector deleting destructor'(unsigned int)
UNDEF:00009C58                 extrn ??_Efacet@locale@std@@MAEPAXI@Z:near ; weak
UNDEF:00009C58                                         ; DATA XREF: .rdata:const std::locale::facet::`vftable'o
UNDEF:00009C5C ; struct std::locale::_Locimp *__cdecl static std::locale::_Getgloballocale()
UNDEF:00009C5C                 extrn ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:near
UNDEF:00009C5C                                         ; CODE XREF: std::locale::_Getfacet(uint):loc_5E0Cp
UNDEF:00009C60 ; public: virtual void * __thiscall std::ctype_base::`vector deleting destructor'(unsigned int)
UNDEF:00009C60                 extrn ??_Ectype_base@std@@UAEPAXI@Z:near ; weak
UNDEF:00009C60                                         ; DATA XREF: .rdata:const std::ctype_base::`vftable'o
UNDEF:00009C64 ; protected: virtual void * __thiscall std::ctype<char>::`vector deleting destructor'(unsigned int)
UNDEF:00009C64                 extrn ??_E?$ctype@D@std@@MAEPAXI@Z:near ; weak
UNDEF:00009C64                                         ; DATA XREF: .rdata:const std::ctype<char>::`vftable'o
UNDEF:00009C68 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00009C68                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00009C68                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00009C6C ; public: virtual void * __thiscall std::_System_error::`vector deleting destructor'(unsigned int)
UNDEF:00009C6C                 extrn ??_E_System_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00009C6C                                         ; DATA XREF: .rdata:const std::_System_error::`vftable'o
UNDEF:00009C70 ; public: virtual void * __thiscall std::system_error::`vector deleting destructor'(unsigned int)
UNDEF:00009C70                 extrn ??_Esystem_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00009C70                                         ; DATA XREF: .rdata:const std::system_error::`vftable'o
UNDEF:00009C74 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00009C74                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00009C74                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00009C74                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00009C78 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00009C78                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00009C78                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00009C7C ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00009C7C                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00009C7C                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00009C80 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00009C80                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00009C80                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00009C84 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00009C84                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00009C84                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00009C88 ; public: virtual void * __thiscall std::ios_base::failure::`vector deleting destructor'(unsigned int)
UNDEF:00009C88                 extrn ??_Efailure@ios_base@std@@UAEPAXI@Z:near ; weak
UNDEF:00009C88                                         ; DATA XREF: .rdata:const std::ios_base::failure::`vftable'o
UNDEF:00009C8C ; public: virtual void * __thiscall TiXmlBaseA::`vector deleting destructor'(unsigned int)
UNDEF:00009C8C                 extrn ??_ETiXmlBaseA@@UAEPAXI@Z:near ; weak
UNDEF:00009C8C                                         ; DATA XREF: .rdata:const TiXmlBaseA::`vftable'o
UNDEF:00009C90 ; _DWORD __thiscall TiXmlNodeA::~TiXmlNodeA(TiXmlNodeA *__hidden this)
UNDEF:00009C90                 extrn ??1TiXmlNodeA@@UAE@XZ:near
UNDEF:00009C90                                         ; CODE XREF: __unwindfunclet$??0TiXmlCommentA@@QAE@XZ$0+3j
UNDEF:00009C90                                         ; __unwindfunclet$??0TiXmlDeclarationA@@QAE@XZ$0+3j ...
UNDEF:00009C94 ; struct TiXmlNodeA *__thiscall TiXmlNodeA::LinkEndChild(TiXmlNodeA *__hidden this, struct TiXmlNodeA *)
UNDEF:00009C94                 extrn ?LinkEndChild@TiXmlNodeA@@QAEPAV1@PAV1@@Z:near
UNDEF:00009C94                                         ; CODE XREF: TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+FEp
UNDEF:00009C94                                         ; TiXmlElementA::ReadValue(char const *,TiXmlParsingDataA *)+188p ...
UNDEF:00009C98 ; struct TiXmlDocumentA *__thiscall TiXmlNodeA::GetDocument(TiXmlNodeA *__hidden this)
UNDEF:00009C98                 extrn ?GetDocument@TiXmlNodeA@@QBEPAVTiXmlDocumentA@@XZ:near
UNDEF:00009C98                                         ; CODE XREF: TiXmlNodeA::Identify(char const *)+63p
UNDEF:00009C98                                         ; TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+40p ...
UNDEF:00009C9C ; protected: __thiscall TiXmlNodeA::TiXmlNodeA(enum  TiXmlNodeA::NodeType)
UNDEF:00009C9C                 extrn ??0TiXmlNodeA@@IAE@W4NodeType@0@@Z:near
UNDEF:00009C9C                                         ; CODE XREF: TiXmlCommentA::TiXmlCommentA(void)+2Bp
UNDEF:00009C9C                                         ; TiXmlDeclarationA::TiXmlDeclarationA(void)+2Bp ...
UNDEF:00009CA0 ; public: virtual void __thiscall TiXmlAttributeA::Print(struct _iobuf *, int)const
UNDEF:00009CA0                 extrn ?Print@TiXmlAttributeA@@UBEXPAU_iobuf@@H@Z:near
UNDEF:00009CA0                                         ; DATA XREF: .rdata:000090F0o
UNDEF:00009CA4 ; public: virtual void __thiscall TiXmlAttributeA::StreamOut(class std::basic_ostream<char, struct std::char_traits<char>> *)const
UNDEF:00009CA4                 extrn ?StreamOut@TiXmlAttributeA@@UBEXPAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z:near
UNDEF:00009CA4                                         ; DATA XREF: .rdata:000090F4o
UNDEF:00009CA8 ; public: virtual void * __thiscall TiXmlAttributeA::`vector deleting destructor'(unsigned int)
UNDEF:00009CA8                 extrn ??_ETiXmlAttributeA@@UAEPAXI@Z:near ; weak
UNDEF:00009CA8                                         ; DATA XREF: .rdata:const TiXmlAttributeA::`vftable'o
UNDEF:00009CAC ; void __thiscall TiXmlAttributeSetA::Add(TiXmlAttributeSetA *__hidden this, struct TiXmlAttributeA *)
UNDEF:00009CAC                 extrn ?Add@TiXmlAttributeSetA@@QAEXPAVTiXmlAttributeA@@@Z:near
UNDEF:00009CAC                                         ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+4C2p
UNDEF:00009CB0 ; struct TiXmlAttributeA *__thiscall TiXmlAttributeSetA::Find(TiXmlAttributeSetA *__hidden this, const char *)
UNDEF:00009CB0                 extrn ?Find@TiXmlAttributeSetA@@QBEPAVTiXmlAttributeA@@PBD@Z:near
UNDEF:00009CB0                                         ; CODE XREF: TiXmlElementA::Parse(char const *,TiXmlParsingDataA *)+452p
UNDEF:00009CB4 ; _DWORD __thiscall TiXmlElementA::TiXmlElementA(TiXmlElementA *__hidden this, const char *)
UNDEF:00009CB4                 extrn ??0TiXmlElementA@@QAE@PBD@Z:near
UNDEF:00009CB4                                         ; CODE XREF: TiXmlNodeA::Identify(char const *)+146p
UNDEF:00009CB8 ; public: virtual class TiXmlNodeA * __thiscall TiXmlCommentA::Clone(void)const
UNDEF:00009CB8                 extrn ?Clone@TiXmlCommentA@@UBEPAVTiXmlNodeA@@XZ:near
UNDEF:00009CB8                                         ; DATA XREF: .rdata:00009114o
UNDEF:00009CBC ; public: virtual void __thiscall TiXmlCommentA::Print(struct _iobuf *, int)const
UNDEF:00009CBC                 extrn ?Print@TiXmlCommentA@@UBEXPAU_iobuf@@H@Z:near
UNDEF:00009CBC                                         ; DATA XREF: .rdata:00009104o
UNDEF:00009CC0 ; protected: virtual void __thiscall TiXmlCommentA::StreamOut(class std::basic_ostream<char, struct std::char_traits<char>> *)const
UNDEF:00009CC0                 extrn ?StreamOut@TiXmlCommentA@@MBEXPAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z:near
UNDEF:00009CC0                                         ; DATA XREF: .rdata:00009108o
UNDEF:00009CC4 ; public: virtual void * __thiscall TiXmlCommentA::`vector deleting destructor'(unsigned int)
UNDEF:00009CC4                 extrn ??_ETiXmlCommentA@@UAEPAXI@Z:near ; weak
UNDEF:00009CC4                                         ; DATA XREF: .rdata:const TiXmlCommentA::`vftable'o
UNDEF:00009CC8 ; public: virtual void __thiscall TiXmlTextA::Print(struct _iobuf *, int)const
UNDEF:00009CC8                 extrn ?Print@TiXmlTextA@@UBEXPAU_iobuf@@H@Z:near
UNDEF:00009CC8                                         ; DATA XREF: .rdata:00009124o
UNDEF:00009CCC ; protected: virtual class TiXmlNodeA * __thiscall TiXmlTextA::Clone(void)const
UNDEF:00009CCC                 extrn ?Clone@TiXmlTextA@@MBEPAVTiXmlNodeA@@XZ:near
UNDEF:00009CCC                                         ; DATA XREF: .rdata:00009134o
UNDEF:00009CD0 ; protected: virtual void __thiscall TiXmlTextA::StreamOut(class std::basic_ostream<char, struct std::char_traits<char>> *)const
UNDEF:00009CD0                 extrn ?StreamOut@TiXmlTextA@@MBEXPAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z:near
UNDEF:00009CD0                                         ; DATA XREF: .rdata:00009128o
UNDEF:00009CD4 ; public: virtual void * __thiscall TiXmlTextA::`vector deleting destructor'(unsigned int)
UNDEF:00009CD4                 extrn ??_ETiXmlTextA@@UAEPAXI@Z:near ; weak
UNDEF:00009CD4                                         ; DATA XREF: .rdata:const TiXmlTextA::`vftable'o
UNDEF:00009CD8 ; public: virtual class TiXmlNodeA * __thiscall TiXmlDeclarationA::Clone(void)const
UNDEF:00009CD8                 extrn ?Clone@TiXmlDeclarationA@@UBEPAVTiXmlNodeA@@XZ:near
UNDEF:00009CD8                                         ; DATA XREF: .rdata:00009154o
UNDEF:00009CDC ; public: virtual void __thiscall TiXmlDeclarationA::Print(struct _iobuf *, int)const
UNDEF:00009CDC                 extrn ?Print@TiXmlDeclarationA@@UBEXPAU_iobuf@@H@Z:near
UNDEF:00009CDC                                         ; DATA XREF: .rdata:00009144o
UNDEF:00009CE0 ; protected: virtual void __thiscall TiXmlDeclarationA::StreamOut(class std::basic_ostream<char, struct std::char_traits<char>> *)const
UNDEF:00009CE0                 extrn ?StreamOut@TiXmlDeclarationA@@MBEXPAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z:near
UNDEF:00009CE0                                         ; DATA XREF: .rdata:00009148o
UNDEF:00009CE4 ; public: virtual void * __thiscall TiXmlDeclarationA::`vector deleting destructor'(unsigned int)
UNDEF:00009CE4                 extrn ??_ETiXmlDeclarationA@@UAEPAXI@Z:near ; weak
UNDEF:00009CE4                                         ; DATA XREF: .rdata:const TiXmlDeclarationA::`vftable'o
UNDEF:00009CE8 ; public: virtual class TiXmlNodeA * __thiscall TiXmlUnknownA::Clone(void)const
UNDEF:00009CE8                 extrn ?Clone@TiXmlUnknownA@@UBEPAVTiXmlNodeA@@XZ:near
UNDEF:00009CE8                                         ; DATA XREF: .rdata:00009174o
UNDEF:00009CEC ; public: virtual void __thiscall TiXmlUnknownA::Print(struct _iobuf *, int)const
UNDEF:00009CEC                 extrn ?Print@TiXmlUnknownA@@UBEXPAU_iobuf@@H@Z:near
UNDEF:00009CEC                                         ; DATA XREF: .rdata:00009164o
UNDEF:00009CF0 ; protected: virtual void __thiscall TiXmlUnknownA::StreamOut(class std::basic_ostream<char, struct std::char_traits<char>> *)const
UNDEF:00009CF0                 extrn ?StreamOut@TiXmlUnknownA@@MBEXPAV?$basic_ostream@DU?$char_traits@D@std@@@std@@@Z:near
UNDEF:00009CF0                                         ; DATA XREF: .rdata:00009168o
UNDEF:00009CF4 ; public: virtual void * __thiscall TiXmlUnknownA::`vector deleting destructor'(unsigned int)
UNDEF:00009CF4                 extrn ??_ETiXmlUnknownA@@UAEPAXI@Z:near ; weak
UNDEF:00009CF4                                         ; DATA XREF: .rdata:const TiXmlUnknownA::`vftable'o
UNDEF:00009CF8 ; __fastcall __security_check_cookie(x)
UNDEF:00009CF8                 extrn @__security_check_cookie@4:near
UNDEF:00009CF8                                         ; CODE XREF: TiXmlBaseA::GetEntity(char const *,char *)+2BAp
UNDEF:00009CF8                                         ; TiXmlElementA::StreamIn(std::basic_istream<char,std::char_traits<char>> *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *)+2D0p ...
UNDEF:00009CFC ; __stdcall _CxxThrowException(x, x)
UNDEF:00009CFC                 extrn __CxxThrowException@8:near
UNDEF:00009CFC                                         ; CODE XREF: std::use_facet<std::ctype<char>>(std::locale const &)+9Bp
UNDEF:00009CFC                                         ; std::_Locinfo::_Locinfo(char const *)+AFp ...
UNDEF:00009D00                 extrn ___CxxFrameHandler3:near
UNDEF:00009D00                                         ; CODE XREF: __ehhandler$?GetEntity@TiXmlBaseA@@KAPBDPBDPAD@Z+20j
UNDEF:00009D00                                         ; __ehhandler$?Identify@TiXmlNodeA@@IAEPAV1@PBD@Z+16j ...
UNDEF:00009D04 ; const type_info::`vftable'
UNDEF:00009D04                 extrn ??_7type_info@@6B@:near
UNDEF:00009D04                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:00009D04                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:00009D08 ; private: static int std::locale::id::_Id_cnt
UNDEF:00009D08                 extrn ?_Id_cnt@id@locale@std@@0HA:near
UNDEF:00009D08                                         ; DATA XREF: std::locale::id::operator uint(void)+49r
UNDEF:00009D08                                         ; std::locale::id::operator uint(void)+52w ...
UNDEF:00009D0C ; public: static class std::locale::id std::ctype<char>::id
UNDEF:00009D0C                 extrn ?id@?$ctype@D@std@@2V0locale@2@A:near
UNDEF:00009D0C                                         ; DATA XREF: std::use_facet<std::ctype<char>>(std::locale const &)+3Eo
UNDEF:00009D10 ; char *TiXmlBaseA::errorString
UNDEF:00009D10                 extrn ?errorString@TiXmlBaseA@@1PAPBDA:near
UNDEF:00009D10                                         ; DATA XREF: TiXmlDocumentA::SetError(int,char const *,TiXmlParsingDataA *)+50r
UNDEF:00009D14 ; private: static bool TiXmlBaseA::condenseWhiteSpace
UNDEF:00009D14                 extrn ?condenseWhiteSpace@TiXmlBaseA@@0_NA:near
UNDEF:00009D14                                         ; DATA XREF: TiXmlBaseA::ReadText(char const *,std::basic_string<char,std::char_traits<char>,std::allocator<char>> *,bool,char const *,bool)+19r
UNDEF:00009D18                 extrn ___security_cookie:near
UNDEF:00009D18                                         ; DATA XREF: TiXmlBaseA::GetEntity(char const *,char *)+14r
UNDEF:00009D18                                         ; TiXmlNodeA::Identify(char const *)+14r ...
UNDEF:00009D1C                 extrn __fltused:near
UNDEF:00009D1C
UNDEF:00009D1C
UNDEF:00009D1C                 end