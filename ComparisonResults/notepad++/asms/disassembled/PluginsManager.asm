.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : 2C19F8420135DF85915B88978AEDDC36
.data:00000000 ; Input CRC32 : DC00E863
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\PluginsManager.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 _data           segment dword public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000                 public ?USERMSG@@3PB_WB
.data:00000000 ; wchar_t *USERMSG
.data:00000000 ?USERMSG@@3PB_WB dd offset $SG126526    ; DATA XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+14r
.data:00000000                                         ; __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2+24r
.data:00000000 _data           ends                    ; "This plugin is not compatible with curr"...
.data:00000000
.rdata:00000004 ; ===========================================================================
.rdata:00000004
.rdata:00000004 ; Segment type: Pure data
.rdata:00000004 ; Segment permissions: Read
.rdata:00000004 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000004 _rdata          segment para public 'DATA' use32
.rdata:00000004                 assume cs:_rdata
.rdata:00000004                 ;org 4
.rdata:00000004 $SG126526:                              ; DATA XREF: .data:wchar_t const * const USERMSGo
.rdata:00000004                 unicode 0, <This plugin is not compatible with current version of Not>
.rdata:00000004                 unicode 0, <epad++.>
.rdata:00000004                 dw 2 dup(0Ah)
.rdata:00000004                 unicode 0, <Do you want to remove this plugin from plugins directory >
.rdata:00000004                 unicode 0, <to prevent this message from the next launch time?>,0
.rdata:00000160 ; wchar_t _SG126535
.rdata:00000160 $SG126535:                              ; DATA XREF: PluginsManager::unloadPlugin(int,HWND__ *):loc_1D45o
.rdata:00000160                 unicode 0, <not ok>,0
.rdata:0000016E                 db    0
.rdata:0000016F                 db    0
.rdata:00000170                 db    0
.rdata:00000171                 db    0
.rdata:00000172                 db    0
.rdata:00000173                 db    0
.rdata:00000174 ; wchar_t _SG126566
.rdata:00000174 $SG126566:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+101o
.rdata:00000174                 unicode 0, <Load Library is failed.>
.rdata:00000174                 dw 0Ah
.rdata:00000174                 unicode 0, <Make "Runtime Library" setting of this project as "Multi->
.rdata:00000174                 unicode 0, <threaded(/MT)" may cure this problem.>,0
.rdata:00000262                 align 4
.rdata:00000264 ; CHAR _SG126568[]
.rdata:00000264 $SG126568       db 'isUnicode',0        ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_BA6o
.rdata:0000026E                 align 10h
.rdata:00000270 ; CHAR _SG126575[]
.rdata:00000270 $SG126575       db 'setInfo',0          ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_BFFo
.rdata:00000278 ; CHAR _SG126587[]
.rdata:00000278 $SG126587       db 'beNotified',0       ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_C93o
.rdata:00000283                 align 4
.rdata:00000284 ; wchar_t _SG126573
.rdata:00000284 $SG126573:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_BDEo
.rdata:00000284                 unicode 0, <This ANSI plugin is not compatible with your Unicode Note>
.rdata:00000284                 unicode 0, <pad++.>,0
.rdata:00000304 ; wchar_t _SG126579
.rdata:00000304 $SG126579:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+1A4o
.rdata:00000304                 unicode 0, <Missing "setInfo" function>,0
.rdata:0000033A                 align 4
.rdata:0000033C ; CHAR _SG126581[]
.rdata:0000033C $SG126581       db 'getName',0          ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_C49o
.rdata:00000344 ; wchar_t _SG126585
.rdata:00000344 $SG126585:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+1EEo
.rdata:00000344                 unicode 0, <Missing "getName" function>,0
.rdata:0000037A                 align 4
.rdata:0000037C ; wchar_t _SG126591
.rdata:0000037C $SG126591:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+238o
.rdata:0000037C                 unicode 0, <Missing "beNotified" function>,0
.rdata:000003B8 ; CHAR _SG126593[]
.rdata:000003B8 $SG126593       db 'messageProc',0      ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_CDDo
.rdata:000003C4 ; wchar_t _SG126597
.rdata:000003C4 $SG126597:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+282o
.rdata:000003C4                 unicode 0, <Missing "messageProc" function>,0
.rdata:00000402                 align 4
.rdata:00000404 ; CHAR _SG126599[]
.rdata:00000404 $SG126599       db 'getFuncsArray',0    ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+2CCo
.rdata:00000412                 align 4
.rdata:00000414 ; wchar_t _SG126603
.rdata:00000414 $SG126603:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+2F5o
.rdata:00000414                 unicode 0, <Missing "getFuncsArray" function>,0
.rdata:00000456                 align 4
.rdata:00000458 ; CHAR _SG126622[]
.rdata:00000458 $SG126622       db 'GetLexerStatusText',0
.rdata:00000458                                         ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_E6Eo
.rdata:0000046B                 align 4
.rdata:0000046C ; wchar_t _SG126608
.rdata:0000046C $SG126608:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_DD3o
.rdata:0000046C                 unicode 0, <Missing "FuncItems" array, or the nb of Function Item is >
.rdata:0000046C                 unicode 0, <not set correctly>,0
.rdata:00000502                 align 4
.rdata:00000504 ; CHAR _SG126611[]
.rdata:00000504 $SG126611       db 'GetLexerCount',0    ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+37Fo
.rdata:00000512                 align 4
.rdata:00000514 ; CHAR _SG126615[]
.rdata:00000514 $SG126615       db 'GetLexerName',0     ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+3A6o
.rdata:00000521                 align 4
.rdata:00000524 ; wchar_t _SG126619
.rdata:00000524 $SG126619:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+3C9o
.rdata:00000524                 unicode 0, <Loading GetLexerName function failed.>,0
.rdata:00000570 ; const WCHAR _SG126649
.rdata:00000570 $SG126649:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+64Ao
.rdata:00000570                 unicode 0, <.xml>,0
.rdata:0000057A                 align 4
.rdata:0000057C ; wchar_t _SG126626
.rdata:0000057C $SG126626:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+40Do
.rdata:0000057C                 unicode 0, <Loading GetLexerStatusText function failed.>,0
.rdata:000005D4 ; const WCHAR _SG126648
.rdata:000005D4 $SG126648:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+60Fo
.rdata:000005D4                 unicode 0, <plugins\Config>,0
.rdata:000005F2                 align 4
.rdata:000005F4 ; const WCHAR _SG126651
.rdata:000005F4 $SG126651       dw 0                    ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+676o
.rdata:000005F6                 align 4
.rdata:000005F8 ; const WCHAR _SG126652
.rdata:000005F8 $SG126652:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+6A1o
.rdata:000005F8                 unicode 0, <plugins\Config>,0
.rdata:00000616                 align 4
.rdata:00000618 ; const WCHAR _SG126653
.rdata:00000618 $SG126653:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+6DCo
.rdata:00000618                 unicode 0, <.xml>,0
.rdata:00000622                 align 4
.rdata:00000624 ; wchar_t _SG126685
.rdata:00000624 $SG126685:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+703o
.rdata:00000624                 unicode 0, < is missing.>,0
.rdata:0000063E                 align 10h
.rdata:00000640 ; wchar_t _SG126698
.rdata:00000640 $SG126698:                              ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+861o
.rdata:00000640                 unicode 0, < failed to load.>,0
.rdata:00000662                 align 4
.rdata:00000664 ; CHAR _SG126707[]
.rdata:00000664 $SG126707       db 'Exception',0        ; DATA XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$0+6o
.rdata:0000066E                 align 10h
.rdata:00000670 ; wchar_t _SG126710
.rdata:00000670 $SG126710:                              ; DATA XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+4o
.rdata:00000670                 dw 2 dup(0Ah), 0
.rdata:00000676                 align 4
.rdata:00000678 ; wchar_t _SG126717
.rdata:00000678 $SG126717:                              ; DATA XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2o
.rdata:00000678                 unicode 0, <Failed to load>,0
.rdata:00000696                 align 4
.rdata:00000698 ; wchar_t _SG126718
.rdata:00000698 $SG126718:                              ; DATA XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2+14o
.rdata:00000698                 dw 2 dup(0Ah), 0
.rdata:0000069E                 align 10h
.rdata:000006A0 ; wchar_t _SG126755
.rdata:000006A0 $SG126755:                              ; DATA XREF: PluginsManager::loadPlugins(wchar_t const *):loc_1861o
.rdata:000006A0                 unicode 0, <\plugins\*.dll>,0
.rdata:000006BE                 align 10h
.rdata:000006C0 ; wchar_t _SG126766
.rdata:000006C0 $SG126766:                              ; DATA XREF: PluginsManager::loadPlugins(wchar_t const *):loc_1995o
.rdata:000006C0                 unicode 0, <\plugins\>,0
.rdata:000006D4 ; wchar_t _SG126777
.rdata:000006D4 $SG126777:                              ; DATA XREF: PluginsManager::loadPlugins(wchar_t const *):loc_1B01o
.rdata:000006D4                 unicode 0, <\plugins\>,0
.rdata:000006E8 ; const WCHAR _SG126827
.rdata:000006E8 $SG126827       dw 0                    ; DATA XREF: PluginsManager::addInMenuFromPMIndex(int)+FEo
.rdata:000006EA                 align 4
.rdata:000006EC ; wchar_t _SG126836
.rdata:000006EC $SG126836:                              ; DATA XREF: PluginsManager::addInMenuFromPMIndex(int)+364o
.rdata:000006EC                 dw 9, 0
.rdata:000006F0 $SG126852:                              ; DATA XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *):loc_25F1o
.rdata:000006F0                 unicode 0, <&Plugins>,0
.rdata:00000702                 align 4
.rdata:00000704 ; CHAR _SG126868[]
.rdata:00000704 $SG126868       db 'PluginsManager::runPluginCommand Exception',0
.rdata:00000704                                         ; DATA XREF: __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$0+6o
.rdata:0000072F                 align 10h
.rdata:00000730 ; CHAR _SG126885[]
.rdata:00000730 $SG126885       db 'Exception',0        ; DATA XREF: __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$0+6o
.rdata:0000073A                 align 4
.rdata:0000073C ; wchar_t _SG126870
.rdata:0000073C $SG126870:                              ; DATA XREF: __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$1+4o
.rdata:0000073C                 unicode 0, <runPluginCommand(size_t i : %d)>,0
.rdata:0000077C ; wchar_t _SG126887
.rdata:0000077C $SG126887:                              ; DATA XREF: __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$1+8o
.rdata:0000077C                 unicode 0, <runPluginCommand(const TCHAR *pluginName : %s, int comman>
.rdata:0000077C                 unicode 0, <dID : %d)>,0
.rdata:00000802                 align 4
.rdata:00000804 ; CHAR _SG126901[]
.rdata:00000804 $SG126901       db 'Exception',0        ; DATA XREF: __catch$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$0+6o
.rdata:0000080E                 align 10h
.rdata:00000810 ; CHAR _SG126918[]
.rdata:00000810 $SG126918       db 'Exception',0        ; DATA XREF: __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$0+6o
.rdata:0000081A                 align 4
.rdata:0000081C ; wchar_t _SG126903
.rdata:0000081C $SG126903:                              ; DATA XREF: __catch$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$1+15o
.rdata:0000081C                 unicode 0, <notify(SCNotification *notification) : >
.rdata:0000081C                 dw 0Dh
.rdata:0000081C                 unicode 0, < notification->
.rdata:0000081C                 dw 3Eh
.rdata:0000081C                 unicode 0, <nmhdr.code == %d>
.rdata:0000081C                 dw 0Dh
.rdata:0000081C                 unicode 0, < notification->
.rdata:0000081C                 dw 3Eh
.rdata:0000081C                 unicode 0, <nmhdr.hwndFrom == %d>
.rdata:0000081C                 dw 0Dh
.rdata:0000081C                 unicode 0, < notification->
.rdata:0000081C                 dw 3Eh
.rdata:0000081C                 unicode 0, <nmhdr.idFrom == %d>,0
.rdata:00000938 ; wchar_t _SG126921
.rdata:00000938 $SG126921       dw 0                    ; DATA XREF: __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$1+20o
.rdata:0000093A                 db    0
.rdata:0000093B                 db    0
.rdata:0000093C ; wchar_t _SG126920
.rdata:0000093C $SG126920:                              ; DATA XREF: __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$1+Co
.rdata:0000093C                 unicode 0, <relayNppMessages(UINT Message : %d, WPARAM wParam : %d, L>
.rdata:0000093C                 unicode 0, <PARAM lParam : %d)>,0
.rdata:000009D4 ; CHAR _SG126957[]
.rdata:000009D4 $SG126957       db 'Exception',0        ; DATA XREF: __catch$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$0+6o
.rdata:000009DE                 db    0
.rdata:000009DF                 db    0
.rdata:000009E0                 db    0
.rdata:000009E1                 db    0
.rdata:000009E2                 db    0
.rdata:000009E3                 db    0
.rdata:000009E4 ; wchar_t _SG126959
.rdata:000009E4 $SG126959:                              ; DATA XREF: __catch$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$1+Co
.rdata:000009E4                 unicode 0, <relayPluginMessages(UINT Message : %d, WPARAM wParam : %d>
.rdata:000009E4                 unicode 0, <, LPARAM lParam : %d)>,0
.rdata:00000A82                 align 4
.rdata:00000A82 _rdata          ends
.rdata:00000A82
.text$mn:00000A84 ; ===========================================================================
.text$mn:00000A84
.text$mn:00000A84 ; Segment type: Pure code
.text$mn:00000A84 ; Segment permissions: Read/Execute
.text$mn:00000A84 _text$mn        segment para public 'CODE' use32
.text$mn:00000A84                 assume cs:_text$mn
.text$mn:00000A84                 ;org 0A84h
.text$mn:00000A84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000A84
.text$mn:00000A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A84
.text$mn:00000A84 ; Attributes: bp-based frame
.text$mn:00000A84
.text$mn:00000A84 ; int __cdecl PluginsManager::loadPlugin(LPCWSTR pszPath)
.text$mn:00000A84                 public ?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z
.text$mn:00000A84 ?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z proc near
.text$mn:00000A84                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+52Cp
.text$mn:00000A84
.text$mn:00000A84 var_5EC         = dword ptr -5ECh
.text$mn:00000A84 var_5E8         = dword ptr -5E8h
.text$mn:00000A84 var_5E4         = dword ptr -5E4h
.text$mn:00000A84 var_5E0         = dword ptr -5E0h
.text$mn:00000A84 var_5DC         = dword ptr -5DCh
.text$mn:00000A84 var_5D4         = dword ptr -5D4h
.text$mn:00000A84 var_5CC         = dword ptr -5CCh
.text$mn:00000A84 var_5C4         = dword ptr -5C4h
.text$mn:00000A84 var_5BC         = dword ptr -5BCh
.text$mn:00000A84 var_5B4         = dword ptr -5B4h
.text$mn:00000A84 var_5AC         = dword ptr -5ACh
.text$mn:00000A84 var_5A4         = dword ptr -5A4h
.text$mn:00000A84 lParam          = dword ptr -5A0h
.text$mn:00000A84 var_59C         = dword ptr -59Ch
.text$mn:00000A84 var_598         = dword ptr -598h
.text$mn:00000A84 var_594         = dword ptr -594h
.text$mn:00000A84 var_590         = dword ptr -590h
.text$mn:00000A84 var_58C         = dword ptr -58Ch
.text$mn:00000A84 var_588         = dword ptr -588h
.text$mn:00000A84 var_584         = dword ptr -584h
.text$mn:00000A84 var_57C         = dword ptr -57Ch
.text$mn:00000A84 var_574         = dword ptr -574h
.text$mn:00000A84 var_570         = dword ptr -570h
.text$mn:00000A84 var_56C         = dword ptr -56Ch
.text$mn:00000A84 var_568         = dword ptr -568h
.text$mn:00000A84 var_564         = dword ptr -564h
.text$mn:00000A84 var_560         = dword ptr -560h
.text$mn:00000A84 var_55C         = dword ptr -55Ch
.text$mn:00000A84 var_558         = dword ptr -558h
.text$mn:00000A84 var_554         = dword ptr -554h
.text$mn:00000A84 Source          = dword ptr -550h
.text$mn:00000A84 var_54C         = dword ptr -54Ch
.text$mn:00000A84 var_548         = dword ptr -548h
.text$mn:00000A84 var_544         = dword ptr -544h
.text$mn:00000A84 var_540         = dword ptr -540h
.text$mn:00000A84 var_53C         = dword ptr -53Ch
.text$mn:00000A84 var_538         = dword ptr -538h
.text$mn:00000A84 var_534         = dword ptr -534h
.text$mn:00000A84 var_530         = byte ptr -530h
.text$mn:00000A84 var_514         = byte ptr -514h
.text$mn:00000A84 var_4F8         = byte ptr -4F8h
.text$mn:00000A84 var_4DC         = byte ptr -4DCh
.text$mn:00000A84 var_4C0         = dword ptr -4C0h
.text$mn:00000A84 var_4A4         = byte ptr -4A4h
.text$mn:00000A84 var_488         = byte ptr -488h
.text$mn:00000A84 var_46C         = byte ptr -46Ch
.text$mn:00000A84 var_450         = byte ptr -450h
.text$mn:00000A84 var_434         = byte ptr -434h
.text$mn:00000A84 var_418         = dword ptr -418h
.text$mn:00000A84 var_3FC         = byte ptr -3FCh
.text$mn:00000A84 var_3E0         = byte ptr -3E0h
.text$mn:00000A84 var_3C4         = byte ptr -3C4h
.text$mn:00000A84 var_3A8         = byte ptr -3A8h
.text$mn:00000A84 var_38C         = byte ptr -38Ch
.text$mn:00000A84 var_370         = byte ptr -370h
.text$mn:00000A84 var_2E4         = dword ptr -2E4h
.text$mn:00000A84 String1         = word ptr -26Ch
.text$mn:00000A84 var_64          = word ptr -64h
.text$mn:00000A84 var_24          = byte ptr -24h
.text$mn:00000A84 var_14          = dword ptr -14h
.text$mn:00000A84 var_10          = dword ptr -10h
.text$mn:00000A84 var_C           = dword ptr -0Ch
.text$mn:00000A84 var_4           = dword ptr -4
.text$mn:00000A84 pszPath         = dword ptr  8
.text$mn:00000A84
.text$mn:00000A84 ; FUNCTION CHUNK AT .text$mn:000016B6 SIZE 0000001E BYTES
.text$mn:00000A84
.text$mn:00000A84                 push    ebp
.text$mn:00000A85                 mov     ebp, esp
.text$mn:00000A87                 push    0FFFFFFFFh
.text$mn:00000A89                 push    offset __ehhandler$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z
.text$mn:00000A8E                 mov     eax, large fs:0
.text$mn:00000A94                 push    eax
.text$mn:00000A95                 push    ecx
.text$mn:00000A96                 sub     esp, 5E8h
.text$mn:00000A9C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AA1                 xor     eax, ebp
.text$mn:00000AA3                 mov     [ebp+var_14], eax
.text$mn:00000AA6                 push    ebx
.text$mn:00000AA7                 push    esi
.text$mn:00000AA8                 push    edi
.text$mn:00000AA9                 push    eax
.text$mn:00000AAA                 lea     eax, [ebp+var_C]
.text$mn:00000AAD                 mov     large fs:0, eax
.text$mn:00000AB3                 mov     [ebp+var_10], esp
.text$mn:00000AB6                 mov     [ebp+var_540], ecx
.text$mn:00000ABC                 mov     eax, [ebp+pszPath]
.text$mn:00000ABF                 push    eax             ; pszPath
.text$mn:00000AC0                 call    dword ptr ds:__imp__PathFindFileNameW@4 ; PathFindFileNameW(x)
.text$mn:00000AC6                 mov     [ebp+var_570], eax
.text$mn:00000ACC                 mov     ecx, [ebp+var_570]
.text$mn:00000AD2                 push    ecx             ; wchar_t *
.text$mn:00000AD3                 mov     ecx, [ebp+var_540] ; this
.text$mn:00000AD9                 call    ?isInLoadedDlls@PluginsManager@@ABE_NPB_W@Z ; PluginsManager::isInLoadedDlls(wchar_t const *)
.text$mn:00000ADE                 movzx   edx, al
.text$mn:00000AE1                 test    edx, edx
.text$mn:00000AE3                 jz      short loc_AEC
.text$mn:00000AE5                 xor     eax, eax
.text$mn:00000AE7                 jmp     loc_16B6
.text$mn:00000AEC ; ---------------------------------------------------------------------------
.text$mn:00000AEC
.text$mn:00000AEC loc_AEC:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+5Fj
.text$mn:00000AEC                 push    44h ; 'D'       ; unsigned int
.text$mn:00000AEE                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000AF3                 add     esp, 4
.text$mn:00000AF6                 mov     [ebp+var_57C], eax
.text$mn:00000AFC                 mov     [ebp+var_4], 0
.text$mn:00000B03                 cmp     [ebp+var_57C], 0
.text$mn:00000B0A                 jz      short loc_B1F
.text$mn:00000B0C                 mov     ecx, [ebp+var_57C] ; this
.text$mn:00000B12                 call    ??0PluginInfo@@QAE@XZ ; PluginInfo::PluginInfo(void)
.text$mn:00000B17                 mov     [ebp+var_588], eax
.text$mn:00000B1D                 jmp     short loc_B29
.text$mn:00000B1F ; ---------------------------------------------------------------------------
.text$mn:00000B1F
.text$mn:00000B1F loc_B1F:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+86j
.text$mn:00000B1F                 mov     [ebp+var_588], 0
.text$mn:00000B29
.text$mn:00000B29 loc_B29:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+99j
.text$mn:00000B29                 mov     eax, [ebp+var_588]
.text$mn:00000B2F                 mov     [ebp+var_5E4], eax
.text$mn:00000B35                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B3C                 mov     ecx, [ebp+var_5E4]
.text$mn:00000B42                 mov     [ebp+var_534], ecx
.text$mn:00000B48                 mov     [ebp+var_4], 1
.text$mn:00000B4F                 mov     edx, [ebp+pszPath]
.text$mn:00000B52                 push    edx             ; pszPath
.text$mn:00000B53                 call    dword ptr ds:__imp__PathFindFileNameW@4 ; PathFindFileNameW(x)
.text$mn:00000B59                 push    eax             ; Str
.text$mn:00000B5A                 mov     ecx, [ebp+var_534]
.text$mn:00000B60                 add     ecx, 28h ; '('
.text$mn:00000B63                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00000B68                 mov     eax, [ebp+pszPath]
.text$mn:00000B6B                 push    eax             ; lpLibFileName
.text$mn:00000B6C                 call    dword ptr ds:__imp__LoadLibraryW@4 ; LoadLibraryW(x)
.text$mn:00000B72                 mov     ecx, [ebp+var_534]
.text$mn:00000B78                 mov     [ecx], eax
.text$mn:00000B7A                 mov     edx, [ebp+var_534]
.text$mn:00000B80                 cmp     dword ptr [edx], 0
.text$mn:00000B83                 jnz     short loc_BA6
.text$mn:00000B85                 push    offset $SG126566 ; "Load Library is failed.\nMake \"Runtime"...
.text$mn:00000B8A                 lea     ecx, [ebp+var_3FC]
.text$mn:00000B90                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000B95                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00000B9A                 lea     eax, [ebp+var_3FC]
.text$mn:00000BA0                 push    eax
.text$mn:00000BA1                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000BA6 ; ---------------------------------------------------------------------------
.text$mn:00000BA6
.text$mn:00000BA6 loc_BA6:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+FFj
.text$mn:00000BA6                 push    offset $SG126568 ; "isUnicode"
.text$mn:00000BAB                 mov     ecx, [ebp+var_534]
.text$mn:00000BB1                 mov     edx, [ecx]
.text$mn:00000BB3                 push    edx             ; hModule
.text$mn:00000BB4                 call    dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
.text$mn:00000BBA                 mov     ecx, [ebp+var_534]
.text$mn:00000BC0                 mov     [ecx+1Ch], eax
.text$mn:00000BC3                 mov     edx, [ebp+var_534]
.text$mn:00000BC9                 cmp     dword ptr [edx+1Ch], 0
.text$mn:00000BCD                 jz      short loc_BDE
.text$mn:00000BCF                 mov     eax, [ebp+var_534]
.text$mn:00000BD5                 mov     ecx, [eax+1Ch]
.text$mn:00000BD8                 call    ecx
.text$mn:00000BDA                 test    eax, eax
.text$mn:00000BDC                 jnz     short loc_BFF
.text$mn:00000BDE
.text$mn:00000BDE loc_BDE:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+149j
.text$mn:00000BDE                 push    offset $SG126573 ; "This ANSI plugin is not compatible with"...
.text$mn:00000BE3                 lea     ecx, [ebp+var_530]
.text$mn:00000BE9                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000BEE                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00000BF3                 lea     edx, [ebp+var_530]
.text$mn:00000BF9                 push    edx
.text$mn:00000BFA                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000BFF ; ---------------------------------------------------------------------------
.text$mn:00000BFF
.text$mn:00000BFF loc_BFF:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+158j
.text$mn:00000BFF                 push    offset $SG126575 ; "setInfo"
.text$mn:00000C04                 mov     eax, [ebp+var_534]
.text$mn:00000C0A                 mov     ecx, [eax]
.text$mn:00000C0C                 push    ecx             ; hModule
.text$mn:00000C0D                 call    dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
.text$mn:00000C13                 mov     edx, [ebp+var_534]
.text$mn:00000C19                 mov     [edx+8], eax
.text$mn:00000C1C                 mov     eax, [ebp+var_534]
.text$mn:00000C22                 cmp     dword ptr [eax+8], 0
.text$mn:00000C26                 jnz     short loc_C49
.text$mn:00000C28                 push    offset $SG126579 ; "Missing \"setInfo\" function"
.text$mn:00000C2D                 lea     ecx, [ebp+var_46C]
.text$mn:00000C33                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000C38                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00000C3D                 lea     ecx, [ebp+var_46C]
.text$mn:00000C43                 push    ecx
.text$mn:00000C44                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000C49 ; ---------------------------------------------------------------------------
.text$mn:00000C49
.text$mn:00000C49 loc_C49:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+1A2j
.text$mn:00000C49                 push    offset $SG126581 ; "getName"
.text$mn:00000C4E                 mov     edx, [ebp+var_534]
.text$mn:00000C54                 mov     eax, [edx]
.text$mn:00000C56                 push    eax             ; hModule
.text$mn:00000C57                 call    dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
.text$mn:00000C5D                 mov     ecx, [ebp+var_534]
.text$mn:00000C63                 mov     [ecx+0Ch], eax
.text$mn:00000C66                 mov     edx, [ebp+var_534]
.text$mn:00000C6C                 cmp     dword ptr [edx+0Ch], 0
.text$mn:00000C70                 jnz     short loc_C93
.text$mn:00000C72                 push    offset $SG126585 ; "Missing \"getName\" function"
.text$mn:00000C77                 lea     ecx, [ebp+var_3C4]
.text$mn:00000C7D                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000C82                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00000C87                 lea     eax, [ebp+var_3C4]
.text$mn:00000C8D                 push    eax
.text$mn:00000C8E                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000C93 ; ---------------------------------------------------------------------------
.text$mn:00000C93
.text$mn:00000C93 loc_C93:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+1ECj
.text$mn:00000C93                 push    offset $SG126587 ; "beNotified"
.text$mn:00000C98                 mov     ecx, [ebp+var_534]
.text$mn:00000C9E                 mov     edx, [ecx]
.text$mn:00000CA0                 push    edx             ; hModule
.text$mn:00000CA1                 call    dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
.text$mn:00000CA7                 mov     ecx, [ebp+var_534]
.text$mn:00000CAD                 mov     [ecx+10h], eax
.text$mn:00000CB0                 mov     edx, [ebp+var_534]
.text$mn:00000CB6                 cmp     dword ptr [edx+10h], 0
.text$mn:00000CBA                 jnz     short loc_CDD
.text$mn:00000CBC                 push    offset $SG126591 ; "Missing \"beNotified\" function"
.text$mn:00000CC1                 lea     ecx, [ebp+var_4DC]
.text$mn:00000CC7                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000CCC                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00000CD1                 lea     eax, [ebp+var_4DC]
.text$mn:00000CD7                 push    eax
.text$mn:00000CD8                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000CDD ; ---------------------------------------------------------------------------
.text$mn:00000CDD
.text$mn:00000CDD loc_CDD:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+236j
.text$mn:00000CDD                 push    offset $SG126593 ; "messageProc"
.text$mn:00000CE2                 mov     ecx, [ebp+var_534]
.text$mn:00000CE8                 mov     edx, [ecx]
.text$mn:00000CEA                 push    edx             ; hModule
.text$mn:00000CEB                 call    dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
.text$mn:00000CF1                 mov     ecx, [ebp+var_534]
.text$mn:00000CF7                 mov     [ecx+18h], eax
.text$mn:00000CFA                 mov     edx, [ebp+var_534]
.text$mn:00000D00                 cmp     dword ptr [edx+18h], 0
.text$mn:00000D04                 jnz     short loc_D27
.text$mn:00000D06                 push    offset $SG126597 ; "Missing \"messageProc\" function"
.text$mn:00000D0B                 lea     ecx, [ebp+var_370]
.text$mn:00000D11                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000D16                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00000D1B                 lea     eax, [ebp+var_370]
.text$mn:00000D21                 push    eax
.text$mn:00000D22                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000D27 ; ---------------------------------------------------------------------------
.text$mn:00000D27
.text$mn:00000D27 loc_D27:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+280j
.text$mn:00000D27                 mov     ecx, [ebp+var_540]
.text$mn:00000D2D                 sub     esp, 0Ch
.text$mn:00000D30                 mov     edx, esp
.text$mn:00000D32                 mov     eax, [ecx]
.text$mn:00000D34                 mov     [edx], eax
.text$mn:00000D36                 mov     eax, [ecx+4]
.text$mn:00000D39                 mov     [edx+4], eax
.text$mn:00000D3C                 mov     ecx, [ecx+8]
.text$mn:00000D3F                 mov     [edx+8], ecx
.text$mn:00000D42                 mov     edx, [ebp+var_534]
.text$mn:00000D48                 mov     eax, [edx+8]
.text$mn:00000D4B                 call    eax
.text$mn:00000D4D                 add     esp, 0Ch
.text$mn:00000D50                 push    offset $SG126599 ; "getFuncsArray"
.text$mn:00000D55                 mov     ecx, [ebp+var_534]
.text$mn:00000D5B                 mov     edx, [ecx]
.text$mn:00000D5D                 push    edx             ; hModule
.text$mn:00000D5E                 call    dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
.text$mn:00000D64                 mov     ecx, [ebp+var_534]
.text$mn:00000D6A                 mov     [ecx+14h], eax
.text$mn:00000D6D                 mov     edx, [ebp+var_534]
.text$mn:00000D73                 cmp     dword ptr [edx+14h], 0
.text$mn:00000D77                 jnz     short loc_D9A
.text$mn:00000D79                 push    offset $SG126603 ; "Missing \"getFuncsArray\" function"
.text$mn:00000D7E                 lea     ecx, [ebp+var_4A4]
.text$mn:00000D84                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000D89                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00000D8E                 lea     eax, [ebp+var_4A4]
.text$mn:00000D94                 push    eax
.text$mn:00000D95                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000D9A ; ---------------------------------------------------------------------------
.text$mn:00000D9A
.text$mn:00000D9A loc_D9A:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+2F3j
.text$mn:00000D9A                 mov     ecx, [ebp+var_534]
.text$mn:00000DA0                 add     ecx, 24h ; '$'
.text$mn:00000DA3                 push    ecx
.text$mn:00000DA4                 mov     edx, [ebp+var_534]
.text$mn:00000DAA                 mov     eax, [edx+14h]
.text$mn:00000DAD                 call    eax
.text$mn:00000DAF                 add     esp, 4
.text$mn:00000DB2                 mov     ecx, [ebp+var_534]
.text$mn:00000DB8                 mov     [ecx+20h], eax
.text$mn:00000DBB                 mov     edx, [ebp+var_534]
.text$mn:00000DC1                 cmp     dword ptr [edx+20h], 0
.text$mn:00000DC5                 jz      short loc_DD3
.text$mn:00000DC7                 mov     eax, [ebp+var_534]
.text$mn:00000DCD                 cmp     dword ptr [eax+24h], 0
.text$mn:00000DD1                 jg      short loc_DF4
.text$mn:00000DD3
.text$mn:00000DD3 loc_DD3:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+341j
.text$mn:00000DD3                 push    offset $SG126608 ; "Missing \"FuncItems\" array, or the nb "...
.text$mn:00000DD8                 lea     ecx, [ebp+var_434]
.text$mn:00000DDE                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000DE3                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00000DE8                 lea     ecx, [ebp+var_434]
.text$mn:00000DEE                 push    ecx
.text$mn:00000DEF                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000DF4 ; ---------------------------------------------------------------------------
.text$mn:00000DF4
.text$mn:00000DF4 loc_DF4:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+34Dj
.text$mn:00000DF4                 call    dword ptr ds:__imp__CreateMenu@0 ; CreateMenu()
.text$mn:00000DFA                 mov     edx, [ebp+var_534]
.text$mn:00000E00                 mov     [edx+4], eax
.text$mn:00000E03                 push    offset $SG126611 ; "GetLexerCount"
.text$mn:00000E08                 mov     eax, [ebp+var_534]
.text$mn:00000E0E                 mov     ecx, [eax]
.text$mn:00000E10                 push    ecx             ; hModule
.text$mn:00000E11                 call    dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
.text$mn:00000E17                 mov     [ebp+var_55C], eax
.text$mn:00000E1D                 cmp     [ebp+var_55C], 0
.text$mn:00000E24                 jz      loc_1437
.text$mn:00000E2A                 push    offset $SG126615 ; "GetLexerName"
.text$mn:00000E2F                 mov     edx, [ebp+var_534]
.text$mn:00000E35                 mov     eax, [edx]
.text$mn:00000E37                 push    eax             ; hModule
.text$mn:00000E38                 call    dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
.text$mn:00000E3E                 mov     [ebp+var_584], eax
.text$mn:00000E44                 cmp     [ebp+var_584], 0
.text$mn:00000E4B                 jnz     short loc_E6E
.text$mn:00000E4D                 push    offset $SG126619 ; "Loading GetLexerName function failed."
.text$mn:00000E52                 lea     ecx, [ebp+var_514]
.text$mn:00000E58                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000E5D                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00000E62                 lea     ecx, [ebp+var_514]
.text$mn:00000E68                 push    ecx
.text$mn:00000E69                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000E6E ; ---------------------------------------------------------------------------
.text$mn:00000E6E
.text$mn:00000E6E loc_E6E:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+3C7j
.text$mn:00000E6E                 push    offset $SG126622 ; "GetLexerStatusText"
.text$mn:00000E73                 mov     edx, [ebp+var_534]
.text$mn:00000E79                 mov     eax, [edx]
.text$mn:00000E7B                 push    eax             ; hModule
.text$mn:00000E7C                 call    dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
.text$mn:00000E82                 mov     [ebp+var_564], eax
.text$mn:00000E88                 cmp     [ebp+var_564], 0
.text$mn:00000E8F                 jnz     short loc_EB2
.text$mn:00000E91                 push    offset $SG126626 ; "Loading GetLexerStatusText function fai"...
.text$mn:00000E96                 lea     ecx, [ebp+var_38C]
.text$mn:00000E9C                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000EA1                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00000EA6                 lea     ecx, [ebp+var_38C]
.text$mn:00000EAC                 push    ecx
.text$mn:00000EAD                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000EB2 ; ---------------------------------------------------------------------------
.text$mn:00000EB2
.text$mn:00000EB2 loc_EB2:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+40Bj
.text$mn:00000EB2                 mov     edx, 1
.text$mn:00000EB7                 imul    eax, edx, 0
.text$mn:00000EBA                 mov     [ebp+var_590], eax
.text$mn:00000EC0                 cmp     [ebp+var_590], 10h
.text$mn:00000EC7                 jnb     short loc_ECB
.text$mn:00000EC9                 jmp     short loc_ED0
.text$mn:00000ECB ; ---------------------------------------------------------------------------
.text$mn:00000ECB
.text$mn:00000ECB loc_ECB:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+443j
.text$mn:00000ECB                 call    ___report_rangecheckfailure
.text$mn:00000ED0
.text$mn:00000ED0 loc_ED0:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+445j
.text$mn:00000ED0                 mov     ecx, [ebp+var_590]
.text$mn:00000ED6                 mov     [ebp+ecx+var_24], 0
.text$mn:00000EDB                 mov     edx, 2
.text$mn:00000EE0                 imul    eax, edx, 0
.text$mn:00000EE3                 mov     [ebp+var_574], eax
.text$mn:00000EE9                 cmp     [ebp+var_574], 40h ; '@'
.text$mn:00000EF0                 jnb     short loc_EF4
.text$mn:00000EF2                 jmp     short loc_EF9
.text$mn:00000EF4 ; ---------------------------------------------------------------------------
.text$mn:00000EF4
.text$mn:00000EF4 loc_EF4:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+46Cj
.text$mn:00000EF4                 call    ___report_rangecheckfailure
.text$mn:00000EF9
.text$mn:00000EF9 loc_EF9:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+46Ej
.text$mn:00000EF9                 xor     ecx, ecx
.text$mn:00000EFB                 mov     edx, [ebp+var_574]
.text$mn:00000F01                 mov     [ebp+edx+var_64], cx
.text$mn:00000F06                 call    [ebp+var_55C]
.text$mn:00000F0C                 mov     [ebp+var_560], eax
.text$mn:00000F12                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000F17                 mov     [ebp+var_538], eax
.text$mn:00000F1D                 call    ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ ; WcharMbcsConvertor::getInstance(void)
.text$mn:00000F22                 mov     [ebp+var_568], eax
.text$mn:00000F28                 mov     [ebp+var_53C], 0
.text$mn:00000F32                 jmp     short loc_F43
.text$mn:00000F34 ; ---------------------------------------------------------------------------
.text$mn:00000F34
.text$mn:00000F34 loc_F34:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_103Ej
.text$mn:00000F34                 mov     eax, [ebp+var_53C]
.text$mn:00000F3A                 add     eax, 1
.text$mn:00000F3D                 mov     [ebp+var_53C], eax
.text$mn:00000F43
.text$mn:00000F43 loc_F43:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+4AEj
.text$mn:00000F43                 mov     ecx, [ebp+var_53C]
.text$mn:00000F49                 cmp     ecx, [ebp+var_560]
.text$mn:00000F4F                 jge     loc_1043
.text$mn:00000F55                 push    10h
.text$mn:00000F57                 lea     edx, [ebp+var_24]
.text$mn:00000F5A                 push    edx
.text$mn:00000F5B                 mov     eax, [ebp+var_53C]
.text$mn:00000F61                 push    eax
.text$mn:00000F62                 call    [ebp+var_584]
.text$mn:00000F68                 push    20h ; ' '
.text$mn:00000F6A                 lea     ecx, [ebp+var_64]
.text$mn:00000F6D                 push    ecx
.text$mn:00000F6E                 mov     edx, [ebp+var_53C]
.text$mn:00000F74                 push    edx
.text$mn:00000F75                 call    [ebp+var_564]
.text$mn:00000F7B                 push    0               ; int *
.text$mn:00000F7D                 push    0               ; int *
.text$mn:00000F7F                 push    0FFFFFFFFh      ; int
.text$mn:00000F81                 push    0               ; unsigned int
.text$mn:00000F83                 lea     eax, [ebp+var_24]
.text$mn:00000F86                 push    eax             ; char *
.text$mn:00000F87                 mov     ecx, [ebp+var_568] ; this
.text$mn:00000F8D                 call    ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)
.text$mn:00000F92                 mov     [ebp+Source], eax
.text$mn:00000F98                 mov     ecx, [ebp+Source]
.text$mn:00000F9E                 push    ecx             ; wchar_t *
.text$mn:00000F9F                 mov     ecx, [ebp+var_538] ; this
.text$mn:00000FA5                 call    ?isExistingExternalLangName@NppParameters@@QBE_NPB_W@Z ; NppParameters::isExistingExternalLangName(wchar_t const *)
.text$mn:00000FAA                 movzx   edx, al
.text$mn:00000FAD                 test    edx, edx
.text$mn:00000FAF                 jnz     short loc_102D
.text$mn:00000FB1                 mov     ecx, [ebp+var_538] ; this
.text$mn:00000FB7                 call    ?ExternalLangHasRoom@NppParameters@@QBE_NXZ ; NppParameters::ExternalLangHasRoom(void)
.text$mn:00000FBC                 movzx   eax, al
.text$mn:00000FBF                 test    eax, eax
.text$mn:00000FC1                 jz      short loc_102D
.text$mn:00000FC3                 push    60h ; '`'       ; unsigned int
.text$mn:00000FC5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000FCA                 add     esp, 4
.text$mn:00000FCD                 mov     [ebp+var_56C], eax
.text$mn:00000FD3                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000FD7                 cmp     [ebp+var_56C], 0
.text$mn:00000FDE                 jz      short loc_FFE
.text$mn:00000FE0                 lea     ecx, [ebp+var_64]
.text$mn:00000FE3                 push    ecx             ; wchar_t *
.text$mn:00000FE4                 mov     edx, [ebp+Source]
.text$mn:00000FEA                 push    edx             ; Source
.text$mn:00000FEB                 mov     ecx, [ebp+var_56C] ; this
.text$mn:00000FF1                 call    ??0ExternalLangContainer@@QAE@PB_W0@Z ; ExternalLangContainer::ExternalLangContainer(wchar_t const *,wchar_t const *)
.text$mn:00000FF6                 mov     [ebp+var_58C], eax
.text$mn:00000FFC                 jmp     short loc_1008
.text$mn:00000FFE ; ---------------------------------------------------------------------------
.text$mn:00000FFE
.text$mn:00000FFE loc_FFE:                                ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+55Aj
.text$mn:00000FFE                 mov     [ebp+var_58C], 0
.text$mn:00001008
.text$mn:00001008 loc_1008:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+578j
.text$mn:00001008                 mov     eax, [ebp+var_58C]
.text$mn:0000100E                 mov     [ebp+var_5EC], eax
.text$mn:00001014                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001018                 mov     ecx, [ebp+var_53C]
.text$mn:0000101E                 mov     edx, [ebp+var_5EC]
.text$mn:00001024                 mov     [ebp+ecx*4+var_2E4], edx
.text$mn:0000102B                 jmp     short loc_103E
.text$mn:0000102D ; ---------------------------------------------------------------------------
.text$mn:0000102D
.text$mn:0000102D loc_102D:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+52Bj
.text$mn:0000102D                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+53Dj
.text$mn:0000102D                 mov     eax, [ebp+var_53C]
.text$mn:00001033                 mov     [ebp+eax*4+var_2E4], 0
.text$mn:0000103E
.text$mn:0000103E loc_103E:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+5A7j
.text$mn:0000103E                 jmp     loc_F34
.text$mn:00001043 ; ---------------------------------------------------------------------------
.text$mn:00001043
.text$mn:00001043 loc_1043:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+4CBj
.text$mn:00001043                 lea     ecx, [ebp+var_3A8]
.text$mn:00001049                 push    ecx
.text$mn:0000104A                 mov     ecx, [ebp+var_538]
.text$mn:00001050                 call    ?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; NppParameters::getNppPath(void)
.text$mn:00001055                 mov     [ebp+var_5E8], eax
.text$mn:0000105B                 mov     edx, [ebp+var_5E8]
.text$mn:00001061                 mov     [ebp+var_59C], edx
.text$mn:00001067                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000106B                 mov     ecx, [ebp+var_59C]
.text$mn:00001071                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001076                 push    eax             ; lpString2
.text$mn:00001077                 lea     eax, [ebp+String1]
.text$mn:0000107D                 push    eax             ; lpString1
.text$mn:0000107E                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:00001084                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001088                 lea     ecx, [ebp+var_3A8]
.text$mn:0000108E                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001093                 push    offset $SG126648 ; "plugins\\Config"
.text$mn:00001098                 lea     ecx, [ebp+String1]
.text$mn:0000109E                 push    ecx             ; pszPath
.text$mn:0000109F                 call    dword ptr ds:__imp__PathAppendW@8 ; PathAppendW(x,x)
.text$mn:000010A5                 mov     ecx, [ebp+var_534]
.text$mn:000010AB                 add     ecx, 28h ; '('
.text$mn:000010AE                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000010B3                 push    eax             ; pMore
.text$mn:000010B4                 lea     edx, [ebp+String1]
.text$mn:000010BA                 push    edx             ; pszPath
.text$mn:000010BB                 call    dword ptr ds:__imp__PathAppendW@8 ; PathAppendW(x,x)
.text$mn:000010C1                 lea     eax, [ebp+String1]
.text$mn:000010C7                 push    eax             ; pszPath
.text$mn:000010C8                 call    dword ptr ds:__imp__PathRemoveExtensionW@4 ; PathRemoveExtensionW(x)
.text$mn:000010CE                 push    offset $SG126649 ; ".xml"
.text$mn:000010D3                 lea     ecx, [ebp+String1]
.text$mn:000010D9                 push    ecx             ; pszPath
.text$mn:000010DA                 call    dword ptr ds:__imp__PathAddExtensionW@8 ; PathAddExtensionW(x,x)
.text$mn:000010E0                 lea     edx, [ebp+String1]
.text$mn:000010E6                 push    edx             ; pszPath
.text$mn:000010E7                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:000010ED                 test    eax, eax
.text$mn:000010EF                 jnz     loc_1221
.text$mn:000010F5                 push    104h            ; iMaxLength
.text$mn:000010FA                 push    offset $SG126651 ; lpString2
.text$mn:000010FF                 lea     eax, [ebp+String1]
.text$mn:00001105                 push    eax             ; lpString1
.text$mn:00001106                 call    dword ptr ds:__imp__lstrcpynW@12 ; lstrcpynW(x,x,x)
.text$mn:0000110C                 mov     ecx, [ebp+var_538] ; this
.text$mn:00001112                 call    ?getAppDataNppDir@NppParameters@@QBEPB_WXZ ; NppParameters::getAppDataNppDir(void)
.text$mn:00001117                 push    eax             ; lpString2
.text$mn:00001118                 lea     ecx, [ebp+String1]
.text$mn:0000111E                 push    ecx             ; lpString1
.text$mn:0000111F                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:00001125                 push    offset $SG126652 ; "plugins\\Config"
.text$mn:0000112A                 lea     edx, [ebp+String1]
.text$mn:00001130                 push    edx             ; pszPath
.text$mn:00001131                 call    dword ptr ds:__imp__PathAppendW@8 ; PathAppendW(x,x)
.text$mn:00001137                 mov     ecx, [ebp+var_534]
.text$mn:0000113D                 add     ecx, 28h ; '('
.text$mn:00001140                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001145                 push    eax             ; pMore
.text$mn:00001146                 lea     eax, [ebp+String1]
.text$mn:0000114C                 push    eax             ; pszPath
.text$mn:0000114D                 call    dword ptr ds:__imp__PathAppendW@8 ; PathAppendW(x,x)
.text$mn:00001153                 lea     ecx, [ebp+String1]
.text$mn:00001159                 push    ecx             ; pszPath
.text$mn:0000115A                 call    dword ptr ds:__imp__PathRemoveExtensionW@4 ; PathRemoveExtensionW(x)
.text$mn:00001160                 push    offset $SG126653 ; ".xml"
.text$mn:00001165                 lea     edx, [ebp+String1]
.text$mn:0000116B                 push    edx             ; pszPath
.text$mn:0000116C                 call    dword ptr ds:__imp__PathAddExtensionW@8 ; PathAddExtensionW(x,x)
.text$mn:00001172                 lea     eax, [ebp+String1]
.text$mn:00001178                 push    eax             ; pszPath
.text$mn:00001179                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:0000117F                 test    eax, eax
.text$mn:00001181                 jnz     loc_1221
.text$mn:00001187                 push    offset $SG126685 ; " is missing."
.text$mn:0000118C                 lea     ecx, [ebp+String1]
.text$mn:00001192                 push    ecx             ; Str
.text$mn:00001193                 lea     ecx, [ebp+var_450]
.text$mn:00001199                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000119E                 mov     [ebp+var_5DC], eax
.text$mn:000011A4                 mov     edx, [ebp+var_5DC]
.text$mn:000011AA                 mov     [ebp+var_5A4], edx
.text$mn:000011B0                 mov     byte ptr [ebp+var_4], 4
.text$mn:000011B4                 mov     eax, [ebp+var_5A4]
.text$mn:000011BA                 push    eax             ; int
.text$mn:000011BB                 lea     ecx, [ebp+var_418]
.text$mn:000011C1                 push    ecx             ; int
.text$mn:000011C2                 call    ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&,wchar_t const *)
.text$mn:000011C7                 add     esp, 0Ch
.text$mn:000011CA                 mov     [ebp+var_5CC], eax
.text$mn:000011D0                 mov     edx, [ebp+var_5CC]
.text$mn:000011D6                 mov     [ebp+var_5AC], edx
.text$mn:000011DC                 mov     byte ptr [ebp+var_4], 5
.text$mn:000011E0                 mov     eax, [ebp+var_5AC]
.text$mn:000011E6                 push    eax
.text$mn:000011E7                 lea     ecx, [ebp+var_3E0]
.text$mn:000011ED                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000011F2                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:000011F7                 lea     ecx, [ebp+var_3E0]
.text$mn:000011FD                 push    ecx
.text$mn:000011FE                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001203 ; ---------------------------------------------------------------------------
.text$mn:00001203                 mov     byte ptr [ebp+var_4], 4
.text$mn:00001207                 lea     ecx, [ebp+var_418]
.text$mn:0000120D                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001212                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001216                 lea     ecx, [ebp+var_450]
.text$mn:0000121C                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001221
.text$mn:00001221 loc_1221:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+66Bj
.text$mn:00001221                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+6FDj
.text$mn:00001221                 push    74h ; 't'       ; unsigned int
.text$mn:00001223                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001228                 add     esp, 4
.text$mn:0000122B                 mov     [ebp+var_554], eax
.text$mn:00001231                 mov     byte ptr [ebp+var_4], 6
.text$mn:00001235                 cmp     [ebp+var_554], 0
.text$mn:0000123C                 jz      short loc_1258
.text$mn:0000123E                 lea     edx, [ebp+String1]
.text$mn:00001244                 push    edx             ; wchar_t *
.text$mn:00001245                 mov     ecx, [ebp+var_554] ; this
.text$mn:0000124B                 call    ??0TiXmlDocument@@QAE@PB_W@Z ; TiXmlDocument::TiXmlDocument(wchar_t const *)
.text$mn:00001250                 mov     [ebp+var_558], eax
.text$mn:00001256                 jmp     short loc_1262
.text$mn:00001258 ; ---------------------------------------------------------------------------
.text$mn:00001258
.text$mn:00001258 loc_1258:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+7B8j
.text$mn:00001258                 mov     [ebp+var_558], 0
.text$mn:00001262
.text$mn:00001262 loc_1262:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+7D2j
.text$mn:00001262                 mov     eax, [ebp+var_558]
.text$mn:00001268                 mov     [ebp+var_5E0], eax
.text$mn:0000126E                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001272                 mov     ecx, [ebp+var_5E0]
.text$mn:00001278                 mov     [ebp+var_544], ecx
.text$mn:0000127E                 mov     ecx, [ebp+var_544] ; this
.text$mn:00001284                 call    ?LoadFile@TiXmlDocument@@QAE_NXZ ; TiXmlDocument::LoadFile(void)
.text$mn:00001289                 movzx   edx, al
.text$mn:0000128C                 test    edx, edx
.text$mn:0000128E                 jnz     loc_137F
.text$mn:00001294                 mov     eax, [ebp+var_544]
.text$mn:0000129A                 mov     [ebp+var_5B4], eax
.text$mn:000012A0                 mov     ecx, [ebp+var_5B4]
.text$mn:000012A6                 mov     [ebp+var_54C], ecx
.text$mn:000012AC                 cmp     [ebp+var_54C], 0
.text$mn:000012B3                 jz      short loc_12D1
.text$mn:000012B5                 push    1
.text$mn:000012B7                 mov     edx, [ebp+var_54C]
.text$mn:000012BD                 mov     eax, [edx]
.text$mn:000012BF                 mov     ecx, [ebp+var_54C]
.text$mn:000012C5                 mov     edx, [eax]
.text$mn:000012C7                 call    edx
.text$mn:000012C9                 mov     [ebp+var_5D4], eax
.text$mn:000012CF                 jmp     short loc_12DB
.text$mn:000012D1 ; ---------------------------------------------------------------------------
.text$mn:000012D1
.text$mn:000012D1 loc_12D1:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+82Fj
.text$mn:000012D1                 mov     [ebp+var_5D4], 0
.text$mn:000012DB
.text$mn:000012DB loc_12DB:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+84Bj
.text$mn:000012DB                 mov     [ebp+var_544], 0
.text$mn:000012E5                 push    offset $SG126698 ; " failed to load."
.text$mn:000012EA                 lea     eax, [ebp+String1]
.text$mn:000012F0                 push    eax             ; Str
.text$mn:000012F1                 lea     ecx, [ebp+var_4F8]
.text$mn:000012F7                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000012FC                 mov     [ebp+var_5BC], eax
.text$mn:00001302                 mov     ecx, [ebp+var_5BC]
.text$mn:00001308                 mov     [ebp+var_594], ecx
.text$mn:0000130E                 mov     byte ptr [ebp+var_4], 7
.text$mn:00001312                 mov     edx, [ebp+var_594]
.text$mn:00001318                 push    edx             ; int
.text$mn:00001319                 lea     eax, [ebp+var_4C0]
.text$mn:0000131F                 push    eax             ; int
.text$mn:00001320                 call    ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&,wchar_t const *)
.text$mn:00001325                 add     esp, 0Ch
.text$mn:00001328                 mov     [ebp+var_5C4], eax
.text$mn:0000132E                 mov     ecx, [ebp+var_5C4]
.text$mn:00001334                 mov     [ebp+var_598], ecx
.text$mn:0000133A                 mov     byte ptr [ebp+var_4], 8
.text$mn:0000133E                 mov     edx, [ebp+var_598]
.text$mn:00001344                 push    edx
.text$mn:00001345                 lea     ecx, [ebp+var_488]
.text$mn:0000134B                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001350                 push    offset __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.text$mn:00001355                 lea     eax, [ebp+var_488]
.text$mn:0000135B                 push    eax
.text$mn:0000135C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001361 ; ---------------------------------------------------------------------------
.text$mn:00001361                 mov     byte ptr [ebp+var_4], 7
.text$mn:00001365                 lea     ecx, [ebp+var_4C0]
.text$mn:0000136B                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001370                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001374                 lea     ecx, [ebp+var_4F8]
.text$mn:0000137A                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000137F
.text$mn:0000137F loc_137F:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+80Aj
.text$mn:0000137F                                         ; DATA XREF: Shortcut::doDialog(void)+17o
.text$mn:0000137F                 mov     [ebp+var_548], 0
.text$mn:00001389                 jmp     short loc_139A
.text$mn:0000138B ; ---------------------------------------------------------------------------
.text$mn:0000138B
.text$mn:0000138B loc_138B:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_13D1j
.text$mn:0000138B                 mov     ecx, [ebp+var_548]
.text$mn:00001391                 add     ecx, 1
.text$mn:00001394                 mov     [ebp+var_548], ecx
.text$mn:0000139A
.text$mn:0000139A loc_139A:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+905j
.text$mn:0000139A                 mov     edx, [ebp+var_548]
.text$mn:000013A0                 cmp     edx, [ebp+var_560]
.text$mn:000013A6                 jge     short loc_13D3
.text$mn:000013A8                 mov     eax, [ebp+var_548]
.text$mn:000013AE                 cmp     [ebp+eax*4+var_2E4], 0
.text$mn:000013B6                 jz      short loc_13D1
.text$mn:000013B8                 mov     ecx, [ebp+var_548]
.text$mn:000013BE                 mov     edx, [ebp+ecx*4+var_2E4]
.text$mn:000013C5                 push    edx             ; struct ExternalLangContainer *
.text$mn:000013C6                 mov     ecx, [ebp+var_538] ; this
.text$mn:000013CC                 call    ?addExternalLangToEnd@NppParameters@@QAEHPAVExternalLangContainer@@@Z ; NppParameters::addExternalLangToEnd(ExternalLangContainer *)
.text$mn:000013D1
.text$mn:000013D1 loc_13D1:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+932j
.text$mn:000013D1                 jmp     short loc_138B
.text$mn:000013D3 ; ---------------------------------------------------------------------------
.text$mn:000013D3
.text$mn:000013D3 loc_13D3:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+922j
.text$mn:000013D3                 mov     eax, [ebp+var_544]
.text$mn:000013D9                 push    eax             ; struct TiXmlDocument *
.text$mn:000013DA                 mov     ecx, [ebp+var_538] ; this
.text$mn:000013E0                 call    ?getExternalLexerFromXmlTree@NppParameters@@QAEXPAVTiXmlDocument@@@Z ; NppParameters::getExternalLexerFromXmlTree(TiXmlDocument *)
.text$mn:000013E5                 lea     ecx, [ebp+var_544]
.text$mn:000013EB                 push    ecx
.text$mn:000013EC                 mov     ecx, [ebp+var_538]
.text$mn:000013F2                 call    ?getExternalLexerDoc@NppParameters@@QAEPAV?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@XZ ; NppParameters::getExternalLexerDoc(void)
.text$mn:000013F7                 mov     ecx, eax
.text$mn:000013F9                 call    ?push_back@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXABQAVTiXmlDocument@@@Z ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)
.text$mn:000013FE                 push    0               ; int *
.text$mn:00001400                 push    0FFFFFFFFh      ; int
.text$mn:00001402                 push    0               ; unsigned int
.text$mn:00001404                 mov     edx, [ebp+pszPath]
.text$mn:00001407                 push    edx             ; wchar_t *
.text$mn:00001408                 mov     ecx, [ebp+var_568] ; this
.text$mn:0000140E                 call    ?wchar2char@WcharMbcsConvertor@@QAEPBDPB_WIHPAH@Z ; WcharMbcsConvertor::wchar2char(wchar_t const *,uint,int,int *)
.text$mn:00001413                 mov     [ebp+lParam], eax
.text$mn:00001419                 mov     eax, [ebp+lParam]
.text$mn:0000141F                 push    eax             ; lParam
.text$mn:00001420                 push    0               ; wParam
.text$mn:00001422                 push    0FA7h           ; Msg
.text$mn:00001427                 mov     ecx, [ebp+var_540]
.text$mn:0000142D                 mov     edx, [ecx+4]
.text$mn:00001430                 push    edx             ; hWnd
.text$mn:00001431                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001437
.text$mn:00001437 loc_1437:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+3A0j
.text$mn:00001437                 mov     eax, [ebp+var_570]
.text$mn:0000143D                 push    eax             ; wchar_t *
.text$mn:0000143E                 mov     ecx, [ebp+var_540] ; this
.text$mn:00001444                 call    ?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z ; PluginsManager::addInLoadedDlls(wchar_t const *)
.text$mn:00001449                 lea     ecx, [ebp+var_534]
.text$mn:0000144F                 push    ecx
.text$mn:00001450                 mov     ecx, [ebp+var_540]
.text$mn:00001456                 add     ecx, 10h
.text$mn:00001459                 call    ?push_back@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXABQAUPluginInfo@@@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)
.text$mn:0000145E                 mov     ecx, [ebp+var_540]
.text$mn:00001464                 add     ecx, 10h
.text$mn:00001467                 call    ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::size(void)
.text$mn:0000146C                 sub     eax, 1
.text$mn:0000146F                 jmp     loc_16B6
.text$mn:0000146F ?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z endp
.text$mn:0000146F
.text$mn:00001474
.text$mn:00001474 ; =============== S U B R O U T I N E =======================================
.text$mn:00001474
.text$mn:00001474
.text$mn:00001474 __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$0 proc near
.text$mn:00001474                                         ; DATA XREF: .xdata$x:0000D328o
.text$mn:00001474                 mov     byte ptr [ebp-4], 0Ah
.text$mn:00001478                 push    0               ; uType
.text$mn:0000147A                 push    offset $SG126707 ; "Exception"
.text$mn:0000147F                 lea     ecx, [ebp-5F8h] ; this
.text$mn:00001485                 call    ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.text$mn:0000148A                 push    eax             ; lpText
.text$mn:0000148B                 push    0               ; hWnd
.text$mn:0000148D                 call    dword ptr ds:__imp__MessageBoxA@16 ; MessageBoxA(x,x,x,x)
.text$mn:00001493                 mov     dword ptr [ebp-5D8h], 0FFFFFFFFh
.text$mn:0000149D                 mov     byte ptr [ebp-4], 9
.text$mn:000014A1                 lea     ecx, [ebp-5F8h] ; this
.text$mn:000014A7                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:000014AC                 mov     eax, offset $LN66
.text$mn:000014B1                 retn
.text$mn:000014B1 __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$0 endp
.text$mn:000014B1
.text$mn:000014B2 ; ---------------------------------------------------------------------------
.text$mn:000014B2                 mov     eax, offset __tryend$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$3
.text$mn:000014B7                 retn
.text$mn:000014B8
.text$mn:000014B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014B8
.text$mn:000014B8
.text$mn:000014B8 __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1 proc near
.text$mn:000014B8                                         ; DATA XREF: .xdata$x:0000D338o
.text$mn:000014B8                 mov     byte ptr [ebp-4], 0Bh
.text$mn:000014BC                 push    offset $SG126710 ; "\n\n"
.text$mn:000014C1                 lea     ecx, [ebp-31Ch]
.text$mn:000014C7                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000014CC                 mov     edx, ?USERMSG@@3PB_WB ; wchar_t const * const USERMSG
.text$mn:000014D2                 push    edx             ; Str
.text$mn:000014D3                 lea     ecx, [ebp-31Ch]
.text$mn:000014D9                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000014DE                 push    4               ; uType
.text$mn:000014E0                 mov     eax, [ebp+8]
.text$mn:000014E3                 push    eax             ; lpCaption
.text$mn:000014E4                 lea     ecx, [ebp-31Ch]
.text$mn:000014EA                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000014EF                 push    eax             ; lpText
.text$mn:000014F0                 push    0               ; hWnd
.text$mn:000014F2                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:000014F8                 cmp     eax, 6
.text$mn:000014FB                 jnz     short loc_152E
.text$mn:000014FD                 mov     ecx, [ebp+8]
.text$mn:00001500                 push    ecx             ; Str
.text$mn:00001501                 lea     ecx, [ebp-354h]
.text$mn:00001507                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000150C                 mov     byte ptr [ebp-4], 0Ch
.text$mn:00001510                 lea     edx, [ebp-354h]
.text$mn:00001516                 push    edx
.text$mn:00001517                 mov     ecx, [ebp+0Ch]
.text$mn:0000151A                 call    ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000151F                 mov     byte ptr [ebp-4], 0Bh
.text$mn:00001523                 lea     ecx, [ebp-354h]
.text$mn:00001529                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000152E
.text$mn:0000152E loc_152E:                               ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+43j
.text$mn:0000152E                 mov     eax, [ebp-534h]
.text$mn:00001534                 mov     [ebp-5A8h], eax
.text$mn:0000153A                 mov     ecx, [ebp-5A8h]
.text$mn:00001540                 mov     [ebp-578h], ecx
.text$mn:00001546                 cmp     dword ptr [ebp-578h], 0
.text$mn:0000154D                 jz      short loc_1564
.text$mn:0000154F                 push    1
.text$mn:00001551                 mov     ecx, [ebp-578h]
.text$mn:00001557                 call    ??_GPluginInfo@@QAEPAXI@Z ; PluginInfo::`scalar deleting destructor'(uint)
.text$mn:0000155C                 mov     [ebp-5B0h], eax
.text$mn:00001562                 jmp     short loc_156E
.text$mn:00001564 ; ---------------------------------------------------------------------------
.text$mn:00001564
.text$mn:00001564 loc_1564:                               ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+95j
.text$mn:00001564                 mov     dword ptr [ebp-5B0h], 0
.text$mn:0000156E
.text$mn:0000156E loc_156E:                               ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+AAj
.text$mn:0000156E                 mov     dword ptr [ebp-5D0h], 0FFFFFFFFh
.text$mn:00001578                 mov     byte ptr [ebp-4], 9
.text$mn:0000157C                 lea     ecx, [ebp-31Ch]
.text$mn:00001582                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001587                 mov     eax, offset $LN68
.text$mn:0000158C                 retn
.text$mn:0000158C __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1 endp
.text$mn:0000158C
.text$mn:0000158D ; ---------------------------------------------------------------------------
.text$mn:0000158D                 mov     eax, offset __tryend$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$3
.text$mn:00001592                 retn
.text$mn:00001593
.text$mn:00001593 ; =============== S U B R O U T I N E =======================================
.text$mn:00001593
.text$mn:00001593
.text$mn:00001593 __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2 proc near
.text$mn:00001593                                         ; DATA XREF: .xdata$x:0000D348o
.text$mn:00001593                 push    offset $SG126717 ; "Failed to load"
.text$mn:00001598                 lea     ecx, [ebp-300h]
.text$mn:0000159E                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000015A3                 mov     byte ptr [ebp-4], 0Dh
.text$mn:000015A7                 push    offset $SG126718 ; "\n\n"
.text$mn:000015AC                 lea     ecx, [ebp-300h]
.text$mn:000015B2                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000015B7                 mov     edx, ?USERMSG@@3PB_WB ; wchar_t const * const USERMSG
.text$mn:000015BD                 push    edx             ; Str
.text$mn:000015BE                 lea     ecx, [ebp-300h]
.text$mn:000015C4                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000015C9                 push    4               ; uType
.text$mn:000015CB                 mov     eax, [ebp+8]
.text$mn:000015CE                 push    eax             ; lpCaption
.text$mn:000015CF                 lea     ecx, [ebp-300h]
.text$mn:000015D5                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000015DA                 push    eax             ; lpText
.text$mn:000015DB                 push    0               ; hWnd
.text$mn:000015DD                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:000015E3                 cmp     eax, 6
.text$mn:000015E6                 jnz     short loc_1619
.text$mn:000015E8                 mov     ecx, [ebp+8]
.text$mn:000015EB                 push    ecx             ; Str
.text$mn:000015EC                 lea     ecx, [ebp-338h]
.text$mn:000015F2                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000015F7                 mov     byte ptr [ebp-4], 0Eh
.text$mn:000015FB                 lea     edx, [ebp-338h]
.text$mn:00001601                 push    edx
.text$mn:00001602                 mov     ecx, [ebp+0Ch]
.text$mn:00001605                 call    ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000160A                 mov     byte ptr [ebp-4], 0Dh
.text$mn:0000160E                 lea     ecx, [ebp-338h]
.text$mn:00001614                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001619
.text$mn:00001619 loc_1619:                               ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2+53j
.text$mn:00001619                 mov     eax, [ebp-534h]
.text$mn:0000161F                 mov     [ebp-5B8h], eax
.text$mn:00001625                 mov     ecx, [ebp-5B8h]
.text$mn:0000162B                 mov     [ebp-580h], ecx
.text$mn:00001631                 cmp     dword ptr [ebp-580h], 0
.text$mn:00001638                 jz      short loc_164F
.text$mn:0000163A                 push    1
.text$mn:0000163C                 mov     ecx, [ebp-580h]
.text$mn:00001642                 call    ??_GPluginInfo@@QAEPAXI@Z ; PluginInfo::`scalar deleting destructor'(uint)
.text$mn:00001647                 mov     [ebp-5C0h], eax
.text$mn:0000164D                 jmp     short loc_1659
.text$mn:0000164F ; ---------------------------------------------------------------------------
.text$mn:0000164F
.text$mn:0000164F loc_164F:                               ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2+A5j
.text$mn:0000164F                 mov     dword ptr [ebp-5C0h], 0
.text$mn:00001659
.text$mn:00001659 loc_1659:                               ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2+BAj
.text$mn:00001659                 mov     dword ptr [ebp-5C8h], 0FFFFFFFFh
.text$mn:00001663                 mov     byte ptr [ebp-4], 9
.text$mn:00001667                 lea     ecx, [ebp-300h]
.text$mn:0000166D                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001672                 mov     eax, offset $LN70
.text$mn:00001677                 retn
.text$mn:00001677 __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2 endp
.text$mn:00001677
.text$mn:00001678 ; ---------------------------------------------------------------------------
.text$mn:00001678                 mov     eax, offset __tryend$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$3
.text$mn:0000167D                 retn
.text$mn:0000167E ; ---------------------------------------------------------------------------
.text$mn:0000167E
.text$mn:0000167E __tryend$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$3:
.text$mn:0000167E                                         ; DATA XREF: .text$mn:000014B2o
.text$mn:0000167E                                         ; .text$mn:0000158Do ...
.text$mn:0000167E                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001685                 jmp     short loc_1696
.text$mn:00001687 ; ---------------------------------------------------------------------------
.text$mn:00001687
.text$mn:00001687 $LN70:                                  ; DATA XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2+DFo
.text$mn:00001687                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000168E                 mov     eax, [ebp-5C8h]
.text$mn:00001694                 jmp     short loc_16B6
.text$mn:00001696 ; ---------------------------------------------------------------------------
.text$mn:00001696
.text$mn:00001696 loc_1696:                               ; CODE XREF: .text$mn:00001685j
.text$mn:00001696                 jmp     short loc_16A7
.text$mn:00001698 ; ---------------------------------------------------------------------------
.text$mn:00001698
.text$mn:00001698 $LN68:                                  ; DATA XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+CFo
.text$mn:00001698                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000169F                 mov     eax, [ebp-5D0h]
.text$mn:000016A5                 jmp     short loc_16B6
.text$mn:000016A7 ; ---------------------------------------------------------------------------
.text$mn:000016A7
.text$mn:000016A7 loc_16A7:                               ; CODE XREF: .text$mn:loc_1696j
.text$mn:000016A7                 jmp     short loc_16B6
.text$mn:000016A9 ; ---------------------------------------------------------------------------
.text$mn:000016A9
.text$mn:000016A9 $LN66:                                  ; DATA XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$0+38o
.text$mn:000016A9                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000016B0                 mov     eax, [ebp-5D8h]
.text$mn:000016B6 ; START OF FUNCTION CHUNK FOR ?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z
.text$mn:000016B6
.text$mn:000016B6 loc_16B6:                               ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+63j
.text$mn:000016B6                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+9EBj ...
.text$mn:000016B6                 mov     ecx, [ebp+var_C]
.text$mn:000016B9                 mov     large fs:0, ecx
.text$mn:000016C0                 pop     ecx
.text$mn:000016C1                 pop     edi
.text$mn:000016C2                 pop     esi
.text$mn:000016C3                 pop     ebx
.text$mn:000016C4                 mov     ecx, [ebp+var_14]
.text$mn:000016C7                 xor     ecx, ebp
.text$mn:000016C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000016CE                 mov     esp, ebp
.text$mn:000016D0                 pop     ebp
.text$mn:000016D1                 retn    8
.text$mn:000016D1 ; END OF FUNCTION CHUNK FOR ?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z
.text$mn:000016D4
.text$mn:000016D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016D4
.text$mn:000016D4 ; Attributes: bp-based frame
.text$mn:000016D4
.text$mn:000016D4 ; bool __thiscall PluginsManager::loadPlugins(PluginsManager *this, const wchar_t *)
.text$mn:000016D4                 public ?loadPlugins@PluginsManager@@QAE_NPB_W@Z
.text$mn:000016D4 ?loadPlugins@PluginsManager@@QAE_NPB_W@Z proc near
.text$mn:000016D4
.text$mn:000016D4 var_414         = dword ptr -414h
.text$mn:000016D4 var_410         = dword ptr -410h
.text$mn:000016D4 var_40C         = byte ptr -40Ch
.text$mn:000016D4 var_3FC         = byte ptr -3FCh
.text$mn:000016D4 var_3EC         = dword ptr -3ECh
.text$mn:000016D4 var_3E8         = dword ptr -3E8h
.text$mn:000016D4 var_3E4         = dword ptr -3E4h
.text$mn:000016D4 var_3E0         = dword ptr -3E0h
.text$mn:000016D4 var_3DC         = dword ptr -3DCh
.text$mn:000016D4 var_3D8         = dword ptr -3D8h
.text$mn:000016D4 var_3D4         = dword ptr -3D4h
.text$mn:000016D4 var_3D0         = dword ptr -3D0h
.text$mn:000016D4 var_3CC         = dword ptr -3CCh
.text$mn:000016D4 var_3C8         = dword ptr -3C8h
.text$mn:000016D4 var_3C4         = dword ptr -3C4h
.text$mn:000016D4 var_3C0         = dword ptr -3C0h
.text$mn:000016D4 var_3BC         = dword ptr -3BCh
.text$mn:000016D4 var_3B8         = dword ptr -3B8h
.text$mn:000016D4 var_3B4         = dword ptr -3B4h
.text$mn:000016D4 var_3B0         = dword ptr -3B0h
.text$mn:000016D4 var_3AC         = dword ptr -3ACh
.text$mn:000016D4 var_3A8         = dword ptr -3A8h
.text$mn:000016D4 var_3A4         = dword ptr -3A4h
.text$mn:000016D4 var_3A0         = dword ptr -3A0h
.text$mn:000016D4 var_39C         = dword ptr -39Ch
.text$mn:000016D4 var_398         = dword ptr -398h
.text$mn:000016D4 var_394         = dword ptr -394h
.text$mn:000016D4 hFindFile       = dword ptr -390h
.text$mn:000016D4 var_38C         = dword ptr -38Ch
.text$mn:000016D4 var_388         = dword ptr -388h
.text$mn:000016D4 var_384         = dword ptr -384h
.text$mn:000016D4 var_37E         = byte ptr -37Eh
.text$mn:000016D4 var_37D         = byte ptr -37Dh
.text$mn:000016D4 var_37C         = dword ptr -37Ch
.text$mn:000016D4 FindFileData    = _WIN32_FIND_DATAW ptr -378h
.text$mn:000016D4 var_128         = byte ptr -128h
.text$mn:000016D4 var_10C         = byte ptr -10Ch
.text$mn:000016D4 var_F0          = byte ptr -0F0h
.text$mn:000016D4 var_D4          = byte ptr -0D4h
.text$mn:000016D4 var_B8          = byte ptr -0B8h
.text$mn:000016D4 var_9C          = byte ptr -9Ch
.text$mn:000016D4 var_80          = byte ptr -80h
.text$mn:000016D4 var_64          = byte ptr -64h
.text$mn:000016D4 var_48          = byte ptr -48h
.text$mn:000016D4 var_2C          = byte ptr -2Ch
.text$mn:000016D4 var_10          = dword ptr -10h
.text$mn:000016D4 var_C           = dword ptr -0Ch
.text$mn:000016D4 var_4           = dword ptr -4
.text$mn:000016D4 Str             = dword ptr  8
.text$mn:000016D4
.text$mn:000016D4                 push    ebp
.text$mn:000016D5                 mov     ebp, esp
.text$mn:000016D7                 push    0FFFFFFFFh
.text$mn:000016D9                 push    offset __ehhandler$?loadPlugins@PluginsManager@@QAE_NPB_W@Z
.text$mn:000016DE                 mov     eax, large fs:0
.text$mn:000016E4                 push    eax
.text$mn:000016E5                 sub     esp, 408h
.text$mn:000016EB                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016F0                 xor     eax, ebp
.text$mn:000016F2                 mov     [ebp+var_10], eax
.text$mn:000016F5                 push    eax
.text$mn:000016F6                 lea     eax, [ebp+var_C]
.text$mn:000016F9                 mov     large fs:0, eax
.text$mn:000016FF                 mov     [ebp+var_394], ecx
.text$mn:00001705                 mov     [ebp+var_37C], 0
.text$mn:0000170F                 mov     eax, [ebp+var_394]
.text$mn:00001715                 movzx   ecx, byte ptr [eax+40h]
.text$mn:00001719                 test    ecx, ecx
.text$mn:0000171B                 jz      short loc_1724
.text$mn:0000171D                 xor     al, al
.text$mn:0000171F                 jmp     loc_1CB5
.text$mn:00001724 ; ---------------------------------------------------------------------------
.text$mn:00001724
.text$mn:00001724 loc_1724:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+47j
.text$mn:00001724                 lea     ecx, [ebp+var_3FC]
.text$mn:0000172A                 call    ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:0000172F                 mov     [ebp+var_4], 0
.text$mn:00001736                 lea     ecx, [ebp+var_40C]
.text$mn:0000173C                 call    ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00001741                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001745                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000174A                 mov     [ebp+var_38C], eax
.text$mn:00001750                 lea     edx, [ebp+var_48]
.text$mn:00001753                 push    edx
.text$mn:00001754                 mov     ecx, [ebp+var_38C]
.text$mn:0000175A                 call    ?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; NppParameters::getNppPath(void)
.text$mn:0000175F                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001763                 cmp     [ebp+Str], 0
.text$mn:00001767                 jz      short loc_17BE
.text$mn:00001769                 mov     eax, 2
.text$mn:0000176E                 imul    ecx, eax, 0
.text$mn:00001771                 mov     edx, [ebp+Str]
.text$mn:00001774                 movzx   eax, word ptr [edx+ecx]
.text$mn:00001778                 test    eax, eax
.text$mn:0000177A                 jz      short loc_17BE
.text$mn:0000177C                 mov     ecx, [ebp+Str]
.text$mn:0000177F                 push    ecx             ; Str
.text$mn:00001780                 lea     ecx, [ebp+var_128]
.text$mn:00001786                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000178B                 mov     [ebp+var_3AC], eax
.text$mn:00001791                 mov     edx, [ebp+var_3AC]
.text$mn:00001797                 mov     [ebp+var_3A8], edx
.text$mn:0000179D                 mov     byte ptr [ebp+var_4], 3
.text$mn:000017A1                 mov     eax, [ebp+var_37C]
.text$mn:000017A7                 or      eax, 1
.text$mn:000017AA                 mov     [ebp+var_37C], eax
.text$mn:000017B0                 mov     ecx, [ebp+var_3A8]
.text$mn:000017B6                 mov     [ebp+var_39C], ecx
.text$mn:000017BC                 jmp     short loc_1801
.text$mn:000017BE ; ---------------------------------------------------------------------------
.text$mn:000017BE
.text$mn:000017BE loc_17BE:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+93j
.text$mn:000017BE                                         ; PluginsManager::loadPlugins(wchar_t const *)+A6j
.text$mn:000017BE                 lea     edx, [ebp+var_48]
.text$mn:000017C1                 push    edx
.text$mn:000017C2                 lea     ecx, [ebp+var_F0]
.text$mn:000017C8                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000017CD                 mov     [ebp+var_3B0], eax
.text$mn:000017D3                 mov     eax, [ebp+var_3B0]
.text$mn:000017D9                 mov     [ebp+var_3B8], eax
.text$mn:000017DF                 mov     [ebp+var_4], 4
.text$mn:000017E6                 mov     ecx, [ebp+var_37C]
.text$mn:000017EC                 or      ecx, 2
.text$mn:000017EF                 mov     [ebp+var_37C], ecx
.text$mn:000017F5                 mov     edx, [ebp+var_3B8]
.text$mn:000017FB                 mov     [ebp+var_39C], edx
.text$mn:00001801
.text$mn:00001801 loc_1801:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+E8j
.text$mn:00001801                 mov     eax, [ebp+var_39C]
.text$mn:00001807                 mov     [ebp+var_3C0], eax
.text$mn:0000180D                 mov     ecx, [ebp+var_3C0]
.text$mn:00001813                 push    ecx
.text$mn:00001814                 lea     ecx, [ebp+var_80]
.text$mn:00001817                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000181C                 mov     [ebp+var_4], 6
.text$mn:00001823                 mov     edx, [ebp+var_37C]
.text$mn:00001829                 and     edx, 2
.text$mn:0000182C                 jz      short loc_1840
.text$mn:0000182E                 and     [ebp+var_37C], 0FFFFFFFDh
.text$mn:00001835                 lea     ecx, [ebp+var_F0]
.text$mn:0000183B                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001840
.text$mn:00001840 loc_1840:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+158j
.text$mn:00001840                 mov     byte ptr [ebp+var_4], 7
.text$mn:00001844                 mov     eax, [ebp+var_37C]
.text$mn:0000184A                 and     eax, 1
.text$mn:0000184D                 jz      short loc_1861
.text$mn:0000184F                 and     [ebp+var_37C], 0FFFFFFFEh
.text$mn:00001856                 lea     ecx, [ebp+var_128]
.text$mn:0000185C                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001861
.text$mn:00001861 loc_1861:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+179j
.text$mn:00001861                 push    offset $SG126755 ; "\\plugins\\*.dll"
.text$mn:00001866                 lea     ecx, [ebp+var_80]
.text$mn:00001869                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000186E                 lea     ecx, [ebp+FindFileData]
.text$mn:00001874                 push    ecx             ; lpFindFileData
.text$mn:00001875                 lea     ecx, [ebp+var_80]
.text$mn:00001878                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000187D                 push    eax             ; lpFileName
.text$mn:0000187E                 call    dword ptr ds:__imp__FindFirstFileW@8 ; FindFirstFileW(x,x)
.text$mn:00001884                 mov     [ebp+hFindFile], eax
.text$mn:0000188A                 cmp     [ebp+hFindFile], 0FFFFFFFFh
.text$mn:00001891                 jz      loc_1C13
.text$mn:00001897                 cmp     [ebp+Str], 0
.text$mn:0000189B                 jz      short loc_18F2
.text$mn:0000189D                 mov     edx, 2
.text$mn:000018A2                 imul    eax, edx, 0
.text$mn:000018A5                 mov     ecx, [ebp+Str]
.text$mn:000018A8                 movzx   edx, word ptr [ecx+eax]
.text$mn:000018AC                 test    edx, edx
.text$mn:000018AE                 jz      short loc_18F2
.text$mn:000018B0                 mov     eax, [ebp+Str]
.text$mn:000018B3                 push    eax             ; Str
.text$mn:000018B4                 lea     ecx, [ebp+var_10C]
.text$mn:000018BA                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000018BF                 mov     [ebp+var_3C8], eax
.text$mn:000018C5                 mov     ecx, [ebp+var_3C8]
.text$mn:000018CB                 mov     [ebp+var_3D0], ecx
.text$mn:000018D1                 mov     byte ptr [ebp+var_4], 8
.text$mn:000018D5                 mov     edx, [ebp+var_37C]
.text$mn:000018DB                 or      edx, 4
.text$mn:000018DE                 mov     [ebp+var_37C], edx
.text$mn:000018E4                 mov     eax, [ebp+var_3D0]
.text$mn:000018EA                 mov     [ebp+var_398], eax
.text$mn:000018F0                 jmp     short loc_1935
.text$mn:000018F2 ; ---------------------------------------------------------------------------
.text$mn:000018F2
.text$mn:000018F2 loc_18F2:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+1C7j
.text$mn:000018F2                                         ; PluginsManager::loadPlugins(wchar_t const *)+1DAj
.text$mn:000018F2                 lea     ecx, [ebp+var_48]
.text$mn:000018F5                 push    ecx
.text$mn:000018F6                 lea     ecx, [ebp+var_D4]
.text$mn:000018FC                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001901                 mov     [ebp+var_3D8], eax
.text$mn:00001907                 mov     edx, [ebp+var_3D8]
.text$mn:0000190D                 mov     [ebp+var_3E4], edx
.text$mn:00001913                 mov     [ebp+var_4], 9
.text$mn:0000191A                 mov     eax, [ebp+var_37C]
.text$mn:00001920                 or      eax, 8
.text$mn:00001923                 mov     [ebp+var_37C], eax
.text$mn:00001929                 mov     ecx, [ebp+var_3E4]
.text$mn:0000192F                 mov     [ebp+var_398], ecx
.text$mn:00001935
.text$mn:00001935 loc_1935:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+21Cj
.text$mn:00001935                 mov     edx, [ebp+var_398]
.text$mn:0000193B                 mov     [ebp+var_3EC], edx
.text$mn:00001941                 mov     eax, [ebp+var_3EC]
.text$mn:00001947                 push    eax
.text$mn:00001948                 lea     ecx, [ebp+var_2C]
.text$mn:0000194B                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00001950                 mov     [ebp+var_4], 0Bh
.text$mn:00001957                 mov     ecx, [ebp+var_37C]
.text$mn:0000195D                 and     ecx, 8
.text$mn:00001960                 jz      short loc_1974
.text$mn:00001962                 and     [ebp+var_37C], 0FFFFFFF7h
.text$mn:00001969                 lea     ecx, [ebp+var_D4]
.text$mn:0000196F                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001974
.text$mn:00001974 loc_1974:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+28Cj
.text$mn:00001974                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:00001978                 mov     edx, [ebp+var_37C]
.text$mn:0000197E                 and     edx, 4
.text$mn:00001981                 jz      short loc_1995
.text$mn:00001983                 and     [ebp+var_37C], 0FFFFFFFBh
.text$mn:0000198A                 lea     ecx, [ebp+var_10C]
.text$mn:00001990                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001995
.text$mn:00001995 loc_1995:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+2ADj
.text$mn:00001995                 push    offset $SG126766 ; "\\plugins\\"
.text$mn:0000199A                 lea     ecx, [ebp+var_2C]
.text$mn:0000199D                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000019A2                 lea     eax, [ebp+FindFileData.cFileName]
.text$mn:000019A8                 push    eax             ; Str
.text$mn:000019A9                 lea     ecx, [ebp+var_2C]
.text$mn:000019AC                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000019B1                 lea     ecx, [ebp+var_2C]
.text$mn:000019B4                 push    ecx
.text$mn:000019B5                 lea     ecx, [ebp+var_3FC]
.text$mn:000019BB                 call    ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000019C0
.text$mn:000019C0 loc_19C0:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+4B9j
.text$mn:000019C0                 lea     edx, [ebp+FindFileData]
.text$mn:000019C6                 push    edx             ; lpFindFileData
.text$mn:000019C7                 mov     eax, [ebp+hFindFile]
.text$mn:000019CD                 push    eax             ; hFindFile
.text$mn:000019CE                 call    dword ptr ds:__imp__FindNextFileW@8 ; FindNextFileW(x,x)
.text$mn:000019D4                 test    eax, eax
.text$mn:000019D6                 jz      loc_1B92
.text$mn:000019DC                 lea     ecx, [ebp+FindFileData.cFileName]
.text$mn:000019E2                 push    ecx             ; wchar_t *
.text$mn:000019E3                 mov     ecx, [ebp+var_38C] ; this
.text$mn:000019E9                 call    ?isInBlackList@NppParameters@@QAE_NPA_W@Z ; NppParameters::isInBlackList(wchar_t *)
.text$mn:000019EE                 mov     [ebp+var_37D], al
.text$mn:000019F4                 movzx   edx, [ebp+var_37D]
.text$mn:000019FB                 test    edx, edx
.text$mn:000019FD                 jnz     loc_1B38
.text$mn:00001A03                 cmp     [ebp+Str], 0
.text$mn:00001A07                 jz      short loc_1A5E
.text$mn:00001A09                 mov     eax, 2
.text$mn:00001A0E                 imul    ecx, eax, 0
.text$mn:00001A11                 mov     edx, [ebp+Str]
.text$mn:00001A14                 movzx   eax, word ptr [edx+ecx]
.text$mn:00001A18                 test    eax, eax
.text$mn:00001A1A                 jz      short loc_1A5E
.text$mn:00001A1C                 mov     ecx, [ebp+Str]
.text$mn:00001A1F                 push    ecx             ; Str
.text$mn:00001A20                 lea     ecx, [ebp+var_B8]
.text$mn:00001A26                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00001A2B                 mov     [ebp+var_3E0], eax
.text$mn:00001A31                 mov     edx, [ebp+var_3E0]
.text$mn:00001A37                 mov     [ebp+var_3A4], edx
.text$mn:00001A3D                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:00001A41                 mov     eax, [ebp+var_37C]
.text$mn:00001A47                 or      eax, 10h
.text$mn:00001A4A                 mov     [ebp+var_37C], eax
.text$mn:00001A50                 mov     ecx, [ebp+var_3A4]
.text$mn:00001A56                 mov     [ebp+var_3A0], ecx
.text$mn:00001A5C                 jmp     short loc_1AA1
.text$mn:00001A5E ; ---------------------------------------------------------------------------
.text$mn:00001A5E
.text$mn:00001A5E loc_1A5E:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+333j
.text$mn:00001A5E                                         ; PluginsManager::loadPlugins(wchar_t const *)+346j
.text$mn:00001A5E                 lea     edx, [ebp+var_48]
.text$mn:00001A61                 push    edx
.text$mn:00001A62                 lea     ecx, [ebp+var_9C]
.text$mn:00001A68                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001A6D                 mov     [ebp+var_3CC], eax
.text$mn:00001A73                 mov     eax, [ebp+var_3CC]
.text$mn:00001A79                 mov     [ebp+var_3DC], eax
.text$mn:00001A7F                 mov     [ebp+var_4], 0Eh
.text$mn:00001A86                 mov     ecx, [ebp+var_37C]
.text$mn:00001A8C                 or      ecx, 20h
.text$mn:00001A8F                 mov     [ebp+var_37C], ecx
.text$mn:00001A95                 mov     edx, [ebp+var_3DC]
.text$mn:00001A9B                 mov     [ebp+var_3A0], edx
.text$mn:00001AA1
.text$mn:00001AA1 loc_1AA1:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+388j
.text$mn:00001AA1                 mov     eax, [ebp+var_3A0]
.text$mn:00001AA7                 mov     [ebp+var_3B4], eax
.text$mn:00001AAD                 mov     ecx, [ebp+var_3B4]
.text$mn:00001AB3                 push    ecx
.text$mn:00001AB4                 lea     ecx, [ebp+var_64]
.text$mn:00001AB7                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00001ABC                 mov     [ebp+var_4], 10h
.text$mn:00001AC3                 mov     edx, [ebp+var_37C]
.text$mn:00001AC9                 and     edx, 20h
.text$mn:00001ACC                 jz      short loc_1AE0
.text$mn:00001ACE                 and     [ebp+var_37C], 0FFFFFFDFh
.text$mn:00001AD5                 lea     ecx, [ebp+var_9C]
.text$mn:00001ADB                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001AE0
.text$mn:00001AE0 loc_1AE0:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+3F8j
.text$mn:00001AE0                 mov     byte ptr [ebp+var_4], 11h
.text$mn:00001AE4                 mov     eax, [ebp+var_37C]
.text$mn:00001AEA                 and     eax, 10h
.text$mn:00001AED                 jz      short loc_1B01
.text$mn:00001AEF                 and     [ebp+var_37C], 0FFFFFFEFh
.text$mn:00001AF6                 lea     ecx, [ebp+var_B8]
.text$mn:00001AFC                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001B01
.text$mn:00001B01 loc_1B01:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+419j
.text$mn:00001B01                 push    offset $SG126777 ; "\\plugins\\"
.text$mn:00001B06                 lea     ecx, [ebp+var_64]
.text$mn:00001B09                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00001B0E                 lea     ecx, [ebp+FindFileData.cFileName]
.text$mn:00001B14                 push    ecx             ; Str
.text$mn:00001B15                 lea     ecx, [ebp+var_64]
.text$mn:00001B18                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00001B1D                 lea     edx, [ebp+var_64]
.text$mn:00001B20                 push    edx
.text$mn:00001B21                 lea     ecx, [ebp+var_3FC]
.text$mn:00001B27                 call    ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001B2C                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:00001B30                 lea     ecx, [ebp+var_64]
.text$mn:00001B33                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001B38
.text$mn:00001B38 loc_1B38:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+329j
.text$mn:00001B38                 mov     ecx, [ebp+var_38C] ; this
.text$mn:00001B3E                 call    ?getPluginList@NppParameters@@QAEAAVPluginList@@XZ ; NppParameters::getPluginList(void)
.text$mn:00001B43                 mov     [ebp+var_3BC], eax
.text$mn:00001B49                 movzx   eax, [ebp+var_37D]
.text$mn:00001B50                 push    eax
.text$mn:00001B51                 sub     esp, 1Ch
.text$mn:00001B54                 mov     ecx, esp
.text$mn:00001B56                 mov     [ebp+var_414], esp
.text$mn:00001B5C                 lea     edx, [ebp+FindFileData.cFileName]
.text$mn:00001B62                 push    edx             ; Str
.text$mn:00001B63                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00001B68                 mov     [ebp+var_3D4], eax
.text$mn:00001B6E                 mov     eax, [ebp+var_3D4]
.text$mn:00001B74                 mov     [ebp+var_410], eax
.text$mn:00001B7A                 mov     byte ptr [ebp+var_4], 12h
.text$mn:00001B7E                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:00001B82                 mov     ecx, [ebp+var_3BC]
.text$mn:00001B88                 call    ?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z ; PluginList::add(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool)
.text$mn:00001B8D                 jmp     loc_19C0
.text$mn:00001B92 ; ---------------------------------------------------------------------------
.text$mn:00001B92
.text$mn:00001B92 loc_1B92:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+302j
.text$mn:00001B92                 mov     ecx, [ebp+hFindFile]
.text$mn:00001B98                 push    ecx             ; hFindFile
.text$mn:00001B99                 call    dword ptr ds:__imp__FindClose@4 ; FindClose(x)
.text$mn:00001B9F                 mov     [ebp+var_388], 0
.text$mn:00001BA9                 lea     ecx, [ebp+var_3FC]
.text$mn:00001BAF                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:00001BB4                 mov     [ebp+var_3E8], eax
.text$mn:00001BBA                 jmp     short loc_1BCB
.text$mn:00001BBC ; ---------------------------------------------------------------------------
.text$mn:00001BBC
.text$mn:00001BBC loc_1BBC:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+531j
.text$mn:00001BBC                 mov     edx, [ebp+var_388]
.text$mn:00001BC2                 add     edx, 1
.text$mn:00001BC5                 mov     [ebp+var_388], edx
.text$mn:00001BCB
.text$mn:00001BCB loc_1BCB:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+4E6j
.text$mn:00001BCB                 mov     eax, [ebp+var_388]
.text$mn:00001BD1                 cmp     eax, [ebp+var_3E8]
.text$mn:00001BD7                 jnb     short loc_1C07
.text$mn:00001BD9                 lea     ecx, [ebp+var_40C]
.text$mn:00001BDF                 push    ecx
.text$mn:00001BE0                 mov     edx, [ebp+var_388]
.text$mn:00001BE6                 push    edx
.text$mn:00001BE7                 lea     ecx, [ebp+var_3FC]
.text$mn:00001BED                 call    ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)
.text$mn:00001BF2                 mov     ecx, eax
.text$mn:00001BF4                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001BF9                 push    eax             ; pszPath
.text$mn:00001BFA                 mov     ecx, [ebp+var_394]
.text$mn:00001C00                 call    ?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:00001C05                 jmp     short loc_1BBC
.text$mn:00001C07 ; ---------------------------------------------------------------------------
.text$mn:00001C07
.text$mn:00001C07 loc_1C07:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+503j
.text$mn:00001C07                 mov     byte ptr [ebp+var_4], 7
.text$mn:00001C0B                 lea     ecx, [ebp+var_2C]
.text$mn:00001C0E                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001C13
.text$mn:00001C13 loc_1C13:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+1BDj
.text$mn:00001C13                 mov     [ebp+var_384], 0
.text$mn:00001C1D                 lea     ecx, [ebp+var_40C]
.text$mn:00001C23                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:00001C28                 mov     [ebp+var_3C4], eax
.text$mn:00001C2E                 jmp     short loc_1C3F
.text$mn:00001C30 ; ---------------------------------------------------------------------------
.text$mn:00001C30
.text$mn:00001C30 loc_1C30:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+599j
.text$mn:00001C30                 mov     eax, [ebp+var_384]
.text$mn:00001C36                 add     eax, 1
.text$mn:00001C39                 mov     [ebp+var_384], eax
.text$mn:00001C3F
.text$mn:00001C3F loc_1C3F:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+55Aj
.text$mn:00001C3F                 mov     ecx, [ebp+var_384]
.text$mn:00001C45                 cmp     ecx, [ebp+var_3C4]
.text$mn:00001C4B                 jnb     short loc_1C6F
.text$mn:00001C4D                 mov     edx, [ebp+var_384]
.text$mn:00001C53                 push    edx
.text$mn:00001C54                 lea     ecx, [ebp+var_40C]
.text$mn:00001C5A                 call    ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)
.text$mn:00001C5F                 mov     ecx, eax
.text$mn:00001C61                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001C66                 push    eax             ; lpFileName
.text$mn:00001C67                 call    dword ptr ds:__imp__DeleteFileW@4 ; DeleteFileW(x)
.text$mn:00001C6D                 jmp     short loc_1C30
.text$mn:00001C6F ; ---------------------------------------------------------------------------
.text$mn:00001C6F
.text$mn:00001C6F loc_1C6F:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+577j
.text$mn:00001C6F                 mov     [ebp+var_37E], 1
.text$mn:00001C76                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001C7A                 lea     ecx, [ebp+var_80]
.text$mn:00001C7D                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001C82                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001C86                 lea     ecx, [ebp+var_48]
.text$mn:00001C89                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001C8E                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001C92                 lea     ecx, [ebp+var_40C]
.text$mn:00001C98                 call    ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00001C9D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001CA4                 lea     ecx, [ebp+var_3FC]
.text$mn:00001CAA                 call    ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00001CAF                 mov     al, [ebp+var_37E]
.text$mn:00001CB5
.text$mn:00001CB5 loc_1CB5:                               ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+4Bj
.text$mn:00001CB5                 mov     ecx, [ebp+var_C]
.text$mn:00001CB8                 mov     large fs:0, ecx
.text$mn:00001CBF                 pop     ecx
.text$mn:00001CC0                 mov     ecx, [ebp+var_10]
.text$mn:00001CC3                 xor     ecx, ebp
.text$mn:00001CC5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001CCA                 mov     esp, ebp
.text$mn:00001CCC                 pop     ebp
.text$mn:00001CCD                 retn    4
.text$mn:00001CCD ?loadPlugins@PluginsManager@@QAE_NPB_W@Z endp ; sp-analysis failed
.text$mn:00001CCD
.text$mn:00001CCD ; ---------------------------------------------------------------------------
.text$mn:00001CD0                 db 4 dup(0CCh)
.text$mn:00001CD4
.text$mn:00001CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CD4
.text$mn:00001CD4 ; Attributes: bp-based frame
.text$mn:00001CD4
.text$mn:00001CD4 ; bool __thiscall PluginsManager::unloadPlugin(PluginsManager *this, int, HWND)
.text$mn:00001CD4                 public ?unloadPlugin@PluginsManager@@QAE_NHPAUHWND__@@@Z
.text$mn:00001CD4 ?unloadPlugin@PluginsManager@@QAE_NHPAUHWND__@@@Z proc near
.text$mn:00001CD4
.text$mn:00001CD4 var_60          = dword ptr -60h
.text$mn:00001CD4 var_5C          = dword ptr -5Ch
.text$mn:00001CD4 var_58          = dword ptr -58h
.text$mn:00001CD4 var_4           = dword ptr -4
.text$mn:00001CD4 arg_0           = dword ptr  8
.text$mn:00001CD4 arg_4           = dword ptr  0Ch
.text$mn:00001CD4
.text$mn:00001CD4                 push    ebp
.text$mn:00001CD5                 mov     ebp, esp
.text$mn:00001CD7                 sub     esp, 60h
.text$mn:00001CDA                 mov     [ebp+var_4], ecx
.text$mn:00001CDD                 mov     [ebp+var_58], 3F1h
.text$mn:00001CE4                 mov     eax, [ebp+arg_4]
.text$mn:00001CE7                 mov     [ebp+var_60], eax
.text$mn:00001CEA                 mov     [ebp+var_5C], 0
.text$mn:00001CF1                 lea     ecx, [ebp+var_60]
.text$mn:00001CF4                 push    ecx
.text$mn:00001CF5                 mov     edx, [ebp+arg_0]
.text$mn:00001CF8                 push    edx
.text$mn:00001CF9                 mov     ecx, [ebp+var_4]
.text$mn:00001CFC                 add     ecx, 10h
.text$mn:00001CFF                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00001D04                 mov     eax, [eax]
.text$mn:00001D06                 mov     ecx, [eax+10h]
.text$mn:00001D09                 call    ecx
.text$mn:00001D0B                 add     esp, 4
.text$mn:00001D0E                 mov     edx, [ebp+arg_0]
.text$mn:00001D11                 push    edx
.text$mn:00001D12                 mov     ecx, [ebp+var_4]
.text$mn:00001D15                 add     ecx, 10h
.text$mn:00001D18                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00001D1D                 mov     eax, [eax]
.text$mn:00001D1F                 mov     ecx, [eax]
.text$mn:00001D21                 push    ecx             ; hLibModule
.text$mn:00001D22                 call    dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
.text$mn:00001D28                 test    eax, eax
.text$mn:00001D2A                 jz      short loc_1D45
.text$mn:00001D2C                 mov     edx, [ebp+arg_0]
.text$mn:00001D2F                 push    edx
.text$mn:00001D30                 mov     ecx, [ebp+var_4]
.text$mn:00001D33                 add     ecx, 10h
.text$mn:00001D36                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00001D3B                 mov     eax, [eax]
.text$mn:00001D3D                 mov     dword ptr [eax], 0
.text$mn:00001D43                 jmp     short loc_1D52
.text$mn:00001D45 ; ---------------------------------------------------------------------------
.text$mn:00001D45
.text$mn:00001D45 loc_1D45:                               ; CODE XREF: PluginsManager::unloadPlugin(int,HWND__ *)+56j
.text$mn:00001D45                 push    offset $SG126535 ; "not ok"
.text$mn:00001D4A                 call    ?printStr@@YAXPB_W@Z ; printStr(wchar_t const *)
.text$mn:00001D4F                 add     esp, 4
.text$mn:00001D52
.text$mn:00001D52 loc_1D52:                               ; CODE XREF: PluginsManager::unloadPlugin(int,HWND__ *)+6Fj
.text$mn:00001D52                 mov     al, 1
.text$mn:00001D54                 mov     esp, ebp
.text$mn:00001D56                 pop     ebp
.text$mn:00001D57                 retn    8
.text$mn:00001D57 ?unloadPlugin@PluginsManager@@QAE_NHPAUHWND__@@@Z endp
.text$mn:00001D57
.text$mn:00001D57 ; ---------------------------------------------------------------------------
.text$mn:00001D5A                 db 0Ah dup(0CCh)
.text$mn:00001D64
.text$mn:00001D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D64
.text$mn:00001D64 ; Attributes: bp-based frame
.text$mn:00001D64
.text$mn:00001D64 ; void __thiscall PluginsManager::runPluginCommand(PluginsManager *this, unsigned int)
.text$mn:00001D64                 public ?runPluginCommand@PluginsManager@@QAEXI@Z
.text$mn:00001D64 ?runPluginCommand@PluginsManager@@QAEXI@Z proc near
.text$mn:00001D64
.text$mn:00001D64 var_118         = dword ptr -118h
.text$mn:00001D64 var_14          = dword ptr -14h
.text$mn:00001D64 var_10          = dword ptr -10h
.text$mn:00001D64 var_C           = dword ptr -0Ch
.text$mn:00001D64 var_4           = dword ptr -4
.text$mn:00001D64 arg_0           = dword ptr  8
.text$mn:00001D64
.text$mn:00001D64 ; FUNCTION CHUNK AT .text$mn:00001E6D SIZE 00000009 BYTES
.text$mn:00001D64 ; FUNCTION CHUNK AT .text$mn:00001E7F SIZE 00000002 BYTES
.text$mn:00001D64 ; FUNCTION CHUNK AT .text$mn:00001E88 SIZE 0000001E BYTES
.text$mn:00001D64
.text$mn:00001D64                 push    ebp
.text$mn:00001D65                 mov     ebp, esp
.text$mn:00001D67                 push    0FFFFFFFFh
.text$mn:00001D69                 push    offset __ehhandler$?runPluginCommand@PluginsManager@@QAEXI@Z
.text$mn:00001D6E                 mov     eax, large fs:0
.text$mn:00001D74                 push    eax
.text$mn:00001D75                 push    ecx
.text$mn:00001D76                 sub     esp, 114h
.text$mn:00001D7C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D81                 xor     eax, ebp
.text$mn:00001D83                 mov     [ebp+var_14], eax
.text$mn:00001D86                 push    ebx
.text$mn:00001D87                 push    esi
.text$mn:00001D88                 push    edi
.text$mn:00001D89                 push    eax
.text$mn:00001D8A                 lea     eax, [ebp+var_C]
.text$mn:00001D8D                 mov     large fs:0, eax
.text$mn:00001D93                 mov     [ebp+var_10], esp
.text$mn:00001D96                 mov     [ebp+var_118], ecx
.text$mn:00001D9C                 mov     ecx, [ebp+var_118]
.text$mn:00001DA2                 add     ecx, 20h ; ' '
.text$mn:00001DA5                 call    ?size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::size(void)
.text$mn:00001DAA                 cmp     [ebp+arg_0], eax
.text$mn:00001DAD                 jnb     loc_1E88
.text$mn:00001DB3                 mov     eax, [ebp+arg_0]
.text$mn:00001DB6                 push    eax
.text$mn:00001DB7                 mov     ecx, [ebp+var_118]
.text$mn:00001DBD                 add     ecx, 20h ; ' '
.text$mn:00001DC0                 call    ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)
.text$mn:00001DC5                 cmp     dword ptr [eax+20h], 0
.text$mn:00001DC9                 jz      loc_1E88
.text$mn:00001DCF                 mov     [ebp+var_4], 0
.text$mn:00001DD6                 mov     ecx, [ebp+arg_0]
.text$mn:00001DD9                 push    ecx
.text$mn:00001DDA                 mov     ecx, [ebp+var_118]
.text$mn:00001DE0                 add     ecx, 20h ; ' '
.text$mn:00001DE3                 call    ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)
.text$mn:00001DE8                 mov     edx, [eax+20h]
.text$mn:00001DEB                 call    edx
.text$mn:00001DED                 jmp     short loc_1E6D
.text$mn:00001DED ?runPluginCommand@PluginsManager@@QAEXI@Z endp
.text$mn:00001DED
.text$mn:00001DEF
.text$mn:00001DEF ; =============== S U B R O U T I N E =======================================
.text$mn:00001DEF
.text$mn:00001DEF
.text$mn:00001DEF __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$0 proc near
.text$mn:00001DEF                                         ; DATA XREF: .xdata$x:0000D1E8o
.text$mn:00001DEF                 mov     byte ptr [ebp-4], 2
.text$mn:00001DF3                 push    0               ; uType
.text$mn:00001DF5                 push    offset $SG126868 ; "PluginsManager::runPluginCommand Except"...
.text$mn:00001DFA                 lea     ecx, [ebp-124h] ; this
.text$mn:00001E00                 call    ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.text$mn:00001E05                 push    eax             ; lpText
.text$mn:00001E06                 push    0               ; hWnd
.text$mn:00001E08                 call    dword ptr ds:__imp__MessageBoxA@16 ; MessageBoxA(x,x,x,x)
.text$mn:00001E0E                 mov     byte ptr [ebp-4], 1
.text$mn:00001E12                 lea     ecx, [ebp-124h] ; this
.text$mn:00001E18                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00001E1D                 mov     eax, offset $LN11
.text$mn:00001E22                 retn
.text$mn:00001E22 __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$0 endp
.text$mn:00001E22
.text$mn:00001E23
.text$mn:00001E23 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E23
.text$mn:00001E23
.text$mn:00001E23 __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$1 proc near
.text$mn:00001E23                                         ; DATA XREF: .xdata$x:0000D1F8o
.text$mn:00001E23                 mov     eax, [ebp+8]
.text$mn:00001E26                 push    eax
.text$mn:00001E27                 push    offset $SG126870 ; "runPluginCommand(size_t i : %d)"
.text$mn:00001E2C                 lea     ecx, [ebp-114h]
.text$mn:00001E32                 push    ecx             ; Dest
.text$mn:00001E33                 call    ?swprintf@@YAHPA_WPB_WZZ ; swprintf(wchar_t *,wchar_t const *,...)
.text$mn:00001E38                 add     esp, 0Ch
.text$mn:00001E3B                 lea     edx, [ebp-114h]
.text$mn:00001E41                 push    edx             ; wchar_t *
.text$mn:00001E42                 mov     eax, [ebp+8]
.text$mn:00001E45                 push    eax
.text$mn:00001E46                 mov     ecx, [ebp-118h]
.text$mn:00001E4C                 add     ecx, 20h ; ' '
.text$mn:00001E4F                 call    ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)
.text$mn:00001E54                 mov     ecx, eax
.text$mn:00001E56                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001E5B                 push    eax             ; Str
.text$mn:00001E5C                 mov     ecx, [ebp-118h] ; this
.text$mn:00001E62                 call    ?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z ; PluginsManager::pluginCrashAlert(wchar_t const *,wchar_t const *)
.text$mn:00001E67                 mov     eax, offset $LN13
.text$mn:00001E6C                 retn
.text$mn:00001E6C __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$1 endp
.text$mn:00001E6C
.text$mn:00001E6D ; ---------------------------------------------------------------------------
.text$mn:00001E6D ; START OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXI@Z
.text$mn:00001E6D
.text$mn:00001E6D loc_1E6D:                               ; CODE XREF: PluginsManager::runPluginCommand(uint)+89j
.text$mn:00001E6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001E74                 jmp     short loc_1E7F
.text$mn:00001E74 ; END OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXI@Z
.text$mn:00001E76
.text$mn:00001E76 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E76
.text$mn:00001E76
.text$mn:00001E76 $LN13           proc near               ; DATA XREF: __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$1+44o
.text$mn:00001E76                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001E7D                 jmp     short loc_1E88
.text$mn:00001E7D $LN13           endp
.text$mn:00001E7D
.text$mn:00001E7F ; ---------------------------------------------------------------------------
.text$mn:00001E7F ; START OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXI@Z
.text$mn:00001E7F
.text$mn:00001E7F loc_1E7F:                               ; CODE XREF: PluginsManager::runPluginCommand(uint)+110j
.text$mn:00001E7F                 jmp     short loc_1E88
.text$mn:00001E7F ; END OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXI@Z
.text$mn:00001E81 ; ---------------------------------------------------------------------------
.text$mn:00001E81
.text$mn:00001E81 $LN11:                                  ; DATA XREF: __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$0+2Eo
.text$mn:00001E81                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001E88 ; START OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXI@Z
.text$mn:00001E88
.text$mn:00001E88 loc_1E88:                               ; CODE XREF: PluginsManager::runPluginCommand(uint)+49j
.text$mn:00001E88                                         ; PluginsManager::runPluginCommand(uint)+65j ...
.text$mn:00001E88                 mov     ecx, [ebp+var_C]
.text$mn:00001E8B                 mov     large fs:0, ecx
.text$mn:00001E92                 pop     ecx
.text$mn:00001E93                 pop     edi
.text$mn:00001E94                 pop     esi
.text$mn:00001E95                 pop     ebx
.text$mn:00001E96                 mov     ecx, [ebp+var_14]
.text$mn:00001E99                 xor     ecx, ebp
.text$mn:00001E9B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001EA0                 mov     esp, ebp
.text$mn:00001EA2                 pop     ebp
.text$mn:00001EA3                 retn    4
.text$mn:00001EA3 ; END OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXI@Z
.text$mn:00001EA3 ; ---------------------------------------------------------------------------
.text$mn:00001EA6                 db 0Eh dup(0CCh)
.text$mn:00001EB4
.text$mn:00001EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EB4
.text$mn:00001EB4 ; Attributes: bp-based frame
.text$mn:00001EB4
.text$mn:00001EB4 ; void __thiscall PluginsManager::runPluginCommand(PluginsManager *this, const wchar_t *Str2, int)
.text$mn:00001EB4                 public ?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.text$mn:00001EB4 ?runPluginCommand@PluginsManager@@QAEXPB_WH@Z proc near
.text$mn:00001EB4
.text$mn:00001EB4 var_120         = dword ptr -120h
.text$mn:00001EB4 var_11C         = dword ptr -11Ch
.text$mn:00001EB4 var_118         = dword ptr -118h
.text$mn:00001EB4 var_14          = dword ptr -14h
.text$mn:00001EB4 var_10          = dword ptr -10h
.text$mn:00001EB4 var_C           = dword ptr -0Ch
.text$mn:00001EB4 var_4           = dword ptr -4
.text$mn:00001EB4 Str2            = dword ptr  8
.text$mn:00001EB4 arg_4           = dword ptr  0Ch
.text$mn:00001EB4
.text$mn:00001EB4 ; FUNCTION CHUNK AT .text$mn:0000202A SIZE 00000009 BYTES
.text$mn:00001EB4 ; FUNCTION CHUNK AT .text$mn:0000203C SIZE 00000002 BYTES
.text$mn:00001EB4 ; FUNCTION CHUNK AT .text$mn:00002045 SIZE 00000023 BYTES
.text$mn:00001EB4
.text$mn:00001EB4                 push    ebp
.text$mn:00001EB5                 mov     ebp, esp
.text$mn:00001EB7                 push    0FFFFFFFFh
.text$mn:00001EB9                 push    offset __ehhandler$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.text$mn:00001EBE                 mov     eax, large fs:0
.text$mn:00001EC4                 push    eax
.text$mn:00001EC5                 push    ecx
.text$mn:00001EC6                 sub     esp, 11Ch
.text$mn:00001ECC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001ED1                 xor     eax, ebp
.text$mn:00001ED3                 mov     [ebp+var_14], eax
.text$mn:00001ED6                 push    ebx
.text$mn:00001ED7                 push    esi
.text$mn:00001ED8                 push    edi
.text$mn:00001ED9                 push    eax
.text$mn:00001EDA                 lea     eax, [ebp+var_C]
.text$mn:00001EDD                 mov     large fs:0, eax
.text$mn:00001EE3                 mov     [ebp+var_10], esp
.text$mn:00001EE6                 mov     [ebp+var_11C], ecx
.text$mn:00001EEC                 mov     [ebp+var_118], 0
.text$mn:00001EF6                 mov     ecx, [ebp+var_11C]
.text$mn:00001EFC                 add     ecx, 20h ; ' '
.text$mn:00001EFF                 call    ?size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::size(void)
.text$mn:00001F04                 mov     [ebp+var_120], eax
.text$mn:00001F0A                 jmp     short loc_1F1B
.text$mn:00001F0C ; ---------------------------------------------------------------------------
.text$mn:00001F0C
.text$mn:00001F0C loc_1F0C:                               ; CODE XREF: PluginsManager::runPluginCommand(wchar_t const *,int):loc_2045j
.text$mn:00001F0C                 mov     eax, [ebp+var_118]
.text$mn:00001F12                 add     eax, 1
.text$mn:00001F15                 mov     [ebp+var_118], eax
.text$mn:00001F1B
.text$mn:00001F1B loc_1F1B:                               ; CODE XREF: PluginsManager::runPluginCommand(wchar_t const *,int)+56j
.text$mn:00001F1B                 mov     ecx, [ebp+var_118]
.text$mn:00001F21                 cmp     ecx, [ebp+var_120]
.text$mn:00001F27                 jnb     loc_204A
.text$mn:00001F2D                 mov     edx, [ebp+Str2]
.text$mn:00001F30                 push    edx             ; Str2
.text$mn:00001F31                 mov     eax, [ebp+var_118]
.text$mn:00001F37                 push    eax
.text$mn:00001F38                 mov     ecx, [ebp+var_11C]
.text$mn:00001F3E                 add     ecx, 20h ; ' '
.text$mn:00001F41                 call    ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)
.text$mn:00001F46                 mov     ecx, eax
.text$mn:00001F48                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001F4D                 push    eax             ; Str1
.text$mn:00001F4E                 call    _wcsicmp
.text$mn:00001F53                 add     esp, 8
.text$mn:00001F56                 test    eax, eax
.text$mn:00001F58                 jnz     loc_2045
.text$mn:00001F5E                 mov     ecx, [ebp+var_118]
.text$mn:00001F64                 push    ecx
.text$mn:00001F65                 mov     ecx, [ebp+var_11C]
.text$mn:00001F6B                 add     ecx, 20h ; ' '
.text$mn:00001F6E                 call    ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)
.text$mn:00001F73                 mov     edx, [eax+1Ch]
.text$mn:00001F76                 cmp     edx, [ebp+arg_4]
.text$mn:00001F79                 jnz     loc_2045
.text$mn:00001F7F                 mov     [ebp+var_4], 0
.text$mn:00001F86                 mov     eax, [ebp+var_118]
.text$mn:00001F8C                 push    eax
.text$mn:00001F8D                 mov     ecx, [ebp+var_11C]
.text$mn:00001F93                 add     ecx, 20h ; ' '
.text$mn:00001F96                 call    ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)
.text$mn:00001F9B                 mov     ecx, [eax+20h]
.text$mn:00001F9E                 call    ecx
.text$mn:00001FA0                 jmp     loc_202A
.text$mn:00001FA0 ?runPluginCommand@PluginsManager@@QAEXPB_WH@Z endp
.text$mn:00001FA0
.text$mn:00001FA5
.text$mn:00001FA5 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FA5
.text$mn:00001FA5
.text$mn:00001FA5 __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$0 proc near
.text$mn:00001FA5                                         ; DATA XREF: .xdata$x:0000D1C8o
.text$mn:00001FA5                 mov     byte ptr [ebp-4], 2
.text$mn:00001FA9                 push    0               ; uType
.text$mn:00001FAB                 push    offset $SG126885 ; "Exception"
.text$mn:00001FB0                 lea     ecx, [ebp-12Ch] ; this
.text$mn:00001FB6                 call    ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.text$mn:00001FBB                 push    eax             ; lpText
.text$mn:00001FBC                 push    0               ; hWnd
.text$mn:00001FBE                 call    dword ptr ds:__imp__MessageBoxA@16 ; MessageBoxA(x,x,x,x)
.text$mn:00001FC4                 mov     byte ptr [ebp-4], 1
.text$mn:00001FC8                 lea     ecx, [ebp-12Ch] ; this
.text$mn:00001FCE                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00001FD3                 mov     eax, offset $LN14
.text$mn:00001FD8                 retn
.text$mn:00001FD8 __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$0 endp
.text$mn:00001FD8
.text$mn:00001FD9
.text$mn:00001FD9 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FD9
.text$mn:00001FD9
.text$mn:00001FD9 __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$1 proc near
.text$mn:00001FD9                                         ; DATA XREF: .xdata$x:0000D1D8o
.text$mn:00001FD9                 mov     edx, [ebp+0Ch]
.text$mn:00001FDC                 push    edx
.text$mn:00001FDD                 mov     eax, [ebp+8]
.text$mn:00001FE0                 push    eax
.text$mn:00001FE1                 push    offset $SG126887 ; "runPluginCommand(const TCHAR *pluginNam"...
.text$mn:00001FE6                 lea     ecx, [ebp-114h]
.text$mn:00001FEC                 push    ecx             ; Dest
.text$mn:00001FED                 call    ?swprintf@@YAHPA_WPB_WZZ ; swprintf(wchar_t *,wchar_t const *,...)
.text$mn:00001FF2                 add     esp, 10h
.text$mn:00001FF5                 lea     edx, [ebp-114h]
.text$mn:00001FFB                 push    edx             ; wchar_t *
.text$mn:00001FFC                 mov     eax, [ebp-118h]
.text$mn:00002002                 push    eax
.text$mn:00002003                 mov     ecx, [ebp-11Ch]
.text$mn:00002009                 add     ecx, 20h ; ' '
.text$mn:0000200C                 call    ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)
.text$mn:00002011                 mov     ecx, eax
.text$mn:00002013                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002018                 push    eax             ; Str
.text$mn:00002019                 mov     ecx, [ebp-11Ch] ; this
.text$mn:0000201F                 call    ?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z ; PluginsManager::pluginCrashAlert(wchar_t const *,wchar_t const *)
.text$mn:00002024                 mov     eax, offset $LN16
.text$mn:00002029                 retn
.text$mn:00002029 __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$1 endp
.text$mn:00002029
.text$mn:0000202A ; ---------------------------------------------------------------------------
.text$mn:0000202A ; START OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.text$mn:0000202A
.text$mn:0000202A loc_202A:                               ; CODE XREF: PluginsManager::runPluginCommand(wchar_t const *,int)+ECj
.text$mn:0000202A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002031                 jmp     short loc_203C
.text$mn:00002031 ; END OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.text$mn:00002033
.text$mn:00002033 ; =============== S U B R O U T I N E =======================================
.text$mn:00002033
.text$mn:00002033
.text$mn:00002033 $LN16           proc near               ; DATA XREF: __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$1+4Bo
.text$mn:00002033                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000203A                 jmp     short loc_2045
.text$mn:0000203A $LN16           endp
.text$mn:0000203A
.text$mn:0000203C ; ---------------------------------------------------------------------------
.text$mn:0000203C ; START OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.text$mn:0000203C
.text$mn:0000203C loc_203C:                               ; CODE XREF: PluginsManager::runPluginCommand(wchar_t const *,int)+17Dj
.text$mn:0000203C                 jmp     short loc_2045
.text$mn:0000203C ; END OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.text$mn:0000203E ; ---------------------------------------------------------------------------
.text$mn:0000203E
.text$mn:0000203E $LN14:                                  ; DATA XREF: __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$0+2Eo
.text$mn:0000203E                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002045 ; START OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.text$mn:00002045
.text$mn:00002045 loc_2045:                               ; CODE XREF: PluginsManager::runPluginCommand(wchar_t const *,int)+A4j
.text$mn:00002045                                         ; PluginsManager::runPluginCommand(wchar_t const *,int)+C5j ...
.text$mn:00002045                 jmp     loc_1F0C
.text$mn:0000204A ; ---------------------------------------------------------------------------
.text$mn:0000204A
.text$mn:0000204A loc_204A:                               ; CODE XREF: PluginsManager::runPluginCommand(wchar_t const *,int)+73j
.text$mn:0000204A                 mov     ecx, [ebp+var_C]
.text$mn:0000204D                 mov     large fs:0, ecx
.text$mn:00002054                 pop     ecx
.text$mn:00002055                 pop     edi
.text$mn:00002056                 pop     esi
.text$mn:00002057                 pop     ebx
.text$mn:00002058                 mov     ecx, [ebp+var_14]
.text$mn:0000205B                 xor     ecx, ebp
.text$mn:0000205D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002062                 mov     esp, ebp
.text$mn:00002064                 pop     ebp
.text$mn:00002065                 retn    8
.text$mn:00002065 ; END OF FUNCTION CHUNK FOR ?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.text$mn:00002065 ; ---------------------------------------------------------------------------
.text$mn:00002068                 db 0Ch dup(0CCh)
.text$mn:00002074
.text$mn:00002074 ; =============== S U B R O U T I N E =======================================
.text$mn:00002074
.text$mn:00002074 ; Attributes: bp-based frame
.text$mn:00002074
.text$mn:00002074 ; void __thiscall PluginsManager::addInMenuFromPMIndex(PluginsManager *this, int)
.text$mn:00002074                 public ?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z
.text$mn:00002074 ?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z proc near
.text$mn:00002074                                         ; CODE XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *)+AAp
.text$mn:00002074
.text$mn:00002074 var_478         = dword ptr -478h
.text$mn:00002074 var_474         = dword ptr -474h
.text$mn:00002074 var_470         = dword ptr -470h
.text$mn:00002074 var_46C         = dword ptr -46Ch
.text$mn:00002074 var_468         = dword ptr -468h
.text$mn:00002074 var_464         = dword ptr -464h
.text$mn:00002074 var_460         = dword ptr -460h
.text$mn:00002074 var_45C         = dword ptr -45Ch
.text$mn:00002074 var_458         = dword ptr -458h
.text$mn:00002074 var_454         = dword ptr -454h
.text$mn:00002074 var_450         = dword ptr -450h
.text$mn:00002074 var_44C         = dword ptr -44Ch
.text$mn:00002074 var_448         = dword ptr -448h
.text$mn:00002074 var_444         = dword ptr -444h
.text$mn:00002074 uIDNewItem      = dword ptr -440h
.text$mn:00002074 var_43C         = dword ptr -43Ch
.text$mn:00002074 var_438         = word ptr -438h
.text$mn:00002074 var_434         = byte ptr -434h
.text$mn:00002074 var_2E4         = byte ptr -2E4h
.text$mn:00002074 var_1BC         = byte ptr -1BCh
.text$mn:00002074 var_6C          = byte ptr -6Ch
.text$mn:00002074 var_48          = byte ptr -48h
.text$mn:00002074 var_2C          = byte ptr -2Ch
.text$mn:00002074 var_10          = dword ptr -10h
.text$mn:00002074 var_C           = dword ptr -0Ch
.text$mn:00002074 var_4           = dword ptr -4
.text$mn:00002074 uPosition       = dword ptr  8
.text$mn:00002074
.text$mn:00002074                 push    ebp
.text$mn:00002075                 mov     ebp, esp
.text$mn:00002077                 push    0FFFFFFFFh
.text$mn:00002079                 push    offset __ehhandler$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z
.text$mn:0000207E                 mov     eax, large fs:0
.text$mn:00002084                 push    eax
.text$mn:00002085                 sub     esp, 46Ch
.text$mn:0000208B                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002090                 xor     eax, ebp
.text$mn:00002092                 mov     [ebp+var_10], eax
.text$mn:00002095                 push    esi
.text$mn:00002096                 push    eax
.text$mn:00002097                 lea     eax, [ebp+var_C]
.text$mn:0000209A                 mov     large fs:0, eax
.text$mn:000020A0                 mov     [ebp+var_43C], ecx
.text$mn:000020A6                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000020AB                 mov     ecx, eax
.text$mn:000020AD                 call    ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ ; NppParameters::getPluginCommandList(void)
.text$mn:000020B2                 mov     [ebp+var_448], eax
.text$mn:000020B8                 mov     eax, [ebp+uPosition]
.text$mn:000020BB                 push    eax
.text$mn:000020BC                 mov     ecx, [ebp+var_43C]
.text$mn:000020C2                 add     ecx, 10h
.text$mn:000020C5                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:000020CA                 mov     ecx, [eax]
.text$mn:000020CC                 mov     edx, [ecx+0Ch]
.text$mn:000020CF                 call    edx
.text$mn:000020D1                 push    eax             ; lpNewItem
.text$mn:000020D2                 mov     eax, [ebp+uPosition]
.text$mn:000020D5                 push    eax
.text$mn:000020D6                 mov     ecx, [ebp+var_43C]
.text$mn:000020DC                 add     ecx, 10h
.text$mn:000020DF                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:000020E4                 mov     ecx, [eax]
.text$mn:000020E6                 mov     edx, [ecx+4]
.text$mn:000020E9                 push    edx             ; uIDNewItem
.text$mn:000020EA                 push    410h            ; uFlags
.text$mn:000020EF                 mov     eax, [ebp+uPosition]
.text$mn:000020F2                 push    eax             ; uPosition
.text$mn:000020F3                 mov     ecx, [ebp+var_43C]
.text$mn:000020F9                 mov     edx, [ecx+0Ch]
.text$mn:000020FC                 push    edx             ; hMenu
.text$mn:000020FD                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:00002103                 xor     eax, eax
.text$mn:00002105                 mov     [ebp+var_438], ax
.text$mn:0000210C                 jmp     short loc_2120
.text$mn:0000210E ; ---------------------------------------------------------------------------
.text$mn:0000210E
.text$mn:0000210E loc_210E:                               ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+130j
.text$mn:0000210E                                         ; PluginsManager::addInMenuFromPMIndex(int)+51Dj
.text$mn:0000210E                 mov     cx, [ebp+var_438]
.text$mn:00002115                 add     cx, 1
.text$mn:00002119                 mov     [ebp+var_438], cx
.text$mn:00002120
.text$mn:00002120 loc_2120:                               ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+98j
.text$mn:00002120                 movzx   esi, [ebp+var_438]
.text$mn:00002127                 mov     edx, [ebp+uPosition]
.text$mn:0000212A                 push    edx
.text$mn:0000212B                 mov     ecx, [ebp+var_43C]
.text$mn:00002131                 add     ecx, 10h
.text$mn:00002134                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00002139                 mov     eax, [eax]
.text$mn:0000213B                 cmp     esi, [eax+24h]
.text$mn:0000213E                 jge     loc_2596
.text$mn:00002144                 mov     ecx, [ebp+uPosition]
.text$mn:00002147                 push    ecx
.text$mn:00002148                 mov     ecx, [ebp+var_43C]
.text$mn:0000214E                 add     ecx, 10h
.text$mn:00002151                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00002156                 mov     edx, [eax]
.text$mn:00002158                 movzx   eax, [ebp+var_438]
.text$mn:0000215F                 imul    ecx, eax, 90h
.text$mn:00002165                 mov     edx, [edx+20h]
.text$mn:00002168                 cmp     dword ptr [edx+ecx+80h], 0
.text$mn:00002170                 jnz     short loc_21A9
.text$mn:00002172                 push    offset $SG126827 ; lpNewItem
.text$mn:00002177                 push    0               ; uIDNewItem
.text$mn:00002179                 push    0C00h           ; uFlags
.text$mn:0000217E                 movzx   eax, [ebp+var_438]
.text$mn:00002185                 push    eax             ; int
.text$mn:00002186                 mov     ecx, [ebp+uPosition]
.text$mn:00002189                 push    ecx
.text$mn:0000218A                 mov     ecx, [ebp+var_43C]
.text$mn:00002190                 add     ecx, 10h
.text$mn:00002193                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00002198                 mov     edx, [eax]
.text$mn:0000219A                 mov     eax, [edx+4]
.text$mn:0000219D                 push    eax             ; int
.text$mn:0000219E                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:000021A4                 jmp     loc_210E
.text$mn:000021A9 ; ---------------------------------------------------------------------------
.text$mn:000021A9
.text$mn:000021A9 loc_21A9:                               ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+FCj
.text$mn:000021A9                 mov     ecx, [ebp+uPosition]
.text$mn:000021AC                 push    ecx
.text$mn:000021AD                 mov     ecx, [ebp+var_43C]
.text$mn:000021B3                 add     ecx, 10h
.text$mn:000021B6                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:000021BB                 mov     edx, [eax]
.text$mn:000021BD                 movzx   eax, [ebp+var_438]
.text$mn:000021C4                 imul    ecx, eax, 90h
.text$mn:000021CA                 mov     edx, [edx+20h]
.text$mn:000021CD                 mov     eax, [edx+ecx+80h]
.text$mn:000021D4                 push    eax             ; int
.text$mn:000021D5                 movzx   ecx, [ebp+var_438]
.text$mn:000021DC                 push    ecx             ; int
.text$mn:000021DD                 mov     edx, [ebp+uPosition]
.text$mn:000021E0                 push    edx
.text$mn:000021E1                 mov     ecx, [ebp+var_43C]
.text$mn:000021E7                 add     ecx, 10h
.text$mn:000021EA                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:000021EF                 mov     ecx, [eax]
.text$mn:000021F1                 add     ecx, 28h ; '('
.text$mn:000021F4                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000021F9                 push    eax             ; Str
.text$mn:000021FA                 lea     ecx, [ebp+var_6C]
.text$mn:000021FD                 call    ??0PluginCommand@@QAE@PB_WHP6AXXZ@Z ; PluginCommand::PluginCommand(wchar_t const *,int,void (*)(void))
.text$mn:00002202                 mov     [ebp+var_45C], eax
.text$mn:00002208                 mov     eax, [ebp+var_45C]
.text$mn:0000220E                 mov     [ebp+var_460], eax
.text$mn:00002214                 mov     [ebp+var_4], 0
.text$mn:0000221B                 mov     ecx, [ebp+var_460]
.text$mn:00002221                 push    ecx
.text$mn:00002222                 mov     ecx, [ebp+var_43C]
.text$mn:00002228                 add     ecx, 20h ; ' '
.text$mn:0000222B                 call    ?push_back@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEX$$QAUPluginCommand@@@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)
.text$mn:00002230                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002237                 lea     ecx, [ebp+var_6C] ; this
.text$mn:0000223A                 call    ??1PluginCommand@@QAE@XZ ; PluginCommand::~PluginCommand(void)
.text$mn:0000223F                 mov     ecx, [ebp+var_43C]
.text$mn:00002245                 add     ecx, 20h ; ' '
.text$mn:00002248                 call    ?size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::size(void)
.text$mn:0000224D                 add     eax, 55EFh
.text$mn:00002252                 mov     [ebp+uIDNewItem], eax
.text$mn:00002258                 mov     edx, [ebp+uPosition]
.text$mn:0000225B                 push    edx
.text$mn:0000225C                 mov     ecx, [ebp+var_43C]
.text$mn:00002262                 add     ecx, 10h
.text$mn:00002265                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:0000226A                 mov     eax, [eax]
.text$mn:0000226C                 movzx   ecx, [ebp+var_438]
.text$mn:00002273                 imul    edx, ecx, 90h
.text$mn:00002279                 mov     eax, [eax+20h]
.text$mn:0000227C                 mov     ecx, [ebp+uIDNewItem]
.text$mn:00002282                 mov     [eax+edx+84h], ecx
.text$mn:00002289                 mov     edx, [ebp+uPosition]
.text$mn:0000228C                 push    edx
.text$mn:0000228D                 mov     ecx, [ebp+var_43C]
.text$mn:00002293                 add     ecx, 10h
.text$mn:00002296                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:0000229B                 mov     eax, [eax]
.text$mn:0000229D                 movzx   ecx, [ebp+var_438]
.text$mn:000022A4                 imul    edx, ecx, 90h
.text$mn:000022AA                 mov     eax, [eax+20h]
.text$mn:000022AD                 add     eax, edx
.text$mn:000022AF                 push    eax             ; Str
.text$mn:000022B0                 lea     ecx, [ebp+var_2C]
.text$mn:000022B3                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000022B8                 mov     [ebp+var_4], 1
.text$mn:000022BF                 mov     ecx, [ebp+uPosition]
.text$mn:000022C2                 push    ecx
.text$mn:000022C3                 mov     ecx, [ebp+var_43C]
.text$mn:000022C9                 add     ecx, 10h
.text$mn:000022CC                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:000022D1                 mov     edx, [eax]
.text$mn:000022D3                 movzx   eax, [ebp+var_438]
.text$mn:000022DA                 imul    ecx, eax, 90h
.text$mn:000022E0                 mov     edx, [edx+20h]
.text$mn:000022E3                 cmp     dword ptr [edx+ecx+8Ch], 0
.text$mn:000022EB                 jz      loc_2439
.text$mn:000022F1                 mov     eax, [ebp+uPosition]
.text$mn:000022F4                 push    eax
.text$mn:000022F5                 mov     ecx, [ebp+var_43C]
.text$mn:000022FB                 add     ecx, 10h
.text$mn:000022FE                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00002303                 mov     ecx, [eax]
.text$mn:00002305                 movzx   edx, [ebp+var_438]
.text$mn:0000230C                 imul    eax, edx, 90h
.text$mn:00002312                 mov     ecx, [ecx+20h]
.text$mn:00002315                 mov     edx, [ecx+eax+8Ch]
.text$mn:0000231C                 mov     [ebp+var_444], edx
.text$mn:00002322                 movzx   eax, [ebp+var_438]
.text$mn:00002329                 push    eax             ; __int16
.text$mn:0000232A                 mov     ecx, [ebp+uPosition]
.text$mn:0000232D                 push    ecx
.text$mn:0000232E                 mov     ecx, [ebp+var_43C]
.text$mn:00002334                 add     ecx, 10h
.text$mn:00002337                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:0000233C                 mov     ecx, [eax]
.text$mn:0000233E                 add     ecx, 28h ; '('
.text$mn:00002341                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002346                 push    eax             ; Str
.text$mn:00002347                 mov     edx, [ebp+uIDNewItem]
.text$mn:0000234D                 push    edx             ; int
.text$mn:0000234E                 sub     esp, 128h
.text$mn:00002354                 mov     esi, esp
.text$mn:00002356                 mov     [ebp+var_464], esp
.text$mn:0000235C                 mov     eax, [ebp+var_444]
.text$mn:00002362                 movzx   ecx, byte ptr [eax+3]
.text$mn:00002366                 push    ecx             ; char
.text$mn:00002367                 mov     edx, [ebp+var_444]
.text$mn:0000236D                 movzx   eax, byte ptr [edx+2]
.text$mn:00002371                 push    eax             ; char
.text$mn:00002372                 mov     ecx, [ebp+var_444]
.text$mn:00002378                 movzx   edx, byte ptr [ecx+1]
.text$mn:0000237C                 push    edx             ; char
.text$mn:0000237D                 mov     eax, [ebp+var_444]
.text$mn:00002383                 movzx   ecx, byte ptr [eax]
.text$mn:00002386                 push    ecx             ; char
.text$mn:00002387                 lea     ecx, [ebp+var_2C]
.text$mn:0000238A                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000238F                 push    eax             ; wchar_t *
.text$mn:00002390                 mov     ecx, esi
.text$mn:00002392                 call    ??0Shortcut@@QAE@PB_W_N11E@Z ; Shortcut::Shortcut(wchar_t const *,bool,bool,bool,uchar)
.text$mn:00002397                 mov     [ebp+var_454], eax
.text$mn:0000239D                 mov     edx, [ebp+var_454]
.text$mn:000023A3                 mov     [ebp+var_478], edx
.text$mn:000023A9                 mov     byte ptr [ebp+var_4], 2
.text$mn:000023AD                 mov     byte ptr [ebp+var_4], 1
.text$mn:000023B1                 lea     ecx, [ebp+var_1BC]
.text$mn:000023B7                 call    ??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z ; PluginCmdShortcut::PluginCmdShortcut(Shortcut,int,wchar_t const *,ushort)
.text$mn:000023BC                 mov     [ebp+var_46C], eax
.text$mn:000023C2                 mov     byte ptr [ebp+var_4], 3
.text$mn:000023C6                 lea     eax, [ebp+var_1BC]
.text$mn:000023CC                 push    eax
.text$mn:000023CD                 mov     ecx, [ebp+var_448]
.text$mn:000023D3                 call    ?push_back@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXABVPluginCmdShortcut@@@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)
.text$mn:000023D8                 push    offset $SG126836 ; "\t"
.text$mn:000023DD                 lea     ecx, [ebp+var_2C]
.text$mn:000023E0                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:000023E5                 lea     ecx, [ebp+var_48]
.text$mn:000023E8                 push    ecx
.text$mn:000023E9                 lea     ecx, [ebp+var_1BC]
.text$mn:000023EF                 call    ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.text$mn:000023F4                 mov     [ebp+var_44C], eax
.text$mn:000023FA                 mov     edx, [ebp+var_44C]
.text$mn:00002400                 mov     [ebp+var_450], edx
.text$mn:00002406                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000240A                 mov     eax, [ebp+var_450]
.text$mn:00002410                 push    eax
.text$mn:00002411                 lea     ecx, [ebp+var_2C]
.text$mn:00002414                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00002419                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000241D                 lea     ecx, [ebp+var_48]
.text$mn:00002420                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002425                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002429                 lea     ecx, [ebp+var_1BC] ; this
.text$mn:0000242F                 call    ??1PluginCmdShortcut@@UAE@XZ ; PluginCmdShortcut::~PluginCmdShortcut(void)
.text$mn:00002434                 jmp     loc_24FE
.text$mn:00002439 ; ---------------------------------------------------------------------------
.text$mn:00002439
.text$mn:00002439 loc_2439:                               ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+277j
.text$mn:00002439                 push    0               ; char
.text$mn:0000243B                 push    0               ; char
.text$mn:0000243D                 push    0               ; char
.text$mn:0000243F                 push    0               ; int
.text$mn:00002441                 lea     ecx, [ebp+var_2C]
.text$mn:00002444                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002449                 push    eax             ; int
.text$mn:0000244A                 lea     ecx, [ebp+var_2E4]
.text$mn:00002450                 call    ??0Shortcut@@QAE@PB_W_N11E@Z ; Shortcut::Shortcut(wchar_t const *,bool,bool,bool,uchar)
.text$mn:00002455                 mov     byte ptr [ebp+var_4], 5
.text$mn:00002459                 movzx   ecx, [ebp+var_438]
.text$mn:00002460                 push    ecx             ; __int16
.text$mn:00002461                 mov     edx, [ebp+uPosition]
.text$mn:00002464                 push    edx
.text$mn:00002465                 mov     ecx, [ebp+var_43C]
.text$mn:0000246B                 add     ecx, 10h
.text$mn:0000246E                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00002473                 mov     ecx, [eax]
.text$mn:00002475                 add     ecx, 28h ; '('
.text$mn:00002478                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000247D                 push    eax             ; Str
.text$mn:0000247E                 mov     eax, [ebp+uIDNewItem]
.text$mn:00002484                 push    eax             ; int
.text$mn:00002485                 sub     esp, 128h
.text$mn:0000248B                 mov     ecx, esp
.text$mn:0000248D                 mov     [ebp+var_474], esp
.text$mn:00002493                 lea     edx, [ebp+var_2E4]
.text$mn:00002499                 push    edx             ; Shortcut *
.text$mn:0000249A                 call    ??0Shortcut@@QAE@ABV0@@Z ; Shortcut::Shortcut(Shortcut const &)
.text$mn:0000249F                 mov     [ebp+var_458], eax
.text$mn:000024A5                 mov     eax, [ebp+var_458]
.text$mn:000024AB                 mov     [ebp+var_468], eax
.text$mn:000024B1                 mov     byte ptr [ebp+var_4], 6
.text$mn:000024B5                 mov     byte ptr [ebp+var_4], 5
.text$mn:000024B9                 lea     ecx, [ebp+var_434]
.text$mn:000024BF                 call    ??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z ; PluginCmdShortcut::PluginCmdShortcut(Shortcut,int,wchar_t const *,ushort)
.text$mn:000024C4                 mov     [ebp+var_470], eax
.text$mn:000024CA                 mov     byte ptr [ebp+var_4], 7
.text$mn:000024CE                 lea     ecx, [ebp+var_434]
.text$mn:000024D4                 push    ecx
.text$mn:000024D5                 mov     ecx, [ebp+var_448]
.text$mn:000024DB                 call    ?push_back@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXABVPluginCmdShortcut@@@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)
.text$mn:000024E0                 mov     byte ptr [ebp+var_4], 5
.text$mn:000024E4                 lea     ecx, [ebp+var_434] ; this
.text$mn:000024EA                 call    ??1PluginCmdShortcut@@UAE@XZ ; PluginCmdShortcut::~PluginCmdShortcut(void)
.text$mn:000024EF                 mov     byte ptr [ebp+var_4], 1
.text$mn:000024F3                 lea     ecx, [ebp+var_2E4] ; this
.text$mn:000024F9                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:000024FE
.text$mn:000024FE loc_24FE:                               ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+3C0j
.text$mn:000024FE                 lea     ecx, [ebp+var_2C]
.text$mn:00002501                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002506                 push    eax             ; lpNewItem
.text$mn:00002507                 mov     edx, [ebp+uIDNewItem]
.text$mn:0000250D                 push    edx             ; uIDNewItem
.text$mn:0000250E                 push    400h            ; uFlags
.text$mn:00002513                 movzx   eax, [ebp+var_438]
.text$mn:0000251A                 push    eax             ; uPosition
.text$mn:0000251B                 mov     ecx, [ebp+uPosition]
.text$mn:0000251E                 push    ecx
.text$mn:0000251F                 mov     ecx, [ebp+var_43C]
.text$mn:00002525                 add     ecx, 10h
.text$mn:00002528                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:0000252D                 mov     edx, [eax]
.text$mn:0000252F                 mov     eax, [edx+4]
.text$mn:00002532                 push    eax             ; hMenu
.text$mn:00002533                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:00002539                 mov     ecx, [ebp+uPosition]
.text$mn:0000253C                 push    ecx
.text$mn:0000253D                 mov     ecx, [ebp+var_43C]
.text$mn:00002543                 add     ecx, 10h
.text$mn:00002546                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:0000254B                 mov     edx, [eax]
.text$mn:0000254D                 movzx   eax, [ebp+var_438]
.text$mn:00002554                 imul    ecx, eax, 90h
.text$mn:0000255A                 mov     edx, [edx+20h]
.text$mn:0000255D                 movzx   eax, byte ptr [edx+ecx+88h]
.text$mn:00002565                 test    eax, eax
.text$mn:00002567                 jz      short loc_2582
.text$mn:00002569                 push    8               ; uCheck
.text$mn:0000256B                 mov     ecx, [ebp+uIDNewItem]
.text$mn:00002571                 push    ecx             ; uIDCheckItem
.text$mn:00002572                 mov     edx, [ebp+var_43C]
.text$mn:00002578                 mov     eax, [edx+0Ch]
.text$mn:0000257B                 push    eax             ; hMenu
.text$mn:0000257C                 call    dword ptr ds:__imp__CheckMenuItem@12 ; CheckMenuItem(x,x,x)
.text$mn:00002582
.text$mn:00002582 loc_2582:                               ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+4F3j
.text$mn:00002582                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002589                 lea     ecx, [ebp+var_2C]
.text$mn:0000258C                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002591                 jmp     loc_210E
.text$mn:00002596 ; ---------------------------------------------------------------------------
.text$mn:00002596
.text$mn:00002596 loc_2596:                               ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+CAj
.text$mn:00002596                 mov     ecx, [ebp+var_C]
.text$mn:00002599                 mov     large fs:0, ecx
.text$mn:000025A0                 pop     ecx
.text$mn:000025A1                 pop     esi
.text$mn:000025A2                 mov     ecx, [ebp+var_10]
.text$mn:000025A5                 xor     ecx, ebp
.text$mn:000025A7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000025AC                 mov     esp, ebp
.text$mn:000025AE                 pop     ebp
.text$mn:000025AF                 retn    4
.text$mn:000025AF ?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z endp
.text$mn:000025AF
.text$mn:000025AF ; ---------------------------------------------------------------------------
.text$mn:000025B2                 align 4
.text$mn:000025B4
.text$mn:000025B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000025B4
.text$mn:000025B4 ; Attributes: bp-based frame
.text$mn:000025B4
.text$mn:000025B4 ; HMENU __thiscall PluginsManager::setMenu(PluginsManager *this, HMENU hMenu, const wchar_t *)
.text$mn:000025B4                 public ?setMenu@PluginsManager@@QAEPAUHMENU__@@PAU2@PB_W@Z
.text$mn:000025B4 ?setMenu@PluginsManager@@QAEPAUHMENU__@@PAU2@PB_W@Z proc near
.text$mn:000025B4
.text$mn:000025B4 var_14          = dword ptr -14h
.text$mn:000025B4 lpNewItem       = dword ptr -10h
.text$mn:000025B4 var_C           = dword ptr -0Ch
.text$mn:000025B4 var_8           = dword ptr -8
.text$mn:000025B4 var_4           = dword ptr -4
.text$mn:000025B4 hMenu           = dword ptr  8
.text$mn:000025B4 arg_4           = dword ptr  0Ch
.text$mn:000025B4
.text$mn:000025B4                 push    ebp
.text$mn:000025B5                 mov     ebp, esp
.text$mn:000025B7                 sub     esp, 14h
.text$mn:000025BA                 mov     [ebp+var_4], ecx
.text$mn:000025BD                 mov     ecx, [ebp+var_4] ; this
.text$mn:000025C0                 call    ?hasPlugins@PluginsManager@@QAE_NXZ ; PluginsManager::hasPlugins(void)
.text$mn:000025C5                 movzx   eax, al
.text$mn:000025C8                 test    eax, eax
.text$mn:000025CA                 jz      loc_266D
.text$mn:000025D0                 cmp     [ebp+arg_4], 0
.text$mn:000025D4                 jz      short loc_25F1
.text$mn:000025D6                 mov     ecx, 2
.text$mn:000025DB                 imul    edx, ecx, 0
.text$mn:000025DE                 mov     eax, [ebp+arg_4]
.text$mn:000025E1                 movzx   ecx, word ptr [eax+edx]
.text$mn:000025E5                 test    ecx, ecx
.text$mn:000025E7                 jz      short loc_25F1
.text$mn:000025E9                 mov     edx, [ebp+arg_4]
.text$mn:000025EC                 mov     [ebp+var_C], edx
.text$mn:000025EF                 jmp     short loc_25F8
.text$mn:000025F1 ; ---------------------------------------------------------------------------
.text$mn:000025F1
.text$mn:000025F1 loc_25F1:                               ; CODE XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *)+20j
.text$mn:000025F1                                         ; PluginsManager::setMenu(HMENU__ *,wchar_t const *)+33j
.text$mn:000025F1                 mov     [ebp+var_C], offset $SG126852 ; "&Plugins"
.text$mn:000025F8
.text$mn:000025F8 loc_25F8:                               ; CODE XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *)+3Bj
.text$mn:000025F8                 mov     eax, [ebp+var_C]
.text$mn:000025FB                 mov     [ebp+lpNewItem], eax
.text$mn:000025FE                 mov     ecx, [ebp+var_4]
.text$mn:00002601                 cmp     dword ptr [ecx+0Ch], 0
.text$mn:00002605                 jnz     short loc_262F
.text$mn:00002607                 call    dword ptr ds:__imp__CreateMenu@0 ; CreateMenu()
.text$mn:0000260D                 mov     edx, [ebp+var_4]
.text$mn:00002610                 mov     [edx+0Ch], eax
.text$mn:00002613                 mov     eax, [ebp+lpNewItem]
.text$mn:00002616                 push    eax             ; lpNewItem
.text$mn:00002617                 mov     ecx, [ebp+var_4]
.text$mn:0000261A                 mov     edx, [ecx+0Ch]
.text$mn:0000261D                 push    edx             ; uIDNewItem
.text$mn:0000261E                 push    410h            ; uFlags
.text$mn:00002623                 push    9               ; uPosition
.text$mn:00002625                 mov     eax, [ebp+hMenu]
.text$mn:00002628                 push    eax             ; hMenu
.text$mn:00002629                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:0000262F
.text$mn:0000262F loc_262F:                               ; CODE XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *)+51j
.text$mn:0000262F                 mov     [ebp+var_8], 0
.text$mn:00002636                 mov     ecx, [ebp+var_4]
.text$mn:00002639                 add     ecx, 10h
.text$mn:0000263C                 call    ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::size(void)
.text$mn:00002641                 mov     [ebp+var_14], eax
.text$mn:00002644                 jmp     short loc_264F
.text$mn:00002646 ; ---------------------------------------------------------------------------
.text$mn:00002646
.text$mn:00002646 loc_2646:                               ; CODE XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *)+AFj
.text$mn:00002646                 mov     ecx, [ebp+var_8]
.text$mn:00002649                 add     ecx, 1
.text$mn:0000264C                 mov     [ebp+var_8], ecx
.text$mn:0000264F
.text$mn:0000264F loc_264F:                               ; CODE XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *)+90j
.text$mn:0000264F                 mov     edx, [ebp+var_8]
.text$mn:00002652                 cmp     edx, [ebp+var_14]
.text$mn:00002655                 jnb     short loc_2665
.text$mn:00002657                 mov     eax, [ebp+var_8]
.text$mn:0000265A                 push    eax             ; int
.text$mn:0000265B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000265E                 call    ?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z ; PluginsManager::addInMenuFromPMIndex(int)
.text$mn:00002663                 jmp     short loc_2646
.text$mn:00002665 ; ---------------------------------------------------------------------------
.text$mn:00002665
.text$mn:00002665 loc_2665:                               ; CODE XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *)+A1j
.text$mn:00002665                 mov     ecx, [ebp+var_4]
.text$mn:00002668                 mov     eax, [ecx+0Ch]
.text$mn:0000266B                 jmp     short loc_266F
.text$mn:0000266D ; ---------------------------------------------------------------------------
.text$mn:0000266D
.text$mn:0000266D loc_266D:                               ; CODE XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *)+16j
.text$mn:0000266D                 xor     eax, eax
.text$mn:0000266F
.text$mn:0000266F loc_266F:                               ; CODE XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *)+B7j
.text$mn:0000266F                 mov     esp, ebp
.text$mn:00002671                 pop     ebp
.text$mn:00002672                 retn    8
.text$mn:00002672 ?setMenu@PluginsManager@@QAEPAUHMENU__@@PAU2@PB_W@Z endp
.text$mn:00002672
.text$mn:00002672 ; ---------------------------------------------------------------------------
.text$mn:00002675                 db 0Fh dup(0CCh)
.text$mn:00002684
.text$mn:00002684 ; =============== S U B R O U T I N E =======================================
.text$mn:00002684
.text$mn:00002684 ; Attributes: bp-based frame
.text$mn:00002684
.text$mn:00002684 ; bool __thiscall PluginsManager::getShortcutByCmdID(PluginsManager *this, int, struct ShortcutKey *)
.text$mn:00002684                 public ?getShortcutByCmdID@PluginsManager@@QAE_NHPAUShortcutKey@@@Z
.text$mn:00002684 ?getShortcutByCmdID@PluginsManager@@QAE_NHPAUShortcutKey@@@Z proc near
.text$mn:00002684
.text$mn:00002684 var_14          = dword ptr -14h
.text$mn:00002684 var_10          = dword ptr -10h
.text$mn:00002684 var_C           = dword ptr -0Ch
.text$mn:00002684 var_8           = dword ptr -8
.text$mn:00002684 var_4           = dword ptr -4
.text$mn:00002684 arg_0           = dword ptr  8
.text$mn:00002684 arg_4           = dword ptr  0Ch
.text$mn:00002684
.text$mn:00002684                 push    ebp
.text$mn:00002685                 mov     ebp, esp
.text$mn:00002687                 sub     esp, 14h
.text$mn:0000268A                 mov     [ebp+var_14], ecx
.text$mn:0000268D                 cmp     [ebp+arg_0], 0
.text$mn:00002691                 jz      short loc_2699
.text$mn:00002693                 cmp     [ebp+arg_4], 0
.text$mn:00002697                 jnz     short loc_26A0
.text$mn:00002699
.text$mn:00002699 loc_2699:                               ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+Dj
.text$mn:00002699                 xor     al, al
.text$mn:0000269B                 jmp     loc_274A
.text$mn:000026A0 ; ---------------------------------------------------------------------------
.text$mn:000026A0
.text$mn:000026A0 loc_26A0:                               ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+13j
.text$mn:000026A0                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000026A5                 mov     ecx, eax
.text$mn:000026A7                 call    ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ ; NppParameters::getPluginCommandList(void)
.text$mn:000026AC                 mov     [ebp+var_C], eax
.text$mn:000026AF                 mov     [ebp+var_4], 0
.text$mn:000026B6                 mov     ecx, [ebp+var_C]
.text$mn:000026B9                 call    ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::size(void)
.text$mn:000026BE                 mov     [ebp+var_10], eax
.text$mn:000026C1                 jmp     short loc_26CC
.text$mn:000026C3 ; ---------------------------------------------------------------------------
.text$mn:000026C3
.text$mn:000026C3 loc_26C3:                               ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *):loc_2743j
.text$mn:000026C3                 mov     eax, [ebp+var_4]
.text$mn:000026C6                 add     eax, 1
.text$mn:000026C9                 mov     [ebp+var_4], eax
.text$mn:000026CC
.text$mn:000026CC loc_26CC:                               ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+3Dj
.text$mn:000026CC                 mov     ecx, [ebp+var_4]
.text$mn:000026CF                 cmp     ecx, [ebp+var_10]
.text$mn:000026D2                 jnb     short loc_2748
.text$mn:000026D4                 mov     edx, [ebp+var_4]
.text$mn:000026D7                 push    edx
.text$mn:000026D8                 mov     ecx, [ebp+var_C]
.text$mn:000026DB                 call    ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEABVPluginCmdShortcut@@I@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)
.text$mn:000026E0                 mov     ecx, eax        ; this
.text$mn:000026E2                 call    ?getID@PluginCmdShortcut@@QBEKXZ ; PluginCmdShortcut::getID(void)
.text$mn:000026E7                 cmp     eax, [ebp+arg_0]
.text$mn:000026EA                 jnz     short loc_2743
.text$mn:000026EC                 mov     eax, [ebp+var_4]
.text$mn:000026EF                 push    eax
.text$mn:000026F0                 mov     ecx, [ebp+var_C]
.text$mn:000026F3                 call    ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEABVPluginCmdShortcut@@I@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)
.text$mn:000026F8                 mov     ecx, eax        ; this
.text$mn:000026FA                 call    ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ ; Shortcut::getKeyCombo(void)
.text$mn:000026FF                 mov     [ebp+var_8], eax
.text$mn:00002702                 mov     ecx, [ebp+var_8]
.text$mn:00002705                 movzx   edx, byte ptr [ecx+3]
.text$mn:00002709                 test    edx, edx
.text$mn:0000270B                 jnz     short loc_2711
.text$mn:0000270D                 xor     al, al
.text$mn:0000270F                 jmp     short loc_274A
.text$mn:00002711 ; ---------------------------------------------------------------------------
.text$mn:00002711
.text$mn:00002711 loc_2711:                               ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+87j
.text$mn:00002711                 mov     eax, [ebp+arg_4]
.text$mn:00002714                 mov     ecx, [ebp+var_8]
.text$mn:00002717                 mov     dl, [ecx+1]
.text$mn:0000271A                 mov     [eax+1], dl
.text$mn:0000271D                 mov     eax, [ebp+arg_4]
.text$mn:00002720                 mov     ecx, [ebp+var_8]
.text$mn:00002723                 mov     dl, [ecx]
.text$mn:00002725                 mov     [eax], dl
.text$mn:00002727                 mov     eax, [ebp+arg_4]
.text$mn:0000272A                 mov     ecx, [ebp+var_8]
.text$mn:0000272D                 mov     dl, [ecx+2]
.text$mn:00002730                 mov     [eax+2], dl
.text$mn:00002733                 mov     eax, [ebp+arg_4]
.text$mn:00002736                 mov     ecx, [ebp+var_8]
.text$mn:00002739                 mov     dl, [ecx+3]
.text$mn:0000273C                 mov     [eax+3], dl
.text$mn:0000273F                 mov     al, 1
.text$mn:00002741                 jmp     short loc_274A
.text$mn:00002743 ; ---------------------------------------------------------------------------
.text$mn:00002743
.text$mn:00002743 loc_2743:                               ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+66j
.text$mn:00002743                 jmp     loc_26C3
.text$mn:00002748 ; ---------------------------------------------------------------------------
.text$mn:00002748
.text$mn:00002748 loc_2748:                               ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+4Ej
.text$mn:00002748                 xor     al, al
.text$mn:0000274A
.text$mn:0000274A loc_274A:                               ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+17j
.text$mn:0000274A                                         ; PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+8Bj ...
.text$mn:0000274A                 mov     esp, ebp
.text$mn:0000274C                 pop     ebp
.text$mn:0000274D                 retn    8
.text$mn:0000274D ?getShortcutByCmdID@PluginsManager@@QAE_NHPAUShortcutKey@@@Z endp
.text$mn:0000274D
.text$mn:0000274D ; ---------------------------------------------------------------------------
.text$mn:00002750                 db 4 dup(0CCh)
.text$mn:00002754
.text$mn:00002754 ; =============== S U B R O U T I N E =======================================
.text$mn:00002754
.text$mn:00002754 ; Attributes: bp-based frame
.text$mn:00002754
.text$mn:00002754 ; void __thiscall PluginsManager::notify(PluginsManager *this, const struct SCNotification *)
.text$mn:00002754                 public ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.text$mn:00002754 ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z proc near
.text$mn:00002754
.text$mn:00002754 var_188         = byte ptr -188h
.text$mn:00002754 var_120         = dword ptr -120h
.text$mn:00002754 var_11C         = dword ptr -11Ch
.text$mn:00002754 var_118         = dword ptr -118h
.text$mn:00002754 var_14          = dword ptr -14h
.text$mn:00002754 var_10          = dword ptr -10h
.text$mn:00002754 var_C           = dword ptr -0Ch
.text$mn:00002754 var_4           = dword ptr -4
.text$mn:00002754 arg_0           = dword ptr  8
.text$mn:00002754
.text$mn:00002754 ; FUNCTION CHUNK AT .text$mn:000028C1 SIZE 00000009 BYTES
.text$mn:00002754 ; FUNCTION CHUNK AT .text$mn:000028D3 SIZE 00000002 BYTES
.text$mn:00002754 ; FUNCTION CHUNK AT .text$mn:000028DC SIZE 00000023 BYTES
.text$mn:00002754
.text$mn:00002754                 push    ebp
.text$mn:00002755                 mov     ebp, esp
.text$mn:00002757                 push    0FFFFFFFFh
.text$mn:00002759                 push    offset __ehhandler$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.text$mn:0000275E                 mov     eax, large fs:0
.text$mn:00002764                 push    eax
.text$mn:00002765                 push    ecx
.text$mn:00002766                 sub     esp, 178h
.text$mn:0000276C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002771                 xor     eax, ebp
.text$mn:00002773                 mov     [ebp+var_14], eax
.text$mn:00002776                 push    ebx
.text$mn:00002777                 push    esi
.text$mn:00002778                 push    edi
.text$mn:00002779                 push    eax
.text$mn:0000277A                 lea     eax, [ebp+var_C]
.text$mn:0000277D                 mov     large fs:0, eax
.text$mn:00002783                 mov     [ebp+var_10], esp
.text$mn:00002786                 mov     [ebp+var_11C], ecx
.text$mn:0000278C                 mov     [ebp+var_118], 0
.text$mn:00002796                 mov     ecx, [ebp+var_11C]
.text$mn:0000279C                 add     ecx, 10h
.text$mn:0000279F                 call    ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::size(void)
.text$mn:000027A4                 mov     [ebp+var_120], eax
.text$mn:000027AA                 jmp     short loc_27BB
.text$mn:000027AC ; ---------------------------------------------------------------------------
.text$mn:000027AC
.text$mn:000027AC loc_27AC:                               ; CODE XREF: PluginsManager::notify(SCNotification const *):loc_28DCj
.text$mn:000027AC                 mov     eax, [ebp+var_118]
.text$mn:000027B2                 add     eax, 1
.text$mn:000027B5                 mov     [ebp+var_118], eax
.text$mn:000027BB
.text$mn:000027BB loc_27BB:                               ; CODE XREF: PluginsManager::notify(SCNotification const *)+56j
.text$mn:000027BB                 mov     ecx, [ebp+var_118]
.text$mn:000027C1                 cmp     ecx, [ebp+var_120]
.text$mn:000027C7                 jnb     loc_28E1
.text$mn:000027CD                 mov     edx, [ebp+var_118]
.text$mn:000027D3                 push    edx
.text$mn:000027D4                 mov     ecx, [ebp+var_11C]
.text$mn:000027DA                 add     ecx, 10h
.text$mn:000027DD                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:000027E2                 mov     eax, [eax]
.text$mn:000027E4                 cmp     dword ptr [eax], 0
.text$mn:000027E7                 jz      loc_28DC
.text$mn:000027ED                 mov     ecx, 17h
.text$mn:000027F2                 mov     esi, [ebp+arg_0]
.text$mn:000027F5                 lea     edi, [ebp+var_188]
.text$mn:000027FB                 rep movsd
.text$mn:000027FD                 mov     [ebp+var_4], 0
.text$mn:00002804                 lea     ecx, [ebp+var_188]
.text$mn:0000280A                 push    ecx
.text$mn:0000280B                 mov     edx, [ebp+var_118]
.text$mn:00002811                 push    edx
.text$mn:00002812                 mov     ecx, [ebp+var_11C]
.text$mn:00002818                 add     ecx, 10h
.text$mn:0000281B                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00002820                 mov     eax, [eax]
.text$mn:00002822                 mov     ecx, [eax+10h]
.text$mn:00002825                 call    ecx
.text$mn:00002827                 add     esp, 4
.text$mn:0000282A                 jmp     loc_28C1
.text$mn:0000282A ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z endp
.text$mn:0000282A
.text$mn:0000282F
.text$mn:0000282F ; =============== S U B R O U T I N E =======================================
.text$mn:0000282F
.text$mn:0000282F
.text$mn:0000282F __catch$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$0 proc near
.text$mn:0000282F                                         ; DATA XREF: .xdata$x:0000D1A8o
.text$mn:0000282F                 mov     byte ptr [ebp-4], 2
.text$mn:00002833                 push    0               ; uType
.text$mn:00002835                 push    offset $SG126901 ; "Exception"
.text$mn:0000283A                 lea     ecx, [ebp-12Ch] ; this
.text$mn:00002840                 call    ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.text$mn:00002845                 push    eax             ; lpText
.text$mn:00002846                 push    0               ; hWnd
.text$mn:00002848                 call    dword ptr ds:__imp__MessageBoxA@16 ; MessageBoxA(x,x,x,x)
.text$mn:0000284E                 mov     byte ptr [ebp-4], 1
.text$mn:00002852                 lea     ecx, [ebp-12Ch] ; this
.text$mn:00002858                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:0000285D                 mov     eax, offset $LN13_0
.text$mn:00002862                 retn
.text$mn:00002862 __catch$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$0 endp
.text$mn:00002862
.text$mn:00002863
.text$mn:00002863 ; =============== S U B R O U T I N E =======================================
.text$mn:00002863
.text$mn:00002863
.text$mn:00002863 __catch$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$1 proc near
.text$mn:00002863                                         ; DATA XREF: .xdata$x:0000D1B8o
.text$mn:00002863                 mov     edx, [ebp-184h]
.text$mn:00002869                 push    edx
.text$mn:0000286A                 mov     eax, [ebp-188h]
.text$mn:00002870                 push    eax
.text$mn:00002871                 mov     ecx, [ebp-180h]
.text$mn:00002877                 push    ecx
.text$mn:00002878                 push    offset $SG126903 ; "notify(SCNotification *notification) : "...
.text$mn:0000287D                 lea     edx, [ebp-114h]
.text$mn:00002883                 push    edx             ; Dest
.text$mn:00002884                 call    ?swprintf@@YAHPA_WPB_WZZ ; swprintf(wchar_t *,wchar_t const *,...)
.text$mn:00002889                 add     esp, 14h
.text$mn:0000288C                 lea     eax, [ebp-114h]
.text$mn:00002892                 push    eax             ; wchar_t *
.text$mn:00002893                 mov     ecx, [ebp-118h]
.text$mn:00002899                 push    ecx
.text$mn:0000289A                 mov     ecx, [ebp-11Ch]
.text$mn:000028A0                 add     ecx, 20h ; ' '
.text$mn:000028A3                 call    ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)
.text$mn:000028A8                 mov     ecx, eax
.text$mn:000028AA                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000028AF                 push    eax             ; Str
.text$mn:000028B0                 mov     ecx, [ebp-11Ch] ; this
.text$mn:000028B6                 call    ?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z ; PluginsManager::pluginCrashAlert(wchar_t const *,wchar_t const *)
.text$mn:000028BB                 mov     eax, offset $LN15
.text$mn:000028C0                 retn
.text$mn:000028C0 __catch$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$1 endp
.text$mn:000028C0
.text$mn:000028C1 ; ---------------------------------------------------------------------------
.text$mn:000028C1 ; START OF FUNCTION CHUNK FOR ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.text$mn:000028C1
.text$mn:000028C1 loc_28C1:                               ; CODE XREF: PluginsManager::notify(SCNotification const *)+D6j
.text$mn:000028C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028C8                 jmp     short loc_28D3
.text$mn:000028C8 ; END OF FUNCTION CHUNK FOR ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.text$mn:000028CA
.text$mn:000028CA ; =============== S U B R O U T I N E =======================================
.text$mn:000028CA
.text$mn:000028CA
.text$mn:000028CA $LN15           proc near               ; DATA XREF: __catch$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$1+58o
.text$mn:000028CA                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000028D1                 jmp     short loc_28DC
.text$mn:000028D1 $LN15           endp
.text$mn:000028D1
.text$mn:000028D3 ; ---------------------------------------------------------------------------
.text$mn:000028D3 ; START OF FUNCTION CHUNK FOR ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.text$mn:000028D3
.text$mn:000028D3 loc_28D3:                               ; CODE XREF: PluginsManager::notify(SCNotification const *)+174j
.text$mn:000028D3                 jmp     short loc_28DC
.text$mn:000028D3 ; END OF FUNCTION CHUNK FOR ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.text$mn:000028D5 ; ---------------------------------------------------------------------------
.text$mn:000028D5
.text$mn:000028D5 $LN13_0:                                ; DATA XREF: __catch$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$0+2Eo
.text$mn:000028D5                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000028DC ; START OF FUNCTION CHUNK FOR ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.text$mn:000028DC
.text$mn:000028DC loc_28DC:                               ; CODE XREF: PluginsManager::notify(SCNotification const *)+93j
.text$mn:000028DC                                         ; $LN15+7j ...
.text$mn:000028DC                 jmp     loc_27AC
.text$mn:000028E1 ; ---------------------------------------------------------------------------
.text$mn:000028E1
.text$mn:000028E1 loc_28E1:                               ; CODE XREF: PluginsManager::notify(SCNotification const *)+73j
.text$mn:000028E1                 mov     ecx, [ebp+var_C]
.text$mn:000028E4                 mov     large fs:0, ecx
.text$mn:000028EB                 pop     ecx
.text$mn:000028EC                 pop     edi
.text$mn:000028ED                 pop     esi
.text$mn:000028EE                 pop     ebx
.text$mn:000028EF                 mov     ecx, [ebp+var_14]
.text$mn:000028F2                 xor     ecx, ebp
.text$mn:000028F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000028F9                 mov     esp, ebp
.text$mn:000028FB                 pop     ebp
.text$mn:000028FC                 retn    4
.text$mn:000028FC ; END OF FUNCTION CHUNK FOR ?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.text$mn:000028FC ; ---------------------------------------------------------------------------
.text$mn:000028FF                 db 5 dup(0CCh)
.text$mn:00002904
.text$mn:00002904 ; =============== S U B R O U T I N E =======================================
.text$mn:00002904
.text$mn:00002904 ; Attributes: bp-based frame
.text$mn:00002904
.text$mn:00002904 ; void __thiscall PluginsManager::relayNppMessages(PluginsManager *this, unsigned int, unsigned int, __int32)
.text$mn:00002904                 public ?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.text$mn:00002904 ?relayNppMessages@PluginsManager@@QAEXIIJ@Z proc near
.text$mn:00002904
.text$mn:00002904 var_120         = dword ptr -120h
.text$mn:00002904 var_11C         = dword ptr -11Ch
.text$mn:00002904 var_118         = dword ptr -118h
.text$mn:00002904 var_14          = dword ptr -14h
.text$mn:00002904 var_10          = dword ptr -10h
.text$mn:00002904 var_C           = dword ptr -0Ch
.text$mn:00002904 var_4           = dword ptr -4
.text$mn:00002904 arg_0           = dword ptr  8
.text$mn:00002904 arg_4           = dword ptr  0Ch
.text$mn:00002904 arg_8           = dword ptr  10h
.text$mn:00002904
.text$mn:00002904 ; FUNCTION CHUNK AT .text$mn:00002A5B SIZE 00000009 BYTES
.text$mn:00002904 ; FUNCTION CHUNK AT .text$mn:00002A6D SIZE 00000002 BYTES
.text$mn:00002904 ; FUNCTION CHUNK AT .text$mn:00002A76 SIZE 00000023 BYTES
.text$mn:00002904
.text$mn:00002904                 push    ebp
.text$mn:00002905                 mov     ebp, esp
.text$mn:00002907                 push    0FFFFFFFFh
.text$mn:00002909                 push    offset __ehhandler$?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.text$mn:0000290E                 mov     eax, large fs:0
.text$mn:00002914                 push    eax
.text$mn:00002915                 push    ecx
.text$mn:00002916                 sub     esp, 11Ch
.text$mn:0000291C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002921                 xor     eax, ebp
.text$mn:00002923                 mov     [ebp+var_14], eax
.text$mn:00002926                 push    ebx
.text$mn:00002927                 push    esi
.text$mn:00002928                 push    edi
.text$mn:00002929                 push    eax
.text$mn:0000292A                 lea     eax, [ebp+var_C]
.text$mn:0000292D                 mov     large fs:0, eax
.text$mn:00002933                 mov     [ebp+var_10], esp
.text$mn:00002936                 mov     [ebp+var_11C], ecx
.text$mn:0000293C                 mov     [ebp+var_118], 0
.text$mn:00002946                 mov     ecx, [ebp+var_11C]
.text$mn:0000294C                 add     ecx, 10h
.text$mn:0000294F                 call    ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::size(void)
.text$mn:00002954                 mov     [ebp+var_120], eax
.text$mn:0000295A                 jmp     short loc_296B
.text$mn:0000295C ; ---------------------------------------------------------------------------
.text$mn:0000295C
.text$mn:0000295C loc_295C:                               ; CODE XREF: PluginsManager::relayNppMessages(uint,uint,long):loc_2A76j
.text$mn:0000295C                 mov     eax, [ebp+var_118]
.text$mn:00002962                 add     eax, 1
.text$mn:00002965                 mov     [ebp+var_118], eax
.text$mn:0000296B
.text$mn:0000296B loc_296B:                               ; CODE XREF: PluginsManager::relayNppMessages(uint,uint,long)+56j
.text$mn:0000296B                 mov     ecx, [ebp+var_118]
.text$mn:00002971                 cmp     ecx, [ebp+var_120]
.text$mn:00002977                 jnb     loc_2A7B
.text$mn:0000297D                 mov     edx, [ebp+var_118]
.text$mn:00002983                 push    edx
.text$mn:00002984                 mov     ecx, [ebp+var_11C]
.text$mn:0000298A                 add     ecx, 10h
.text$mn:0000298D                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00002992                 mov     eax, [eax]
.text$mn:00002994                 cmp     dword ptr [eax], 0
.text$mn:00002997                 jz      loc_2A76
.text$mn:0000299D                 mov     [ebp+var_4], 0
.text$mn:000029A4                 mov     ecx, [ebp+arg_8]
.text$mn:000029A7                 push    ecx
.text$mn:000029A8                 mov     edx, [ebp+arg_4]
.text$mn:000029AB                 push    edx
.text$mn:000029AC                 mov     eax, [ebp+arg_0]
.text$mn:000029AF                 push    eax
.text$mn:000029B0                 mov     ecx, [ebp+var_118]
.text$mn:000029B6                 push    ecx
.text$mn:000029B7                 mov     ecx, [ebp+var_11C]
.text$mn:000029BD                 add     ecx, 10h
.text$mn:000029C0                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:000029C5                 mov     edx, [eax]
.text$mn:000029C7                 mov     eax, [edx+18h]
.text$mn:000029CA                 call    eax
.text$mn:000029CC                 add     esp, 0Ch
.text$mn:000029CF                 jmp     loc_2A5B
.text$mn:000029CF ?relayNppMessages@PluginsManager@@QAEXIIJ@Z endp
.text$mn:000029CF
.text$mn:000029D4
.text$mn:000029D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029D4
.text$mn:000029D4
.text$mn:000029D4 __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$0 proc near
.text$mn:000029D4                                         ; DATA XREF: .xdata$x:0000D188o
.text$mn:000029D4                 mov     byte ptr [ebp-4], 2
.text$mn:000029D8                 push    0               ; uType
.text$mn:000029DA                 push    offset $SG126918 ; "Exception"
.text$mn:000029DF                 lea     ecx, [ebp-12Ch] ; this
.text$mn:000029E5                 call    ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.text$mn:000029EA                 push    eax             ; lpText
.text$mn:000029EB                 push    0               ; hWnd
.text$mn:000029ED                 call    dword ptr ds:__imp__MessageBoxA@16 ; MessageBoxA(x,x,x,x)
.text$mn:000029F3                 mov     byte ptr [ebp-4], 1
.text$mn:000029F7                 lea     ecx, [ebp-12Ch] ; this
.text$mn:000029FD                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00002A02                 mov     eax, offset $LN13_1
.text$mn:00002A07                 retn
.text$mn:00002A07 __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$0 endp
.text$mn:00002A07
.text$mn:00002A08
.text$mn:00002A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A08
.text$mn:00002A08
.text$mn:00002A08 __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$1 proc near
.text$mn:00002A08                                         ; DATA XREF: .xdata$x:0000D198o
.text$mn:00002A08                 mov     ecx, [ebp+10h]
.text$mn:00002A0B                 push    ecx
.text$mn:00002A0C                 mov     edx, [ebp+0Ch]
.text$mn:00002A0F                 push    edx
.text$mn:00002A10                 mov     eax, [ebp+8]
.text$mn:00002A13                 push    eax
.text$mn:00002A14                 push    offset $SG126920 ; "relayNppMessages(UINT Message : %d, WPA"...
.text$mn:00002A19                 lea     ecx, [ebp-114h]
.text$mn:00002A1F                 push    ecx             ; Dest
.text$mn:00002A20                 call    ?swprintf@@YAHPA_WPB_WZZ ; swprintf(wchar_t *,wchar_t const *,...)
.text$mn:00002A25                 add     esp, 14h
.text$mn:00002A28                 push    offset $SG126921 ; wchar_t *
.text$mn:00002A2D                 mov     edx, [ebp-118h]
.text$mn:00002A33                 push    edx
.text$mn:00002A34                 mov     ecx, [ebp-11Ch]
.text$mn:00002A3A                 add     ecx, 20h ; ' '
.text$mn:00002A3D                 call    ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)
.text$mn:00002A42                 mov     ecx, eax
.text$mn:00002A44                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002A49                 push    eax             ; Str
.text$mn:00002A4A                 mov     ecx, [ebp-11Ch] ; this
.text$mn:00002A50                 call    ?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z ; PluginsManager::pluginCrashAlert(wchar_t const *,wchar_t const *)
.text$mn:00002A55                 mov     eax, offset $LN15_0
.text$mn:00002A5A                 retn
.text$mn:00002A5A __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$1 endp
.text$mn:00002A5A
.text$mn:00002A5B ; ---------------------------------------------------------------------------
.text$mn:00002A5B ; START OF FUNCTION CHUNK FOR ?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.text$mn:00002A5B
.text$mn:00002A5B loc_2A5B:                               ; CODE XREF: PluginsManager::relayNppMessages(uint,uint,long)+CBj
.text$mn:00002A5B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A62                 jmp     short loc_2A6D
.text$mn:00002A62 ; END OF FUNCTION CHUNK FOR ?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.text$mn:00002A64
.text$mn:00002A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A64
.text$mn:00002A64
.text$mn:00002A64 $LN15_0         proc near               ; DATA XREF: __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$1+4Do
.text$mn:00002A64                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002A6B                 jmp     short loc_2A76
.text$mn:00002A6B $LN15_0         endp
.text$mn:00002A6B
.text$mn:00002A6D ; ---------------------------------------------------------------------------
.text$mn:00002A6D ; START OF FUNCTION CHUNK FOR ?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.text$mn:00002A6D
.text$mn:00002A6D loc_2A6D:                               ; CODE XREF: PluginsManager::relayNppMessages(uint,uint,long)+15Ej
.text$mn:00002A6D                 jmp     short loc_2A76
.text$mn:00002A6D ; END OF FUNCTION CHUNK FOR ?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.text$mn:00002A6F ; ---------------------------------------------------------------------------
.text$mn:00002A6F
.text$mn:00002A6F $LN13_1:                                ; DATA XREF: __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$0+2Eo
.text$mn:00002A6F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002A76 ; START OF FUNCTION CHUNK FOR ?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.text$mn:00002A76
.text$mn:00002A76 loc_2A76:                               ; CODE XREF: PluginsManager::relayNppMessages(uint,uint,long)+93j
.text$mn:00002A76                                         ; $LN15_0+7j ...
.text$mn:00002A76                 jmp     loc_295C
.text$mn:00002A7B ; ---------------------------------------------------------------------------
.text$mn:00002A7B
.text$mn:00002A7B loc_2A7B:                               ; CODE XREF: PluginsManager::relayNppMessages(uint,uint,long)+73j
.text$mn:00002A7B                 mov     ecx, [ebp+var_C]
.text$mn:00002A7E                 mov     large fs:0, ecx
.text$mn:00002A85                 pop     ecx
.text$mn:00002A86                 pop     edi
.text$mn:00002A87                 pop     esi
.text$mn:00002A88                 pop     ebx
.text$mn:00002A89                 mov     ecx, [ebp+var_14]
.text$mn:00002A8C                 xor     ecx, ebp
.text$mn:00002A8E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002A93                 mov     esp, ebp
.text$mn:00002A95                 pop     ebp
.text$mn:00002A96                 retn    0Ch
.text$mn:00002A96 ; END OF FUNCTION CHUNK FOR ?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.text$mn:00002A96 ; ---------------------------------------------------------------------------
.text$mn:00002A99                 db 0Bh dup(0CCh)
.text$mn:00002AA4
.text$mn:00002AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AA4
.text$mn:00002AA4 ; Attributes: bp-based frame
.text$mn:00002AA4
.text$mn:00002AA4 ; bool __thiscall PluginsManager::relayPluginMessages(PluginsManager *this, unsigned int, unsigned int, __int32)
.text$mn:00002AA4                 public ?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z
.text$mn:00002AA4 ?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z proc near
.text$mn:00002AA4
.text$mn:00002AA4 var_124         = dword ptr -124h
.text$mn:00002AA4 Str             = dword ptr -120h
.text$mn:00002AA4 var_11C         = dword ptr -11Ch
.text$mn:00002AA4 var_118         = dword ptr -118h
.text$mn:00002AA4 var_14          = dword ptr -14h
.text$mn:00002AA4 var_10          = dword ptr -10h
.text$mn:00002AA4 var_C           = dword ptr -0Ch
.text$mn:00002AA4 var_4           = dword ptr -4
.text$mn:00002AA4 arg_0           = dword ptr  8
.text$mn:00002AA4 arg_4           = dword ptr  0Ch
.text$mn:00002AA4 arg_8           = dword ptr  10h
.text$mn:00002AA4
.text$mn:00002AA4 ; FUNCTION CHUNK AT .text$mn:00002C67 SIZE 00000009 BYTES
.text$mn:00002AA4 ; FUNCTION CHUNK AT .text$mn:00002C86 SIZE 00000025 BYTES
.text$mn:00002AA4
.text$mn:00002AA4                 push    ebp
.text$mn:00002AA5                 mov     ebp, esp
.text$mn:00002AA7                 push    0FFFFFFFFh
.text$mn:00002AA9                 push    offset __ehhandler$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z
.text$mn:00002AAE                 mov     eax, large fs:0
.text$mn:00002AB4                 push    eax
.text$mn:00002AB5                 push    ecx
.text$mn:00002AB6                 sub     esp, 120h
.text$mn:00002ABC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002AC1                 xor     eax, ebp
.text$mn:00002AC3                 mov     [ebp+var_14], eax
.text$mn:00002AC6                 push    ebx
.text$mn:00002AC7                 push    esi
.text$mn:00002AC8                 push    edi
.text$mn:00002AC9                 push    eax
.text$mn:00002ACA                 lea     eax, [ebp+var_C]
.text$mn:00002ACD                 mov     large fs:0, eax
.text$mn:00002AD3                 mov     [ebp+var_10], esp
.text$mn:00002AD6                 mov     [ebp+var_11C], ecx
.text$mn:00002ADC                 mov     eax, [ebp+arg_4]
.text$mn:00002ADF                 mov     [ebp+Str], eax
.text$mn:00002AE5                 cmp     [ebp+Str], 0
.text$mn:00002AEC                 jz      short loc_2B0A
.text$mn:00002AEE                 mov     ecx, 2
.text$mn:00002AF3                 imul    edx, ecx, 0
.text$mn:00002AF6                 mov     eax, [ebp+Str]
.text$mn:00002AFC                 movzx   ecx, word ptr [eax+edx]
.text$mn:00002B00                 test    ecx, ecx
.text$mn:00002B02                 jz      short loc_2B0A
.text$mn:00002B04                 cmp     [ebp+arg_8], 0
.text$mn:00002B08                 jnz     short loc_2B11
.text$mn:00002B0A
.text$mn:00002B0A loc_2B0A:                               ; CODE XREF: PluginsManager::relayPluginMessages(uint,uint,long)+48j
.text$mn:00002B0A                                         ; PluginsManager::relayPluginMessages(uint,uint,long)+5Ej
.text$mn:00002B0A                 xor     al, al
.text$mn:00002B0C                 jmp     loc_2C8D
.text$mn:00002B11 ; ---------------------------------------------------------------------------
.text$mn:00002B11
.text$mn:00002B11 loc_2B11:                               ; CODE XREF: PluginsManager::relayPluginMessages(uint,uint,long)+64j
.text$mn:00002B11                 mov     [ebp+var_118], 0
.text$mn:00002B1B                 mov     ecx, [ebp+var_11C]
.text$mn:00002B21                 add     ecx, 10h
.text$mn:00002B24                 call    ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::size(void)
.text$mn:00002B29                 mov     [ebp+var_124], eax
.text$mn:00002B2F                 jmp     short loc_2B40
.text$mn:00002B31 ; ---------------------------------------------------------------------------
.text$mn:00002B31
.text$mn:00002B31 loc_2B31:                               ; CODE XREF: PluginsManager::relayPluginMessages(uint,uint,long):loc_2C86j
.text$mn:00002B31                 mov     edx, [ebp+var_118]
.text$mn:00002B37                 add     edx, 1
.text$mn:00002B3A                 mov     [ebp+var_118], edx
.text$mn:00002B40
.text$mn:00002B40 loc_2B40:                               ; CODE XREF: PluginsManager::relayPluginMessages(uint,uint,long)+8Bj
.text$mn:00002B40                 mov     eax, [ebp+var_118]
.text$mn:00002B46                 cmp     eax, [ebp+var_124]
.text$mn:00002B4C                 jnb     loc_2C8B
.text$mn:00002B52                 mov     ecx, [ebp+Str]
.text$mn:00002B58                 push    ecx             ; Str
.text$mn:00002B59                 mov     edx, [ebp+var_118]
.text$mn:00002B5F                 push    edx
.text$mn:00002B60                 mov     ecx, [ebp+var_11C]
.text$mn:00002B66                 add     ecx, 10h
.text$mn:00002B69                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00002B6E                 mov     eax, [eax]
.text$mn:00002B70                 add     eax, 28h ; '('
.text$mn:00002B73                 push    eax             ; int
.text$mn:00002B74                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00002B79                 add     esp, 8
.text$mn:00002B7C                 movzx   ecx, al
.text$mn:00002B7F                 test    ecx, ecx
.text$mn:00002B81                 jz      loc_2C86
.text$mn:00002B87                 mov     edx, [ebp+var_118]
.text$mn:00002B8D                 push    edx
.text$mn:00002B8E                 mov     ecx, [ebp+var_11C]
.text$mn:00002B94                 add     ecx, 10h
.text$mn:00002B97                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00002B9C                 mov     eax, [eax]
.text$mn:00002B9E                 cmp     dword ptr [eax], 0
.text$mn:00002BA1                 jz      loc_2C86
.text$mn:00002BA7                 mov     [ebp+var_4], 0
.text$mn:00002BAE                 mov     ecx, [ebp+arg_8]
.text$mn:00002BB1                 push    ecx
.text$mn:00002BB2                 mov     edx, [ebp+arg_4]
.text$mn:00002BB5                 push    edx
.text$mn:00002BB6                 mov     eax, [ebp+arg_0]
.text$mn:00002BB9                 push    eax
.text$mn:00002BBA                 mov     ecx, [ebp+var_118]
.text$mn:00002BC0                 push    ecx
.text$mn:00002BC1                 mov     ecx, [ebp+var_11C]
.text$mn:00002BC7                 add     ecx, 10h
.text$mn:00002BCA                 call    ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)
.text$mn:00002BCF                 mov     edx, [eax]
.text$mn:00002BD1                 mov     eax, [edx+18h]
.text$mn:00002BD4                 call    eax
.text$mn:00002BD6                 add     esp, 0Ch
.text$mn:00002BD9                 jmp     loc_2C67
.text$mn:00002BD9 ?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z endp
.text$mn:00002BD9
.text$mn:00002BDE
.text$mn:00002BDE ; =============== S U B R O U T I N E =======================================
.text$mn:00002BDE
.text$mn:00002BDE
.text$mn:00002BDE __catch$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$0 proc near
.text$mn:00002BDE                                         ; DATA XREF: .xdata$x:0000D168o
.text$mn:00002BDE                 mov     byte ptr [ebp-4], 2
.text$mn:00002BE2                 push    0               ; uType
.text$mn:00002BE4                 push    offset $SG126957 ; "Exception"
.text$mn:00002BE9                 lea     ecx, [ebp-130h] ; this
.text$mn:00002BEF                 call    ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.text$mn:00002BF4                 push    eax             ; lpText
.text$mn:00002BF5                 push    0               ; hWnd
.text$mn:00002BF7                 call    dword ptr ds:__imp__MessageBoxA@16 ; MessageBoxA(x,x,x,x)
.text$mn:00002BFD                 mov     byte ptr [ebp-4], 1
.text$mn:00002C01                 lea     ecx, [ebp-130h] ; this
.text$mn:00002C07                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00002C0C                 mov     eax, offset $LN16_0
.text$mn:00002C11                 retn
.text$mn:00002C11 __catch$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$0 endp
.text$mn:00002C11
.text$mn:00002C12
.text$mn:00002C12 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C12
.text$mn:00002C12
.text$mn:00002C12 __catch$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$1 proc near
.text$mn:00002C12                                         ; DATA XREF: .xdata$x:0000D178o
.text$mn:00002C12                 mov     ecx, [ebp+10h]
.text$mn:00002C15                 push    ecx
.text$mn:00002C16                 mov     edx, [ebp+0Ch]
.text$mn:00002C19                 push    edx
.text$mn:00002C1A                 mov     eax, [ebp+8]
.text$mn:00002C1D                 push    eax
.text$mn:00002C1E                 push    offset $SG126959 ; "relayPluginMessages(UINT Message : %d, "...
.text$mn:00002C23                 lea     ecx, [ebp-114h]
.text$mn:00002C29                 push    ecx             ; Dest
.text$mn:00002C2A                 call    ?swprintf@@YAHPA_WPB_WZZ ; swprintf(wchar_t *,wchar_t const *,...)
.text$mn:00002C2F                 add     esp, 14h
.text$mn:00002C32                 lea     edx, [ebp-114h]
.text$mn:00002C38                 push    edx             ; wchar_t *
.text$mn:00002C39                 mov     eax, [ebp-118h]
.text$mn:00002C3F                 push    eax
.text$mn:00002C40                 mov     ecx, [ebp-11Ch]
.text$mn:00002C46                 add     ecx, 20h ; ' '
.text$mn:00002C49                 call    ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)
.text$mn:00002C4E                 mov     ecx, eax
.text$mn:00002C50                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002C55                 push    eax             ; Str
.text$mn:00002C56                 mov     ecx, [ebp-11Ch] ; this
.text$mn:00002C5C                 call    ?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z ; PluginsManager::pluginCrashAlert(wchar_t const *,wchar_t const *)
.text$mn:00002C61                 mov     eax, offset $LN18
.text$mn:00002C66                 retn
.text$mn:00002C66 __catch$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$1 endp
.text$mn:00002C66
.text$mn:00002C67 ; ---------------------------------------------------------------------------
.text$mn:00002C67 ; START OF FUNCTION CHUNK FOR ?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z
.text$mn:00002C67
.text$mn:00002C67 loc_2C67:                               ; CODE XREF: PluginsManager::relayPluginMessages(uint,uint,long)+135j
.text$mn:00002C67                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C6E                 jmp     short loc_2C79
.text$mn:00002C6E ; END OF FUNCTION CHUNK FOR ?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z
.text$mn:00002C70
.text$mn:00002C70 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C70
.text$mn:00002C70
.text$mn:00002C70 $LN18           proc near               ; DATA XREF: __catch$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$1+4Fo
.text$mn:00002C70                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002C77                 jmp     short loc_2C82
.text$mn:00002C79 ; ---------------------------------------------------------------------------
.text$mn:00002C79
.text$mn:00002C79 loc_2C79:                               ; CODE XREF: PluginsManager::relayPluginMessages(uint,uint,long)+1CAj
.text$mn:00002C79                 jmp     short loc_2C82
.text$mn:00002C7B ; ---------------------------------------------------------------------------
.text$mn:00002C7B
.text$mn:00002C7B $LN16_0:                                ; DATA XREF: __catch$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$0+2Eo
.text$mn:00002C7B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002C82
.text$mn:00002C82 loc_2C82:                               ; CODE XREF: $LN18+7j
.text$mn:00002C82                                         ; $LN18:loc_2C79j
.text$mn:00002C82                 mov     al, 1
.text$mn:00002C84                 jmp     short loc_2C8D
.text$mn:00002C84 $LN18           endp
.text$mn:00002C84
.text$mn:00002C86 ; ---------------------------------------------------------------------------
.text$mn:00002C86 ; START OF FUNCTION CHUNK FOR ?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z
.text$mn:00002C86
.text$mn:00002C86 loc_2C86:                               ; CODE XREF: PluginsManager::relayPluginMessages(uint,uint,long)+DDj
.text$mn:00002C86                                         ; PluginsManager::relayPluginMessages(uint,uint,long)+FDj
.text$mn:00002C86                 jmp     loc_2B31
.text$mn:00002C8B ; ---------------------------------------------------------------------------
.text$mn:00002C8B
.text$mn:00002C8B loc_2C8B:                               ; CODE XREF: PluginsManager::relayPluginMessages(uint,uint,long)+A8j
.text$mn:00002C8B                 xor     al, al
.text$mn:00002C8D
.text$mn:00002C8D loc_2C8D:                               ; CODE XREF: PluginsManager::relayPluginMessages(uint,uint,long)+68j
.text$mn:00002C8D                                         ; $LN18+14j
.text$mn:00002C8D                 mov     ecx, [ebp+var_C]
.text$mn:00002C90                 mov     large fs:0, ecx
.text$mn:00002C97                 pop     ecx
.text$mn:00002C98                 pop     edi
.text$mn:00002C99                 pop     esi
.text$mn:00002C9A                 pop     ebx
.text$mn:00002C9B                 mov     ecx, [ebp+var_14]
.text$mn:00002C9E                 xor     ecx, ebp
.text$mn:00002CA0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002CA5                 mov     esp, ebp
.text$mn:00002CA7                 pop     ebp
.text$mn:00002CA8                 retn    0Ch
.text$mn:00002CA8 ; END OF FUNCTION CHUNK FOR ?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z
.text$mn:00002CA8 ; ---------------------------------------------------------------------------
.text$mn:00002CAB                 db 9 dup(0CCh)
.text$mn:00002CB4
.text$mn:00002CB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CB4
.text$mn:00002CB4 ; Attributes: bp-based frame
.text$mn:00002CB4
.text$mn:00002CB4 ; bool __thiscall PluginsManager::allocateCmdID(PluginsManager *this, int, int *)
.text$mn:00002CB4                 public ?allocateCmdID@PluginsManager@@QAE_NHPAH@Z
.text$mn:00002CB4 ?allocateCmdID@PluginsManager@@QAE_NHPAH@Z proc near
.text$mn:00002CB4
.text$mn:00002CB4 var_8           = dword ptr -8
.text$mn:00002CB4 var_1           = byte ptr -1
.text$mn:00002CB4 arg_0           = dword ptr  8
.text$mn:00002CB4 arg_4           = dword ptr  0Ch
.text$mn:00002CB4
.text$mn:00002CB4                 push    ebp
.text$mn:00002CB5                 mov     ebp, esp
.text$mn:00002CB7                 sub     esp, 8
.text$mn:00002CBA                 mov     [ebp+var_8], ecx
.text$mn:00002CBD                 mov     [ebp+var_1], 1
.text$mn:00002CC1                 mov     eax, [ebp+arg_0]
.text$mn:00002CC4                 push    eax             ; int
.text$mn:00002CC5                 mov     ecx, [ebp+var_8]
.text$mn:00002CC8                 add     ecx, 44h ; 'D'  ; this
.text$mn:00002CCB                 call    ?allocate@IDAllocator@@QAEHH@Z ; IDAllocator::allocate(int)
.text$mn:00002CD0                 mov     ecx, [ebp+arg_4]
.text$mn:00002CD3                 mov     [ecx], eax
.text$mn:00002CD5                 mov     edx, [ebp+arg_4]
.text$mn:00002CD8                 cmp     dword ptr [edx], 0FFFFFFFFh
.text$mn:00002CDB                 jnz     short loc_2CEA
.text$mn:00002CDD                 mov     eax, [ebp+arg_4]
.text$mn:00002CE0                 mov     dword ptr [eax], 0
.text$mn:00002CE6                 mov     [ebp+var_1], 0
.text$mn:00002CEA
.text$mn:00002CEA loc_2CEA:                               ; CODE XREF: PluginsManager::allocateCmdID(int,int *)+27j
.text$mn:00002CEA                 mov     al, [ebp+var_1]
.text$mn:00002CED                 mov     esp, ebp
.text$mn:00002CEF                 pop     ebp
.text$mn:00002CF0                 retn    8
.text$mn:00002CF0 ?allocateCmdID@PluginsManager@@QAE_NHPAH@Z endp
.text$mn:00002CF0
.text$mn:00002CF0 ; ---------------------------------------------------------------------------
.text$mn:00002CF3                 align 4
.text$mn:00002CF4
.text$mn:00002CF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CF4
.text$mn:00002CF4 ; Attributes: bp-based frame
.text$mn:00002CF4
.text$mn:00002CF4 ; bool __thiscall PluginsManager::allocateMarker(PluginsManager *this, int, int *)
.text$mn:00002CF4                 public ?allocateMarker@PluginsManager@@QAE_NHPAH@Z
.text$mn:00002CF4 ?allocateMarker@PluginsManager@@QAE_NHPAH@Z proc near
.text$mn:00002CF4
.text$mn:00002CF4 var_8           = dword ptr -8
.text$mn:00002CF4 var_1           = byte ptr -1
.text$mn:00002CF4 arg_0           = dword ptr  8
.text$mn:00002CF4 arg_4           = dword ptr  0Ch
.text$mn:00002CF4
.text$mn:00002CF4                 push    ebp
.text$mn:00002CF5                 mov     ebp, esp
.text$mn:00002CF7                 sub     esp, 8
.text$mn:00002CFA                 mov     [ebp+var_8], ecx
.text$mn:00002CFD                 mov     [ebp+var_1], 1
.text$mn:00002D01                 mov     eax, [ebp+arg_0]
.text$mn:00002D04                 push    eax             ; int
.text$mn:00002D05                 mov     ecx, [ebp+var_8]
.text$mn:00002D08                 add     ecx, 50h ; 'P'  ; this
.text$mn:00002D0B                 call    ?allocate@IDAllocator@@QAEHH@Z ; IDAllocator::allocate(int)
.text$mn:00002D10                 mov     ecx, [ebp+arg_4]
.text$mn:00002D13                 mov     [ecx], eax
.text$mn:00002D15                 mov     edx, [ebp+arg_4]
.text$mn:00002D18                 cmp     dword ptr [edx], 0FFFFFFFFh
.text$mn:00002D1B                 jnz     short loc_2D2A
.text$mn:00002D1D                 mov     eax, [ebp+arg_4]
.text$mn:00002D20                 mov     dword ptr [eax], 0
.text$mn:00002D26                 mov     [ebp+var_1], 0
.text$mn:00002D2A
.text$mn:00002D2A loc_2D2A:                               ; CODE XREF: PluginsManager::allocateMarker(int,int *)+27j
.text$mn:00002D2A                 mov     al, [ebp+var_1]
.text$mn:00002D2D                 mov     esp, ebp
.text$mn:00002D2F                 pop     ebp
.text$mn:00002D30                 retn    8
.text$mn:00002D30 ?allocateMarker@PluginsManager@@QAE_NHPAH@Z endp
.text$mn:00002D30
.text$mn:00002D30 ; ---------------------------------------------------------------------------
.text$mn:00002D33                 align 4
.text$mn:00002D33 _text$mn        ends
.text$mn:00002D33
.text$x:00002D34 ; ===========================================================================
.text$x:00002D34
.text$x:00002D34 ; Segment type: Pure code
.text$x:00002D34 ; Segment permissions: Read/Execute
.text$x:00002D34 _text$x         segment para public 'CODE' use32
.text$x:00002D34                 assume cs:_text$x
.text$x:00002D34                 ;org 2D34h
.text$x:00002D34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002D34
.text$x:00002D34 ; =============== S U B R O U T I N E =======================================
.text$x:00002D34
.text$x:00002D34
.text$x:00002D34 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$4 proc near
.text$x:00002D34                                         ; DATA XREF: .xdata$x:0000D390o
.text$x:00002D34                 mov     eax, [ebp-57Ch]
.text$x:00002D3A                 push    eax             ; void *
.text$x:00002D3B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002D40                 pop     ecx
.text$x:00002D41                 retn
.text$x:00002D41 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$4 endp
.text$x:00002D41
.text$x:00002D42
.text$x:00002D42 ; =============== S U B R O U T I N E =======================================
.text$x:00002D42
.text$x:00002D42
.text$x:00002D42 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$5 proc near
.text$x:00002D42                                         ; DATA XREF: .xdata$x:0000D3A0o
.text$x:00002D42                 mov     eax, [ebp-56Ch]
.text$x:00002D48                 push    eax             ; void *
.text$x:00002D49                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002D4E                 pop     ecx
.text$x:00002D4F                 retn
.text$x:00002D4F __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$5 endp
.text$x:00002D4F
.text$x:00002D50
.text$x:00002D50 ; =============== S U B R O U T I N E =======================================
.text$x:00002D50
.text$x:00002D50
.text$x:00002D50 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$6 proc near
.text$x:00002D50                                         ; DATA XREF: .xdata$x:0000D3A8o
.text$x:00002D50                 lea     ecx, [ebp-3A8h]
.text$x:00002D56                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002D56 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$6 endp
.text$x:00002D56
.text$x:00002D5B
.text$x:00002D5B ; =============== S U B R O U T I N E =======================================
.text$x:00002D5B
.text$x:00002D5B
.text$x:00002D5B __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$7 proc near
.text$x:00002D5B                                         ; DATA XREF: .xdata$x:0000D3B0o
.text$x:00002D5B                 lea     ecx, [ebp-450h]
.text$x:00002D61                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002D61 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$7 endp
.text$x:00002D61
.text$x:00002D66
.text$x:00002D66 ; =============== S U B R O U T I N E =======================================
.text$x:00002D66
.text$x:00002D66
.text$x:00002D66 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$8 proc near
.text$x:00002D66                                         ; DATA XREF: .xdata$x:0000D3B8o
.text$x:00002D66                 lea     ecx, [ebp-418h]
.text$x:00002D6C                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002D6C __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$8 endp
.text$x:00002D6C
.text$x:00002D71
.text$x:00002D71 ; =============== S U B R O U T I N E =======================================
.text$x:00002D71
.text$x:00002D71
.text$x:00002D71 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$9 proc near
.text$x:00002D71                                         ; DATA XREF: .xdata$x:0000D3C0o
.text$x:00002D71                 mov     eax, [ebp-554h]
.text$x:00002D77                 push    eax             ; void *
.text$x:00002D78                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002D7D                 pop     ecx
.text$x:00002D7E                 retn
.text$x:00002D7E __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$9 endp
.text$x:00002D7E
.text$x:00002D7F
.text$x:00002D7F ; =============== S U B R O U T I N E =======================================
.text$x:00002D7F
.text$x:00002D7F
.text$x:00002D7F __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$10 proc near
.text$x:00002D7F                                         ; DATA XREF: .xdata$x:0000D3C8o
.text$x:00002D7F                 lea     ecx, [ebp-4F8h]
.text$x:00002D85                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002D85 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$10 endp
.text$x:00002D85
.text$x:00002D8A
.text$x:00002D8A ; =============== S U B R O U T I N E =======================================
.text$x:00002D8A
.text$x:00002D8A
.text$x:00002D8A __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$11 proc near
.text$x:00002D8A                                         ; DATA XREF: .xdata$x:0000D3D0o
.text$x:00002D8A                 lea     ecx, [ebp-4C0h]
.text$x:00002D90                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002D90 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$11 endp
.text$x:00002D90
.text$x:00002D95
.text$x:00002D95 ; =============== S U B R O U T I N E =======================================
.text$x:00002D95
.text$x:00002D95
.text$x:00002D95 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$12 proc near
.text$x:00002D95                                         ; DATA XREF: .xdata$x:0000D3E0o
.text$x:00002D95                 lea     ecx, [ebp-5F8h] ; this
.text$x:00002D9B                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00002D9B __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$12 endp
.text$x:00002D9B
.text$x:00002DA0
.text$x:00002DA0 ; =============== S U B R O U T I N E =======================================
.text$x:00002DA0
.text$x:00002DA0
.text$x:00002DA0 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$13 proc near
.text$x:00002DA0                                         ; DATA XREF: .xdata$x:0000D3E8o
.text$x:00002DA0                 lea     ecx, [ebp-31Ch]
.text$x:00002DA6                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002DA6 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$13 endp
.text$x:00002DA6
.text$x:00002DAB
.text$x:00002DAB ; =============== S U B R O U T I N E =======================================
.text$x:00002DAB
.text$x:00002DAB
.text$x:00002DAB __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$14 proc near
.text$x:00002DAB                                         ; DATA XREF: .xdata$x:0000D3F0o
.text$x:00002DAB                 lea     ecx, [ebp-354h]
.text$x:00002DB1                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002DB1 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$14 endp
.text$x:00002DB1
.text$x:00002DB6
.text$x:00002DB6 ; =============== S U B R O U T I N E =======================================
.text$x:00002DB6
.text$x:00002DB6
.text$x:00002DB6 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$15 proc near
.text$x:00002DB6                                         ; DATA XREF: .xdata$x:0000D3F8o
.text$x:00002DB6                 lea     ecx, [ebp-300h]
.text$x:00002DBC                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002DBC __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$15 endp
.text$x:00002DBC
.text$x:00002DC1
.text$x:00002DC1 ; =============== S U B R O U T I N E =======================================
.text$x:00002DC1
.text$x:00002DC1
.text$x:00002DC1 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$16 proc near
.text$x:00002DC1                                         ; DATA XREF: .xdata$x:0000D400o
.text$x:00002DC1                 lea     ecx, [ebp-338h]
.text$x:00002DC7                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002DC7 __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$16 endp
.text$x:00002DC7
.text$x:00002DCC
.text$x:00002DCC ; =============== S U B R O U T I N E =======================================
.text$x:00002DCC
.text$x:00002DCC
.text$x:00002DCC __ehhandler$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z proc near
.text$x:00002DCC                                         ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+5o
.text$x:00002DCC
.text$x:00002DCC arg_4           = dword ptr  8
.text$x:00002DCC
.text$x:00002DCC                 mov     edx, [esp+arg_4]
.text$x:00002DD0                 lea     eax, [edx+0Ch]
.text$x:00002DD3                 mov     ecx, [edx-5FCh]
.text$x:00002DD9                 xor     ecx, eax
.text$x:00002DDB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DE0                 mov     ecx, [edx-8]
.text$x:00002DE3                 xor     ecx, eax
.text$x:00002DE5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DEA                 mov     eax, offset __ehfuncinfo$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z
.text$x:00002DEF                 jmp     ___CxxFrameHandler3
.text$x:00002DEF __ehhandler$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z endp
.text$x:00002DEF
.text$x:00002DF4
.text$x:00002DF4 ; =============== S U B R O U T I N E =======================================
.text$x:00002DF4
.text$x:00002DF4
.text$x:00002DF4 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$0 proc near
.text$x:00002DF4                                         ; DATA XREF: .xdata$x:0000D408o
.text$x:00002DF4                 lea     ecx, [ebp-3FCh]
.text$x:00002DFA                 jmp     ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00002DFA __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$0 endp
.text$x:00002DFA
.text$x:00002DFF
.text$x:00002DFF ; =============== S U B R O U T I N E =======================================
.text$x:00002DFF
.text$x:00002DFF
.text$x:00002DFF __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$1 proc near
.text$x:00002DFF                                         ; DATA XREF: .xdata$x:0000D410o
.text$x:00002DFF                 lea     ecx, [ebp-40Ch]
.text$x:00002E05                 jmp     ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00002E05 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$1 endp
.text$x:00002E05
.text$x:00002E0A
.text$x:00002E0A ; =============== S U B R O U T I N E =======================================
.text$x:00002E0A
.text$x:00002E0A
.text$x:00002E0A __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$2 proc near
.text$x:00002E0A                                         ; DATA XREF: .xdata$x:0000D418o
.text$x:00002E0A                 lea     ecx, [ebp-48h]
.text$x:00002E0D                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002E0D __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$2 endp
.text$x:00002E0D
.text$x:00002E12
.text$x:00002E12 ; =============== S U B R O U T I N E =======================================
.text$x:00002E12
.text$x:00002E12
.text$x:00002E12 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$3 proc near
.text$x:00002E12                                         ; DATA XREF: .xdata$x:0000D420o
.text$x:00002E12                 mov     eax, [ebp-37Ch]
.text$x:00002E18                 and     eax, 1
.text$x:00002E1B                 jz      locret_2E33
.text$x:00002E21                 and     dword ptr [ebp-37Ch], 0FFFFFFFEh
.text$x:00002E28                 lea     ecx, [ebp-128h]
.text$x:00002E2E                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002E33 ; ---------------------------------------------------------------------------
.text$x:00002E33
.text$x:00002E33 locret_2E33:                            ; CODE XREF: __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$3+9j
.text$x:00002E33                 retn
.text$x:00002E33 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$3 endp
.text$x:00002E33
.text$x:00002E34
.text$x:00002E34 ; =============== S U B R O U T I N E =======================================
.text$x:00002E34
.text$x:00002E34
.text$x:00002E34 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$4 proc near
.text$x:00002E34                                         ; DATA XREF: .xdata$x:0000D428o
.text$x:00002E34                 mov     eax, [ebp-37Ch]
.text$x:00002E3A                 and     eax, 2
.text$x:00002E3D                 jz      locret_2E55
.text$x:00002E43                 and     dword ptr [ebp-37Ch], 0FFFFFFFDh
.text$x:00002E4A                 lea     ecx, [ebp-0F0h]
.text$x:00002E50                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002E55 ; ---------------------------------------------------------------------------
.text$x:00002E55
.text$x:00002E55 locret_2E55:                            ; CODE XREF: __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$4+9j
.text$x:00002E55                 retn
.text$x:00002E55 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$4 endp
.text$x:00002E55
.text$x:00002E56
.text$x:00002E56 ; =============== S U B R O U T I N E =======================================
.text$x:00002E56
.text$x:00002E56
.text$x:00002E56 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$5 proc near
.text$x:00002E56                                         ; DATA XREF: .xdata$x:0000D430o
.text$x:00002E56                                         ; .xdata$x:0000D438o ...
.text$x:00002E56                 lea     ecx, [ebp-80h]
.text$x:00002E59                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002E59 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$5 endp
.text$x:00002E59
.text$x:00002E5E
.text$x:00002E5E ; =============== S U B R O U T I N E =======================================
.text$x:00002E5E
.text$x:00002E5E
.text$x:00002E5E __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$6 proc near
.text$x:00002E5E                                         ; DATA XREF: .xdata$x:0000D448o
.text$x:00002E5E                 mov     eax, [ebp-37Ch]
.text$x:00002E64                 and     eax, 4
.text$x:00002E67                 jz      locret_2E7F
.text$x:00002E6D                 and     dword ptr [ebp-37Ch], 0FFFFFFFBh
.text$x:00002E74                 lea     ecx, [ebp-10Ch]
.text$x:00002E7A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002E7F ; ---------------------------------------------------------------------------
.text$x:00002E7F
.text$x:00002E7F locret_2E7F:                            ; CODE XREF: __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$6+9j
.text$x:00002E7F                 retn
.text$x:00002E7F __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$6 endp
.text$x:00002E7F
.text$x:00002E80
.text$x:00002E80 ; =============== S U B R O U T I N E =======================================
.text$x:00002E80
.text$x:00002E80
.text$x:00002E80 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$7 proc near
.text$x:00002E80                                         ; DATA XREF: .xdata$x:0000D450o
.text$x:00002E80                 mov     eax, [ebp-37Ch]
.text$x:00002E86                 and     eax, 8
.text$x:00002E89                 jz      locret_2EA1
.text$x:00002E8F                 and     dword ptr [ebp-37Ch], 0FFFFFFF7h
.text$x:00002E96                 lea     ecx, [ebp-0D4h]
.text$x:00002E9C                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002EA1 ; ---------------------------------------------------------------------------
.text$x:00002EA1
.text$x:00002EA1 locret_2EA1:                            ; CODE XREF: __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$7+9j
.text$x:00002EA1                 retn
.text$x:00002EA1 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$7 endp
.text$x:00002EA1
.text$x:00002EA2
.text$x:00002EA2 ; =============== S U B R O U T I N E =======================================
.text$x:00002EA2
.text$x:00002EA2
.text$x:00002EA2 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$8 proc near
.text$x:00002EA2                                         ; DATA XREF: .xdata$x:0000D458o
.text$x:00002EA2                                         ; .xdata$x:0000D460o ...
.text$x:00002EA2                 lea     ecx, [ebp-2Ch]
.text$x:00002EA5                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002EA5 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$8 endp
.text$x:00002EA5
.text$x:00002EAA
.text$x:00002EAA ; =============== S U B R O U T I N E =======================================
.text$x:00002EAA
.text$x:00002EAA
.text$x:00002EAA __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$9 proc near
.text$x:00002EAA                                         ; DATA XREF: .xdata$x:0000D470o
.text$x:00002EAA                 mov     eax, [ebp-37Ch]
.text$x:00002EB0                 and     eax, 10h
.text$x:00002EB3                 jz      locret_2ECB
.text$x:00002EB9                 and     dword ptr [ebp-37Ch], 0FFFFFFEFh
.text$x:00002EC0                 lea     ecx, [ebp-0B8h]
.text$x:00002EC6                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002ECB ; ---------------------------------------------------------------------------
.text$x:00002ECB
.text$x:00002ECB locret_2ECB:                            ; CODE XREF: __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$9+9j
.text$x:00002ECB                 retn
.text$x:00002ECB __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$9 endp
.text$x:00002ECB
.text$x:00002ECC
.text$x:00002ECC ; =============== S U B R O U T I N E =======================================
.text$x:00002ECC
.text$x:00002ECC
.text$x:00002ECC __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$10 proc near
.text$x:00002ECC                                         ; DATA XREF: .xdata$x:0000D478o
.text$x:00002ECC                 mov     eax, [ebp-37Ch]
.text$x:00002ED2                 and     eax, 20h
.text$x:00002ED5                 jz      locret_2EED
.text$x:00002EDB                 and     dword ptr [ebp-37Ch], 0FFFFFFDFh
.text$x:00002EE2                 lea     ecx, [ebp-9Ch]
.text$x:00002EE8                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002EED ; ---------------------------------------------------------------------------
.text$x:00002EED
.text$x:00002EED locret_2EED:                            ; CODE XREF: __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$10+9j
.text$x:00002EED                 retn
.text$x:00002EED __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$10 endp
.text$x:00002EED
.text$x:00002EEE
.text$x:00002EEE ; =============== S U B R O U T I N E =======================================
.text$x:00002EEE
.text$x:00002EEE
.text$x:00002EEE __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$11 proc near
.text$x:00002EEE                                         ; DATA XREF: .xdata$x:0000D480o
.text$x:00002EEE                                         ; .xdata$x:0000D488o ...
.text$x:00002EEE                 lea     ecx, [ebp-64h]
.text$x:00002EF1                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002EF1 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$11 endp
.text$x:00002EF1
.text$x:00002EF6
.text$x:00002EF6 ; =============== S U B R O U T I N E =======================================
.text$x:00002EF6
.text$x:00002EF6
.text$x:00002EF6 __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$12 proc near
.text$x:00002EF6                                         ; DATA XREF: .xdata$x:0000D498o
.text$x:00002EF6                 mov     ecx, [ebp-414h]
.text$x:00002EFC                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002EFC __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$12 endp
.text$x:00002EFC
.text$x:00002F01
.text$x:00002F01 ; =============== S U B R O U T I N E =======================================
.text$x:00002F01
.text$x:00002F01
.text$x:00002F01 __ehhandler$?loadPlugins@PluginsManager@@QAE_NPB_W@Z proc near
.text$x:00002F01                                         ; DATA XREF: PluginsManager::loadPlugins(wchar_t const *)+5o
.text$x:00002F01
.text$x:00002F01 arg_4           = dword ptr  8
.text$x:00002F01
.text$x:00002F01                 mov     edx, [esp+arg_4]
.text$x:00002F05                 lea     eax, [edx+0Ch]
.text$x:00002F08                 mov     ecx, [edx-40Ch]
.text$x:00002F0E                 xor     ecx, eax
.text$x:00002F10                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F15                 mov     ecx, [edx-4]
.text$x:00002F18                 xor     ecx, eax
.text$x:00002F1A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F1F                 mov     eax, offset __ehfuncinfo$?loadPlugins@PluginsManager@@QAE_NPB_W@Z
.text$x:00002F24                 jmp     ___CxxFrameHandler3
.text$x:00002F24 __ehhandler$?loadPlugins@PluginsManager@@QAE_NPB_W@Z endp
.text$x:00002F24
.text$x:00002F29
.text$x:00002F29 ; =============== S U B R O U T I N E =======================================
.text$x:00002F29
.text$x:00002F29
.text$x:00002F29 __unwindfunclet$?runPluginCommand@PluginsManager@@QAEXI@Z$3 proc near
.text$x:00002F29                                         ; DATA XREF: .xdata$x:0000D158o
.text$x:00002F29                 lea     ecx, [ebp-124h] ; this
.text$x:00002F2F                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00002F2F __unwindfunclet$?runPluginCommand@PluginsManager@@QAEXI@Z$3 endp
.text$x:00002F2F
.text$x:00002F34
.text$x:00002F34 ; =============== S U B R O U T I N E =======================================
.text$x:00002F34
.text$x:00002F34
.text$x:00002F34 __ehhandler$?runPluginCommand@PluginsManager@@QAEXI@Z proc near
.text$x:00002F34                                         ; DATA XREF: PluginsManager::runPluginCommand(uint)+5o
.text$x:00002F34
.text$x:00002F34 arg_4           = dword ptr  8
.text$x:00002F34
.text$x:00002F34                 mov     edx, [esp+arg_4]
.text$x:00002F38                 lea     eax, [edx+0Ch]
.text$x:00002F3B                 mov     ecx, [edx-128h]
.text$x:00002F41                 xor     ecx, eax
.text$x:00002F43                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F48                 mov     ecx, [edx-8]
.text$x:00002F4B                 xor     ecx, eax
.text$x:00002F4D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F52                 mov     eax, offset __ehfuncinfo$?runPluginCommand@PluginsManager@@QAEXI@Z
.text$x:00002F57                 jmp     ___CxxFrameHandler3
.text$x:00002F57 __ehhandler$?runPluginCommand@PluginsManager@@QAEXI@Z endp
.text$x:00002F57
.text$x:00002F5C
.text$x:00002F5C ; =============== S U B R O U T I N E =======================================
.text$x:00002F5C
.text$x:00002F5C
.text$x:00002F5C __unwindfunclet$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$3 proc near
.text$x:00002F5C                                         ; DATA XREF: .xdata$x:0000D140o
.text$x:00002F5C                 lea     ecx, [ebp-12Ch] ; this
.text$x:00002F62                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00002F62 __unwindfunclet$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$3 endp
.text$x:00002F62
.text$x:00002F67
.text$x:00002F67 ; =============== S U B R O U T I N E =======================================
.text$x:00002F67
.text$x:00002F67
.text$x:00002F67 __ehhandler$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z proc near
.text$x:00002F67                                         ; DATA XREF: PluginsManager::runPluginCommand(wchar_t const *,int)+5o
.text$x:00002F67
.text$x:00002F67 arg_4           = dword ptr  8
.text$x:00002F67
.text$x:00002F67                 mov     edx, [esp+arg_4]
.text$x:00002F6B                 lea     eax, [edx+0Ch]
.text$x:00002F6E                 mov     ecx, [edx-130h]
.text$x:00002F74                 xor     ecx, eax
.text$x:00002F76                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F7B                 mov     ecx, [edx-8]
.text$x:00002F7E                 xor     ecx, eax
.text$x:00002F80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F85                 mov     eax, offset __ehfuncinfo$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.text$x:00002F8A                 jmp     ___CxxFrameHandler3
.text$x:00002F8A __ehhandler$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z endp
.text$x:00002F8A
.text$x:00002F8F
.text$x:00002F8F ; =============== S U B R O U T I N E =======================================
.text$x:00002F8F
.text$x:00002F8F
.text$x:00002F8F __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$0 proc near
.text$x:00002F8F                                         ; DATA XREF: .xdata$x:0000D350o
.text$x:00002F8F                 lea     ecx, [ebp-6Ch]  ; this
.text$x:00002F92                 jmp     ??1PluginCommand@@QAE@XZ ; PluginCommand::~PluginCommand(void)
.text$x:00002F92 __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$0 endp
.text$x:00002F92
.text$x:00002F97
.text$x:00002F97 ; =============== S U B R O U T I N E =======================================
.text$x:00002F97
.text$x:00002F97
.text$x:00002F97 __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$1 proc near
.text$x:00002F97                                         ; DATA XREF: .xdata$x:0000D358o
.text$x:00002F97                 lea     ecx, [ebp-2Ch]
.text$x:00002F9A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002F9A __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$1 endp
.text$x:00002F9A
.text$x:00002F9F
.text$x:00002F9F ; =============== S U B R O U T I N E =======================================
.text$x:00002F9F
.text$x:00002F9F
.text$x:00002F9F __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$2 proc near
.text$x:00002F9F                                         ; DATA XREF: .xdata$x:0000D360o
.text$x:00002F9F                 mov     ecx, [ebp-464h] ; this
.text$x:00002FA5                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00002FA5 __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$2 endp
.text$x:00002FA5
.text$x:00002FAA
.text$x:00002FAA ; =============== S U B R O U T I N E =======================================
.text$x:00002FAA
.text$x:00002FAA
.text$x:00002FAA __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$3 proc near
.text$x:00002FAA                                         ; DATA XREF: .xdata$x:0000D368o
.text$x:00002FAA                 lea     ecx, [ebp-1BCh] ; this
.text$x:00002FB0                 jmp     ??1PluginCmdShortcut@@UAE@XZ ; PluginCmdShortcut::~PluginCmdShortcut(void)
.text$x:00002FB0 __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$3 endp
.text$x:00002FB0
.text$x:00002FB5
.text$x:00002FB5 ; =============== S U B R O U T I N E =======================================
.text$x:00002FB5
.text$x:00002FB5
.text$x:00002FB5 __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$4 proc near
.text$x:00002FB5                                         ; DATA XREF: .xdata$x:0000D370o
.text$x:00002FB5                 lea     ecx, [ebp-48h]
.text$x:00002FB8                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002FB8 __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$4 endp
.text$x:00002FB8
.text$x:00002FBD
.text$x:00002FBD ; =============== S U B R O U T I N E =======================================
.text$x:00002FBD
.text$x:00002FBD
.text$x:00002FBD __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$5 proc near
.text$x:00002FBD                                         ; DATA XREF: .xdata$x:0000D378o
.text$x:00002FBD                 lea     ecx, [ebp-2E4h] ; this
.text$x:00002FC3                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00002FC3 __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$5 endp
.text$x:00002FC3
.text$x:00002FC8
.text$x:00002FC8 ; =============== S U B R O U T I N E =======================================
.text$x:00002FC8
.text$x:00002FC8
.text$x:00002FC8 __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$6 proc near
.text$x:00002FC8                                         ; DATA XREF: .xdata$x:0000D380o
.text$x:00002FC8                 mov     ecx, [ebp-474h] ; this
.text$x:00002FCE                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00002FCE __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$6 endp
.text$x:00002FCE
.text$x:00002FD3
.text$x:00002FD3 ; =============== S U B R O U T I N E =======================================
.text$x:00002FD3
.text$x:00002FD3
.text$x:00002FD3 __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$7 proc near
.text$x:00002FD3                                         ; DATA XREF: .xdata$x:0000D388o
.text$x:00002FD3                 lea     ecx, [ebp-434h] ; this
.text$x:00002FD9                 jmp     ??1PluginCmdShortcut@@UAE@XZ ; PluginCmdShortcut::~PluginCmdShortcut(void)
.text$x:00002FD9 __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$7 endp
.text$x:00002FD9
.text$x:00002FDE
.text$x:00002FDE ; =============== S U B R O U T I N E =======================================
.text$x:00002FDE
.text$x:00002FDE
.text$x:00002FDE __ehhandler$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z proc near
.text$x:00002FDE                                         ; DATA XREF: PluginsManager::addInMenuFromPMIndex(int)+5o
.text$x:00002FDE
.text$x:00002FDE arg_4           = dword ptr  8
.text$x:00002FDE
.text$x:00002FDE                 mov     edx, [esp+arg_4]
.text$x:00002FE2                 lea     eax, [edx+0Ch]
.text$x:00002FE5                 mov     ecx, [edx-474h]
.text$x:00002FEB                 xor     ecx, eax
.text$x:00002FED                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FF2                 mov     ecx, [edx-4]
.text$x:00002FF5                 xor     ecx, eax
.text$x:00002FF7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FFC                 mov     eax, offset __ehfuncinfo$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z
.text$x:00003001                 jmp     ___CxxFrameHandler3
.text$x:00003001 __ehhandler$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z endp
.text$x:00003001
.text$x:00003006
.text$x:00003006 ; =============== S U B R O U T I N E =======================================
.text$x:00003006
.text$x:00003006
.text$x:00003006 __unwindfunclet$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$3 proc near
.text$x:00003006                                         ; DATA XREF: .xdata$x:0000D128o
.text$x:00003006                 lea     ecx, [ebp-12Ch] ; this
.text$x:0000300C                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:0000300C __unwindfunclet$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$3 endp
.text$x:0000300C
.text$x:00003011
.text$x:00003011 ; =============== S U B R O U T I N E =======================================
.text$x:00003011
.text$x:00003011
.text$x:00003011 __ehhandler$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z proc near
.text$x:00003011                                         ; DATA XREF: PluginsManager::notify(SCNotification const *)+5o
.text$x:00003011
.text$x:00003011 arg_4           = dword ptr  8
.text$x:00003011
.text$x:00003011                 mov     edx, [esp+arg_4]
.text$x:00003015                 lea     eax, [edx+0Ch]
.text$x:00003018                 mov     ecx, [edx-18Ch]
.text$x:0000301E                 xor     ecx, eax
.text$x:00003020                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003025                 mov     ecx, [edx-8]
.text$x:00003028                 xor     ecx, eax
.text$x:0000302A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000302F                 mov     eax, offset __ehfuncinfo$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.text$x:00003034                 jmp     ___CxxFrameHandler3
.text$x:00003034 __ehhandler$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z endp
.text$x:00003034
.text$x:00003039
.text$x:00003039 ; =============== S U B R O U T I N E =======================================
.text$x:00003039
.text$x:00003039
.text$x:00003039 __unwindfunclet$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$3 proc near
.text$x:00003039                                         ; DATA XREF: .xdata$x:0000D110o
.text$x:00003039                 lea     ecx, [ebp-12Ch] ; this
.text$x:0000303F                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:0000303F __unwindfunclet$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$3 endp
.text$x:0000303F
.text$x:00003044
.text$x:00003044 ; =============== S U B R O U T I N E =======================================
.text$x:00003044
.text$x:00003044
.text$x:00003044 __ehhandler$?relayNppMessages@PluginsManager@@QAEXIIJ@Z proc near
.text$x:00003044                                         ; DATA XREF: PluginsManager::relayNppMessages(uint,uint,long)+5o
.text$x:00003044
.text$x:00003044 arg_4           = dword ptr  8
.text$x:00003044
.text$x:00003044                 mov     edx, [esp+arg_4]
.text$x:00003048                 lea     eax, [edx+0Ch]
.text$x:0000304B                 mov     ecx, [edx-130h]
.text$x:00003051                 xor     ecx, eax
.text$x:00003053                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003058                 mov     ecx, [edx-8]
.text$x:0000305B                 xor     ecx, eax
.text$x:0000305D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003062                 mov     eax, offset __ehfuncinfo$?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.text$x:00003067                 jmp     ___CxxFrameHandler3
.text$x:00003067 __ehhandler$?relayNppMessages@PluginsManager@@QAEXIIJ@Z endp
.text$x:00003067
.text$x:0000306C
.text$x:0000306C ; =============== S U B R O U T I N E =======================================
.text$x:0000306C
.text$x:0000306C
.text$x:0000306C __unwindfunclet$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$3 proc near
.text$x:0000306C                                         ; DATA XREF: .xdata$x:0000D0F8o
.text$x:0000306C                 lea     ecx, [ebp-130h] ; this
.text$x:00003072                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00003072 __unwindfunclet$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$3 endp
.text$x:00003072
.text$x:00003077
.text$x:00003077 ; =============== S U B R O U T I N E =======================================
.text$x:00003077
.text$x:00003077
.text$x:00003077 __ehhandler$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z proc near
.text$x:00003077                                         ; DATA XREF: PluginsManager::relayPluginMessages(uint,uint,long)+5o
.text$x:00003077
.text$x:00003077 arg_4           = dword ptr  8
.text$x:00003077
.text$x:00003077                 mov     edx, [esp+arg_4]
.text$x:0000307B                 lea     eax, [edx+0Ch]
.text$x:0000307E                 mov     ecx, [edx-134h]
.text$x:00003084                 xor     ecx, eax
.text$x:00003086                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000308B                 mov     ecx, [edx-8]
.text$x:0000308E                 xor     ecx, eax
.text$x:00003090                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003095                 mov     eax, offset __ehfuncinfo$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z
.text$x:0000309A                 jmp     ___CxxFrameHandler3
.text$x:0000309A __ehhandler$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z endp
.text$x:0000309A
.text$x:0000309A ; ---------------------------------------------------------------------------
.text$x:0000309F                 align 10h
.text$x:0000309F _text$x         ends
.text$x:0000309F
.text$mn:000030A0 ; ===========================================================================
.text$mn:000030A0
.text$mn:000030A0 ; Segment type: Pure code
.text$mn:000030A0 ; Segment permissions: Read/Execute
.text$mn:000030A0 _text$mn        segment para public 'CODE' use32
.text$mn:000030A0                 assume cs:_text$mn
.text$mn:000030A0                 ;org 30A0h
.text$mn:000030A0 ; COMDAT (pick any)
.text$mn:000030A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000030A0
.text$mn:000030A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000030A0
.text$mn:000030A0 ; Attributes: bp-based frame
.text$mn:000030A0
.text$mn:000030A0 ; public: __thiscall std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &, bool &)
.text$mn:000030A0                 public ??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z
.text$mn:000030A0 ??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z proc near
.text$mn:000030A0                                         ; CODE XREF: PluginList::add(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool)+3Dp
.text$mn:000030A0
.text$mn:000030A0 var_10          = dword ptr -10h
.text$mn:000030A0 var_C           = dword ptr -0Ch
.text$mn:000030A0 var_4           = dword ptr -4
.text$mn:000030A0 arg_0           = dword ptr  8
.text$mn:000030A0 arg_4           = dword ptr  0Ch
.text$mn:000030A0
.text$mn:000030A0                 push    ebp
.text$mn:000030A1                 mov     ebp, esp
.text$mn:000030A3                 push    0FFFFFFFFh
.text$mn:000030A5                 push    offset __ehhandler$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z
.text$mn:000030AA                 mov     eax, large fs:0
.text$mn:000030B0                 push    eax
.text$mn:000030B1                 push    ecx
.text$mn:000030B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000030B7                 xor     eax, ebp
.text$mn:000030B9                 push    eax
.text$mn:000030BA                 lea     eax, [ebp+var_C]
.text$mn:000030BD                 mov     large fs:0, eax
.text$mn:000030C3                 mov     [ebp+var_10], ecx
.text$mn:000030C6                 mov     eax, [ebp+arg_0]
.text$mn:000030C9                 push    eax
.text$mn:000030CA                 call    ??$forward@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:000030CF                 add     esp, 4
.text$mn:000030D2                 push    eax
.text$mn:000030D3                 mov     ecx, [ebp+var_10]
.text$mn:000030D6                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000030DB                 mov     [ebp+var_4], 0
.text$mn:000030E2                 mov     ecx, [ebp+arg_4]
.text$mn:000030E5                 push    ecx
.text$mn:000030E6                 call    ??$forward@AA_N@std@@YAAA_NAA_N@Z ; std::forward<bool &>(bool &)
.text$mn:000030EB                 add     esp, 4
.text$mn:000030EE                 mov     edx, [ebp+var_10]
.text$mn:000030F1                 mov     al, [eax]
.text$mn:000030F3                 mov     [edx+1Ch], al
.text$mn:000030F6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000030FD                 mov     eax, [ebp+var_10]
.text$mn:00003100                 mov     ecx, [ebp+var_C]
.text$mn:00003103                 mov     large fs:0, ecx
.text$mn:0000310A                 pop     ecx
.text$mn:0000310B                 mov     esp, ebp
.text$mn:0000310D                 pop     ebp
.text$mn:0000310E                 retn    8
.text$mn:0000310E ??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z endp
.text$mn:0000310E
.text$mn:0000310E ; ---------------------------------------------------------------------------
.text$mn:00003111                 align 4
.text$mn:00003111 _text$mn        ends
.text$mn:00003111
.text$x:00003114 ; ===========================================================================
.text$x:00003114
.text$x:00003114 ; Segment type: Pure code
.text$x:00003114 ; Segment permissions: Read/Execute
.text$x:00003114 _text$x         segment para public 'CODE' use32
.text$x:00003114                 assume cs:_text$x
.text$x:00003114                 ;org 3114h
.text$x:00003114 ; COMDAT (pick associative to section at 30A0)
.text$x:00003114                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003114
.text$x:00003114 ; =============== S U B R O U T I N E =======================================
.text$x:00003114
.text$x:00003114
.text$x:00003114 __unwindfunclet$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z$0 proc near
.text$x:00003114                                         ; DATA XREF: .xdata$x:0000CE08o
.text$x:00003114                 mov     ecx, [ebp-10h]
.text$x:00003117                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00003117 __unwindfunclet$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z$0 endp
.text$x:00003117
.text$x:0000311C
.text$x:0000311C ; =============== S U B R O U T I N E =======================================
.text$x:0000311C
.text$x:0000311C
.text$x:0000311C __ehhandler$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z proc near
.text$x:0000311C                                         ; DATA XREF: std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,bool &)+5o
.text$x:0000311C
.text$x:0000311C arg_4           = dword ptr  8
.text$x:0000311C
.text$x:0000311C                 mov     edx, [esp+arg_4]
.text$x:00003120                 lea     eax, [edx+0Ch]
.text$x:00003123                 mov     ecx, [edx-8]
.text$x:00003126                 xor     ecx, eax
.text$x:00003128                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000312D                 mov     eax, offset __ehfuncinfo$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z
.text$x:00003132                 jmp     ___CxxFrameHandler3
.text$x:00003132 __ehhandler$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z endp
.text$x:00003132
.text$x:00003132 ; ---------------------------------------------------------------------------
.text$x:00003137                 align 4
.text$x:00003137 _text$x         ends
.text$x:00003137
.text$mn:00003138 ; ===========================================================================
.text$mn:00003138
.text$mn:00003138 ; Segment type: Pure code
.text$mn:00003138 ; Segment permissions: Read/Execute
.text$mn:00003138 _text$mn        segment para public 'CODE' use32
.text$mn:00003138                 assume cs:_text$mn
.text$mn:00003138                 ;org 3138h
.text$mn:00003138 ; COMDAT (pick any)
.text$mn:00003138                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003138
.text$mn:00003138 ; =============== S U B R O U T I N E =======================================
.text$mn:00003138
.text$mn:00003138 ; Attributes: bp-based frame
.text$mn:00003138
.text$mn:00003138 ; public: __thiscall std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> &&)
.text$mn:00003138                 public ??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z
.text$mn:00003138 ??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z proc near
.text$mn:00003138                                         ; CODE XREF: std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+56p
.text$mn:00003138
.text$mn:00003138 var_10          = dword ptr -10h
.text$mn:00003138 var_C           = dword ptr -0Ch
.text$mn:00003138 var_4           = dword ptr -4
.text$mn:00003138 arg_0           = dword ptr  8
.text$mn:00003138
.text$mn:00003138                 push    ebp
.text$mn:00003139                 mov     ebp, esp
.text$mn:0000313B                 push    0FFFFFFFFh
.text$mn:0000313D                 push    offset __ehhandler$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z
.text$mn:00003142                 mov     eax, large fs:0
.text$mn:00003148                 push    eax
.text$mn:00003149                 push    ecx
.text$mn:0000314A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000314F                 xor     eax, ebp
.text$mn:00003151                 push    eax
.text$mn:00003152                 lea     eax, [ebp+var_C]
.text$mn:00003155                 mov     large fs:0, eax
.text$mn:0000315B                 mov     [ebp+var_10], ecx
.text$mn:0000315E                 mov     eax, [ebp+arg_0]
.text$mn:00003161                 push    eax
.text$mn:00003162                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00003167                 add     esp, 4
.text$mn:0000316A                 push    eax
.text$mn:0000316B                 mov     ecx, [ebp+var_10]
.text$mn:0000316E                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00003173                 mov     [ebp+var_4], 0
.text$mn:0000317A                 mov     ecx, [ebp+arg_0]
.text$mn:0000317D                 add     ecx, 1Ch
.text$mn:00003180                 push    ecx
.text$mn:00003181                 call    ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>(bool &)
.text$mn:00003186                 add     esp, 4
.text$mn:00003189                 mov     edx, [ebp+var_10]
.text$mn:0000318C                 mov     al, [eax]
.text$mn:0000318E                 mov     [edx+1Ch], al
.text$mn:00003191                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003198                 mov     eax, [ebp+var_10]
.text$mn:0000319B                 mov     ecx, [ebp+var_C]
.text$mn:0000319E                 mov     large fs:0, ecx
.text$mn:000031A5                 pop     ecx
.text$mn:000031A6                 mov     esp, ebp
.text$mn:000031A8                 pop     ebp
.text$mn:000031A9                 retn    4
.text$mn:000031A9 ??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z endp
.text$mn:000031A9
.text$mn:000031A9 _text$mn        ends
.text$mn:000031A9
.text$x:000031AC ; ===========================================================================
.text$x:000031AC
.text$x:000031AC ; Segment type: Pure code
.text$x:000031AC ; Segment permissions: Read/Execute
.text$x:000031AC _text$x         segment para public 'CODE' use32
.text$x:000031AC                 assume cs:_text$x
.text$x:000031AC                 ;org 31ACh
.text$x:000031AC ; COMDAT (pick associative to section at 3138)
.text$x:000031AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000031AC
.text$x:000031AC ; =============== S U B R O U T I N E =======================================
.text$x:000031AC
.text$x:000031AC
.text$x:000031AC __unwindfunclet$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z$0 proc near
.text$x:000031AC                                         ; DATA XREF: .xdata$x:0000D7E4o
.text$x:000031AC                 mov     ecx, [ebp-10h]
.text$x:000031AF                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000031AF __unwindfunclet$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z$0 endp
.text$x:000031AF
.text$x:000031B4
.text$x:000031B4 ; =============== S U B R O U T I N E =======================================
.text$x:000031B4
.text$x:000031B4
.text$x:000031B4 __ehhandler$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z proc near
.text$x:000031B4                                         ; DATA XREF: std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+5o
.text$x:000031B4
.text$x:000031B4 arg_4           = dword ptr  8
.text$x:000031B4
.text$x:000031B4                 mov     edx, [esp+arg_4]
.text$x:000031B8                 lea     eax, [edx+0Ch]
.text$x:000031BB                 mov     ecx, [edx-8]
.text$x:000031BE                 xor     ecx, eax
.text$x:000031C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000031C5                 mov     eax, offset __ehfuncinfo$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z
.text$x:000031CA                 jmp     ___CxxFrameHandler3
.text$x:000031CA __ehhandler$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z endp
.text$x:000031CA
.text$x:000031CA ; ---------------------------------------------------------------------------
.text$x:000031CF                 align 10h
.text$x:000031CF _text$x         ends
.text$x:000031CF
.text$mn:000031D0 ; ===========================================================================
.text$mn:000031D0
.text$mn:000031D0 ; Segment type: Pure code
.text$mn:000031D0 ; Segment permissions: Read/Execute
.text$mn:000031D0 _text$mn        segment para public 'CODE' use32
.text$mn:000031D0                 assume cs:_text$mn
.text$mn:000031D0                 ;org 31D0h
.text$mn:000031D0 ; COMDAT (pick any)
.text$mn:000031D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000031D0
.text$mn:000031D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000031D0
.text$mn:000031D0 ; Attributes: bp-based frame
.text$mn:000031D0
.text$mn:000031D0 ; int __cdecl std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:000031D0                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:000031D0 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:000031D0                                         ; CODE XREF: PluginsManager::relayPluginMessages(uint,uint,long)+D0p
.text$mn:000031D0                                         ; NppParameters::isInBlackList(wchar_t *)+4Bp
.text$mn:000031D0
.text$mn:000031D0 var_4           = dword ptr -4
.text$mn:000031D0 arg_0           = dword ptr  8
.text$mn:000031D0 Str             = dword ptr  0Ch
.text$mn:000031D0
.text$mn:000031D0                 push    ebp
.text$mn:000031D1                 mov     ebp, esp
.text$mn:000031D3                 push    ecx
.text$mn:000031D4                 mov     eax, [ebp+Str]
.text$mn:000031D7                 push    eax             ; Str
.text$mn:000031D8                 mov     ecx, [ebp+arg_0]
.text$mn:000031DB                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)
.text$mn:000031E0                 test    eax, eax
.text$mn:000031E2                 jnz     short loc_31ED
.text$mn:000031E4                 mov     [ebp+var_4], 1
.text$mn:000031EB                 jmp     short loc_31F4
.text$mn:000031ED ; ---------------------------------------------------------------------------
.text$mn:000031ED
.text$mn:000031ED loc_31ED:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+12j
.text$mn:000031ED                 mov     [ebp+var_4], 0
.text$mn:000031F4
.text$mn:000031F4 loc_31F4:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+1Bj
.text$mn:000031F4                 mov     al, byte ptr [ebp+var_4]
.text$mn:000031F7                 mov     esp, ebp
.text$mn:000031F9                 pop     ebp
.text$mn:000031FA                 retn
.text$mn:000031FA ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:000031FA
.text$mn:000031FA ; ---------------------------------------------------------------------------
.text$mn:000031FB                 align 4
.text$mn:000031FB _text$mn        ends
.text$mn:000031FB
.text$mn:000031FC ; ===========================================================================
.text$mn:000031FC
.text$mn:000031FC ; Segment type: Pure code
.text$mn:000031FC ; Segment permissions: Read/Execute
.text$mn:000031FC _text$mn        segment para public 'CODE' use32
.text$mn:000031FC                 assume cs:_text$mn
.text$mn:000031FC                 ;org 31FCh
.text$mn:000031FC ; COMDAT (pick any)
.text$mn:000031FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000031FC
.text$mn:000031FC ; =============== S U B R O U T I N E =======================================
.text$mn:000031FC
.text$mn:000031FC ; Attributes: bp-based frame
.text$mn:000031FC
.text$mn:000031FC ; int __cdecl std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, int, wchar_t *Str)
.text$mn:000031FC                 public ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
.text$mn:000031FC ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z proc near
.text$mn:000031FC                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+73Ep
.text$mn:000031FC                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+89Cp
.text$mn:000031FC
.text$mn:000031FC var_10          = dword ptr -10h
.text$mn:000031FC var_C           = dword ptr -0Ch
.text$mn:000031FC var_4           = dword ptr -4
.text$mn:000031FC arg_0           = dword ptr  8
.text$mn:000031FC arg_4           = dword ptr  0Ch
.text$mn:000031FC Str             = dword ptr  10h
.text$mn:000031FC
.text$mn:000031FC                 push    ebp
.text$mn:000031FD                 mov     ebp, esp
.text$mn:000031FF                 push    0FFFFFFFFh
.text$mn:00003201                 push    offset __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
.text$mn:00003206                 mov     eax, large fs:0
.text$mn:0000320C                 push    eax
.text$mn:0000320D                 push    ecx
.text$mn:0000320E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003213                 xor     eax, ebp
.text$mn:00003215                 push    eax
.text$mn:00003216                 lea     eax, [ebp+var_C]
.text$mn:00003219                 mov     large fs:0, eax
.text$mn:0000321F                 mov     [ebp+var_10], 0
.text$mn:00003226                 mov     eax, [ebp+Str]
.text$mn:00003229                 push    eax             ; Str
.text$mn:0000322A                 mov     ecx, [ebp+arg_4]
.text$mn:0000322D                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:00003232                 push    eax
.text$mn:00003233                 call    ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00003238                 add     esp, 4
.text$mn:0000323B                 push    eax
.text$mn:0000323C                 mov     ecx, [ebp+arg_0]
.text$mn:0000323F                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00003244                 mov     [ebp+var_4], 0
.text$mn:0000324B                 mov     ecx, [ebp+var_10]
.text$mn:0000324E                 or      ecx, 1
.text$mn:00003251                 mov     [ebp+var_10], ecx
.text$mn:00003254                 mov     eax, [ebp+arg_0]
.text$mn:00003257                 mov     ecx, [ebp+var_C]
.text$mn:0000325A                 mov     large fs:0, ecx
.text$mn:00003261                 pop     ecx
.text$mn:00003262                 mov     esp, ebp
.text$mn:00003264                 pop     ebp
.text$mn:00003265                 retn
.text$mn:00003265 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z endp
.text$mn:00003265
.text$mn:00003265 ; ---------------------------------------------------------------------------
.text$mn:00003266                 align 4
.text$mn:00003266 _text$mn        ends
.text$mn:00003266
.text$x:00003268 ; ===========================================================================
.text$x:00003268
.text$x:00003268 ; Segment type: Pure code
.text$x:00003268 ; Segment permissions: Read/Execute
.text$x:00003268 _text$x         segment para public 'CODE' use32
.text$x:00003268                 assume cs:_text$x
.text$x:00003268                 ;org 3268h
.text$x:00003268 ; COMDAT (pick associative to section at 31FC)
.text$x:00003268                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003268
.text$x:00003268 ; =============== S U B R O U T I N E =======================================
.text$x:00003268
.text$x:00003268
.text$x:00003268 __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z$0 proc near
.text$x:00003268                                         ; DATA XREF: .xdata$x:0000D600o
.text$x:00003268                 mov     eax, [ebp-10h]
.text$x:0000326B                 and     eax, 1
.text$x:0000326E                 jz      $LN4_0
.text$x:00003274                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00003278                 mov     ecx, [ebp+8]
.text$x:0000327B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00003280 ; ---------------------------------------------------------------------------
.text$x:00003280
.text$x:00003280 $LN4_0:                                 ; CODE XREF: __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z$0+6j
.text$x:00003280                 retn
.text$x:00003280 __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z$0 endp
.text$x:00003280
.text$x:00003281
.text$x:00003281 ; =============== S U B R O U T I N E =======================================
.text$x:00003281
.text$x:00003281
.text$x:00003281 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z proc near
.text$x:00003281                                         ; DATA XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&,wchar_t const *)+5o
.text$x:00003281
.text$x:00003281 arg_4           = dword ptr  8
.text$x:00003281
.text$x:00003281                 mov     edx, [esp+arg_4]
.text$x:00003285                 lea     eax, [edx+0Ch]
.text$x:00003288                 mov     ecx, [edx-8]
.text$x:0000328B                 xor     ecx, eax
.text$x:0000328D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003292                 mov     eax, offset __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
.text$x:00003297                 jmp     ___CxxFrameHandler3
.text$x:00003297 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z endp
.text$x:00003297
.text$x:00003297 _text$x         ends
.text$x:00003297
.text$mn:0000329C ; ===========================================================================
.text$mn:0000329C
.text$mn:0000329C ; Segment type: Pure code
.text$mn:0000329C ; Segment permissions: Read/Execute
.text$mn:0000329C _text$mn        segment para public 'CODE' use32
.text$mn:0000329C                 assume cs:_text$mn
.text$mn:0000329C                 ;org 329Ch
.text$mn:0000329C ; COMDAT (pick any)
.text$mn:0000329C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000329C
.text$mn:0000329C ; =============== S U B R O U T I N E =======================================
.text$mn:0000329C
.text$mn:0000329C ; Attributes: bp-based frame
.text$mn:0000329C
.text$mn:0000329C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:0000329C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:0000329C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:0000329C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:0000329C
.text$mn:0000329C var_4           = dword ptr -4
.text$mn:0000329C arg_0           = dword ptr  8
.text$mn:0000329C
.text$mn:0000329C                 push    ebp
.text$mn:0000329D                 mov     ebp, esp
.text$mn:0000329F                 push    ecx
.text$mn:000032A0                 mov     [ebp+var_4], 0
.text$mn:000032A7                 cmp     [ebp+arg_0], 0
.text$mn:000032AB                 jnz     short loc_32AF
.text$mn:000032AD                 jmp     short loc_32CF
.text$mn:000032AF ; ---------------------------------------------------------------------------
.text$mn:000032AF
.text$mn:000032AF loc_32AF:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000032AF                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000032B3                 ja      short loc_32CA
.text$mn:000032B5                 mov     eax, [ebp+arg_0]
.text$mn:000032B8                 push    eax             ; unsigned int
.text$mn:000032B9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000032BE                 add     esp, 4
.text$mn:000032C1                 mov     [ebp+var_4], eax
.text$mn:000032C4                 cmp     [ebp+var_4], 0
.text$mn:000032C8                 jnz     short loc_32CF
.text$mn:000032CA
.text$mn:000032CA loc_32CA:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000032CA                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000032CF
.text$mn:000032CF loc_32CF:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000032CF                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000032CF                 mov     eax, [ebp+var_4]
.text$mn:000032D2                 mov     esp, ebp
.text$mn:000032D4                 pop     ebp
.text$mn:000032D5                 retn
.text$mn:000032D5 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000032D5
.text$mn:000032D5 ; ---------------------------------------------------------------------------
.text$mn:000032D6                 align 4
.text$mn:000032D6 _text$mn        ends
.text$mn:000032D6
.text$mn:000032D8 ; ===========================================================================
.text$mn:000032D8
.text$mn:000032D8 ; Segment type: Pure code
.text$mn:000032D8 ; Segment permissions: Read/Execute
.text$mn:000032D8 _text$mn        segment para public 'CODE' use32
.text$mn:000032D8                 assume cs:_text$mn
.text$mn:000032D8                 ;org 32D8h
.text$mn:000032D8 ; COMDAT (pick any)
.text$mn:000032D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000032D8
.text$mn:000032D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000032D8
.text$mn:000032D8 ; Attributes: bp-based frame
.text$mn:000032D8
.text$mn:000032D8 ; struct PluginInfo * * __cdecl std::_Allocate<struct PluginInfo *>(unsigned int, struct PluginInfo * *)
.text$mn:000032D8                 public ??$_Allocate@PAUPluginInfo@@@std@@YAPAPAUPluginInfo@@IPAPAU1@@Z
.text$mn:000032D8 ??$_Allocate@PAUPluginInfo@@@std@@YAPAPAUPluginInfo@@IPAPAU1@@Z proc near
.text$mn:000032D8                                         ; CODE XREF: std::allocator<PluginInfo *>::allocate(uint)+Dp
.text$mn:000032D8
.text$mn:000032D8 var_4           = dword ptr -4
.text$mn:000032D8 arg_0           = dword ptr  8
.text$mn:000032D8
.text$mn:000032D8                 push    ebp
.text$mn:000032D9                 mov     ebp, esp
.text$mn:000032DB                 push    ecx
.text$mn:000032DC                 mov     [ebp+var_4], 0
.text$mn:000032E3                 cmp     [ebp+arg_0], 0
.text$mn:000032E7                 jnz     short loc_32EB
.text$mn:000032E9                 jmp     short loc_3311
.text$mn:000032EB ; ---------------------------------------------------------------------------
.text$mn:000032EB
.text$mn:000032EB loc_32EB:                               ; CODE XREF: std::_Allocate<PluginInfo *>(uint,PluginInfo * *)+Fj
.text$mn:000032EB                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:000032F2                 ja      short loc_330C
.text$mn:000032F4                 mov     eax, [ebp+arg_0]
.text$mn:000032F7                 shl     eax, 2
.text$mn:000032FA                 push    eax             ; unsigned int
.text$mn:000032FB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00003300                 add     esp, 4
.text$mn:00003303                 mov     [ebp+var_4], eax
.text$mn:00003306                 cmp     [ebp+var_4], 0
.text$mn:0000330A                 jnz     short loc_3311
.text$mn:0000330C
.text$mn:0000330C loc_330C:                               ; CODE XREF: std::_Allocate<PluginInfo *>(uint,PluginInfo * *)+1Aj
.text$mn:0000330C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00003311
.text$mn:00003311 loc_3311:                               ; CODE XREF: std::_Allocate<PluginInfo *>(uint,PluginInfo * *)+11j
.text$mn:00003311                                         ; std::_Allocate<PluginInfo *>(uint,PluginInfo * *)+32j
.text$mn:00003311                 mov     eax, [ebp+var_4]
.text$mn:00003314                 mov     esp, ebp
.text$mn:00003316                 pop     ebp
.text$mn:00003317                 retn
.text$mn:00003317 ??$_Allocate@PAUPluginInfo@@@std@@YAPAPAUPluginInfo@@IPAPAU1@@Z endp
.text$mn:00003317
.text$mn:00003317 _text$mn        ends
.text$mn:00003317
.text$mn:00003318 ; ===========================================================================
.text$mn:00003318
.text$mn:00003318 ; Segment type: Pure code
.text$mn:00003318 ; Segment permissions: Read/Execute
.text$mn:00003318 _text$mn        segment para public 'CODE' use32
.text$mn:00003318                 assume cs:_text$mn
.text$mn:00003318                 ;org 3318h
.text$mn:00003318 ; COMDAT (pick any)
.text$mn:00003318                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003318
.text$mn:00003318 ; =============== S U B R O U T I N E =======================================
.text$mn:00003318
.text$mn:00003318 ; Attributes: bp-based frame
.text$mn:00003318
.text$mn:00003318 ; class TiXmlDocument * * __cdecl std::_Allocate<class TiXmlDocument *>(unsigned int, class TiXmlDocument * *)
.text$mn:00003318                 public ??$_Allocate@PAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@IPAPAV1@@Z
.text$mn:00003318 ??$_Allocate@PAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@IPAPAV1@@Z proc near
.text$mn:00003318                                         ; CODE XREF: std::allocator<TiXmlDocument *>::allocate(uint)+Dp
.text$mn:00003318
.text$mn:00003318 var_4           = dword ptr -4
.text$mn:00003318 arg_0           = dword ptr  8
.text$mn:00003318
.text$mn:00003318                 push    ebp
.text$mn:00003319                 mov     ebp, esp
.text$mn:0000331B                 push    ecx
.text$mn:0000331C                 mov     [ebp+var_4], 0
.text$mn:00003323                 cmp     [ebp+arg_0], 0
.text$mn:00003327                 jnz     short loc_332B
.text$mn:00003329                 jmp     short loc_3351
.text$mn:0000332B ; ---------------------------------------------------------------------------
.text$mn:0000332B
.text$mn:0000332B loc_332B:                               ; CODE XREF: std::_Allocate<TiXmlDocument *>(uint,TiXmlDocument * *)+Fj
.text$mn:0000332B                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00003332                 ja      short loc_334C
.text$mn:00003334                 mov     eax, [ebp+arg_0]
.text$mn:00003337                 shl     eax, 2
.text$mn:0000333A                 push    eax             ; unsigned int
.text$mn:0000333B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00003340                 add     esp, 4
.text$mn:00003343                 mov     [ebp+var_4], eax
.text$mn:00003346                 cmp     [ebp+var_4], 0
.text$mn:0000334A                 jnz     short loc_3351
.text$mn:0000334C
.text$mn:0000334C loc_334C:                               ; CODE XREF: std::_Allocate<TiXmlDocument *>(uint,TiXmlDocument * *)+1Aj
.text$mn:0000334C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00003351
.text$mn:00003351 loc_3351:                               ; CODE XREF: std::_Allocate<TiXmlDocument *>(uint,TiXmlDocument * *)+11j
.text$mn:00003351                                         ; std::_Allocate<TiXmlDocument *>(uint,TiXmlDocument * *)+32j
.text$mn:00003351                 mov     eax, [ebp+var_4]
.text$mn:00003354                 mov     esp, ebp
.text$mn:00003356                 pop     ebp
.text$mn:00003357                 retn
.text$mn:00003357 ??$_Allocate@PAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@IPAPAV1@@Z endp
.text$mn:00003357
.text$mn:00003357 _text$mn        ends
.text$mn:00003357
.text$mn:00003358 ; ===========================================================================
.text$mn:00003358
.text$mn:00003358 ; Segment type: Pure code
.text$mn:00003358 ; Segment permissions: Read/Execute
.text$mn:00003358 _text$mn        segment para public 'CODE' use32
.text$mn:00003358                 assume cs:_text$mn
.text$mn:00003358                 ;org 3358h
.text$mn:00003358 ; COMDAT (pick any)
.text$mn:00003358                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003358
.text$mn:00003358 ; =============== S U B R O U T I N E =======================================
.text$mn:00003358
.text$mn:00003358 ; Attributes: bp-based frame
.text$mn:00003358
.text$mn:00003358 ; struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * __cdecl std::_Allocate<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>(unsigned int, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)
.text$mn:00003358                 public ??$_Allocate@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@IPAU10@@Z
.text$mn:00003358 ??$_Allocate@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@IPAU10@@Z proc near
.text$mn:00003358                                         ; CODE XREF: std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::allocate(uint)+Dp
.text$mn:00003358
.text$mn:00003358 var_4           = dword ptr -4
.text$mn:00003358 arg_0           = dword ptr  8
.text$mn:00003358
.text$mn:00003358                 push    ebp
.text$mn:00003359                 mov     ebp, esp
.text$mn:0000335B                 push    ecx
.text$mn:0000335C                 mov     [ebp+var_4], 0
.text$mn:00003363                 cmp     [ebp+arg_0], 0
.text$mn:00003367                 jnz     short loc_336B
.text$mn:00003369                 jmp     short loc_3391
.text$mn:0000336B ; ---------------------------------------------------------------------------
.text$mn:0000336B
.text$mn:0000336B loc_336B:                               ; CODE XREF: std::_Allocate<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(uint,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+Fj
.text$mn:0000336B                 cmp     [ebp+arg_0], 7FFFFFFh
.text$mn:00003372                 ja      short loc_338C
.text$mn:00003374                 mov     eax, [ebp+arg_0]
.text$mn:00003377                 shl     eax, 5
.text$mn:0000337A                 push    eax             ; unsigned int
.text$mn:0000337B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00003380                 add     esp, 4
.text$mn:00003383                 mov     [ebp+var_4], eax
.text$mn:00003386                 cmp     [ebp+var_4], 0
.text$mn:0000338A                 jnz     short loc_3391
.text$mn:0000338C
.text$mn:0000338C loc_338C:                               ; CODE XREF: std::_Allocate<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(uint,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+1Aj
.text$mn:0000338C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00003391
.text$mn:00003391 loc_3391:                               ; CODE XREF: std::_Allocate<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(uint,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+11j
.text$mn:00003391                                         ; std::_Allocate<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(uint,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+32j
.text$mn:00003391                 mov     eax, [ebp+var_4]
.text$mn:00003394                 mov     esp, ebp
.text$mn:00003396                 pop     ebp
.text$mn:00003397                 retn
.text$mn:00003397 ??$_Allocate@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@IPAU10@@Z endp
.text$mn:00003397
.text$mn:00003397 _text$mn        ends
.text$mn:00003397
.text$mn:00003398 ; ===========================================================================
.text$mn:00003398
.text$mn:00003398 ; Segment type: Pure code
.text$mn:00003398 ; Segment permissions: Read/Execute
.text$mn:00003398 _text$mn        segment para public 'CODE' use32
.text$mn:00003398                 assume cs:_text$mn
.text$mn:00003398                 ;org 3398h
.text$mn:00003398 ; COMDAT (pick any)
.text$mn:00003398                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003398
.text$mn:00003398 ; =============== S U B R O U T I N E =======================================
.text$mn:00003398
.text$mn:00003398 ; Attributes: bp-based frame
.text$mn:00003398
.text$mn:00003398 ; struct PluginCommand * __cdecl std::_Allocate<struct PluginCommand>(unsigned int, struct PluginCommand *)
.text$mn:00003398                 public ??$_Allocate@UPluginCommand@@@std@@YAPAUPluginCommand@@IPAU1@@Z
.text$mn:00003398 ??$_Allocate@UPluginCommand@@@std@@YAPAUPluginCommand@@IPAU1@@Z proc near
.text$mn:00003398                                         ; CODE XREF: std::allocator<PluginCommand>::allocate(uint)+Dp
.text$mn:00003398
.text$mn:00003398 var_4           = dword ptr -4
.text$mn:00003398 arg_0           = dword ptr  8
.text$mn:00003398
.text$mn:00003398                 push    ebp
.text$mn:00003399                 mov     ebp, esp
.text$mn:0000339B                 push    ecx
.text$mn:0000339C                 mov     [ebp+var_4], 0
.text$mn:000033A3                 cmp     [ebp+arg_0], 0
.text$mn:000033A7                 jnz     short loc_33AB
.text$mn:000033A9                 jmp     short loc_33CF
.text$mn:000033AB ; ---------------------------------------------------------------------------
.text$mn:000033AB
.text$mn:000033AB loc_33AB:                               ; CODE XREF: std::_Allocate<PluginCommand>(uint,PluginCommand *)+Fj
.text$mn:000033AB                 cmp     [ebp+arg_0], 71C71C7h
.text$mn:000033B2                 ja      short loc_33CA
.text$mn:000033B4                 imul    eax, [ebp+arg_0], 24h
.text$mn:000033B8                 push    eax             ; unsigned int
.text$mn:000033B9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000033BE                 add     esp, 4
.text$mn:000033C1                 mov     [ebp+var_4], eax
.text$mn:000033C4                 cmp     [ebp+var_4], 0
.text$mn:000033C8                 jnz     short loc_33CF
.text$mn:000033CA
.text$mn:000033CA loc_33CA:                               ; CODE XREF: std::_Allocate<PluginCommand>(uint,PluginCommand *)+1Aj
.text$mn:000033CA                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000033CF
.text$mn:000033CF loc_33CF:                               ; CODE XREF: std::_Allocate<PluginCommand>(uint,PluginCommand *)+11j
.text$mn:000033CF                                         ; std::_Allocate<PluginCommand>(uint,PluginCommand *)+30j
.text$mn:000033CF                 mov     eax, [ebp+var_4]
.text$mn:000033D2                 mov     esp, ebp
.text$mn:000033D4                 pop     ebp
.text$mn:000033D5                 retn
.text$mn:000033D5 ??$_Allocate@UPluginCommand@@@std@@YAPAUPluginCommand@@IPAU1@@Z endp
.text$mn:000033D5
.text$mn:000033D5 ; ---------------------------------------------------------------------------
.text$mn:000033D6                 align 4
.text$mn:000033D6 _text$mn        ends
.text$mn:000033D6
.text$mn:000033D8 ; ===========================================================================
.text$mn:000033D8
.text$mn:000033D8 ; Segment type: Pure code
.text$mn:000033D8 ; Segment permissions: Read/Execute
.text$mn:000033D8 _text$mn        segment para public 'CODE' use32
.text$mn:000033D8                 assume cs:_text$mn
.text$mn:000033D8                 ;org 33D8h
.text$mn:000033D8 ; COMDAT (pick any)
.text$mn:000033D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000033D8
.text$mn:000033D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000033D8
.text$mn:000033D8 ; Attributes: bp-based frame
.text$mn:000033D8
.text$mn:000033D8 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000033D8                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000033D8 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000033D8                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000033D8
.text$mn:000033D8 var_4           = dword ptr -4
.text$mn:000033D8 arg_0           = dword ptr  8
.text$mn:000033D8
.text$mn:000033D8                 push    ebp
.text$mn:000033D9                 mov     ebp, esp
.text$mn:000033DB                 push    ecx
.text$mn:000033DC                 mov     [ebp+var_4], 0
.text$mn:000033E3                 cmp     [ebp+arg_0], 0
.text$mn:000033E7                 jnz     short loc_33EB
.text$mn:000033E9                 jmp     short loc_3411
.text$mn:000033EB ; ---------------------------------------------------------------------------
.text$mn:000033EB
.text$mn:000033EB loc_33EB:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000033EB                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000033F2                 ja      short loc_340C
.text$mn:000033F4                 mov     eax, [ebp+arg_0]
.text$mn:000033F7                 shl     eax, 3
.text$mn:000033FA                 push    eax             ; unsigned int
.text$mn:000033FB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00003400                 add     esp, 4
.text$mn:00003403                 mov     [ebp+var_4], eax
.text$mn:00003406                 cmp     [ebp+var_4], 0
.text$mn:0000340A                 jnz     short loc_3411
.text$mn:0000340C
.text$mn:0000340C loc_340C:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:0000340C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00003411
.text$mn:00003411 loc_3411:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00003411                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00003411                 mov     eax, [ebp+var_4]
.text$mn:00003414                 mov     esp, ebp
.text$mn:00003416                 pop     ebp
.text$mn:00003417                 retn
.text$mn:00003417 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00003417
.text$mn:00003417 _text$mn        ends
.text$mn:00003417
.text$mn:00003418 ; ===========================================================================
.text$mn:00003418
.text$mn:00003418 ; Segment type: Pure code
.text$mn:00003418 ; Segment permissions: Read/Execute
.text$mn:00003418 _text$mn        segment para public 'CODE' use32
.text$mn:00003418                 assume cs:_text$mn
.text$mn:00003418                 ;org 3418h
.text$mn:00003418 ; COMDAT (pick any)
.text$mn:00003418                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003418
.text$mn:00003418 ; =============== S U B R O U T I N E =======================================
.text$mn:00003418
.text$mn:00003418 ; Attributes: bp-based frame
.text$mn:00003418
.text$mn:00003418 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Allocate<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00003418                 public ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z
.text$mn:00003418 ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z proc near
.text$mn:00003418                                         ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocate(uint)+Dp
.text$mn:00003418
.text$mn:00003418 var_4           = dword ptr -4
.text$mn:00003418 arg_0           = dword ptr  8
.text$mn:00003418
.text$mn:00003418                 push    ebp
.text$mn:00003419                 mov     ebp, esp
.text$mn:0000341B                 push    ecx
.text$mn:0000341C                 mov     [ebp+var_4], 0
.text$mn:00003423                 cmp     [ebp+arg_0], 0
.text$mn:00003427                 jnz     short loc_342B
.text$mn:00003429                 jmp     short loc_344F
.text$mn:0000342B ; ---------------------------------------------------------------------------
.text$mn:0000342B
.text$mn:0000342B loc_342B:                               ; CODE XREF: std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Fj
.text$mn:0000342B                 cmp     [ebp+arg_0], 9249249h
.text$mn:00003432                 ja      short loc_344A
.text$mn:00003434                 imul    eax, [ebp+arg_0], 1Ch
.text$mn:00003438                 push    eax             ; unsigned int
.text$mn:00003439                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000343E                 add     esp, 4
.text$mn:00003441                 mov     [ebp+var_4], eax
.text$mn:00003444                 cmp     [ebp+var_4], 0
.text$mn:00003448                 jnz     short loc_344F
.text$mn:0000344A
.text$mn:0000344A loc_344A:                               ; CODE XREF: std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+1Aj
.text$mn:0000344A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000344F
.text$mn:0000344F loc_344F:                               ; CODE XREF: std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+11j
.text$mn:0000344F                                         ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+30j
.text$mn:0000344F                 mov     eax, [ebp+var_4]
.text$mn:00003452                 mov     esp, ebp
.text$mn:00003454                 pop     ebp
.text$mn:00003455                 retn
.text$mn:00003455 ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z endp
.text$mn:00003455
.text$mn:00003455 ; ---------------------------------------------------------------------------
.text$mn:00003456                 align 4
.text$mn:00003456 _text$mn        ends
.text$mn:00003456
.text$mn:00003458 ; ===========================================================================
.text$mn:00003458
.text$mn:00003458 ; Segment type: Pure code
.text$mn:00003458 ; Segment permissions: Read/Execute
.text$mn:00003458 _text$mn        segment para public 'CODE' use32
.text$mn:00003458                 assume cs:_text$mn
.text$mn:00003458                 ;org 3458h
.text$mn:00003458 ; COMDAT (pick any)
.text$mn:00003458                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003458
.text$mn:00003458 ; =============== S U B R O U T I N E =======================================
.text$mn:00003458
.text$mn:00003458 ; Attributes: bp-based frame
.text$mn:00003458
.text$mn:00003458 ; class PluginCmdShortcut * __cdecl std::_Allocate<class PluginCmdShortcut>(unsigned int, class PluginCmdShortcut *)
.text$mn:00003458                 public ??$_Allocate@VPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@IPAV1@@Z
.text$mn:00003458 ??$_Allocate@VPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@IPAV1@@Z proc near
.text$mn:00003458                                         ; CODE XREF: std::allocator<PluginCmdShortcut>::allocate(uint)+Dp
.text$mn:00003458
.text$mn:00003458 var_4           = dword ptr -4
.text$mn:00003458 arg_0           = dword ptr  8
.text$mn:00003458
.text$mn:00003458                 push    ebp
.text$mn:00003459                 mov     ebp, esp
.text$mn:0000345B                 push    ecx
.text$mn:0000345C                 mov     [ebp+var_4], 0
.text$mn:00003463                 cmp     [ebp+arg_0], 0
.text$mn:00003467                 jnz     short loc_346B
.text$mn:00003469                 jmp     short loc_3492
.text$mn:0000346B ; ---------------------------------------------------------------------------
.text$mn:0000346B
.text$mn:0000346B loc_346B:                               ; CODE XREF: std::_Allocate<PluginCmdShortcut>(uint,PluginCmdShortcut *)+Fj
.text$mn:0000346B                 cmp     [ebp+arg_0], 0C30C30h
.text$mn:00003472                 ja      short loc_348D
.text$mn:00003474                 imul    eax, [ebp+arg_0], 150h
.text$mn:0000347B                 push    eax             ; unsigned int
.text$mn:0000347C                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00003481                 add     esp, 4
.text$mn:00003484                 mov     [ebp+var_4], eax
.text$mn:00003487                 cmp     [ebp+var_4], 0
.text$mn:0000348B                 jnz     short loc_3492
.text$mn:0000348D
.text$mn:0000348D loc_348D:                               ; CODE XREF: std::_Allocate<PluginCmdShortcut>(uint,PluginCmdShortcut *)+1Aj
.text$mn:0000348D                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00003492
.text$mn:00003492 loc_3492:                               ; CODE XREF: std::_Allocate<PluginCmdShortcut>(uint,PluginCmdShortcut *)+11j
.text$mn:00003492                                         ; std::_Allocate<PluginCmdShortcut>(uint,PluginCmdShortcut *)+33j
.text$mn:00003492                 mov     eax, [ebp+var_4]
.text$mn:00003495                 mov     esp, ebp
.text$mn:00003497                 pop     ebp
.text$mn:00003498                 retn
.text$mn:00003498 ??$_Allocate@VPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@IPAV1@@Z endp
.text$mn:00003498
.text$mn:00003498 ; ---------------------------------------------------------------------------
.text$mn:00003499                 align 4
.text$mn:00003499 _text$mn        ends
.text$mn:00003499
.text$mn:0000349C ; ===========================================================================
.text$mn:0000349C
.text$mn:0000349C ; Segment type: Pure code
.text$mn:0000349C ; Segment permissions: Read/Execute
.text$mn:0000349C _text$mn        segment para public 'CODE' use32
.text$mn:0000349C                 assume cs:_text$mn
.text$mn:0000349C                 ;org 349Ch
.text$mn:0000349C ; COMDAT (pick any)
.text$mn:0000349C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000349C
.text$mn:0000349C ; =============== S U B R O U T I N E =======================================
.text$mn:0000349C
.text$mn:0000349C ; Attributes: bp-based frame
.text$mn:0000349C
.text$mn:0000349C ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:0000349C                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:0000349C ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:0000349C                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:0000349C
.text$mn:0000349C var_4           = dword ptr -4
.text$mn:0000349C arg_0           = dword ptr  8
.text$mn:0000349C
.text$mn:0000349C                 push    ebp
.text$mn:0000349D                 mov     ebp, esp
.text$mn:0000349F                 push    ecx
.text$mn:000034A0                 mov     [ebp+var_4], 0
.text$mn:000034A7                 cmp     [ebp+arg_0], 0
.text$mn:000034AB                 jnz     short loc_34AF
.text$mn:000034AD                 jmp     short loc_34D4
.text$mn:000034AF ; ---------------------------------------------------------------------------
.text$mn:000034AF
.text$mn:000034AF loc_34AF:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:000034AF                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:000034B6                 ja      short loc_34CF
.text$mn:000034B8                 mov     eax, [ebp+arg_0]
.text$mn:000034BB                 shl     eax, 1
.text$mn:000034BD                 push    eax             ; unsigned int
.text$mn:000034BE                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000034C3                 add     esp, 4
.text$mn:000034C6                 mov     [ebp+var_4], eax
.text$mn:000034C9                 cmp     [ebp+var_4], 0
.text$mn:000034CD                 jnz     short loc_34D4
.text$mn:000034CF
.text$mn:000034CF loc_34CF:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:000034CF                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000034D4
.text$mn:000034D4 loc_34D4:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:000034D4                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:000034D4                 mov     eax, [ebp+var_4]
.text$mn:000034D7                 mov     esp, ebp
.text$mn:000034D9                 pop     ebp
.text$mn:000034DA                 retn
.text$mn:000034DA ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:000034DA
.text$mn:000034DA ; ---------------------------------------------------------------------------
.text$mn:000034DB                 align 4
.text$mn:000034DB _text$mn        ends
.text$mn:000034DB
.text$mn:000034DC ; ===========================================================================
.text$mn:000034DC
.text$mn:000034DC ; Segment type: Pure code
.text$mn:000034DC ; Segment permissions: Read/Execute
.text$mn:000034DC _text$mn        segment para public 'CODE' use32
.text$mn:000034DC                 assume cs:_text$mn
.text$mn:000034DC                 ;org 34DCh
.text$mn:000034DC ; COMDAT (pick any)
.text$mn:000034DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034DC
.text$mn:000034DC ; =============== S U B R O U T I N E =======================================
.text$mn:000034DC
.text$mn:000034DC ; Attributes: bp-based frame
.text$mn:000034DC
.text$mn:000034DC ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000034DC                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000034DC ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000034DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000034DC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000034DC
.text$mn:000034DC arg_0           = dword ptr  8
.text$mn:000034DC arg_4           = dword ptr  0Ch
.text$mn:000034DC arg_8           = dword ptr  10h
.text$mn:000034DC
.text$mn:000034DC                 push    ebp
.text$mn:000034DD                 mov     ebp, esp
.text$mn:000034DF                 cmp     [ebp+arg_0], 0
.text$mn:000034E3                 jnz     short loc_34FA
.text$mn:000034E5                 mov     eax, [ebp+arg_8]
.text$mn:000034E8                 push    eax             ; unsigned int
.text$mn:000034E9                 mov     ecx, [ebp+arg_4]
.text$mn:000034EC                 push    ecx             ; wchar_t *
.text$mn:000034ED                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000034F2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000034F7                 add     esp, 0Ch
.text$mn:000034FA
.text$mn:000034FA loc_34FA:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000034FA                 pop     ebp
.text$mn:000034FB                 retn
.text$mn:000034FB ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000034FB
.text$mn:000034FB _text$mn        ends
.text$mn:000034FB
.text$mn:000034FC ; ===========================================================================
.text$mn:000034FC
.text$mn:000034FC ; Segment type: Pure code
.text$mn:000034FC ; Segment permissions: Read/Execute
.text$mn:000034FC _text$mn        segment para public 'CODE' use32
.text$mn:000034FC                 assume cs:_text$mn
.text$mn:000034FC                 ;org 34FCh
.text$mn:000034FC ; COMDAT (pick any)
.text$mn:000034FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034FC
.text$mn:000034FC ; =============== S U B R O U T I N E =======================================
.text$mn:000034FC
.text$mn:000034FC ; Attributes: bp-based frame
.text$mn:000034FC
.text$mn:000034FC ; int __cdecl std::_Debug_pointer<PluginInfo *>(int, wchar_t *, unsigned int)
.text$mn:000034FC                 public ??$_Debug_pointer@PAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@PB_WI@Z
.text$mn:000034FC ??$_Debug_pointer@PAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@PB_WI@Z proc near
.text$mn:000034FC                                         ; CODE XREF: std::_Debug_range2<PluginInfo * *>(PluginInfo * *,PluginInfo * *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:000034FC                                         ; std::_Debug_range2<PluginInfo * *>(PluginInfo * *,PluginInfo * *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:000034FC
.text$mn:000034FC arg_0           = dword ptr  8
.text$mn:000034FC arg_4           = dword ptr  0Ch
.text$mn:000034FC arg_8           = dword ptr  10h
.text$mn:000034FC
.text$mn:000034FC                 push    ebp
.text$mn:000034FD                 mov     ebp, esp
.text$mn:000034FF                 cmp     [ebp+arg_0], 0
.text$mn:00003503                 jnz     short loc_351A
.text$mn:00003505                 mov     eax, [ebp+arg_8]
.text$mn:00003508                 push    eax             ; unsigned int
.text$mn:00003509                 mov     ecx, [ebp+arg_4]
.text$mn:0000350C                 push    ecx             ; wchar_t *
.text$mn:0000350D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00003512                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003517                 add     esp, 0Ch
.text$mn:0000351A
.text$mn:0000351A loc_351A:                               ; CODE XREF: std::_Debug_pointer<PluginInfo *>(PluginInfo * *,wchar_t const *,uint)+7j
.text$mn:0000351A                 pop     ebp
.text$mn:0000351B                 retn
.text$mn:0000351B ??$_Debug_pointer@PAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@PB_WI@Z endp
.text$mn:0000351B
.text$mn:0000351B _text$mn        ends
.text$mn:0000351B
.text$mn:0000351C ; ===========================================================================
.text$mn:0000351C
.text$mn:0000351C ; Segment type: Pure code
.text$mn:0000351C ; Segment permissions: Read/Execute
.text$mn:0000351C _text$mn        segment para public 'CODE' use32
.text$mn:0000351C                 assume cs:_text$mn
.text$mn:0000351C                 ;org 351Ch
.text$mn:0000351C ; COMDAT (pick any)
.text$mn:0000351C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000351C
.text$mn:0000351C ; =============== S U B R O U T I N E =======================================
.text$mn:0000351C
.text$mn:0000351C ; Attributes: bp-based frame
.text$mn:0000351C
.text$mn:0000351C ; int __cdecl std::_Debug_pointer<TiXmlDocument *>(int, wchar_t *, unsigned int)
.text$mn:0000351C                 public ??$_Debug_pointer@PAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@PB_WI@Z
.text$mn:0000351C ??$_Debug_pointer@PAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@PB_WI@Z proc near
.text$mn:0000351C                                         ; CODE XREF: std::_Debug_range2<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000351C                                         ; std::_Debug_range2<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000351C
.text$mn:0000351C arg_0           = dword ptr  8
.text$mn:0000351C arg_4           = dword ptr  0Ch
.text$mn:0000351C arg_8           = dword ptr  10h
.text$mn:0000351C
.text$mn:0000351C                 push    ebp
.text$mn:0000351D                 mov     ebp, esp
.text$mn:0000351F                 cmp     [ebp+arg_0], 0
.text$mn:00003523                 jnz     short loc_353A
.text$mn:00003525                 mov     eax, [ebp+arg_8]
.text$mn:00003528                 push    eax             ; unsigned int
.text$mn:00003529                 mov     ecx, [ebp+arg_4]
.text$mn:0000352C                 push    ecx             ; wchar_t *
.text$mn:0000352D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00003532                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003537                 add     esp, 0Ch
.text$mn:0000353A
.text$mn:0000353A loc_353A:                               ; CODE XREF: std::_Debug_pointer<TiXmlDocument *>(TiXmlDocument * *,wchar_t const *,uint)+7j
.text$mn:0000353A                 pop     ebp
.text$mn:0000353B                 retn
.text$mn:0000353B ??$_Debug_pointer@PAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@PB_WI@Z endp
.text$mn:0000353B
.text$mn:0000353B _text$mn        ends
.text$mn:0000353B
.text$mn:0000353C ; ===========================================================================
.text$mn:0000353C
.text$mn:0000353C ; Segment type: Pure code
.text$mn:0000353C ; Segment permissions: Read/Execute
.text$mn:0000353C _text$mn        segment para public 'CODE' use32
.text$mn:0000353C                 assume cs:_text$mn
.text$mn:0000353C                 ;org 353Ch
.text$mn:0000353C ; COMDAT (pick any)
.text$mn:0000353C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000353C
.text$mn:0000353C ; =============== S U B R O U T I N E =======================================
.text$mn:0000353C
.text$mn:0000353C ; Attributes: bp-based frame
.text$mn:0000353C
.text$mn:0000353C ; int __cdecl std::_Debug_pointer<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(int, wchar_t *, unsigned int)
.text$mn:0000353C                 public ??$_Debug_pointer@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PB_WI@Z
.text$mn:0000353C ??$_Debug_pointer@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PB_WI@Z proc near
.text$mn:0000353C                                         ; CODE XREF: std::_Debug_range2<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000353C                                         ; std::_Debug_range2<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000353C
.text$mn:0000353C arg_0           = dword ptr  8
.text$mn:0000353C arg_4           = dword ptr  0Ch
.text$mn:0000353C arg_8           = dword ptr  10h
.text$mn:0000353C
.text$mn:0000353C                 push    ebp
.text$mn:0000353D                 mov     ebp, esp
.text$mn:0000353F                 cmp     [ebp+arg_0], 0
.text$mn:00003543                 jnz     short loc_355A
.text$mn:00003545                 mov     eax, [ebp+arg_8]
.text$mn:00003548                 push    eax             ; unsigned int
.text$mn:00003549                 mov     ecx, [ebp+arg_4]
.text$mn:0000354C                 push    ecx             ; wchar_t *
.text$mn:0000354D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00003552                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003557                 add     esp, 0Ch
.text$mn:0000355A
.text$mn:0000355A loc_355A:                               ; CODE XREF: std::_Debug_pointer<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint)+7j
.text$mn:0000355A                 pop     ebp
.text$mn:0000355B                 retn
.text$mn:0000355B ??$_Debug_pointer@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PB_WI@Z endp
.text$mn:0000355B
.text$mn:0000355B _text$mn        ends
.text$mn:0000355B
.text$mn:0000355C ; ===========================================================================
.text$mn:0000355C
.text$mn:0000355C ; Segment type: Pure code
.text$mn:0000355C ; Segment permissions: Read/Execute
.text$mn:0000355C _text$mn        segment para public 'CODE' use32
.text$mn:0000355C                 assume cs:_text$mn
.text$mn:0000355C                 ;org 355Ch
.text$mn:0000355C ; COMDAT (pick any)
.text$mn:0000355C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000355C
.text$mn:0000355C ; =============== S U B R O U T I N E =======================================
.text$mn:0000355C
.text$mn:0000355C ; Attributes: bp-based frame
.text$mn:0000355C
.text$mn:0000355C ; int __cdecl std::_Debug_pointer<PluginCommand>(int, wchar_t *, unsigned int)
.text$mn:0000355C                 public ??$_Debug_pointer@UPluginCommand@@@std@@YAXPAUPluginCommand@@PB_WI@Z
.text$mn:0000355C ??$_Debug_pointer@UPluginCommand@@@std@@YAXPAUPluginCommand@@PB_WI@Z proc near
.text$mn:0000355C                                         ; CODE XREF: std::_Debug_range2<PluginCommand *>(PluginCommand *,PluginCommand *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000355C                                         ; std::_Debug_range2<PluginCommand *>(PluginCommand *,PluginCommand *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000355C
.text$mn:0000355C arg_0           = dword ptr  8
.text$mn:0000355C arg_4           = dword ptr  0Ch
.text$mn:0000355C arg_8           = dword ptr  10h
.text$mn:0000355C
.text$mn:0000355C                 push    ebp
.text$mn:0000355D                 mov     ebp, esp
.text$mn:0000355F                 cmp     [ebp+arg_0], 0
.text$mn:00003563                 jnz     short loc_357A
.text$mn:00003565                 mov     eax, [ebp+arg_8]
.text$mn:00003568                 push    eax             ; unsigned int
.text$mn:00003569                 mov     ecx, [ebp+arg_4]
.text$mn:0000356C                 push    ecx             ; wchar_t *
.text$mn:0000356D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00003572                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003577                 add     esp, 0Ch
.text$mn:0000357A
.text$mn:0000357A loc_357A:                               ; CODE XREF: std::_Debug_pointer<PluginCommand>(PluginCommand *,wchar_t const *,uint)+7j
.text$mn:0000357A                 pop     ebp
.text$mn:0000357B                 retn
.text$mn:0000357B ??$_Debug_pointer@UPluginCommand@@@std@@YAXPAUPluginCommand@@PB_WI@Z endp
.text$mn:0000357B
.text$mn:0000357B _text$mn        ends
.text$mn:0000357B
.text$mn:0000357C ; ===========================================================================
.text$mn:0000357C
.text$mn:0000357C ; Segment type: Pure code
.text$mn:0000357C ; Segment permissions: Read/Execute
.text$mn:0000357C _text$mn        segment para public 'CODE' use32
.text$mn:0000357C                 assume cs:_text$mn
.text$mn:0000357C                 ;org 357Ch
.text$mn:0000357C ; COMDAT (pick any)
.text$mn:0000357C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000357C
.text$mn:0000357C ; =============== S U B R O U T I N E =======================================
.text$mn:0000357C
.text$mn:0000357C ; Attributes: bp-based frame
.text$mn:0000357C
.text$mn:0000357C ; int __cdecl std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(int, wchar_t *, unsigned int)
.text$mn:0000357C                 public ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z
.text$mn:0000357C ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z proc near
.text$mn:0000357C                                         ; CODE XREF: std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000357C                                         ; std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000357C
.text$mn:0000357C arg_0           = dword ptr  8
.text$mn:0000357C arg_4           = dword ptr  0Ch
.text$mn:0000357C arg_8           = dword ptr  10h
.text$mn:0000357C
.text$mn:0000357C                 push    ebp
.text$mn:0000357D                 mov     ebp, esp
.text$mn:0000357F                 cmp     [ebp+arg_0], 0
.text$mn:00003583                 jnz     short loc_359A
.text$mn:00003585                 mov     eax, [ebp+arg_8]
.text$mn:00003588                 push    eax             ; unsigned int
.text$mn:00003589                 mov     ecx, [ebp+arg_4]
.text$mn:0000358C                 push    ecx             ; wchar_t *
.text$mn:0000358D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00003592                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003597                 add     esp, 0Ch
.text$mn:0000359A
.text$mn:0000359A loc_359A:                               ; CODE XREF: std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)+7j
.text$mn:0000359A                 pop     ebp
.text$mn:0000359B                 retn
.text$mn:0000359B ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z endp
.text$mn:0000359B
.text$mn:0000359B _text$mn        ends
.text$mn:0000359B
.text$mn:0000359C ; ===========================================================================
.text$mn:0000359C
.text$mn:0000359C ; Segment type: Pure code
.text$mn:0000359C ; Segment permissions: Read/Execute
.text$mn:0000359C _text$mn        segment para public 'CODE' use32
.text$mn:0000359C                 assume cs:_text$mn
.text$mn:0000359C                 ;org 359Ch
.text$mn:0000359C ; COMDAT (pick any)
.text$mn:0000359C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000359C
.text$mn:0000359C ; =============== S U B R O U T I N E =======================================
.text$mn:0000359C
.text$mn:0000359C ; Attributes: bp-based frame
.text$mn:0000359C
.text$mn:0000359C ; int __cdecl std::_Debug_pointer<PluginCmdShortcut>(int, wchar_t *, unsigned int)
.text$mn:0000359C                 public ??$_Debug_pointer@VPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@PB_WI@Z
.text$mn:0000359C ??$_Debug_pointer@VPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@PB_WI@Z proc near
.text$mn:0000359C                                         ; CODE XREF: std::_Debug_range2<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000359C                                         ; std::_Debug_range2<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000359C
.text$mn:0000359C arg_0           = dword ptr  8
.text$mn:0000359C arg_4           = dword ptr  0Ch
.text$mn:0000359C arg_8           = dword ptr  10h
.text$mn:0000359C
.text$mn:0000359C                 push    ebp
.text$mn:0000359D                 mov     ebp, esp
.text$mn:0000359F                 cmp     [ebp+arg_0], 0
.text$mn:000035A3                 jnz     short loc_35BA
.text$mn:000035A5                 mov     eax, [ebp+arg_8]
.text$mn:000035A8                 push    eax             ; unsigned int
.text$mn:000035A9                 mov     ecx, [ebp+arg_4]
.text$mn:000035AC                 push    ecx             ; wchar_t *
.text$mn:000035AD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000035B2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000035B7                 add     esp, 0Ch
.text$mn:000035BA
.text$mn:000035BA loc_35BA:                               ; CODE XREF: std::_Debug_pointer<PluginCmdShortcut>(PluginCmdShortcut *,wchar_t const *,uint)+7j
.text$mn:000035BA                 pop     ebp
.text$mn:000035BB                 retn
.text$mn:000035BB ??$_Debug_pointer@VPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@PB_WI@Z endp
.text$mn:000035BB
.text$mn:000035BB _text$mn        ends
.text$mn:000035BB
.text$mn:000035BC ; ===========================================================================
.text$mn:000035BC
.text$mn:000035BC ; Segment type: Pure code
.text$mn:000035BC ; Segment permissions: Read/Execute
.text$mn:000035BC _text$mn        segment para public 'CODE' use32
.text$mn:000035BC                 assume cs:_text$mn
.text$mn:000035BC                 ;org 35BCh
.text$mn:000035BC ; COMDAT (pick any)
.text$mn:000035BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035BC
.text$mn:000035BC ; =============== S U B R O U T I N E =======================================
.text$mn:000035BC
.text$mn:000035BC ; Attributes: bp-based frame
.text$mn:000035BC
.text$mn:000035BC ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:000035BC                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:000035BC ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:000035BC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+15p
.text$mn:000035BC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+1Dp ...
.text$mn:000035BC
.text$mn:000035BC arg_0           = dword ptr  8
.text$mn:000035BC arg_4           = dword ptr  0Ch
.text$mn:000035BC arg_8           = dword ptr  10h
.text$mn:000035BC
.text$mn:000035BC                 push    ebp
.text$mn:000035BD                 mov     ebp, esp
.text$mn:000035BF                 cmp     [ebp+arg_0], 0
.text$mn:000035C3                 jnz     short loc_35DA
.text$mn:000035C5                 mov     eax, [ebp+arg_8]
.text$mn:000035C8                 push    eax             ; unsigned int
.text$mn:000035C9                 mov     ecx, [ebp+arg_4]
.text$mn:000035CC                 push    ecx             ; wchar_t *
.text$mn:000035CD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000035D2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000035D7                 add     esp, 0Ch
.text$mn:000035DA
.text$mn:000035DA loc_35DA:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:000035DA                 pop     ebp
.text$mn:000035DB                 retn
.text$mn:000035DB ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:000035DB
.text$mn:000035DB _text$mn        ends
.text$mn:000035DB
.text$mn:000035DC ; ===========================================================================
.text$mn:000035DC
.text$mn:000035DC ; Segment type: Pure code
.text$mn:000035DC ; Segment permissions: Read/Execute
.text$mn:000035DC _text$mn        segment para public 'CODE' use32
.text$mn:000035DC                 assume cs:_text$mn
.text$mn:000035DC                 ;org 35DCh
.text$mn:000035DC ; COMDAT (pick any)
.text$mn:000035DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035DC
.text$mn:000035DC ; =============== S U B R O U T I N E =======================================
.text$mn:000035DC
.text$mn:000035DC ; Attributes: bp-based frame
.text$mn:000035DC
.text$mn:000035DC ; int __cdecl std::_Debug_range2<PluginInfo * *>(int, int, wchar_t *, unsigned int)
.text$mn:000035DC                 public ??$_Debug_range2@PAPAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000035DC ??$_Debug_range2@PAPAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000035DC                                         ; CODE XREF: std::_Debug_range<PluginInfo * *>(PluginInfo * *,PluginInfo * *,wchar_t const *,uint)+2Ap
.text$mn:000035DC
.text$mn:000035DC arg_0           = dword ptr  8
.text$mn:000035DC arg_4           = dword ptr  0Ch
.text$mn:000035DC arg_8           = dword ptr  10h
.text$mn:000035DC arg_C           = dword ptr  14h
.text$mn:000035DC
.text$mn:000035DC                 push    ebp
.text$mn:000035DD                 mov     ebp, esp
.text$mn:000035DF                 mov     eax, [ebp+arg_0]
.text$mn:000035E2                 cmp     eax, [ebp+arg_4]
.text$mn:000035E5                 jz      short loc_362C
.text$mn:000035E7                 mov     ecx, [ebp+arg_C]
.text$mn:000035EA                 push    ecx             ; unsigned int
.text$mn:000035EB                 mov     edx, [ebp+arg_8]
.text$mn:000035EE                 push    edx             ; wchar_t *
.text$mn:000035EF                 mov     eax, [ebp+arg_0]
.text$mn:000035F2                 push    eax             ; int
.text$mn:000035F3                 call    ??$_Debug_pointer@PAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@PB_WI@Z ; std::_Debug_pointer<PluginInfo *>(PluginInfo * *,wchar_t const *,uint)
.text$mn:000035F8                 add     esp, 0Ch
.text$mn:000035FB                 mov     ecx, [ebp+arg_C]
.text$mn:000035FE                 push    ecx             ; unsigned int
.text$mn:000035FF                 mov     edx, [ebp+arg_8]
.text$mn:00003602                 push    edx             ; wchar_t *
.text$mn:00003603                 mov     eax, [ebp+arg_4]
.text$mn:00003606                 push    eax             ; int
.text$mn:00003607                 call    ??$_Debug_pointer@PAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@PB_WI@Z ; std::_Debug_pointer<PluginInfo *>(PluginInfo * *,wchar_t const *,uint)
.text$mn:0000360C                 add     esp, 0Ch
.text$mn:0000360F                 mov     ecx, [ebp+arg_4]
.text$mn:00003612                 cmp     ecx, [ebp+arg_0]
.text$mn:00003615                 jnb     short loc_362C
.text$mn:00003617                 mov     edx, [ebp+arg_C]
.text$mn:0000361A                 push    edx             ; unsigned int
.text$mn:0000361B                 mov     eax, [ebp+arg_8]
.text$mn:0000361E                 push    eax             ; wchar_t *
.text$mn:0000361F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003624                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003629                 add     esp, 0Ch
.text$mn:0000362C
.text$mn:0000362C loc_362C:                               ; CODE XREF: std::_Debug_range2<PluginInfo * *>(PluginInfo * *,PluginInfo * *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:0000362C                                         ; std::_Debug_range2<PluginInfo * *>(PluginInfo * *,PluginInfo * *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:0000362C                 pop     ebp
.text$mn:0000362D                 retn
.text$mn:0000362D ??$_Debug_range2@PAPAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:0000362D
.text$mn:0000362D ; ---------------------------------------------------------------------------
.text$mn:0000362E                 align 10h
.text$mn:0000362E _text$mn        ends
.text$mn:0000362E
.text$mn:00003630 ; ===========================================================================
.text$mn:00003630
.text$mn:00003630 ; Segment type: Pure code
.text$mn:00003630 ; Segment permissions: Read/Execute
.text$mn:00003630 _text$mn        segment para public 'CODE' use32
.text$mn:00003630                 assume cs:_text$mn
.text$mn:00003630                 ;org 3630h
.text$mn:00003630 ; COMDAT (pick any)
.text$mn:00003630                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003630
.text$mn:00003630 ; =============== S U B R O U T I N E =======================================
.text$mn:00003630
.text$mn:00003630 ; Attributes: bp-based frame
.text$mn:00003630
.text$mn:00003630 ; int __cdecl std::_Debug_range2<TiXmlDocument * *>(int, int, wchar_t *, unsigned int)
.text$mn:00003630                 public ??$_Debug_range2@PAPAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00003630 ??$_Debug_range2@PAPAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003630                                         ; CODE XREF: std::_Debug_range<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,wchar_t const *,uint)+2Ap
.text$mn:00003630
.text$mn:00003630 arg_0           = dword ptr  8
.text$mn:00003630 arg_4           = dword ptr  0Ch
.text$mn:00003630 arg_8           = dword ptr  10h
.text$mn:00003630 arg_C           = dword ptr  14h
.text$mn:00003630
.text$mn:00003630                 push    ebp
.text$mn:00003631                 mov     ebp, esp
.text$mn:00003633                 mov     eax, [ebp+arg_0]
.text$mn:00003636                 cmp     eax, [ebp+arg_4]
.text$mn:00003639                 jz      short loc_3680
.text$mn:0000363B                 mov     ecx, [ebp+arg_C]
.text$mn:0000363E                 push    ecx             ; unsigned int
.text$mn:0000363F                 mov     edx, [ebp+arg_8]
.text$mn:00003642                 push    edx             ; wchar_t *
.text$mn:00003643                 mov     eax, [ebp+arg_0]
.text$mn:00003646                 push    eax             ; int
.text$mn:00003647                 call    ??$_Debug_pointer@PAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@PB_WI@Z ; std::_Debug_pointer<TiXmlDocument *>(TiXmlDocument * *,wchar_t const *,uint)
.text$mn:0000364C                 add     esp, 0Ch
.text$mn:0000364F                 mov     ecx, [ebp+arg_C]
.text$mn:00003652                 push    ecx             ; unsigned int
.text$mn:00003653                 mov     edx, [ebp+arg_8]
.text$mn:00003656                 push    edx             ; wchar_t *
.text$mn:00003657                 mov     eax, [ebp+arg_4]
.text$mn:0000365A                 push    eax             ; int
.text$mn:0000365B                 call    ??$_Debug_pointer@PAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@PB_WI@Z ; std::_Debug_pointer<TiXmlDocument *>(TiXmlDocument * *,wchar_t const *,uint)
.text$mn:00003660                 add     esp, 0Ch
.text$mn:00003663                 mov     ecx, [ebp+arg_4]
.text$mn:00003666                 cmp     ecx, [ebp+arg_0]
.text$mn:00003669                 jnb     short loc_3680
.text$mn:0000366B                 mov     edx, [ebp+arg_C]
.text$mn:0000366E                 push    edx             ; unsigned int
.text$mn:0000366F                 mov     eax, [ebp+arg_8]
.text$mn:00003672                 push    eax             ; wchar_t *
.text$mn:00003673                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003678                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000367D                 add     esp, 0Ch
.text$mn:00003680
.text$mn:00003680 loc_3680:                               ; CODE XREF: std::_Debug_range2<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00003680                                         ; std::_Debug_range2<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00003680                 pop     ebp
.text$mn:00003681                 retn
.text$mn:00003681 ??$_Debug_range2@PAPAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00003681
.text$mn:00003681 ; ---------------------------------------------------------------------------
.text$mn:00003682                 align 4
.text$mn:00003682 _text$mn        ends
.text$mn:00003682
.text$mn:00003684 ; ===========================================================================
.text$mn:00003684
.text$mn:00003684 ; Segment type: Pure code
.text$mn:00003684 ; Segment permissions: Read/Execute
.text$mn:00003684 _text$mn        segment para public 'CODE' use32
.text$mn:00003684                 assume cs:_text$mn
.text$mn:00003684                 ;org 3684h
.text$mn:00003684 ; COMDAT (pick any)
.text$mn:00003684                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003684
.text$mn:00003684 ; =============== S U B R O U T I N E =======================================
.text$mn:00003684
.text$mn:00003684 ; Attributes: bp-based frame
.text$mn:00003684
.text$mn:00003684 ; int __cdecl std::_Debug_range2<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(int, int, wchar_t *, unsigned int)
.text$mn:00003684                 public ??$_Debug_range2@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00003684 ??$_Debug_range2@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003684                                         ; CODE XREF: std::_Debug_range<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint)+2Ap
.text$mn:00003684
.text$mn:00003684 arg_0           = dword ptr  8
.text$mn:00003684 arg_4           = dword ptr  0Ch
.text$mn:00003684 arg_8           = dword ptr  10h
.text$mn:00003684 arg_C           = dword ptr  14h
.text$mn:00003684
.text$mn:00003684                 push    ebp
.text$mn:00003685                 mov     ebp, esp
.text$mn:00003687                 mov     eax, [ebp+arg_0]
.text$mn:0000368A                 cmp     eax, [ebp+arg_4]
.text$mn:0000368D                 jz      short loc_36D4
.text$mn:0000368F                 mov     ecx, [ebp+arg_C]
.text$mn:00003692                 push    ecx             ; unsigned int
.text$mn:00003693                 mov     edx, [ebp+arg_8]
.text$mn:00003696                 push    edx             ; wchar_t *
.text$mn:00003697                 mov     eax, [ebp+arg_0]
.text$mn:0000369A                 push    eax             ; int
.text$mn:0000369B                 call    ??$_Debug_pointer@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PB_WI@Z ; std::_Debug_pointer<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint)
.text$mn:000036A0                 add     esp, 0Ch
.text$mn:000036A3                 mov     ecx, [ebp+arg_C]
.text$mn:000036A6                 push    ecx             ; unsigned int
.text$mn:000036A7                 mov     edx, [ebp+arg_8]
.text$mn:000036AA                 push    edx             ; wchar_t *
.text$mn:000036AB                 mov     eax, [ebp+arg_4]
.text$mn:000036AE                 push    eax             ; int
.text$mn:000036AF                 call    ??$_Debug_pointer@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PB_WI@Z ; std::_Debug_pointer<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint)
.text$mn:000036B4                 add     esp, 0Ch
.text$mn:000036B7                 mov     ecx, [ebp+arg_4]
.text$mn:000036BA                 cmp     ecx, [ebp+arg_0]
.text$mn:000036BD                 jnb     short loc_36D4
.text$mn:000036BF                 mov     edx, [ebp+arg_C]
.text$mn:000036C2                 push    edx             ; unsigned int
.text$mn:000036C3                 mov     eax, [ebp+arg_8]
.text$mn:000036C6                 push    eax             ; wchar_t *
.text$mn:000036C7                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000036CC                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000036D1                 add     esp, 0Ch
.text$mn:000036D4
.text$mn:000036D4 loc_36D4:                               ; CODE XREF: std::_Debug_range2<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000036D4                                         ; std::_Debug_range2<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000036D4                 pop     ebp
.text$mn:000036D5                 retn
.text$mn:000036D5 ??$_Debug_range2@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000036D5
.text$mn:000036D5 ; ---------------------------------------------------------------------------
.text$mn:000036D6                 align 4
.text$mn:000036D6 _text$mn        ends
.text$mn:000036D6
.text$mn:000036D8 ; ===========================================================================
.text$mn:000036D8
.text$mn:000036D8 ; Segment type: Pure code
.text$mn:000036D8 ; Segment permissions: Read/Execute
.text$mn:000036D8 _text$mn        segment para public 'CODE' use32
.text$mn:000036D8                 assume cs:_text$mn
.text$mn:000036D8                 ;org 36D8h
.text$mn:000036D8 ; COMDAT (pick any)
.text$mn:000036D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036D8
.text$mn:000036D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000036D8
.text$mn:000036D8 ; Attributes: bp-based frame
.text$mn:000036D8
.text$mn:000036D8 ; int __cdecl std::_Debug_range2<PluginCommand *>(int, int, wchar_t *, unsigned int)
.text$mn:000036D8                 public ??$_Debug_range2@PAUPluginCommand@@@std@@YAXPAUPluginCommand@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000036D8 ??$_Debug_range2@PAUPluginCommand@@@std@@YAXPAUPluginCommand@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000036D8                                         ; CODE XREF: std::_Debug_range<PluginCommand *>(PluginCommand *,PluginCommand *,wchar_t const *,uint)+2Ap
.text$mn:000036D8
.text$mn:000036D8 arg_0           = dword ptr  8
.text$mn:000036D8 arg_4           = dword ptr  0Ch
.text$mn:000036D8 arg_8           = dword ptr  10h
.text$mn:000036D8 arg_C           = dword ptr  14h
.text$mn:000036D8
.text$mn:000036D8                 push    ebp
.text$mn:000036D9                 mov     ebp, esp
.text$mn:000036DB                 mov     eax, [ebp+arg_0]
.text$mn:000036DE                 cmp     eax, [ebp+arg_4]
.text$mn:000036E1                 jz      short loc_3728
.text$mn:000036E3                 mov     ecx, [ebp+arg_C]
.text$mn:000036E6                 push    ecx             ; unsigned int
.text$mn:000036E7                 mov     edx, [ebp+arg_8]
.text$mn:000036EA                 push    edx             ; wchar_t *
.text$mn:000036EB                 mov     eax, [ebp+arg_0]
.text$mn:000036EE                 push    eax             ; int
.text$mn:000036EF                 call    ??$_Debug_pointer@UPluginCommand@@@std@@YAXPAUPluginCommand@@PB_WI@Z ; std::_Debug_pointer<PluginCommand>(PluginCommand *,wchar_t const *,uint)
.text$mn:000036F4                 add     esp, 0Ch
.text$mn:000036F7                 mov     ecx, [ebp+arg_C]
.text$mn:000036FA                 push    ecx             ; unsigned int
.text$mn:000036FB                 mov     edx, [ebp+arg_8]
.text$mn:000036FE                 push    edx             ; wchar_t *
.text$mn:000036FF                 mov     eax, [ebp+arg_4]
.text$mn:00003702                 push    eax             ; int
.text$mn:00003703                 call    ??$_Debug_pointer@UPluginCommand@@@std@@YAXPAUPluginCommand@@PB_WI@Z ; std::_Debug_pointer<PluginCommand>(PluginCommand *,wchar_t const *,uint)
.text$mn:00003708                 add     esp, 0Ch
.text$mn:0000370B                 mov     ecx, [ebp+arg_4]
.text$mn:0000370E                 cmp     ecx, [ebp+arg_0]
.text$mn:00003711                 jnb     short loc_3728
.text$mn:00003713                 mov     edx, [ebp+arg_C]
.text$mn:00003716                 push    edx             ; unsigned int
.text$mn:00003717                 mov     eax, [ebp+arg_8]
.text$mn:0000371A                 push    eax             ; wchar_t *
.text$mn:0000371B                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003720                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003725                 add     esp, 0Ch
.text$mn:00003728
.text$mn:00003728 loc_3728:                               ; CODE XREF: std::_Debug_range2<PluginCommand *>(PluginCommand *,PluginCommand *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00003728                                         ; std::_Debug_range2<PluginCommand *>(PluginCommand *,PluginCommand *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00003728                 pop     ebp
.text$mn:00003729                 retn
.text$mn:00003729 ??$_Debug_range2@PAUPluginCommand@@@std@@YAXPAUPluginCommand@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00003729
.text$mn:00003729 ; ---------------------------------------------------------------------------
.text$mn:0000372A                 align 4
.text$mn:0000372A _text$mn        ends
.text$mn:0000372A
.text$mn:0000372C ; ===========================================================================
.text$mn:0000372C
.text$mn:0000372C ; Segment type: Pure code
.text$mn:0000372C ; Segment permissions: Read/Execute
.text$mn:0000372C _text$mn        segment para public 'CODE' use32
.text$mn:0000372C                 assume cs:_text$mn
.text$mn:0000372C                 ;org 372Ch
.text$mn:0000372C ; COMDAT (pick any)
.text$mn:0000372C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000372C
.text$mn:0000372C ; =============== S U B R O U T I N E =======================================
.text$mn:0000372C
.text$mn:0000372C ; Attributes: bp-based frame
.text$mn:0000372C
.text$mn:0000372C ; int __cdecl std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(int, int, wchar_t *, unsigned int)
.text$mn:0000372C                 public ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:0000372C ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:0000372C                                         ; CODE XREF: std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)+2Ap
.text$mn:0000372C
.text$mn:0000372C arg_0           = dword ptr  8
.text$mn:0000372C arg_4           = dword ptr  0Ch
.text$mn:0000372C arg_8           = dword ptr  10h
.text$mn:0000372C arg_C           = dword ptr  14h
.text$mn:0000372C
.text$mn:0000372C                 push    ebp
.text$mn:0000372D                 mov     ebp, esp
.text$mn:0000372F                 mov     eax, [ebp+arg_0]
.text$mn:00003732                 cmp     eax, [ebp+arg_4]
.text$mn:00003735                 jz      short loc_377C
.text$mn:00003737                 mov     ecx, [ebp+arg_C]
.text$mn:0000373A                 push    ecx             ; unsigned int
.text$mn:0000373B                 mov     edx, [ebp+arg_8]
.text$mn:0000373E                 push    edx             ; wchar_t *
.text$mn:0000373F                 mov     eax, [ebp+arg_0]
.text$mn:00003742                 push    eax             ; int
.text$mn:00003743                 call    ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z ; std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:00003748                 add     esp, 0Ch
.text$mn:0000374B                 mov     ecx, [ebp+arg_C]
.text$mn:0000374E                 push    ecx             ; unsigned int
.text$mn:0000374F                 mov     edx, [ebp+arg_8]
.text$mn:00003752                 push    edx             ; wchar_t *
.text$mn:00003753                 mov     eax, [ebp+arg_4]
.text$mn:00003756                 push    eax             ; int
.text$mn:00003757                 call    ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z ; std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:0000375C                 add     esp, 0Ch
.text$mn:0000375F                 mov     ecx, [ebp+arg_4]
.text$mn:00003762                 cmp     ecx, [ebp+arg_0]
.text$mn:00003765                 jnb     short loc_377C
.text$mn:00003767                 mov     edx, [ebp+arg_C]
.text$mn:0000376A                 push    edx             ; unsigned int
.text$mn:0000376B                 mov     eax, [ebp+arg_8]
.text$mn:0000376E                 push    eax             ; wchar_t *
.text$mn:0000376F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00003774                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003779                 add     esp, 0Ch
.text$mn:0000377C
.text$mn:0000377C loc_377C:                               ; CODE XREF: std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:0000377C                                         ; std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:0000377C                 pop     ebp
.text$mn:0000377D                 retn
.text$mn:0000377D ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:0000377D
.text$mn:0000377D ; ---------------------------------------------------------------------------
.text$mn:0000377E                 align 10h
.text$mn:0000377E _text$mn        ends
.text$mn:0000377E
.text$mn:00003780 ; ===========================================================================
.text$mn:00003780
.text$mn:00003780 ; Segment type: Pure code
.text$mn:00003780 ; Segment permissions: Read/Execute
.text$mn:00003780 _text$mn        segment para public 'CODE' use32
.text$mn:00003780                 assume cs:_text$mn
.text$mn:00003780                 ;org 3780h
.text$mn:00003780 ; COMDAT (pick any)
.text$mn:00003780                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003780
.text$mn:00003780 ; =============== S U B R O U T I N E =======================================
.text$mn:00003780
.text$mn:00003780 ; Attributes: bp-based frame
.text$mn:00003780
.text$mn:00003780 ; int __cdecl std::_Debug_range2<PluginCmdShortcut *>(int, int, wchar_t *, unsigned int)
.text$mn:00003780                 public ??$_Debug_range2@PAVPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00003780 ??$_Debug_range2@PAVPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00003780                                         ; CODE XREF: std::_Debug_range<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,wchar_t const *,uint)+2Ap
.text$mn:00003780
.text$mn:00003780 arg_0           = dword ptr  8
.text$mn:00003780 arg_4           = dword ptr  0Ch
.text$mn:00003780 arg_8           = dword ptr  10h
.text$mn:00003780 arg_C           = dword ptr  14h
.text$mn:00003780
.text$mn:00003780                 push    ebp
.text$mn:00003781                 mov     ebp, esp
.text$mn:00003783                 mov     eax, [ebp+arg_0]
.text$mn:00003786                 cmp     eax, [ebp+arg_4]
.text$mn:00003789                 jz      short loc_37D0
.text$mn:0000378B                 mov     ecx, [ebp+arg_C]
.text$mn:0000378E                 push    ecx             ; unsigned int
.text$mn:0000378F                 mov     edx, [ebp+arg_8]
.text$mn:00003792                 push    edx             ; wchar_t *
.text$mn:00003793                 mov     eax, [ebp+arg_0]
.text$mn:00003796                 push    eax             ; int
.text$mn:00003797                 call    ??$_Debug_pointer@VPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@PB_WI@Z ; std::_Debug_pointer<PluginCmdShortcut>(PluginCmdShortcut *,wchar_t const *,uint)
.text$mn:0000379C                 add     esp, 0Ch
.text$mn:0000379F                 mov     ecx, [ebp+arg_C]
.text$mn:000037A2                 push    ecx             ; unsigned int
.text$mn:000037A3                 mov     edx, [ebp+arg_8]
.text$mn:000037A6                 push    edx             ; wchar_t *
.text$mn:000037A7                 mov     eax, [ebp+arg_4]
.text$mn:000037AA                 push    eax             ; int
.text$mn:000037AB                 call    ??$_Debug_pointer@VPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@PB_WI@Z ; std::_Debug_pointer<PluginCmdShortcut>(PluginCmdShortcut *,wchar_t const *,uint)
.text$mn:000037B0                 add     esp, 0Ch
.text$mn:000037B3                 mov     ecx, [ebp+arg_4]
.text$mn:000037B6                 cmp     ecx, [ebp+arg_0]
.text$mn:000037B9                 jnb     short loc_37D0
.text$mn:000037BB                 mov     edx, [ebp+arg_C]
.text$mn:000037BE                 push    edx             ; unsigned int
.text$mn:000037BF                 mov     eax, [ebp+arg_8]
.text$mn:000037C2                 push    eax             ; wchar_t *
.text$mn:000037C3                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000037C8                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000037CD                 add     esp, 0Ch
.text$mn:000037D0
.text$mn:000037D0 loc_37D0:                               ; CODE XREF: std::_Debug_range2<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000037D0                                         ; std::_Debug_range2<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000037D0                 pop     ebp
.text$mn:000037D1                 retn
.text$mn:000037D1 ??$_Debug_range2@PAVPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000037D1
.text$mn:000037D1 ; ---------------------------------------------------------------------------
.text$mn:000037D2                 align 4
.text$mn:000037D2 _text$mn        ends
.text$mn:000037D2
.text$mn:000037D4 ; ===========================================================================
.text$mn:000037D4
.text$mn:000037D4 ; Segment type: Pure code
.text$mn:000037D4 ; Segment permissions: Read/Execute
.text$mn:000037D4 _text$mn        segment para public 'CODE' use32
.text$mn:000037D4                 assume cs:_text$mn
.text$mn:000037D4                 ;org 37D4h
.text$mn:000037D4 ; COMDAT (pick any)
.text$mn:000037D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037D4
.text$mn:000037D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000037D4
.text$mn:000037D4 ; Attributes: bp-based frame
.text$mn:000037D4
.text$mn:000037D4 ; int __cdecl std::_Debug_range<PluginInfo * *>(int, int, wchar_t *, unsigned int)
.text$mn:000037D4                 public ??$_Debug_range@PAPAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@0PB_WI@Z
.text$mn:000037D4 ??$_Debug_range@PAPAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@0PB_WI@Z proc near
.text$mn:000037D4                                         ; CODE XREF: std::_Uninit_move<PluginInfo *,PluginInfo *,PluginInfo *>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &,PluginInfo * *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000037D4
.text$mn:000037D4 var_1           = byte ptr -1
.text$mn:000037D4 arg_0           = dword ptr  8
.text$mn:000037D4 arg_4           = dword ptr  0Ch
.text$mn:000037D4 arg_8           = dword ptr  10h
.text$mn:000037D4 arg_C           = dword ptr  14h
.text$mn:000037D4
.text$mn:000037D4                 push    ebp
.text$mn:000037D5                 mov     ebp, esp
.text$mn:000037D7                 push    ecx
.text$mn:000037D8                 lea     eax, [ebp+arg_0]
.text$mn:000037DB                 push    eax
.text$mn:000037DC                 lea     ecx, [ebp+var_1]
.text$mn:000037DF                 push    ecx
.text$mn:000037E0                 call    ??$_Iter_cat@PAPAUPluginInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUPluginInfo@@@Z ; std::_Iter_cat<PluginInfo * *>(PluginInfo * * const &)
.text$mn:000037E5                 add     esp, 8
.text$mn:000037E8                 mov     dl, [eax]
.text$mn:000037EA                 movzx   eax, dl
.text$mn:000037ED                 push    eax
.text$mn:000037EE                 mov     ecx, [ebp+arg_C]
.text$mn:000037F1                 push    ecx             ; unsigned int
.text$mn:000037F2                 mov     edx, [ebp+arg_8]
.text$mn:000037F5                 push    edx             ; wchar_t *
.text$mn:000037F6                 mov     eax, [ebp+arg_4]
.text$mn:000037F9                 push    eax             ; int
.text$mn:000037FA                 mov     ecx, [ebp+arg_0]
.text$mn:000037FD                 push    ecx             ; int
.text$mn:000037FE                 call    ??$_Debug_range2@PAPAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<PluginInfo * *>(PluginInfo * *,PluginInfo * *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00003803                 add     esp, 14h
.text$mn:00003806                 mov     esp, ebp
.text$mn:00003808                 pop     ebp
.text$mn:00003809                 retn
.text$mn:00003809 ??$_Debug_range@PAPAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@0PB_WI@Z endp
.text$mn:00003809
.text$mn:00003809 ; ---------------------------------------------------------------------------
.text$mn:0000380A                 align 4
.text$mn:0000380A _text$mn        ends
.text$mn:0000380A
.text$mn:0000380C ; ===========================================================================
.text$mn:0000380C
.text$mn:0000380C ; Segment type: Pure code
.text$mn:0000380C ; Segment permissions: Read/Execute
.text$mn:0000380C _text$mn        segment para public 'CODE' use32
.text$mn:0000380C                 assume cs:_text$mn
.text$mn:0000380C                 ;org 380Ch
.text$mn:0000380C ; COMDAT (pick any)
.text$mn:0000380C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000380C
.text$mn:0000380C ; =============== S U B R O U T I N E =======================================
.text$mn:0000380C
.text$mn:0000380C ; Attributes: bp-based frame
.text$mn:0000380C
.text$mn:0000380C ; int __cdecl std::_Debug_range<TiXmlDocument * *>(int, int, wchar_t *, unsigned int)
.text$mn:0000380C                 public ??$_Debug_range@PAPAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@0PB_WI@Z
.text$mn:0000380C ??$_Debug_range@PAPAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@0PB_WI@Z proc near
.text$mn:0000380C                                         ; CODE XREF: std::_Uninit_move<TiXmlDocument *,TiXmlDocument *,TiXmlDocument *>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &,TiXmlDocument * *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:0000380C
.text$mn:0000380C var_1           = byte ptr -1
.text$mn:0000380C arg_0           = dword ptr  8
.text$mn:0000380C arg_4           = dword ptr  0Ch
.text$mn:0000380C arg_8           = dword ptr  10h
.text$mn:0000380C arg_C           = dword ptr  14h
.text$mn:0000380C
.text$mn:0000380C                 push    ebp
.text$mn:0000380D                 mov     ebp, esp
.text$mn:0000380F                 push    ecx
.text$mn:00003810                 lea     eax, [ebp+arg_0]
.text$mn:00003813                 push    eax
.text$mn:00003814                 lea     ecx, [ebp+var_1]
.text$mn:00003817                 push    ecx
.text$mn:00003818                 call    ??$_Iter_cat@PAPAVTiXmlDocument@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTiXmlDocument@@@Z ; std::_Iter_cat<TiXmlDocument * *>(TiXmlDocument * * const &)
.text$mn:0000381D                 add     esp, 8
.text$mn:00003820                 mov     dl, [eax]
.text$mn:00003822                 movzx   eax, dl
.text$mn:00003825                 push    eax
.text$mn:00003826                 mov     ecx, [ebp+arg_C]
.text$mn:00003829                 push    ecx             ; unsigned int
.text$mn:0000382A                 mov     edx, [ebp+arg_8]
.text$mn:0000382D                 push    edx             ; wchar_t *
.text$mn:0000382E                 mov     eax, [ebp+arg_4]
.text$mn:00003831                 push    eax             ; int
.text$mn:00003832                 mov     ecx, [ebp+arg_0]
.text$mn:00003835                 push    ecx             ; int
.text$mn:00003836                 call    ??$_Debug_range2@PAPAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000383B                 add     esp, 14h
.text$mn:0000383E                 mov     esp, ebp
.text$mn:00003840                 pop     ebp
.text$mn:00003841                 retn
.text$mn:00003841 ??$_Debug_range@PAPAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@0PB_WI@Z endp
.text$mn:00003841
.text$mn:00003841 ; ---------------------------------------------------------------------------
.text$mn:00003842                 align 4
.text$mn:00003842 _text$mn        ends
.text$mn:00003842
.text$mn:00003844 ; ===========================================================================
.text$mn:00003844
.text$mn:00003844 ; Segment type: Pure code
.text$mn:00003844 ; Segment permissions: Read/Execute
.text$mn:00003844 _text$mn        segment para public 'CODE' use32
.text$mn:00003844                 assume cs:_text$mn
.text$mn:00003844                 ;org 3844h
.text$mn:00003844 ; COMDAT (pick any)
.text$mn:00003844                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003844
.text$mn:00003844 ; =============== S U B R O U T I N E =======================================
.text$mn:00003844
.text$mn:00003844 ; Attributes: bp-based frame
.text$mn:00003844
.text$mn:00003844 ; int __cdecl std::_Debug_range<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(int, int, wchar_t *, unsigned int)
.text$mn:00003844                 public ??$_Debug_range@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0PB_WI@Z
.text$mn:00003844 ??$_Debug_range@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0PB_WI@Z proc near
.text$mn:00003844                                         ; CODE XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00003844
.text$mn:00003844 var_1           = byte ptr -1
.text$mn:00003844 arg_0           = dword ptr  8
.text$mn:00003844 arg_4           = dword ptr  0Ch
.text$mn:00003844 arg_8           = dword ptr  10h
.text$mn:00003844 arg_C           = dword ptr  14h
.text$mn:00003844
.text$mn:00003844                 push    ebp
.text$mn:00003845                 mov     ebp, esp
.text$mn:00003847                 push    ecx
.text$mn:00003848                 lea     eax, [ebp+arg_0]
.text$mn:0000384B                 push    eax
.text$mn:0000384C                 lea     ecx, [ebp+var_1]
.text$mn:0000384F                 push    ecx
.text$mn:00003850                 call    ??$_Iter_cat@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@@Z ; std::_Iter_cat<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> * const &)
.text$mn:00003855                 add     esp, 8
.text$mn:00003858                 mov     dl, [eax]
.text$mn:0000385A                 movzx   eax, dl
.text$mn:0000385D                 push    eax
.text$mn:0000385E                 mov     ecx, [ebp+arg_C]
.text$mn:00003861                 push    ecx             ; unsigned int
.text$mn:00003862                 mov     edx, [ebp+arg_8]
.text$mn:00003865                 push    edx             ; wchar_t *
.text$mn:00003866                 mov     eax, [ebp+arg_4]
.text$mn:00003869                 push    eax             ; int
.text$mn:0000386A                 mov     ecx, [ebp+arg_0]
.text$mn:0000386D                 push    ecx             ; int
.text$mn:0000386E                 call    ??$_Debug_range2@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00003873                 add     esp, 14h
.text$mn:00003876                 mov     esp, ebp
.text$mn:00003878                 pop     ebp
.text$mn:00003879                 retn
.text$mn:00003879 ??$_Debug_range@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0PB_WI@Z endp
.text$mn:00003879
.text$mn:00003879 ; ---------------------------------------------------------------------------
.text$mn:0000387A                 align 4
.text$mn:0000387A _text$mn        ends
.text$mn:0000387A
.text$mn:0000387C ; ===========================================================================
.text$mn:0000387C
.text$mn:0000387C ; Segment type: Pure code
.text$mn:0000387C ; Segment permissions: Read/Execute
.text$mn:0000387C _text$mn        segment para public 'CODE' use32
.text$mn:0000387C                 assume cs:_text$mn
.text$mn:0000387C                 ;org 387Ch
.text$mn:0000387C ; COMDAT (pick any)
.text$mn:0000387C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000387C
.text$mn:0000387C ; =============== S U B R O U T I N E =======================================
.text$mn:0000387C
.text$mn:0000387C ; Attributes: bp-based frame
.text$mn:0000387C
.text$mn:0000387C ; int __cdecl std::_Debug_range<PluginCommand *>(int, int, wchar_t *, unsigned int)
.text$mn:0000387C                 public ??$_Debug_range@PAUPluginCommand@@@std@@YAXPAUPluginCommand@@0PB_WI@Z
.text$mn:0000387C ??$_Debug_range@PAUPluginCommand@@@std@@YAXPAUPluginCommand@@0PB_WI@Z proc near
.text$mn:0000387C                                         ; CODE XREF: std::_Uninit_move<PluginCommand *,PluginCommand *,std::allocator<PluginCommand>,PluginCommand>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,PluginCommand *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:0000387C
.text$mn:0000387C var_1           = byte ptr -1
.text$mn:0000387C arg_0           = dword ptr  8
.text$mn:0000387C arg_4           = dword ptr  0Ch
.text$mn:0000387C arg_8           = dword ptr  10h
.text$mn:0000387C arg_C           = dword ptr  14h
.text$mn:0000387C
.text$mn:0000387C                 push    ebp
.text$mn:0000387D                 mov     ebp, esp
.text$mn:0000387F                 push    ecx
.text$mn:00003880                 lea     eax, [ebp+arg_0]
.text$mn:00003883                 push    eax
.text$mn:00003884                 lea     ecx, [ebp+var_1]
.text$mn:00003887                 push    ecx
.text$mn:00003888                 call    ??$_Iter_cat@PAUPluginCommand@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPluginCommand@@@Z ; std::_Iter_cat<PluginCommand *>(PluginCommand * const &)
.text$mn:0000388D                 add     esp, 8
.text$mn:00003890                 mov     dl, [eax]
.text$mn:00003892                 movzx   eax, dl
.text$mn:00003895                 push    eax
.text$mn:00003896                 mov     ecx, [ebp+arg_C]
.text$mn:00003899                 push    ecx             ; unsigned int
.text$mn:0000389A                 mov     edx, [ebp+arg_8]
.text$mn:0000389D                 push    edx             ; wchar_t *
.text$mn:0000389E                 mov     eax, [ebp+arg_4]
.text$mn:000038A1                 push    eax             ; int
.text$mn:000038A2                 mov     ecx, [ebp+arg_0]
.text$mn:000038A5                 push    ecx             ; int
.text$mn:000038A6                 call    ??$_Debug_range2@PAUPluginCommand@@@std@@YAXPAUPluginCommand@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<PluginCommand *>(PluginCommand *,PluginCommand *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000038AB                 add     esp, 14h
.text$mn:000038AE                 mov     esp, ebp
.text$mn:000038B0                 pop     ebp
.text$mn:000038B1                 retn
.text$mn:000038B1 ??$_Debug_range@PAUPluginCommand@@@std@@YAXPAUPluginCommand@@0PB_WI@Z endp
.text$mn:000038B1
.text$mn:000038B1 ; ---------------------------------------------------------------------------
.text$mn:000038B2                 align 4
.text$mn:000038B2 _text$mn        ends
.text$mn:000038B2
.text$mn:000038B4 ; ===========================================================================
.text$mn:000038B4
.text$mn:000038B4 ; Segment type: Pure code
.text$mn:000038B4 ; Segment permissions: Read/Execute
.text$mn:000038B4 _text$mn        segment para public 'CODE' use32
.text$mn:000038B4                 assume cs:_text$mn
.text$mn:000038B4                 ;org 38B4h
.text$mn:000038B4 ; COMDAT (pick any)
.text$mn:000038B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038B4
.text$mn:000038B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000038B4
.text$mn:000038B4 ; Attributes: bp-based frame
.text$mn:000038B4
.text$mn:000038B4 ; int __cdecl std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(int, int, wchar_t *, unsigned int)
.text$mn:000038B4                 public ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z
.text$mn:000038B4 ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z proc near
.text$mn:000038B4                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:000038B4
.text$mn:000038B4 var_1           = byte ptr -1
.text$mn:000038B4 arg_0           = dword ptr  8
.text$mn:000038B4 arg_4           = dword ptr  0Ch
.text$mn:000038B4 arg_8           = dword ptr  10h
.text$mn:000038B4 arg_C           = dword ptr  14h
.text$mn:000038B4
.text$mn:000038B4                 push    ebp
.text$mn:000038B5                 mov     ebp, esp
.text$mn:000038B7                 push    ecx
.text$mn:000038B8                 lea     eax, [ebp+arg_0]
.text$mn:000038BB                 push    eax
.text$mn:000038BC                 lea     ecx, [ebp+var_1]
.text$mn:000038BF                 push    ecx
.text$mn:000038C0                 call    ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::_Iter_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> * const &)
.text$mn:000038C5                 add     esp, 8
.text$mn:000038C8                 mov     dl, [eax]
.text$mn:000038CA                 movzx   eax, dl
.text$mn:000038CD                 push    eax
.text$mn:000038CE                 mov     ecx, [ebp+arg_C]
.text$mn:000038D1                 push    ecx             ; unsigned int
.text$mn:000038D2                 mov     edx, [ebp+arg_8]
.text$mn:000038D5                 push    edx             ; wchar_t *
.text$mn:000038D6                 mov     eax, [ebp+arg_4]
.text$mn:000038D9                 push    eax             ; int
.text$mn:000038DA                 mov     ecx, [ebp+arg_0]
.text$mn:000038DD                 push    ecx             ; int
.text$mn:000038DE                 call    ??$_Debug_range2@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000038E3                 add     esp, 14h
.text$mn:000038E6                 mov     esp, ebp
.text$mn:000038E8                 pop     ebp
.text$mn:000038E9                 retn
.text$mn:000038E9 ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z endp
.text$mn:000038E9
.text$mn:000038E9 ; ---------------------------------------------------------------------------
.text$mn:000038EA                 align 4
.text$mn:000038EA _text$mn        ends
.text$mn:000038EA
.text$mn:000038EC ; ===========================================================================
.text$mn:000038EC
.text$mn:000038EC ; Segment type: Pure code
.text$mn:000038EC ; Segment permissions: Read/Execute
.text$mn:000038EC _text$mn        segment para public 'CODE' use32
.text$mn:000038EC                 assume cs:_text$mn
.text$mn:000038EC                 ;org 38ECh
.text$mn:000038EC ; COMDAT (pick any)
.text$mn:000038EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038EC
.text$mn:000038EC ; =============== S U B R O U T I N E =======================================
.text$mn:000038EC
.text$mn:000038EC ; Attributes: bp-based frame
.text$mn:000038EC
.text$mn:000038EC ; int __cdecl std::_Debug_range<PluginCmdShortcut *>(int, int, wchar_t *, unsigned int)
.text$mn:000038EC                 public ??$_Debug_range@PAVPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@0PB_WI@Z
.text$mn:000038EC ??$_Debug_range@PAVPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@0PB_WI@Z proc near
.text$mn:000038EC                                         ; CODE XREF: std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::allocator<PluginCmdShortcut>,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,PluginCmdShortcut *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:000038EC
.text$mn:000038EC var_1           = byte ptr -1
.text$mn:000038EC arg_0           = dword ptr  8
.text$mn:000038EC arg_4           = dword ptr  0Ch
.text$mn:000038EC arg_8           = dword ptr  10h
.text$mn:000038EC arg_C           = dword ptr  14h
.text$mn:000038EC
.text$mn:000038EC                 push    ebp
.text$mn:000038ED                 mov     ebp, esp
.text$mn:000038EF                 push    ecx
.text$mn:000038F0                 lea     eax, [ebp+arg_0]
.text$mn:000038F3                 push    eax
.text$mn:000038F4                 lea     ecx, [ebp+var_1]
.text$mn:000038F7                 push    ecx
.text$mn:000038F8                 call    ??$_Iter_cat@PAVPluginCmdShortcut@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPluginCmdShortcut@@@Z ; std::_Iter_cat<PluginCmdShortcut *>(PluginCmdShortcut * const &)
.text$mn:000038FD                 add     esp, 8
.text$mn:00003900                 mov     dl, [eax]
.text$mn:00003902                 movzx   eax, dl
.text$mn:00003905                 push    eax
.text$mn:00003906                 mov     ecx, [ebp+arg_C]
.text$mn:00003909                 push    ecx             ; unsigned int
.text$mn:0000390A                 mov     edx, [ebp+arg_8]
.text$mn:0000390D                 push    edx             ; wchar_t *
.text$mn:0000390E                 mov     eax, [ebp+arg_4]
.text$mn:00003911                 push    eax             ; int
.text$mn:00003912                 mov     ecx, [ebp+arg_0]
.text$mn:00003915                 push    ecx             ; int
.text$mn:00003916                 call    ??$_Debug_range2@PAVPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000391B                 add     esp, 14h
.text$mn:0000391E                 mov     esp, ebp
.text$mn:00003920                 pop     ebp
.text$mn:00003921                 retn
.text$mn:00003921 ??$_Debug_range@PAVPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@0PB_WI@Z endp
.text$mn:00003921
.text$mn:00003921 ; ---------------------------------------------------------------------------
.text$mn:00003922                 align 4
.text$mn:00003922 _text$mn        ends
.text$mn:00003922
.text$mn:00003924 ; ===========================================================================
.text$mn:00003924
.text$mn:00003924 ; Segment type: Pure code
.text$mn:00003924 ; Segment permissions: Read/Execute
.text$mn:00003924 _text$mn        segment para public 'CODE' use32
.text$mn:00003924                 assume cs:_text$mn
.text$mn:00003924                 ;org 3924h
.text$mn:00003924 ; COMDAT (pick any)
.text$mn:00003924                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003924
.text$mn:00003924 ; =============== S U B R O U T I N E =======================================
.text$mn:00003924
.text$mn:00003924 ; Attributes: bp-based frame
.text$mn:00003924
.text$mn:00003924 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct PluginInfo *>>>(struct PluginInfo * *, struct PluginInfo * *, struct std::_Wrap_alloc<class std::allocator<struct PluginInfo *>> &)
.text$mn:00003924                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAXPAPAUPluginInfo@@0AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z
.text$mn:00003924 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAXPAPAUPluginInfo@@0AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z proc near
.text$mn:00003924                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Destroy(PluginInfo * *,PluginInfo * *)+21p
.text$mn:00003924
.text$mn:00003924 var_1           = byte ptr -1
.text$mn:00003924 arg_0           = dword ptr  8
.text$mn:00003924 arg_4           = dword ptr  0Ch
.text$mn:00003924 arg_8           = dword ptr  10h
.text$mn:00003924
.text$mn:00003924                 push    ebp
.text$mn:00003925                 mov     ebp, esp
.text$mn:00003927                 push    ecx
.text$mn:00003928                 mov     eax, [ebp+arg_4]
.text$mn:0000392B                 push    eax
.text$mn:0000392C                 mov     ecx, [ebp+arg_0]
.text$mn:0000392F                 push    ecx
.text$mn:00003930                 call    ??$_Ptr_cat@PAUPluginInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUPluginInfo@@0@Z ; std::_Ptr_cat<PluginInfo *,PluginInfo *>(PluginInfo * *,PluginInfo * *)
.text$mn:00003935                 add     esp, 8
.text$mn:00003938                 mov     [ebp+var_1], al
.text$mn:0000393B                 movzx   edx, [ebp+var_1]
.text$mn:0000393F                 push    edx
.text$mn:00003940                 mov     eax, [ebp+arg_8]
.text$mn:00003943                 push    eax
.text$mn:00003944                 mov     ecx, [ebp+arg_4]
.text$mn:00003947                 push    ecx
.text$mn:00003948                 mov     edx, [ebp+arg_0]
.text$mn:0000394B                 push    edx
.text$mn:0000394C                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAXPAPAUPluginInfo@@0AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00003951                 add     esp, 10h
.text$mn:00003954                 mov     esp, ebp
.text$mn:00003956                 pop     ebp
.text$mn:00003957                 retn
.text$mn:00003957 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAXPAPAUPluginInfo@@0AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z endp
.text$mn:00003957
.text$mn:00003957 _text$mn        ends
.text$mn:00003957
.text$mn:00003958 ; ===========================================================================
.text$mn:00003958
.text$mn:00003958 ; Segment type: Pure code
.text$mn:00003958 ; Segment permissions: Read/Execute
.text$mn:00003958 _text$mn        segment para public 'CODE' use32
.text$mn:00003958                 assume cs:_text$mn
.text$mn:00003958                 ;org 3958h
.text$mn:00003958 ; COMDAT (pick any)
.text$mn:00003958                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003958
.text$mn:00003958 ; =============== S U B R O U T I N E =======================================
.text$mn:00003958
.text$mn:00003958 ; Attributes: bp-based frame
.text$mn:00003958
.text$mn:00003958 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct PluginInfo *>>>(struct PluginInfo * *, struct PluginInfo * *, struct std::_Wrap_alloc<class std::allocator<struct PluginInfo *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00003958                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAXPAPAUPluginInfo@@0AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00003958 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAXPAPAUPluginInfo@@0AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003958                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)+28p
.text$mn:00003958                 push    ebp
.text$mn:00003959                 mov     ebp, esp
.text$mn:0000395B                 pop     ebp
.text$mn:0000395C                 retn
.text$mn:0000395C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAXPAPAUPluginInfo@@0AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000395C
.text$mn:0000395C ; ---------------------------------------------------------------------------
.text$mn:0000395D                 align 10h
.text$mn:0000395D _text$mn        ends
.text$mn:0000395D
.text$mn:00003960 ; ===========================================================================
.text$mn:00003960
.text$mn:00003960 ; Segment type: Pure code
.text$mn:00003960 ; Segment permissions: Read/Execute
.text$mn:00003960 _text$mn        segment para public 'CODE' use32
.text$mn:00003960                 assume cs:_text$mn
.text$mn:00003960                 ;org 3960h
.text$mn:00003960 ; COMDAT (pick any)
.text$mn:00003960                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003960
.text$mn:00003960 ; =============== S U B R O U T I N E =======================================
.text$mn:00003960
.text$mn:00003960 ; Attributes: bp-based frame
.text$mn:00003960
.text$mn:00003960 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class TiXmlDocument *>>>(class TiXmlDocument * *, class TiXmlDocument * *, struct std::_Wrap_alloc<class std::allocator<class TiXmlDocument *>> &)
.text$mn:00003960                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAXPAPAVTiXmlDocument@@0AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z
.text$mn:00003960 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAXPAPAVTiXmlDocument@@0AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z proc near
.text$mn:00003960                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Destroy(TiXmlDocument * *,TiXmlDocument * *)+21p
.text$mn:00003960
.text$mn:00003960 var_1           = byte ptr -1
.text$mn:00003960 arg_0           = dword ptr  8
.text$mn:00003960 arg_4           = dword ptr  0Ch
.text$mn:00003960 arg_8           = dword ptr  10h
.text$mn:00003960
.text$mn:00003960                 push    ebp
.text$mn:00003961                 mov     ebp, esp
.text$mn:00003963                 push    ecx
.text$mn:00003964                 mov     eax, [ebp+arg_4]
.text$mn:00003967                 push    eax
.text$mn:00003968                 mov     ecx, [ebp+arg_0]
.text$mn:0000396B                 push    ecx
.text$mn:0000396C                 call    ??$_Ptr_cat@PAVTiXmlDocument@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVTiXmlDocument@@0@Z ; std::_Ptr_cat<TiXmlDocument *,TiXmlDocument *>(TiXmlDocument * *,TiXmlDocument * *)
.text$mn:00003971                 add     esp, 8
.text$mn:00003974                 mov     [ebp+var_1], al
.text$mn:00003977                 movzx   edx, [ebp+var_1]
.text$mn:0000397B                 push    edx
.text$mn:0000397C                 mov     eax, [ebp+arg_8]
.text$mn:0000397F                 push    eax
.text$mn:00003980                 mov     ecx, [ebp+arg_4]
.text$mn:00003983                 push    ecx
.text$mn:00003984                 mov     edx, [ebp+arg_0]
.text$mn:00003987                 push    edx
.text$mn:00003988                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAXPAPAVTiXmlDocument@@0AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:0000398D                 add     esp, 10h
.text$mn:00003990                 mov     esp, ebp
.text$mn:00003992                 pop     ebp
.text$mn:00003993                 retn
.text$mn:00003993 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAXPAPAVTiXmlDocument@@0AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z endp
.text$mn:00003993
.text$mn:00003993 _text$mn        ends
.text$mn:00003993
.text$mn:00003994 ; ===========================================================================
.text$mn:00003994
.text$mn:00003994 ; Segment type: Pure code
.text$mn:00003994 ; Segment permissions: Read/Execute
.text$mn:00003994 _text$mn        segment para public 'CODE' use32
.text$mn:00003994                 assume cs:_text$mn
.text$mn:00003994                 ;org 3994h
.text$mn:00003994 ; COMDAT (pick any)
.text$mn:00003994                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003994
.text$mn:00003994 ; =============== S U B R O U T I N E =======================================
.text$mn:00003994
.text$mn:00003994 ; Attributes: bp-based frame
.text$mn:00003994
.text$mn:00003994 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class TiXmlDocument *>>>(class TiXmlDocument * *, class TiXmlDocument * *, struct std::_Wrap_alloc<class std::allocator<class TiXmlDocument *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00003994                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAXPAPAVTiXmlDocument@@0AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00003994 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAXPAPAVTiXmlDocument@@0AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003994                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)+28p
.text$mn:00003994                 push    ebp
.text$mn:00003995                 mov     ebp, esp
.text$mn:00003997                 pop     ebp
.text$mn:00003998                 retn
.text$mn:00003998 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAXPAPAVTiXmlDocument@@0AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003998
.text$mn:00003998 ; ---------------------------------------------------------------------------
.text$mn:00003999                 align 4
.text$mn:00003999 _text$mn        ends
.text$mn:00003999
.text$mn:0000399C ; ===========================================================================
.text$mn:0000399C
.text$mn:0000399C ; Segment type: Pure code
.text$mn:0000399C ; Segment permissions: Read/Execute
.text$mn:0000399C _text$mn        segment para public 'CODE' use32
.text$mn:0000399C                 assume cs:_text$mn
.text$mn:0000399C                 ;org 399Ch
.text$mn:0000399C ; COMDAT (pick any)
.text$mn:0000399C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000399C
.text$mn:0000399C ; =============== S U B R O U T I N E =======================================
.text$mn:0000399C
.text$mn:0000399C ; Attributes: bp-based frame
.text$mn:0000399C
.text$mn:0000399C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>> &)
.text$mn:0000399C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z
.text$mn:0000399C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z proc near
.text$mn:0000399C                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Destroy(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+21p
.text$mn:0000399C
.text$mn:0000399C var_1           = byte ptr -1
.text$mn:0000399C arg_0           = dword ptr  8
.text$mn:0000399C arg_4           = dword ptr  0Ch
.text$mn:0000399C arg_8           = dword ptr  10h
.text$mn:0000399C
.text$mn:0000399C                 push    ebp
.text$mn:0000399D                 mov     ebp, esp
.text$mn:0000399F                 push    ecx
.text$mn:000039A0                 mov     eax, [ebp+arg_4]
.text$mn:000039A3                 push    eax
.text$mn:000039A4                 mov     ecx, [ebp+arg_0]
.text$mn:000039A7                 push    ecx
.text$mn:000039A8                 call    ??$_Ptr_cat@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0@Z ; std::_Ptr_cat<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:000039AD                 add     esp, 8
.text$mn:000039B0                 mov     [ebp+var_1], al
.text$mn:000039B3                 movzx   edx, [ebp+var_1]
.text$mn:000039B7                 push    edx
.text$mn:000039B8                 mov     eax, [ebp+arg_8]
.text$mn:000039BB                 push    eax
.text$mn:000039BC                 mov     ecx, [ebp+arg_4]
.text$mn:000039BF                 push    ecx
.text$mn:000039C0                 mov     edx, [ebp+arg_0]
.text$mn:000039C3                 push    edx
.text$mn:000039C4                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000039C9                 add     esp, 10h
.text$mn:000039CC                 mov     esp, ebp
.text$mn:000039CE                 pop     ebp
.text$mn:000039CF                 retn
.text$mn:000039CF ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z endp
.text$mn:000039CF
.text$mn:000039CF _text$mn        ends
.text$mn:000039CF
.text$mn:000039D0 ; ===========================================================================
.text$mn:000039D0
.text$mn:000039D0 ; Segment type: Pure code
.text$mn:000039D0 ; Segment permissions: Read/Execute
.text$mn:000039D0 _text$mn        segment para public 'CODE' use32
.text$mn:000039D0                 assume cs:_text$mn
.text$mn:000039D0                 ;org 39D0h
.text$mn:000039D0 ; COMDAT (pick any)
.text$mn:000039D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039D0
.text$mn:000039D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000039D0
.text$mn:000039D0 ; Attributes: bp-based frame
.text$mn:000039D0
.text$mn:000039D0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:000039D0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000039D0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000039D0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)+28p
.text$mn:000039D0
.text$mn:000039D0 arg_0           = dword ptr  8
.text$mn:000039D0 arg_4           = dword ptr  0Ch
.text$mn:000039D0 arg_8           = dword ptr  10h
.text$mn:000039D0
.text$mn:000039D0                 push    ebp
.text$mn:000039D1                 mov     ebp, esp
.text$mn:000039D3                 jmp     short loc_39DE
.text$mn:000039D5 ; ---------------------------------------------------------------------------
.text$mn:000039D5
.text$mn:000039D5 loc_39D5:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:000039D5                 mov     eax, [ebp+arg_0]
.text$mn:000039D8                 add     eax, 20h ; ' '
.text$mn:000039DB                 mov     [ebp+arg_0], eax
.text$mn:000039DE
.text$mn:000039DE loc_39DE:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:000039DE                 mov     ecx, [ebp+arg_0]
.text$mn:000039E1                 cmp     ecx, [ebp+arg_4]
.text$mn:000039E4                 jz      short loc_39F4
.text$mn:000039E6                 mov     edx, [ebp+arg_0]
.text$mn:000039E9                 push    edx
.text$mn:000039EA                 mov     ecx, [ebp+arg_8]
.text$mn:000039ED                 call    ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:000039F2                 jmp     short loc_39D5
.text$mn:000039F4 ; ---------------------------------------------------------------------------
.text$mn:000039F4
.text$mn:000039F4 loc_39F4:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:000039F4                 pop     ebp
.text$mn:000039F5                 retn
.text$mn:000039F5 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000039F5
.text$mn:000039F5 ; ---------------------------------------------------------------------------
.text$mn:000039F6                 align 4
.text$mn:000039F6 _text$mn        ends
.text$mn:000039F6
.text$mn:000039F8 ; ===========================================================================
.text$mn:000039F8
.text$mn:000039F8 ; Segment type: Pure code
.text$mn:000039F8 ; Segment permissions: Read/Execute
.text$mn:000039F8 _text$mn        segment para public 'CODE' use32
.text$mn:000039F8                 assume cs:_text$mn
.text$mn:000039F8                 ;org 39F8h
.text$mn:000039F8 ; COMDAT (pick any)
.text$mn:000039F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000039F8
.text$mn:000039F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000039F8
.text$mn:000039F8 ; Attributes: bp-based frame
.text$mn:000039F8
.text$mn:000039F8 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct PluginCommand>>>(struct PluginCommand *, struct PluginCommand *, struct std::_Wrap_alloc<class std::allocator<struct PluginCommand>> &)
.text$mn:000039F8                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAXPAUPluginCommand@@0AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z
.text$mn:000039F8 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAXPAUPluginCommand@@0AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z proc near
.text$mn:000039F8                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Destroy(PluginCommand *,PluginCommand *)+21p
.text$mn:000039F8
.text$mn:000039F8 var_1           = byte ptr -1
.text$mn:000039F8 arg_0           = dword ptr  8
.text$mn:000039F8 arg_4           = dword ptr  0Ch
.text$mn:000039F8 arg_8           = dword ptr  10h
.text$mn:000039F8
.text$mn:000039F8                 push    ebp
.text$mn:000039F9                 mov     ebp, esp
.text$mn:000039FB                 push    ecx
.text$mn:000039FC                 mov     eax, [ebp+arg_4]
.text$mn:000039FF                 push    eax
.text$mn:00003A00                 mov     ecx, [ebp+arg_0]
.text$mn:00003A03                 push    ecx
.text$mn:00003A04                 call    ??$_Ptr_cat@UPluginCommand@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPluginCommand@@0@Z ; std::_Ptr_cat<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand *)
.text$mn:00003A09                 add     esp, 8
.text$mn:00003A0C                 mov     [ebp+var_1], al
.text$mn:00003A0F                 movzx   edx, [ebp+var_1]
.text$mn:00003A13                 push    edx
.text$mn:00003A14                 mov     eax, [ebp+arg_8]
.text$mn:00003A17                 push    eax
.text$mn:00003A18                 mov     ecx, [ebp+arg_4]
.text$mn:00003A1B                 push    ecx
.text$mn:00003A1C                 mov     edx, [ebp+arg_0]
.text$mn:00003A1F                 push    edx
.text$mn:00003A20                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAXPAUPluginCommand@@0AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003A25                 add     esp, 10h
.text$mn:00003A28                 mov     esp, ebp
.text$mn:00003A2A                 pop     ebp
.text$mn:00003A2B                 retn
.text$mn:00003A2B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAXPAUPluginCommand@@0AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z endp
.text$mn:00003A2B
.text$mn:00003A2B _text$mn        ends
.text$mn:00003A2B
.text$mn:00003A2C ; ===========================================================================
.text$mn:00003A2C
.text$mn:00003A2C ; Segment type: Pure code
.text$mn:00003A2C ; Segment permissions: Read/Execute
.text$mn:00003A2C _text$mn        segment para public 'CODE' use32
.text$mn:00003A2C                 assume cs:_text$mn
.text$mn:00003A2C                 ;org 3A2Ch
.text$mn:00003A2C ; COMDAT (pick any)
.text$mn:00003A2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A2C
.text$mn:00003A2C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A2C
.text$mn:00003A2C ; Attributes: bp-based frame
.text$mn:00003A2C
.text$mn:00003A2C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct PluginCommand>>>(struct PluginCommand *, struct PluginCommand *, struct std::_Wrap_alloc<class std::allocator<struct PluginCommand>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003A2C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAXPAUPluginCommand@@0AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003A2C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAXPAUPluginCommand@@0AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003A2C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)+28p
.text$mn:00003A2C
.text$mn:00003A2C arg_0           = dword ptr  8
.text$mn:00003A2C arg_4           = dword ptr  0Ch
.text$mn:00003A2C arg_8           = dword ptr  10h
.text$mn:00003A2C
.text$mn:00003A2C                 push    ebp
.text$mn:00003A2D                 mov     ebp, esp
.text$mn:00003A2F                 jmp     short loc_3A3A
.text$mn:00003A31 ; ---------------------------------------------------------------------------
.text$mn:00003A31
.text$mn:00003A31 loc_3A31:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00003A31                 mov     eax, [ebp+arg_0]
.text$mn:00003A34                 add     eax, 24h ; '$'
.text$mn:00003A37                 mov     [ebp+arg_0], eax
.text$mn:00003A3A
.text$mn:00003A3A loc_3A3A:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00003A3A                 mov     ecx, [ebp+arg_0]
.text$mn:00003A3D                 cmp     ecx, [ebp+arg_4]
.text$mn:00003A40                 jz      short loc_3A50
.text$mn:00003A42                 mov     edx, [ebp+arg_0]
.text$mn:00003A45                 push    edx
.text$mn:00003A46                 mov     ecx, [ebp+arg_8]
.text$mn:00003A49                 call    ??$destroy@UPluginCommand@@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@@Z ; std::_Wrap_alloc<std::allocator<PluginCommand>>::destroy<PluginCommand>(PluginCommand *)
.text$mn:00003A4E                 jmp     short loc_3A31
.text$mn:00003A50 ; ---------------------------------------------------------------------------
.text$mn:00003A50
.text$mn:00003A50 loc_3A50:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00003A50                 pop     ebp
.text$mn:00003A51                 retn
.text$mn:00003A51 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAXPAUPluginCommand@@0AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003A51
.text$mn:00003A51 ; ---------------------------------------------------------------------------
.text$mn:00003A52                 align 4
.text$mn:00003A52 _text$mn        ends
.text$mn:00003A52
.text$mn:00003A54 ; ===========================================================================
.text$mn:00003A54
.text$mn:00003A54 ; Segment type: Pure code
.text$mn:00003A54 ; Segment permissions: Read/Execute
.text$mn:00003A54 _text$mn        segment para public 'CODE' use32
.text$mn:00003A54                 assume cs:_text$mn
.text$mn:00003A54                 ;org 3A54h
.text$mn:00003A54 ; COMDAT (pick any)
.text$mn:00003A54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A54
.text$mn:00003A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A54
.text$mn:00003A54 ; Attributes: bp-based frame
.text$mn:00003A54
.text$mn:00003A54 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &)
.text$mn:00003A54                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
.text$mn:00003A54 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z proc near
.text$mn:00003A54                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+21p
.text$mn:00003A54
.text$mn:00003A54 var_1           = byte ptr -1
.text$mn:00003A54 arg_0           = dword ptr  8
.text$mn:00003A54 arg_4           = dword ptr  0Ch
.text$mn:00003A54 arg_8           = dword ptr  10h
.text$mn:00003A54
.text$mn:00003A54                 push    ebp
.text$mn:00003A55                 mov     ebp, esp
.text$mn:00003A57                 push    ecx
.text$mn:00003A58                 mov     eax, [ebp+arg_4]
.text$mn:00003A5B                 push    eax
.text$mn:00003A5C                 mov     ecx, [ebp+arg_0]
.text$mn:00003A5F                 push    ecx
.text$mn:00003A60                 call    ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00003A65                 add     esp, 8
.text$mn:00003A68                 mov     [ebp+var_1], al
.text$mn:00003A6B                 movzx   edx, [ebp+var_1]
.text$mn:00003A6F                 push    edx
.text$mn:00003A70                 mov     eax, [ebp+arg_8]
.text$mn:00003A73                 push    eax
.text$mn:00003A74                 mov     ecx, [ebp+arg_4]
.text$mn:00003A77                 push    ecx
.text$mn:00003A78                 mov     edx, [ebp+arg_0]
.text$mn:00003A7B                 push    edx
.text$mn:00003A7C                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003A81                 add     esp, 10h
.text$mn:00003A84                 mov     esp, ebp
.text$mn:00003A86                 pop     ebp
.text$mn:00003A87                 retn
.text$mn:00003A87 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z endp
.text$mn:00003A87
.text$mn:00003A87 _text$mn        ends
.text$mn:00003A87
.text$mn:00003A88 ; ===========================================================================
.text$mn:00003A88
.text$mn:00003A88 ; Segment type: Pure code
.text$mn:00003A88 ; Segment permissions: Read/Execute
.text$mn:00003A88 _text$mn        segment para public 'CODE' use32
.text$mn:00003A88                 assume cs:_text$mn
.text$mn:00003A88                 ;org 3A88h
.text$mn:00003A88 ; COMDAT (pick any)
.text$mn:00003A88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A88
.text$mn:00003A88 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A88
.text$mn:00003A88 ; Attributes: bp-based frame
.text$mn:00003A88
.text$mn:00003A88 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003A88                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003A88 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003A88                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+28p
.text$mn:00003A88
.text$mn:00003A88 arg_0           = dword ptr  8
.text$mn:00003A88 arg_4           = dword ptr  0Ch
.text$mn:00003A88 arg_8           = dword ptr  10h
.text$mn:00003A88
.text$mn:00003A88                 push    ebp
.text$mn:00003A89                 mov     ebp, esp
.text$mn:00003A8B                 jmp     short loc_3A96
.text$mn:00003A8D ; ---------------------------------------------------------------------------
.text$mn:00003A8D
.text$mn:00003A8D loc_3A8D:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00003A8D                 mov     eax, [ebp+arg_0]
.text$mn:00003A90                 add     eax, 1Ch
.text$mn:00003A93                 mov     [ebp+arg_0], eax
.text$mn:00003A96
.text$mn:00003A96 loc_3A96:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00003A96                 mov     ecx, [ebp+arg_0]
.text$mn:00003A99                 cmp     ecx, [ebp+arg_4]
.text$mn:00003A9C                 jz      short loc_3AAC
.text$mn:00003A9E                 mov     edx, [ebp+arg_0]
.text$mn:00003AA1                 push    edx
.text$mn:00003AA2                 mov     ecx, [ebp+arg_8]
.text$mn:00003AA5                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00003AAA                 jmp     short loc_3A8D
.text$mn:00003AAC ; ---------------------------------------------------------------------------
.text$mn:00003AAC
.text$mn:00003AAC loc_3AAC:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00003AAC                 pop     ebp
.text$mn:00003AAD                 retn
.text$mn:00003AAD ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003AAD
.text$mn:00003AAD ; ---------------------------------------------------------------------------
.text$mn:00003AAE                 align 10h
.text$mn:00003AAE _text$mn        ends
.text$mn:00003AAE
.text$mn:00003AB0 ; ===========================================================================
.text$mn:00003AB0
.text$mn:00003AB0 ; Segment type: Pure code
.text$mn:00003AB0 ; Segment permissions: Read/Execute
.text$mn:00003AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00003AB0                 assume cs:_text$mn
.text$mn:00003AB0                 ;org 3AB0h
.text$mn:00003AB0 ; COMDAT (pick any)
.text$mn:00003AB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003AB0
.text$mn:00003AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AB0
.text$mn:00003AB0 ; Attributes: bp-based frame
.text$mn:00003AB0
.text$mn:00003AB0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>>>(class PluginCmdShortcut *, class PluginCmdShortcut *, struct std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>> &)
.text$mn:00003AB0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAXPAVPluginCmdShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z
.text$mn:00003AB0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAXPAVPluginCmdShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z proc near
.text$mn:00003AB0                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Destroy(PluginCmdShortcut *,PluginCmdShortcut *)+21p
.text$mn:00003AB0
.text$mn:00003AB0 var_1           = byte ptr -1
.text$mn:00003AB0 arg_0           = dword ptr  8
.text$mn:00003AB0 arg_4           = dword ptr  0Ch
.text$mn:00003AB0 arg_8           = dword ptr  10h
.text$mn:00003AB0
.text$mn:00003AB0                 push    ebp
.text$mn:00003AB1                 mov     ebp, esp
.text$mn:00003AB3                 push    ecx
.text$mn:00003AB4                 mov     eax, [ebp+arg_4]
.text$mn:00003AB7                 push    eax
.text$mn:00003AB8                 mov     ecx, [ebp+arg_0]
.text$mn:00003ABB                 push    ecx
.text$mn:00003ABC                 call    ??$_Ptr_cat@VPluginCmdShortcut@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPluginCmdShortcut@@0@Z ; std::_Ptr_cat<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *)
.text$mn:00003AC1                 add     esp, 8
.text$mn:00003AC4                 mov     [ebp+var_1], al
.text$mn:00003AC7                 movzx   edx, [ebp+var_1]
.text$mn:00003ACB                 push    edx
.text$mn:00003ACC                 mov     eax, [ebp+arg_8]
.text$mn:00003ACF                 push    eax
.text$mn:00003AD0                 mov     ecx, [ebp+arg_4]
.text$mn:00003AD3                 push    ecx
.text$mn:00003AD4                 mov     edx, [ebp+arg_0]
.text$mn:00003AD7                 push    edx
.text$mn:00003AD8                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAXPAVPluginCmdShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003ADD                 add     esp, 10h
.text$mn:00003AE0                 mov     esp, ebp
.text$mn:00003AE2                 pop     ebp
.text$mn:00003AE3                 retn
.text$mn:00003AE3 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAXPAVPluginCmdShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z endp
.text$mn:00003AE3
.text$mn:00003AE3 _text$mn        ends
.text$mn:00003AE3
.text$mn:00003AE4 ; ===========================================================================
.text$mn:00003AE4
.text$mn:00003AE4 ; Segment type: Pure code
.text$mn:00003AE4 ; Segment permissions: Read/Execute
.text$mn:00003AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00003AE4                 assume cs:_text$mn
.text$mn:00003AE4                 ;org 3AE4h
.text$mn:00003AE4 ; COMDAT (pick any)
.text$mn:00003AE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003AE4
.text$mn:00003AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AE4
.text$mn:00003AE4 ; Attributes: bp-based frame
.text$mn:00003AE4
.text$mn:00003AE4 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>>>(class PluginCmdShortcut *, class PluginCmdShortcut *, struct std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003AE4                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAXPAVPluginCmdShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003AE4 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAXPAVPluginCmdShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003AE4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)+28p
.text$mn:00003AE4
.text$mn:00003AE4 arg_0           = dword ptr  8
.text$mn:00003AE4 arg_4           = dword ptr  0Ch
.text$mn:00003AE4 arg_8           = dword ptr  10h
.text$mn:00003AE4
.text$mn:00003AE4                 push    ebp
.text$mn:00003AE5                 mov     ebp, esp
.text$mn:00003AE7                 jmp     short loc_3AF4
.text$mn:00003AE9 ; ---------------------------------------------------------------------------
.text$mn:00003AE9
.text$mn:00003AE9 loc_3AE9:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,std::_Nonscalar_ptr_iterator_tag)+24j
.text$mn:00003AE9                 mov     eax, [ebp+arg_0]
.text$mn:00003AEC                 add     eax, 150h
.text$mn:00003AF1                 mov     [ebp+arg_0], eax
.text$mn:00003AF4
.text$mn:00003AF4 loc_3AF4:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00003AF4                 mov     ecx, [ebp+arg_0]
.text$mn:00003AF7                 cmp     ecx, [ebp+arg_4]
.text$mn:00003AFA                 jz      short loc_3B0A
.text$mn:00003AFC                 mov     edx, [ebp+arg_0]
.text$mn:00003AFF                 push    edx
.text$mn:00003B00                 mov     ecx, [ebp+arg_8]
.text$mn:00003B03                 call    ??$destroy@VPluginCmdShortcut@@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@@Z ; std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::destroy<PluginCmdShortcut>(PluginCmdShortcut *)
.text$mn:00003B08                 jmp     short loc_3AE9
.text$mn:00003B0A ; ---------------------------------------------------------------------------
.text$mn:00003B0A
.text$mn:00003B0A loc_3B0A:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,std::_Nonscalar_ptr_iterator_tag)+16j
.text$mn:00003B0A                 pop     ebp
.text$mn:00003B0B                 retn
.text$mn:00003B0B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAXPAVPluginCmdShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003B0B
.text$mn:00003B0B _text$mn        ends
.text$mn:00003B0B
.text$mn:00003B0C ; ===========================================================================
.text$mn:00003B0C
.text$mn:00003B0C ; Segment type: Pure code
.text$mn:00003B0C ; Segment permissions: Read/Execute
.text$mn:00003B0C _text$mn        segment para public 'CODE' use32
.text$mn:00003B0C                 assume cs:_text$mn
.text$mn:00003B0C                 ;org 3B0Ch
.text$mn:00003B0C ; COMDAT (pick any)
.text$mn:00003B0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B0C
.text$mn:00003B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00003B0C
.text$mn:00003B0C ; Attributes: bp-based frame
.text$mn:00003B0C
.text$mn:00003B0C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct PluginInfo * *>(struct PluginInfo * * const &)
.text$mn:00003B0C                 public ??$_Iter_cat@PAPAUPluginInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUPluginInfo@@@Z
.text$mn:00003B0C ??$_Iter_cat@PAPAUPluginInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUPluginInfo@@@Z proc near
.text$mn:00003B0C                                         ; CODE XREF: std::_Debug_range<PluginInfo * *>(PluginInfo * *,PluginInfo * *,wchar_t const *,uint)+Cp
.text$mn:00003B0C
.text$mn:00003B0C var_1           = byte ptr -1
.text$mn:00003B0C arg_0           = dword ptr  8
.text$mn:00003B0C
.text$mn:00003B0C                 push    ebp
.text$mn:00003B0D                 mov     ebp, esp
.text$mn:00003B0F                 push    ecx
.text$mn:00003B10                 mov     eax, [ebp+arg_0]
.text$mn:00003B13                 mov     cl, [ebp+var_1]
.text$mn:00003B16                 mov     [eax], cl
.text$mn:00003B18                 mov     eax, [ebp+arg_0]
.text$mn:00003B1B                 mov     esp, ebp
.text$mn:00003B1D                 pop     ebp
.text$mn:00003B1E                 retn
.text$mn:00003B1E ??$_Iter_cat@PAPAUPluginInfo@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUPluginInfo@@@Z endp
.text$mn:00003B1E
.text$mn:00003B1E ; ---------------------------------------------------------------------------
.text$mn:00003B1F                 align 10h
.text$mn:00003B1F _text$mn        ends
.text$mn:00003B1F
.text$mn:00003B20 ; ===========================================================================
.text$mn:00003B20
.text$mn:00003B20 ; Segment type: Pure code
.text$mn:00003B20 ; Segment permissions: Read/Execute
.text$mn:00003B20 _text$mn        segment para public 'CODE' use32
.text$mn:00003B20                 assume cs:_text$mn
.text$mn:00003B20                 ;org 3B20h
.text$mn:00003B20 ; COMDAT (pick any)
.text$mn:00003B20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B20
.text$mn:00003B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B20
.text$mn:00003B20 ; Attributes: bp-based frame
.text$mn:00003B20
.text$mn:00003B20 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class TiXmlDocument * *>(class TiXmlDocument * * const &)
.text$mn:00003B20                 public ??$_Iter_cat@PAPAVTiXmlDocument@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTiXmlDocument@@@Z
.text$mn:00003B20 ??$_Iter_cat@PAPAVTiXmlDocument@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTiXmlDocument@@@Z proc near
.text$mn:00003B20                                         ; CODE XREF: std::_Debug_range<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,wchar_t const *,uint)+Cp
.text$mn:00003B20
.text$mn:00003B20 var_1           = byte ptr -1
.text$mn:00003B20 arg_0           = dword ptr  8
.text$mn:00003B20
.text$mn:00003B20                 push    ebp
.text$mn:00003B21                 mov     ebp, esp
.text$mn:00003B23                 push    ecx
.text$mn:00003B24                 mov     eax, [ebp+arg_0]
.text$mn:00003B27                 mov     cl, [ebp+var_1]
.text$mn:00003B2A                 mov     [eax], cl
.text$mn:00003B2C                 mov     eax, [ebp+arg_0]
.text$mn:00003B2F                 mov     esp, ebp
.text$mn:00003B31                 pop     ebp
.text$mn:00003B32                 retn
.text$mn:00003B32 ??$_Iter_cat@PAPAVTiXmlDocument@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVTiXmlDocument@@@Z endp
.text$mn:00003B32
.text$mn:00003B32 ; ---------------------------------------------------------------------------
.text$mn:00003B33                 align 4
.text$mn:00003B33 _text$mn        ends
.text$mn:00003B33
.text$mn:00003B34 ; ===========================================================================
.text$mn:00003B34
.text$mn:00003B34 ; Segment type: Pure code
.text$mn:00003B34 ; Segment permissions: Read/Execute
.text$mn:00003B34 _text$mn        segment para public 'CODE' use32
.text$mn:00003B34                 assume cs:_text$mn
.text$mn:00003B34                 ;org 3B34h
.text$mn:00003B34 ; COMDAT (pick any)
.text$mn:00003B34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B34
.text$mn:00003B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B34
.text$mn:00003B34 ; Attributes: bp-based frame
.text$mn:00003B34
.text$mn:00003B34 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * const &)
.text$mn:00003B34                 public ??$_Iter_cat@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@@Z
.text$mn:00003B34 ??$_Iter_cat@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@@Z proc near
.text$mn:00003B34                                         ; CODE XREF: std::_Debug_range<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint)+Cp
.text$mn:00003B34
.text$mn:00003B34 var_1           = byte ptr -1
.text$mn:00003B34 arg_0           = dword ptr  8
.text$mn:00003B34
.text$mn:00003B34                 push    ebp
.text$mn:00003B35                 mov     ebp, esp
.text$mn:00003B37                 push    ecx
.text$mn:00003B38                 mov     eax, [ebp+arg_0]
.text$mn:00003B3B                 mov     cl, [ebp+var_1]
.text$mn:00003B3E                 mov     [eax], cl
.text$mn:00003B40                 mov     eax, [ebp+arg_0]
.text$mn:00003B43                 mov     esp, ebp
.text$mn:00003B45                 pop     ebp
.text$mn:00003B46                 retn
.text$mn:00003B46 ??$_Iter_cat@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@@Z endp
.text$mn:00003B46
.text$mn:00003B46 ; ---------------------------------------------------------------------------
.text$mn:00003B47                 align 4
.text$mn:00003B47 _text$mn        ends
.text$mn:00003B47
.text$mn:00003B48 ; ===========================================================================
.text$mn:00003B48
.text$mn:00003B48 ; Segment type: Pure code
.text$mn:00003B48 ; Segment permissions: Read/Execute
.text$mn:00003B48 _text$mn        segment para public 'CODE' use32
.text$mn:00003B48                 assume cs:_text$mn
.text$mn:00003B48                 ;org 3B48h
.text$mn:00003B48 ; COMDAT (pick any)
.text$mn:00003B48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B48
.text$mn:00003B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B48
.text$mn:00003B48 ; Attributes: bp-based frame
.text$mn:00003B48
.text$mn:00003B48 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct PluginCommand *>(struct PluginCommand * const &)
.text$mn:00003B48                 public ??$_Iter_cat@PAUPluginCommand@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPluginCommand@@@Z
.text$mn:00003B48 ??$_Iter_cat@PAUPluginCommand@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPluginCommand@@@Z proc near
.text$mn:00003B48                                         ; CODE XREF: std::_Debug_range<PluginCommand *>(PluginCommand *,PluginCommand *,wchar_t const *,uint)+Cp
.text$mn:00003B48
.text$mn:00003B48 var_1           = byte ptr -1
.text$mn:00003B48 arg_0           = dword ptr  8
.text$mn:00003B48
.text$mn:00003B48                 push    ebp
.text$mn:00003B49                 mov     ebp, esp
.text$mn:00003B4B                 push    ecx
.text$mn:00003B4C                 mov     eax, [ebp+arg_0]
.text$mn:00003B4F                 mov     cl, [ebp+var_1]
.text$mn:00003B52                 mov     [eax], cl
.text$mn:00003B54                 mov     eax, [ebp+arg_0]
.text$mn:00003B57                 mov     esp, ebp
.text$mn:00003B59                 pop     ebp
.text$mn:00003B5A                 retn
.text$mn:00003B5A ??$_Iter_cat@PAUPluginCommand@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPluginCommand@@@Z endp
.text$mn:00003B5A
.text$mn:00003B5A ; ---------------------------------------------------------------------------
.text$mn:00003B5B                 align 4
.text$mn:00003B5B _text$mn        ends
.text$mn:00003B5B
.text$mn:00003B5C ; ===========================================================================
.text$mn:00003B5C
.text$mn:00003B5C ; Segment type: Pure code
.text$mn:00003B5C ; Segment permissions: Read/Execute
.text$mn:00003B5C _text$mn        segment para public 'CODE' use32
.text$mn:00003B5C                 assume cs:_text$mn
.text$mn:00003B5C                 ;org 3B5Ch
.text$mn:00003B5C ; COMDAT (pick any)
.text$mn:00003B5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B5C
.text$mn:00003B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00003B5C
.text$mn:00003B5C ; Attributes: bp-based frame
.text$mn:00003B5C
.text$mn:00003B5C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * const &)
.text$mn:00003B5C                 public ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
.text$mn:00003B5C ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z proc near
.text$mn:00003B5C                                         ; CODE XREF: std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)+Cp
.text$mn:00003B5C
.text$mn:00003B5C var_1           = byte ptr -1
.text$mn:00003B5C arg_0           = dword ptr  8
.text$mn:00003B5C
.text$mn:00003B5C                 push    ebp
.text$mn:00003B5D                 mov     ebp, esp
.text$mn:00003B5F                 push    ecx
.text$mn:00003B60                 mov     eax, [ebp+arg_0]
.text$mn:00003B63                 mov     cl, [ebp+var_1]
.text$mn:00003B66                 mov     [eax], cl
.text$mn:00003B68                 mov     eax, [ebp+arg_0]
.text$mn:00003B6B                 mov     esp, ebp
.text$mn:00003B6D                 pop     ebp
.text$mn:00003B6E                 retn
.text$mn:00003B6E ??$_Iter_cat@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z endp
.text$mn:00003B6E
.text$mn:00003B6E ; ---------------------------------------------------------------------------
.text$mn:00003B6F                 align 10h
.text$mn:00003B6F _text$mn        ends
.text$mn:00003B6F
.text$mn:00003B70 ; ===========================================================================
.text$mn:00003B70
.text$mn:00003B70 ; Segment type: Pure code
.text$mn:00003B70 ; Segment permissions: Read/Execute
.text$mn:00003B70 _text$mn        segment para public 'CODE' use32
.text$mn:00003B70                 assume cs:_text$mn
.text$mn:00003B70                 ;org 3B70h
.text$mn:00003B70 ; COMDAT (pick any)
.text$mn:00003B70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B70
.text$mn:00003B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B70
.text$mn:00003B70 ; Attributes: bp-based frame
.text$mn:00003B70
.text$mn:00003B70 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class PluginCmdShortcut *>(class PluginCmdShortcut * const &)
.text$mn:00003B70                 public ??$_Iter_cat@PAVPluginCmdShortcut@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPluginCmdShortcut@@@Z
.text$mn:00003B70 ??$_Iter_cat@PAVPluginCmdShortcut@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPluginCmdShortcut@@@Z proc near
.text$mn:00003B70                                         ; CODE XREF: std::_Debug_range<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,wchar_t const *,uint)+Cp
.text$mn:00003B70
.text$mn:00003B70 var_1           = byte ptr -1
.text$mn:00003B70 arg_0           = dword ptr  8
.text$mn:00003B70
.text$mn:00003B70                 push    ebp
.text$mn:00003B71                 mov     ebp, esp
.text$mn:00003B73                 push    ecx
.text$mn:00003B74                 mov     eax, [ebp+arg_0]
.text$mn:00003B77                 mov     cl, [ebp+var_1]
.text$mn:00003B7A                 mov     [eax], cl
.text$mn:00003B7C                 mov     eax, [ebp+arg_0]
.text$mn:00003B7F                 mov     esp, ebp
.text$mn:00003B81                 pop     ebp
.text$mn:00003B82                 retn
.text$mn:00003B82 ??$_Iter_cat@PAVPluginCmdShortcut@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPluginCmdShortcut@@@Z endp
.text$mn:00003B82
.text$mn:00003B82 ; ---------------------------------------------------------------------------
.text$mn:00003B83                 align 4
.text$mn:00003B83 _text$mn        ends
.text$mn:00003B83
.text$mn:00003B84 ; ===========================================================================
.text$mn:00003B84
.text$mn:00003B84 ; Segment type: Pure code
.text$mn:00003B84 ; Segment permissions: Read/Execute
.text$mn:00003B84 _text$mn        segment para public 'CODE' use32
.text$mn:00003B84                 assume cs:_text$mn
.text$mn:00003B84                 ;org 3B84h
.text$mn:00003B84 ; COMDAT (pick any)
.text$mn:00003B84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B84
.text$mn:00003B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B84
.text$mn:00003B84 ; Attributes: bp-based frame
.text$mn:00003B84
.text$mn:00003B84 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct PluginInfo *, struct PluginInfo *>(struct PluginInfo * *, struct PluginInfo * *)
.text$mn:00003B84                 public ??$_Ptr_cat@PAUPluginInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUPluginInfo@@0@Z
.text$mn:00003B84 ??$_Ptr_cat@PAUPluginInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUPluginInfo@@0@Z proc near
.text$mn:00003B84                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)+Cp
.text$mn:00003B84                                         ; std::_Uninit_move<PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)+Cp
.text$mn:00003B84
.text$mn:00003B84 var_1           = byte ptr -1
.text$mn:00003B84
.text$mn:00003B84                 push    ebp
.text$mn:00003B85                 mov     ebp, esp
.text$mn:00003B87                 push    ecx
.text$mn:00003B88                 mov     al, [ebp+var_1]
.text$mn:00003B8B                 mov     esp, ebp
.text$mn:00003B8D                 pop     ebp
.text$mn:00003B8E                 retn
.text$mn:00003B8E ??$_Ptr_cat@PAUPluginInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUPluginInfo@@0@Z endp
.text$mn:00003B8E
.text$mn:00003B8E ; ---------------------------------------------------------------------------
.text$mn:00003B8F                 align 10h
.text$mn:00003B8F _text$mn        ends
.text$mn:00003B8F
.text$mn:00003B90 ; ===========================================================================
.text$mn:00003B90
.text$mn:00003B90 ; Segment type: Pure code
.text$mn:00003B90 ; Segment permissions: Read/Execute
.text$mn:00003B90 _text$mn        segment para public 'CODE' use32
.text$mn:00003B90                 assume cs:_text$mn
.text$mn:00003B90                 ;org 3B90h
.text$mn:00003B90 ; COMDAT (pick any)
.text$mn:00003B90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B90
.text$mn:00003B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B90
.text$mn:00003B90 ; Attributes: bp-based frame
.text$mn:00003B90
.text$mn:00003B90 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class TiXmlDocument *, class TiXmlDocument *>(class TiXmlDocument * *, class TiXmlDocument * *)
.text$mn:00003B90                 public ??$_Ptr_cat@PAVTiXmlDocument@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVTiXmlDocument@@0@Z
.text$mn:00003B90 ??$_Ptr_cat@PAVTiXmlDocument@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVTiXmlDocument@@0@Z proc near
.text$mn:00003B90                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)+Cp
.text$mn:00003B90                                         ; std::_Uninit_move<TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)+Cp
.text$mn:00003B90
.text$mn:00003B90 var_1           = byte ptr -1
.text$mn:00003B90
.text$mn:00003B90                 push    ebp
.text$mn:00003B91                 mov     ebp, esp
.text$mn:00003B93                 push    ecx
.text$mn:00003B94                 mov     al, [ebp+var_1]
.text$mn:00003B97                 mov     esp, ebp
.text$mn:00003B99                 pop     ebp
.text$mn:00003B9A                 retn
.text$mn:00003B9A ??$_Ptr_cat@PAVTiXmlDocument@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVTiXmlDocument@@0@Z endp
.text$mn:00003B9A
.text$mn:00003B9A ; ---------------------------------------------------------------------------
.text$mn:00003B9B                 align 4
.text$mn:00003B9B _text$mn        ends
.text$mn:00003B9B
.text$mn:00003B9C ; ===========================================================================
.text$mn:00003B9C
.text$mn:00003B9C ; Segment type: Pure code
.text$mn:00003B9C ; Segment permissions: Read/Execute
.text$mn:00003B9C _text$mn        segment para public 'CODE' use32
.text$mn:00003B9C                 assume cs:_text$mn
.text$mn:00003B9C                 ;org 3B9Ch
.text$mn:00003B9C ; COMDAT (pick any)
.text$mn:00003B9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B9C
.text$mn:00003B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003B9C
.text$mn:00003B9C ; Attributes: bp-based frame
.text$mn:00003B9C
.text$mn:00003B9C ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)
.text$mn:00003B9C                 public ??$_Ptr_cat@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0@Z
.text$mn:00003B9C ??$_Ptr_cat@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0@Z proc near
.text$mn:00003B9C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)+Cp
.text$mn:00003B9C                                         ; std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)+Cp
.text$mn:00003B9C
.text$mn:00003B9C var_1           = byte ptr -1
.text$mn:00003B9C
.text$mn:00003B9C                 push    ebp
.text$mn:00003B9D                 mov     ebp, esp
.text$mn:00003B9F                 push    ecx
.text$mn:00003BA0                 mov     al, [ebp+var_1]
.text$mn:00003BA3                 mov     esp, ebp
.text$mn:00003BA5                 pop     ebp
.text$mn:00003BA6                 retn
.text$mn:00003BA6 ??$_Ptr_cat@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0@Z endp
.text$mn:00003BA6
.text$mn:00003BA6 ; ---------------------------------------------------------------------------
.text$mn:00003BA7                 align 4
.text$mn:00003BA7 _text$mn        ends
.text$mn:00003BA7
.text$mn:00003BA8 ; ===========================================================================
.text$mn:00003BA8
.text$mn:00003BA8 ; Segment type: Pure code
.text$mn:00003BA8 ; Segment permissions: Read/Execute
.text$mn:00003BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00003BA8                 assume cs:_text$mn
.text$mn:00003BA8                 ;org 3BA8h
.text$mn:00003BA8 ; COMDAT (pick any)
.text$mn:00003BA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BA8
.text$mn:00003BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BA8
.text$mn:00003BA8 ; Attributes: bp-based frame
.text$mn:00003BA8
.text$mn:00003BA8 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct PluginCommand, struct PluginCommand>(struct PluginCommand *, struct PluginCommand *)
.text$mn:00003BA8                 public ??$_Ptr_cat@UPluginCommand@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPluginCommand@@0@Z
.text$mn:00003BA8 ??$_Ptr_cat@UPluginCommand@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPluginCommand@@0@Z proc near
.text$mn:00003BA8                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)+Cp
.text$mn:00003BA8                                         ; std::_Uninit_move<PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)+Cp
.text$mn:00003BA8
.text$mn:00003BA8 var_1           = byte ptr -1
.text$mn:00003BA8
.text$mn:00003BA8                 push    ebp
.text$mn:00003BA9                 mov     ebp, esp
.text$mn:00003BAB                 push    ecx
.text$mn:00003BAC                 mov     al, [ebp+var_1]
.text$mn:00003BAF                 mov     esp, ebp
.text$mn:00003BB1                 pop     ebp
.text$mn:00003BB2                 retn
.text$mn:00003BB2 ??$_Ptr_cat@UPluginCommand@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPluginCommand@@0@Z endp
.text$mn:00003BB2
.text$mn:00003BB2 ; ---------------------------------------------------------------------------
.text$mn:00003BB3                 align 4
.text$mn:00003BB3 _text$mn        ends
.text$mn:00003BB3
.text$mn:00003BB4 ; ===========================================================================
.text$mn:00003BB4
.text$mn:00003BB4 ; Segment type: Pure code
.text$mn:00003BB4 ; Segment permissions: Read/Execute
.text$mn:00003BB4 _text$mn        segment para public 'CODE' use32
.text$mn:00003BB4                 assume cs:_text$mn
.text$mn:00003BB4                 ;org 3BB4h
.text$mn:00003BB4 ; COMDAT (pick any)
.text$mn:00003BB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BB4
.text$mn:00003BB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BB4
.text$mn:00003BB4 ; Attributes: bp-based frame
.text$mn:00003BB4
.text$mn:00003BB4 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00003BB4                 public ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
.text$mn:00003BB4 ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z proc near
.text$mn:00003BB4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+Cp
.text$mn:00003BB4                                         ; std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+Cp
.text$mn:00003BB4
.text$mn:00003BB4 var_1           = byte ptr -1
.text$mn:00003BB4
.text$mn:00003BB4                 push    ebp
.text$mn:00003BB5                 mov     ebp, esp
.text$mn:00003BB7                 push    ecx
.text$mn:00003BB8                 mov     al, [ebp+var_1]
.text$mn:00003BBB                 mov     esp, ebp
.text$mn:00003BBD                 pop     ebp
.text$mn:00003BBE                 retn
.text$mn:00003BBE ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z endp
.text$mn:00003BBE
.text$mn:00003BBE ; ---------------------------------------------------------------------------
.text$mn:00003BBF                 align 10h
.text$mn:00003BBF _text$mn        ends
.text$mn:00003BBF
.text$mn:00003BC0 ; ===========================================================================
.text$mn:00003BC0
.text$mn:00003BC0 ; Segment type: Pure code
.text$mn:00003BC0 ; Segment permissions: Read/Execute
.text$mn:00003BC0 _text$mn        segment para public 'CODE' use32
.text$mn:00003BC0                 assume cs:_text$mn
.text$mn:00003BC0                 ;org 3BC0h
.text$mn:00003BC0 ; COMDAT (pick any)
.text$mn:00003BC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BC0
.text$mn:00003BC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BC0
.text$mn:00003BC0 ; Attributes: bp-based frame
.text$mn:00003BC0
.text$mn:00003BC0 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class PluginCmdShortcut, class PluginCmdShortcut>(class PluginCmdShortcut *, class PluginCmdShortcut *)
.text$mn:00003BC0                 public ??$_Ptr_cat@VPluginCmdShortcut@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPluginCmdShortcut@@0@Z
.text$mn:00003BC0 ??$_Ptr_cat@VPluginCmdShortcut@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPluginCmdShortcut@@0@Z proc near
.text$mn:00003BC0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)+Cp
.text$mn:00003BC0                                         ; std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)+Cp
.text$mn:00003BC0
.text$mn:00003BC0 var_1           = byte ptr -1
.text$mn:00003BC0
.text$mn:00003BC0                 push    ebp
.text$mn:00003BC1                 mov     ebp, esp
.text$mn:00003BC3                 push    ecx
.text$mn:00003BC4                 mov     al, [ebp+var_1]
.text$mn:00003BC7                 mov     esp, ebp
.text$mn:00003BC9                 pop     ebp
.text$mn:00003BCA                 retn
.text$mn:00003BCA ??$_Ptr_cat@VPluginCmdShortcut@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPluginCmdShortcut@@0@Z endp
.text$mn:00003BCA
.text$mn:00003BCA ; ---------------------------------------------------------------------------
.text$mn:00003BCB                 align 4
.text$mn:00003BCB _text$mn        ends
.text$mn:00003BCB
.text$mn:00003BCC ; ===========================================================================
.text$mn:00003BCC
.text$mn:00003BCC ; Segment type: Pure code
.text$mn:00003BCC ; Segment permissions: Read/Execute
.text$mn:00003BCC _text$mn        segment para public 'CODE' use32
.text$mn:00003BCC                 assume cs:_text$mn
.text$mn:00003BCC                 ;org 3BCCh
.text$mn:00003BCC ; COMDAT (pick any)
.text$mn:00003BCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BCC
.text$mn:00003BCC ; =============== S U B R O U T I N E =======================================
.text$mn:00003BCC
.text$mn:00003BCC ; Attributes: bp-based frame
.text$mn:00003BCC
.text$mn:00003BCC ; struct PluginInfo * * & __cdecl std::_Rechecked<struct PluginInfo * *, struct PluginInfo * *>(struct PluginInfo * * &, struct PluginInfo * *)
.text$mn:00003BCC                 public ??$_Rechecked@PAPAUPluginInfo@@PAPAU1@@std@@YAAAPAPAUPluginInfo@@AAPAPAU1@PAPAU1@@Z
.text$mn:00003BCC ??$_Rechecked@PAPAUPluginInfo@@PAPAU1@@std@@YAAAPAPAUPluginInfo@@AAPAPAU1@PAPAU1@@Z proc near
.text$mn:00003BCC                                         ; CODE XREF: std::_Uninitialized_move<PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)+3Bp
.text$mn:00003BCC
.text$mn:00003BCC arg_0           = dword ptr  8
.text$mn:00003BCC arg_4           = dword ptr  0Ch
.text$mn:00003BCC
.text$mn:00003BCC                 push    ebp
.text$mn:00003BCD                 mov     ebp, esp
.text$mn:00003BCF                 mov     eax, [ebp+arg_0]
.text$mn:00003BD2                 mov     ecx, [ebp+arg_4]
.text$mn:00003BD5                 mov     [eax], ecx
.text$mn:00003BD7                 mov     eax, [ebp+arg_0]
.text$mn:00003BDA                 pop     ebp
.text$mn:00003BDB                 retn
.text$mn:00003BDB ??$_Rechecked@PAPAUPluginInfo@@PAPAU1@@std@@YAAAPAPAUPluginInfo@@AAPAPAU1@PAPAU1@@Z endp
.text$mn:00003BDB
.text$mn:00003BDB _text$mn        ends
.text$mn:00003BDB
.text$mn:00003BDC ; ===========================================================================
.text$mn:00003BDC
.text$mn:00003BDC ; Segment type: Pure code
.text$mn:00003BDC ; Segment permissions: Read/Execute
.text$mn:00003BDC _text$mn        segment para public 'CODE' use32
.text$mn:00003BDC                 assume cs:_text$mn
.text$mn:00003BDC                 ;org 3BDCh
.text$mn:00003BDC ; COMDAT (pick any)
.text$mn:00003BDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BDC
.text$mn:00003BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00003BDC
.text$mn:00003BDC ; Attributes: bp-based frame
.text$mn:00003BDC
.text$mn:00003BDC ; class TiXmlDocument * * & __cdecl std::_Rechecked<class TiXmlDocument * *, class TiXmlDocument * *>(class TiXmlDocument * * &, class TiXmlDocument * *)
.text$mn:00003BDC                 public ??$_Rechecked@PAPAVTiXmlDocument@@PAPAV1@@std@@YAAAPAPAVTiXmlDocument@@AAPAPAV1@PAPAV1@@Z
.text$mn:00003BDC ??$_Rechecked@PAPAVTiXmlDocument@@PAPAV1@@std@@YAAAPAPAVTiXmlDocument@@AAPAPAV1@PAPAV1@@Z proc near
.text$mn:00003BDC                                         ; CODE XREF: std::_Uninitialized_move<TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)+3Bp
.text$mn:00003BDC
.text$mn:00003BDC arg_0           = dword ptr  8
.text$mn:00003BDC arg_4           = dword ptr  0Ch
.text$mn:00003BDC
.text$mn:00003BDC                 push    ebp
.text$mn:00003BDD                 mov     ebp, esp
.text$mn:00003BDF                 mov     eax, [ebp+arg_0]
.text$mn:00003BE2                 mov     ecx, [ebp+arg_4]
.text$mn:00003BE5                 mov     [eax], ecx
.text$mn:00003BE7                 mov     eax, [ebp+arg_0]
.text$mn:00003BEA                 pop     ebp
.text$mn:00003BEB                 retn
.text$mn:00003BEB ??$_Rechecked@PAPAVTiXmlDocument@@PAPAV1@@std@@YAAAPAPAVTiXmlDocument@@AAPAPAV1@PAPAV1@@Z endp
.text$mn:00003BEB
.text$mn:00003BEB _text$mn        ends
.text$mn:00003BEB
.text$mn:00003BEC ; ===========================================================================
.text$mn:00003BEC
.text$mn:00003BEC ; Segment type: Pure code
.text$mn:00003BEC ; Segment permissions: Read/Execute
.text$mn:00003BEC _text$mn        segment para public 'CODE' use32
.text$mn:00003BEC                 assume cs:_text$mn
.text$mn:00003BEC                 ;org 3BECh
.text$mn:00003BEC ; COMDAT (pick any)
.text$mn:00003BEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BEC
.text$mn:00003BEC ; =============== S U B R O U T I N E =======================================
.text$mn:00003BEC
.text$mn:00003BEC ; Attributes: bp-based frame
.text$mn:00003BEC
.text$mn:00003BEC ; struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * & __cdecl std::_Rechecked<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * &, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)
.text$mn:00003BEC                 public ??$_Rechecked@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@@std@@YAAAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAPAU10@PAU10@@Z
.text$mn:00003BEC ??$_Rechecked@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@@std@@YAAAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAPAU10@PAU10@@Z proc near
.text$mn:00003BEC                                         ; CODE XREF: std::_Uninitialized_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)+3Bp
.text$mn:00003BEC
.text$mn:00003BEC arg_0           = dword ptr  8
.text$mn:00003BEC arg_4           = dword ptr  0Ch
.text$mn:00003BEC
.text$mn:00003BEC                 push    ebp
.text$mn:00003BED                 mov     ebp, esp
.text$mn:00003BEF                 mov     eax, [ebp+arg_0]
.text$mn:00003BF2                 mov     ecx, [ebp+arg_4]
.text$mn:00003BF5                 mov     [eax], ecx
.text$mn:00003BF7                 mov     eax, [ebp+arg_0]
.text$mn:00003BFA                 pop     ebp
.text$mn:00003BFB                 retn
.text$mn:00003BFB ??$_Rechecked@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@@std@@YAAAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAPAU10@PAU10@@Z endp
.text$mn:00003BFB
.text$mn:00003BFB _text$mn        ends
.text$mn:00003BFB
.text$mn:00003BFC ; ===========================================================================
.text$mn:00003BFC
.text$mn:00003BFC ; Segment type: Pure code
.text$mn:00003BFC ; Segment permissions: Read/Execute
.text$mn:00003BFC _text$mn        segment para public 'CODE' use32
.text$mn:00003BFC                 assume cs:_text$mn
.text$mn:00003BFC                 ;org 3BFCh
.text$mn:00003BFC ; COMDAT (pick any)
.text$mn:00003BFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BFC
.text$mn:00003BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00003BFC
.text$mn:00003BFC ; Attributes: bp-based frame
.text$mn:00003BFC
.text$mn:00003BFC ; struct PluginCommand * & __cdecl std::_Rechecked<struct PluginCommand *, struct PluginCommand *>(struct PluginCommand * &, struct PluginCommand *)
.text$mn:00003BFC                 public ??$_Rechecked@PAUPluginCommand@@PAU1@@std@@YAAAPAUPluginCommand@@AAPAU1@PAU1@@Z
.text$mn:00003BFC ??$_Rechecked@PAUPluginCommand@@PAU1@@std@@YAAAPAUPluginCommand@@AAPAU1@PAU1@@Z proc near
.text$mn:00003BFC                                         ; CODE XREF: std::_Uninitialized_move<PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)+3Bp
.text$mn:00003BFC
.text$mn:00003BFC arg_0           = dword ptr  8
.text$mn:00003BFC arg_4           = dword ptr  0Ch
.text$mn:00003BFC
.text$mn:00003BFC                 push    ebp
.text$mn:00003BFD                 mov     ebp, esp
.text$mn:00003BFF                 mov     eax, [ebp+arg_0]
.text$mn:00003C02                 mov     ecx, [ebp+arg_4]
.text$mn:00003C05                 mov     [eax], ecx
.text$mn:00003C07                 mov     eax, [ebp+arg_0]
.text$mn:00003C0A                 pop     ebp
.text$mn:00003C0B                 retn
.text$mn:00003C0B ??$_Rechecked@PAUPluginCommand@@PAU1@@std@@YAAAPAUPluginCommand@@AAPAU1@PAU1@@Z endp
.text$mn:00003C0B
.text$mn:00003C0B _text$mn        ends
.text$mn:00003C0B
.text$mn:00003C0C ; ===========================================================================
.text$mn:00003C0C
.text$mn:00003C0C ; Segment type: Pure code
.text$mn:00003C0C ; Segment permissions: Read/Execute
.text$mn:00003C0C _text$mn        segment para public 'CODE' use32
.text$mn:00003C0C                 assume cs:_text$mn
.text$mn:00003C0C                 ;org 3C0Ch
.text$mn:00003C0C ; COMDAT (pick any)
.text$mn:00003C0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C0C
.text$mn:00003C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C0C
.text$mn:00003C0C ; Attributes: bp-based frame
.text$mn:00003C0C
.text$mn:00003C0C ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * & __cdecl std::_Rechecked<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00003C0C                 public ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z
.text$mn:00003C0C ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z proc near
.text$mn:00003C0C                                         ; CODE XREF: std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+3Bp
.text$mn:00003C0C
.text$mn:00003C0C arg_0           = dword ptr  8
.text$mn:00003C0C arg_4           = dword ptr  0Ch
.text$mn:00003C0C
.text$mn:00003C0C                 push    ebp
.text$mn:00003C0D                 mov     ebp, esp
.text$mn:00003C0F                 mov     eax, [ebp+arg_0]
.text$mn:00003C12                 mov     ecx, [ebp+arg_4]
.text$mn:00003C15                 mov     [eax], ecx
.text$mn:00003C17                 mov     eax, [ebp+arg_0]
.text$mn:00003C1A                 pop     ebp
.text$mn:00003C1B                 retn
.text$mn:00003C1B ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z endp
.text$mn:00003C1B
.text$mn:00003C1B _text$mn        ends
.text$mn:00003C1B
.text$mn:00003C1C ; ===========================================================================
.text$mn:00003C1C
.text$mn:00003C1C ; Segment type: Pure code
.text$mn:00003C1C ; Segment permissions: Read/Execute
.text$mn:00003C1C _text$mn        segment para public 'CODE' use32
.text$mn:00003C1C                 assume cs:_text$mn
.text$mn:00003C1C                 ;org 3C1Ch
.text$mn:00003C1C ; COMDAT (pick any)
.text$mn:00003C1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C1C
.text$mn:00003C1C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C1C
.text$mn:00003C1C ; Attributes: bp-based frame
.text$mn:00003C1C
.text$mn:00003C1C ; class PluginCmdShortcut * & __cdecl std::_Rechecked<class PluginCmdShortcut *, class PluginCmdShortcut *>(class PluginCmdShortcut * &, class PluginCmdShortcut *)
.text$mn:00003C1C                 public ??$_Rechecked@PAVPluginCmdShortcut@@PAV1@@std@@YAAAPAVPluginCmdShortcut@@AAPAV1@PAV1@@Z
.text$mn:00003C1C ??$_Rechecked@PAVPluginCmdShortcut@@PAV1@@std@@YAAAPAVPluginCmdShortcut@@AAPAV1@PAV1@@Z proc near
.text$mn:00003C1C                                         ; CODE XREF: std::_Uninitialized_move<PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)+3Bp
.text$mn:00003C1C
.text$mn:00003C1C arg_0           = dword ptr  8
.text$mn:00003C1C arg_4           = dword ptr  0Ch
.text$mn:00003C1C
.text$mn:00003C1C                 push    ebp
.text$mn:00003C1D                 mov     ebp, esp
.text$mn:00003C1F                 mov     eax, [ebp+arg_0]
.text$mn:00003C22                 mov     ecx, [ebp+arg_4]
.text$mn:00003C25                 mov     [eax], ecx
.text$mn:00003C27                 mov     eax, [ebp+arg_0]
.text$mn:00003C2A                 pop     ebp
.text$mn:00003C2B                 retn
.text$mn:00003C2B ??$_Rechecked@PAVPluginCmdShortcut@@PAV1@@std@@YAAAPAVPluginCmdShortcut@@AAPAV1@PAV1@@Z endp
.text$mn:00003C2B
.text$mn:00003C2B _text$mn        ends
.text$mn:00003C2B
.text$mn:00003C2C ; ===========================================================================
.text$mn:00003C2C
.text$mn:00003C2C ; Segment type: Pure code
.text$mn:00003C2C ; Segment permissions: Read/Execute
.text$mn:00003C2C _text$mn        segment para public 'CODE' use32
.text$mn:00003C2C                 assume cs:_text$mn
.text$mn:00003C2C                 ;org 3C2Ch
.text$mn:00003C2C ; COMDAT (pick any)
.text$mn:00003C2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C2C
.text$mn:00003C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C2C
.text$mn:00003C2C ; Attributes: bp-based frame
.text$mn:00003C2C
.text$mn:00003C2C ; protected: struct PluginInfo * * __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::_Umove<struct PluginInfo * *>(struct PluginInfo * *, struct PluginInfo * *, struct PluginInfo * *)
.text$mn:00003C2C                 public ??$_Umove@PAPAUPluginInfo@@@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEPAPAUPluginInfo@@PAPAU2@00@Z
.text$mn:00003C2C ??$_Umove@PAPAUPluginInfo@@@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEPAPAUPluginInfo@@PAPAU2@00@Z proc near
.text$mn:00003C2C                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reallocate(uint)+65p
.text$mn:00003C2C
.text$mn:00003C2C var_8           = dword ptr -8
.text$mn:00003C2C var_1           = byte ptr -1
.text$mn:00003C2C arg_0           = dword ptr  8
.text$mn:00003C2C arg_4           = dword ptr  0Ch
.text$mn:00003C2C arg_8           = dword ptr  10h
.text$mn:00003C2C
.text$mn:00003C2C                 push    ebp
.text$mn:00003C2D                 mov     ebp, esp
.text$mn:00003C2F                 sub     esp, 8
.text$mn:00003C32                 mov     [ebp+var_8], ecx
.text$mn:00003C35                 lea     eax, [ebp+var_1]
.text$mn:00003C38                 push    eax
.text$mn:00003C39                 mov     ecx, [ebp+var_8]
.text$mn:00003C3C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginInfo *,std::allocator<PluginInfo *>>>::_Getal(void)
.text$mn:00003C41                 lea     ecx, [ebp+var_1]
.text$mn:00003C44                 push    ecx
.text$mn:00003C45                 mov     edx, [ebp+arg_8]
.text$mn:00003C48                 push    edx
.text$mn:00003C49                 mov     eax, [ebp+arg_4]
.text$mn:00003C4C                 push    eax
.text$mn:00003C4D                 mov     ecx, [ebp+arg_0]
.text$mn:00003C50                 push    ecx
.text$mn:00003C51                 call    ??$_Uninitialized_move@PAPAUPluginInfo@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z ; std::_Uninitialized_move<PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)
.text$mn:00003C56                 add     esp, 10h
.text$mn:00003C59                 mov     esp, ebp
.text$mn:00003C5B                 pop     ebp
.text$mn:00003C5C                 retn    0Ch
.text$mn:00003C5C ??$_Umove@PAPAUPluginInfo@@@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEPAPAUPluginInfo@@PAPAU2@00@Z endp
.text$mn:00003C5C
.text$mn:00003C5C ; ---------------------------------------------------------------------------
.text$mn:00003C5F                 align 10h
.text$mn:00003C5F _text$mn        ends
.text$mn:00003C5F
.text$mn:00003C60 ; ===========================================================================
.text$mn:00003C60
.text$mn:00003C60 ; Segment type: Pure code
.text$mn:00003C60 ; Segment permissions: Read/Execute
.text$mn:00003C60 _text$mn        segment para public 'CODE' use32
.text$mn:00003C60                 assume cs:_text$mn
.text$mn:00003C60                 ;org 3C60h
.text$mn:00003C60 ; COMDAT (pick any)
.text$mn:00003C60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C60
.text$mn:00003C60 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C60
.text$mn:00003C60 ; Attributes: bp-based frame
.text$mn:00003C60
.text$mn:00003C60 ; protected: class TiXmlDocument * * __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::_Umove<class TiXmlDocument * *>(class TiXmlDocument * *, class TiXmlDocument * *, class TiXmlDocument * *)
.text$mn:00003C60                 public ??$_Umove@PAPAVTiXmlDocument@@@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEPAPAVTiXmlDocument@@PAPAV2@00@Z
.text$mn:00003C60 ??$_Umove@PAPAVTiXmlDocument@@@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEPAPAVTiXmlDocument@@PAPAV2@00@Z proc near
.text$mn:00003C60                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reallocate(uint)+65p
.text$mn:00003C60
.text$mn:00003C60 var_8           = dword ptr -8
.text$mn:00003C60 var_1           = byte ptr -1
.text$mn:00003C60 arg_0           = dword ptr  8
.text$mn:00003C60 arg_4           = dword ptr  0Ch
.text$mn:00003C60 arg_8           = dword ptr  10h
.text$mn:00003C60
.text$mn:00003C60                 push    ebp
.text$mn:00003C61                 mov     ebp, esp
.text$mn:00003C63                 sub     esp, 8
.text$mn:00003C66                 mov     [ebp+var_8], ecx
.text$mn:00003C69                 lea     eax, [ebp+var_1]
.text$mn:00003C6C                 push    eax
.text$mn:00003C6D                 mov     ecx, [ebp+var_8]
.text$mn:00003C70                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TiXmlDocument *,std::allocator<TiXmlDocument *>>>::_Getal(void)
.text$mn:00003C75                 lea     ecx, [ebp+var_1]
.text$mn:00003C78                 push    ecx
.text$mn:00003C79                 mov     edx, [ebp+arg_8]
.text$mn:00003C7C                 push    edx
.text$mn:00003C7D                 mov     eax, [ebp+arg_4]
.text$mn:00003C80                 push    eax
.text$mn:00003C81                 mov     ecx, [ebp+arg_0]
.text$mn:00003C84                 push    ecx
.text$mn:00003C85                 call    ??$_Uninitialized_move@PAPAVTiXmlDocument@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z ; std::_Uninitialized_move<TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)
.text$mn:00003C8A                 add     esp, 10h
.text$mn:00003C8D                 mov     esp, ebp
.text$mn:00003C8F                 pop     ebp
.text$mn:00003C90                 retn    0Ch
.text$mn:00003C90 ??$_Umove@PAPAVTiXmlDocument@@@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEPAPAVTiXmlDocument@@PAPAV2@00@Z endp
.text$mn:00003C90
.text$mn:00003C90 ; ---------------------------------------------------------------------------
.text$mn:00003C93                 align 4
.text$mn:00003C93 _text$mn        ends
.text$mn:00003C93
.text$mn:00003C94 ; ===========================================================================
.text$mn:00003C94
.text$mn:00003C94 ; Segment type: Pure code
.text$mn:00003C94 ; Segment permissions: Read/Execute
.text$mn:00003C94 _text$mn        segment para public 'CODE' use32
.text$mn:00003C94                 assume cs:_text$mn
.text$mn:00003C94                 ;org 3C94h
.text$mn:00003C94 ; COMDAT (pick any)
.text$mn:00003C94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C94
.text$mn:00003C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C94
.text$mn:00003C94 ; Attributes: bp-based frame
.text$mn:00003C94
.text$mn:00003C94 ; protected: struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::_Umove<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)
.text$mn:00003C94                 public ??$_Umove@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@PAU21@00@Z
.text$mn:00003C94 ??$_Umove@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@PAU21@00@Z proc near
.text$mn:00003C94                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reallocate(uint)+65p
.text$mn:00003C94
.text$mn:00003C94 var_8           = dword ptr -8
.text$mn:00003C94 var_1           = byte ptr -1
.text$mn:00003C94 arg_0           = dword ptr  8
.text$mn:00003C94 arg_4           = dword ptr  0Ch
.text$mn:00003C94 arg_8           = dword ptr  10h
.text$mn:00003C94
.text$mn:00003C94                 push    ebp
.text$mn:00003C95                 mov     ebp, esp
.text$mn:00003C97                 sub     esp, 8
.text$mn:00003C9A                 mov     [ebp+var_8], ecx
.text$mn:00003C9D                 lea     eax, [ebp+var_1]
.text$mn:00003CA0                 push    eax
.text$mn:00003CA1                 mov     ecx, [ebp+var_8]
.text$mn:00003CA4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>::_Getal(void)
.text$mn:00003CA9                 lea     ecx, [ebp+var_1]
.text$mn:00003CAC                 push    ecx
.text$mn:00003CAD                 mov     edx, [ebp+arg_8]
.text$mn:00003CB0                 push    edx
.text$mn:00003CB1                 mov     eax, [ebp+arg_4]
.text$mn:00003CB4                 push    eax
.text$mn:00003CB5                 mov     ecx, [ebp+arg_0]
.text$mn:00003CB8                 push    ecx
.text$mn:00003CB9                 call    ??$_Uninitialized_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)
.text$mn:00003CBE                 add     esp, 10h
.text$mn:00003CC1                 mov     esp, ebp
.text$mn:00003CC3                 pop     ebp
.text$mn:00003CC4                 retn    0Ch
.text$mn:00003CC4 ??$_Umove@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@PAU21@00@Z endp
.text$mn:00003CC4
.text$mn:00003CC4 ; ---------------------------------------------------------------------------
.text$mn:00003CC7                 align 4
.text$mn:00003CC7 _text$mn        ends
.text$mn:00003CC7
.text$mn:00003CC8 ; ===========================================================================
.text$mn:00003CC8
.text$mn:00003CC8 ; Segment type: Pure code
.text$mn:00003CC8 ; Segment permissions: Read/Execute
.text$mn:00003CC8 _text$mn        segment para public 'CODE' use32
.text$mn:00003CC8                 assume cs:_text$mn
.text$mn:00003CC8                 ;org 3CC8h
.text$mn:00003CC8 ; COMDAT (pick any)
.text$mn:00003CC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CC8
.text$mn:00003CC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CC8
.text$mn:00003CC8 ; Attributes: bp-based frame
.text$mn:00003CC8
.text$mn:00003CC8 ; protected: struct PluginCommand * __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::_Umove<struct PluginCommand *>(struct PluginCommand *, struct PluginCommand *, struct PluginCommand *)
.text$mn:00003CC8                 public ??$_Umove@PAUPluginCommand@@@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEPAUPluginCommand@@PAU2@00@Z
.text$mn:00003CC8 ??$_Umove@PAUPluginCommand@@@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEPAUPluginCommand@@PAU2@00@Z proc near
.text$mn:00003CC8                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reallocate(uint)+65p
.text$mn:00003CC8
.text$mn:00003CC8 var_8           = dword ptr -8
.text$mn:00003CC8 var_1           = byte ptr -1
.text$mn:00003CC8 arg_0           = dword ptr  8
.text$mn:00003CC8 arg_4           = dword ptr  0Ch
.text$mn:00003CC8 arg_8           = dword ptr  10h
.text$mn:00003CC8
.text$mn:00003CC8                 push    ebp
.text$mn:00003CC9                 mov     ebp, esp
.text$mn:00003CCB                 sub     esp, 8
.text$mn:00003CCE                 mov     [ebp+var_8], ecx
.text$mn:00003CD1                 lea     eax, [ebp+var_1]
.text$mn:00003CD4                 push    eax
.text$mn:00003CD5                 mov     ecx, [ebp+var_8]
.text$mn:00003CD8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCommand,std::allocator<PluginCommand>>>::_Getal(void)
.text$mn:00003CDD                 lea     ecx, [ebp+var_1]
.text$mn:00003CE0                 push    ecx
.text$mn:00003CE1                 mov     edx, [ebp+arg_8]
.text$mn:00003CE4                 push    edx
.text$mn:00003CE5                 mov     eax, [ebp+arg_4]
.text$mn:00003CE8                 push    eax
.text$mn:00003CE9                 mov     ecx, [ebp+arg_0]
.text$mn:00003CEC                 push    ecx
.text$mn:00003CED                 call    ??$_Uninitialized_move@PAUPluginCommand@@PAU1@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z ; std::_Uninitialized_move<PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)
.text$mn:00003CF2                 add     esp, 10h
.text$mn:00003CF5                 mov     esp, ebp
.text$mn:00003CF7                 pop     ebp
.text$mn:00003CF8                 retn    0Ch
.text$mn:00003CF8 ??$_Umove@PAUPluginCommand@@@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEPAUPluginCommand@@PAU2@00@Z endp
.text$mn:00003CF8
.text$mn:00003CF8 ; ---------------------------------------------------------------------------
.text$mn:00003CFB                 align 4
.text$mn:00003CFB _text$mn        ends
.text$mn:00003CFB
.text$mn:00003CFC ; ===========================================================================
.text$mn:00003CFC
.text$mn:00003CFC ; Segment type: Pure code
.text$mn:00003CFC ; Segment permissions: Read/Execute
.text$mn:00003CFC _text$mn        segment para public 'CODE' use32
.text$mn:00003CFC                 assume cs:_text$mn
.text$mn:00003CFC                 ;org 3CFCh
.text$mn:00003CFC ; COMDAT (pick any)
.text$mn:00003CFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CFC
.text$mn:00003CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00003CFC
.text$mn:00003CFC ; Attributes: bp-based frame
.text$mn:00003CFC
.text$mn:00003CFC ; protected: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Umove<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00003CFC                 public ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z
.text$mn:00003CFC ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z proc near
.text$mn:00003CFC                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+65p
.text$mn:00003CFC
.text$mn:00003CFC var_8           = dword ptr -8
.text$mn:00003CFC var_1           = byte ptr -1
.text$mn:00003CFC arg_0           = dword ptr  8
.text$mn:00003CFC arg_4           = dword ptr  0Ch
.text$mn:00003CFC arg_8           = dword ptr  10h
.text$mn:00003CFC
.text$mn:00003CFC                 push    ebp
.text$mn:00003CFD                 mov     ebp, esp
.text$mn:00003CFF                 sub     esp, 8
.text$mn:00003D02                 mov     [ebp+var_8], ecx
.text$mn:00003D05                 lea     eax, [ebp+var_1]
.text$mn:00003D08                 push    eax
.text$mn:00003D09                 mov     ecx, [ebp+var_8]
.text$mn:00003D0C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:00003D11                 lea     ecx, [ebp+var_1]
.text$mn:00003D14                 push    ecx
.text$mn:00003D15                 mov     edx, [ebp+arg_8]
.text$mn:00003D18                 push    edx
.text$mn:00003D19                 mov     eax, [ebp+arg_4]
.text$mn:00003D1C                 push    eax
.text$mn:00003D1D                 mov     ecx, [ebp+arg_0]
.text$mn:00003D20                 push    ecx
.text$mn:00003D21                 call    ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:00003D26                 add     esp, 10h
.text$mn:00003D29                 mov     esp, ebp
.text$mn:00003D2B                 pop     ebp
.text$mn:00003D2C                 retn    0Ch
.text$mn:00003D2C ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z endp
.text$mn:00003D2C
.text$mn:00003D2C ; ---------------------------------------------------------------------------
.text$mn:00003D2F                 align 10h
.text$mn:00003D2F _text$mn        ends
.text$mn:00003D2F
.text$mn:00003D30 ; ===========================================================================
.text$mn:00003D30
.text$mn:00003D30 ; Segment type: Pure code
.text$mn:00003D30 ; Segment permissions: Read/Execute
.text$mn:00003D30 _text$mn        segment para public 'CODE' use32
.text$mn:00003D30                 assume cs:_text$mn
.text$mn:00003D30                 ;org 3D30h
.text$mn:00003D30 ; COMDAT (pick any)
.text$mn:00003D30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D30
.text$mn:00003D30 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D30
.text$mn:00003D30 ; Attributes: bp-based frame
.text$mn:00003D30
.text$mn:00003D30 ; protected: class PluginCmdShortcut * __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::_Umove<class PluginCmdShortcut *>(class PluginCmdShortcut *, class PluginCmdShortcut *, class PluginCmdShortcut *)
.text$mn:00003D30                 public ??$_Umove@PAVPluginCmdShortcut@@@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEPAVPluginCmdShortcut@@PAV2@00@Z
.text$mn:00003D30 ??$_Umove@PAVPluginCmdShortcut@@@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEPAVPluginCmdShortcut@@PAV2@00@Z proc near
.text$mn:00003D30                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reallocate(uint)+65p
.text$mn:00003D30
.text$mn:00003D30 var_8           = dword ptr -8
.text$mn:00003D30 var_1           = byte ptr -1
.text$mn:00003D30 arg_0           = dword ptr  8
.text$mn:00003D30 arg_4           = dword ptr  0Ch
.text$mn:00003D30 arg_8           = dword ptr  10h
.text$mn:00003D30
.text$mn:00003D30                 push    ebp
.text$mn:00003D31                 mov     ebp, esp
.text$mn:00003D33                 sub     esp, 8
.text$mn:00003D36                 mov     [ebp+var_8], ecx
.text$mn:00003D39                 lea     eax, [ebp+var_1]
.text$mn:00003D3C                 push    eax
.text$mn:00003D3D                 mov     ecx, [ebp+var_8]
.text$mn:00003D40                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>>::_Getal(void)
.text$mn:00003D45                 lea     ecx, [ebp+var_1]
.text$mn:00003D48                 push    ecx
.text$mn:00003D49                 mov     edx, [ebp+arg_8]
.text$mn:00003D4C                 push    edx
.text$mn:00003D4D                 mov     eax, [ebp+arg_4]
.text$mn:00003D50                 push    eax
.text$mn:00003D51                 mov     ecx, [ebp+arg_0]
.text$mn:00003D54                 push    ecx
.text$mn:00003D55                 call    ??$_Uninitialized_move@PAVPluginCmdShortcut@@PAV1@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z ; std::_Uninitialized_move<PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)
.text$mn:00003D5A                 add     esp, 10h
.text$mn:00003D5D                 mov     esp, ebp
.text$mn:00003D5F                 pop     ebp
.text$mn:00003D60                 retn    0Ch
.text$mn:00003D60 ??$_Umove@PAVPluginCmdShortcut@@@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEPAVPluginCmdShortcut@@PAV2@00@Z endp
.text$mn:00003D60
.text$mn:00003D60 ; ---------------------------------------------------------------------------
.text$mn:00003D63                 align 4
.text$mn:00003D63 _text$mn        ends
.text$mn:00003D63
.text$mn:00003D64 ; ===========================================================================
.text$mn:00003D64
.text$mn:00003D64 ; Segment type: Pure code
.text$mn:00003D64 ; Segment permissions: Read/Execute
.text$mn:00003D64 _text$mn        segment para public 'CODE' use32
.text$mn:00003D64                 assume cs:_text$mn
.text$mn:00003D64                 ;org 3D64h
.text$mn:00003D64 ; COMDAT (pick any)
.text$mn:00003D64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D64
.text$mn:00003D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D64
.text$mn:00003D64 ; Attributes: bp-based frame
.text$mn:00003D64
.text$mn:00003D64 ; struct PluginInfo * * __cdecl std::_Unchecked<struct PluginInfo * *>(struct PluginInfo * *)
.text$mn:00003D64                 public ??$_Unchecked@PAPAUPluginInfo@@@std@@YAPAPAUPluginInfo@@PAPAU1@@Z
.text$mn:00003D64 ??$_Unchecked@PAPAUPluginInfo@@@std@@YAPAPAUPluginInfo@@PAPAU1@@Z proc near
.text$mn:00003D64                                         ; CODE XREF: std::_Uninitialized_move<PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)+Bp
.text$mn:00003D64                                         ; std::_Uninitialized_move<PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)+18p ...
.text$mn:00003D64
.text$mn:00003D64 arg_0           = dword ptr  8
.text$mn:00003D64
.text$mn:00003D64                 push    ebp
.text$mn:00003D65                 mov     ebp, esp
.text$mn:00003D67                 mov     eax, [ebp+arg_0]
.text$mn:00003D6A                 pop     ebp
.text$mn:00003D6B                 retn
.text$mn:00003D6B ??$_Unchecked@PAPAUPluginInfo@@@std@@YAPAPAUPluginInfo@@PAPAU1@@Z endp
.text$mn:00003D6B
.text$mn:00003D6B _text$mn        ends
.text$mn:00003D6B
.text$mn:00003D6C ; ===========================================================================
.text$mn:00003D6C
.text$mn:00003D6C ; Segment type: Pure code
.text$mn:00003D6C ; Segment permissions: Read/Execute
.text$mn:00003D6C _text$mn        segment para public 'CODE' use32
.text$mn:00003D6C                 assume cs:_text$mn
.text$mn:00003D6C                 ;org 3D6Ch
.text$mn:00003D6C ; COMDAT (pick any)
.text$mn:00003D6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D6C
.text$mn:00003D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D6C
.text$mn:00003D6C ; Attributes: bp-based frame
.text$mn:00003D6C
.text$mn:00003D6C ; class TiXmlDocument * * __cdecl std::_Unchecked<class TiXmlDocument * *>(class TiXmlDocument * *)
.text$mn:00003D6C                 public ??$_Unchecked@PAPAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@@Z
.text$mn:00003D6C ??$_Unchecked@PAPAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@@Z proc near
.text$mn:00003D6C                                         ; CODE XREF: std::_Uninitialized_move<TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)+Bp
.text$mn:00003D6C                                         ; std::_Uninitialized_move<TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)+18p ...
.text$mn:00003D6C
.text$mn:00003D6C arg_0           = dword ptr  8
.text$mn:00003D6C
.text$mn:00003D6C                 push    ebp
.text$mn:00003D6D                 mov     ebp, esp
.text$mn:00003D6F                 mov     eax, [ebp+arg_0]
.text$mn:00003D72                 pop     ebp
.text$mn:00003D73                 retn
.text$mn:00003D73 ??$_Unchecked@PAPAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@@Z endp
.text$mn:00003D73
.text$mn:00003D73 _text$mn        ends
.text$mn:00003D73
.text$mn:00003D74 ; ===========================================================================
.text$mn:00003D74
.text$mn:00003D74 ; Segment type: Pure code
.text$mn:00003D74 ; Segment permissions: Read/Execute
.text$mn:00003D74 _text$mn        segment para public 'CODE' use32
.text$mn:00003D74                 assume cs:_text$mn
.text$mn:00003D74                 ;org 3D74h
.text$mn:00003D74 ; COMDAT (pick any)
.text$mn:00003D74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D74
.text$mn:00003D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D74
.text$mn:00003D74 ; Attributes: bp-based frame
.text$mn:00003D74
.text$mn:00003D74 ; struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * __cdecl std::_Unchecked<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)
.text$mn:00003D74                 public ??$_Unchecked@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@@Z
.text$mn:00003D74 ??$_Unchecked@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@@Z proc near
.text$mn:00003D74                                         ; CODE XREF: std::_Uninitialized_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)+Bp
.text$mn:00003D74                                         ; std::_Uninitialized_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)+18p ...
.text$mn:00003D74
.text$mn:00003D74 arg_0           = dword ptr  8
.text$mn:00003D74
.text$mn:00003D74                 push    ebp
.text$mn:00003D75                 mov     ebp, esp
.text$mn:00003D77                 mov     eax, [ebp+arg_0]
.text$mn:00003D7A                 pop     ebp
.text$mn:00003D7B                 retn
.text$mn:00003D7B ??$_Unchecked@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@@Z endp
.text$mn:00003D7B
.text$mn:00003D7B _text$mn        ends
.text$mn:00003D7B
.text$mn:00003D7C ; ===========================================================================
.text$mn:00003D7C
.text$mn:00003D7C ; Segment type: Pure code
.text$mn:00003D7C ; Segment permissions: Read/Execute
.text$mn:00003D7C _text$mn        segment para public 'CODE' use32
.text$mn:00003D7C                 assume cs:_text$mn
.text$mn:00003D7C                 ;org 3D7Ch
.text$mn:00003D7C ; COMDAT (pick any)
.text$mn:00003D7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D7C
.text$mn:00003D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D7C
.text$mn:00003D7C ; Attributes: bp-based frame
.text$mn:00003D7C
.text$mn:00003D7C ; struct PluginCommand * __cdecl std::_Unchecked<struct PluginCommand *>(struct PluginCommand *)
.text$mn:00003D7C                 public ??$_Unchecked@PAUPluginCommand@@@std@@YAPAUPluginCommand@@PAU1@@Z
.text$mn:00003D7C ??$_Unchecked@PAUPluginCommand@@@std@@YAPAUPluginCommand@@PAU1@@Z proc near
.text$mn:00003D7C                                         ; CODE XREF: std::_Uninitialized_move<PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)+Bp
.text$mn:00003D7C                                         ; std::_Uninitialized_move<PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)+18p ...
.text$mn:00003D7C
.text$mn:00003D7C arg_0           = dword ptr  8
.text$mn:00003D7C
.text$mn:00003D7C                 push    ebp
.text$mn:00003D7D                 mov     ebp, esp
.text$mn:00003D7F                 mov     eax, [ebp+arg_0]
.text$mn:00003D82                 pop     ebp
.text$mn:00003D83                 retn
.text$mn:00003D83 ??$_Unchecked@PAUPluginCommand@@@std@@YAPAUPluginCommand@@PAU1@@Z endp
.text$mn:00003D83
.text$mn:00003D83 _text$mn        ends
.text$mn:00003D83
.text$mn:00003D84 ; ===========================================================================
.text$mn:00003D84
.text$mn:00003D84 ; Segment type: Pure code
.text$mn:00003D84 ; Segment permissions: Read/Execute
.text$mn:00003D84 _text$mn        segment para public 'CODE' use32
.text$mn:00003D84                 assume cs:_text$mn
.text$mn:00003D84                 ;org 3D84h
.text$mn:00003D84 ; COMDAT (pick any)
.text$mn:00003D84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D84
.text$mn:00003D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D84
.text$mn:00003D84 ; Attributes: bp-based frame
.text$mn:00003D84
.text$mn:00003D84 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Unchecked<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00003D84                 public ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z
.text$mn:00003D84 ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z proc near
.text$mn:00003D84                                         ; CODE XREF: std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+Bp
.text$mn:00003D84                                         ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+18p ...
.text$mn:00003D84
.text$mn:00003D84 arg_0           = dword ptr  8
.text$mn:00003D84
.text$mn:00003D84                 push    ebp
.text$mn:00003D85                 mov     ebp, esp
.text$mn:00003D87                 mov     eax, [ebp+arg_0]
.text$mn:00003D8A                 pop     ebp
.text$mn:00003D8B                 retn
.text$mn:00003D8B ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z endp
.text$mn:00003D8B
.text$mn:00003D8B _text$mn        ends
.text$mn:00003D8B
.text$mn:00003D8C ; ===========================================================================
.text$mn:00003D8C
.text$mn:00003D8C ; Segment type: Pure code
.text$mn:00003D8C ; Segment permissions: Read/Execute
.text$mn:00003D8C _text$mn        segment para public 'CODE' use32
.text$mn:00003D8C                 assume cs:_text$mn
.text$mn:00003D8C                 ;org 3D8Ch
.text$mn:00003D8C ; COMDAT (pick any)
.text$mn:00003D8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D8C
.text$mn:00003D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D8C
.text$mn:00003D8C ; Attributes: bp-based frame
.text$mn:00003D8C
.text$mn:00003D8C ; class PluginCmdShortcut * __cdecl std::_Unchecked<class PluginCmdShortcut *>(class PluginCmdShortcut *)
.text$mn:00003D8C                 public ??$_Unchecked@PAVPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@PAV1@@Z
.text$mn:00003D8C ??$_Unchecked@PAVPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@PAV1@@Z proc near
.text$mn:00003D8C                                         ; CODE XREF: std::_Uninitialized_move<PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)+Bp
.text$mn:00003D8C                                         ; std::_Uninitialized_move<PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)+18p ...
.text$mn:00003D8C
.text$mn:00003D8C arg_0           = dword ptr  8
.text$mn:00003D8C
.text$mn:00003D8C                 push    ebp
.text$mn:00003D8D                 mov     ebp, esp
.text$mn:00003D8F                 mov     eax, [ebp+arg_0]
.text$mn:00003D92                 pop     ebp
.text$mn:00003D93                 retn
.text$mn:00003D93 ??$_Unchecked@PAVPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@PAV1@@Z endp
.text$mn:00003D93
.text$mn:00003D93 _text$mn        ends
.text$mn:00003D93
.text$mn:00003D94 ; ===========================================================================
.text$mn:00003D94
.text$mn:00003D94 ; Segment type: Pure code
.text$mn:00003D94 ; Segment permissions: Read/Execute
.text$mn:00003D94 _text$mn        segment para public 'CODE' use32
.text$mn:00003D94                 assume cs:_text$mn
.text$mn:00003D94                 ;org 3D94h
.text$mn:00003D94 ; COMDAT (pick any)
.text$mn:00003D94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D94
.text$mn:00003D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D94
.text$mn:00003D94 ; Attributes: bp-based frame
.text$mn:00003D94
.text$mn:00003D94 ; int __cdecl std::_Uninit_move<PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>>>(void *Src, int, void *Dst, int)
.text$mn:00003D94                 public ??$_Uninit_move@PAPAUPluginInfo@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z
.text$mn:00003D94 ??$_Uninit_move@PAPAUPluginInfo@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z proc near
.text$mn:00003D94                                         ; CODE XREF: std::_Uninitialized_move<PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)+2Ep
.text$mn:00003D94
.text$mn:00003D94 var_1           = byte ptr -1
.text$mn:00003D94 Src             = dword ptr  8
.text$mn:00003D94 arg_4           = dword ptr  0Ch
.text$mn:00003D94 Dst             = dword ptr  10h
.text$mn:00003D94 arg_C           = dword ptr  14h
.text$mn:00003D94
.text$mn:00003D94                 push    ebp
.text$mn:00003D95                 mov     ebp, esp
.text$mn:00003D97                 push    ecx
.text$mn:00003D98                 mov     eax, [ebp+Dst]
.text$mn:00003D9B                 push    eax
.text$mn:00003D9C                 mov     ecx, [ebp+Src]
.text$mn:00003D9F                 push    ecx
.text$mn:00003DA0                 call    ??$_Ptr_cat@PAUPluginInfo@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUPluginInfo@@0@Z ; std::_Ptr_cat<PluginInfo *,PluginInfo *>(PluginInfo * *,PluginInfo * *)
.text$mn:00003DA5                 add     esp, 8
.text$mn:00003DA8                 mov     [ebp+var_1], al
.text$mn:00003DAB                 movzx   edx, [ebp+var_1]
.text$mn:00003DAF                 push    edx
.text$mn:00003DB0                 mov     eax, [ebp+Src]
.text$mn:00003DB3                 push    eax
.text$mn:00003DB4                 call    ??$_Val_type@PAPAUPluginInfo@@@std@@YAPAPAUPluginInfo@@PAPAU1@@Z ; std::_Val_type<PluginInfo * *>(PluginInfo * *)
.text$mn:00003DB9                 add     esp, 4
.text$mn:00003DBC                 push    eax
.text$mn:00003DBD                 mov     ecx, [ebp+arg_C]
.text$mn:00003DC0                 push    ecx
.text$mn:00003DC1                 mov     edx, [ebp+Dst]
.text$mn:00003DC4                 push    edx             ; Dst
.text$mn:00003DC5                 mov     eax, [ebp+arg_4]
.text$mn:00003DC8                 push    eax             ; int
.text$mn:00003DC9                 mov     ecx, [ebp+Src]
.text$mn:00003DCC                 push    ecx             ; Src
.text$mn:00003DCD                 call    ??$_Uninit_move@PAUPluginInfo@@PAU1@PAU1@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PluginInfo *,PluginInfo *,PluginInfo *>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &,PluginInfo * *,std::_Scalar_ptr_iterator_tag)
.text$mn:00003DD2                 add     esp, 18h
.text$mn:00003DD5                 mov     esp, ebp
.text$mn:00003DD7                 pop     ebp
.text$mn:00003DD8                 retn
.text$mn:00003DD8 ??$_Uninit_move@PAPAUPluginInfo@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z endp
.text$mn:00003DD8
.text$mn:00003DD8 ; ---------------------------------------------------------------------------
.text$mn:00003DD9                 align 4
.text$mn:00003DD9 _text$mn        ends
.text$mn:00003DD9
.text$mn:00003DDC ; ===========================================================================
.text$mn:00003DDC
.text$mn:00003DDC ; Segment type: Pure code
.text$mn:00003DDC ; Segment permissions: Read/Execute
.text$mn:00003DDC _text$mn        segment para public 'CODE' use32
.text$mn:00003DDC                 assume cs:_text$mn
.text$mn:00003DDC                 ;org 3DDCh
.text$mn:00003DDC ; COMDAT (pick any)
.text$mn:00003DDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DDC
.text$mn:00003DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DDC
.text$mn:00003DDC ; Attributes: bp-based frame
.text$mn:00003DDC
.text$mn:00003DDC ; int __cdecl std::_Uninit_move<TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(void *Src, int, void *Dst, int)
.text$mn:00003DDC                 public ??$_Uninit_move@PAPAVTiXmlDocument@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z
.text$mn:00003DDC ??$_Uninit_move@PAPAVTiXmlDocument@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z proc near
.text$mn:00003DDC                                         ; CODE XREF: std::_Uninitialized_move<TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)+2Ep
.text$mn:00003DDC
.text$mn:00003DDC var_1           = byte ptr -1
.text$mn:00003DDC Src             = dword ptr  8
.text$mn:00003DDC arg_4           = dword ptr  0Ch
.text$mn:00003DDC Dst             = dword ptr  10h
.text$mn:00003DDC arg_C           = dword ptr  14h
.text$mn:00003DDC
.text$mn:00003DDC                 push    ebp
.text$mn:00003DDD                 mov     ebp, esp
.text$mn:00003DDF                 push    ecx
.text$mn:00003DE0                 mov     eax, [ebp+Dst]
.text$mn:00003DE3                 push    eax
.text$mn:00003DE4                 mov     ecx, [ebp+Src]
.text$mn:00003DE7                 push    ecx
.text$mn:00003DE8                 call    ??$_Ptr_cat@PAVTiXmlDocument@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVTiXmlDocument@@0@Z ; std::_Ptr_cat<TiXmlDocument *,TiXmlDocument *>(TiXmlDocument * *,TiXmlDocument * *)
.text$mn:00003DED                 add     esp, 8
.text$mn:00003DF0                 mov     [ebp+var_1], al
.text$mn:00003DF3                 movzx   edx, [ebp+var_1]
.text$mn:00003DF7                 push    edx
.text$mn:00003DF8                 mov     eax, [ebp+Src]
.text$mn:00003DFB                 push    eax
.text$mn:00003DFC                 call    ??$_Val_type@PAPAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@@Z ; std::_Val_type<TiXmlDocument * *>(TiXmlDocument * *)
.text$mn:00003E01                 add     esp, 4
.text$mn:00003E04                 push    eax
.text$mn:00003E05                 mov     ecx, [ebp+arg_C]
.text$mn:00003E08                 push    ecx
.text$mn:00003E09                 mov     edx, [ebp+Dst]
.text$mn:00003E0C                 push    edx             ; Dst
.text$mn:00003E0D                 mov     eax, [ebp+arg_4]
.text$mn:00003E10                 push    eax             ; int
.text$mn:00003E11                 mov     ecx, [ebp+Src]
.text$mn:00003E14                 push    ecx             ; Src
.text$mn:00003E15                 call    ??$_Uninit_move@PAVTiXmlDocument@@PAV1@PAV1@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<TiXmlDocument *,TiXmlDocument *,TiXmlDocument *>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &,TiXmlDocument * *,std::_Scalar_ptr_iterator_tag)
.text$mn:00003E1A                 add     esp, 18h
.text$mn:00003E1D                 mov     esp, ebp
.text$mn:00003E1F                 pop     ebp
.text$mn:00003E20                 retn
.text$mn:00003E20 ??$_Uninit_move@PAPAVTiXmlDocument@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z endp
.text$mn:00003E20
.text$mn:00003E20 ; ---------------------------------------------------------------------------
.text$mn:00003E21                 align 4
.text$mn:00003E21 _text$mn        ends
.text$mn:00003E21
.text$mn:00003E24 ; ===========================================================================
.text$mn:00003E24
.text$mn:00003E24 ; Segment type: Pure code
.text$mn:00003E24 ; Segment permissions: Read/Execute
.text$mn:00003E24 _text$mn        segment para public 'CODE' use32
.text$mn:00003E24                 assume cs:_text$mn
.text$mn:00003E24                 ;org 3E24h
.text$mn:00003E24 ; COMDAT (pick any)
.text$mn:00003E24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E24
.text$mn:00003E24 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E24
.text$mn:00003E24 ; Attributes: bp-based frame
.text$mn:00003E24
.text$mn:00003E24 ; int __cdecl std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(int, int, void *, int)
.text$mn:00003E24                 public ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z
.text$mn:00003E24 ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z proc near
.text$mn:00003E24                                         ; CODE XREF: std::_Uninitialized_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)+2Ep
.text$mn:00003E24
.text$mn:00003E24 var_1           = byte ptr -1
.text$mn:00003E24 arg_0           = dword ptr  8
.text$mn:00003E24 arg_4           = dword ptr  0Ch
.text$mn:00003E24 arg_8           = dword ptr  10h
.text$mn:00003E24 arg_C           = dword ptr  14h
.text$mn:00003E24
.text$mn:00003E24                 push    ebp
.text$mn:00003E25                 mov     ebp, esp
.text$mn:00003E27                 push    ecx
.text$mn:00003E28                 mov     eax, [ebp+arg_8]
.text$mn:00003E2B                 push    eax
.text$mn:00003E2C                 mov     ecx, [ebp+arg_0]
.text$mn:00003E2F                 push    ecx
.text$mn:00003E30                 call    ??$_Ptr_cat@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0@Z ; std::_Ptr_cat<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:00003E35                 add     esp, 8
.text$mn:00003E38                 mov     [ebp+var_1], al
.text$mn:00003E3B                 movzx   edx, [ebp+var_1]
.text$mn:00003E3F                 push    edx
.text$mn:00003E40                 mov     eax, [ebp+arg_0]
.text$mn:00003E43                 push    eax
.text$mn:00003E44                 call    ??$_Val_type@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@@Z ; std::_Val_type<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:00003E49                 add     esp, 4
.text$mn:00003E4C                 push    eax
.text$mn:00003E4D                 mov     ecx, [ebp+arg_C]
.text$mn:00003E50                 push    ecx             ; int
.text$mn:00003E51                 mov     edx, [ebp+arg_8]
.text$mn:00003E54                 push    edx             ; void *
.text$mn:00003E55                 mov     eax, [ebp+arg_4]
.text$mn:00003E58                 push    eax             ; int
.text$mn:00003E59                 mov     ecx, [ebp+arg_0]
.text$mn:00003E5C                 push    ecx             ; int
.text$mn:00003E5D                 call    ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003E62                 add     esp, 18h
.text$mn:00003E65                 mov     esp, ebp
.text$mn:00003E67                 pop     ebp
.text$mn:00003E68                 retn
.text$mn:00003E68 ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z endp
.text$mn:00003E68
.text$mn:00003E68 ; ---------------------------------------------------------------------------
.text$mn:00003E69                 align 4
.text$mn:00003E69 _text$mn        ends
.text$mn:00003E69
.text$mn:00003E6C ; ===========================================================================
.text$mn:00003E6C
.text$mn:00003E6C ; Segment type: Pure code
.text$mn:00003E6C ; Segment permissions: Read/Execute
.text$mn:00003E6C _text$mn        segment para public 'CODE' use32
.text$mn:00003E6C                 assume cs:_text$mn
.text$mn:00003E6C                 ;org 3E6Ch
.text$mn:00003E6C ; COMDAT (pick any)
.text$mn:00003E6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E6C
.text$mn:00003E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E6C
.text$mn:00003E6C ; Attributes: bp-based frame
.text$mn:00003E6C
.text$mn:00003E6C ; int __cdecl std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(int, int, void *, int)
.text$mn:00003E6C                 public ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003E6C ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003E6C                                         ; CODE XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)+39p
.text$mn:00003E6C
.text$mn:00003E6C var_14          = dword ptr -14h
.text$mn:00003E6C var_10          = dword ptr -10h
.text$mn:00003E6C var_C           = dword ptr -0Ch
.text$mn:00003E6C var_4           = dword ptr -4
.text$mn:00003E6C arg_0           = dword ptr  8
.text$mn:00003E6C arg_4           = dword ptr  0Ch
.text$mn:00003E6C arg_8           = dword ptr  10h
.text$mn:00003E6C arg_C           = dword ptr  14h
.text$mn:00003E6C
.text$mn:00003E6C ; FUNCTION CHUNK AT .text$mn:00003F33 SIZE 00000009 BYTES
.text$mn:00003E6C ; FUNCTION CHUNK AT .text$mn:00003F43 SIZE 00000015 BYTES
.text$mn:00003E6C
.text$mn:00003E6C                 push    ebp
.text$mn:00003E6D                 mov     ebp, esp
.text$mn:00003E6F                 push    0FFFFFFFFh
.text$mn:00003E71                 push    offset __ehhandler$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003E76                 mov     eax, large fs:0
.text$mn:00003E7C                 push    eax
.text$mn:00003E7D                 push    ecx
.text$mn:00003E7E                 push    ecx
.text$mn:00003E7F                 push    ebx
.text$mn:00003E80                 push    esi
.text$mn:00003E81                 push    edi
.text$mn:00003E82                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E87                 xor     eax, ebp
.text$mn:00003E89                 push    eax
.text$mn:00003E8A                 lea     eax, [ebp+var_C]
.text$mn:00003E8D                 mov     large fs:0, eax
.text$mn:00003E93                 mov     [ebp+var_10], esp
.text$mn:00003E96                 push    1B6h            ; unsigned int
.text$mn:00003E9B                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003EA0                 mov     eax, [ebp+arg_4]
.text$mn:00003EA3                 push    eax             ; int
.text$mn:00003EA4                 mov     ecx, [ebp+arg_0]
.text$mn:00003EA7                 push    ecx             ; int
.text$mn:00003EA8                 call    ??$_Debug_range@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0PB_WI@Z ; std::_Debug_range<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint)
.text$mn:00003EAD                 add     esp, 10h
.text$mn:00003EB0                 push    1B7h            ; unsigned int
.text$mn:00003EB5                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003EBA                 mov     edx, [ebp+arg_8]
.text$mn:00003EBD                 push    edx             ; int
.text$mn:00003EBE                 call    ??$_Debug_pointer@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PB_WI@Z ; std::_Debug_pointer<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,wchar_t const *,uint)
.text$mn:00003EC3                 add     esp, 0Ch
.text$mn:00003EC6                 mov     eax, [ebp+arg_8]
.text$mn:00003EC9                 mov     [ebp+var_14], eax
.text$mn:00003ECC                 mov     [ebp+var_4], 0
.text$mn:00003ED3                 jmp     short loc_3EE7
.text$mn:00003ED5 ; ---------------------------------------------------------------------------
.text$mn:00003ED5
.text$mn:00003ED5 loc_3ED5:                               ; CODE XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00003ED5                 mov     ecx, [ebp+arg_8]
.text$mn:00003ED8                 add     ecx, 20h ; ' '
.text$mn:00003EDB                 mov     [ebp+arg_8], ecx
.text$mn:00003EDE                 mov     edx, [ebp+arg_0]
.text$mn:00003EE1                 add     edx, 20h ; ' '
.text$mn:00003EE4                 mov     [ebp+arg_0], edx
.text$mn:00003EE7
.text$mn:00003EE7 loc_3EE7:                               ; CODE XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00003EE7                 mov     eax, [ebp+arg_0]
.text$mn:00003EEA                 cmp     eax, [ebp+arg_4]
.text$mn:00003EED                 jz      short loc_3F01
.text$mn:00003EEF                 mov     ecx, [ebp+arg_0]
.text$mn:00003EF2                 push    ecx             ; int
.text$mn:00003EF3                 mov     edx, [ebp+arg_8]
.text$mn:00003EF6                 push    edx             ; void *
.text$mn:00003EF7                 mov     ecx, [ebp+arg_C]
.text$mn:00003EFA                 call    ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)
.text$mn:00003EFF                 jmp     short loc_3ED5
.text$mn:00003F01 ; ---------------------------------------------------------------------------
.text$mn:00003F01
.text$mn:00003F01 loc_3F01:                               ; CODE XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00003F01                 jmp     short loc_3F33
.text$mn:00003F01 ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003F01
.text$mn:00003F03
.text$mn:00003F03 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F03
.text$mn:00003F03 ; Attributes: noreturn
.text$mn:00003F03
.text$mn:00003F03 __catch$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00003F03                                         ; DATA XREF: .xdata$x:0000D870o
.text$mn:00003F03                 jmp     short loc_3F0E
.text$mn:00003F05 ; ---------------------------------------------------------------------------
.text$mn:00003F05
.text$mn:00003F05 loc_3F05:                               ; CODE XREF: __catch$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00003F05                 mov     eax, [ebp-14h]
.text$mn:00003F08                 add     eax, 20h ; ' '
.text$mn:00003F0B                 mov     [ebp-14h], eax
.text$mn:00003F0E
.text$mn:00003F0E loc_3F0E:                               ; CODE XREF: __catch$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00003F0E                 mov     ecx, [ebp-14h]
.text$mn:00003F11                 cmp     ecx, [ebp+10h]
.text$mn:00003F14                 jz      short loc_3F24
.text$mn:00003F16                 mov     edx, [ebp-14h]
.text$mn:00003F19                 push    edx
.text$mn:00003F1A                 mov     ecx, [ebp+14h]
.text$mn:00003F1D                 call    ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:00003F22                 jmp     short loc_3F05
.text$mn:00003F24 ; ---------------------------------------------------------------------------
.text$mn:00003F24
.text$mn:00003F24 loc_3F24:                               ; CODE XREF: __catch$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00003F24                 push    0
.text$mn:00003F26                 push    0
.text$mn:00003F28                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003F28 __catch$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00003F28
.text$mn:00003F2D ; ---------------------------------------------------------------------------
.text$mn:00003F2D                 mov     eax, offset $LN13_3
.text$mn:00003F32                 retn
.text$mn:00003F33 ; ---------------------------------------------------------------------------
.text$mn:00003F33 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003F33
.text$mn:00003F33 loc_3F33:                               ; CODE XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag):loc_3F01j
.text$mn:00003F33                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F3A                 jmp     short loc_3F43
.text$mn:00003F3A ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003F3C
.text$mn:00003F3C ; =============== S U B R O U T I N E =======================================
.text$mn:00003F3C
.text$mn:00003F3C
.text$mn:00003F3C $LN13_3         proc near               ; DATA XREF: .text$mn:00003F2Do
.text$mn:00003F3C                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003F3C $LN13_3         endp ; sp-analysis failed
.text$mn:00003F3C
.text$mn:00003F43 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003F43
.text$mn:00003F43 loc_3F43:                               ; CODE XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00003F43                 mov     eax, [ebp+arg_8]
.text$mn:00003F46                 mov     ecx, [ebp+var_C]
.text$mn:00003F49                 mov     large fs:0, ecx
.text$mn:00003F50                 pop     ecx
.text$mn:00003F51                 pop     edi
.text$mn:00003F52                 pop     esi
.text$mn:00003F53                 pop     ebx
.text$mn:00003F54                 mov     esp, ebp
.text$mn:00003F56                 pop     ebp
.text$mn:00003F57                 retn
.text$mn:00003F57 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003F57 _text$mn        ends
.text$mn:00003F57
.text$x:00003F58 ; ===========================================================================
.text$x:00003F58
.text$x:00003F58 ; Segment type: Pure code
.text$x:00003F58 ; Segment permissions: Read/Execute
.text$x:00003F58 _text$x         segment para public 'CODE' use32
.text$x:00003F58                 assume cs:_text$x
.text$x:00003F58                 ;org 3F58h
.text$x:00003F58 ; COMDAT (pick associative to section at 3E6C)
.text$x:00003F58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003F58
.text$x:00003F58 ; =============== S U B R O U T I N E =======================================
.text$x:00003F58
.text$x:00003F58
.text$x:00003F58 __ehhandler$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00003F58                                         ; DATA XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00003F58
.text$x:00003F58 arg_4           = dword ptr  8
.text$x:00003F58
.text$x:00003F58                 mov     edx, [esp+arg_4]
.text$x:00003F5C                 lea     eax, [edx+0Ch]
.text$x:00003F5F                 mov     ecx, [edx-18h]
.text$x:00003F62                 xor     ecx, eax
.text$x:00003F64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F69                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00003F6E                 jmp     ___CxxFrameHandler3
.text$x:00003F6E __ehhandler$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00003F6E
.text$x:00003F6E ; ---------------------------------------------------------------------------
.text$x:00003F73                 align 4
.text$x:00003F73 _text$x         ends
.text$x:00003F73
.text$mn:00003F74 ; ===========================================================================
.text$mn:00003F74
.text$mn:00003F74 ; Segment type: Pure code
.text$mn:00003F74 ; Segment permissions: Read/Execute
.text$mn:00003F74 _text$mn        segment para public 'CODE' use32
.text$mn:00003F74                 assume cs:_text$mn
.text$mn:00003F74                 ;org 3F74h
.text$mn:00003F74 ; COMDAT (pick any)
.text$mn:00003F74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003F74
.text$mn:00003F74 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F74
.text$mn:00003F74 ; Attributes: bp-based frame
.text$mn:00003F74
.text$mn:00003F74 ; int __cdecl std::_Uninit_move<PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>>>(int, int, void *, int)
.text$mn:00003F74                 public ??$_Uninit_move@PAUPluginCommand@@PAU1@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z
.text$mn:00003F74 ??$_Uninit_move@PAUPluginCommand@@PAU1@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z proc near
.text$mn:00003F74                                         ; CODE XREF: std::_Uninitialized_move<PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)+2Ep
.text$mn:00003F74
.text$mn:00003F74 var_1           = byte ptr -1
.text$mn:00003F74 arg_0           = dword ptr  8
.text$mn:00003F74 arg_4           = dword ptr  0Ch
.text$mn:00003F74 arg_8           = dword ptr  10h
.text$mn:00003F74 arg_C           = dword ptr  14h
.text$mn:00003F74
.text$mn:00003F74                 push    ebp
.text$mn:00003F75                 mov     ebp, esp
.text$mn:00003F77                 push    ecx
.text$mn:00003F78                 mov     eax, [ebp+arg_8]
.text$mn:00003F7B                 push    eax
.text$mn:00003F7C                 mov     ecx, [ebp+arg_0]
.text$mn:00003F7F                 push    ecx
.text$mn:00003F80                 call    ??$_Ptr_cat@UPluginCommand@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUPluginCommand@@0@Z ; std::_Ptr_cat<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand *)
.text$mn:00003F85                 add     esp, 8
.text$mn:00003F88                 mov     [ebp+var_1], al
.text$mn:00003F8B                 movzx   edx, [ebp+var_1]
.text$mn:00003F8F                 push    edx
.text$mn:00003F90                 mov     eax, [ebp+arg_0]
.text$mn:00003F93                 push    eax
.text$mn:00003F94                 call    ??$_Val_type@PAUPluginCommand@@@std@@YAPAUPluginCommand@@PAU1@@Z ; std::_Val_type<PluginCommand *>(PluginCommand *)
.text$mn:00003F99                 add     esp, 4
.text$mn:00003F9C                 push    eax
.text$mn:00003F9D                 mov     ecx, [ebp+arg_C]
.text$mn:00003FA0                 push    ecx             ; int
.text$mn:00003FA1                 mov     edx, [ebp+arg_8]
.text$mn:00003FA4                 push    edx             ; void *
.text$mn:00003FA5                 mov     eax, [ebp+arg_4]
.text$mn:00003FA8                 push    eax             ; int
.text$mn:00003FA9                 mov     ecx, [ebp+arg_0]
.text$mn:00003FAC                 push    ecx             ; int
.text$mn:00003FAD                 call    ??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PluginCommand *,PluginCommand *,std::allocator<PluginCommand>,PluginCommand>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,PluginCommand *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00003FB2                 add     esp, 18h
.text$mn:00003FB5                 mov     esp, ebp
.text$mn:00003FB7                 pop     ebp
.text$mn:00003FB8                 retn
.text$mn:00003FB8 ??$_Uninit_move@PAUPluginCommand@@PAU1@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z endp
.text$mn:00003FB8
.text$mn:00003FB8 ; ---------------------------------------------------------------------------
.text$mn:00003FB9                 align 4
.text$mn:00003FB9 _text$mn        ends
.text$mn:00003FB9
.text$mn:00003FBC ; ===========================================================================
.text$mn:00003FBC
.text$mn:00003FBC ; Segment type: Pure code
.text$mn:00003FBC ; Segment permissions: Read/Execute
.text$mn:00003FBC _text$mn        segment para public 'CODE' use32
.text$mn:00003FBC                 assume cs:_text$mn
.text$mn:00003FBC                 ;org 3FBCh
.text$mn:00003FBC ; COMDAT (pick any)
.text$mn:00003FBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003FBC
.text$mn:00003FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00003FBC
.text$mn:00003FBC ; Attributes: bp-based frame
.text$mn:00003FBC
.text$mn:00003FBC ; int __cdecl std::_Uninit_move<PluginCommand *,PluginCommand *,std::allocator<PluginCommand>,PluginCommand>(int, int, void *, int)
.text$mn:00003FBC                 public ??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003FBC ??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003FBC                                         ; CODE XREF: std::_Uninit_move<PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)+39p
.text$mn:00003FBC
.text$mn:00003FBC var_14          = dword ptr -14h
.text$mn:00003FBC var_10          = dword ptr -10h
.text$mn:00003FBC var_C           = dword ptr -0Ch
.text$mn:00003FBC var_4           = dword ptr -4
.text$mn:00003FBC arg_0           = dword ptr  8
.text$mn:00003FBC arg_4           = dword ptr  0Ch
.text$mn:00003FBC arg_8           = dword ptr  10h
.text$mn:00003FBC arg_C           = dword ptr  14h
.text$mn:00003FBC
.text$mn:00003FBC ; FUNCTION CHUNK AT .text$mn:00004083 SIZE 00000009 BYTES
.text$mn:00003FBC ; FUNCTION CHUNK AT .text$mn:00004093 SIZE 00000015 BYTES
.text$mn:00003FBC
.text$mn:00003FBC                 push    ebp
.text$mn:00003FBD                 mov     ebp, esp
.text$mn:00003FBF                 push    0FFFFFFFFh
.text$mn:00003FC1                 push    offset __ehhandler$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003FC6                 mov     eax, large fs:0
.text$mn:00003FCC                 push    eax
.text$mn:00003FCD                 push    ecx
.text$mn:00003FCE                 push    ecx
.text$mn:00003FCF                 push    ebx
.text$mn:00003FD0                 push    esi
.text$mn:00003FD1                 push    edi
.text$mn:00003FD2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FD7                 xor     eax, ebp
.text$mn:00003FD9                 push    eax
.text$mn:00003FDA                 lea     eax, [ebp+var_C]
.text$mn:00003FDD                 mov     large fs:0, eax
.text$mn:00003FE3                 mov     [ebp+var_10], esp
.text$mn:00003FE6                 push    1B6h            ; unsigned int
.text$mn:00003FEB                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003FF0                 mov     eax, [ebp+arg_4]
.text$mn:00003FF3                 push    eax             ; int
.text$mn:00003FF4                 mov     ecx, [ebp+arg_0]
.text$mn:00003FF7                 push    ecx             ; int
.text$mn:00003FF8                 call    ??$_Debug_range@PAUPluginCommand@@@std@@YAXPAUPluginCommand@@0PB_WI@Z ; std::_Debug_range<PluginCommand *>(PluginCommand *,PluginCommand *,wchar_t const *,uint)
.text$mn:00003FFD                 add     esp, 10h
.text$mn:00004000                 push    1B7h            ; unsigned int
.text$mn:00004005                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000400A                 mov     edx, [ebp+arg_8]
.text$mn:0000400D                 push    edx             ; int
.text$mn:0000400E                 call    ??$_Debug_pointer@UPluginCommand@@@std@@YAXPAUPluginCommand@@PB_WI@Z ; std::_Debug_pointer<PluginCommand>(PluginCommand *,wchar_t const *,uint)
.text$mn:00004013                 add     esp, 0Ch
.text$mn:00004016                 mov     eax, [ebp+arg_8]
.text$mn:00004019                 mov     [ebp+var_14], eax
.text$mn:0000401C                 mov     [ebp+var_4], 0
.text$mn:00004023                 jmp     short loc_4037
.text$mn:00004025 ; ---------------------------------------------------------------------------
.text$mn:00004025
.text$mn:00004025 loc_4025:                               ; CODE XREF: std::_Uninit_move<PluginCommand *,PluginCommand *,std::allocator<PluginCommand>,PluginCommand>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,PluginCommand *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00004025                 mov     ecx, [ebp+arg_8]
.text$mn:00004028                 add     ecx, 24h ; '$'
.text$mn:0000402B                 mov     [ebp+arg_8], ecx
.text$mn:0000402E                 mov     edx, [ebp+arg_0]
.text$mn:00004031                 add     edx, 24h ; '$'
.text$mn:00004034                 mov     [ebp+arg_0], edx
.text$mn:00004037
.text$mn:00004037 loc_4037:                               ; CODE XREF: std::_Uninit_move<PluginCommand *,PluginCommand *,std::allocator<PluginCommand>,PluginCommand>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,PluginCommand *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00004037                 mov     eax, [ebp+arg_0]
.text$mn:0000403A                 cmp     eax, [ebp+arg_4]
.text$mn:0000403D                 jz      short loc_4051
.text$mn:0000403F                 mov     ecx, [ebp+arg_0]
.text$mn:00004042                 push    ecx             ; int
.text$mn:00004043                 mov     edx, [ebp+arg_8]
.text$mn:00004046                 push    edx             ; void *
.text$mn:00004047                 mov     ecx, [ebp+arg_C]
.text$mn:0000404A                 call    ??$construct@UPluginCommand@@U1@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<PluginCommand>>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)
.text$mn:0000404F                 jmp     short loc_4025
.text$mn:00004051 ; ---------------------------------------------------------------------------
.text$mn:00004051
.text$mn:00004051 loc_4051:                               ; CODE XREF: std::_Uninit_move<PluginCommand *,PluginCommand *,std::allocator<PluginCommand>,PluginCommand>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,PluginCommand *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00004051                 jmp     short loc_4083
.text$mn:00004051 ??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004051
.text$mn:00004053
.text$mn:00004053 ; =============== S U B R O U T I N E =======================================
.text$mn:00004053
.text$mn:00004053 ; Attributes: noreturn
.text$mn:00004053
.text$mn:00004053 __catch$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00004053                                         ; DATA XREF: .xdata$x:0000D920o
.text$mn:00004053                 jmp     short loc_405E
.text$mn:00004055 ; ---------------------------------------------------------------------------
.text$mn:00004055
.text$mn:00004055 loc_4055:                               ; CODE XREF: __catch$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00004055                 mov     eax, [ebp-14h]
.text$mn:00004058                 add     eax, 24h ; '$'
.text$mn:0000405B                 mov     [ebp-14h], eax
.text$mn:0000405E
.text$mn:0000405E loc_405E:                               ; CODE XREF: __catch$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:0000405E                 mov     ecx, [ebp-14h]
.text$mn:00004061                 cmp     ecx, [ebp+10h]
.text$mn:00004064                 jz      short loc_4074
.text$mn:00004066                 mov     edx, [ebp-14h]
.text$mn:00004069                 push    edx
.text$mn:0000406A                 mov     ecx, [ebp+14h]
.text$mn:0000406D                 call    ??$destroy@UPluginCommand@@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@@Z ; std::_Wrap_alloc<std::allocator<PluginCommand>>::destroy<PluginCommand>(PluginCommand *)
.text$mn:00004072                 jmp     short loc_4055
.text$mn:00004074 ; ---------------------------------------------------------------------------
.text$mn:00004074
.text$mn:00004074 loc_4074:                               ; CODE XREF: __catch$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00004074                 push    0
.text$mn:00004076                 push    0
.text$mn:00004078                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00004078 __catch$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00004078
.text$mn:0000407D ; ---------------------------------------------------------------------------
.text$mn:0000407D                 mov     eax, offset $LN13_5
.text$mn:00004082                 retn
.text$mn:00004083 ; ---------------------------------------------------------------------------
.text$mn:00004083 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004083
.text$mn:00004083 loc_4083:                               ; CODE XREF: std::_Uninit_move<PluginCommand *,PluginCommand *,std::allocator<PluginCommand>,PluginCommand>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,PluginCommand *,std::_Nonscalar_ptr_iterator_tag):loc_4051j
.text$mn:00004083                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000408A                 jmp     short loc_4093
.text$mn:0000408A ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000408C
.text$mn:0000408C ; =============== S U B R O U T I N E =======================================
.text$mn:0000408C
.text$mn:0000408C
.text$mn:0000408C $LN13_5         proc near               ; DATA XREF: .text$mn:0000407Do
.text$mn:0000408C                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000408C $LN13_5         endp ; sp-analysis failed
.text$mn:0000408C
.text$mn:00004093 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004093
.text$mn:00004093 loc_4093:                               ; CODE XREF: std::_Uninit_move<PluginCommand *,PluginCommand *,std::allocator<PluginCommand>,PluginCommand>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,PluginCommand *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00004093                 mov     eax, [ebp+arg_8]
.text$mn:00004096                 mov     ecx, [ebp+var_C]
.text$mn:00004099                 mov     large fs:0, ecx
.text$mn:000040A0                 pop     ecx
.text$mn:000040A1                 pop     edi
.text$mn:000040A2                 pop     esi
.text$mn:000040A3                 pop     ebx
.text$mn:000040A4                 mov     esp, ebp
.text$mn:000040A6                 pop     ebp
.text$mn:000040A7                 retn
.text$mn:000040A7 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000040A7 _text$mn        ends
.text$mn:000040A7
.text$x:000040A8 ; ===========================================================================
.text$x:000040A8
.text$x:000040A8 ; Segment type: Pure code
.text$x:000040A8 ; Segment permissions: Read/Execute
.text$x:000040A8 _text$x         segment para public 'CODE' use32
.text$x:000040A8                 assume cs:_text$x
.text$x:000040A8                 ;org 40A8h
.text$x:000040A8 ; COMDAT (pick associative to section at 3FBC)
.text$x:000040A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000040A8
.text$x:000040A8 ; =============== S U B R O U T I N E =======================================
.text$x:000040A8
.text$x:000040A8
.text$x:000040A8 __ehhandler$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:000040A8                                         ; DATA XREF: std::_Uninit_move<PluginCommand *,PluginCommand *,std::allocator<PluginCommand>,PluginCommand>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,PluginCommand *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:000040A8
.text$x:000040A8 arg_4           = dword ptr  8
.text$x:000040A8
.text$x:000040A8                 mov     edx, [esp+arg_4]
.text$x:000040AC                 lea     eax, [edx+0Ch]
.text$x:000040AF                 mov     ecx, [edx-18h]
.text$x:000040B2                 xor     ecx, eax
.text$x:000040B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000040B9                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:000040BE                 jmp     ___CxxFrameHandler3
.text$x:000040BE __ehhandler$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:000040BE
.text$x:000040BE ; ---------------------------------------------------------------------------
.text$x:000040C3                 align 4
.text$x:000040C3 _text$x         ends
.text$x:000040C3
.text$mn:000040C4 ; ===========================================================================
.text$mn:000040C4
.text$mn:000040C4 ; Segment type: Pure code
.text$mn:000040C4 ; Segment permissions: Read/Execute
.text$mn:000040C4 _text$mn        segment para public 'CODE' use32
.text$mn:000040C4                 assume cs:_text$mn
.text$mn:000040C4                 ;org 40C4h
.text$mn:000040C4 ; COMDAT (pick any)
.text$mn:000040C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000040C4
.text$mn:000040C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000040C4
.text$mn:000040C4 ; Attributes: bp-based frame
.text$mn:000040C4
.text$mn:000040C4 ; int __cdecl std::_Uninit_move<PluginInfo *,PluginInfo *,PluginInfo *>(void *Src, int, void *Dst)
.text$mn:000040C4                 public ??$_Uninit_move@PAUPluginInfo@@PAU1@PAU1@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:000040C4 ??$_Uninit_move@PAUPluginInfo@@PAU1@PAU1@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000040C4                                         ; CODE XREF: std::_Uninit_move<PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)+39p
.text$mn:000040C4
.text$mn:000040C4 var_4           = dword ptr -4
.text$mn:000040C4 Src             = dword ptr  8
.text$mn:000040C4 arg_4           = dword ptr  0Ch
.text$mn:000040C4 Dst             = dword ptr  10h
.text$mn:000040C4
.text$mn:000040C4                 push    ebp
.text$mn:000040C5                 mov     ebp, esp
.text$mn:000040C7                 push    ecx
.text$mn:000040C8                 push    1D6h            ; unsigned int
.text$mn:000040CD                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000040D2                 mov     eax, [ebp+arg_4]
.text$mn:000040D5                 push    eax             ; int
.text$mn:000040D6                 mov     ecx, [ebp+Src]
.text$mn:000040D9                 push    ecx             ; int
.text$mn:000040DA                 call    ??$_Debug_range@PAPAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@0PB_WI@Z ; std::_Debug_range<PluginInfo * *>(PluginInfo * *,PluginInfo * *,wchar_t const *,uint)
.text$mn:000040DF                 add     esp, 10h
.text$mn:000040E2                 push    1D7h            ; unsigned int
.text$mn:000040E7                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000040EC                 mov     edx, [ebp+Dst]
.text$mn:000040EF                 push    edx             ; int
.text$mn:000040F0                 call    ??$_Debug_pointer@PAUPluginInfo@@@std@@YAXPAPAUPluginInfo@@PB_WI@Z ; std::_Debug_pointer<PluginInfo *>(PluginInfo * *,wchar_t const *,uint)
.text$mn:000040F5                 add     esp, 0Ch
.text$mn:000040F8                 mov     eax, [ebp+arg_4]
.text$mn:000040FB                 sub     eax, [ebp+Src]
.text$mn:000040FE                 sar     eax, 2
.text$mn:00004101                 mov     [ebp+var_4], eax
.text$mn:00004104                 mov     ecx, [ebp+var_4]
.text$mn:00004107                 shl     ecx, 2
.text$mn:0000410A                 push    ecx             ; Size
.text$mn:0000410B                 mov     edx, [ebp+Src]
.text$mn:0000410E                 push    edx             ; Src
.text$mn:0000410F                 mov     eax, [ebp+Dst]
.text$mn:00004112                 push    eax             ; Dst
.text$mn:00004113                 call    _memmove
.text$mn:00004118                 add     esp, 0Ch
.text$mn:0000411B                 mov     ecx, [ebp+var_4]
.text$mn:0000411E                 lea     eax, [eax+ecx*4]
.text$mn:00004121                 mov     esp, ebp
.text$mn:00004123                 pop     ebp
.text$mn:00004124                 retn
.text$mn:00004124 ??$_Uninit_move@PAUPluginInfo@@PAU1@PAU1@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004124
.text$mn:00004124 ; ---------------------------------------------------------------------------
.text$mn:00004125                 align 4
.text$mn:00004125 _text$mn        ends
.text$mn:00004125
.text$mn:00004128 ; ===========================================================================
.text$mn:00004128
.text$mn:00004128 ; Segment type: Pure code
.text$mn:00004128 ; Segment permissions: Read/Execute
.text$mn:00004128 _text$mn        segment para public 'CODE' use32
.text$mn:00004128                 assume cs:_text$mn
.text$mn:00004128                 ;org 4128h
.text$mn:00004128 ; COMDAT (pick any)
.text$mn:00004128                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004128
.text$mn:00004128 ; =============== S U B R O U T I N E =======================================
.text$mn:00004128
.text$mn:00004128 ; Attributes: bp-based frame
.text$mn:00004128
.text$mn:00004128 ; int __cdecl std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(int, int, void *, int)
.text$mn:00004128                 public ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
.text$mn:00004128 ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z proc near
.text$mn:00004128                                         ; CODE XREF: std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+2Ep
.text$mn:00004128
.text$mn:00004128 var_1           = byte ptr -1
.text$mn:00004128 arg_0           = dword ptr  8
.text$mn:00004128 arg_4           = dword ptr  0Ch
.text$mn:00004128 arg_8           = dword ptr  10h
.text$mn:00004128 arg_C           = dword ptr  14h
.text$mn:00004128
.text$mn:00004128                 push    ebp
.text$mn:00004129                 mov     ebp, esp
.text$mn:0000412B                 push    ecx
.text$mn:0000412C                 mov     eax, [ebp+arg_8]
.text$mn:0000412F                 push    eax
.text$mn:00004130                 mov     ecx, [ebp+arg_0]
.text$mn:00004133                 push    ecx
.text$mn:00004134                 call    ??$_Ptr_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00004139                 add     esp, 8
.text$mn:0000413C                 mov     [ebp+var_1], al
.text$mn:0000413F                 movzx   edx, [ebp+var_1]
.text$mn:00004143                 push    edx
.text$mn:00004144                 mov     eax, [ebp+arg_0]
.text$mn:00004147                 push    eax
.text$mn:00004148                 call    ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Val_type<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000414D                 add     esp, 4
.text$mn:00004150                 push    eax
.text$mn:00004151                 mov     ecx, [ebp+arg_C]
.text$mn:00004154                 push    ecx             ; int
.text$mn:00004155                 mov     edx, [ebp+arg_8]
.text$mn:00004158                 push    edx             ; void *
.text$mn:00004159                 mov     eax, [ebp+arg_4]
.text$mn:0000415C                 push    eax             ; int
.text$mn:0000415D                 mov     ecx, [ebp+arg_0]
.text$mn:00004160                 push    ecx             ; int
.text$mn:00004161                 call    ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00004166                 add     esp, 18h
.text$mn:00004169                 mov     esp, ebp
.text$mn:0000416B                 pop     ebp
.text$mn:0000416C                 retn
.text$mn:0000416C ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z endp
.text$mn:0000416C
.text$mn:0000416C ; ---------------------------------------------------------------------------
.text$mn:0000416D                 align 10h
.text$mn:0000416D _text$mn        ends
.text$mn:0000416D
.text$mn:00004170 ; ===========================================================================
.text$mn:00004170
.text$mn:00004170 ; Segment type: Pure code
.text$mn:00004170 ; Segment permissions: Read/Execute
.text$mn:00004170 _text$mn        segment para public 'CODE' use32
.text$mn:00004170                 assume cs:_text$mn
.text$mn:00004170                 ;org 4170h
.text$mn:00004170 ; COMDAT (pick any)
.text$mn:00004170                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004170
.text$mn:00004170 ; =============== S U B R O U T I N E =======================================
.text$mn:00004170
.text$mn:00004170 ; Attributes: bp-based frame
.text$mn:00004170
.text$mn:00004170 ; int __cdecl std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(int, int, void *, int)
.text$mn:00004170                 public ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004170 ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004170                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+39p
.text$mn:00004170
.text$mn:00004170 var_14          = dword ptr -14h
.text$mn:00004170 var_10          = dword ptr -10h
.text$mn:00004170 var_C           = dword ptr -0Ch
.text$mn:00004170 var_4           = dword ptr -4
.text$mn:00004170 arg_0           = dword ptr  8
.text$mn:00004170 arg_4           = dword ptr  0Ch
.text$mn:00004170 arg_8           = dword ptr  10h
.text$mn:00004170 arg_C           = dword ptr  14h
.text$mn:00004170
.text$mn:00004170 ; FUNCTION CHUNK AT .text$mn:00004237 SIZE 00000009 BYTES
.text$mn:00004170 ; FUNCTION CHUNK AT .text$mn:00004247 SIZE 00000015 BYTES
.text$mn:00004170
.text$mn:00004170                 push    ebp
.text$mn:00004171                 mov     ebp, esp
.text$mn:00004173                 push    0FFFFFFFFh
.text$mn:00004175                 push    offset __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000417A                 mov     eax, large fs:0
.text$mn:00004180                 push    eax
.text$mn:00004181                 push    ecx
.text$mn:00004182                 push    ecx
.text$mn:00004183                 push    ebx
.text$mn:00004184                 push    esi
.text$mn:00004185                 push    edi
.text$mn:00004186                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000418B                 xor     eax, ebp
.text$mn:0000418D                 push    eax
.text$mn:0000418E                 lea     eax, [ebp+var_C]
.text$mn:00004191                 mov     large fs:0, eax
.text$mn:00004197                 mov     [ebp+var_10], esp
.text$mn:0000419A                 push    1B6h            ; unsigned int
.text$mn:0000419F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000041A4                 mov     eax, [ebp+arg_4]
.text$mn:000041A7                 push    eax             ; int
.text$mn:000041A8                 mov     ecx, [ebp+arg_0]
.text$mn:000041AB                 push    ecx             ; int
.text$mn:000041AC                 call    ??$_Debug_range@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0PB_WI@Z ; std::_Debug_range<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:000041B1                 add     esp, 10h
.text$mn:000041B4                 push    1B7h            ; unsigned int
.text$mn:000041B9                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000041BE                 mov     edx, [ebp+arg_8]
.text$mn:000041C1                 push    edx             ; int
.text$mn:000041C2                 call    ??$_Debug_pointer@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WI@Z ; std::_Debug_pointer<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,wchar_t const *,uint)
.text$mn:000041C7                 add     esp, 0Ch
.text$mn:000041CA                 mov     eax, [ebp+arg_8]
.text$mn:000041CD                 mov     [ebp+var_14], eax
.text$mn:000041D0                 mov     [ebp+var_4], 0
.text$mn:000041D7                 jmp     short loc_41EB
.text$mn:000041D9 ; ---------------------------------------------------------------------------
.text$mn:000041D9
.text$mn:000041D9 loc_41D9:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:000041D9                 mov     ecx, [ebp+arg_8]
.text$mn:000041DC                 add     ecx, 1Ch
.text$mn:000041DF                 mov     [ebp+arg_8], ecx
.text$mn:000041E2                 mov     edx, [ebp+arg_0]
.text$mn:000041E5                 add     edx, 1Ch
.text$mn:000041E8                 mov     [ebp+arg_0], edx
.text$mn:000041EB
.text$mn:000041EB loc_41EB:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:000041EB                 mov     eax, [ebp+arg_0]
.text$mn:000041EE                 cmp     eax, [ebp+arg_4]
.text$mn:000041F1                 jz      short loc_4205
.text$mn:000041F3                 mov     ecx, [ebp+arg_0]
.text$mn:000041F6                 push    ecx             ; int
.text$mn:000041F7                 mov     edx, [ebp+arg_8]
.text$mn:000041FA                 push    edx             ; void *
.text$mn:000041FB                 mov     ecx, [ebp+arg_C]
.text$mn:000041FE                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00004203                 jmp     short loc_41D9
.text$mn:00004205 ; ---------------------------------------------------------------------------
.text$mn:00004205
.text$mn:00004205 loc_4205:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00004205                 jmp     short loc_4237
.text$mn:00004205 ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004205
.text$mn:00004207
.text$mn:00004207 ; =============== S U B R O U T I N E =======================================
.text$mn:00004207
.text$mn:00004207 ; Attributes: noreturn
.text$mn:00004207
.text$mn:00004207 __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00004207                                         ; DATA XREF: .xdata$x:0000D818o
.text$mn:00004207                 jmp     short loc_4212
.text$mn:00004209 ; ---------------------------------------------------------------------------
.text$mn:00004209
.text$mn:00004209 loc_4209:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00004209                 mov     eax, [ebp-14h]
.text$mn:0000420C                 add     eax, 1Ch
.text$mn:0000420F                 mov     [ebp-14h], eax
.text$mn:00004212
.text$mn:00004212 loc_4212:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00004212                 mov     ecx, [ebp-14h]
.text$mn:00004215                 cmp     ecx, [ebp+10h]
.text$mn:00004218                 jz      short loc_4228
.text$mn:0000421A                 mov     edx, [ebp-14h]
.text$mn:0000421D                 push    edx
.text$mn:0000421E                 mov     ecx, [ebp+14h]
.text$mn:00004221                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00004226                 jmp     short loc_4209
.text$mn:00004228 ; ---------------------------------------------------------------------------
.text$mn:00004228
.text$mn:00004228 loc_4228:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00004228                 push    0
.text$mn:0000422A                 push    0
.text$mn:0000422C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000422C __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:0000422C
.text$mn:00004231 ; ---------------------------------------------------------------------------
.text$mn:00004231                 mov     eax, offset $LN13_2
.text$mn:00004236                 retn
.text$mn:00004237 ; ---------------------------------------------------------------------------
.text$mn:00004237 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004237
.text$mn:00004237 loc_4237:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag):loc_4205j
.text$mn:00004237                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000423E                 jmp     short loc_4247
.text$mn:0000423E ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004240
.text$mn:00004240 ; =============== S U B R O U T I N E =======================================
.text$mn:00004240
.text$mn:00004240
.text$mn:00004240 $LN13_2         proc near               ; DATA XREF: .text$mn:00004231o
.text$mn:00004240                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00004240 $LN13_2         endp ; sp-analysis failed
.text$mn:00004240
.text$mn:00004247 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004247
.text$mn:00004247 loc_4247:                               ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00004247                 mov     eax, [ebp+arg_8]
.text$mn:0000424A                 mov     ecx, [ebp+var_C]
.text$mn:0000424D                 mov     large fs:0, ecx
.text$mn:00004254                 pop     ecx
.text$mn:00004255                 pop     edi
.text$mn:00004256                 pop     esi
.text$mn:00004257                 pop     ebx
.text$mn:00004258                 mov     esp, ebp
.text$mn:0000425A                 pop     ebp
.text$mn:0000425B                 retn
.text$mn:0000425B ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000425B _text$mn        ends
.text$mn:0000425B
.text$x:0000425C ; ===========================================================================
.text$x:0000425C
.text$x:0000425C ; Segment type: Pure code
.text$x:0000425C ; Segment permissions: Read/Execute
.text$x:0000425C _text$x         segment para public 'CODE' use32
.text$x:0000425C                 assume cs:_text$x
.text$x:0000425C                 ;org 425Ch
.text$x:0000425C ; COMDAT (pick associative to section at 4170)
.text$x:0000425C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000425C
.text$x:0000425C ; =============== S U B R O U T I N E =======================================
.text$x:0000425C
.text$x:0000425C
.text$x:0000425C __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:0000425C                                         ; DATA XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:0000425C
.text$x:0000425C arg_4           = dword ptr  8
.text$x:0000425C
.text$x:0000425C                 mov     edx, [esp+arg_4]
.text$x:00004260                 lea     eax, [edx+0Ch]
.text$x:00004263                 mov     ecx, [edx-18h]
.text$x:00004266                 xor     ecx, eax
.text$x:00004268                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000426D                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00004272                 jmp     ___CxxFrameHandler3
.text$x:00004272 __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00004272
.text$x:00004272 ; ---------------------------------------------------------------------------
.text$x:00004277                 align 4
.text$x:00004277 _text$x         ends
.text$x:00004277
.text$mn:00004278 ; ===========================================================================
.text$mn:00004278
.text$mn:00004278 ; Segment type: Pure code
.text$mn:00004278 ; Segment permissions: Read/Execute
.text$mn:00004278 _text$mn        segment para public 'CODE' use32
.text$mn:00004278                 assume cs:_text$mn
.text$mn:00004278                 ;org 4278h
.text$mn:00004278 ; COMDAT (pick any)
.text$mn:00004278                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004278
.text$mn:00004278 ; =============== S U B R O U T I N E =======================================
.text$mn:00004278
.text$mn:00004278 ; Attributes: bp-based frame
.text$mn:00004278
.text$mn:00004278 ; int __cdecl std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(int, int, void *, int)
.text$mn:00004278                 public ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z
.text$mn:00004278 ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z proc near
.text$mn:00004278                                         ; CODE XREF: std::_Uninitialized_move<PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)+2Ep
.text$mn:00004278
.text$mn:00004278 var_1           = byte ptr -1
.text$mn:00004278 arg_0           = dword ptr  8
.text$mn:00004278 arg_4           = dword ptr  0Ch
.text$mn:00004278 arg_8           = dword ptr  10h
.text$mn:00004278 arg_C           = dword ptr  14h
.text$mn:00004278
.text$mn:00004278                 push    ebp
.text$mn:00004279                 mov     ebp, esp
.text$mn:0000427B                 push    ecx
.text$mn:0000427C                 mov     eax, [ebp+arg_8]
.text$mn:0000427F                 push    eax
.text$mn:00004280                 mov     ecx, [ebp+arg_0]
.text$mn:00004283                 push    ecx
.text$mn:00004284                 call    ??$_Ptr_cat@VPluginCmdShortcut@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVPluginCmdShortcut@@0@Z ; std::_Ptr_cat<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *)
.text$mn:00004289                 add     esp, 8
.text$mn:0000428C                 mov     [ebp+var_1], al
.text$mn:0000428F                 movzx   edx, [ebp+var_1]
.text$mn:00004293                 push    edx
.text$mn:00004294                 mov     eax, [ebp+arg_0]
.text$mn:00004297                 push    eax
.text$mn:00004298                 call    ??$_Val_type@PAVPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@PAV1@@Z ; std::_Val_type<PluginCmdShortcut *>(PluginCmdShortcut *)
.text$mn:0000429D                 add     esp, 4
.text$mn:000042A0                 push    eax
.text$mn:000042A1                 mov     ecx, [ebp+arg_C]
.text$mn:000042A4                 push    ecx             ; int
.text$mn:000042A5                 mov     edx, [ebp+arg_8]
.text$mn:000042A8                 push    edx             ; void *
.text$mn:000042A9                 mov     eax, [ebp+arg_4]
.text$mn:000042AC                 push    eax             ; int
.text$mn:000042AD                 mov     ecx, [ebp+arg_0]
.text$mn:000042B0                 push    ecx             ; int
.text$mn:000042B1                 call    ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::allocator<PluginCmdShortcut>,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,PluginCmdShortcut *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000042B6                 add     esp, 18h
.text$mn:000042B9                 mov     esp, ebp
.text$mn:000042BB                 pop     ebp
.text$mn:000042BC                 retn
.text$mn:000042BC ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z endp
.text$mn:000042BC
.text$mn:000042BC ; ---------------------------------------------------------------------------
.text$mn:000042BD                 align 10h
.text$mn:000042BD _text$mn        ends
.text$mn:000042BD
.text$mn:000042C0 ; ===========================================================================
.text$mn:000042C0
.text$mn:000042C0 ; Segment type: Pure code
.text$mn:000042C0 ; Segment permissions: Read/Execute
.text$mn:000042C0 _text$mn        segment para public 'CODE' use32
.text$mn:000042C0                 assume cs:_text$mn
.text$mn:000042C0                 ;org 42C0h
.text$mn:000042C0 ; COMDAT (pick any)
.text$mn:000042C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000042C0
.text$mn:000042C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000042C0
.text$mn:000042C0 ; Attributes: bp-based frame
.text$mn:000042C0
.text$mn:000042C0 ; int __cdecl std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::allocator<PluginCmdShortcut>,PluginCmdShortcut>(int, int, void *, int)
.text$mn:000042C0                 public ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000042C0 ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000042C0                                         ; CODE XREF: std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)+39p
.text$mn:000042C0
.text$mn:000042C0 var_14          = dword ptr -14h
.text$mn:000042C0 var_10          = dword ptr -10h
.text$mn:000042C0 var_C           = dword ptr -0Ch
.text$mn:000042C0 var_4           = dword ptr -4
.text$mn:000042C0 arg_0           = dword ptr  8
.text$mn:000042C0 arg_4           = dword ptr  0Ch
.text$mn:000042C0 arg_8           = dword ptr  10h
.text$mn:000042C0 arg_C           = dword ptr  14h
.text$mn:000042C0
.text$mn:000042C0 ; FUNCTION CHUNK AT .text$mn:0000438F SIZE 00000009 BYTES
.text$mn:000042C0 ; FUNCTION CHUNK AT .text$mn:0000439F SIZE 00000015 BYTES
.text$mn:000042C0
.text$mn:000042C0                 push    ebp
.text$mn:000042C1                 mov     ebp, esp
.text$mn:000042C3                 push    0FFFFFFFFh
.text$mn:000042C5                 push    offset __ehhandler$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000042CA                 mov     eax, large fs:0
.text$mn:000042D0                 push    eax
.text$mn:000042D1                 push    ecx
.text$mn:000042D2                 push    ecx
.text$mn:000042D3                 push    ebx
.text$mn:000042D4                 push    esi
.text$mn:000042D5                 push    edi
.text$mn:000042D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000042DB                 xor     eax, ebp
.text$mn:000042DD                 push    eax
.text$mn:000042DE                 lea     eax, [ebp+var_C]
.text$mn:000042E1                 mov     large fs:0, eax
.text$mn:000042E7                 mov     [ebp+var_10], esp
.text$mn:000042EA                 push    1B6h            ; unsigned int
.text$mn:000042EF                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000042F4                 mov     eax, [ebp+arg_4]
.text$mn:000042F7                 push    eax             ; int
.text$mn:000042F8                 mov     ecx, [ebp+arg_0]
.text$mn:000042FB                 push    ecx             ; int
.text$mn:000042FC                 call    ??$_Debug_range@PAVPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@0PB_WI@Z ; std::_Debug_range<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,wchar_t const *,uint)
.text$mn:00004301                 add     esp, 10h
.text$mn:00004304                 push    1B7h            ; unsigned int
.text$mn:00004309                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000430E                 mov     edx, [ebp+arg_8]
.text$mn:00004311                 push    edx             ; int
.text$mn:00004312                 call    ??$_Debug_pointer@VPluginCmdShortcut@@@std@@YAXPAVPluginCmdShortcut@@PB_WI@Z ; std::_Debug_pointer<PluginCmdShortcut>(PluginCmdShortcut *,wchar_t const *,uint)
.text$mn:00004317                 add     esp, 0Ch
.text$mn:0000431A                 mov     eax, [ebp+arg_8]
.text$mn:0000431D                 mov     [ebp+var_14], eax
.text$mn:00004320                 mov     [ebp+var_4], 0
.text$mn:00004327                 jmp     short loc_4341
.text$mn:00004329 ; ---------------------------------------------------------------------------
.text$mn:00004329
.text$mn:00004329 loc_4329:                               ; CODE XREF: std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::allocator<PluginCmdShortcut>,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,PluginCmdShortcut *,std::_Nonscalar_ptr_iterator_tag)+99j
.text$mn:00004329                 mov     ecx, [ebp+arg_8]
.text$mn:0000432C                 add     ecx, 150h
.text$mn:00004332                 mov     [ebp+arg_8], ecx
.text$mn:00004335                 mov     edx, [ebp+arg_0]
.text$mn:00004338                 add     edx, 150h
.text$mn:0000433E                 mov     [ebp+arg_0], edx
.text$mn:00004341
.text$mn:00004341 loc_4341:                               ; CODE XREF: std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::allocator<PluginCmdShortcut>,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,PluginCmdShortcut *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00004341                 mov     eax, [ebp+arg_0]
.text$mn:00004344                 cmp     eax, [ebp+arg_4]
.text$mn:00004347                 jz      short loc_435B
.text$mn:00004349                 mov     ecx, [ebp+arg_0]
.text$mn:0000434C                 push    ecx             ; int
.text$mn:0000434D                 mov     edx, [ebp+arg_8]
.text$mn:00004350                 push    edx             ; void *
.text$mn:00004351                 mov     ecx, [ebp+arg_C]
.text$mn:00004354                 call    ??$construct@VPluginCmdShortcut@@V1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z ; std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut &&)
.text$mn:00004359                 jmp     short loc_4329
.text$mn:0000435B ; ---------------------------------------------------------------------------
.text$mn:0000435B
.text$mn:0000435B loc_435B:                               ; CODE XREF: std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::allocator<PluginCmdShortcut>,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,PluginCmdShortcut *,std::_Nonscalar_ptr_iterator_tag)+87j
.text$mn:0000435B                 jmp     short loc_438F
.text$mn:0000435B ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000435B
.text$mn:0000435D
.text$mn:0000435D ; =============== S U B R O U T I N E =======================================
.text$mn:0000435D
.text$mn:0000435D ; Attributes: noreturn
.text$mn:0000435D
.text$mn:0000435D __catch$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:0000435D                                         ; DATA XREF: .xdata$x:0000D8C8o
.text$mn:0000435D                 jmp     short loc_436A
.text$mn:0000435F ; ---------------------------------------------------------------------------
.text$mn:0000435F
.text$mn:0000435F loc_435F:                               ; CODE XREF: __catch$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+21j
.text$mn:0000435F                 mov     eax, [ebp-14h]
.text$mn:00004362                 add     eax, 150h
.text$mn:00004367                 mov     [ebp-14h], eax
.text$mn:0000436A
.text$mn:0000436A loc_436A:                               ; CODE XREF: __catch$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:0000436A                 mov     ecx, [ebp-14h]
.text$mn:0000436D                 cmp     ecx, [ebp+10h]
.text$mn:00004370                 jz      short loc_4380
.text$mn:00004372                 mov     edx, [ebp-14h]
.text$mn:00004375                 push    edx
.text$mn:00004376                 mov     ecx, [ebp+14h]
.text$mn:00004379                 call    ??$destroy@VPluginCmdShortcut@@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@@Z ; std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::destroy<PluginCmdShortcut>(PluginCmdShortcut *)
.text$mn:0000437E                 jmp     short loc_435F
.text$mn:00004380 ; ---------------------------------------------------------------------------
.text$mn:00004380
.text$mn:00004380 loc_4380:                               ; CODE XREF: __catch$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+13j
.text$mn:00004380                 push    0
.text$mn:00004382                 push    0
.text$mn:00004384                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00004384 __catch$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00004384
.text$mn:00004389 ; ---------------------------------------------------------------------------
.text$mn:00004389                 mov     eax, offset $LN13_4
.text$mn:0000438E                 retn
.text$mn:0000438F ; ---------------------------------------------------------------------------
.text$mn:0000438F ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000438F
.text$mn:0000438F loc_438F:                               ; CODE XREF: std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::allocator<PluginCmdShortcut>,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,PluginCmdShortcut *,std::_Nonscalar_ptr_iterator_tag):loc_435Bj
.text$mn:0000438F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004396                 jmp     short loc_439F
.text$mn:00004396 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004398
.text$mn:00004398 ; =============== S U B R O U T I N E =======================================
.text$mn:00004398
.text$mn:00004398
.text$mn:00004398 $LN13_4         proc near               ; DATA XREF: .text$mn:00004389o
.text$mn:00004398                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00004398 $LN13_4         endp ; sp-analysis failed
.text$mn:00004398
.text$mn:0000439F ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000439F
.text$mn:0000439F loc_439F:                               ; CODE XREF: std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::allocator<PluginCmdShortcut>,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,PluginCmdShortcut *,std::_Nonscalar_ptr_iterator_tag)+D6j
.text$mn:0000439F                 mov     eax, [ebp+arg_8]
.text$mn:000043A2                 mov     ecx, [ebp+var_C]
.text$mn:000043A5                 mov     large fs:0, ecx
.text$mn:000043AC                 pop     ecx
.text$mn:000043AD                 pop     edi
.text$mn:000043AE                 pop     esi
.text$mn:000043AF                 pop     ebx
.text$mn:000043B0                 mov     esp, ebp
.text$mn:000043B2                 pop     ebp
.text$mn:000043B3                 retn
.text$mn:000043B3 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000043B3 _text$mn        ends
.text$mn:000043B3
.text$x:000043B4 ; ===========================================================================
.text$x:000043B4
.text$x:000043B4 ; Segment type: Pure code
.text$x:000043B4 ; Segment permissions: Read/Execute
.text$x:000043B4 _text$x         segment para public 'CODE' use32
.text$x:000043B4                 assume cs:_text$x
.text$x:000043B4                 ;org 43B4h
.text$x:000043B4 ; COMDAT (pick associative to section at 42C0)
.text$x:000043B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000043B4
.text$x:000043B4 ; =============== S U B R O U T I N E =======================================
.text$x:000043B4
.text$x:000043B4
.text$x:000043B4 __ehhandler$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:000043B4                                         ; DATA XREF: std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::allocator<PluginCmdShortcut>,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,PluginCmdShortcut *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:000043B4
.text$x:000043B4 arg_4           = dword ptr  8
.text$x:000043B4
.text$x:000043B4                 mov     edx, [esp+arg_4]
.text$x:000043B8                 lea     eax, [edx+0Ch]
.text$x:000043BB                 mov     ecx, [edx-18h]
.text$x:000043BE                 xor     ecx, eax
.text$x:000043C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000043C5                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:000043CA                 jmp     ___CxxFrameHandler3
.text$x:000043CA __ehhandler$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:000043CA
.text$x:000043CA ; ---------------------------------------------------------------------------
.text$x:000043CF                 align 10h
.text$x:000043CF _text$x         ends
.text$x:000043CF
.text$mn:000043D0 ; ===========================================================================
.text$mn:000043D0
.text$mn:000043D0 ; Segment type: Pure code
.text$mn:000043D0 ; Segment permissions: Read/Execute
.text$mn:000043D0 _text$mn        segment para public 'CODE' use32
.text$mn:000043D0                 assume cs:_text$mn
.text$mn:000043D0                 ;org 43D0h
.text$mn:000043D0 ; COMDAT (pick any)
.text$mn:000043D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000043D0
.text$mn:000043D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000043D0
.text$mn:000043D0 ; Attributes: bp-based frame
.text$mn:000043D0
.text$mn:000043D0 ; int __cdecl std::_Uninit_move<TiXmlDocument *,TiXmlDocument *,TiXmlDocument *>(void *Src, int, void *Dst)
.text$mn:000043D0                 public ??$_Uninit_move@PAVTiXmlDocument@@PAV1@PAV1@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:000043D0 ??$_Uninit_move@PAVTiXmlDocument@@PAV1@PAV1@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000043D0                                         ; CODE XREF: std::_Uninit_move<TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)+39p
.text$mn:000043D0
.text$mn:000043D0 var_4           = dword ptr -4
.text$mn:000043D0 Src             = dword ptr  8
.text$mn:000043D0 arg_4           = dword ptr  0Ch
.text$mn:000043D0 Dst             = dword ptr  10h
.text$mn:000043D0
.text$mn:000043D0                 push    ebp
.text$mn:000043D1                 mov     ebp, esp
.text$mn:000043D3                 push    ecx
.text$mn:000043D4                 push    1D6h            ; unsigned int
.text$mn:000043D9                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000043DE                 mov     eax, [ebp+arg_4]
.text$mn:000043E1                 push    eax             ; int
.text$mn:000043E2                 mov     ecx, [ebp+Src]
.text$mn:000043E5                 push    ecx             ; int
.text$mn:000043E6                 call    ??$_Debug_range@PAPAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@0PB_WI@Z ; std::_Debug_range<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,wchar_t const *,uint)
.text$mn:000043EB                 add     esp, 10h
.text$mn:000043EE                 push    1D7h            ; unsigned int
.text$mn:000043F3                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000043F8                 mov     edx, [ebp+Dst]
.text$mn:000043FB                 push    edx             ; int
.text$mn:000043FC                 call    ??$_Debug_pointer@PAVTiXmlDocument@@@std@@YAXPAPAVTiXmlDocument@@PB_WI@Z ; std::_Debug_pointer<TiXmlDocument *>(TiXmlDocument * *,wchar_t const *,uint)
.text$mn:00004401                 add     esp, 0Ch
.text$mn:00004404                 mov     eax, [ebp+arg_4]
.text$mn:00004407                 sub     eax, [ebp+Src]
.text$mn:0000440A                 sar     eax, 2
.text$mn:0000440D                 mov     [ebp+var_4], eax
.text$mn:00004410                 mov     ecx, [ebp+var_4]
.text$mn:00004413                 shl     ecx, 2
.text$mn:00004416                 push    ecx             ; Size
.text$mn:00004417                 mov     edx, [ebp+Src]
.text$mn:0000441A                 push    edx             ; Src
.text$mn:0000441B                 mov     eax, [ebp+Dst]
.text$mn:0000441E                 push    eax             ; Dst
.text$mn:0000441F                 call    _memmove
.text$mn:00004424                 add     esp, 0Ch
.text$mn:00004427                 mov     ecx, [ebp+var_4]
.text$mn:0000442A                 lea     eax, [eax+ecx*4]
.text$mn:0000442D                 mov     esp, ebp
.text$mn:0000442F                 pop     ebp
.text$mn:00004430                 retn
.text$mn:00004430 ??$_Uninit_move@PAVTiXmlDocument@@PAV1@PAV1@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004430
.text$mn:00004430 ; ---------------------------------------------------------------------------
.text$mn:00004431                 align 4
.text$mn:00004431 _text$mn        ends
.text$mn:00004431
.text$mn:00004434 ; ===========================================================================
.text$mn:00004434
.text$mn:00004434 ; Segment type: Pure code
.text$mn:00004434 ; Segment permissions: Read/Execute
.text$mn:00004434 _text$mn        segment para public 'CODE' use32
.text$mn:00004434                 assume cs:_text$mn
.text$mn:00004434                 ;org 4434h
.text$mn:00004434 ; COMDAT (pick any)
.text$mn:00004434                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004434
.text$mn:00004434 ; =============== S U B R O U T I N E =======================================
.text$mn:00004434
.text$mn:00004434 ; Attributes: bp-based frame
.text$mn:00004434
.text$mn:00004434 ; struct PluginInfo * * __cdecl std::_Uninitialized_move<struct PluginInfo * *, struct PluginInfo * *, struct std::_Wrap_alloc<class std::allocator<struct PluginInfo *>>>(struct PluginInfo * *, struct PluginInfo * *, struct PluginInfo * *, struct std::_Wrap_alloc<class std::allocator<struct PluginInfo *>> &)
.text$mn:00004434                 public ??$_Uninitialized_move@PAPAUPluginInfo@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z
.text$mn:00004434 ??$_Uninitialized_move@PAPAUPluginInfo@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z proc near
.text$mn:00004434                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Umove<PluginInfo * *>(PluginInfo * *,PluginInfo * *,PluginInfo * *)+25p
.text$mn:00004434
.text$mn:00004434 arg_0           = dword ptr  8
.text$mn:00004434 arg_4           = dword ptr  0Ch
.text$mn:00004434 arg_8           = dword ptr  10h
.text$mn:00004434 arg_C           = dword ptr  14h
.text$mn:00004434
.text$mn:00004434                 push    ebp
.text$mn:00004435                 mov     ebp, esp
.text$mn:00004437                 mov     eax, [ebp+arg_C]
.text$mn:0000443A                 push    eax             ; int
.text$mn:0000443B                 mov     ecx, [ebp+arg_8]
.text$mn:0000443E                 push    ecx
.text$mn:0000443F                 call    ??$_Unchecked@PAPAUPluginInfo@@@std@@YAPAPAUPluginInfo@@PAPAU1@@Z ; std::_Unchecked<PluginInfo * *>(PluginInfo * *)
.text$mn:00004444                 add     esp, 4
.text$mn:00004447                 push    eax             ; Dst
.text$mn:00004448                 mov     edx, [ebp+arg_4]
.text$mn:0000444B                 push    edx
.text$mn:0000444C                 call    ??$_Unchecked@PAPAUPluginInfo@@@std@@YAPAPAUPluginInfo@@PAPAU1@@Z ; std::_Unchecked<PluginInfo * *>(PluginInfo * *)
.text$mn:00004451                 add     esp, 4
.text$mn:00004454                 push    eax             ; int
.text$mn:00004455                 mov     eax, [ebp+arg_0]
.text$mn:00004458                 push    eax
.text$mn:00004459                 call    ??$_Unchecked@PAPAUPluginInfo@@@std@@YAPAPAUPluginInfo@@PAPAU1@@Z ; std::_Unchecked<PluginInfo * *>(PluginInfo * *)
.text$mn:0000445E                 add     esp, 4
.text$mn:00004461                 push    eax             ; Src
.text$mn:00004462                 call    ??$_Uninit_move@PAPAUPluginInfo@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z ; std::_Uninit_move<PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)
.text$mn:00004467                 add     esp, 10h
.text$mn:0000446A                 push    eax
.text$mn:0000446B                 lea     ecx, [ebp+arg_8]
.text$mn:0000446E                 push    ecx
.text$mn:0000446F                 call    ??$_Rechecked@PAPAUPluginInfo@@PAPAU1@@std@@YAAAPAPAUPluginInfo@@AAPAPAU1@PAPAU1@@Z ; std::_Rechecked<PluginInfo * *,PluginInfo * *>(PluginInfo * * &,PluginInfo * *)
.text$mn:00004474                 add     esp, 8
.text$mn:00004477                 mov     eax, [eax]
.text$mn:00004479                 pop     ebp
.text$mn:0000447A                 retn
.text$mn:0000447A ??$_Uninitialized_move@PAPAUPluginInfo@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAPAPAUPluginInfo@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z endp
.text$mn:0000447A
.text$mn:0000447A ; ---------------------------------------------------------------------------
.text$mn:0000447B                 align 4
.text$mn:0000447B _text$mn        ends
.text$mn:0000447B
.text$mn:0000447C ; ===========================================================================
.text$mn:0000447C
.text$mn:0000447C ; Segment type: Pure code
.text$mn:0000447C ; Segment permissions: Read/Execute
.text$mn:0000447C _text$mn        segment para public 'CODE' use32
.text$mn:0000447C                 assume cs:_text$mn
.text$mn:0000447C                 ;org 447Ch
.text$mn:0000447C ; COMDAT (pick any)
.text$mn:0000447C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000447C
.text$mn:0000447C ; =============== S U B R O U T I N E =======================================
.text$mn:0000447C
.text$mn:0000447C ; Attributes: bp-based frame
.text$mn:0000447C
.text$mn:0000447C ; class TiXmlDocument * * __cdecl std::_Uninitialized_move<class TiXmlDocument * *, class TiXmlDocument * *, struct std::_Wrap_alloc<class std::allocator<class TiXmlDocument *>>>(class TiXmlDocument * *, class TiXmlDocument * *, class TiXmlDocument * *, struct std::_Wrap_alloc<class std::allocator<class TiXmlDocument *>> &)
.text$mn:0000447C                 public ??$_Uninitialized_move@PAPAVTiXmlDocument@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z
.text$mn:0000447C ??$_Uninitialized_move@PAPAVTiXmlDocument@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z proc near
.text$mn:0000447C                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Umove<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *)+25p
.text$mn:0000447C
.text$mn:0000447C arg_0           = dword ptr  8
.text$mn:0000447C arg_4           = dword ptr  0Ch
.text$mn:0000447C arg_8           = dword ptr  10h
.text$mn:0000447C arg_C           = dword ptr  14h
.text$mn:0000447C
.text$mn:0000447C                 push    ebp
.text$mn:0000447D                 mov     ebp, esp
.text$mn:0000447F                 mov     eax, [ebp+arg_C]
.text$mn:00004482                 push    eax             ; int
.text$mn:00004483                 mov     ecx, [ebp+arg_8]
.text$mn:00004486                 push    ecx
.text$mn:00004487                 call    ??$_Unchecked@PAPAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@@Z ; std::_Unchecked<TiXmlDocument * *>(TiXmlDocument * *)
.text$mn:0000448C                 add     esp, 4
.text$mn:0000448F                 push    eax             ; Dst
.text$mn:00004490                 mov     edx, [ebp+arg_4]
.text$mn:00004493                 push    edx
.text$mn:00004494                 call    ??$_Unchecked@PAPAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@@Z ; std::_Unchecked<TiXmlDocument * *>(TiXmlDocument * *)
.text$mn:00004499                 add     esp, 4
.text$mn:0000449C                 push    eax             ; int
.text$mn:0000449D                 mov     eax, [ebp+arg_0]
.text$mn:000044A0                 push    eax
.text$mn:000044A1                 call    ??$_Unchecked@PAPAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@@Z ; std::_Unchecked<TiXmlDocument * *>(TiXmlDocument * *)
.text$mn:000044A6                 add     esp, 4
.text$mn:000044A9                 push    eax             ; Src
.text$mn:000044AA                 call    ??$_Uninit_move@PAPAVTiXmlDocument@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z ; std::_Uninit_move<TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)
.text$mn:000044AF                 add     esp, 10h
.text$mn:000044B2                 push    eax
.text$mn:000044B3                 lea     ecx, [ebp+arg_8]
.text$mn:000044B6                 push    ecx
.text$mn:000044B7                 call    ??$_Rechecked@PAPAVTiXmlDocument@@PAPAV1@@std@@YAAAPAPAVTiXmlDocument@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<TiXmlDocument * *,TiXmlDocument * *>(TiXmlDocument * * &,TiXmlDocument * *)
.text$mn:000044BC                 add     esp, 8
.text$mn:000044BF                 mov     eax, [eax]
.text$mn:000044C1                 pop     ebp
.text$mn:000044C2                 retn
.text$mn:000044C2 ??$_Uninitialized_move@PAPAVTiXmlDocument@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z endp
.text$mn:000044C2
.text$mn:000044C2 ; ---------------------------------------------------------------------------
.text$mn:000044C3                 align 4
.text$mn:000044C3 _text$mn        ends
.text$mn:000044C3
.text$mn:000044C4 ; ===========================================================================
.text$mn:000044C4
.text$mn:000044C4 ; Segment type: Pure code
.text$mn:000044C4 ; Segment permissions: Read/Execute
.text$mn:000044C4 _text$mn        segment para public 'CODE' use32
.text$mn:000044C4                 assume cs:_text$mn
.text$mn:000044C4                 ;org 44C4h
.text$mn:000044C4 ; COMDAT (pick any)
.text$mn:000044C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000044C4
.text$mn:000044C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000044C4
.text$mn:000044C4 ; Attributes: bp-based frame
.text$mn:000044C4
.text$mn:000044C4 ; struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * __cdecl std::_Uninitialized_move<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::_Wrap_alloc<class std::allocator<struct std::pair<class
.text$mn:000044C4                 public ??$_Uninitialized_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z
.text$mn:000044C4 ??$_Uninitialized_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z proc near
.text$mn:000044C4                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Umove<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+25p
.text$mn:000044C4
.text$mn:000044C4 arg_0           = dword ptr  8
.text$mn:000044C4 arg_4           = dword ptr  0Ch
.text$mn:000044C4 arg_8           = dword ptr  10h
.text$mn:000044C4 arg_C           = dword ptr  14h
.text$mn:000044C4
.text$mn:000044C4                 push    ebp
.text$mn:000044C5                 mov     ebp, esp
.text$mn:000044C7                 mov     eax, [ebp+arg_C]
.text$mn:000044CA                 push    eax             ; int
.text$mn:000044CB                 mov     ecx, [ebp+arg_8]
.text$mn:000044CE                 push    ecx
.text$mn:000044CF                 call    ??$_Unchecked@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@@Z ; std::_Unchecked<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:000044D4                 add     esp, 4
.text$mn:000044D7                 push    eax             ; void *
.text$mn:000044D8                 mov     edx, [ebp+arg_4]
.text$mn:000044DB                 push    edx
.text$mn:000044DC                 call    ??$_Unchecked@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@@Z ; std::_Unchecked<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:000044E1                 add     esp, 4
.text$mn:000044E4                 push    eax             ; int
.text$mn:000044E5                 mov     eax, [ebp+arg_0]
.text$mn:000044E8                 push    eax
.text$mn:000044E9                 call    ??$_Unchecked@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@@Z ; std::_Unchecked<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:000044EE                 add     esp, 4
.text$mn:000044F1                 push    eax             ; int
.text$mn:000044F2                 call    ??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z ; std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)
.text$mn:000044F7                 add     esp, 10h
.text$mn:000044FA                 push    eax
.text$mn:000044FB                 lea     ecx, [ebp+arg_8]
.text$mn:000044FE                 push    ecx
.text$mn:000044FF                 call    ??$_Rechecked@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@@std@@YAAAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAPAU10@PAU10@@Z ; std::_Rechecked<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> * &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:00004504                 add     esp, 8
.text$mn:00004507                 mov     eax, [eax]
.text$mn:00004509                 pop     ebp
.text$mn:0000450A                 retn
.text$mn:0000450A ??$_Uninitialized_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z endp
.text$mn:0000450A
.text$mn:0000450A ; ---------------------------------------------------------------------------
.text$mn:0000450B                 align 4
.text$mn:0000450B _text$mn        ends
.text$mn:0000450B
.text$mn:0000450C ; ===========================================================================
.text$mn:0000450C
.text$mn:0000450C ; Segment type: Pure code
.text$mn:0000450C ; Segment permissions: Read/Execute
.text$mn:0000450C _text$mn        segment para public 'CODE' use32
.text$mn:0000450C                 assume cs:_text$mn
.text$mn:0000450C                 ;org 450Ch
.text$mn:0000450C ; COMDAT (pick any)
.text$mn:0000450C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000450C
.text$mn:0000450C ; =============== S U B R O U T I N E =======================================
.text$mn:0000450C
.text$mn:0000450C ; Attributes: bp-based frame
.text$mn:0000450C
.text$mn:0000450C ; struct PluginCommand * __cdecl std::_Uninitialized_move<struct PluginCommand *, struct PluginCommand *, struct std::_Wrap_alloc<class std::allocator<struct PluginCommand>>>(struct PluginCommand *, struct PluginCommand *, struct PluginCommand *, struct std::_Wrap_alloc<class std::allocator<struct PluginCommand>> &)
.text$mn:0000450C                 public ??$_Uninitialized_move@PAUPluginCommand@@PAU1@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z
.text$mn:0000450C ??$_Uninitialized_move@PAUPluginCommand@@PAU1@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z proc near
.text$mn:0000450C                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Umove<PluginCommand *>(PluginCommand *,PluginCommand *,PluginCommand *)+25p
.text$mn:0000450C
.text$mn:0000450C arg_0           = dword ptr  8
.text$mn:0000450C arg_4           = dword ptr  0Ch
.text$mn:0000450C arg_8           = dword ptr  10h
.text$mn:0000450C arg_C           = dword ptr  14h
.text$mn:0000450C
.text$mn:0000450C                 push    ebp
.text$mn:0000450D                 mov     ebp, esp
.text$mn:0000450F                 mov     eax, [ebp+arg_C]
.text$mn:00004512                 push    eax             ; int
.text$mn:00004513                 mov     ecx, [ebp+arg_8]
.text$mn:00004516                 push    ecx
.text$mn:00004517                 call    ??$_Unchecked@PAUPluginCommand@@@std@@YAPAUPluginCommand@@PAU1@@Z ; std::_Unchecked<PluginCommand *>(PluginCommand *)
.text$mn:0000451C                 add     esp, 4
.text$mn:0000451F                 push    eax             ; void *
.text$mn:00004520                 mov     edx, [ebp+arg_4]
.text$mn:00004523                 push    edx
.text$mn:00004524                 call    ??$_Unchecked@PAUPluginCommand@@@std@@YAPAUPluginCommand@@PAU1@@Z ; std::_Unchecked<PluginCommand *>(PluginCommand *)
.text$mn:00004529                 add     esp, 4
.text$mn:0000452C                 push    eax             ; int
.text$mn:0000452D                 mov     eax, [ebp+arg_0]
.text$mn:00004530                 push    eax
.text$mn:00004531                 call    ??$_Unchecked@PAUPluginCommand@@@std@@YAPAUPluginCommand@@PAU1@@Z ; std::_Unchecked<PluginCommand *>(PluginCommand *)
.text$mn:00004536                 add     esp, 4
.text$mn:00004539                 push    eax             ; int
.text$mn:0000453A                 call    ??$_Uninit_move@PAUPluginCommand@@PAU1@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z ; std::_Uninit_move<PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)
.text$mn:0000453F                 add     esp, 10h
.text$mn:00004542                 push    eax
.text$mn:00004543                 lea     ecx, [ebp+arg_8]
.text$mn:00004546                 push    ecx
.text$mn:00004547                 call    ??$_Rechecked@PAUPluginCommand@@PAU1@@std@@YAAAPAUPluginCommand@@AAPAU1@PAU1@@Z ; std::_Rechecked<PluginCommand *,PluginCommand *>(PluginCommand * &,PluginCommand *)
.text$mn:0000454C                 add     esp, 8
.text$mn:0000454F                 mov     eax, [eax]
.text$mn:00004551                 pop     ebp
.text$mn:00004552                 retn
.text$mn:00004552 ??$_Uninitialized_move@PAUPluginCommand@@PAU1@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z endp
.text$mn:00004552
.text$mn:00004552 ; ---------------------------------------------------------------------------
.text$mn:00004553                 align 4
.text$mn:00004553 _text$mn        ends
.text$mn:00004553
.text$mn:00004554 ; ===========================================================================
.text$mn:00004554
.text$mn:00004554 ; Segment type: Pure code
.text$mn:00004554 ; Segment permissions: Read/Execute
.text$mn:00004554 _text$mn        segment para public 'CODE' use32
.text$mn:00004554                 assume cs:_text$mn
.text$mn:00004554                 ;org 4554h
.text$mn:00004554 ; COMDAT (pick any)
.text$mn:00004554                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004554
.text$mn:00004554 ; =============== S U B R O U T I N E =======================================
.text$mn:00004554
.text$mn:00004554 ; Attributes: bp-based frame
.text$mn:00004554
.text$mn:00004554 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Uninitialized_move<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> &)
.text$mn:00004554                 public ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
.text$mn:00004554 ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z proc near
.text$mn:00004554                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+25p
.text$mn:00004554
.text$mn:00004554 arg_0           = dword ptr  8
.text$mn:00004554 arg_4           = dword ptr  0Ch
.text$mn:00004554 arg_8           = dword ptr  10h
.text$mn:00004554 arg_C           = dword ptr  14h
.text$mn:00004554
.text$mn:00004554                 push    ebp
.text$mn:00004555                 mov     ebp, esp
.text$mn:00004557                 mov     eax, [ebp+arg_C]
.text$mn:0000455A                 push    eax             ; int
.text$mn:0000455B                 mov     ecx, [ebp+arg_8]
.text$mn:0000455E                 push    ecx
.text$mn:0000455F                 call    ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00004564                 add     esp, 4
.text$mn:00004567                 push    eax             ; void *
.text$mn:00004568                 mov     edx, [ebp+arg_4]
.text$mn:0000456B                 push    edx
.text$mn:0000456C                 call    ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00004571                 add     esp, 4
.text$mn:00004574                 push    eax             ; int
.text$mn:00004575                 mov     eax, [ebp+arg_0]
.text$mn:00004578                 push    eax
.text$mn:00004579                 call    ??$_Unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000457E                 add     esp, 4
.text$mn:00004581                 push    eax             ; int
.text$mn:00004582                 call    ??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ; std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:00004587                 add     esp, 10h
.text$mn:0000458A                 push    eax
.text$mn:0000458B                 lea     ecx, [ebp+arg_8]
.text$mn:0000458E                 push    ecx
.text$mn:0000458F                 call    ??$_Rechecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAAAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> * &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00004594                 add     esp, 8
.text$mn:00004597                 mov     eax, [eax]
.text$mn:00004599                 pop     ebp
.text$mn:0000459A                 retn
.text$mn:0000459A ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z endp
.text$mn:0000459A
.text$mn:0000459A ; ---------------------------------------------------------------------------
.text$mn:0000459B                 align 4
.text$mn:0000459B _text$mn        ends
.text$mn:0000459B
.text$mn:0000459C ; ===========================================================================
.text$mn:0000459C
.text$mn:0000459C ; Segment type: Pure code
.text$mn:0000459C ; Segment permissions: Read/Execute
.text$mn:0000459C _text$mn        segment para public 'CODE' use32
.text$mn:0000459C                 assume cs:_text$mn
.text$mn:0000459C                 ;org 459Ch
.text$mn:0000459C ; COMDAT (pick any)
.text$mn:0000459C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000459C
.text$mn:0000459C ; =============== S U B R O U T I N E =======================================
.text$mn:0000459C
.text$mn:0000459C ; Attributes: bp-based frame
.text$mn:0000459C
.text$mn:0000459C ; class PluginCmdShortcut * __cdecl std::_Uninitialized_move<class PluginCmdShortcut *, class PluginCmdShortcut *, struct std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>>>(class PluginCmdShortcut *, class PluginCmdShortcut *, class PluginCmdShortcut *, struct std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>> &)
.text$mn:0000459C                 public ??$_Uninitialized_move@PAVPluginCmdShortcut@@PAV1@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z
.text$mn:0000459C ??$_Uninitialized_move@PAVPluginCmdShortcut@@PAV1@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z proc near
.text$mn:0000459C                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Umove<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *)+25p
.text$mn:0000459C
.text$mn:0000459C arg_0           = dword ptr  8
.text$mn:0000459C arg_4           = dword ptr  0Ch
.text$mn:0000459C arg_8           = dword ptr  10h
.text$mn:0000459C arg_C           = dword ptr  14h
.text$mn:0000459C
.text$mn:0000459C                 push    ebp
.text$mn:0000459D                 mov     ebp, esp
.text$mn:0000459F                 mov     eax, [ebp+arg_C]
.text$mn:000045A2                 push    eax             ; int
.text$mn:000045A3                 mov     ecx, [ebp+arg_8]
.text$mn:000045A6                 push    ecx
.text$mn:000045A7                 call    ??$_Unchecked@PAVPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@PAV1@@Z ; std::_Unchecked<PluginCmdShortcut *>(PluginCmdShortcut *)
.text$mn:000045AC                 add     esp, 4
.text$mn:000045AF                 push    eax             ; void *
.text$mn:000045B0                 mov     edx, [ebp+arg_4]
.text$mn:000045B3                 push    edx
.text$mn:000045B4                 call    ??$_Unchecked@PAVPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@PAV1@@Z ; std::_Unchecked<PluginCmdShortcut *>(PluginCmdShortcut *)
.text$mn:000045B9                 add     esp, 4
.text$mn:000045BC                 push    eax             ; int
.text$mn:000045BD                 mov     eax, [ebp+arg_0]
.text$mn:000045C0                 push    eax
.text$mn:000045C1                 call    ??$_Unchecked@PAVPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@PAV1@@Z ; std::_Unchecked<PluginCmdShortcut *>(PluginCmdShortcut *)
.text$mn:000045C6                 add     esp, 4
.text$mn:000045C9                 push    eax             ; int
.text$mn:000045CA                 call    ??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z ; std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)
.text$mn:000045CF                 add     esp, 10h
.text$mn:000045D2                 push    eax
.text$mn:000045D3                 lea     ecx, [ebp+arg_8]
.text$mn:000045D6                 push    ecx
.text$mn:000045D7                 call    ??$_Rechecked@PAVPluginCmdShortcut@@PAV1@@std@@YAAAPAVPluginCmdShortcut@@AAPAV1@PAV1@@Z ; std::_Rechecked<PluginCmdShortcut *,PluginCmdShortcut *>(PluginCmdShortcut * &,PluginCmdShortcut *)
.text$mn:000045DC                 add     esp, 8
.text$mn:000045DF                 mov     eax, [eax]
.text$mn:000045E1                 pop     ebp
.text$mn:000045E2                 retn
.text$mn:000045E2 ??$_Uninitialized_move@PAVPluginCmdShortcut@@PAV1@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z endp
.text$mn:000045E2
.text$mn:000045E2 ; ---------------------------------------------------------------------------
.text$mn:000045E3                 align 4
.text$mn:000045E3 _text$mn        ends
.text$mn:000045E3
.text$mn:000045E4 ; ===========================================================================
.text$mn:000045E4
.text$mn:000045E4 ; Segment type: Pure code
.text$mn:000045E4 ; Segment permissions: Read/Execute
.text$mn:000045E4 _text$mn        segment para public 'CODE' use32
.text$mn:000045E4                 assume cs:_text$mn
.text$mn:000045E4                 ;org 45E4h
.text$mn:000045E4 ; COMDAT (pick any)
.text$mn:000045E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000045E4
.text$mn:000045E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000045E4
.text$mn:000045E4 ; Attributes: bp-based frame
.text$mn:000045E4
.text$mn:000045E4 ; struct PluginInfo * * __cdecl std::_Val_type<struct PluginInfo * *>(struct PluginInfo * *)
.text$mn:000045E4                 public ??$_Val_type@PAPAUPluginInfo@@@std@@YAPAPAUPluginInfo@@PAPAU1@@Z
.text$mn:000045E4 ??$_Val_type@PAPAUPluginInfo@@@std@@YAPAPAUPluginInfo@@PAPAU1@@Z proc near
.text$mn:000045E4                                         ; CODE XREF: std::_Uninit_move<PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)+20p
.text$mn:000045E4                 push    ebp
.text$mn:000045E5                 mov     ebp, esp
.text$mn:000045E7                 xor     eax, eax
.text$mn:000045E9                 pop     ebp
.text$mn:000045EA                 retn
.text$mn:000045EA ??$_Val_type@PAPAUPluginInfo@@@std@@YAPAPAUPluginInfo@@PAPAU1@@Z endp
.text$mn:000045EA
.text$mn:000045EA ; ---------------------------------------------------------------------------
.text$mn:000045EB                 align 4
.text$mn:000045EB _text$mn        ends
.text$mn:000045EB
.text$mn:000045EC ; ===========================================================================
.text$mn:000045EC
.text$mn:000045EC ; Segment type: Pure code
.text$mn:000045EC ; Segment permissions: Read/Execute
.text$mn:000045EC _text$mn        segment para public 'CODE' use32
.text$mn:000045EC                 assume cs:_text$mn
.text$mn:000045EC                 ;org 45ECh
.text$mn:000045EC ; COMDAT (pick any)
.text$mn:000045EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000045EC
.text$mn:000045EC ; =============== S U B R O U T I N E =======================================
.text$mn:000045EC
.text$mn:000045EC ; Attributes: bp-based frame
.text$mn:000045EC
.text$mn:000045EC ; class TiXmlDocument * * __cdecl std::_Val_type<class TiXmlDocument * *>(class TiXmlDocument * *)
.text$mn:000045EC                 public ??$_Val_type@PAPAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@@Z
.text$mn:000045EC ??$_Val_type@PAPAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@@Z proc near
.text$mn:000045EC                                         ; CODE XREF: std::_Uninit_move<TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)+20p
.text$mn:000045EC                 push    ebp
.text$mn:000045ED                 mov     ebp, esp
.text$mn:000045EF                 xor     eax, eax
.text$mn:000045F1                 pop     ebp
.text$mn:000045F2                 retn
.text$mn:000045F2 ??$_Val_type@PAPAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@PAPAV1@@Z endp
.text$mn:000045F2
.text$mn:000045F2 ; ---------------------------------------------------------------------------
.text$mn:000045F3                 align 4
.text$mn:000045F3 _text$mn        ends
.text$mn:000045F3
.text$mn:000045F4 ; ===========================================================================
.text$mn:000045F4
.text$mn:000045F4 ; Segment type: Pure code
.text$mn:000045F4 ; Segment permissions: Read/Execute
.text$mn:000045F4 _text$mn        segment para public 'CODE' use32
.text$mn:000045F4                 assume cs:_text$mn
.text$mn:000045F4                 ;org 45F4h
.text$mn:000045F4 ; COMDAT (pick any)
.text$mn:000045F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000045F4
.text$mn:000045F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000045F4
.text$mn:000045F4 ; Attributes: bp-based frame
.text$mn:000045F4
.text$mn:000045F4 ; struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * __cdecl std::_Val_type<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)
.text$mn:000045F4                 public ??$_Val_type@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@@Z
.text$mn:000045F4 ??$_Val_type@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@@Z proc near
.text$mn:000045F4                                         ; CODE XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)+20p
.text$mn:000045F4                 push    ebp
.text$mn:000045F5                 mov     ebp, esp
.text$mn:000045F7                 xor     eax, eax
.text$mn:000045F9                 pop     ebp
.text$mn:000045FA                 retn
.text$mn:000045FA ??$_Val_type@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@@Z endp
.text$mn:000045FA
.text$mn:000045FA ; ---------------------------------------------------------------------------
.text$mn:000045FB                 align 4
.text$mn:000045FB _text$mn        ends
.text$mn:000045FB
.text$mn:000045FC ; ===========================================================================
.text$mn:000045FC
.text$mn:000045FC ; Segment type: Pure code
.text$mn:000045FC ; Segment permissions: Read/Execute
.text$mn:000045FC _text$mn        segment para public 'CODE' use32
.text$mn:000045FC                 assume cs:_text$mn
.text$mn:000045FC                 ;org 45FCh
.text$mn:000045FC ; COMDAT (pick any)
.text$mn:000045FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000045FC
.text$mn:000045FC ; =============== S U B R O U T I N E =======================================
.text$mn:000045FC
.text$mn:000045FC ; Attributes: bp-based frame
.text$mn:000045FC
.text$mn:000045FC ; struct PluginCommand * __cdecl std::_Val_type<struct PluginCommand *>(struct PluginCommand *)
.text$mn:000045FC                 public ??$_Val_type@PAUPluginCommand@@@std@@YAPAUPluginCommand@@PAU1@@Z
.text$mn:000045FC ??$_Val_type@PAUPluginCommand@@@std@@YAPAUPluginCommand@@PAU1@@Z proc near
.text$mn:000045FC                                         ; CODE XREF: std::_Uninit_move<PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)+20p
.text$mn:000045FC                 push    ebp
.text$mn:000045FD                 mov     ebp, esp
.text$mn:000045FF                 xor     eax, eax
.text$mn:00004601                 pop     ebp
.text$mn:00004602                 retn
.text$mn:00004602 ??$_Val_type@PAUPluginCommand@@@std@@YAPAUPluginCommand@@PAU1@@Z endp
.text$mn:00004602
.text$mn:00004602 ; ---------------------------------------------------------------------------
.text$mn:00004603                 align 4
.text$mn:00004603 _text$mn        ends
.text$mn:00004603
.text$mn:00004604 ; ===========================================================================
.text$mn:00004604
.text$mn:00004604 ; Segment type: Pure code
.text$mn:00004604 ; Segment permissions: Read/Execute
.text$mn:00004604 _text$mn        segment para public 'CODE' use32
.text$mn:00004604                 assume cs:_text$mn
.text$mn:00004604                 ;org 4604h
.text$mn:00004604 ; COMDAT (pick any)
.text$mn:00004604                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004604
.text$mn:00004604 ; =============== S U B R O U T I N E =======================================
.text$mn:00004604
.text$mn:00004604 ; Attributes: bp-based frame
.text$mn:00004604
.text$mn:00004604 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::_Val_type<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00004604                 public ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z
.text$mn:00004604 ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z proc near
.text$mn:00004604                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+20p
.text$mn:00004604                 push    ebp
.text$mn:00004605                 mov     ebp, esp
.text$mn:00004607                 xor     eax, eax
.text$mn:00004609                 pop     ebp
.text$mn:0000460A                 retn
.text$mn:0000460A ??$_Val_type@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@@Z endp
.text$mn:0000460A
.text$mn:0000460A ; ---------------------------------------------------------------------------
.text$mn:0000460B                 align 4
.text$mn:0000460B _text$mn        ends
.text$mn:0000460B
.text$mn:0000460C ; ===========================================================================
.text$mn:0000460C
.text$mn:0000460C ; Segment type: Pure code
.text$mn:0000460C ; Segment permissions: Read/Execute
.text$mn:0000460C _text$mn        segment para public 'CODE' use32
.text$mn:0000460C                 assume cs:_text$mn
.text$mn:0000460C                 ;org 460Ch
.text$mn:0000460C ; COMDAT (pick any)
.text$mn:0000460C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000460C
.text$mn:0000460C ; =============== S U B R O U T I N E =======================================
.text$mn:0000460C
.text$mn:0000460C ; Attributes: bp-based frame
.text$mn:0000460C
.text$mn:0000460C ; class PluginCmdShortcut * __cdecl std::_Val_type<class PluginCmdShortcut *>(class PluginCmdShortcut *)
.text$mn:0000460C                 public ??$_Val_type@PAVPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@PAV1@@Z
.text$mn:0000460C ??$_Val_type@PAVPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@PAV1@@Z proc near
.text$mn:0000460C                                         ; CODE XREF: std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)+20p
.text$mn:0000460C                 push    ebp
.text$mn:0000460D                 mov     ebp, esp
.text$mn:0000460F                 xor     eax, eax
.text$mn:00004611                 pop     ebp
.text$mn:00004612                 retn
.text$mn:00004612 ??$_Val_type@PAVPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@PAV1@@Z endp
.text$mn:00004612
.text$mn:00004612 ; ---------------------------------------------------------------------------
.text$mn:00004613                 align 4
.text$mn:00004613 _text$mn        ends
.text$mn:00004613
.text$mn:00004614 ; ===========================================================================
.text$mn:00004614
.text$mn:00004614 ; Segment type: Pure code
.text$mn:00004614 ; Segment permissions: Read/Execute
.text$mn:00004614 _text$mn        segment para public 'CODE' use32
.text$mn:00004614                 assume cs:_text$mn
.text$mn:00004614                 ;org 4614h
.text$mn:00004614 ; COMDAT (pick any)
.text$mn:00004614                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004614
.text$mn:00004614 ; =============== S U B R O U T I N E =======================================
.text$mn:00004614
.text$mn:00004614 ; Attributes: bp-based frame
.text$mn:00004614
.text$mn:00004614 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const * __cdecl std::addressof<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00004614                 public ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z
.text$mn:00004614 ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z proc near
.text$mn:00004614                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Dp
.text$mn:00004614                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+2Dp
.text$mn:00004614
.text$mn:00004614 arg_0           = dword ptr  8
.text$mn:00004614
.text$mn:00004614                 push    ebp
.text$mn:00004615                 mov     ebp, esp
.text$mn:00004617                 mov     eax, [ebp+arg_0]
.text$mn:0000461A                 pop     ebp
.text$mn:0000461B                 retn
.text$mn:0000461B ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z endp
.text$mn:0000461B
.text$mn:0000461B _text$mn        ends
.text$mn:0000461B
.text$mn:0000461C ; ===========================================================================
.text$mn:0000461C
.text$mn:0000461C ; Segment type: Pure code
.text$mn:0000461C ; Segment permissions: Read/Execute
.text$mn:0000461C _text$mn        segment para public 'CODE' use32
.text$mn:0000461C                 assume cs:_text$mn
.text$mn:0000461C                 ;org 461Ch
.text$mn:0000461C ; COMDAT (pick any)
.text$mn:0000461C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000461C
.text$mn:0000461C ; =============== S U B R O U T I N E =======================================
.text$mn:0000461C
.text$mn:0000461C ; Attributes: bp-based frame
.text$mn:0000461C
.text$mn:0000461C ; class PluginCmdShortcut const * __cdecl std::addressof<class PluginCmdShortcut const>(class PluginCmdShortcut const &)
.text$mn:0000461C                 public ??$addressof@$$CBVPluginCmdShortcut@@@std@@YAPBVPluginCmdShortcut@@ABV1@@Z
.text$mn:0000461C ??$addressof@$$CBVPluginCmdShortcut@@@std@@YAPBVPluginCmdShortcut@@ABV1@@Z proc near
.text$mn:0000461C                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+Dp
.text$mn:0000461C                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+2Dp
.text$mn:0000461C
.text$mn:0000461C arg_0           = dword ptr  8
.text$mn:0000461C
.text$mn:0000461C                 push    ebp
.text$mn:0000461D                 mov     ebp, esp
.text$mn:0000461F                 mov     eax, [ebp+arg_0]
.text$mn:00004622                 pop     ebp
.text$mn:00004623                 retn
.text$mn:00004623 ??$addressof@$$CBVPluginCmdShortcut@@@std@@YAPBVPluginCmdShortcut@@ABV1@@Z endp
.text$mn:00004623
.text$mn:00004623 _text$mn        ends
.text$mn:00004623
.text$mn:00004624 ; ===========================================================================
.text$mn:00004624
.text$mn:00004624 ; Segment type: Pure code
.text$mn:00004624 ; Segment permissions: Read/Execute
.text$mn:00004624 _text$mn        segment para public 'CODE' use32
.text$mn:00004624                 assume cs:_text$mn
.text$mn:00004624                 ;org 4624h
.text$mn:00004624 ; COMDAT (pick any)
.text$mn:00004624                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004624
.text$mn:00004624 ; =============== S U B R O U T I N E =======================================
.text$mn:00004624
.text$mn:00004624 ; Attributes: bp-based frame
.text$mn:00004624
.text$mn:00004624 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00004624                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00004624 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00004624                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00004624                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00004624
.text$mn:00004624 arg_0           = dword ptr  8
.text$mn:00004624
.text$mn:00004624                 push    ebp
.text$mn:00004625                 mov     ebp, esp
.text$mn:00004627                 mov     eax, [ebp+arg_0]
.text$mn:0000462A                 pop     ebp
.text$mn:0000462B                 retn
.text$mn:0000462B ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000462B
.text$mn:0000462B _text$mn        ends
.text$mn:0000462B
.text$mn:0000462C ; ===========================================================================
.text$mn:0000462C
.text$mn:0000462C ; Segment type: Pure code
.text$mn:0000462C ; Segment permissions: Read/Execute
.text$mn:0000462C _text$mn        segment para public 'CODE' use32
.text$mn:0000462C                 assume cs:_text$mn
.text$mn:0000462C                 ;org 462Ch
.text$mn:0000462C ; COMDAT (pick any)
.text$mn:0000462C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000462C
.text$mn:0000462C ; =============== S U B R O U T I N E =======================================
.text$mn:0000462C
.text$mn:0000462C ; Attributes: bp-based frame
.text$mn:0000462C
.text$mn:0000462C ; struct PluginInfo * const * __cdecl std::addressof<struct PluginInfo * const>(struct PluginInfo * const &)
.text$mn:0000462C                 public ??$addressof@QAUPluginInfo@@@std@@YAPBQAUPluginInfo@@ABQAU1@@Z
.text$mn:0000462C ??$addressof@QAUPluginInfo@@@std@@YAPBQAUPluginInfo@@ABQAU1@@Z proc near
.text$mn:0000462C                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+Dp
.text$mn:0000462C                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+29p
.text$mn:0000462C
.text$mn:0000462C arg_0           = dword ptr  8
.text$mn:0000462C
.text$mn:0000462C                 push    ebp
.text$mn:0000462D                 mov     ebp, esp
.text$mn:0000462F                 mov     eax, [ebp+arg_0]
.text$mn:00004632                 pop     ebp
.text$mn:00004633                 retn
.text$mn:00004633 ??$addressof@QAUPluginInfo@@@std@@YAPBQAUPluginInfo@@ABQAU1@@Z endp
.text$mn:00004633
.text$mn:00004633 _text$mn        ends
.text$mn:00004633
.text$mn:00004634 ; ===========================================================================
.text$mn:00004634
.text$mn:00004634 ; Segment type: Pure code
.text$mn:00004634 ; Segment permissions: Read/Execute
.text$mn:00004634 _text$mn        segment para public 'CODE' use32
.text$mn:00004634                 assume cs:_text$mn
.text$mn:00004634                 ;org 4634h
.text$mn:00004634 ; COMDAT (pick any)
.text$mn:00004634                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004634
.text$mn:00004634 ; =============== S U B R O U T I N E =======================================
.text$mn:00004634
.text$mn:00004634 ; Attributes: bp-based frame
.text$mn:00004634
.text$mn:00004634 ; class TiXmlDocument * const * __cdecl std::addressof<class TiXmlDocument * const>(class TiXmlDocument * const &)
.text$mn:00004634                 public ??$addressof@QAVTiXmlDocument@@@std@@YAPBQAVTiXmlDocument@@ABQAV1@@Z
.text$mn:00004634 ??$addressof@QAVTiXmlDocument@@@std@@YAPBQAVTiXmlDocument@@ABQAV1@@Z proc near
.text$mn:00004634                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+Dp
.text$mn:00004634                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+29p
.text$mn:00004634
.text$mn:00004634 arg_0           = dword ptr  8
.text$mn:00004634
.text$mn:00004634                 push    ebp
.text$mn:00004635                 mov     ebp, esp
.text$mn:00004637                 mov     eax, [ebp+arg_0]
.text$mn:0000463A                 pop     ebp
.text$mn:0000463B                 retn
.text$mn:0000463B ??$addressof@QAVTiXmlDocument@@@std@@YAPBQAVTiXmlDocument@@ABQAV1@@Z endp
.text$mn:0000463B
.text$mn:0000463B _text$mn        ends
.text$mn:0000463B
.text$mn:0000463C ; ===========================================================================
.text$mn:0000463C
.text$mn:0000463C ; Segment type: Pure code
.text$mn:0000463C ; Segment permissions: Read/Execute
.text$mn:0000463C _text$mn        segment para public 'CODE' use32
.text$mn:0000463C                 assume cs:_text$mn
.text$mn:0000463C                 ;org 463Ch
.text$mn:0000463C ; COMDAT (pick any)
.text$mn:0000463C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000463C
.text$mn:0000463C ; =============== S U B R O U T I N E =======================================
.text$mn:0000463C
.text$mn:0000463C ; Attributes: bp-based frame
.text$mn:0000463C
.text$mn:0000463C ; struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * __cdecl std::addressof<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> &)
.text$mn:0000463C                 public ??$addressof@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z
.text$mn:0000463C ??$addressof@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z proc near
.text$mn:0000463C                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+Dp
.text$mn:0000463C                                         ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+2Dp
.text$mn:0000463C
.text$mn:0000463C arg_0           = dword ptr  8
.text$mn:0000463C
.text$mn:0000463C                 push    ebp
.text$mn:0000463D                 mov     ebp, esp
.text$mn:0000463F                 mov     eax, [ebp+arg_0]
.text$mn:00004642                 pop     ebp
.text$mn:00004643                 retn
.text$mn:00004643 ??$addressof@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z endp
.text$mn:00004643
.text$mn:00004643 _text$mn        ends
.text$mn:00004643
.text$mn:00004644 ; ===========================================================================
.text$mn:00004644
.text$mn:00004644 ; Segment type: Pure code
.text$mn:00004644 ; Segment permissions: Read/Execute
.text$mn:00004644 _text$mn        segment para public 'CODE' use32
.text$mn:00004644                 assume cs:_text$mn
.text$mn:00004644                 ;org 4644h
.text$mn:00004644 ; COMDAT (pick any)
.text$mn:00004644                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004644
.text$mn:00004644 ; =============== S U B R O U T I N E =======================================
.text$mn:00004644
.text$mn:00004644 ; Attributes: bp-based frame
.text$mn:00004644
.text$mn:00004644 ; struct PluginCommand * __cdecl std::addressof<struct PluginCommand>(struct PluginCommand &)
.text$mn:00004644                 public ??$addressof@UPluginCommand@@@std@@YAPAUPluginCommand@@AAU1@@Z
.text$mn:00004644 ??$addressof@UPluginCommand@@@std@@YAPAUPluginCommand@@AAU1@@Z proc near
.text$mn:00004644                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+Dp
.text$mn:00004644                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+2Dp
.text$mn:00004644
.text$mn:00004644 arg_0           = dword ptr  8
.text$mn:00004644
.text$mn:00004644                 push    ebp
.text$mn:00004645                 mov     ebp, esp
.text$mn:00004647                 mov     eax, [ebp+arg_0]
.text$mn:0000464A                 pop     ebp
.text$mn:0000464B                 retn
.text$mn:0000464B ??$addressof@UPluginCommand@@@std@@YAPAUPluginCommand@@AAU1@@Z endp
.text$mn:0000464B
.text$mn:0000464B _text$mn        ends
.text$mn:0000464B
.text$mn:0000464C ; ===========================================================================
.text$mn:0000464C
.text$mn:0000464C ; Segment type: Pure code
.text$mn:0000464C ; Segment permissions: Read/Execute
.text$mn:0000464C _text$mn        segment para public 'CODE' use32
.text$mn:0000464C                 assume cs:_text$mn
.text$mn:0000464C                 ;org 464Ch
.text$mn:0000464C ; COMDAT (pick any)
.text$mn:0000464C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000464C
.text$mn:0000464C ; =============== S U B R O U T I N E =======================================
.text$mn:0000464C
.text$mn:0000464C ; Attributes: bp-based frame
.text$mn:0000464C
.text$mn:0000464C ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __cdecl std::addressof<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:0000464C                 public ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
.text$mn:0000464C ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z proc near
.text$mn:0000464C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+Dp
.text$mn:0000464C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Dp
.text$mn:0000464C
.text$mn:0000464C arg_0           = dword ptr  8
.text$mn:0000464C
.text$mn:0000464C                 push    ebp
.text$mn:0000464D                 mov     ebp, esp
.text$mn:0000464F                 mov     eax, [ebp+arg_0]
.text$mn:00004652                 pop     ebp
.text$mn:00004653                 retn
.text$mn:00004653 ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z endp
.text$mn:00004653
.text$mn:00004653 _text$mn        ends
.text$mn:00004653
.text$mn:00004654 ; ===========================================================================
.text$mn:00004654
.text$mn:00004654 ; Segment type: Pure code
.text$mn:00004654 ; Segment permissions: Read/Execute
.text$mn:00004654 _text$mn        segment para public 'CODE' use32
.text$mn:00004654                 assume cs:_text$mn
.text$mn:00004654                 ;org 4654h
.text$mn:00004654 ; COMDAT (pick any)
.text$mn:00004654                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004654
.text$mn:00004654 ; =============== S U B R O U T I N E =======================================
.text$mn:00004654
.text$mn:00004654 ; Attributes: bp-based frame
.text$mn:00004654
.text$mn:00004654 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00004654                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00004654 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00004654                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00004654                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:00004654
.text$mn:00004654 arg_0           = dword ptr  8
.text$mn:00004654
.text$mn:00004654                 push    ebp
.text$mn:00004655                 mov     ebp, esp
.text$mn:00004657                 mov     eax, [ebp+arg_0]
.text$mn:0000465A                 pop     ebp
.text$mn:0000465B                 retn
.text$mn:0000465B ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:0000465B
.text$mn:0000465B _text$mn        ends
.text$mn:0000465B
.text$mn:0000465C ; ===========================================================================
.text$mn:0000465C
.text$mn:0000465C ; Segment type: Pure code
.text$mn:0000465C ; Segment permissions: Read/Execute
.text$mn:0000465C _text$mn        segment para public 'CODE' use32
.text$mn:0000465C                 assume cs:_text$mn
.text$mn:0000465C                 ;org 465Ch
.text$mn:0000465C ; COMDAT (pick any)
.text$mn:0000465C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000465C
.text$mn:0000465C ; =============== S U B R O U T I N E =======================================
.text$mn:0000465C
.text$mn:0000465C ; Attributes: bp-based frame
.text$mn:0000465C
.text$mn:0000465C ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:0000465C                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:0000465C ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000465C                                         ; CODE XREF: $LN19+4Bp
.text$mn:0000465C
.text$mn:0000465C var_4           = dword ptr -4
.text$mn:0000465C arg_0           = dword ptr  8
.text$mn:0000465C arg_4           = dword ptr  0Ch
.text$mn:0000465C
.text$mn:0000465C                 push    ebp
.text$mn:0000465D                 mov     ebp, esp
.text$mn:0000465F                 push    ecx
.text$mn:00004660                 mov     [ebp+var_4], ecx
.text$mn:00004663                 mov     eax, [ebp+arg_4]
.text$mn:00004666                 push    eax
.text$mn:00004667                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000466C                 add     esp, 4
.text$mn:0000466F                 push    eax             ; int
.text$mn:00004670                 mov     ecx, [ebp+arg_0]
.text$mn:00004673                 push    ecx             ; void *
.text$mn:00004674                 mov     edx, [ebp+var_4]
.text$mn:00004677                 push    edx             ; int
.text$mn:00004678                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:0000467D                 add     esp, 0Ch
.text$mn:00004680                 mov     esp, ebp
.text$mn:00004682                 pop     ebp
.text$mn:00004683                 retn    8
.text$mn:00004683 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00004683
.text$mn:00004683 ; ---------------------------------------------------------------------------
.text$mn:00004686                 align 4
.text$mn:00004686 _text$mn        ends
.text$mn:00004686
.text$mn:00004688 ; ===========================================================================
.text$mn:00004688
.text$mn:00004688 ; Segment type: Pure code
.text$mn:00004688 ; Segment permissions: Read/Execute
.text$mn:00004688 _text$mn        segment para public 'CODE' use32
.text$mn:00004688                 assume cs:_text$mn
.text$mn:00004688                 ;org 4688h
.text$mn:00004688 ; COMDAT (pick any)
.text$mn:00004688                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004688
.text$mn:00004688 ; =============== S U B R O U T I N E =======================================
.text$mn:00004688
.text$mn:00004688 ; Attributes: bp-based frame
.text$mn:00004688
.text$mn:00004688 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00004688                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00004688 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00004688                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00004688
.text$mn:00004688 var_1C          = dword ptr -1Ch
.text$mn:00004688 var_18          = dword ptr -18h
.text$mn:00004688 var_14          = dword ptr -14h
.text$mn:00004688 var_10          = dword ptr -10h
.text$mn:00004688 var_C           = dword ptr -0Ch
.text$mn:00004688 var_4           = dword ptr -4
.text$mn:00004688 arg_0           = dword ptr  8
.text$mn:00004688 arg_4           = dword ptr  0Ch
.text$mn:00004688
.text$mn:00004688                 push    ebp
.text$mn:00004689                 mov     ebp, esp
.text$mn:0000468B                 push    0FFFFFFFFh
.text$mn:0000468D                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00004692                 mov     eax, large fs:0
.text$mn:00004698                 push    eax
.text$mn:00004699                 sub     esp, 10h
.text$mn:0000469C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000046A1                 xor     eax, ebp
.text$mn:000046A3                 push    eax
.text$mn:000046A4                 lea     eax, [ebp+var_C]
.text$mn:000046A7                 mov     large fs:0, eax
.text$mn:000046AD                 mov     [ebp+var_18], ecx
.text$mn:000046B0                 mov     eax, [ebp+arg_0]
.text$mn:000046B3                 push    eax             ; void *
.text$mn:000046B4                 push    4               ; unsigned int
.text$mn:000046B6                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000046BB                 add     esp, 8
.text$mn:000046BE                 mov     [ebp+var_10], eax
.text$mn:000046C1                 mov     [ebp+var_4], 0
.text$mn:000046C8                 cmp     [ebp+var_10], 0
.text$mn:000046CC                 jz      short loc_46E9
.text$mn:000046CE                 mov     ecx, [ebp+arg_4]
.text$mn:000046D1                 push    ecx
.text$mn:000046D2                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000046D7                 add     esp, 4
.text$mn:000046DA                 mov     edx, [ebp+var_10]
.text$mn:000046DD                 mov     eax, [eax]
.text$mn:000046DF                 mov     [edx], eax
.text$mn:000046E1                 mov     ecx, [ebp+var_10]
.text$mn:000046E4                 mov     [ebp+var_14], ecx
.text$mn:000046E7                 jmp     short loc_46F0
.text$mn:000046E9 ; ---------------------------------------------------------------------------
.text$mn:000046E9
.text$mn:000046E9 loc_46E9:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000046E9                 mov     [ebp+var_14], 0
.text$mn:000046F0
.text$mn:000046F0 loc_46F0:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000046F0                 mov     edx, [ebp+var_14]
.text$mn:000046F3                 mov     [ebp+var_1C], edx
.text$mn:000046F6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000046FD                 mov     ecx, [ebp+var_C]
.text$mn:00004700                 mov     large fs:0, ecx
.text$mn:00004707                 pop     ecx
.text$mn:00004708                 mov     esp, ebp
.text$mn:0000470A                 pop     ebp
.text$mn:0000470B                 retn    8
.text$mn:0000470B ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000470B
.text$mn:0000470B ; ---------------------------------------------------------------------------
.text$mn:0000470E                 align 10h
.text$mn:0000470E _text$mn        ends
.text$mn:0000470E
.text$x:00004710 ; ===========================================================================
.text$x:00004710
.text$x:00004710 ; Segment type: Pure code
.text$x:00004710 ; Segment permissions: Read/Execute
.text$x:00004710 _text$x         segment para public 'CODE' use32
.text$x:00004710                 assume cs:_text$x
.text$x:00004710                 ;org 4710h
.text$x:00004710 ; COMDAT (pick associative to section at 4688)
.text$x:00004710                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004710
.text$x:00004710 ; =============== S U B R O U T I N E =======================================
.text$x:00004710
.text$x:00004710
.text$x:00004710 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00004710                                         ; DATA XREF: .xdata$x:0000D78Co
.text$x:00004710                 mov     eax, [ebp+8]
.text$x:00004713                 push    eax
.text$x:00004714                 mov     eax, [ebp-10h]
.text$x:00004717                 push    eax             ; void *
.text$x:00004718                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000471D                 add     esp, 8
.text$x:00004720                 retn
.text$x:00004720 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00004720
.text$x:00004721
.text$x:00004721 ; =============== S U B R O U T I N E =======================================
.text$x:00004721
.text$x:00004721
.text$x:00004721 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00004721                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00004721
.text$x:00004721 arg_4           = dword ptr  8
.text$x:00004721
.text$x:00004721                 mov     edx, [esp+arg_4]
.text$x:00004725                 lea     eax, [edx+0Ch]
.text$x:00004728                 mov     ecx, [edx-14h]
.text$x:0000472B                 xor     ecx, eax
.text$x:0000472D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004732                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00004737                 jmp     ___CxxFrameHandler3
.text$x:00004737 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00004737
.text$x:00004737 _text$x         ends
.text$x:00004737
.text$mn:0000473C ; ===========================================================================
.text$mn:0000473C
.text$mn:0000473C ; Segment type: Pure code
.text$mn:0000473C ; Segment permissions: Read/Execute
.text$mn:0000473C _text$mn        segment para public 'CODE' use32
.text$mn:0000473C                 assume cs:_text$mn
.text$mn:0000473C                 ;org 473Ch
.text$mn:0000473C ; COMDAT (pick any)
.text$mn:0000473C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000473C
.text$mn:0000473C ; =============== S U B R O U T I N E =======================================
.text$mn:0000473C
.text$mn:0000473C ; Attributes: bp-based frame
.text$mn:0000473C
.text$mn:0000473C ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:0000473C                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:0000473C ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:0000473C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:0000473C
.text$mn:0000473C arg_0           = dword ptr  8
.text$mn:0000473C arg_4           = dword ptr  0Ch
.text$mn:0000473C arg_8           = dword ptr  10h
.text$mn:0000473C
.text$mn:0000473C                 push    ebp
.text$mn:0000473D                 mov     ebp, esp
.text$mn:0000473F                 mov     eax, [ebp+arg_8]
.text$mn:00004742                 push    eax
.text$mn:00004743                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00004748                 add     esp, 4
.text$mn:0000474B                 push    eax             ; int
.text$mn:0000474C                 mov     ecx, [ebp+arg_4]
.text$mn:0000474F                 push    ecx             ; void *
.text$mn:00004750                 mov     ecx, [ebp+arg_0]
.text$mn:00004753                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00004758                 pop     ebp
.text$mn:00004759                 retn
.text$mn:00004759 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00004759
.text$mn:00004759 ; ---------------------------------------------------------------------------
.text$mn:0000475A                 align 4
.text$mn:0000475A _text$mn        ends
.text$mn:0000475A
.text$mn:0000475C ; ===========================================================================
.text$mn:0000475C
.text$mn:0000475C ; Segment type: Pure code
.text$mn:0000475C ; Segment permissions: Read/Execute
.text$mn:0000475C _text$mn        segment para public 'CODE' use32
.text$mn:0000475C                 assume cs:_text$mn
.text$mn:0000475C                 ;org 475Ch
.text$mn:0000475C ; COMDAT (pick any)
.text$mn:0000475C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000475C
.text$mn:0000475C ; =============== S U B R O U T I N E =======================================
.text$mn:0000475C
.text$mn:0000475C ; Attributes: bp-based frame
.text$mn:0000475C
.text$mn:0000475C ; int __stdcall std::_Wrap_alloc<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * &>(void *, int)
.text$mn:0000475C                 public ??$construct@PAUPluginInfo@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z
.text$mn:0000475C ??$construct@PAUPluginInfo@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z proc near
.text$mn:0000475C                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+8Dp
.text$mn:0000475C
.text$mn:0000475C var_4           = dword ptr -4
.text$mn:0000475C arg_0           = dword ptr  8
.text$mn:0000475C arg_4           = dword ptr  0Ch
.text$mn:0000475C
.text$mn:0000475C                 push    ebp
.text$mn:0000475D                 mov     ebp, esp
.text$mn:0000475F                 push    ecx
.text$mn:00004760                 mov     [ebp+var_4], ecx
.text$mn:00004763                 mov     eax, [ebp+arg_4]
.text$mn:00004766                 push    eax
.text$mn:00004767                 call    ??$forward@AAPAUPluginInfo@@@std@@YAAAPAUPluginInfo@@AAPAU1@@Z ; std::forward<PluginInfo * &>(PluginInfo * &)
.text$mn:0000476C                 add     esp, 4
.text$mn:0000476F                 push    eax             ; int
.text$mn:00004770                 mov     ecx, [ebp+arg_0]
.text$mn:00004773                 push    ecx             ; void *
.text$mn:00004774                 mov     edx, [ebp+var_4]
.text$mn:00004777                 push    edx             ; int
.text$mn:00004778                 call    ??$construct@PAUPluginInfo@@AAPAU1@@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAXAAV?$allocator@PAUPluginInfo@@@1@PAPAUPluginInfo@@AAPAU3@@Z ; std::allocator_traits<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * &>(std::allocator<PluginInfo *> &,PluginInfo * *,PluginInfo * &)
.text$mn:0000477D                 add     esp, 0Ch
.text$mn:00004780                 mov     esp, ebp
.text$mn:00004782                 pop     ebp
.text$mn:00004783                 retn    8
.text$mn:00004783 ??$construct@PAUPluginInfo@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z endp
.text$mn:00004783
.text$mn:00004783 ; ---------------------------------------------------------------------------
.text$mn:00004786                 align 4
.text$mn:00004786 _text$mn        ends
.text$mn:00004786
.text$mn:00004788 ; ===========================================================================
.text$mn:00004788
.text$mn:00004788 ; Segment type: Pure code
.text$mn:00004788 ; Segment permissions: Read/Execute
.text$mn:00004788 _text$mn        segment para public 'CODE' use32
.text$mn:00004788                 assume cs:_text$mn
.text$mn:00004788                 ;org 4788h
.text$mn:00004788 ; COMDAT (pick any)
.text$mn:00004788                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004788
.text$mn:00004788 ; =============== S U B R O U T I N E =======================================
.text$mn:00004788
.text$mn:00004788 ; Attributes: bp-based frame
.text$mn:00004788
.text$mn:00004788 ; int __stdcall std::allocator<PluginInfo *>::construct<PluginInfo *,PluginInfo * &>(void *, int)
.text$mn:00004788                 public ??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z
.text$mn:00004788 ??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z proc near
.text$mn:00004788                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * &>(std::allocator<PluginInfo *> &,PluginInfo * *,PluginInfo * &)+17p
.text$mn:00004788
.text$mn:00004788 var_1C          = dword ptr -1Ch
.text$mn:00004788 var_18          = dword ptr -18h
.text$mn:00004788 var_14          = dword ptr -14h
.text$mn:00004788 var_10          = dword ptr -10h
.text$mn:00004788 var_C           = dword ptr -0Ch
.text$mn:00004788 var_4           = dword ptr -4
.text$mn:00004788 arg_0           = dword ptr  8
.text$mn:00004788 arg_4           = dword ptr  0Ch
.text$mn:00004788
.text$mn:00004788                 push    ebp
.text$mn:00004789                 mov     ebp, esp
.text$mn:0000478B                 push    0FFFFFFFFh
.text$mn:0000478D                 push    offset __ehhandler$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z
.text$mn:00004792                 mov     eax, large fs:0
.text$mn:00004798                 push    eax
.text$mn:00004799                 sub     esp, 10h
.text$mn:0000479C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000047A1                 xor     eax, ebp
.text$mn:000047A3                 push    eax
.text$mn:000047A4                 lea     eax, [ebp+var_C]
.text$mn:000047A7                 mov     large fs:0, eax
.text$mn:000047AD                 mov     [ebp+var_18], ecx
.text$mn:000047B0                 mov     eax, [ebp+arg_0]
.text$mn:000047B3                 push    eax             ; void *
.text$mn:000047B4                 push    4               ; unsigned int
.text$mn:000047B6                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000047BB                 add     esp, 8
.text$mn:000047BE                 mov     [ebp+var_10], eax
.text$mn:000047C1                 mov     [ebp+var_4], 0
.text$mn:000047C8                 cmp     [ebp+var_10], 0
.text$mn:000047CC                 jz      short loc_47E9
.text$mn:000047CE                 mov     ecx, [ebp+arg_4]
.text$mn:000047D1                 push    ecx
.text$mn:000047D2                 call    ??$forward@AAPAUPluginInfo@@@std@@YAAAPAUPluginInfo@@AAPAU1@@Z ; std::forward<PluginInfo * &>(PluginInfo * &)
.text$mn:000047D7                 add     esp, 4
.text$mn:000047DA                 mov     edx, [ebp+var_10]
.text$mn:000047DD                 mov     eax, [eax]
.text$mn:000047DF                 mov     [edx], eax
.text$mn:000047E1                 mov     ecx, [ebp+var_10]
.text$mn:000047E4                 mov     [ebp+var_14], ecx
.text$mn:000047E7                 jmp     short loc_47F0
.text$mn:000047E9 ; ---------------------------------------------------------------------------
.text$mn:000047E9
.text$mn:000047E9 loc_47E9:                               ; CODE XREF: std::allocator<PluginInfo *>::construct<PluginInfo *,PluginInfo * &>(PluginInfo * *,PluginInfo * &)+44j
.text$mn:000047E9                 mov     [ebp+var_14], 0
.text$mn:000047F0
.text$mn:000047F0 loc_47F0:                               ; CODE XREF: std::allocator<PluginInfo *>::construct<PluginInfo *,PluginInfo * &>(PluginInfo * *,PluginInfo * &)+5Fj
.text$mn:000047F0                 mov     edx, [ebp+var_14]
.text$mn:000047F3                 mov     [ebp+var_1C], edx
.text$mn:000047F6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000047FD                 mov     ecx, [ebp+var_C]
.text$mn:00004800                 mov     large fs:0, ecx
.text$mn:00004807                 pop     ecx
.text$mn:00004808                 mov     esp, ebp
.text$mn:0000480A                 pop     ebp
.text$mn:0000480B                 retn    8
.text$mn:0000480B ??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z endp
.text$mn:0000480B
.text$mn:0000480B ; ---------------------------------------------------------------------------
.text$mn:0000480E                 align 10h
.text$mn:0000480E _text$mn        ends
.text$mn:0000480E
.text$x:00004810 ; ===========================================================================
.text$x:00004810
.text$x:00004810 ; Segment type: Pure code
.text$x:00004810 ; Segment permissions: Read/Execute
.text$x:00004810 _text$x         segment para public 'CODE' use32
.text$x:00004810                 assume cs:_text$x
.text$x:00004810                 ;org 4810h
.text$x:00004810 ; COMDAT (pick associative to section at 4788)
.text$x:00004810                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004810
.text$x:00004810 ; =============== S U B R O U T I N E =======================================
.text$x:00004810
.text$x:00004810
.text$x:00004810 __unwindfunclet$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z$0 proc near
.text$x:00004810                                         ; DATA XREF: .xdata$x:0000D734o
.text$x:00004810                 mov     eax, [ebp+8]
.text$x:00004813                 push    eax
.text$x:00004814                 mov     eax, [ebp-10h]
.text$x:00004817                 push    eax             ; void *
.text$x:00004818                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000481D                 add     esp, 8
.text$x:00004820                 retn
.text$x:00004820 __unwindfunclet$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z$0 endp
.text$x:00004820
.text$x:00004821
.text$x:00004821 ; =============== S U B R O U T I N E =======================================
.text$x:00004821
.text$x:00004821
.text$x:00004821 __ehhandler$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z proc near
.text$x:00004821                                         ; DATA XREF: std::allocator<PluginInfo *>::construct<PluginInfo *,PluginInfo * &>(PluginInfo * *,PluginInfo * &)+5o
.text$x:00004821
.text$x:00004821 arg_4           = dword ptr  8
.text$x:00004821
.text$x:00004821                 mov     edx, [esp+arg_4]
.text$x:00004825                 lea     eax, [edx+0Ch]
.text$x:00004828                 mov     ecx, [edx-14h]
.text$x:0000482B                 xor     ecx, eax
.text$x:0000482D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004832                 mov     eax, offset __ehfuncinfo$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z
.text$x:00004837                 jmp     ___CxxFrameHandler3
.text$x:00004837 __ehhandler$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z endp
.text$x:00004837
.text$x:00004837 _text$x         ends
.text$x:00004837
.text$mn:0000483C ; ===========================================================================
.text$mn:0000483C
.text$mn:0000483C ; Segment type: Pure code
.text$mn:0000483C ; Segment permissions: Read/Execute
.text$mn:0000483C _text$mn        segment para public 'CODE' use32
.text$mn:0000483C                 assume cs:_text$mn
.text$mn:0000483C                 ;org 483Ch
.text$mn:0000483C ; COMDAT (pick any)
.text$mn:0000483C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000483C
.text$mn:0000483C ; =============== S U B R O U T I N E =======================================
.text$mn:0000483C
.text$mn:0000483C ; Attributes: bp-based frame
.text$mn:0000483C
.text$mn:0000483C ; int __cdecl std::allocator_traits<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * &>(int, void *, int)
.text$mn:0000483C                 public ??$construct@PAUPluginInfo@@AAPAU1@@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAXAAV?$allocator@PAUPluginInfo@@@1@PAPAUPluginInfo@@AAPAU3@@Z
.text$mn:0000483C ??$construct@PAUPluginInfo@@AAPAU1@@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAXAAV?$allocator@PAUPluginInfo@@@1@PAPAUPluginInfo@@AAPAU3@@Z proc near
.text$mn:0000483C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * &>(PluginInfo * *,PluginInfo * &)+1Cp
.text$mn:0000483C
.text$mn:0000483C arg_0           = dword ptr  8
.text$mn:0000483C arg_4           = dword ptr  0Ch
.text$mn:0000483C arg_8           = dword ptr  10h
.text$mn:0000483C
.text$mn:0000483C                 push    ebp
.text$mn:0000483D                 mov     ebp, esp
.text$mn:0000483F                 mov     eax, [ebp+arg_8]
.text$mn:00004842                 push    eax
.text$mn:00004843                 call    ??$forward@AAPAUPluginInfo@@@std@@YAAAPAUPluginInfo@@AAPAU1@@Z ; std::forward<PluginInfo * &>(PluginInfo * &)
.text$mn:00004848                 add     esp, 4
.text$mn:0000484B                 push    eax             ; int
.text$mn:0000484C                 mov     ecx, [ebp+arg_4]
.text$mn:0000484F                 push    ecx             ; void *
.text$mn:00004850                 mov     ecx, [ebp+arg_0]
.text$mn:00004853                 call    ??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z ; std::allocator<PluginInfo *>::construct<PluginInfo *,PluginInfo * &>(PluginInfo * *,PluginInfo * &)
.text$mn:00004858                 pop     ebp
.text$mn:00004859                 retn
.text$mn:00004859 ??$construct@PAUPluginInfo@@AAPAU1@@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAXAAV?$allocator@PAUPluginInfo@@@1@PAPAUPluginInfo@@AAPAU3@@Z endp
.text$mn:00004859
.text$mn:00004859 ; ---------------------------------------------------------------------------
.text$mn:0000485A                 align 4
.text$mn:0000485A _text$mn        ends
.text$mn:0000485A
.text$mn:0000485C ; ===========================================================================
.text$mn:0000485C
.text$mn:0000485C ; Segment type: Pure code
.text$mn:0000485C ; Segment permissions: Read/Execute
.text$mn:0000485C _text$mn        segment para public 'CODE' use32
.text$mn:0000485C                 assume cs:_text$mn
.text$mn:0000485C                 ;org 485Ch
.text$mn:0000485C ; COMDAT (pick any)
.text$mn:0000485C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000485C
.text$mn:0000485C ; =============== S U B R O U T I N E =======================================
.text$mn:0000485C
.text$mn:0000485C ; Attributes: bp-based frame
.text$mn:0000485C
.text$mn:0000485C ; int __stdcall std::_Wrap_alloc<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * const &>(void *, int)
.text$mn:0000485C                 public ??$construct@PAUPluginInfo@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@ABQAU2@@Z
.text$mn:0000485C ??$construct@PAUPluginInfo@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@ABQAU2@@Z proc near
.text$mn:0000485C                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+EAp
.text$mn:0000485C
.text$mn:0000485C var_4           = dword ptr -4
.text$mn:0000485C arg_0           = dword ptr  8
.text$mn:0000485C arg_4           = dword ptr  0Ch
.text$mn:0000485C
.text$mn:0000485C                 push    ebp
.text$mn:0000485D                 mov     ebp, esp
.text$mn:0000485F                 push    ecx
.text$mn:00004860                 mov     [ebp+var_4], ecx
.text$mn:00004863                 mov     eax, [ebp+arg_4]
.text$mn:00004866                 push    eax
.text$mn:00004867                 call    ??$forward@ABQAUPluginInfo@@@std@@YAABQAUPluginInfo@@ABQAU1@@Z ; std::forward<PluginInfo * const &>(PluginInfo * const &)
.text$mn:0000486C                 add     esp, 4
.text$mn:0000486F                 push    eax             ; int
.text$mn:00004870                 mov     ecx, [ebp+arg_0]
.text$mn:00004873                 push    ecx             ; void *
.text$mn:00004874                 mov     edx, [ebp+var_4]
.text$mn:00004877                 push    edx             ; int
.text$mn:00004878                 call    ??$construct@PAUPluginInfo@@ABQAU1@@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAXAAV?$allocator@PAUPluginInfo@@@1@PAPAUPluginInfo@@ABQAU3@@Z ; std::allocator_traits<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * const &>(std::allocator<PluginInfo *> &,PluginInfo * *,PluginInfo * const &)
.text$mn:0000487D                 add     esp, 0Ch
.text$mn:00004880                 mov     esp, ebp
.text$mn:00004882                 pop     ebp
.text$mn:00004883                 retn    8
.text$mn:00004883 ??$construct@PAUPluginInfo@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@ABQAU2@@Z endp
.text$mn:00004883
.text$mn:00004883 ; ---------------------------------------------------------------------------
.text$mn:00004886                 align 4
.text$mn:00004886 _text$mn        ends
.text$mn:00004886
.text$mn:00004888 ; ===========================================================================
.text$mn:00004888
.text$mn:00004888 ; Segment type: Pure code
.text$mn:00004888 ; Segment permissions: Read/Execute
.text$mn:00004888 _text$mn        segment para public 'CODE' use32
.text$mn:00004888                 assume cs:_text$mn
.text$mn:00004888                 ;org 4888h
.text$mn:00004888 ; COMDAT (pick any)
.text$mn:00004888                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004888
.text$mn:00004888 ; =============== S U B R O U T I N E =======================================
.text$mn:00004888
.text$mn:00004888 ; Attributes: bp-based frame
.text$mn:00004888
.text$mn:00004888 ; int __cdecl std::allocator_traits<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * const &>(int, void *, int)
.text$mn:00004888                 public ??$construct@PAUPluginInfo@@ABQAU1@@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAXAAV?$allocator@PAUPluginInfo@@@1@PAPAUPluginInfo@@ABQAU3@@Z
.text$mn:00004888 ??$construct@PAUPluginInfo@@ABQAU1@@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAXAAV?$allocator@PAUPluginInfo@@@1@PAPAUPluginInfo@@ABQAU3@@Z proc near
.text$mn:00004888                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * const &>(PluginInfo * *,PluginInfo * const &)+1Cp
.text$mn:00004888
.text$mn:00004888 arg_0           = dword ptr  8
.text$mn:00004888 arg_4           = dword ptr  0Ch
.text$mn:00004888 arg_8           = dword ptr  10h
.text$mn:00004888
.text$mn:00004888                 push    ebp
.text$mn:00004889                 mov     ebp, esp
.text$mn:0000488B                 mov     eax, [ebp+arg_8]
.text$mn:0000488E                 push    eax
.text$mn:0000488F                 call    ??$forward@ABQAUPluginInfo@@@std@@YAABQAUPluginInfo@@ABQAU1@@Z ; std::forward<PluginInfo * const &>(PluginInfo * const &)
.text$mn:00004894                 add     esp, 4
.text$mn:00004897                 push    eax             ; int
.text$mn:00004898                 mov     ecx, [ebp+arg_4]
.text$mn:0000489B                 push    ecx             ; void *
.text$mn:0000489C                 mov     ecx, [ebp+arg_0]
.text$mn:0000489F                 call    ?construct@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@ABQAU3@@Z ; std::allocator<PluginInfo *>::construct(PluginInfo * *,PluginInfo * const &)
.text$mn:000048A4                 pop     ebp
.text$mn:000048A5                 retn
.text$mn:000048A5 ??$construct@PAUPluginInfo@@ABQAU1@@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAXAAV?$allocator@PAUPluginInfo@@@1@PAPAUPluginInfo@@ABQAU3@@Z endp
.text$mn:000048A5
.text$mn:000048A5 ; ---------------------------------------------------------------------------
.text$mn:000048A6                 align 4
.text$mn:000048A6 _text$mn        ends
.text$mn:000048A6
.text$mn:000048A8 ; ===========================================================================
.text$mn:000048A8
.text$mn:000048A8 ; Segment type: Pure code
.text$mn:000048A8 ; Segment permissions: Read/Execute
.text$mn:000048A8 _text$mn        segment para public 'CODE' use32
.text$mn:000048A8                 assume cs:_text$mn
.text$mn:000048A8                 ;org 48A8h
.text$mn:000048A8 ; COMDAT (pick any)
.text$mn:000048A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000048A8
.text$mn:000048A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000048A8
.text$mn:000048A8 ; Attributes: bp-based frame
.text$mn:000048A8
.text$mn:000048A8 ; int __stdcall std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * &>(void *, int)
.text$mn:000048A8                 public ??$construct@PAVTiXmlDocument@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z
.text$mn:000048A8 ??$construct@PAVTiXmlDocument@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z proc near
.text$mn:000048A8                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+8Dp
.text$mn:000048A8
.text$mn:000048A8 var_4           = dword ptr -4
.text$mn:000048A8 arg_0           = dword ptr  8
.text$mn:000048A8 arg_4           = dword ptr  0Ch
.text$mn:000048A8
.text$mn:000048A8                 push    ebp
.text$mn:000048A9                 mov     ebp, esp
.text$mn:000048AB                 push    ecx
.text$mn:000048AC                 mov     [ebp+var_4], ecx
.text$mn:000048AF                 mov     eax, [ebp+arg_4]
.text$mn:000048B2                 push    eax
.text$mn:000048B3                 call    ??$forward@AAPAVTiXmlDocument@@@std@@YAAAPAVTiXmlDocument@@AAPAV1@@Z ; std::forward<TiXmlDocument * &>(TiXmlDocument * &)
.text$mn:000048B8                 add     esp, 4
.text$mn:000048BB                 push    eax             ; int
.text$mn:000048BC                 mov     ecx, [ebp+arg_0]
.text$mn:000048BF                 push    ecx             ; void *
.text$mn:000048C0                 mov     edx, [ebp+var_4]
.text$mn:000048C3                 push    edx             ; int
.text$mn:000048C4                 call    ??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAXAAV?$allocator@PAVTiXmlDocument@@@1@PAPAVTiXmlDocument@@AAPAV3@@Z ; std::allocator_traits<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * &>(std::allocator<TiXmlDocument *> &,TiXmlDocument * *,TiXmlDocument * &)
.text$mn:000048C9                 add     esp, 0Ch
.text$mn:000048CC                 mov     esp, ebp
.text$mn:000048CE                 pop     ebp
.text$mn:000048CF                 retn    8
.text$mn:000048CF ??$construct@PAVTiXmlDocument@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z endp
.text$mn:000048CF
.text$mn:000048CF ; ---------------------------------------------------------------------------
.text$mn:000048D2                 align 4
.text$mn:000048D2 _text$mn        ends
.text$mn:000048D2
.text$mn:000048D4 ; ===========================================================================
.text$mn:000048D4
.text$mn:000048D4 ; Segment type: Pure code
.text$mn:000048D4 ; Segment permissions: Read/Execute
.text$mn:000048D4 _text$mn        segment para public 'CODE' use32
.text$mn:000048D4                 assume cs:_text$mn
.text$mn:000048D4                 ;org 48D4h
.text$mn:000048D4 ; COMDAT (pick any)
.text$mn:000048D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000048D4
.text$mn:000048D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000048D4
.text$mn:000048D4 ; Attributes: bp-based frame
.text$mn:000048D4
.text$mn:000048D4 ; int __stdcall std::allocator<TiXmlDocument *>::construct<TiXmlDocument *,TiXmlDocument * &>(void *, int)
.text$mn:000048D4                 public ??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z
.text$mn:000048D4 ??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z proc near
.text$mn:000048D4                                         ; CODE XREF: std::allocator_traits<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * &>(std::allocator<TiXmlDocument *> &,TiXmlDocument * *,TiXmlDocument * &)+17p
.text$mn:000048D4
.text$mn:000048D4 var_1C          = dword ptr -1Ch
.text$mn:000048D4 var_18          = dword ptr -18h
.text$mn:000048D4 var_14          = dword ptr -14h
.text$mn:000048D4 var_10          = dword ptr -10h
.text$mn:000048D4 var_C           = dword ptr -0Ch
.text$mn:000048D4 var_4           = dword ptr -4
.text$mn:000048D4 arg_0           = dword ptr  8
.text$mn:000048D4 arg_4           = dword ptr  0Ch
.text$mn:000048D4
.text$mn:000048D4                 push    ebp
.text$mn:000048D5                 mov     ebp, esp
.text$mn:000048D7                 push    0FFFFFFFFh
.text$mn:000048D9                 push    offset __ehhandler$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z
.text$mn:000048DE                 mov     eax, large fs:0
.text$mn:000048E4                 push    eax
.text$mn:000048E5                 sub     esp, 10h
.text$mn:000048E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000048ED                 xor     eax, ebp
.text$mn:000048EF                 push    eax
.text$mn:000048F0                 lea     eax, [ebp+var_C]
.text$mn:000048F3                 mov     large fs:0, eax
.text$mn:000048F9                 mov     [ebp+var_18], ecx
.text$mn:000048FC                 mov     eax, [ebp+arg_0]
.text$mn:000048FF                 push    eax             ; void *
.text$mn:00004900                 push    4               ; unsigned int
.text$mn:00004902                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004907                 add     esp, 8
.text$mn:0000490A                 mov     [ebp+var_10], eax
.text$mn:0000490D                 mov     [ebp+var_4], 0
.text$mn:00004914                 cmp     [ebp+var_10], 0
.text$mn:00004918                 jz      short loc_4935
.text$mn:0000491A                 mov     ecx, [ebp+arg_4]
.text$mn:0000491D                 push    ecx
.text$mn:0000491E                 call    ??$forward@AAPAVTiXmlDocument@@@std@@YAAAPAVTiXmlDocument@@AAPAV1@@Z ; std::forward<TiXmlDocument * &>(TiXmlDocument * &)
.text$mn:00004923                 add     esp, 4
.text$mn:00004926                 mov     edx, [ebp+var_10]
.text$mn:00004929                 mov     eax, [eax]
.text$mn:0000492B                 mov     [edx], eax
.text$mn:0000492D                 mov     ecx, [ebp+var_10]
.text$mn:00004930                 mov     [ebp+var_14], ecx
.text$mn:00004933                 jmp     short loc_493C
.text$mn:00004935 ; ---------------------------------------------------------------------------
.text$mn:00004935
.text$mn:00004935 loc_4935:                               ; CODE XREF: std::allocator<TiXmlDocument *>::construct<TiXmlDocument *,TiXmlDocument * &>(TiXmlDocument * *,TiXmlDocument * &)+44j
.text$mn:00004935                 mov     [ebp+var_14], 0
.text$mn:0000493C
.text$mn:0000493C loc_493C:                               ; CODE XREF: std::allocator<TiXmlDocument *>::construct<TiXmlDocument *,TiXmlDocument * &>(TiXmlDocument * *,TiXmlDocument * &)+5Fj
.text$mn:0000493C                 mov     edx, [ebp+var_14]
.text$mn:0000493F                 mov     [ebp+var_1C], edx
.text$mn:00004942                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004949                 mov     ecx, [ebp+var_C]
.text$mn:0000494C                 mov     large fs:0, ecx
.text$mn:00004953                 pop     ecx
.text$mn:00004954                 mov     esp, ebp
.text$mn:00004956                 pop     ebp
.text$mn:00004957                 retn    8
.text$mn:00004957 ??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z endp
.text$mn:00004957
.text$mn:00004957 ; ---------------------------------------------------------------------------
.text$mn:0000495A                 align 4
.text$mn:0000495A _text$mn        ends
.text$mn:0000495A
.text$x:0000495C ; ===========================================================================
.text$x:0000495C
.text$x:0000495C ; Segment type: Pure code
.text$x:0000495C ; Segment permissions: Read/Execute
.text$x:0000495C _text$x         segment para public 'CODE' use32
.text$x:0000495C                 assume cs:_text$x
.text$x:0000495C                 ;org 495Ch
.text$x:0000495C ; COMDAT (pick associative to section at 48D4)
.text$x:0000495C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000495C
.text$x:0000495C ; =============== S U B R O U T I N E =======================================
.text$x:0000495C
.text$x:0000495C
.text$x:0000495C __unwindfunclet$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z$0 proc near
.text$x:0000495C                                         ; DATA XREF: .xdata$x:0000D6DCo
.text$x:0000495C                 mov     eax, [ebp+8]
.text$x:0000495F                 push    eax
.text$x:00004960                 mov     eax, [ebp-10h]
.text$x:00004963                 push    eax             ; void *
.text$x:00004964                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004969                 add     esp, 8
.text$x:0000496C                 retn
.text$x:0000496C __unwindfunclet$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z$0 endp
.text$x:0000496C
.text$x:0000496D
.text$x:0000496D ; =============== S U B R O U T I N E =======================================
.text$x:0000496D
.text$x:0000496D
.text$x:0000496D __ehhandler$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z proc near
.text$x:0000496D                                         ; DATA XREF: std::allocator<TiXmlDocument *>::construct<TiXmlDocument *,TiXmlDocument * &>(TiXmlDocument * *,TiXmlDocument * &)+5o
.text$x:0000496D
.text$x:0000496D arg_4           = dword ptr  8
.text$x:0000496D
.text$x:0000496D                 mov     edx, [esp+arg_4]
.text$x:00004971                 lea     eax, [edx+0Ch]
.text$x:00004974                 mov     ecx, [edx-14h]
.text$x:00004977                 xor     ecx, eax
.text$x:00004979                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000497E                 mov     eax, offset __ehfuncinfo$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z
.text$x:00004983                 jmp     ___CxxFrameHandler3
.text$x:00004983 __ehhandler$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z endp
.text$x:00004983
.text$x:00004983 _text$x         ends
.text$x:00004983
.text$mn:00004988 ; ===========================================================================
.text$mn:00004988
.text$mn:00004988 ; Segment type: Pure code
.text$mn:00004988 ; Segment permissions: Read/Execute
.text$mn:00004988 _text$mn        segment para public 'CODE' use32
.text$mn:00004988                 assume cs:_text$mn
.text$mn:00004988                 ;org 4988h
.text$mn:00004988 ; COMDAT (pick any)
.text$mn:00004988                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004988
.text$mn:00004988 ; =============== S U B R O U T I N E =======================================
.text$mn:00004988
.text$mn:00004988 ; Attributes: bp-based frame
.text$mn:00004988
.text$mn:00004988 ; int __cdecl std::allocator_traits<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * &>(int, void *, int)
.text$mn:00004988                 public ??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAXAAV?$allocator@PAVTiXmlDocument@@@1@PAPAVTiXmlDocument@@AAPAV3@@Z
.text$mn:00004988 ??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAXAAV?$allocator@PAVTiXmlDocument@@@1@PAPAVTiXmlDocument@@AAPAV3@@Z proc near
.text$mn:00004988                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * &>(TiXmlDocument * *,TiXmlDocument * &)+1Cp
.text$mn:00004988
.text$mn:00004988 arg_0           = dword ptr  8
.text$mn:00004988 arg_4           = dword ptr  0Ch
.text$mn:00004988 arg_8           = dword ptr  10h
.text$mn:00004988
.text$mn:00004988                 push    ebp
.text$mn:00004989                 mov     ebp, esp
.text$mn:0000498B                 mov     eax, [ebp+arg_8]
.text$mn:0000498E                 push    eax
.text$mn:0000498F                 call    ??$forward@AAPAVTiXmlDocument@@@std@@YAAAPAVTiXmlDocument@@AAPAV1@@Z ; std::forward<TiXmlDocument * &>(TiXmlDocument * &)
.text$mn:00004994                 add     esp, 4
.text$mn:00004997                 push    eax             ; int
.text$mn:00004998                 mov     ecx, [ebp+arg_4]
.text$mn:0000499B                 push    ecx             ; void *
.text$mn:0000499C                 mov     ecx, [ebp+arg_0]
.text$mn:0000499F                 call    ??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z ; std::allocator<TiXmlDocument *>::construct<TiXmlDocument *,TiXmlDocument * &>(TiXmlDocument * *,TiXmlDocument * &)
.text$mn:000049A4                 pop     ebp
.text$mn:000049A5                 retn
.text$mn:000049A5 ??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAXAAV?$allocator@PAVTiXmlDocument@@@1@PAPAVTiXmlDocument@@AAPAV3@@Z endp
.text$mn:000049A5
.text$mn:000049A5 ; ---------------------------------------------------------------------------
.text$mn:000049A6                 align 4
.text$mn:000049A6 _text$mn        ends
.text$mn:000049A6
.text$mn:000049A8 ; ===========================================================================
.text$mn:000049A8
.text$mn:000049A8 ; Segment type: Pure code
.text$mn:000049A8 ; Segment permissions: Read/Execute
.text$mn:000049A8 _text$mn        segment para public 'CODE' use32
.text$mn:000049A8                 assume cs:_text$mn
.text$mn:000049A8                 ;org 49A8h
.text$mn:000049A8 ; COMDAT (pick any)
.text$mn:000049A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000049A8
.text$mn:000049A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000049A8
.text$mn:000049A8 ; Attributes: bp-based frame
.text$mn:000049A8
.text$mn:000049A8 ; int __stdcall std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * const &>(void *, int)
.text$mn:000049A8                 public ??$construct@PAVTiXmlDocument@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@ABQAV2@@Z
.text$mn:000049A8 ??$construct@PAVTiXmlDocument@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@ABQAV2@@Z proc near
.text$mn:000049A8                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+EAp
.text$mn:000049A8
.text$mn:000049A8 var_4           = dword ptr -4
.text$mn:000049A8 arg_0           = dword ptr  8
.text$mn:000049A8 arg_4           = dword ptr  0Ch
.text$mn:000049A8
.text$mn:000049A8                 push    ebp
.text$mn:000049A9                 mov     ebp, esp
.text$mn:000049AB                 push    ecx
.text$mn:000049AC                 mov     [ebp+var_4], ecx
.text$mn:000049AF                 mov     eax, [ebp+arg_4]
.text$mn:000049B2                 push    eax
.text$mn:000049B3                 call    ??$forward@ABQAVTiXmlDocument@@@std@@YAABQAVTiXmlDocument@@ABQAV1@@Z ; std::forward<TiXmlDocument * const &>(TiXmlDocument * const &)
.text$mn:000049B8                 add     esp, 4
.text$mn:000049BB                 push    eax             ; int
.text$mn:000049BC                 mov     ecx, [ebp+arg_0]
.text$mn:000049BF                 push    ecx             ; void *
.text$mn:000049C0                 mov     edx, [ebp+var_4]
.text$mn:000049C3                 push    edx             ; int
.text$mn:000049C4                 call    ??$construct@PAVTiXmlDocument@@ABQAV1@@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAXAAV?$allocator@PAVTiXmlDocument@@@1@PAPAVTiXmlDocument@@ABQAV3@@Z ; std::allocator_traits<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * const &>(std::allocator<TiXmlDocument *> &,TiXmlDocument * *,TiXmlDocument * const &)
.text$mn:000049C9                 add     esp, 0Ch
.text$mn:000049CC                 mov     esp, ebp
.text$mn:000049CE                 pop     ebp
.text$mn:000049CF                 retn    8
.text$mn:000049CF ??$construct@PAVTiXmlDocument@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@ABQAV2@@Z endp
.text$mn:000049CF
.text$mn:000049CF ; ---------------------------------------------------------------------------
.text$mn:000049D2                 align 4
.text$mn:000049D2 _text$mn        ends
.text$mn:000049D2
.text$mn:000049D4 ; ===========================================================================
.text$mn:000049D4
.text$mn:000049D4 ; Segment type: Pure code
.text$mn:000049D4 ; Segment permissions: Read/Execute
.text$mn:000049D4 _text$mn        segment para public 'CODE' use32
.text$mn:000049D4                 assume cs:_text$mn
.text$mn:000049D4                 ;org 49D4h
.text$mn:000049D4 ; COMDAT (pick any)
.text$mn:000049D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000049D4
.text$mn:000049D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000049D4
.text$mn:000049D4 ; Attributes: bp-based frame
.text$mn:000049D4
.text$mn:000049D4 ; int __cdecl std::allocator_traits<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * const &>(int, void *, int)
.text$mn:000049D4                 public ??$construct@PAVTiXmlDocument@@ABQAV1@@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAXAAV?$allocator@PAVTiXmlDocument@@@1@PAPAVTiXmlDocument@@ABQAV3@@Z
.text$mn:000049D4 ??$construct@PAVTiXmlDocument@@ABQAV1@@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAXAAV?$allocator@PAVTiXmlDocument@@@1@PAPAVTiXmlDocument@@ABQAV3@@Z proc near
.text$mn:000049D4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * const &>(TiXmlDocument * *,TiXmlDocument * const &)+1Cp
.text$mn:000049D4
.text$mn:000049D4 arg_0           = dword ptr  8
.text$mn:000049D4 arg_4           = dword ptr  0Ch
.text$mn:000049D4 arg_8           = dword ptr  10h
.text$mn:000049D4
.text$mn:000049D4                 push    ebp
.text$mn:000049D5                 mov     ebp, esp
.text$mn:000049D7                 mov     eax, [ebp+arg_8]
.text$mn:000049DA                 push    eax
.text$mn:000049DB                 call    ??$forward@ABQAVTiXmlDocument@@@std@@YAABQAVTiXmlDocument@@ABQAV1@@Z ; std::forward<TiXmlDocument * const &>(TiXmlDocument * const &)
.text$mn:000049E0                 add     esp, 4
.text$mn:000049E3                 push    eax             ; int
.text$mn:000049E4                 mov     ecx, [ebp+arg_4]
.text$mn:000049E7                 push    ecx             ; void *
.text$mn:000049E8                 mov     ecx, [ebp+arg_0]
.text$mn:000049EB                 call    ?construct@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@ABQAV3@@Z ; std::allocator<TiXmlDocument *>::construct(TiXmlDocument * *,TiXmlDocument * const &)
.text$mn:000049F0                 pop     ebp
.text$mn:000049F1                 retn
.text$mn:000049F1 ??$construct@PAVTiXmlDocument@@ABQAV1@@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAXAAV?$allocator@PAVTiXmlDocument@@@1@PAPAVTiXmlDocument@@ABQAV3@@Z endp
.text$mn:000049F1
.text$mn:000049F1 ; ---------------------------------------------------------------------------
.text$mn:000049F2                 align 4
.text$mn:000049F2 _text$mn        ends
.text$mn:000049F2
.text$mn:000049F4 ; ===========================================================================
.text$mn:000049F4
.text$mn:000049F4 ; Segment type: Pure code
.text$mn:000049F4 ; Segment permissions: Read/Execute
.text$mn:000049F4 _text$mn        segment para public 'CODE' use32
.text$mn:000049F4                 assume cs:_text$mn
.text$mn:000049F4                 ;org 49F4h
.text$mn:000049F4 ; COMDAT (pick any)
.text$mn:000049F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000049F4
.text$mn:000049F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000049F4
.text$mn:000049F4 ; Attributes: bp-based frame
.text$mn:000049F4
.text$mn:000049F4 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:000049F4                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000049F4 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:000049F4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+50p
.text$mn:000049F4                                         ; $LN19_0+4Bp
.text$mn:000049F4
.text$mn:000049F4 var_4           = dword ptr -4
.text$mn:000049F4 arg_0           = dword ptr  8
.text$mn:000049F4 arg_4           = dword ptr  0Ch
.text$mn:000049F4
.text$mn:000049F4                 push    ebp
.text$mn:000049F5                 mov     ebp, esp
.text$mn:000049F7                 push    ecx
.text$mn:000049F8                 mov     [ebp+var_4], ecx
.text$mn:000049FB                 mov     eax, [ebp+arg_4]
.text$mn:000049FE                 push    eax
.text$mn:000049FF                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00004A04                 add     esp, 4
.text$mn:00004A07                 push    eax             ; int
.text$mn:00004A08                 mov     ecx, [ebp+arg_0]
.text$mn:00004A0B                 push    ecx             ; void *
.text$mn:00004A0C                 mov     edx, [ebp+var_4]
.text$mn:00004A0F                 push    edx             ; int
.text$mn:00004A10                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00004A15                 add     esp, 0Ch
.text$mn:00004A18                 mov     esp, ebp
.text$mn:00004A1A                 pop     ebp
.text$mn:00004A1B                 retn    8
.text$mn:00004A1B ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00004A1B
.text$mn:00004A1B ; ---------------------------------------------------------------------------
.text$mn:00004A1E                 align 10h
.text$mn:00004A1E _text$mn        ends
.text$mn:00004A1E
.text$mn:00004A20 ; ===========================================================================
.text$mn:00004A20
.text$mn:00004A20 ; Segment type: Pure code
.text$mn:00004A20 ; Segment permissions: Read/Execute
.text$mn:00004A20 _text$mn        segment para public 'CODE' use32
.text$mn:00004A20                 assume cs:_text$mn
.text$mn:00004A20                 ;org 4A20h
.text$mn:00004A20 ; COMDAT (pick any)
.text$mn:00004A20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004A20
.text$mn:00004A20 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A20
.text$mn:00004A20 ; Attributes: bp-based frame
.text$mn:00004A20
.text$mn:00004A20 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00004A20                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00004A20 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00004A20                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00004A20
.text$mn:00004A20 var_1C          = dword ptr -1Ch
.text$mn:00004A20 var_18          = dword ptr -18h
.text$mn:00004A20 var_14          = dword ptr -14h
.text$mn:00004A20 var_10          = dword ptr -10h
.text$mn:00004A20 var_C           = dword ptr -0Ch
.text$mn:00004A20 var_4           = dword ptr -4
.text$mn:00004A20 arg_0           = dword ptr  8
.text$mn:00004A20 arg_4           = dword ptr  0Ch
.text$mn:00004A20
.text$mn:00004A20                 push    ebp
.text$mn:00004A21                 mov     ebp, esp
.text$mn:00004A23                 push    0FFFFFFFFh
.text$mn:00004A25                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00004A2A                 mov     eax, large fs:0
.text$mn:00004A30                 push    eax
.text$mn:00004A31                 sub     esp, 10h
.text$mn:00004A34                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004A39                 xor     eax, ebp
.text$mn:00004A3B                 push    eax
.text$mn:00004A3C                 lea     eax, [ebp+var_C]
.text$mn:00004A3F                 mov     large fs:0, eax
.text$mn:00004A45                 mov     [ebp+var_18], ecx
.text$mn:00004A48                 mov     eax, [ebp+arg_0]
.text$mn:00004A4B                 push    eax             ; void *
.text$mn:00004A4C                 push    4               ; unsigned int
.text$mn:00004A4E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004A53                 add     esp, 8
.text$mn:00004A56                 mov     [ebp+var_10], eax
.text$mn:00004A59                 mov     [ebp+var_4], 0
.text$mn:00004A60                 cmp     [ebp+var_10], 0
.text$mn:00004A64                 jz      short loc_4A81
.text$mn:00004A66                 mov     ecx, [ebp+arg_4]
.text$mn:00004A69                 push    ecx
.text$mn:00004A6A                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00004A6F                 add     esp, 4
.text$mn:00004A72                 mov     edx, [ebp+var_10]
.text$mn:00004A75                 mov     eax, [eax]
.text$mn:00004A77                 mov     [edx], eax
.text$mn:00004A79                 mov     ecx, [ebp+var_10]
.text$mn:00004A7C                 mov     [ebp+var_14], ecx
.text$mn:00004A7F                 jmp     short loc_4A88
.text$mn:00004A81 ; ---------------------------------------------------------------------------
.text$mn:00004A81
.text$mn:00004A81 loc_4A81:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:00004A81                 mov     [ebp+var_14], 0
.text$mn:00004A88
.text$mn:00004A88 loc_4A88:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00004A88                 mov     edx, [ebp+var_14]
.text$mn:00004A8B                 mov     [ebp+var_1C], edx
.text$mn:00004A8E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004A95                 mov     ecx, [ebp+var_C]
.text$mn:00004A98                 mov     large fs:0, ecx
.text$mn:00004A9F                 pop     ecx
.text$mn:00004AA0                 mov     esp, ebp
.text$mn:00004AA2                 pop     ebp
.text$mn:00004AA3                 retn    8
.text$mn:00004AA3 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00004AA3
.text$mn:00004AA3 ; ---------------------------------------------------------------------------
.text$mn:00004AA6                 align 4
.text$mn:00004AA6 _text$mn        ends
.text$mn:00004AA6
.text$x:00004AA8 ; ===========================================================================
.text$x:00004AA8
.text$x:00004AA8 ; Segment type: Pure code
.text$x:00004AA8 ; Segment permissions: Read/Execute
.text$x:00004AA8 _text$x         segment para public 'CODE' use32
.text$x:00004AA8                 assume cs:_text$x
.text$x:00004AA8                 ;org 4AA8h
.text$x:00004AA8 ; COMDAT (pick associative to section at 4A20)
.text$x:00004AA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004AA8
.text$x:00004AA8 ; =============== S U B R O U T I N E =======================================
.text$x:00004AA8
.text$x:00004AA8
.text$x:00004AA8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00004AA8                                         ; DATA XREF: .xdata$x:0000D7B8o
.text$x:00004AA8                 mov     eax, [ebp+8]
.text$x:00004AAB                 push    eax
.text$x:00004AAC                 mov     eax, [ebp-10h]
.text$x:00004AAF                 push    eax             ; void *
.text$x:00004AB0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004AB5                 add     esp, 8
.text$x:00004AB8                 retn
.text$x:00004AB8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00004AB8
.text$x:00004AB9
.text$x:00004AB9 ; =============== S U B R O U T I N E =======================================
.text$x:00004AB9
.text$x:00004AB9
.text$x:00004AB9 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00004AB9                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00004AB9
.text$x:00004AB9 arg_4           = dword ptr  8
.text$x:00004AB9
.text$x:00004AB9                 mov     edx, [esp+arg_4]
.text$x:00004ABD                 lea     eax, [edx+0Ch]
.text$x:00004AC0                 mov     ecx, [edx-14h]
.text$x:00004AC3                 xor     ecx, eax
.text$x:00004AC5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004ACA                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:00004ACF                 jmp     ___CxxFrameHandler3
.text$x:00004ACF __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:00004ACF
.text$x:00004ACF _text$x         ends
.text$x:00004ACF
.text$mn:00004AD4 ; ===========================================================================
.text$mn:00004AD4
.text$mn:00004AD4 ; Segment type: Pure code
.text$mn:00004AD4 ; Segment permissions: Read/Execute
.text$mn:00004AD4 _text$mn        segment para public 'CODE' use32
.text$mn:00004AD4                 assume cs:_text$mn
.text$mn:00004AD4                 ;org 4AD4h
.text$mn:00004AD4 ; COMDAT (pick any)
.text$mn:00004AD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004AD4
.text$mn:00004AD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AD4
.text$mn:00004AD4 ; Attributes: bp-based frame
.text$mn:00004AD4
.text$mn:00004AD4 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00004AD4                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00004AD4 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00004AD4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00004AD4
.text$mn:00004AD4 arg_0           = dword ptr  8
.text$mn:00004AD4 arg_4           = dword ptr  0Ch
.text$mn:00004AD4 arg_8           = dword ptr  10h
.text$mn:00004AD4
.text$mn:00004AD4                 push    ebp
.text$mn:00004AD5                 mov     ebp, esp
.text$mn:00004AD7                 mov     eax, [ebp+arg_8]
.text$mn:00004ADA                 push    eax
.text$mn:00004ADB                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00004AE0                 add     esp, 4
.text$mn:00004AE3                 push    eax             ; int
.text$mn:00004AE4                 mov     ecx, [ebp+arg_4]
.text$mn:00004AE7                 push    ecx             ; void *
.text$mn:00004AE8                 mov     ecx, [ebp+arg_0]
.text$mn:00004AEB                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00004AF0                 pop     ebp
.text$mn:00004AF1                 retn
.text$mn:00004AF1 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00004AF1
.text$mn:00004AF1 ; ---------------------------------------------------------------------------
.text$mn:00004AF2                 align 4
.text$mn:00004AF2 _text$mn        ends
.text$mn:00004AF2
.text$mn:00004AF4 ; ===========================================================================
.text$mn:00004AF4
.text$mn:00004AF4 ; Segment type: Pure code
.text$mn:00004AF4 ; Segment permissions: Read/Execute
.text$mn:00004AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004AF4                 assume cs:_text$mn
.text$mn:00004AF4                 ;org 4AF4h
.text$mn:00004AF4 ; COMDAT (pick any)
.text$mn:00004AF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004AF4
.text$mn:00004AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AF4
.text$mn:00004AF4 ; Attributes: bp-based frame
.text$mn:00004AF4
.text$mn:00004AF4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(void *, int)
.text$mn:00004AF4                 public ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z
.text$mn:00004AF4 ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z proc near
.text$mn:00004AF4                                         ; CODE XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00004AF4                                         ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+9Ap ...
.text$mn:00004AF4
.text$mn:00004AF4 var_4           = dword ptr -4
.text$mn:00004AF4 arg_0           = dword ptr  8
.text$mn:00004AF4 arg_4           = dword ptr  0Ch
.text$mn:00004AF4
.text$mn:00004AF4                 push    ebp
.text$mn:00004AF5                 mov     ebp, esp
.text$mn:00004AF7                 push    ecx
.text$mn:00004AF8                 mov     [ebp+var_4], ecx
.text$mn:00004AFB                 mov     eax, [ebp+arg_4]
.text$mn:00004AFE                 push    eax
.text$mn:00004AFF                 call    ??$forward@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ; std::forward<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &)
.text$mn:00004B04                 add     esp, 4
.text$mn:00004B07                 push    eax             ; int
.text$mn:00004B08                 mov     ecx, [ebp+arg_0]
.text$mn:00004B0B                 push    ecx             ; void *
.text$mn:00004B0C                 mov     edx, [ebp+var_4]
.text$mn:00004B0F                 push    edx             ; int
.text$mn:00004B10                 call    ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)
.text$mn:00004B15                 add     esp, 0Ch
.text$mn:00004B18                 mov     esp, ebp
.text$mn:00004B1A                 pop     ebp
.text$mn:00004B1B                 retn    8
.text$mn:00004B1B ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z endp
.text$mn:00004B1B
.text$mn:00004B1B ; ---------------------------------------------------------------------------
.text$mn:00004B1E                 align 10h
.text$mn:00004B1E _text$mn        ends
.text$mn:00004B1E
.text$mn:00004B20 ; ===========================================================================
.text$mn:00004B20
.text$mn:00004B20 ; Segment type: Pure code
.text$mn:00004B20 ; Segment permissions: Read/Execute
.text$mn:00004B20 _text$mn        segment para public 'CODE' use32
.text$mn:00004B20                 assume cs:_text$mn
.text$mn:00004B20                 ;org 4B20h
.text$mn:00004B20 ; COMDAT (pick any)
.text$mn:00004B20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004B20
.text$mn:00004B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B20
.text$mn:00004B20 ; Attributes: bp-based frame
.text$mn:00004B20
.text$mn:00004B20 ; int __stdcall std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(void *, int)
.text$mn:00004B20                 public ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z
.text$mn:00004B20 ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z proc near
.text$mn:00004B20                                         ; CODE XREF: std::allocator_traits<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+17p
.text$mn:00004B20
.text$mn:00004B20 var_1C          = dword ptr -1Ch
.text$mn:00004B20 var_18          = dword ptr -18h
.text$mn:00004B20 var_14          = dword ptr -14h
.text$mn:00004B20 var_10          = dword ptr -10h
.text$mn:00004B20 var_C           = dword ptr -0Ch
.text$mn:00004B20 var_4           = dword ptr -4
.text$mn:00004B20 arg_0           = dword ptr  8
.text$mn:00004B20 arg_4           = dword ptr  0Ch
.text$mn:00004B20
.text$mn:00004B20                 push    ebp
.text$mn:00004B21                 mov     ebp, esp
.text$mn:00004B23                 push    0FFFFFFFFh
.text$mn:00004B25                 push    offset __ehhandler$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z
.text$mn:00004B2A                 mov     eax, large fs:0
.text$mn:00004B30                 push    eax
.text$mn:00004B31                 sub     esp, 10h
.text$mn:00004B34                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004B39                 xor     eax, ebp
.text$mn:00004B3B                 push    eax
.text$mn:00004B3C                 lea     eax, [ebp+var_C]
.text$mn:00004B3F                 mov     large fs:0, eax
.text$mn:00004B45                 mov     [ebp+var_18], ecx
.text$mn:00004B48                 mov     eax, [ebp+arg_0]
.text$mn:00004B4B                 push    eax             ; void *
.text$mn:00004B4C                 push    20h ; ' '       ; unsigned int
.text$mn:00004B4E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004B53                 add     esp, 8
.text$mn:00004B56                 mov     [ebp+var_10], eax
.text$mn:00004B59                 mov     [ebp+var_4], 0
.text$mn:00004B60                 cmp     [ebp+var_10], 0
.text$mn:00004B64                 jz      short loc_4B80
.text$mn:00004B66                 mov     ecx, [ebp+arg_4]
.text$mn:00004B69                 push    ecx
.text$mn:00004B6A                 call    ??$forward@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ; std::forward<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &)
.text$mn:00004B6F                 add     esp, 4
.text$mn:00004B72                 push    eax
.text$mn:00004B73                 mov     ecx, [ebp+var_10]
.text$mn:00004B76                 call    ??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)
.text$mn:00004B7B                 mov     [ebp+var_14], eax
.text$mn:00004B7E                 jmp     short loc_4B87
.text$mn:00004B80 ; ---------------------------------------------------------------------------
.text$mn:00004B80
.text$mn:00004B80 loc_4B80:                               ; CODE XREF: std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+44j
.text$mn:00004B80                 mov     [ebp+var_14], 0
.text$mn:00004B87
.text$mn:00004B87 loc_4B87:                               ; CODE XREF: std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+5Ej
.text$mn:00004B87                 mov     edx, [ebp+var_14]
.text$mn:00004B8A                 mov     [ebp+var_1C], edx
.text$mn:00004B8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004B94                 mov     ecx, [ebp+var_C]
.text$mn:00004B97                 mov     large fs:0, ecx
.text$mn:00004B9E                 pop     ecx
.text$mn:00004B9F                 mov     esp, ebp
.text$mn:00004BA1                 pop     ebp
.text$mn:00004BA2                 retn    8
.text$mn:00004BA2 ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z endp
.text$mn:00004BA2
.text$mn:00004BA2 ; ---------------------------------------------------------------------------
.text$mn:00004BA5                 align 4
.text$mn:00004BA5 _text$mn        ends
.text$mn:00004BA5
.text$x:00004BA8 ; ===========================================================================
.text$x:00004BA8
.text$x:00004BA8 ; Segment type: Pure code
.text$x:00004BA8 ; Segment permissions: Read/Execute
.text$x:00004BA8 _text$x         segment para public 'CODE' use32
.text$x:00004BA8                 assume cs:_text$x
.text$x:00004BA8                 ;org 4BA8h
.text$x:00004BA8 ; COMDAT (pick associative to section at 4B20)
.text$x:00004BA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004BA8
.text$x:00004BA8 ; =============== S U B R O U T I N E =======================================
.text$x:00004BA8
.text$x:00004BA8
.text$x:00004BA8 __unwindfunclet$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z$0 proc near
.text$x:00004BA8                                         ; DATA XREF: .xdata$x:0000D6B0o
.text$x:00004BA8                 mov     eax, [ebp+8]
.text$x:00004BAB                 push    eax
.text$x:00004BAC                 mov     eax, [ebp-10h]
.text$x:00004BAF                 push    eax             ; void *
.text$x:00004BB0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004BB5                 add     esp, 8
.text$x:00004BB8                 retn
.text$x:00004BB8 __unwindfunclet$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z$0 endp
.text$x:00004BB8
.text$x:00004BB9
.text$x:00004BB9 ; =============== S U B R O U T I N E =======================================
.text$x:00004BB9
.text$x:00004BB9
.text$x:00004BB9 __ehhandler$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z proc near
.text$x:00004BB9                                         ; DATA XREF: std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+5o
.text$x:00004BB9
.text$x:00004BB9 arg_4           = dword ptr  8
.text$x:00004BB9
.text$x:00004BB9                 mov     edx, [esp+arg_4]
.text$x:00004BBD                 lea     eax, [edx+0Ch]
.text$x:00004BC0                 mov     ecx, [edx-14h]
.text$x:00004BC3                 xor     ecx, eax
.text$x:00004BC5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004BCA                 mov     eax, offset __ehfuncinfo$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z
.text$x:00004BCF                 jmp     ___CxxFrameHandler3
.text$x:00004BCF __ehhandler$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z endp
.text$x:00004BCF
.text$x:00004BCF _text$x         ends
.text$x:00004BCF
.text$mn:00004BD4 ; ===========================================================================
.text$mn:00004BD4
.text$mn:00004BD4 ; Segment type: Pure code
.text$mn:00004BD4 ; Segment permissions: Read/Execute
.text$mn:00004BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BD4                 assume cs:_text$mn
.text$mn:00004BD4                 ;org 4BD4h
.text$mn:00004BD4 ; COMDAT (pick any)
.text$mn:00004BD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004BD4
.text$mn:00004BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BD4
.text$mn:00004BD4 ; Attributes: bp-based frame
.text$mn:00004BD4
.text$mn:00004BD4 ; int __cdecl std::allocator_traits<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(int, void *, int)
.text$mn:00004BD4                 public ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU31@@Z
.text$mn:00004BD4 ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU31@@Z proc near
.text$mn:00004BD4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+1Cp
.text$mn:00004BD4
.text$mn:00004BD4 arg_0           = dword ptr  8
.text$mn:00004BD4 arg_4           = dword ptr  0Ch
.text$mn:00004BD4 arg_8           = dword ptr  10h
.text$mn:00004BD4
.text$mn:00004BD4                 push    ebp
.text$mn:00004BD5                 mov     ebp, esp
.text$mn:00004BD7                 mov     eax, [ebp+arg_8]
.text$mn:00004BDA                 push    eax
.text$mn:00004BDB                 call    ??$forward@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ; std::forward<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &)
.text$mn:00004BE0                 add     esp, 4
.text$mn:00004BE3                 push    eax             ; int
.text$mn:00004BE4                 mov     ecx, [ebp+arg_4]
.text$mn:00004BE7                 push    ecx             ; void *
.text$mn:00004BE8                 mov     ecx, [ebp+arg_0]
.text$mn:00004BEB                 call    ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)
.text$mn:00004BF0                 pop     ebp
.text$mn:00004BF1                 retn
.text$mn:00004BF1 ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU31@@Z endp
.text$mn:00004BF1
.text$mn:00004BF1 ; ---------------------------------------------------------------------------
.text$mn:00004BF2                 align 4
.text$mn:00004BF2 _text$mn        ends
.text$mn:00004BF2
.text$mn:00004BF4 ; ===========================================================================
.text$mn:00004BF4
.text$mn:00004BF4 ; Segment type: Pure code
.text$mn:00004BF4 ; Segment permissions: Read/Execute
.text$mn:00004BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BF4                 assume cs:_text$mn
.text$mn:00004BF4                 ;org 4BF4h
.text$mn:00004BF4 ; COMDAT (pick any)
.text$mn:00004BF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004BF4
.text$mn:00004BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BF4
.text$mn:00004BF4 ; Attributes: bp-based frame
.text$mn:00004BF4
.text$mn:00004BF4 ; int __stdcall std::_Wrap_alloc<std::allocator<PluginCommand>>::construct<PluginCommand,PluginCommand>(void *, int)
.text$mn:00004BF4                 public ??$construct@UPluginCommand@@U1@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z
.text$mn:00004BF4 ??$construct@UPluginCommand@@U1@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z proc near
.text$mn:00004BF4                                         ; CODE XREF: std::_Uninit_move<PluginCommand *,PluginCommand *,std::allocator<PluginCommand>,PluginCommand>(PluginCommand *,PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,PluginCommand *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00004BF4                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+9Dp ...
.text$mn:00004BF4
.text$mn:00004BF4 var_4           = dword ptr -4
.text$mn:00004BF4 arg_0           = dword ptr  8
.text$mn:00004BF4 arg_4           = dword ptr  0Ch
.text$mn:00004BF4
.text$mn:00004BF4                 push    ebp
.text$mn:00004BF5                 mov     ebp, esp
.text$mn:00004BF7                 push    ecx
.text$mn:00004BF8                 mov     [ebp+var_4], ecx
.text$mn:00004BFB                 mov     eax, [ebp+arg_4]
.text$mn:00004BFE                 push    eax
.text$mn:00004BFF                 call    ??$forward@UPluginCommand@@@std@@YA$$QAUPluginCommand@@AAU1@@Z ; std::forward<PluginCommand>(PluginCommand &)
.text$mn:00004C04                 add     esp, 4
.text$mn:00004C07                 push    eax             ; int
.text$mn:00004C08                 mov     ecx, [ebp+arg_0]
.text$mn:00004C0B                 push    ecx             ; void *
.text$mn:00004C0C                 mov     edx, [ebp+var_4]
.text$mn:00004C0F                 push    edx             ; int
.text$mn:00004C10                 call    ??$construct@UPluginCommand@@U1@@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAXAAV?$allocator@UPluginCommand@@@1@PAUPluginCommand@@$$QAU3@@Z ; std::allocator_traits<std::allocator<PluginCommand>>::construct<PluginCommand,PluginCommand>(std::allocator<PluginCommand> &,PluginCommand *,PluginCommand &&)
.text$mn:00004C15                 add     esp, 0Ch
.text$mn:00004C18                 mov     esp, ebp
.text$mn:00004C1A                 pop     ebp
.text$mn:00004C1B                 retn    8
.text$mn:00004C1B ??$construct@UPluginCommand@@U1@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z endp
.text$mn:00004C1B
.text$mn:00004C1B ; ---------------------------------------------------------------------------
.text$mn:00004C1E                 align 10h
.text$mn:00004C1E _text$mn        ends
.text$mn:00004C1E
.text$mn:00004C20 ; ===========================================================================
.text$mn:00004C20
.text$mn:00004C20 ; Segment type: Pure code
.text$mn:00004C20 ; Segment permissions: Read/Execute
.text$mn:00004C20 _text$mn        segment para public 'CODE' use32
.text$mn:00004C20                 assume cs:_text$mn
.text$mn:00004C20                 ;org 4C20h
.text$mn:00004C20 ; COMDAT (pick any)
.text$mn:00004C20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C20
.text$mn:00004C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C20
.text$mn:00004C20 ; Attributes: bp-based frame
.text$mn:00004C20
.text$mn:00004C20 ; int __stdcall std::allocator<PluginCommand>::construct<PluginCommand,PluginCommand>(void *, int)
.text$mn:00004C20                 public ??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z
.text$mn:00004C20 ??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z proc near
.text$mn:00004C20                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginCommand>>::construct<PluginCommand,PluginCommand>(std::allocator<PluginCommand> &,PluginCommand *,PluginCommand &&)+17p
.text$mn:00004C20
.text$mn:00004C20 var_1C          = dword ptr -1Ch
.text$mn:00004C20 var_18          = dword ptr -18h
.text$mn:00004C20 var_14          = dword ptr -14h
.text$mn:00004C20 var_10          = dword ptr -10h
.text$mn:00004C20 var_C           = dword ptr -0Ch
.text$mn:00004C20 var_4           = dword ptr -4
.text$mn:00004C20 arg_0           = dword ptr  8
.text$mn:00004C20 arg_4           = dword ptr  0Ch
.text$mn:00004C20
.text$mn:00004C20                 push    ebp
.text$mn:00004C21                 mov     ebp, esp
.text$mn:00004C23                 push    0FFFFFFFFh
.text$mn:00004C25                 push    offset __ehhandler$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z
.text$mn:00004C2A                 mov     eax, large fs:0
.text$mn:00004C30                 push    eax
.text$mn:00004C31                 sub     esp, 10h
.text$mn:00004C34                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004C39                 xor     eax, ebp
.text$mn:00004C3B                 push    eax
.text$mn:00004C3C                 lea     eax, [ebp+var_C]
.text$mn:00004C3F                 mov     large fs:0, eax
.text$mn:00004C45                 mov     [ebp+var_18], ecx
.text$mn:00004C48                 mov     eax, [ebp+arg_0]
.text$mn:00004C4B                 push    eax             ; void *
.text$mn:00004C4C                 push    24h ; '$'       ; unsigned int
.text$mn:00004C4E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004C53                 add     esp, 8
.text$mn:00004C56                 mov     [ebp+var_10], eax
.text$mn:00004C59                 mov     [ebp+var_4], 0
.text$mn:00004C60                 cmp     [ebp+var_10], 0
.text$mn:00004C64                 jz      short loc_4C80
.text$mn:00004C66                 mov     ecx, [ebp+arg_4]
.text$mn:00004C69                 push    ecx
.text$mn:00004C6A                 call    ??$forward@UPluginCommand@@@std@@YA$$QAUPluginCommand@@AAU1@@Z ; std::forward<PluginCommand>(PluginCommand &)
.text$mn:00004C6F                 add     esp, 4
.text$mn:00004C72                 push    eax
.text$mn:00004C73                 mov     ecx, [ebp+var_10]
.text$mn:00004C76                 call    ??0PluginCommand@@QAE@ABU0@@Z ; PluginCommand::PluginCommand(PluginCommand const &)
.text$mn:00004C7B                 mov     [ebp+var_14], eax
.text$mn:00004C7E                 jmp     short loc_4C87
.text$mn:00004C80 ; ---------------------------------------------------------------------------
.text$mn:00004C80
.text$mn:00004C80 loc_4C80:                               ; CODE XREF: std::allocator<PluginCommand>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)+44j
.text$mn:00004C80                 mov     [ebp+var_14], 0
.text$mn:00004C87
.text$mn:00004C87 loc_4C87:                               ; CODE XREF: std::allocator<PluginCommand>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)+5Ej
.text$mn:00004C87                 mov     edx, [ebp+var_14]
.text$mn:00004C8A                 mov     [ebp+var_1C], edx
.text$mn:00004C8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004C94                 mov     ecx, [ebp+var_C]
.text$mn:00004C97                 mov     large fs:0, ecx
.text$mn:00004C9E                 pop     ecx
.text$mn:00004C9F                 mov     esp, ebp
.text$mn:00004CA1                 pop     ebp
.text$mn:00004CA2                 retn    8
.text$mn:00004CA2 ??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z endp
.text$mn:00004CA2
.text$mn:00004CA2 ; ---------------------------------------------------------------------------
.text$mn:00004CA5                 align 4
.text$mn:00004CA5 _text$mn        ends
.text$mn:00004CA5
.text$x:00004CA8 ; ===========================================================================
.text$x:00004CA8
.text$x:00004CA8 ; Segment type: Pure code
.text$x:00004CA8 ; Segment permissions: Read/Execute
.text$x:00004CA8 _text$x         segment para public 'CODE' use32
.text$x:00004CA8                 assume cs:_text$x
.text$x:00004CA8                 ;org 4CA8h
.text$x:00004CA8 ; COMDAT (pick associative to section at 4C20)
.text$x:00004CA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004CA8
.text$x:00004CA8 ; =============== S U B R O U T I N E =======================================
.text$x:00004CA8
.text$x:00004CA8
.text$x:00004CA8 __unwindfunclet$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z$0 proc near
.text$x:00004CA8                                         ; DATA XREF: .xdata$x:0000D760o
.text$x:00004CA8                 mov     eax, [ebp+8]
.text$x:00004CAB                 push    eax
.text$x:00004CAC                 mov     eax, [ebp-10h]
.text$x:00004CAF                 push    eax             ; void *
.text$x:00004CB0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004CB5                 add     esp, 8
.text$x:00004CB8                 retn
.text$x:00004CB8 __unwindfunclet$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z$0 endp
.text$x:00004CB8
.text$x:00004CB9
.text$x:00004CB9 ; =============== S U B R O U T I N E =======================================
.text$x:00004CB9
.text$x:00004CB9
.text$x:00004CB9 __ehhandler$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z proc near
.text$x:00004CB9                                         ; DATA XREF: std::allocator<PluginCommand>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)+5o
.text$x:00004CB9
.text$x:00004CB9 arg_4           = dword ptr  8
.text$x:00004CB9
.text$x:00004CB9                 mov     edx, [esp+arg_4]
.text$x:00004CBD                 lea     eax, [edx+0Ch]
.text$x:00004CC0                 mov     ecx, [edx-14h]
.text$x:00004CC3                 xor     ecx, eax
.text$x:00004CC5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004CCA                 mov     eax, offset __ehfuncinfo$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z
.text$x:00004CCF                 jmp     ___CxxFrameHandler3
.text$x:00004CCF __ehhandler$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z endp
.text$x:00004CCF
.text$x:00004CCF _text$x         ends
.text$x:00004CCF
.text$mn:00004CD4 ; ===========================================================================
.text$mn:00004CD4
.text$mn:00004CD4 ; Segment type: Pure code
.text$mn:00004CD4 ; Segment permissions: Read/Execute
.text$mn:00004CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CD4                 assume cs:_text$mn
.text$mn:00004CD4                 ;org 4CD4h
.text$mn:00004CD4 ; COMDAT (pick any)
.text$mn:00004CD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004CD4
.text$mn:00004CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CD4
.text$mn:00004CD4 ; Attributes: bp-based frame
.text$mn:00004CD4
.text$mn:00004CD4 ; int __cdecl std::allocator_traits<std::allocator<PluginCommand>>::construct<PluginCommand,PluginCommand>(int, void *, int)
.text$mn:00004CD4                 public ??$construct@UPluginCommand@@U1@@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAXAAV?$allocator@UPluginCommand@@@1@PAUPluginCommand@@$$QAU3@@Z
.text$mn:00004CD4 ??$construct@UPluginCommand@@U1@@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAXAAV?$allocator@UPluginCommand@@@1@PAUPluginCommand@@$$QAU3@@Z proc near
.text$mn:00004CD4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCommand>>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)+1Cp
.text$mn:00004CD4
.text$mn:00004CD4 arg_0           = dword ptr  8
.text$mn:00004CD4 arg_4           = dword ptr  0Ch
.text$mn:00004CD4 arg_8           = dword ptr  10h
.text$mn:00004CD4
.text$mn:00004CD4                 push    ebp
.text$mn:00004CD5                 mov     ebp, esp
.text$mn:00004CD7                 mov     eax, [ebp+arg_8]
.text$mn:00004CDA                 push    eax
.text$mn:00004CDB                 call    ??$forward@UPluginCommand@@@std@@YA$$QAUPluginCommand@@AAU1@@Z ; std::forward<PluginCommand>(PluginCommand &)
.text$mn:00004CE0                 add     esp, 4
.text$mn:00004CE3                 push    eax             ; int
.text$mn:00004CE4                 mov     ecx, [ebp+arg_4]
.text$mn:00004CE7                 push    ecx             ; void *
.text$mn:00004CE8                 mov     ecx, [ebp+arg_0]
.text$mn:00004CEB                 call    ??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z ; std::allocator<PluginCommand>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)
.text$mn:00004CF0                 pop     ebp
.text$mn:00004CF1                 retn
.text$mn:00004CF1 ??$construct@UPluginCommand@@U1@@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAXAAV?$allocator@UPluginCommand@@@1@PAUPluginCommand@@$$QAU3@@Z endp
.text$mn:00004CF1
.text$mn:00004CF1 ; ---------------------------------------------------------------------------
.text$mn:00004CF2                 align 4
.text$mn:00004CF2 _text$mn        ends
.text$mn:00004CF2
.text$mn:00004CF4 ; ===========================================================================
.text$mn:00004CF4
.text$mn:00004CF4 ; Segment type: Pure code
.text$mn:00004CF4 ; Segment permissions: Read/Execute
.text$mn:00004CF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004CF4                 assume cs:_text$mn
.text$mn:00004CF4                 ;org 4CF4h
.text$mn:00004CF4 ; COMDAT (pick any)
.text$mn:00004CF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004CF4
.text$mn:00004CF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CF4
.text$mn:00004CF4 ; Attributes: bp-based frame
.text$mn:00004CF4
.text$mn:00004CF4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00004CF4                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00004CF4 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00004CF4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Alloc_proxy(void)+32p
.text$mn:00004CF4
.text$mn:00004CF4 var_4           = dword ptr -4
.text$mn:00004CF4 arg_0           = dword ptr  8
.text$mn:00004CF4 arg_4           = dword ptr  0Ch
.text$mn:00004CF4
.text$mn:00004CF4                 push    ebp
.text$mn:00004CF5                 mov     ebp, esp
.text$mn:00004CF7                 push    ecx
.text$mn:00004CF8                 mov     [ebp+var_4], ecx
.text$mn:00004CFB                 mov     eax, [ebp+arg_4]
.text$mn:00004CFE                 push    eax
.text$mn:00004CFF                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00004D04                 add     esp, 4
.text$mn:00004D07                 push    eax             ; int
.text$mn:00004D08                 mov     ecx, [ebp+arg_0]
.text$mn:00004D0B                 push    ecx             ; void *
.text$mn:00004D0C                 mov     edx, [ebp+var_4]
.text$mn:00004D0F                 push    edx             ; int
.text$mn:00004D10                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00004D15                 add     esp, 0Ch
.text$mn:00004D18                 mov     esp, ebp
.text$mn:00004D1A                 pop     ebp
.text$mn:00004D1B                 retn    8
.text$mn:00004D1B ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00004D1B
.text$mn:00004D1B ; ---------------------------------------------------------------------------
.text$mn:00004D1E                 align 10h
.text$mn:00004D1E _text$mn        ends
.text$mn:00004D1E
.text$mn:00004D20 ; ===========================================================================
.text$mn:00004D20
.text$mn:00004D20 ; Segment type: Pure code
.text$mn:00004D20 ; Segment permissions: Read/Execute
.text$mn:00004D20 _text$mn        segment para public 'CODE' use32
.text$mn:00004D20                 assume cs:_text$mn
.text$mn:00004D20                 ;org 4D20h
.text$mn:00004D20 ; COMDAT (pick any)
.text$mn:00004D20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004D20
.text$mn:00004D20 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D20
.text$mn:00004D20 ; Attributes: bp-based frame
.text$mn:00004D20
.text$mn:00004D20 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00004D20                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00004D20 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00004D20                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00004D20                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p ...
.text$mn:00004D20
.text$mn:00004D20 var_1C          = dword ptr -1Ch
.text$mn:00004D20 var_18          = dword ptr -18h
.text$mn:00004D20 var_14          = dword ptr -14h
.text$mn:00004D20 var_10          = dword ptr -10h
.text$mn:00004D20 var_C           = dword ptr -0Ch
.text$mn:00004D20 var_4           = dword ptr -4
.text$mn:00004D20 arg_0           = dword ptr  8
.text$mn:00004D20 arg_4           = dword ptr  0Ch
.text$mn:00004D20
.text$mn:00004D20                 push    ebp
.text$mn:00004D21                 mov     ebp, esp
.text$mn:00004D23                 push    0FFFFFFFFh
.text$mn:00004D25                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00004D2A                 mov     eax, large fs:0
.text$mn:00004D30                 push    eax
.text$mn:00004D31                 sub     esp, 10h
.text$mn:00004D34                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004D39                 xor     eax, ebp
.text$mn:00004D3B                 push    eax
.text$mn:00004D3C                 lea     eax, [ebp+var_C]
.text$mn:00004D3F                 mov     large fs:0, eax
.text$mn:00004D45                 mov     [ebp+var_18], ecx
.text$mn:00004D48                 mov     eax, [ebp+arg_0]
.text$mn:00004D4B                 push    eax             ; void *
.text$mn:00004D4C                 push    8               ; unsigned int
.text$mn:00004D4E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004D53                 add     esp, 8
.text$mn:00004D56                 mov     [ebp+var_10], eax
.text$mn:00004D59                 mov     [ebp+var_4], 0
.text$mn:00004D60                 cmp     [ebp+var_10], 0
.text$mn:00004D64                 jz      short loc_4D87
.text$mn:00004D66                 mov     ecx, [ebp+arg_4]
.text$mn:00004D69                 push    ecx
.text$mn:00004D6A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00004D6F                 add     esp, 4
.text$mn:00004D72                 mov     edx, [eax]
.text$mn:00004D74                 mov     eax, [eax+4]
.text$mn:00004D77                 mov     ecx, [ebp+var_10]
.text$mn:00004D7A                 mov     [ecx], edx
.text$mn:00004D7C                 mov     [ecx+4], eax
.text$mn:00004D7F                 mov     edx, [ebp+var_10]
.text$mn:00004D82                 mov     [ebp+var_14], edx
.text$mn:00004D85                 jmp     short loc_4D8E
.text$mn:00004D87 ; ---------------------------------------------------------------------------
.text$mn:00004D87
.text$mn:00004D87 loc_4D87:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00004D87                 mov     [ebp+var_14], 0
.text$mn:00004D8E
.text$mn:00004D8E loc_4D8E:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00004D8E                 mov     eax, [ebp+var_14]
.text$mn:00004D91                 mov     [ebp+var_1C], eax
.text$mn:00004D94                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D9B                 mov     ecx, [ebp+var_C]
.text$mn:00004D9E                 mov     large fs:0, ecx
.text$mn:00004DA5                 pop     ecx
.text$mn:00004DA6                 mov     esp, ebp
.text$mn:00004DA8                 pop     ebp
.text$mn:00004DA9                 retn    8
.text$mn:00004DA9 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00004DA9
.text$mn:00004DA9 _text$mn        ends
.text$mn:00004DA9
.text$x:00004DAC ; ===========================================================================
.text$x:00004DAC
.text$x:00004DAC ; Segment type: Pure code
.text$x:00004DAC ; Segment permissions: Read/Execute
.text$x:00004DAC _text$x         segment para public 'CODE' use32
.text$x:00004DAC                 assume cs:_text$x
.text$x:00004DAC                 ;org 4DACh
.text$x:00004DAC ; COMDAT (pick associative to section at 4D20)
.text$x:00004DAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004DAC
.text$x:00004DAC ; =============== S U B R O U T I N E =======================================
.text$x:00004DAC
.text$x:00004DAC
.text$x:00004DAC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00004DAC                                         ; DATA XREF: .xdata$x:0000D62Co
.text$x:00004DAC                 mov     eax, [ebp+8]
.text$x:00004DAF                 push    eax
.text$x:00004DB0                 mov     eax, [ebp-10h]
.text$x:00004DB3                 push    eax             ; void *
.text$x:00004DB4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004DB9                 add     esp, 8
.text$x:00004DBC                 retn
.text$x:00004DBC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00004DBC
.text$x:00004DBD
.text$x:00004DBD ; =============== S U B R O U T I N E =======================================
.text$x:00004DBD
.text$x:00004DBD
.text$x:00004DBD __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00004DBD                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00004DBD
.text$x:00004DBD arg_4           = dword ptr  8
.text$x:00004DBD
.text$x:00004DBD                 mov     edx, [esp+arg_4]
.text$x:00004DC1                 lea     eax, [edx+0Ch]
.text$x:00004DC4                 mov     ecx, [edx-14h]
.text$x:00004DC7                 xor     ecx, eax
.text$x:00004DC9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004DCE                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00004DD3                 jmp     ___CxxFrameHandler3
.text$x:00004DD3 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00004DD3
.text$x:00004DD3 _text$x         ends
.text$x:00004DD3
.text$mn:00004DD8 ; ===========================================================================
.text$mn:00004DD8
.text$mn:00004DD8 ; Segment type: Pure code
.text$mn:00004DD8 ; Segment permissions: Read/Execute
.text$mn:00004DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00004DD8                 assume cs:_text$mn
.text$mn:00004DD8                 ;org 4DD8h
.text$mn:00004DD8 ; COMDAT (pick any)
.text$mn:00004DD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004DD8
.text$mn:00004DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DD8
.text$mn:00004DD8 ; Attributes: bp-based frame
.text$mn:00004DD8
.text$mn:00004DD8 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00004DD8                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00004DD8 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00004DD8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00004DD8
.text$mn:00004DD8 arg_0           = dword ptr  8
.text$mn:00004DD8 arg_4           = dword ptr  0Ch
.text$mn:00004DD8 arg_8           = dword ptr  10h
.text$mn:00004DD8
.text$mn:00004DD8                 push    ebp
.text$mn:00004DD9                 mov     ebp, esp
.text$mn:00004DDB                 mov     eax, [ebp+arg_8]
.text$mn:00004DDE                 push    eax
.text$mn:00004DDF                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00004DE4                 add     esp, 4
.text$mn:00004DE7                 push    eax             ; int
.text$mn:00004DE8                 mov     ecx, [ebp+arg_4]
.text$mn:00004DEB                 push    ecx             ; void *
.text$mn:00004DEC                 mov     ecx, [ebp+arg_0]
.text$mn:00004DEF                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00004DF4                 pop     ebp
.text$mn:00004DF5                 retn
.text$mn:00004DF5 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00004DF5
.text$mn:00004DF5 ; ---------------------------------------------------------------------------
.text$mn:00004DF6                 align 4
.text$mn:00004DF6 _text$mn        ends
.text$mn:00004DF6
.text$mn:00004DF8 ; ===========================================================================
.text$mn:00004DF8
.text$mn:00004DF8 ; Segment type: Pure code
.text$mn:00004DF8 ; Segment permissions: Read/Execute
.text$mn:00004DF8 _text$mn        segment para public 'CODE' use32
.text$mn:00004DF8                 assume cs:_text$mn
.text$mn:00004DF8                 ;org 4DF8h
.text$mn:00004DF8 ; COMDAT (pick any)
.text$mn:00004DF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004DF8
.text$mn:00004DF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DF8
.text$mn:00004DF8 ; Attributes: bp-based frame
.text$mn:00004DF8
.text$mn:00004DF8 ; int __stdcall std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(void *, int)
.text$mn:00004DF8                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z
.text$mn:00004DF8 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z proc near
.text$mn:00004DF8                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+94p
.text$mn:00004DF8
.text$mn:00004DF8 var_4           = dword ptr -4
.text$mn:00004DF8 arg_0           = dword ptr  8
.text$mn:00004DF8 arg_4           = dword ptr  0Ch
.text$mn:00004DF8
.text$mn:00004DF8                 push    ebp
.text$mn:00004DF9                 mov     ebp, esp
.text$mn:00004DFB                 push    ecx
.text$mn:00004DFC                 mov     [ebp+var_4], ecx
.text$mn:00004DFF                 mov     eax, [ebp+arg_4]
.text$mn:00004E02                 push    eax
.text$mn:00004E03                 call    ??$forward@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004E08                 add     esp, 4
.text$mn:00004E0B                 push    eax             ; int
.text$mn:00004E0C                 mov     ecx, [ebp+arg_0]
.text$mn:00004E0F                 push    ecx             ; void *
.text$mn:00004E10                 mov     edx, [ebp+var_4]
.text$mn:00004E13                 push    edx             ; int
.text$mn:00004E14                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV31@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004E19                 add     esp, 0Ch
.text$mn:00004E1C                 mov     esp, ebp
.text$mn:00004E1E                 pop     ebp
.text$mn:00004E1F                 retn    8
.text$mn:00004E1F ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z endp
.text$mn:00004E1F
.text$mn:00004E1F ; ---------------------------------------------------------------------------
.text$mn:00004E22                 align 4
.text$mn:00004E22 _text$mn        ends
.text$mn:00004E22
.text$mn:00004E24 ; ===========================================================================
.text$mn:00004E24
.text$mn:00004E24 ; Segment type: Pure code
.text$mn:00004E24 ; Segment permissions: Read/Execute
.text$mn:00004E24 _text$mn        segment para public 'CODE' use32
.text$mn:00004E24                 assume cs:_text$mn
.text$mn:00004E24                 ;org 4E24h
.text$mn:00004E24 ; COMDAT (pick any)
.text$mn:00004E24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004E24
.text$mn:00004E24 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E24
.text$mn:00004E24 ; Attributes: bp-based frame
.text$mn:00004E24
.text$mn:00004E24 ; int __stdcall std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(void *, int)
.text$mn:00004E24                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z
.text$mn:00004E24 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z proc near
.text$mn:00004E24                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+17p
.text$mn:00004E24
.text$mn:00004E24 var_1C          = dword ptr -1Ch
.text$mn:00004E24 var_18          = dword ptr -18h
.text$mn:00004E24 var_14          = dword ptr -14h
.text$mn:00004E24 var_10          = dword ptr -10h
.text$mn:00004E24 var_C           = dword ptr -0Ch
.text$mn:00004E24 var_4           = dword ptr -4
.text$mn:00004E24 arg_0           = dword ptr  8
.text$mn:00004E24 arg_4           = dword ptr  0Ch
.text$mn:00004E24
.text$mn:00004E24                 push    ebp
.text$mn:00004E25                 mov     ebp, esp
.text$mn:00004E27                 push    0FFFFFFFFh
.text$mn:00004E29                 push    offset __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z
.text$mn:00004E2E                 mov     eax, large fs:0
.text$mn:00004E34                 push    eax
.text$mn:00004E35                 sub     esp, 10h
.text$mn:00004E38                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004E3D                 xor     eax, ebp
.text$mn:00004E3F                 push    eax
.text$mn:00004E40                 lea     eax, [ebp+var_C]
.text$mn:00004E43                 mov     large fs:0, eax
.text$mn:00004E49                 mov     [ebp+var_18], ecx
.text$mn:00004E4C                 mov     eax, [ebp+arg_0]
.text$mn:00004E4F                 push    eax             ; void *
.text$mn:00004E50                 push    1Ch             ; unsigned int
.text$mn:00004E52                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004E57                 add     esp, 8
.text$mn:00004E5A                 mov     [ebp+var_10], eax
.text$mn:00004E5D                 mov     [ebp+var_4], 0
.text$mn:00004E64                 cmp     [ebp+var_10], 0
.text$mn:00004E68                 jz      short loc_4E84
.text$mn:00004E6A                 mov     ecx, [ebp+arg_4]
.text$mn:00004E6D                 push    ecx
.text$mn:00004E6E                 call    ??$forward@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004E73                 add     esp, 4
.text$mn:00004E76                 push    eax
.text$mn:00004E77                 mov     ecx, [ebp+var_10]
.text$mn:00004E7A                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00004E7F                 mov     [ebp+var_14], eax
.text$mn:00004E82                 jmp     short loc_4E8B
.text$mn:00004E84 ; ---------------------------------------------------------------------------
.text$mn:00004E84
.text$mn:00004E84 loc_4E84:                               ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+44j
.text$mn:00004E84                 mov     [ebp+var_14], 0
.text$mn:00004E8B
.text$mn:00004E8B loc_4E8B:                               ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+5Ej
.text$mn:00004E8B                 mov     edx, [ebp+var_14]
.text$mn:00004E8E                 mov     [ebp+var_1C], edx
.text$mn:00004E91                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004E98                 mov     ecx, [ebp+var_C]
.text$mn:00004E9B                 mov     large fs:0, ecx
.text$mn:00004EA2                 pop     ecx
.text$mn:00004EA3                 mov     esp, ebp
.text$mn:00004EA5                 pop     ebp
.text$mn:00004EA6                 retn    8
.text$mn:00004EA6 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z endp
.text$mn:00004EA6
.text$mn:00004EA6 ; ---------------------------------------------------------------------------
.text$mn:00004EA9                 align 4
.text$mn:00004EA9 _text$mn        ends
.text$mn:00004EA9
.text$x:00004EAC ; ===========================================================================
.text$x:00004EAC
.text$x:00004EAC ; Segment type: Pure code
.text$x:00004EAC ; Segment permissions: Read/Execute
.text$x:00004EAC _text$x         segment para public 'CODE' use32
.text$x:00004EAC                 assume cs:_text$x
.text$x:00004EAC                 ;org 4EACh
.text$x:00004EAC ; COMDAT (pick associative to section at 4E24)
.text$x:00004EAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004EAC
.text$x:00004EAC ; =============== S U B R O U T I N E =======================================
.text$x:00004EAC
.text$x:00004EAC
.text$x:00004EAC __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z$0 proc near
.text$x:00004EAC                                         ; DATA XREF: .xdata$x:0000D684o
.text$x:00004EAC                 mov     eax, [ebp+8]
.text$x:00004EAF                 push    eax
.text$x:00004EB0                 mov     eax, [ebp-10h]
.text$x:00004EB3                 push    eax             ; void *
.text$x:00004EB4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00004EB9                 add     esp, 8
.text$x:00004EBC                 retn
.text$x:00004EBC __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z$0 endp
.text$x:00004EBC
.text$x:00004EBD
.text$x:00004EBD ; =============== S U B R O U T I N E =======================================
.text$x:00004EBD
.text$x:00004EBD
.text$x:00004EBD __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z proc near
.text$x:00004EBD                                         ; DATA XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+5o
.text$x:00004EBD
.text$x:00004EBD arg_4           = dword ptr  8
.text$x:00004EBD
.text$x:00004EBD                 mov     edx, [esp+arg_4]
.text$x:00004EC1                 lea     eax, [edx+0Ch]
.text$x:00004EC4                 mov     ecx, [edx-14h]
.text$x:00004EC7                 xor     ecx, eax
.text$x:00004EC9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004ECE                 mov     eax, offset __ehfuncinfo$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z
.text$x:00004ED3                 jmp     ___CxxFrameHandler3
.text$x:00004ED3 __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z endp
.text$x:00004ED3
.text$x:00004ED3 _text$x         ends
.text$x:00004ED3
.text$mn:00004ED8 ; ===========================================================================
.text$mn:00004ED8
.text$mn:00004ED8 ; Segment type: Pure code
.text$mn:00004ED8 ; Segment permissions: Read/Execute
.text$mn:00004ED8 _text$mn        segment para public 'CODE' use32
.text$mn:00004ED8                 assume cs:_text$mn
.text$mn:00004ED8                 ;org 4ED8h
.text$mn:00004ED8 ; COMDAT (pick any)
.text$mn:00004ED8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004ED8
.text$mn:00004ED8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004ED8
.text$mn:00004ED8 ; Attributes: bp-based frame
.text$mn:00004ED8
.text$mn:00004ED8 ; int __cdecl std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(int, void *, int)
.text$mn:00004ED8                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV31@@Z
.text$mn:00004ED8 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV31@@Z proc near
.text$mn:00004ED8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+1Cp
.text$mn:00004ED8
.text$mn:00004ED8 arg_0           = dword ptr  8
.text$mn:00004ED8 arg_4           = dword ptr  0Ch
.text$mn:00004ED8 arg_8           = dword ptr  10h
.text$mn:00004ED8
.text$mn:00004ED8                 push    ebp
.text$mn:00004ED9                 mov     ebp, esp
.text$mn:00004EDB                 mov     eax, [ebp+arg_8]
.text$mn:00004EDE                 push    eax
.text$mn:00004EDF                 call    ??$forward@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004EE4                 add     esp, 4
.text$mn:00004EE7                 push    eax             ; int
.text$mn:00004EE8                 mov     ecx, [ebp+arg_4]
.text$mn:00004EEB                 push    ecx             ; void *
.text$mn:00004EEC                 mov     ecx, [ebp+arg_0]
.text$mn:00004EEF                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004EF4                 pop     ebp
.text$mn:00004EF5                 retn
.text$mn:00004EF5 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV31@@Z endp
.text$mn:00004EF5
.text$mn:00004EF5 ; ---------------------------------------------------------------------------
.text$mn:00004EF6                 align 4
.text$mn:00004EF6 _text$mn        ends
.text$mn:00004EF6
.text$mn:00004EF8 ; ===========================================================================
.text$mn:00004EF8
.text$mn:00004EF8 ; Segment type: Pure code
.text$mn:00004EF8 ; Segment permissions: Read/Execute
.text$mn:00004EF8 _text$mn        segment para public 'CODE' use32
.text$mn:00004EF8                 assume cs:_text$mn
.text$mn:00004EF8                 ;org 4EF8h
.text$mn:00004EF8 ; COMDAT (pick any)
.text$mn:00004EF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004EF8
.text$mn:00004EF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EF8
.text$mn:00004EF8 ; Attributes: bp-based frame
.text$mn:00004EF8
.text$mn:00004EF8 ; int __stdcall std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &>(void *, int)
.text$mn:00004EF8                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV21@@Z
.text$mn:00004EF8 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV21@@Z proc near
.text$mn:00004EF8                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+F1p
.text$mn:00004EF8
.text$mn:00004EF8 var_4           = dword ptr -4
.text$mn:00004EF8 arg_0           = dword ptr  8
.text$mn:00004EF8 arg_4           = dword ptr  0Ch
.text$mn:00004EF8
.text$mn:00004EF8                 push    ebp
.text$mn:00004EF9                 mov     ebp, esp
.text$mn:00004EFB                 push    ecx
.text$mn:00004EFC                 mov     [ebp+var_4], ecx
.text$mn:00004EFF                 mov     eax, [ebp+arg_4]
.text$mn:00004F02                 push    eax
.text$mn:00004F03                 call    ??$forward@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00004F08                 add     esp, 4
.text$mn:00004F0B                 push    eax             ; int
.text$mn:00004F0C                 mov     ecx, [ebp+arg_0]
.text$mn:00004F0F                 push    ecx             ; void *
.text$mn:00004F10                 mov     edx, [ebp+var_4]
.text$mn:00004F13                 push    edx             ; int
.text$mn:00004F14                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV31@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00004F19                 add     esp, 0Ch
.text$mn:00004F1C                 mov     esp, ebp
.text$mn:00004F1E                 pop     ebp
.text$mn:00004F1F                 retn    8
.text$mn:00004F1F ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV21@@Z endp
.text$mn:00004F1F
.text$mn:00004F1F ; ---------------------------------------------------------------------------
.text$mn:00004F22                 align 4
.text$mn:00004F22 _text$mn        ends
.text$mn:00004F22
.text$mn:00004F24 ; ===========================================================================
.text$mn:00004F24
.text$mn:00004F24 ; Segment type: Pure code
.text$mn:00004F24 ; Segment permissions: Read/Execute
.text$mn:00004F24 _text$mn        segment para public 'CODE' use32
.text$mn:00004F24                 assume cs:_text$mn
.text$mn:00004F24                 ;org 4F24h
.text$mn:00004F24 ; COMDAT (pick any)
.text$mn:00004F24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F24
.text$mn:00004F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F24
.text$mn:00004F24 ; Attributes: bp-based frame
.text$mn:00004F24
.text$mn:00004F24 ; int __cdecl std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &>(int, void *, int)
.text$mn:00004F24                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV31@@Z
.text$mn:00004F24 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV31@@Z proc near
.text$mn:00004F24                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+1Cp
.text$mn:00004F24
.text$mn:00004F24 arg_0           = dword ptr  8
.text$mn:00004F24 arg_4           = dword ptr  0Ch
.text$mn:00004F24 arg_8           = dword ptr  10h
.text$mn:00004F24
.text$mn:00004F24                 push    ebp
.text$mn:00004F25                 mov     ebp, esp
.text$mn:00004F27                 mov     eax, [ebp+arg_8]
.text$mn:00004F2A                 push    eax
.text$mn:00004F2B                 call    ??$forward@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00004F30                 add     esp, 4
.text$mn:00004F33                 push    eax             ; int
.text$mn:00004F34                 mov     ecx, [ebp+arg_4]
.text$mn:00004F37                 push    ecx             ; void *
.text$mn:00004F38                 mov     ecx, [ebp+arg_0]
.text$mn:00004F3B                 call    ?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00004F40                 pop     ebp
.text$mn:00004F41                 retn
.text$mn:00004F41 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV31@@Z endp
.text$mn:00004F41
.text$mn:00004F41 ; ---------------------------------------------------------------------------
.text$mn:00004F42                 align 4
.text$mn:00004F42 _text$mn        ends
.text$mn:00004F42
.text$mn:00004F44 ; ===========================================================================
.text$mn:00004F44
.text$mn:00004F44 ; Segment type: Pure code
.text$mn:00004F44 ; Segment permissions: Read/Execute
.text$mn:00004F44 _text$mn        segment para public 'CODE' use32
.text$mn:00004F44                 assume cs:_text$mn
.text$mn:00004F44                 ;org 4F44h
.text$mn:00004F44 ; COMDAT (pick any)
.text$mn:00004F44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F44
.text$mn:00004F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F44
.text$mn:00004F44 ; Attributes: bp-based frame
.text$mn:00004F44
.text$mn:00004F44 ; int __stdcall std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void *, int)
.text$mn:00004F44                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$mn:00004F44 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z proc near
.text$mn:00004F44                                         ; CODE XREF: std::_Uninit_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00004F44                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+9Dp ...
.text$mn:00004F44
.text$mn:00004F44 var_4           = dword ptr -4
.text$mn:00004F44 arg_0           = dword ptr  8
.text$mn:00004F44 arg_4           = dword ptr  0Ch
.text$mn:00004F44
.text$mn:00004F44                 push    ebp
.text$mn:00004F45                 mov     ebp, esp
.text$mn:00004F47                 push    ecx
.text$mn:00004F48                 mov     [ebp+var_4], ecx
.text$mn:00004F4B                 mov     eax, [ebp+arg_4]
.text$mn:00004F4E                 push    eax
.text$mn:00004F4F                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004F54                 add     esp, 4
.text$mn:00004F57                 push    eax             ; int
.text$mn:00004F58                 mov     ecx, [ebp+arg_0]
.text$mn:00004F5B                 push    ecx             ; void *
.text$mn:00004F5C                 mov     edx, [ebp+var_4]
.text$mn:00004F5F                 push    edx             ; int
.text$mn:00004F60                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00004F65                 add     esp, 0Ch
.text$mn:00004F68                 mov     esp, ebp
.text$mn:00004F6A                 pop     ebp
.text$mn:00004F6B                 retn    8
.text$mn:00004F6B ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z endp
.text$mn:00004F6B
.text$mn:00004F6B ; ---------------------------------------------------------------------------
.text$mn:00004F6E                 align 10h
.text$mn:00004F6E _text$mn        ends
.text$mn:00004F6E
.text$mn:00004F70 ; ===========================================================================
.text$mn:00004F70
.text$mn:00004F70 ; Segment type: Pure code
.text$mn:00004F70 ; Segment permissions: Read/Execute
.text$mn:00004F70 _text$mn        segment para public 'CODE' use32
.text$mn:00004F70                 assume cs:_text$mn
.text$mn:00004F70                 ;org 4F70h
.text$mn:00004F70 ; COMDAT (pick any)
.text$mn:00004F70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F70
.text$mn:00004F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F70
.text$mn:00004F70 ; Attributes: bp-based frame
.text$mn:00004F70
.text$mn:00004F70 ; int __stdcall std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void *, int)
.text$mn:00004F70                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$mn:00004F70 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z proc near
.text$mn:00004F70                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+17p
.text$mn:00004F70
.text$mn:00004F70 var_1C          = dword ptr -1Ch
.text$mn:00004F70 var_18          = dword ptr -18h
.text$mn:00004F70 var_14          = dword ptr -14h
.text$mn:00004F70 var_10          = dword ptr -10h
.text$mn:00004F70 var_C           = dword ptr -0Ch
.text$mn:00004F70 var_4           = dword ptr -4
.text$mn:00004F70 arg_0           = dword ptr  8
.text$mn:00004F70 arg_4           = dword ptr  0Ch
.text$mn:00004F70
.text$mn:00004F70                 push    ebp
.text$mn:00004F71                 mov     ebp, esp
.text$mn:00004F73                 push    0FFFFFFFFh
.text$mn:00004F75                 push    offset __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$mn:00004F7A                 mov     eax, large fs:0
.text$mn:00004F80                 push    eax
.text$mn:00004F81                 sub     esp, 10h
.text$mn:00004F84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004F89                 xor     eax, ebp
.text$mn:00004F8B                 push    eax
.text$mn:00004F8C                 lea     eax, [ebp+var_C]
.text$mn:00004F8F                 mov     large fs:0, eax
.text$mn:00004F95                 mov     [ebp+var_18], ecx
.text$mn:00004F98                 mov     eax, [ebp+arg_0]
.text$mn:00004F9B                 push    eax             ; void *
.text$mn:00004F9C                 push    1Ch             ; unsigned int
.text$mn:00004F9E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00004FA3                 add     esp, 8
.text$mn:00004FA6                 mov     [ebp+var_10], eax
.text$mn:00004FA9                 mov     [ebp+var_4], 0
.text$mn:00004FB0                 cmp     [ebp+var_10], 0
.text$mn:00004FB4                 jz      short loc_4FD0
.text$mn:00004FB6                 mov     ecx, [ebp+arg_4]
.text$mn:00004FB9                 push    ecx
.text$mn:00004FBA                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004FBF                 add     esp, 4
.text$mn:00004FC2                 push    eax
.text$mn:00004FC3                 mov     ecx, [ebp+var_10]
.text$mn:00004FC6                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00004FCB                 mov     [ebp+var_14], eax
.text$mn:00004FCE                 jmp     short loc_4FD7
.text$mn:00004FD0 ; ---------------------------------------------------------------------------
.text$mn:00004FD0
.text$mn:00004FD0 loc_4FD0:                               ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+44j
.text$mn:00004FD0                 mov     [ebp+var_14], 0
.text$mn:00004FD7
.text$mn:00004FD7 loc_4FD7:                               ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5Ej
.text$mn:00004FD7                 mov     edx, [ebp+var_14]
.text$mn:00004FDA                 mov     [ebp+var_1C], edx
.text$mn:00004FDD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004FE4                 mov     ecx, [ebp+var_C]
.text$mn:00004FE7                 mov     large fs:0, ecx
.text$mn:00004FEE                 pop     ecx
.text$mn:00004FEF                 mov     esp, ebp
.text$mn:00004FF1                 pop     ebp
.text$mn:00004FF2                 retn    8
.text$mn:00004FF2 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z endp
.text$mn:00004FF2
.text$mn:00004FF2 ; ---------------------------------------------------------------------------
.text$mn:00004FF5                 align 4
.text$mn:00004FF5 _text$mn        ends
.text$mn:00004FF5
.text$x:00004FF8 ; ===========================================================================
.text$x:00004FF8
.text$x:00004FF8 ; Segment type: Pure code
.text$x:00004FF8 ; Segment permissions: Read/Execute
.text$x:00004FF8 _text$x         segment para public 'CODE' use32
.text$x:00004FF8                 assume cs:_text$x
.text$x:00004FF8                 ;org 4FF8h
.text$x:00004FF8 ; COMDAT (pick associative to section at 4F70)
.text$x:00004FF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004FF8
.text$x:00004FF8 ; =============== S U B R O U T I N E =======================================
.text$x:00004FF8
.text$x:00004FF8
.text$x:00004FF8 __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z$0 proc near
.text$x:00004FF8                                         ; DATA XREF: .xdata$x:0000D658o
.text$x:00004FF8                 mov     eax, [ebp+8]
.text$x:00004FFB                 push    eax
.text$x:00004FFC                 mov     eax, [ebp-10h]
.text$x:00004FFF                 push    eax             ; void *
.text$x:00005000                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00005005                 add     esp, 8
.text$x:00005008                 retn
.text$x:00005008 __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z$0 endp
.text$x:00005008
.text$x:00005009
.text$x:00005009 ; =============== S U B R O U T I N E =======================================
.text$x:00005009
.text$x:00005009
.text$x:00005009 __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z proc near
.text$x:00005009                                         ; DATA XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5o
.text$x:00005009
.text$x:00005009 arg_4           = dword ptr  8
.text$x:00005009
.text$x:00005009                 mov     edx, [esp+arg_4]
.text$x:0000500D                 lea     eax, [edx+0Ch]
.text$x:00005010                 mov     ecx, [edx-14h]
.text$x:00005013                 xor     ecx, eax
.text$x:00005015                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000501A                 mov     eax, offset __ehfuncinfo$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.text$x:0000501F                 jmp     ___CxxFrameHandler3
.text$x:0000501F __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z endp
.text$x:0000501F
.text$x:0000501F _text$x         ends
.text$x:0000501F
.text$mn:00005024 ; ===========================================================================
.text$mn:00005024
.text$mn:00005024 ; Segment type: Pure code
.text$mn:00005024 ; Segment permissions: Read/Execute
.text$mn:00005024 _text$mn        segment para public 'CODE' use32
.text$mn:00005024                 assume cs:_text$mn
.text$mn:00005024                 ;org 5024h
.text$mn:00005024 ; COMDAT (pick any)
.text$mn:00005024                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005024
.text$mn:00005024 ; =============== S U B R O U T I N E =======================================
.text$mn:00005024
.text$mn:00005024 ; Attributes: bp-based frame
.text$mn:00005024
.text$mn:00005024 ; int __cdecl std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(int, void *, int)
.text$mn:00005024                 public ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z
.text$mn:00005024 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z proc near
.text$mn:00005024                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+1Cp
.text$mn:00005024
.text$mn:00005024 arg_0           = dword ptr  8
.text$mn:00005024 arg_4           = dword ptr  0Ch
.text$mn:00005024 arg_8           = dword ptr  10h
.text$mn:00005024
.text$mn:00005024                 push    ebp
.text$mn:00005025                 mov     ebp, esp
.text$mn:00005027                 mov     eax, [ebp+arg_8]
.text$mn:0000502A                 push    eax
.text$mn:0000502B                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00005030                 add     esp, 4
.text$mn:00005033                 push    eax             ; int
.text$mn:00005034                 mov     ecx, [ebp+arg_4]
.text$mn:00005037                 push    ecx             ; void *
.text$mn:00005038                 mov     ecx, [ebp+arg_0]
.text$mn:0000503B                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00005040                 pop     ebp
.text$mn:00005041                 retn
.text$mn:00005041 ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV31@@Z endp
.text$mn:00005041
.text$mn:00005041 ; ---------------------------------------------------------------------------
.text$mn:00005042                 align 4
.text$mn:00005042 _text$mn        ends
.text$mn:00005042
.text$mn:00005044 ; ===========================================================================
.text$mn:00005044
.text$mn:00005044 ; Segment type: Pure code
.text$mn:00005044 ; Segment permissions: Read/Execute
.text$mn:00005044 _text$mn        segment para public 'CODE' use32
.text$mn:00005044                 assume cs:_text$mn
.text$mn:00005044                 ;org 5044h
.text$mn:00005044 ; COMDAT (pick any)
.text$mn:00005044                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005044
.text$mn:00005044 ; =============== S U B R O U T I N E =======================================
.text$mn:00005044
.text$mn:00005044 ; Attributes: bp-based frame
.text$mn:00005044
.text$mn:00005044 ; int __stdcall std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut &>(void *, int)
.text$mn:00005044                 public ??$construct@VPluginCmdShortcut@@AAV1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z
.text$mn:00005044 ??$construct@VPluginCmdShortcut@@AAV1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z proc near
.text$mn:00005044                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+97p
.text$mn:00005044
.text$mn:00005044 var_4           = dword ptr -4
.text$mn:00005044 arg_0           = dword ptr  8
.text$mn:00005044 arg_4           = dword ptr  0Ch
.text$mn:00005044
.text$mn:00005044                 push    ebp
.text$mn:00005045                 mov     ebp, esp
.text$mn:00005047                 push    ecx
.text$mn:00005048                 mov     [ebp+var_4], ecx
.text$mn:0000504B                 mov     eax, [ebp+arg_4]
.text$mn:0000504E                 push    eax
.text$mn:0000504F                 call    ??$forward@AAVPluginCmdShortcut@@@std@@YAAAVPluginCmdShortcut@@AAV1@@Z ; std::forward<PluginCmdShortcut &>(PluginCmdShortcut &)
.text$mn:00005054                 add     esp, 4
.text$mn:00005057                 push    eax             ; int
.text$mn:00005058                 mov     ecx, [ebp+arg_0]
.text$mn:0000505B                 push    ecx             ; void *
.text$mn:0000505C                 mov     edx, [ebp+var_4]
.text$mn:0000505F                 push    edx             ; int
.text$mn:00005060                 call    ??$construct@VPluginCmdShortcut@@AAV1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@AAV3@@Z ; std::allocator_traits<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut &>(std::allocator<PluginCmdShortcut> &,PluginCmdShortcut *,PluginCmdShortcut &)
.text$mn:00005065                 add     esp, 0Ch
.text$mn:00005068                 mov     esp, ebp
.text$mn:0000506A                 pop     ebp
.text$mn:0000506B                 retn    8
.text$mn:0000506B ??$construct@VPluginCmdShortcut@@AAV1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z endp
.text$mn:0000506B
.text$mn:0000506B ; ---------------------------------------------------------------------------
.text$mn:0000506E                 align 10h
.text$mn:0000506E _text$mn        ends
.text$mn:0000506E
.text$mn:00005070 ; ===========================================================================
.text$mn:00005070
.text$mn:00005070 ; Segment type: Pure code
.text$mn:00005070 ; Segment permissions: Read/Execute
.text$mn:00005070 _text$mn        segment para public 'CODE' use32
.text$mn:00005070                 assume cs:_text$mn
.text$mn:00005070                 ;org 5070h
.text$mn:00005070 ; COMDAT (pick any)
.text$mn:00005070                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005070
.text$mn:00005070 ; =============== S U B R O U T I N E =======================================
.text$mn:00005070
.text$mn:00005070 ; Attributes: bp-based frame
.text$mn:00005070
.text$mn:00005070 ; int __stdcall std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut &>(void *, int)
.text$mn:00005070                 public ??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z
.text$mn:00005070 ??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z proc near
.text$mn:00005070                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut &>(std::allocator<PluginCmdShortcut> &,PluginCmdShortcut *,PluginCmdShortcut &)+17p
.text$mn:00005070
.text$mn:00005070 var_1C          = dword ptr -1Ch
.text$mn:00005070 var_18          = dword ptr -18h
.text$mn:00005070 var_14          = dword ptr -14h
.text$mn:00005070 var_10          = dword ptr -10h
.text$mn:00005070 var_C           = dword ptr -0Ch
.text$mn:00005070 var_4           = dword ptr -4
.text$mn:00005070 arg_0           = dword ptr  8
.text$mn:00005070 arg_4           = dword ptr  0Ch
.text$mn:00005070
.text$mn:00005070                 push    ebp
.text$mn:00005071                 mov     ebp, esp
.text$mn:00005073                 push    0FFFFFFFFh
.text$mn:00005075                 push    offset __ehhandler$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z
.text$mn:0000507A                 mov     eax, large fs:0
.text$mn:00005080                 push    eax
.text$mn:00005081                 sub     esp, 10h
.text$mn:00005084                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005089                 xor     eax, ebp
.text$mn:0000508B                 push    eax
.text$mn:0000508C                 lea     eax, [ebp+var_C]
.text$mn:0000508F                 mov     large fs:0, eax
.text$mn:00005095                 mov     [ebp+var_18], ecx
.text$mn:00005098                 mov     eax, [ebp+arg_0]
.text$mn:0000509B                 push    eax             ; void *
.text$mn:0000509C                 push    150h            ; unsigned int
.text$mn:000050A1                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000050A6                 add     esp, 8
.text$mn:000050A9                 mov     [ebp+var_10], eax
.text$mn:000050AC                 mov     [ebp+var_4], 0
.text$mn:000050B3                 cmp     [ebp+var_10], 0
.text$mn:000050B7                 jz      short loc_50D3
.text$mn:000050B9                 mov     ecx, [ebp+arg_4]
.text$mn:000050BC                 push    ecx
.text$mn:000050BD                 call    ??$forward@AAVPluginCmdShortcut@@@std@@YAAAVPluginCmdShortcut@@AAV1@@Z ; std::forward<PluginCmdShortcut &>(PluginCmdShortcut &)
.text$mn:000050C2                 add     esp, 4
.text$mn:000050C5                 push    eax             ; struct CommandShortcut *
.text$mn:000050C6                 mov     ecx, [ebp+var_10]
.text$mn:000050C9                 call    ??0PluginCmdShortcut@@QAE@ABV0@@Z ; PluginCmdShortcut::PluginCmdShortcut(PluginCmdShortcut const &)
.text$mn:000050CE                 mov     [ebp+var_14], eax
.text$mn:000050D1                 jmp     short loc_50DA
.text$mn:000050D3 ; ---------------------------------------------------------------------------
.text$mn:000050D3
.text$mn:000050D3 loc_50D3:                               ; CODE XREF: std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut &>(PluginCmdShortcut *,PluginCmdShortcut &)+47j
.text$mn:000050D3                 mov     [ebp+var_14], 0
.text$mn:000050DA
.text$mn:000050DA loc_50DA:                               ; CODE XREF: std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut &>(PluginCmdShortcut *,PluginCmdShortcut &)+61j
.text$mn:000050DA                 mov     edx, [ebp+var_14]
.text$mn:000050DD                 mov     [ebp+var_1C], edx
.text$mn:000050E0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000050E7                 mov     ecx, [ebp+var_C]
.text$mn:000050EA                 mov     large fs:0, ecx
.text$mn:000050F1                 pop     ecx
.text$mn:000050F2                 mov     esp, ebp
.text$mn:000050F4                 pop     ebp
.text$mn:000050F5                 retn    8
.text$mn:000050F5 ??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z endp
.text$mn:000050F5
.text$mn:000050F5 _text$mn        ends
.text$mn:000050F5
.text$x:000050F8 ; ===========================================================================
.text$x:000050F8
.text$x:000050F8 ; Segment type: Pure code
.text$x:000050F8 ; Segment permissions: Read/Execute
.text$x:000050F8 _text$x         segment para public 'CODE' use32
.text$x:000050F8                 assume cs:_text$x
.text$x:000050F8                 ;org 50F8h
.text$x:000050F8 ; COMDAT (pick associative to section at 5070)
.text$x:000050F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000050F8
.text$x:000050F8 ; =============== S U B R O U T I N E =======================================
.text$x:000050F8
.text$x:000050F8
.text$x:000050F8 __unwindfunclet$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z$0 proc near
.text$x:000050F8                                         ; DATA XREF: .xdata$x:0000D708o
.text$x:000050F8                 mov     eax, [ebp+8]
.text$x:000050FB                 push    eax
.text$x:000050FC                 mov     eax, [ebp-10h]
.text$x:000050FF                 push    eax             ; void *
.text$x:00005100                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00005105                 add     esp, 8
.text$x:00005108                 retn
.text$x:00005108 __unwindfunclet$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z$0 endp
.text$x:00005108
.text$x:00005109
.text$x:00005109 ; =============== S U B R O U T I N E =======================================
.text$x:00005109
.text$x:00005109
.text$x:00005109 __ehhandler$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z proc near
.text$x:00005109                                         ; DATA XREF: std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut &>(PluginCmdShortcut *,PluginCmdShortcut &)+5o
.text$x:00005109
.text$x:00005109 arg_4           = dword ptr  8
.text$x:00005109
.text$x:00005109                 mov     edx, [esp+arg_4]
.text$x:0000510D                 lea     eax, [edx+0Ch]
.text$x:00005110                 mov     ecx, [edx-14h]
.text$x:00005113                 xor     ecx, eax
.text$x:00005115                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000511A                 mov     eax, offset __ehfuncinfo$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z
.text$x:0000511F                 jmp     ___CxxFrameHandler3
.text$x:0000511F __ehhandler$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z endp
.text$x:0000511F
.text$x:0000511F _text$x         ends
.text$x:0000511F
.text$mn:00005124 ; ===========================================================================
.text$mn:00005124
.text$mn:00005124 ; Segment type: Pure code
.text$mn:00005124 ; Segment permissions: Read/Execute
.text$mn:00005124 _text$mn        segment para public 'CODE' use32
.text$mn:00005124                 assume cs:_text$mn
.text$mn:00005124                 ;org 5124h
.text$mn:00005124 ; COMDAT (pick any)
.text$mn:00005124                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005124
.text$mn:00005124 ; =============== S U B R O U T I N E =======================================
.text$mn:00005124
.text$mn:00005124 ; Attributes: bp-based frame
.text$mn:00005124
.text$mn:00005124 ; int __cdecl std::allocator_traits<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut &>(int, void *, int)
.text$mn:00005124                 public ??$construct@VPluginCmdShortcut@@AAV1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@AAV3@@Z
.text$mn:00005124 ??$construct@VPluginCmdShortcut@@AAV1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@AAV3@@Z proc near
.text$mn:00005124                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut &>(PluginCmdShortcut *,PluginCmdShortcut &)+1Cp
.text$mn:00005124
.text$mn:00005124 arg_0           = dword ptr  8
.text$mn:00005124 arg_4           = dword ptr  0Ch
.text$mn:00005124 arg_8           = dword ptr  10h
.text$mn:00005124
.text$mn:00005124                 push    ebp
.text$mn:00005125                 mov     ebp, esp
.text$mn:00005127                 mov     eax, [ebp+arg_8]
.text$mn:0000512A                 push    eax
.text$mn:0000512B                 call    ??$forward@AAVPluginCmdShortcut@@@std@@YAAAVPluginCmdShortcut@@AAV1@@Z ; std::forward<PluginCmdShortcut &>(PluginCmdShortcut &)
.text$mn:00005130                 add     esp, 4
.text$mn:00005133                 push    eax             ; int
.text$mn:00005134                 mov     ecx, [ebp+arg_4]
.text$mn:00005137                 push    ecx             ; void *
.text$mn:00005138                 mov     ecx, [ebp+arg_0]
.text$mn:0000513B                 call    ??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z ; std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut &>(PluginCmdShortcut *,PluginCmdShortcut &)
.text$mn:00005140                 pop     ebp
.text$mn:00005141                 retn
.text$mn:00005141 ??$construct@VPluginCmdShortcut@@AAV1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@AAV3@@Z endp
.text$mn:00005141
.text$mn:00005141 ; ---------------------------------------------------------------------------
.text$mn:00005142                 align 4
.text$mn:00005142 _text$mn        ends
.text$mn:00005142
.text$mn:00005144 ; ===========================================================================
.text$mn:00005144
.text$mn:00005144 ; Segment type: Pure code
.text$mn:00005144 ; Segment permissions: Read/Execute
.text$mn:00005144 _text$mn        segment para public 'CODE' use32
.text$mn:00005144                 assume cs:_text$mn
.text$mn:00005144                 ;org 5144h
.text$mn:00005144 ; COMDAT (pick any)
.text$mn:00005144                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005144
.text$mn:00005144 ; =============== S U B R O U T I N E =======================================
.text$mn:00005144
.text$mn:00005144 ; Attributes: bp-based frame
.text$mn:00005144
.text$mn:00005144 ; int __stdcall std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut const &>(void *, int)
.text$mn:00005144                 public ??$construct@VPluginCmdShortcut@@ABV1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@ABV2@@Z
.text$mn:00005144 ??$construct@VPluginCmdShortcut@@ABV1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@ABV2@@Z proc near
.text$mn:00005144                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+F6p
.text$mn:00005144
.text$mn:00005144 var_4           = dword ptr -4
.text$mn:00005144 arg_0           = dword ptr  8
.text$mn:00005144 arg_4           = dword ptr  0Ch
.text$mn:00005144
.text$mn:00005144                 push    ebp
.text$mn:00005145                 mov     ebp, esp
.text$mn:00005147                 push    ecx
.text$mn:00005148                 mov     [ebp+var_4], ecx
.text$mn:0000514B                 mov     eax, [ebp+arg_4]
.text$mn:0000514E                 push    eax
.text$mn:0000514F                 call    ??$forward@ABVPluginCmdShortcut@@@std@@YAABVPluginCmdShortcut@@ABV1@@Z ; std::forward<PluginCmdShortcut const &>(PluginCmdShortcut const &)
.text$mn:00005154                 add     esp, 4
.text$mn:00005157                 push    eax             ; int
.text$mn:00005158                 mov     ecx, [ebp+arg_0]
.text$mn:0000515B                 push    ecx             ; void *
.text$mn:0000515C                 mov     edx, [ebp+var_4]
.text$mn:0000515F                 push    edx             ; int
.text$mn:00005160                 call    ??$construct@VPluginCmdShortcut@@ABV1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@ABV3@@Z ; std::allocator_traits<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut const &>(std::allocator<PluginCmdShortcut> &,PluginCmdShortcut *,PluginCmdShortcut const &)
.text$mn:00005165                 add     esp, 0Ch
.text$mn:00005168                 mov     esp, ebp
.text$mn:0000516A                 pop     ebp
.text$mn:0000516B                 retn    8
.text$mn:0000516B ??$construct@VPluginCmdShortcut@@ABV1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@ABV2@@Z endp
.text$mn:0000516B
.text$mn:0000516B ; ---------------------------------------------------------------------------
.text$mn:0000516E                 align 10h
.text$mn:0000516E _text$mn        ends
.text$mn:0000516E
.text$mn:00005170 ; ===========================================================================
.text$mn:00005170
.text$mn:00005170 ; Segment type: Pure code
.text$mn:00005170 ; Segment permissions: Read/Execute
.text$mn:00005170 _text$mn        segment para public 'CODE' use32
.text$mn:00005170                 assume cs:_text$mn
.text$mn:00005170                 ;org 5170h
.text$mn:00005170 ; COMDAT (pick any)
.text$mn:00005170                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005170
.text$mn:00005170 ; =============== S U B R O U T I N E =======================================
.text$mn:00005170
.text$mn:00005170 ; Attributes: bp-based frame
.text$mn:00005170
.text$mn:00005170 ; int __cdecl std::allocator_traits<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut const &>(int, void *, int)
.text$mn:00005170                 public ??$construct@VPluginCmdShortcut@@ABV1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@ABV3@@Z
.text$mn:00005170 ??$construct@VPluginCmdShortcut@@ABV1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@ABV3@@Z proc near
.text$mn:00005170                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut const &>(PluginCmdShortcut *,PluginCmdShortcut const &)+1Cp
.text$mn:00005170
.text$mn:00005170 arg_0           = dword ptr  8
.text$mn:00005170 arg_4           = dword ptr  0Ch
.text$mn:00005170 arg_8           = dword ptr  10h
.text$mn:00005170
.text$mn:00005170                 push    ebp
.text$mn:00005171                 mov     ebp, esp
.text$mn:00005173                 mov     eax, [ebp+arg_8]
.text$mn:00005176                 push    eax
.text$mn:00005177                 call    ??$forward@ABVPluginCmdShortcut@@@std@@YAABVPluginCmdShortcut@@ABV1@@Z ; std::forward<PluginCmdShortcut const &>(PluginCmdShortcut const &)
.text$mn:0000517C                 add     esp, 4
.text$mn:0000517F                 push    eax             ; struct CommandShortcut *
.text$mn:00005180                 mov     ecx, [ebp+arg_4]
.text$mn:00005183                 push    ecx             ; void *
.text$mn:00005184                 mov     ecx, [ebp+arg_0]
.text$mn:00005187                 call    ?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z ; std::allocator<PluginCmdShortcut>::construct(PluginCmdShortcut *,PluginCmdShortcut const &)
.text$mn:0000518C                 pop     ebp
.text$mn:0000518D                 retn
.text$mn:0000518D ??$construct@VPluginCmdShortcut@@ABV1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@ABV3@@Z endp
.text$mn:0000518D
.text$mn:0000518D ; ---------------------------------------------------------------------------
.text$mn:0000518E                 align 10h
.text$mn:0000518E _text$mn        ends
.text$mn:0000518E
.text$mn:00005190 ; ===========================================================================
.text$mn:00005190
.text$mn:00005190 ; Segment type: Pure code
.text$mn:00005190 ; Segment permissions: Read/Execute
.text$mn:00005190 _text$mn        segment para public 'CODE' use32
.text$mn:00005190                 assume cs:_text$mn
.text$mn:00005190                 ;org 5190h
.text$mn:00005190 ; COMDAT (pick any)
.text$mn:00005190                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005190
.text$mn:00005190 ; =============== S U B R O U T I N E =======================================
.text$mn:00005190
.text$mn:00005190 ; Attributes: bp-based frame
.text$mn:00005190
.text$mn:00005190 ; int __stdcall std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut>(void *, int)
.text$mn:00005190                 public ??$construct@VPluginCmdShortcut@@V1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z
.text$mn:00005190 ??$construct@VPluginCmdShortcut@@V1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z proc near
.text$mn:00005190                                         ; CODE XREF: std::_Uninit_move<PluginCmdShortcut *,PluginCmdShortcut *,std::allocator<PluginCmdShortcut>,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,PluginCmdShortcut *,std::_Nonscalar_ptr_iterator_tag)+94p
.text$mn:00005190
.text$mn:00005190 var_4           = dword ptr -4
.text$mn:00005190 arg_0           = dword ptr  8
.text$mn:00005190 arg_4           = dword ptr  0Ch
.text$mn:00005190
.text$mn:00005190                 push    ebp
.text$mn:00005191                 mov     ebp, esp
.text$mn:00005193                 push    ecx
.text$mn:00005194                 mov     [ebp+var_4], ecx
.text$mn:00005197                 mov     eax, [ebp+arg_4]
.text$mn:0000519A                 push    eax
.text$mn:0000519B                 call    ??$forward@VPluginCmdShortcut@@@std@@YA$$QAVPluginCmdShortcut@@AAV1@@Z ; std::forward<PluginCmdShortcut>(PluginCmdShortcut &)
.text$mn:000051A0                 add     esp, 4
.text$mn:000051A3                 push    eax             ; int
.text$mn:000051A4                 mov     ecx, [ebp+arg_0]
.text$mn:000051A7                 push    ecx             ; void *
.text$mn:000051A8                 mov     edx, [ebp+var_4]
.text$mn:000051AB                 push    edx             ; int
.text$mn:000051AC                 call    ??$construct@VPluginCmdShortcut@@V1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@$$QAV3@@Z ; std::allocator_traits<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut>(std::allocator<PluginCmdShortcut> &,PluginCmdShortcut *,PluginCmdShortcut &&)
.text$mn:000051B1                 add     esp, 0Ch
.text$mn:000051B4                 mov     esp, ebp
.text$mn:000051B6                 pop     ebp
.text$mn:000051B7                 retn    8
.text$mn:000051B7 ??$construct@VPluginCmdShortcut@@V1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z endp
.text$mn:000051B7
.text$mn:000051B7 ; ---------------------------------------------------------------------------
.text$mn:000051BA                 align 4
.text$mn:000051BA _text$mn        ends
.text$mn:000051BA
.text$mn:000051BC ; ===========================================================================
.text$mn:000051BC
.text$mn:000051BC ; Segment type: Pure code
.text$mn:000051BC ; Segment permissions: Read/Execute
.text$mn:000051BC _text$mn        segment para public 'CODE' use32
.text$mn:000051BC                 assume cs:_text$mn
.text$mn:000051BC                 ;org 51BCh
.text$mn:000051BC ; COMDAT (pick any)
.text$mn:000051BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000051BC
.text$mn:000051BC ; =============== S U B R O U T I N E =======================================
.text$mn:000051BC
.text$mn:000051BC ; Attributes: bp-based frame
.text$mn:000051BC
.text$mn:000051BC ; int __stdcall std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut>(void *, int)
.text$mn:000051BC                 public ??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z
.text$mn:000051BC ??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z proc near
.text$mn:000051BC                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut>(std::allocator<PluginCmdShortcut> &,PluginCmdShortcut *,PluginCmdShortcut &&)+17p
.text$mn:000051BC
.text$mn:000051BC var_1C          = dword ptr -1Ch
.text$mn:000051BC var_18          = dword ptr -18h
.text$mn:000051BC var_14          = dword ptr -14h
.text$mn:000051BC var_10          = dword ptr -10h
.text$mn:000051BC var_C           = dword ptr -0Ch
.text$mn:000051BC var_4           = dword ptr -4
.text$mn:000051BC arg_0           = dword ptr  8
.text$mn:000051BC arg_4           = dword ptr  0Ch
.text$mn:000051BC
.text$mn:000051BC                 push    ebp
.text$mn:000051BD                 mov     ebp, esp
.text$mn:000051BF                 push    0FFFFFFFFh
.text$mn:000051C1                 push    offset __ehhandler$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z
.text$mn:000051C6                 mov     eax, large fs:0
.text$mn:000051CC                 push    eax
.text$mn:000051CD                 sub     esp, 10h
.text$mn:000051D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000051D5                 xor     eax, ebp
.text$mn:000051D7                 push    eax
.text$mn:000051D8                 lea     eax, [ebp+var_C]
.text$mn:000051DB                 mov     large fs:0, eax
.text$mn:000051E1                 mov     [ebp+var_18], ecx
.text$mn:000051E4                 mov     eax, [ebp+arg_0]
.text$mn:000051E7                 push    eax             ; void *
.text$mn:000051E8                 push    150h            ; unsigned int
.text$mn:000051ED                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000051F2                 add     esp, 8
.text$mn:000051F5                 mov     [ebp+var_10], eax
.text$mn:000051F8                 mov     [ebp+var_4], 0
.text$mn:000051FF                 cmp     [ebp+var_10], 0
.text$mn:00005203                 jz      short loc_521F
.text$mn:00005205                 mov     ecx, [ebp+arg_4]
.text$mn:00005208                 push    ecx
.text$mn:00005209                 call    ??$forward@VPluginCmdShortcut@@@std@@YA$$QAVPluginCmdShortcut@@AAV1@@Z ; std::forward<PluginCmdShortcut>(PluginCmdShortcut &)
.text$mn:0000520E                 add     esp, 4
.text$mn:00005211                 push    eax             ; struct CommandShortcut *
.text$mn:00005212                 mov     ecx, [ebp+var_10]
.text$mn:00005215                 call    ??0PluginCmdShortcut@@QAE@ABV0@@Z ; PluginCmdShortcut::PluginCmdShortcut(PluginCmdShortcut const &)
.text$mn:0000521A                 mov     [ebp+var_14], eax
.text$mn:0000521D                 jmp     short loc_5226
.text$mn:0000521F ; ---------------------------------------------------------------------------
.text$mn:0000521F
.text$mn:0000521F loc_521F:                               ; CODE XREF: std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut &&)+47j
.text$mn:0000521F                 mov     [ebp+var_14], 0
.text$mn:00005226
.text$mn:00005226 loc_5226:                               ; CODE XREF: std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut &&)+61j
.text$mn:00005226                 mov     edx, [ebp+var_14]
.text$mn:00005229                 mov     [ebp+var_1C], edx
.text$mn:0000522C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005233                 mov     ecx, [ebp+var_C]
.text$mn:00005236                 mov     large fs:0, ecx
.text$mn:0000523D                 pop     ecx
.text$mn:0000523E                 mov     esp, ebp
.text$mn:00005240                 pop     ebp
.text$mn:00005241                 retn    8
.text$mn:00005241 ??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z endp
.text$mn:00005241
.text$mn:00005241 _text$mn        ends
.text$mn:00005241
.text$x:00005244 ; ===========================================================================
.text$x:00005244
.text$x:00005244 ; Segment type: Pure code
.text$x:00005244 ; Segment permissions: Read/Execute
.text$x:00005244 _text$x         segment para public 'CODE' use32
.text$x:00005244                 assume cs:_text$x
.text$x:00005244                 ;org 5244h
.text$x:00005244 ; COMDAT (pick associative to section at 51BC)
.text$x:00005244                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005244
.text$x:00005244 ; =============== S U B R O U T I N E =======================================
.text$x:00005244
.text$x:00005244
.text$x:00005244 __unwindfunclet$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z$0 proc near
.text$x:00005244                                         ; DATA XREF: .xdata$x:0000D970o
.text$x:00005244                 mov     eax, [ebp+8]
.text$x:00005247                 push    eax
.text$x:00005248                 mov     eax, [ebp-10h]
.text$x:0000524B                 push    eax             ; void *
.text$x:0000524C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00005251                 add     esp, 8
.text$x:00005254                 retn
.text$x:00005254 __unwindfunclet$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z$0 endp
.text$x:00005254
.text$x:00005255
.text$x:00005255 ; =============== S U B R O U T I N E =======================================
.text$x:00005255
.text$x:00005255
.text$x:00005255 __ehhandler$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z proc near
.text$x:00005255                                         ; DATA XREF: std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut &&)+5o
.text$x:00005255
.text$x:00005255 arg_4           = dword ptr  8
.text$x:00005255
.text$x:00005255                 mov     edx, [esp+arg_4]
.text$x:00005259                 lea     eax, [edx+0Ch]
.text$x:0000525C                 mov     ecx, [edx-14h]
.text$x:0000525F                 xor     ecx, eax
.text$x:00005261                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005266                 mov     eax, offset __ehfuncinfo$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z
.text$x:0000526B                 jmp     ___CxxFrameHandler3
.text$x:0000526B __ehhandler$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z endp
.text$x:0000526B
.text$x:0000526B _text$x         ends
.text$x:0000526B
.text$mn:00005270 ; ===========================================================================
.text$mn:00005270
.text$mn:00005270 ; Segment type: Pure code
.text$mn:00005270 ; Segment permissions: Read/Execute
.text$mn:00005270 _text$mn        segment para public 'CODE' use32
.text$mn:00005270                 assume cs:_text$mn
.text$mn:00005270                 ;org 5270h
.text$mn:00005270 ; COMDAT (pick any)
.text$mn:00005270                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005270
.text$mn:00005270 ; =============== S U B R O U T I N E =======================================
.text$mn:00005270
.text$mn:00005270 ; Attributes: bp-based frame
.text$mn:00005270
.text$mn:00005270 ; int __cdecl std::allocator_traits<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut>(int, void *, int)
.text$mn:00005270                 public ??$construct@VPluginCmdShortcut@@V1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@$$QAV3@@Z
.text$mn:00005270 ??$construct@VPluginCmdShortcut@@V1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@$$QAV3@@Z proc near
.text$mn:00005270                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut &&)+1Cp
.text$mn:00005270
.text$mn:00005270 arg_0           = dword ptr  8
.text$mn:00005270 arg_4           = dword ptr  0Ch
.text$mn:00005270 arg_8           = dword ptr  10h
.text$mn:00005270
.text$mn:00005270                 push    ebp
.text$mn:00005271                 mov     ebp, esp
.text$mn:00005273                 mov     eax, [ebp+arg_8]
.text$mn:00005276                 push    eax
.text$mn:00005277                 call    ??$forward@VPluginCmdShortcut@@@std@@YA$$QAVPluginCmdShortcut@@AAV1@@Z ; std::forward<PluginCmdShortcut>(PluginCmdShortcut &)
.text$mn:0000527C                 add     esp, 4
.text$mn:0000527F                 push    eax             ; int
.text$mn:00005280                 mov     ecx, [ebp+arg_4]
.text$mn:00005283                 push    ecx             ; void *
.text$mn:00005284                 mov     ecx, [ebp+arg_0]
.text$mn:00005287                 call    ??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z ; std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut &&)
.text$mn:0000528C                 pop     ebp
.text$mn:0000528D                 retn
.text$mn:0000528D ??$construct@VPluginCmdShortcut@@V1@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@$$QAV3@@Z endp
.text$mn:0000528D
.text$mn:0000528D ; ---------------------------------------------------------------------------
.text$mn:0000528E                 align 10h
.text$mn:0000528E _text$mn        ends
.text$mn:0000528E
.text$mn:00005290 ; ===========================================================================
.text$mn:00005290
.text$mn:00005290 ; Segment type: Pure code
.text$mn:00005290 ; Segment permissions: Read/Execute
.text$mn:00005290 _text$mn        segment para public 'CODE' use32
.text$mn:00005290                 assume cs:_text$mn
.text$mn:00005290                 ;org 5290h
.text$mn:00005290 ; COMDAT (pick any)
.text$mn:00005290                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005290
.text$mn:00005290 ; =============== S U B R O U T I N E =======================================
.text$mn:00005290
.text$mn:00005290 ; Attributes: bp-based frame
.text$mn:00005290
.text$mn:00005290 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00005290                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00005290 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00005290                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00005290
.text$mn:00005290 var_4           = dword ptr -4
.text$mn:00005290 arg_0           = dword ptr  8
.text$mn:00005290
.text$mn:00005290                 push    ebp
.text$mn:00005291                 mov     ebp, esp
.text$mn:00005293                 push    ecx
.text$mn:00005294                 mov     [ebp+var_4], ecx
.text$mn:00005297                 mov     eax, [ebp+arg_0]
.text$mn:0000529A                 push    eax
.text$mn:0000529B                 mov     ecx, [ebp+var_4]
.text$mn:0000529E                 push    ecx
.text$mn:0000529F                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000052A4                 add     esp, 8
.text$mn:000052A7                 mov     esp, ebp
.text$mn:000052A9                 pop     ebp
.text$mn:000052AA                 retn    4
.text$mn:000052AA ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000052AA
.text$mn:000052AA ; ---------------------------------------------------------------------------
.text$mn:000052AD                 align 10h
.text$mn:000052AD _text$mn        ends
.text$mn:000052AD
.text$mn:000052B0 ; ===========================================================================
.text$mn:000052B0
.text$mn:000052B0 ; Segment type: Pure code
.text$mn:000052B0 ; Segment permissions: Read/Execute
.text$mn:000052B0 _text$mn        segment para public 'CODE' use32
.text$mn:000052B0                 assume cs:_text$mn
.text$mn:000052B0                 ;org 52B0h
.text$mn:000052B0 ; COMDAT (pick any)
.text$mn:000052B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000052B0
.text$mn:000052B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000052B0
.text$mn:000052B0 ; Attributes: bp-based frame
.text$mn:000052B0
.text$mn:000052B0 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000052B0                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000052B0 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000052B0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000052B0
.text$mn:000052B0 var_4           = dword ptr -4
.text$mn:000052B0
.text$mn:000052B0                 push    ebp
.text$mn:000052B1                 mov     ebp, esp
.text$mn:000052B3                 push    ecx
.text$mn:000052B4                 mov     [ebp+var_4], ecx
.text$mn:000052B7                 mov     esp, ebp
.text$mn:000052B9                 pop     ebp
.text$mn:000052BA                 retn    4
.text$mn:000052BA ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000052BA
.text$mn:000052BA ; ---------------------------------------------------------------------------
.text$mn:000052BD                 align 10h
.text$mn:000052BD _text$mn        ends
.text$mn:000052BD
.text$mn:000052C0 ; ===========================================================================
.text$mn:000052C0
.text$mn:000052C0 ; Segment type: Pure code
.text$mn:000052C0 ; Segment permissions: Read/Execute
.text$mn:000052C0 _text$mn        segment para public 'CODE' use32
.text$mn:000052C0                 assume cs:_text$mn
.text$mn:000052C0                 ;org 52C0h
.text$mn:000052C0 ; COMDAT (pick any)
.text$mn:000052C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000052C0
.text$mn:000052C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000052C0
.text$mn:000052C0 ; Attributes: bp-based frame
.text$mn:000052C0
.text$mn:000052C0 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000052C0                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000052C0 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000052C0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000052C0
.text$mn:000052C0 arg_0           = dword ptr  8
.text$mn:000052C0 arg_4           = dword ptr  0Ch
.text$mn:000052C0
.text$mn:000052C0                 push    ebp
.text$mn:000052C1                 mov     ebp, esp
.text$mn:000052C3                 mov     eax, [ebp+arg_4]
.text$mn:000052C6                 push    eax
.text$mn:000052C7                 mov     ecx, [ebp+arg_0]
.text$mn:000052CA                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000052CF                 pop     ebp
.text$mn:000052D0                 retn
.text$mn:000052D0 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000052D0
.text$mn:000052D0 ; ---------------------------------------------------------------------------
.text$mn:000052D1                 align 4
.text$mn:000052D1 _text$mn        ends
.text$mn:000052D1
.text$mn:000052D4 ; ===========================================================================
.text$mn:000052D4
.text$mn:000052D4 ; Segment type: Pure code
.text$mn:000052D4 ; Segment permissions: Read/Execute
.text$mn:000052D4 _text$mn        segment para public 'CODE' use32
.text$mn:000052D4                 assume cs:_text$mn
.text$mn:000052D4                 ;org 52D4h
.text$mn:000052D4 ; COMDAT (pick any)
.text$mn:000052D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000052D4
.text$mn:000052D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000052D4
.text$mn:000052D4 ; Attributes: bp-based frame
.text$mn:000052D4
.text$mn:000052D4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000052D4                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:000052D4 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:000052D4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:000052D4
.text$mn:000052D4 var_4           = dword ptr -4
.text$mn:000052D4 arg_0           = dword ptr  8
.text$mn:000052D4
.text$mn:000052D4                 push    ebp
.text$mn:000052D5                 mov     ebp, esp
.text$mn:000052D7                 push    ecx
.text$mn:000052D8                 mov     [ebp+var_4], ecx
.text$mn:000052DB                 mov     eax, [ebp+arg_0]
.text$mn:000052DE                 push    eax
.text$mn:000052DF                 mov     ecx, [ebp+var_4]
.text$mn:000052E2                 push    ecx
.text$mn:000052E3                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:000052E8                 add     esp, 8
.text$mn:000052EB                 mov     esp, ebp
.text$mn:000052ED                 pop     ebp
.text$mn:000052EE                 retn    4
.text$mn:000052EE ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:000052EE
.text$mn:000052EE ; ---------------------------------------------------------------------------
.text$mn:000052F1                 align 4
.text$mn:000052F1 _text$mn        ends
.text$mn:000052F1
.text$mn:000052F4 ; ===========================================================================
.text$mn:000052F4
.text$mn:000052F4 ; Segment type: Pure code
.text$mn:000052F4 ; Segment permissions: Read/Execute
.text$mn:000052F4 _text$mn        segment para public 'CODE' use32
.text$mn:000052F4                 assume cs:_text$mn
.text$mn:000052F4                 ;org 52F4h
.text$mn:000052F4 ; COMDAT (pick any)
.text$mn:000052F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000052F4
.text$mn:000052F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000052F4
.text$mn:000052F4 ; Attributes: bp-based frame
.text$mn:000052F4
.text$mn:000052F4 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000052F4                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:000052F4 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:000052F4                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:000052F4
.text$mn:000052F4 var_4           = dword ptr -4
.text$mn:000052F4
.text$mn:000052F4                 push    ebp
.text$mn:000052F5                 mov     ebp, esp
.text$mn:000052F7                 push    ecx
.text$mn:000052F8                 mov     [ebp+var_4], ecx
.text$mn:000052FB                 mov     esp, ebp
.text$mn:000052FD                 pop     ebp
.text$mn:000052FE                 retn    4
.text$mn:000052FE ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:000052FE
.text$mn:000052FE ; ---------------------------------------------------------------------------
.text$mn:00005301                 align 4
.text$mn:00005301 _text$mn        ends
.text$mn:00005301
.text$mn:00005304 ; ===========================================================================
.text$mn:00005304
.text$mn:00005304 ; Segment type: Pure code
.text$mn:00005304 ; Segment permissions: Read/Execute
.text$mn:00005304 _text$mn        segment para public 'CODE' use32
.text$mn:00005304                 assume cs:_text$mn
.text$mn:00005304                 ;org 5304h
.text$mn:00005304 ; COMDAT (pick any)
.text$mn:00005304                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005304
.text$mn:00005304 ; =============== S U B R O U T I N E =======================================
.text$mn:00005304
.text$mn:00005304 ; Attributes: bp-based frame
.text$mn:00005304
.text$mn:00005304 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00005304                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00005304 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00005304                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00005304
.text$mn:00005304 arg_0           = dword ptr  8
.text$mn:00005304 arg_4           = dword ptr  0Ch
.text$mn:00005304
.text$mn:00005304                 push    ebp
.text$mn:00005305                 mov     ebp, esp
.text$mn:00005307                 mov     eax, [ebp+arg_4]
.text$mn:0000530A                 push    eax
.text$mn:0000530B                 mov     ecx, [ebp+arg_0]
.text$mn:0000530E                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00005313                 pop     ebp
.text$mn:00005314                 retn
.text$mn:00005314 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00005314
.text$mn:00005314 ; ---------------------------------------------------------------------------
.text$mn:00005315                 align 4
.text$mn:00005315 _text$mn        ends
.text$mn:00005315
.text$mn:00005318 ; ===========================================================================
.text$mn:00005318
.text$mn:00005318 ; Segment type: Pure code
.text$mn:00005318 ; Segment permissions: Read/Execute
.text$mn:00005318 _text$mn        segment para public 'CODE' use32
.text$mn:00005318                 assume cs:_text$mn
.text$mn:00005318                 ;org 5318h
.text$mn:00005318 ; COMDAT (pick any)
.text$mn:00005318                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005318
.text$mn:00005318 ; =============== S U B R O U T I N E =======================================
.text$mn:00005318
.text$mn:00005318 ; Attributes: bp-based frame
.text$mn:00005318
.text$mn:00005318 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::destroy<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)
.text$mn:00005318                 public ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z
.text$mn:00005318 ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z proc near
.text$mn:00005318                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00005318                                         ; __catch$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00005318
.text$mn:00005318 var_4           = dword ptr -4
.text$mn:00005318 arg_0           = dword ptr  8
.text$mn:00005318
.text$mn:00005318                 push    ebp
.text$mn:00005319                 mov     ebp, esp
.text$mn:0000531B                 push    ecx
.text$mn:0000531C                 mov     [ebp+var_4], ecx
.text$mn:0000531F                 mov     eax, [ebp+arg_0]
.text$mn:00005322                 push    eax
.text$mn:00005323                 mov     ecx, [ebp+var_4]
.text$mn:00005326                 push    ecx
.text$mn:00005327                 call    ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::allocator_traits<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:0000532C                 add     esp, 8
.text$mn:0000532F                 mov     esp, ebp
.text$mn:00005331                 pop     ebp
.text$mn:00005332                 retn    4
.text$mn:00005332 ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z endp
.text$mn:00005332
.text$mn:00005332 ; ---------------------------------------------------------------------------
.text$mn:00005335                 align 4
.text$mn:00005335 _text$mn        ends
.text$mn:00005335
.text$mn:00005338 ; ===========================================================================
.text$mn:00005338
.text$mn:00005338 ; Segment type: Pure code
.text$mn:00005338 ; Segment permissions: Read/Execute
.text$mn:00005338 _text$mn        segment para public 'CODE' use32
.text$mn:00005338                 assume cs:_text$mn
.text$mn:00005338                 ;org 5338h
.text$mn:00005338 ; COMDAT (pick any)
.text$mn:00005338                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005338
.text$mn:00005338 ; =============== S U B R O U T I N E =======================================
.text$mn:00005338
.text$mn:00005338 ; Attributes: bp-based frame
.text$mn:00005338
.text$mn:00005338 ; public: void __thiscall std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>::destroy<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)
.text$mn:00005338                 public ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z
.text$mn:00005338 ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z proc near
.text$mn:00005338                                         ; CODE XREF: std::allocator_traits<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+Ap
.text$mn:00005338
.text$mn:00005338 var_4           = dword ptr -4
.text$mn:00005338 arg_0           = dword ptr  8
.text$mn:00005338
.text$mn:00005338                 push    ebp
.text$mn:00005339                 mov     ebp, esp
.text$mn:0000533B                 push    ecx
.text$mn:0000533C                 mov     [ebp+var_4], ecx
.text$mn:0000533F                 push    0
.text$mn:00005341                 mov     ecx, [ebp+arg_0]
.text$mn:00005344                 call    ??_G?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAEPAXI@Z ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::`scalar deleting destructor'(uint)
.text$mn:00005349                 mov     esp, ebp
.text$mn:0000534B                 pop     ebp
.text$mn:0000534C                 retn    4
.text$mn:0000534C ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z endp
.text$mn:0000534C
.text$mn:0000534C ; ---------------------------------------------------------------------------
.text$mn:0000534F                 align 10h
.text$mn:0000534F _text$mn        ends
.text$mn:0000534F
.text$mn:00005350 ; ===========================================================================
.text$mn:00005350
.text$mn:00005350 ; Segment type: Pure code
.text$mn:00005350 ; Segment permissions: Read/Execute
.text$mn:00005350 _text$mn        segment para public 'CODE' use32
.text$mn:00005350                 assume cs:_text$mn
.text$mn:00005350                 ;org 5350h
.text$mn:00005350 ; COMDAT (pick any)
.text$mn:00005350                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005350
.text$mn:00005350 ; =============== S U B R O U T I N E =======================================
.text$mn:00005350
.text$mn:00005350 ; Attributes: bp-based frame
.text$mn:00005350
.text$mn:00005350 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::destroy<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>(class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>> &, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)
.text$mn:00005350                 public ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z
.text$mn:00005350 ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z proc near
.text$mn:00005350                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+Fp
.text$mn:00005350
.text$mn:00005350 arg_0           = dword ptr  8
.text$mn:00005350 arg_4           = dword ptr  0Ch
.text$mn:00005350
.text$mn:00005350                 push    ebp
.text$mn:00005351                 mov     ebp, esp
.text$mn:00005353                 mov     eax, [ebp+arg_4]
.text$mn:00005356                 push    eax
.text$mn:00005357                 mov     ecx, [ebp+arg_0]
.text$mn:0000535A                 call    ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:0000535F                 pop     ebp
.text$mn:00005360                 retn
.text$mn:00005360 ??$destroy@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z endp
.text$mn:00005360
.text$mn:00005360 ; ---------------------------------------------------------------------------
.text$mn:00005361                 align 4
.text$mn:00005361 _text$mn        ends
.text$mn:00005361
.text$mn:00005364 ; ===========================================================================
.text$mn:00005364
.text$mn:00005364 ; Segment type: Pure code
.text$mn:00005364 ; Segment permissions: Read/Execute
.text$mn:00005364 _text$mn        segment para public 'CODE' use32
.text$mn:00005364                 assume cs:_text$mn
.text$mn:00005364                 ;org 5364h
.text$mn:00005364 ; COMDAT (pick any)
.text$mn:00005364                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005364
.text$mn:00005364 ; =============== S U B R O U T I N E =======================================
.text$mn:00005364
.text$mn:00005364 ; Attributes: bp-based frame
.text$mn:00005364
.text$mn:00005364 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct PluginCommand>>::destroy<struct PluginCommand>(struct PluginCommand *)
.text$mn:00005364                 public ??$destroy@UPluginCommand@@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@@Z
.text$mn:00005364 ??$destroy@UPluginCommand@@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@@Z proc near
.text$mn:00005364                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00005364                                         ; __catch$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00005364
.text$mn:00005364 var_4           = dword ptr -4
.text$mn:00005364 arg_0           = dword ptr  8
.text$mn:00005364
.text$mn:00005364                 push    ebp
.text$mn:00005365                 mov     ebp, esp
.text$mn:00005367                 push    ecx
.text$mn:00005368                 mov     [ebp+var_4], ecx
.text$mn:0000536B                 mov     eax, [ebp+arg_0]
.text$mn:0000536E                 push    eax
.text$mn:0000536F                 mov     ecx, [ebp+var_4]
.text$mn:00005372                 push    ecx
.text$mn:00005373                 call    ??$destroy@UPluginCommand@@@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAXAAV?$allocator@UPluginCommand@@@1@PAUPluginCommand@@@Z ; std::allocator_traits<std::allocator<PluginCommand>>::destroy<PluginCommand>(std::allocator<PluginCommand> &,PluginCommand *)
.text$mn:00005378                 add     esp, 8
.text$mn:0000537B                 mov     esp, ebp
.text$mn:0000537D                 pop     ebp
.text$mn:0000537E                 retn    4
.text$mn:0000537E ??$destroy@UPluginCommand@@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@@Z endp
.text$mn:0000537E
.text$mn:0000537E ; ---------------------------------------------------------------------------
.text$mn:00005381                 align 4
.text$mn:00005381 _text$mn        ends
.text$mn:00005381
.text$mn:00005384 ; ===========================================================================
.text$mn:00005384
.text$mn:00005384 ; Segment type: Pure code
.text$mn:00005384 ; Segment permissions: Read/Execute
.text$mn:00005384 _text$mn        segment para public 'CODE' use32
.text$mn:00005384                 assume cs:_text$mn
.text$mn:00005384                 ;org 5384h
.text$mn:00005384 ; COMDAT (pick any)
.text$mn:00005384                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005384
.text$mn:00005384 ; =============== S U B R O U T I N E =======================================
.text$mn:00005384
.text$mn:00005384 ; Attributes: bp-based frame
.text$mn:00005384
.text$mn:00005384 ; public: void __thiscall std::allocator<struct PluginCommand>::destroy<struct PluginCommand>(struct PluginCommand *)
.text$mn:00005384                 public ??$destroy@UPluginCommand@@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@@Z
.text$mn:00005384 ??$destroy@UPluginCommand@@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@@Z proc near
.text$mn:00005384                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginCommand>>::destroy<PluginCommand>(std::allocator<PluginCommand> &,PluginCommand *)+Ap
.text$mn:00005384
.text$mn:00005384 var_4           = dword ptr -4
.text$mn:00005384 arg_0           = dword ptr  8
.text$mn:00005384
.text$mn:00005384                 push    ebp
.text$mn:00005385                 mov     ebp, esp
.text$mn:00005387                 push    ecx
.text$mn:00005388                 mov     [ebp+var_4], ecx
.text$mn:0000538B                 push    0
.text$mn:0000538D                 mov     ecx, [ebp+arg_0]
.text$mn:00005390                 call    ??_GPluginCommand@@QAEPAXI@Z ; PluginCommand::`scalar deleting destructor'(uint)
.text$mn:00005395                 mov     esp, ebp
.text$mn:00005397                 pop     ebp
.text$mn:00005398                 retn    4
.text$mn:00005398 ??$destroy@UPluginCommand@@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@@Z endp
.text$mn:00005398
.text$mn:00005398 ; ---------------------------------------------------------------------------
.text$mn:0000539B                 align 4
.text$mn:0000539B _text$mn        ends
.text$mn:0000539B
.text$mn:0000539C ; ===========================================================================
.text$mn:0000539C
.text$mn:0000539C ; Segment type: Pure code
.text$mn:0000539C ; Segment permissions: Read/Execute
.text$mn:0000539C _text$mn        segment para public 'CODE' use32
.text$mn:0000539C                 assume cs:_text$mn
.text$mn:0000539C                 ;org 539Ch
.text$mn:0000539C ; COMDAT (pick any)
.text$mn:0000539C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000539C
.text$mn:0000539C ; =============== S U B R O U T I N E =======================================
.text$mn:0000539C
.text$mn:0000539C ; Attributes: bp-based frame
.text$mn:0000539C
.text$mn:0000539C ; public: static void __cdecl std::allocator_traits<class std::allocator<struct PluginCommand>>::destroy<struct PluginCommand>(class std::allocator<struct PluginCommand> &, struct PluginCommand *)
.text$mn:0000539C                 public ??$destroy@UPluginCommand@@@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAXAAV?$allocator@UPluginCommand@@@1@PAUPluginCommand@@@Z
.text$mn:0000539C ??$destroy@UPluginCommand@@@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAXAAV?$allocator@UPluginCommand@@@1@PAUPluginCommand@@@Z proc near
.text$mn:0000539C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCommand>>::destroy<PluginCommand>(PluginCommand *)+Fp
.text$mn:0000539C
.text$mn:0000539C arg_0           = dword ptr  8
.text$mn:0000539C arg_4           = dword ptr  0Ch
.text$mn:0000539C
.text$mn:0000539C                 push    ebp
.text$mn:0000539D                 mov     ebp, esp
.text$mn:0000539F                 mov     eax, [ebp+arg_4]
.text$mn:000053A2                 push    eax
.text$mn:000053A3                 mov     ecx, [ebp+arg_0]
.text$mn:000053A6                 call    ??$destroy@UPluginCommand@@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@@Z ; std::allocator<PluginCommand>::destroy<PluginCommand>(PluginCommand *)
.text$mn:000053AB                 pop     ebp
.text$mn:000053AC                 retn
.text$mn:000053AC ??$destroy@UPluginCommand@@@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAXAAV?$allocator@UPluginCommand@@@1@PAUPluginCommand@@@Z endp
.text$mn:000053AC
.text$mn:000053AC ; ---------------------------------------------------------------------------
.text$mn:000053AD                 align 10h
.text$mn:000053AD _text$mn        ends
.text$mn:000053AD
.text$mn:000053B0 ; ===========================================================================
.text$mn:000053B0
.text$mn:000053B0 ; Segment type: Pure code
.text$mn:000053B0 ; Segment permissions: Read/Execute
.text$mn:000053B0 _text$mn        segment para public 'CODE' use32
.text$mn:000053B0                 assume cs:_text$mn
.text$mn:000053B0                 ;org 53B0h
.text$mn:000053B0 ; COMDAT (pick any)
.text$mn:000053B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000053B0
.text$mn:000053B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000053B0
.text$mn:000053B0 ; Attributes: bp-based frame
.text$mn:000053B0
.text$mn:000053B0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000053B0                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000053B0 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000053B0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Free_proxy(void)+22p
.text$mn:000053B0
.text$mn:000053B0 var_4           = dword ptr -4
.text$mn:000053B0 arg_0           = dword ptr  8
.text$mn:000053B0
.text$mn:000053B0                 push    ebp
.text$mn:000053B1                 mov     ebp, esp
.text$mn:000053B3                 push    ecx
.text$mn:000053B4                 mov     [ebp+var_4], ecx
.text$mn:000053B7                 mov     eax, [ebp+arg_0]
.text$mn:000053BA                 push    eax
.text$mn:000053BB                 mov     ecx, [ebp+var_4]
.text$mn:000053BE                 push    ecx
.text$mn:000053BF                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:000053C4                 add     esp, 8
.text$mn:000053C7                 mov     esp, ebp
.text$mn:000053C9                 pop     ebp
.text$mn:000053CA                 retn    4
.text$mn:000053CA ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000053CA
.text$mn:000053CA ; ---------------------------------------------------------------------------
.text$mn:000053CD                 align 10h
.text$mn:000053CD _text$mn        ends
.text$mn:000053CD
.text$mn:000053D0 ; ===========================================================================
.text$mn:000053D0
.text$mn:000053D0 ; Segment type: Pure code
.text$mn:000053D0 ; Segment permissions: Read/Execute
.text$mn:000053D0 _text$mn        segment para public 'CODE' use32
.text$mn:000053D0                 assume cs:_text$mn
.text$mn:000053D0                 ;org 53D0h
.text$mn:000053D0 ; COMDAT (pick any)
.text$mn:000053D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000053D0
.text$mn:000053D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000053D0
.text$mn:000053D0 ; Attributes: bp-based frame
.text$mn:000053D0
.text$mn:000053D0 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000053D0                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000053D0 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000053D0                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:000053D0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:000053D0
.text$mn:000053D0 var_4           = dword ptr -4
.text$mn:000053D0
.text$mn:000053D0                 push    ebp
.text$mn:000053D1                 mov     ebp, esp
.text$mn:000053D3                 push    ecx
.text$mn:000053D4                 mov     [ebp+var_4], ecx
.text$mn:000053D7                 mov     esp, ebp
.text$mn:000053D9                 pop     ebp
.text$mn:000053DA                 retn    4
.text$mn:000053DA ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000053DA
.text$mn:000053DA ; ---------------------------------------------------------------------------
.text$mn:000053DD                 align 10h
.text$mn:000053DD _text$mn        ends
.text$mn:000053DD
.text$mn:000053E0 ; ===========================================================================
.text$mn:000053E0
.text$mn:000053E0 ; Segment type: Pure code
.text$mn:000053E0 ; Segment permissions: Read/Execute
.text$mn:000053E0 _text$mn        segment para public 'CODE' use32
.text$mn:000053E0                 assume cs:_text$mn
.text$mn:000053E0                 ;org 53E0h
.text$mn:000053E0 ; COMDAT (pick any)
.text$mn:000053E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000053E0
.text$mn:000053E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000053E0
.text$mn:000053E0 ; Attributes: bp-based frame
.text$mn:000053E0
.text$mn:000053E0 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:000053E0                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:000053E0 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:000053E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:000053E0
.text$mn:000053E0 arg_0           = dword ptr  8
.text$mn:000053E0 arg_4           = dword ptr  0Ch
.text$mn:000053E0
.text$mn:000053E0                 push    ebp
.text$mn:000053E1                 mov     ebp, esp
.text$mn:000053E3                 mov     eax, [ebp+arg_4]
.text$mn:000053E6                 push    eax
.text$mn:000053E7                 mov     ecx, [ebp+arg_0]
.text$mn:000053EA                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000053EF                 pop     ebp
.text$mn:000053F0                 retn
.text$mn:000053F0 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:000053F0
.text$mn:000053F0 ; ---------------------------------------------------------------------------
.text$mn:000053F1                 align 4
.text$mn:000053F1 _text$mn        ends
.text$mn:000053F1
.text$mn:000053F4 ; ===========================================================================
.text$mn:000053F4
.text$mn:000053F4 ; Segment type: Pure code
.text$mn:000053F4 ; Segment permissions: Read/Execute
.text$mn:000053F4 _text$mn        segment para public 'CODE' use32
.text$mn:000053F4                 assume cs:_text$mn
.text$mn:000053F4                 ;org 53F4h
.text$mn:000053F4 ; COMDAT (pick any)
.text$mn:000053F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000053F4
.text$mn:000053F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000053F4
.text$mn:000053F4 ; Attributes: bp-based frame
.text$mn:000053F4
.text$mn:000053F4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::destroy<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:000053F4                 public ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
.text$mn:000053F4 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z proc near
.text$mn:000053F4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:000053F4                                         ; __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:000053F4
.text$mn:000053F4 var_4           = dword ptr -4
.text$mn:000053F4 arg_0           = dword ptr  8
.text$mn:000053F4
.text$mn:000053F4                 push    ebp
.text$mn:000053F5                 mov     ebp, esp
.text$mn:000053F7                 push    ecx
.text$mn:000053F8                 mov     [ebp+var_4], ecx
.text$mn:000053FB                 mov     eax, [ebp+arg_0]
.text$mn:000053FE                 push    eax
.text$mn:000053FF                 mov     ecx, [ebp+var_4]
.text$mn:00005402                 push    ecx
.text$mn:00005403                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00005408                 add     esp, 8
.text$mn:0000540B                 mov     esp, ebp
.text$mn:0000540D                 pop     ebp
.text$mn:0000540E                 retn    4
.text$mn:0000540E ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z endp
.text$mn:0000540E
.text$mn:0000540E ; ---------------------------------------------------------------------------
.text$mn:00005411                 align 4
.text$mn:00005411 _text$mn        ends
.text$mn:00005411
.text$mn:00005414 ; ===========================================================================
.text$mn:00005414
.text$mn:00005414 ; Segment type: Pure code
.text$mn:00005414 ; Segment permissions: Read/Execute
.text$mn:00005414 _text$mn        segment para public 'CODE' use32
.text$mn:00005414                 assume cs:_text$mn
.text$mn:00005414                 ;org 5414h
.text$mn:00005414 ; COMDAT (pick any)
.text$mn:00005414                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005414
.text$mn:00005414 ; =============== S U B R O U T I N E =======================================
.text$mn:00005414
.text$mn:00005414 ; Attributes: bp-based frame
.text$mn:00005414
.text$mn:00005414 ; public: void __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::destroy<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00005414                 public ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
.text$mn:00005414 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z proc near
.text$mn:00005414                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Ap
.text$mn:00005414
.text$mn:00005414 var_4           = dword ptr -4
.text$mn:00005414 arg_0           = dword ptr  8
.text$mn:00005414
.text$mn:00005414                 push    ebp
.text$mn:00005415                 mov     ebp, esp
.text$mn:00005417                 push    ecx
.text$mn:00005418                 mov     [ebp+var_4], ecx
.text$mn:0000541B                 push    0
.text$mn:0000541D                 mov     ecx, [ebp+arg_0]
.text$mn:00005420                 call    ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)
.text$mn:00005425                 mov     esp, ebp
.text$mn:00005427                 pop     ebp
.text$mn:00005428                 retn    4
.text$mn:00005428 ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z endp
.text$mn:00005428
.text$mn:00005428 ; ---------------------------------------------------------------------------
.text$mn:0000542B                 align 4
.text$mn:0000542B _text$mn        ends
.text$mn:0000542B
.text$mn:0000542C ; ===========================================================================
.text$mn:0000542C
.text$mn:0000542C ; Segment type: Pure code
.text$mn:0000542C ; Segment permissions: Read/Execute
.text$mn:0000542C _text$mn        segment para public 'CODE' use32
.text$mn:0000542C                 assume cs:_text$mn
.text$mn:0000542C                 ;org 542Ch
.text$mn:0000542C ; COMDAT (pick any)
.text$mn:0000542C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000542C
.text$mn:0000542C ; =============== S U B R O U T I N E =======================================
.text$mn:0000542C
.text$mn:0000542C ; Attributes: bp-based frame
.text$mn:0000542C
.text$mn:0000542C ; public: static void __cdecl std::allocator_traits<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::destroy<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>> &, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:0000542C                 public ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
.text$mn:0000542C ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z proc near
.text$mn:0000542C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Fp
.text$mn:0000542C
.text$mn:0000542C arg_0           = dword ptr  8
.text$mn:0000542C arg_4           = dword ptr  0Ch
.text$mn:0000542C
.text$mn:0000542C                 push    ebp
.text$mn:0000542D                 mov     ebp, esp
.text$mn:0000542F                 mov     eax, [ebp+arg_4]
.text$mn:00005432                 push    eax
.text$mn:00005433                 mov     ecx, [ebp+arg_0]
.text$mn:00005436                 call    ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000543B                 pop     ebp
.text$mn:0000543C                 retn
.text$mn:0000543C ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z endp
.text$mn:0000543C
.text$mn:0000543C ; ---------------------------------------------------------------------------
.text$mn:0000543D                 align 10h
.text$mn:0000543D _text$mn        ends
.text$mn:0000543D
.text$mn:00005440 ; ===========================================================================
.text$mn:00005440
.text$mn:00005440 ; Segment type: Pure code
.text$mn:00005440 ; Segment permissions: Read/Execute
.text$mn:00005440 _text$mn        segment para public 'CODE' use32
.text$mn:00005440                 assume cs:_text$mn
.text$mn:00005440                 ;org 5440h
.text$mn:00005440 ; COMDAT (pick any)
.text$mn:00005440                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005440
.text$mn:00005440 ; =============== S U B R O U T I N E =======================================
.text$mn:00005440
.text$mn:00005440 ; Attributes: bp-based frame
.text$mn:00005440
.text$mn:00005440 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>>::destroy<class PluginCmdShortcut>(class PluginCmdShortcut *)
.text$mn:00005440                 public ??$destroy@VPluginCmdShortcut@@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@@Z
.text$mn:00005440 ??$destroy@VPluginCmdShortcut@@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@@Z proc near
.text$mn:00005440                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &,std::_Nonscalar_ptr_iterator_tag)+1Fp
.text$mn:00005440                                         ; __catch$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Cp
.text$mn:00005440
.text$mn:00005440 var_4           = dword ptr -4
.text$mn:00005440 arg_0           = dword ptr  8
.text$mn:00005440
.text$mn:00005440                 push    ebp
.text$mn:00005441                 mov     ebp, esp
.text$mn:00005443                 push    ecx
.text$mn:00005444                 mov     [ebp+var_4], ecx
.text$mn:00005447                 mov     eax, [ebp+arg_0]
.text$mn:0000544A                 push    eax
.text$mn:0000544B                 mov     ecx, [ebp+var_4]
.text$mn:0000544E                 push    ecx
.text$mn:0000544F                 call    ??$destroy@VPluginCmdShortcut@@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@@Z ; std::allocator_traits<std::allocator<PluginCmdShortcut>>::destroy<PluginCmdShortcut>(std::allocator<PluginCmdShortcut> &,PluginCmdShortcut *)
.text$mn:00005454                 add     esp, 8
.text$mn:00005457                 mov     esp, ebp
.text$mn:00005459                 pop     ebp
.text$mn:0000545A                 retn    4
.text$mn:0000545A ??$destroy@VPluginCmdShortcut@@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@@Z endp
.text$mn:0000545A
.text$mn:0000545A ; ---------------------------------------------------------------------------
.text$mn:0000545D                 align 10h
.text$mn:0000545D _text$mn        ends
.text$mn:0000545D
.text$mn:00005460 ; ===========================================================================
.text$mn:00005460
.text$mn:00005460 ; Segment type: Pure code
.text$mn:00005460 ; Segment permissions: Read/Execute
.text$mn:00005460 _text$mn        segment para public 'CODE' use32
.text$mn:00005460                 assume cs:_text$mn
.text$mn:00005460                 ;org 5460h
.text$mn:00005460 ; COMDAT (pick any)
.text$mn:00005460                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005460
.text$mn:00005460 ; =============== S U B R O U T I N E =======================================
.text$mn:00005460
.text$mn:00005460 ; Attributes: bp-based frame
.text$mn:00005460
.text$mn:00005460 ; public: void __thiscall std::allocator<class PluginCmdShortcut>::destroy<class PluginCmdShortcut>(class PluginCmdShortcut *)
.text$mn:00005460                 public ??$destroy@VPluginCmdShortcut@@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@@Z
.text$mn:00005460 ??$destroy@VPluginCmdShortcut@@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@@Z proc near
.text$mn:00005460                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginCmdShortcut>>::destroy<PluginCmdShortcut>(std::allocator<PluginCmdShortcut> &,PluginCmdShortcut *)+Ap
.text$mn:00005460
.text$mn:00005460 var_4           = dword ptr -4
.text$mn:00005460 arg_0           = dword ptr  8
.text$mn:00005460
.text$mn:00005460                 push    ebp
.text$mn:00005461                 mov     ebp, esp
.text$mn:00005463                 push    ecx
.text$mn:00005464                 mov     [ebp+var_4], ecx
.text$mn:00005467                 push    0
.text$mn:00005469                 mov     eax, [ebp+arg_0]
.text$mn:0000546C                 mov     edx, [eax]
.text$mn:0000546E                 mov     ecx, [ebp+arg_0]
.text$mn:00005471                 mov     eax, [edx]
.text$mn:00005473                 call    eax
.text$mn:00005475                 mov     esp, ebp
.text$mn:00005477                 pop     ebp
.text$mn:00005478                 retn    4
.text$mn:00005478 ??$destroy@VPluginCmdShortcut@@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@@Z endp
.text$mn:00005478
.text$mn:00005478 ; ---------------------------------------------------------------------------
.text$mn:0000547B                 align 4
.text$mn:0000547B _text$mn        ends
.text$mn:0000547B
.text$mn:0000547C ; ===========================================================================
.text$mn:0000547C
.text$mn:0000547C ; Segment type: Pure code
.text$mn:0000547C ; Segment permissions: Read/Execute
.text$mn:0000547C _text$mn        segment para public 'CODE' use32
.text$mn:0000547C                 assume cs:_text$mn
.text$mn:0000547C                 ;org 547Ch
.text$mn:0000547C ; COMDAT (pick any)
.text$mn:0000547C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000547C
.text$mn:0000547C ; =============== S U B R O U T I N E =======================================
.text$mn:0000547C
.text$mn:0000547C ; Attributes: bp-based frame
.text$mn:0000547C
.text$mn:0000547C ; public: static void __cdecl std::allocator_traits<class std::allocator<class PluginCmdShortcut>>::destroy<class PluginCmdShortcut>(class std::allocator<class PluginCmdShortcut> &, class PluginCmdShortcut *)
.text$mn:0000547C                 public ??$destroy@VPluginCmdShortcut@@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@@Z
.text$mn:0000547C ??$destroy@VPluginCmdShortcut@@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@@Z proc near
.text$mn:0000547C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::destroy<PluginCmdShortcut>(PluginCmdShortcut *)+Fp
.text$mn:0000547C
.text$mn:0000547C arg_0           = dword ptr  8
.text$mn:0000547C arg_4           = dword ptr  0Ch
.text$mn:0000547C
.text$mn:0000547C                 push    ebp
.text$mn:0000547D                 mov     ebp, esp
.text$mn:0000547F                 mov     eax, [ebp+arg_4]
.text$mn:00005482                 push    eax
.text$mn:00005483                 mov     ecx, [ebp+arg_0]
.text$mn:00005486                 call    ??$destroy@VPluginCmdShortcut@@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@@Z ; std::allocator<PluginCmdShortcut>::destroy<PluginCmdShortcut>(PluginCmdShortcut *)
.text$mn:0000548B                 pop     ebp
.text$mn:0000548C                 retn
.text$mn:0000548C ??$destroy@VPluginCmdShortcut@@@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAXAAV?$allocator@VPluginCmdShortcut@@@1@PAVPluginCmdShortcut@@@Z endp
.text$mn:0000548C
.text$mn:0000548C ; ---------------------------------------------------------------------------
.text$mn:0000548D                 align 10h
.text$mn:0000548D _text$mn        ends
.text$mn:0000548D
.text$mn:00005490 ; ===========================================================================
.text$mn:00005490
.text$mn:00005490 ; Segment type: Pure code
.text$mn:00005490 ; Segment permissions: Read/Execute
.text$mn:00005490 _text$mn        segment para public 'CODE' use32
.text$mn:00005490                 assume cs:_text$mn
.text$mn:00005490                 ;org 5490h
.text$mn:00005490 ; COMDAT (pick any)
.text$mn:00005490                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005490
.text$mn:00005490 ; =============== S U B R O U T I N E =======================================
.text$mn:00005490
.text$mn:00005490 ; Attributes: bp-based frame
.text$mn:00005490
.text$mn:00005490 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00005490                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00005490 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00005490                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00005490                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00005490
.text$mn:00005490 arg_0           = dword ptr  8
.text$mn:00005490
.text$mn:00005490                 push    ebp
.text$mn:00005491                 mov     ebp, esp
.text$mn:00005493                 mov     eax, [ebp+arg_0]
.text$mn:00005496                 pop     ebp
.text$mn:00005497                 retn
.text$mn:00005497 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00005497
.text$mn:00005497 _text$mn        ends
.text$mn:00005497
.text$mn:00005498 ; ===========================================================================
.text$mn:00005498
.text$mn:00005498 ; Segment type: Pure code
.text$mn:00005498 ; Segment permissions: Read/Execute
.text$mn:00005498 _text$mn        segment para public 'CODE' use32
.text$mn:00005498                 assume cs:_text$mn
.text$mn:00005498                 ;org 5498h
.text$mn:00005498 ; COMDAT (pick any)
.text$mn:00005498                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005498
.text$mn:00005498 ; =============== S U B R O U T I N E =======================================
.text$mn:00005498
.text$mn:00005498 ; Attributes: bp-based frame
.text$mn:00005498
.text$mn:00005498 ; struct PluginInfo * & __cdecl std::forward<struct PluginInfo * &>(struct PluginInfo * &)
.text$mn:00005498                 public ??$forward@AAPAUPluginInfo@@@std@@YAAAPAUPluginInfo@@AAPAU1@@Z
.text$mn:00005498 ??$forward@AAPAUPluginInfo@@@std@@YAAAPAUPluginInfo@@AAPAU1@@Z proc near
.text$mn:00005498                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * &>(PluginInfo * *,PluginInfo * &)+Bp
.text$mn:00005498                                         ; std::allocator<PluginInfo *>::construct<PluginInfo *,PluginInfo * &>(PluginInfo * *,PluginInfo * &)+4Ap ...
.text$mn:00005498
.text$mn:00005498 arg_0           = dword ptr  8
.text$mn:00005498
.text$mn:00005498                 push    ebp
.text$mn:00005499                 mov     ebp, esp
.text$mn:0000549B                 mov     eax, [ebp+arg_0]
.text$mn:0000549E                 pop     ebp
.text$mn:0000549F                 retn
.text$mn:0000549F ??$forward@AAPAUPluginInfo@@@std@@YAAAPAUPluginInfo@@AAPAU1@@Z endp
.text$mn:0000549F
.text$mn:0000549F _text$mn        ends
.text$mn:0000549F
.text$mn:000054A0 ; ===========================================================================
.text$mn:000054A0
.text$mn:000054A0 ; Segment type: Pure code
.text$mn:000054A0 ; Segment permissions: Read/Execute
.text$mn:000054A0 _text$mn        segment para public 'CODE' use32
.text$mn:000054A0                 assume cs:_text$mn
.text$mn:000054A0                 ;org 54A0h
.text$mn:000054A0 ; COMDAT (pick any)
.text$mn:000054A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054A0
.text$mn:000054A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054A0
.text$mn:000054A0 ; Attributes: bp-based frame
.text$mn:000054A0
.text$mn:000054A0 ; class TiXmlDocument * & __cdecl std::forward<class TiXmlDocument * &>(class TiXmlDocument * &)
.text$mn:000054A0                 public ??$forward@AAPAVTiXmlDocument@@@std@@YAAAPAVTiXmlDocument@@AAPAV1@@Z
.text$mn:000054A0 ??$forward@AAPAVTiXmlDocument@@@std@@YAAAPAVTiXmlDocument@@AAPAV1@@Z proc near
.text$mn:000054A0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * &>(TiXmlDocument * *,TiXmlDocument * &)+Bp
.text$mn:000054A0                                         ; std::allocator<TiXmlDocument *>::construct<TiXmlDocument *,TiXmlDocument * &>(TiXmlDocument * *,TiXmlDocument * &)+4Ap ...
.text$mn:000054A0
.text$mn:000054A0 arg_0           = dword ptr  8
.text$mn:000054A0
.text$mn:000054A0                 push    ebp
.text$mn:000054A1                 mov     ebp, esp
.text$mn:000054A3                 mov     eax, [ebp+arg_0]
.text$mn:000054A6                 pop     ebp
.text$mn:000054A7                 retn
.text$mn:000054A7 ??$forward@AAPAVTiXmlDocument@@@std@@YAAAPAVTiXmlDocument@@AAPAV1@@Z endp
.text$mn:000054A7
.text$mn:000054A7 _text$mn        ends
.text$mn:000054A7
.text$mn:000054A8 ; ===========================================================================
.text$mn:000054A8
.text$mn:000054A8 ; Segment type: Pure code
.text$mn:000054A8 ; Segment permissions: Read/Execute
.text$mn:000054A8 _text$mn        segment para public 'CODE' use32
.text$mn:000054A8                 assume cs:_text$mn
.text$mn:000054A8                 ;org 54A8h
.text$mn:000054A8 ; COMDAT (pick any)
.text$mn:000054A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054A8
.text$mn:000054A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054A8
.text$mn:000054A8 ; Attributes: bp-based frame
.text$mn:000054A8
.text$mn:000054A8 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000054A8                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:000054A8 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:000054A8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:000054A8                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:000054A8
.text$mn:000054A8 arg_0           = dword ptr  8
.text$mn:000054A8
.text$mn:000054A8                 push    ebp
.text$mn:000054A9                 mov     ebp, esp
.text$mn:000054AB                 mov     eax, [ebp+arg_0]
.text$mn:000054AE                 pop     ebp
.text$mn:000054AF                 retn
.text$mn:000054AF ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:000054AF
.text$mn:000054AF _text$mn        ends
.text$mn:000054AF
.text$mn:000054B0 ; ===========================================================================
.text$mn:000054B0
.text$mn:000054B0 ; Segment type: Pure code
.text$mn:000054B0 ; Segment permissions: Read/Execute
.text$mn:000054B0 _text$mn        segment para public 'CODE' use32
.text$mn:000054B0                 assume cs:_text$mn
.text$mn:000054B0                 ;org 54B0h
.text$mn:000054B0 ; COMDAT (pick any)
.text$mn:000054B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054B0
.text$mn:000054B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054B0
.text$mn:000054B0 ; Attributes: bp-based frame
.text$mn:000054B0
.text$mn:000054B0 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __cdecl std::forward<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:000054B0                 public ??$forward@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
.text$mn:000054B0 ??$forward@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z proc near
.text$mn:000054B0                                         ; CODE XREF: std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,bool &)+2Ap
.text$mn:000054B0                                         ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)+Bp ...
.text$mn:000054B0
.text$mn:000054B0 arg_0           = dword ptr  8
.text$mn:000054B0
.text$mn:000054B0                 push    ebp
.text$mn:000054B1                 mov     ebp, esp
.text$mn:000054B3                 mov     eax, [ebp+arg_0]
.text$mn:000054B6                 pop     ebp
.text$mn:000054B7                 retn
.text$mn:000054B7 ??$forward@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z endp
.text$mn:000054B7
.text$mn:000054B7 _text$mn        ends
.text$mn:000054B7
.text$mn:000054B8 ; ===========================================================================
.text$mn:000054B8
.text$mn:000054B8 ; Segment type: Pure code
.text$mn:000054B8 ; Segment permissions: Read/Execute
.text$mn:000054B8 _text$mn        segment para public 'CODE' use32
.text$mn:000054B8                 assume cs:_text$mn
.text$mn:000054B8                 ;org 54B8h
.text$mn:000054B8 ; COMDAT (pick any)
.text$mn:000054B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054B8
.text$mn:000054B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054B8
.text$mn:000054B8 ; Attributes: bp-based frame
.text$mn:000054B8
.text$mn:000054B8 ; class PluginCmdShortcut & __cdecl std::forward<class PluginCmdShortcut &>(class PluginCmdShortcut &)
.text$mn:000054B8                 public ??$forward@AAVPluginCmdShortcut@@@std@@YAAAVPluginCmdShortcut@@AAV1@@Z
.text$mn:000054B8 ??$forward@AAVPluginCmdShortcut@@@std@@YAAAVPluginCmdShortcut@@AAV1@@Z proc near
.text$mn:000054B8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut &>(PluginCmdShortcut *,PluginCmdShortcut &)+Bp
.text$mn:000054B8                                         ; std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut &>(PluginCmdShortcut *,PluginCmdShortcut &)+4Dp ...
.text$mn:000054B8
.text$mn:000054B8 arg_0           = dword ptr  8
.text$mn:000054B8
.text$mn:000054B8                 push    ebp
.text$mn:000054B9                 mov     ebp, esp
.text$mn:000054BB                 mov     eax, [ebp+arg_0]
.text$mn:000054BE                 pop     ebp
.text$mn:000054BF                 retn
.text$mn:000054BF ??$forward@AAVPluginCmdShortcut@@@std@@YAAAVPluginCmdShortcut@@AAV1@@Z endp
.text$mn:000054BF
.text$mn:000054BF _text$mn        ends
.text$mn:000054BF
.text$mn:000054C0 ; ===========================================================================
.text$mn:000054C0
.text$mn:000054C0 ; Segment type: Pure code
.text$mn:000054C0 ; Segment permissions: Read/Execute
.text$mn:000054C0 _text$mn        segment para public 'CODE' use32
.text$mn:000054C0                 assume cs:_text$mn
.text$mn:000054C0                 ;org 54C0h
.text$mn:000054C0 ; COMDAT (pick any)
.text$mn:000054C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054C0
.text$mn:000054C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054C0
.text$mn:000054C0 ; Attributes: bp-based frame
.text$mn:000054C0
.text$mn:000054C0 ; bool & __cdecl std::forward<bool &>(bool &)
.text$mn:000054C0                 public ??$forward@AA_N@std@@YAAA_NAA_N@Z
.text$mn:000054C0 ??$forward@AA_N@std@@YAAA_NAA_N@Z proc near
.text$mn:000054C0                                         ; CODE XREF: std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,bool &)+46p
.text$mn:000054C0
.text$mn:000054C0 arg_0           = dword ptr  8
.text$mn:000054C0
.text$mn:000054C0                 push    ebp
.text$mn:000054C1                 mov     ebp, esp
.text$mn:000054C3                 mov     eax, [ebp+arg_0]
.text$mn:000054C6                 pop     ebp
.text$mn:000054C7                 retn
.text$mn:000054C7 ??$forward@AA_N@std@@YAAA_NAA_N@Z endp
.text$mn:000054C7
.text$mn:000054C7 _text$mn        ends
.text$mn:000054C7
.text$mn:000054C8 ; ===========================================================================
.text$mn:000054C8
.text$mn:000054C8 ; Segment type: Pure code
.text$mn:000054C8 ; Segment permissions: Read/Execute
.text$mn:000054C8 _text$mn        segment para public 'CODE' use32
.text$mn:000054C8                 assume cs:_text$mn
.text$mn:000054C8                 ;org 54C8h
.text$mn:000054C8 ; COMDAT (pick any)
.text$mn:000054C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054C8
.text$mn:000054C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054C8
.text$mn:000054C8 ; Attributes: bp-based frame
.text$mn:000054C8
.text$mn:000054C8 ; struct PluginInfo * const & __cdecl std::forward<struct PluginInfo * const &>(struct PluginInfo * const &)
.text$mn:000054C8                 public ??$forward@ABQAUPluginInfo@@@std@@YAABQAUPluginInfo@@ABQAU1@@Z
.text$mn:000054C8 ??$forward@ABQAUPluginInfo@@@std@@YAABQAUPluginInfo@@ABQAU1@@Z proc near
.text$mn:000054C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * const &>(PluginInfo * *,PluginInfo * const &)+Bp
.text$mn:000054C8                                         ; std::allocator_traits<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * const &>(std::allocator<PluginInfo *> &,PluginInfo * *,PluginInfo * const &)+7p
.text$mn:000054C8
.text$mn:000054C8 arg_0           = dword ptr  8
.text$mn:000054C8
.text$mn:000054C8                 push    ebp
.text$mn:000054C9                 mov     ebp, esp
.text$mn:000054CB                 mov     eax, [ebp+arg_0]
.text$mn:000054CE                 pop     ebp
.text$mn:000054CF                 retn
.text$mn:000054CF ??$forward@ABQAUPluginInfo@@@std@@YAABQAUPluginInfo@@ABQAU1@@Z endp
.text$mn:000054CF
.text$mn:000054CF _text$mn        ends
.text$mn:000054CF
.text$mn:000054D0 ; ===========================================================================
.text$mn:000054D0
.text$mn:000054D0 ; Segment type: Pure code
.text$mn:000054D0 ; Segment permissions: Read/Execute
.text$mn:000054D0 _text$mn        segment para public 'CODE' use32
.text$mn:000054D0                 assume cs:_text$mn
.text$mn:000054D0                 ;org 54D0h
.text$mn:000054D0 ; COMDAT (pick any)
.text$mn:000054D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054D0
.text$mn:000054D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054D0
.text$mn:000054D0 ; Attributes: bp-based frame
.text$mn:000054D0
.text$mn:000054D0 ; class TiXmlDocument * const & __cdecl std::forward<class TiXmlDocument * const &>(class TiXmlDocument * const &)
.text$mn:000054D0                 public ??$forward@ABQAVTiXmlDocument@@@std@@YAABQAVTiXmlDocument@@ABQAV1@@Z
.text$mn:000054D0 ??$forward@ABQAVTiXmlDocument@@@std@@YAABQAVTiXmlDocument@@ABQAV1@@Z proc near
.text$mn:000054D0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * const &>(TiXmlDocument * *,TiXmlDocument * const &)+Bp
.text$mn:000054D0                                         ; std::allocator_traits<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * const &>(std::allocator<TiXmlDocument *> &,TiXmlDocument * *,TiXmlDocument * const &)+7p
.text$mn:000054D0
.text$mn:000054D0 arg_0           = dword ptr  8
.text$mn:000054D0
.text$mn:000054D0                 push    ebp
.text$mn:000054D1                 mov     ebp, esp
.text$mn:000054D3                 mov     eax, [ebp+arg_0]
.text$mn:000054D6                 pop     ebp
.text$mn:000054D7                 retn
.text$mn:000054D7 ??$forward@ABQAVTiXmlDocument@@@std@@YAABQAVTiXmlDocument@@ABQAV1@@Z endp
.text$mn:000054D7
.text$mn:000054D7 _text$mn        ends
.text$mn:000054D7
.text$mn:000054D8 ; ===========================================================================
.text$mn:000054D8
.text$mn:000054D8 ; Segment type: Pure code
.text$mn:000054D8 ; Segment permissions: Read/Execute
.text$mn:000054D8 _text$mn        segment para public 'CODE' use32
.text$mn:000054D8                 assume cs:_text$mn
.text$mn:000054D8                 ;org 54D8h
.text$mn:000054D8 ; COMDAT (pick any)
.text$mn:000054D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054D8
.text$mn:000054D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054D8
.text$mn:000054D8 ; Attributes: bp-based frame
.text$mn:000054D8
.text$mn:000054D8 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const & __cdecl std::forward<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:000054D8                 public ??$forward@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z
.text$mn:000054D8 ??$forward@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z proc near
.text$mn:000054D8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Bp
.text$mn:000054D8                                         ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7p
.text$mn:000054D8
.text$mn:000054D8 arg_0           = dword ptr  8
.text$mn:000054D8
.text$mn:000054D8                 push    ebp
.text$mn:000054D9                 mov     ebp, esp
.text$mn:000054DB                 mov     eax, [ebp+arg_0]
.text$mn:000054DE                 pop     ebp
.text$mn:000054DF                 retn
.text$mn:000054DF ??$forward@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z endp
.text$mn:000054DF
.text$mn:000054DF _text$mn        ends
.text$mn:000054DF
.text$mn:000054E0 ; ===========================================================================
.text$mn:000054E0
.text$mn:000054E0 ; Segment type: Pure code
.text$mn:000054E0 ; Segment permissions: Read/Execute
.text$mn:000054E0 _text$mn        segment para public 'CODE' use32
.text$mn:000054E0                 assume cs:_text$mn
.text$mn:000054E0                 ;org 54E0h
.text$mn:000054E0 ; COMDAT (pick any)
.text$mn:000054E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054E0
.text$mn:000054E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054E0
.text$mn:000054E0 ; Attributes: bp-based frame
.text$mn:000054E0
.text$mn:000054E0 ; class PluginCmdShortcut const & __cdecl std::forward<class PluginCmdShortcut const &>(class PluginCmdShortcut const &)
.text$mn:000054E0                 public ??$forward@ABVPluginCmdShortcut@@@std@@YAABVPluginCmdShortcut@@ABV1@@Z
.text$mn:000054E0 ??$forward@ABVPluginCmdShortcut@@@std@@YAABVPluginCmdShortcut@@ABV1@@Z proc near
.text$mn:000054E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut const &>(PluginCmdShortcut *,PluginCmdShortcut const &)+Bp
.text$mn:000054E0                                         ; std::allocator_traits<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut const &>(std::allocator<PluginCmdShortcut> &,PluginCmdShortcut *,PluginCmdShortcut const &)+7p
.text$mn:000054E0
.text$mn:000054E0 arg_0           = dword ptr  8
.text$mn:000054E0
.text$mn:000054E0                 push    ebp
.text$mn:000054E1                 mov     ebp, esp
.text$mn:000054E3                 mov     eax, [ebp+arg_0]
.text$mn:000054E6                 pop     ebp
.text$mn:000054E7                 retn
.text$mn:000054E7 ??$forward@ABVPluginCmdShortcut@@@std@@YAABVPluginCmdShortcut@@ABV1@@Z endp
.text$mn:000054E7
.text$mn:000054E7 _text$mn        ends
.text$mn:000054E7
.text$mn:000054E8 ; ===========================================================================
.text$mn:000054E8
.text$mn:000054E8 ; Segment type: Pure code
.text$mn:000054E8 ; Segment permissions: Read/Execute
.text$mn:000054E8 _text$mn        segment para public 'CODE' use32
.text$mn:000054E8                 assume cs:_text$mn
.text$mn:000054E8                 ;org 54E8h
.text$mn:000054E8 ; COMDAT (pick any)
.text$mn:000054E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054E8
.text$mn:000054E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054E8
.text$mn:000054E8 ; Attributes: bp-based frame
.text$mn:000054E8
.text$mn:000054E8 ; struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> && __cdecl std::forward<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> &)
.text$mn:000054E8                 public ??$forward@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z
.text$mn:000054E8 ??$forward@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z proc near
.text$mn:000054E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+Bp
.text$mn:000054E8                                         ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+4Ap ...
.text$mn:000054E8
.text$mn:000054E8 arg_0           = dword ptr  8
.text$mn:000054E8
.text$mn:000054E8                 push    ebp
.text$mn:000054E9                 mov     ebp, esp
.text$mn:000054EB                 mov     eax, [ebp+arg_0]
.text$mn:000054EE                 pop     ebp
.text$mn:000054EF                 retn
.text$mn:000054EF ??$forward@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z endp
.text$mn:000054EF
.text$mn:000054EF _text$mn        ends
.text$mn:000054EF
.text$mn:000054F0 ; ===========================================================================
.text$mn:000054F0
.text$mn:000054F0 ; Segment type: Pure code
.text$mn:000054F0 ; Segment permissions: Read/Execute
.text$mn:000054F0 _text$mn        segment para public 'CODE' use32
.text$mn:000054F0                 assume cs:_text$mn
.text$mn:000054F0                 ;org 54F0h
.text$mn:000054F0 ; COMDAT (pick any)
.text$mn:000054F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054F0
.text$mn:000054F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054F0
.text$mn:000054F0 ; Attributes: bp-based frame
.text$mn:000054F0
.text$mn:000054F0 ; struct PluginCommand && __cdecl std::forward<struct PluginCommand>(struct PluginCommand &)
.text$mn:000054F0                 public ??$forward@UPluginCommand@@@std@@YA$$QAUPluginCommand@@AAU1@@Z
.text$mn:000054F0 ??$forward@UPluginCommand@@@std@@YA$$QAUPluginCommand@@AAU1@@Z proc near
.text$mn:000054F0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCommand>>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)+Bp
.text$mn:000054F0                                         ; std::allocator<PluginCommand>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)+4Ap ...
.text$mn:000054F0
.text$mn:000054F0 arg_0           = dword ptr  8
.text$mn:000054F0
.text$mn:000054F0                 push    ebp
.text$mn:000054F1                 mov     ebp, esp
.text$mn:000054F3                 mov     eax, [ebp+arg_0]
.text$mn:000054F6                 pop     ebp
.text$mn:000054F7                 retn
.text$mn:000054F7 ??$forward@UPluginCommand@@@std@@YA$$QAUPluginCommand@@AAU1@@Z endp
.text$mn:000054F7
.text$mn:000054F7 _text$mn        ends
.text$mn:000054F7
.text$mn:000054F8 ; ===========================================================================
.text$mn:000054F8
.text$mn:000054F8 ; Segment type: Pure code
.text$mn:000054F8 ; Segment permissions: Read/Execute
.text$mn:000054F8 _text$mn        segment para public 'CODE' use32
.text$mn:000054F8                 assume cs:_text$mn
.text$mn:000054F8                 ;org 54F8h
.text$mn:000054F8 ; COMDAT (pick any)
.text$mn:000054F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054F8
.text$mn:000054F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054F8
.text$mn:000054F8 ; Attributes: bp-based frame
.text$mn:000054F8
.text$mn:000054F8 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000054F8                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000054F8 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000054F8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:000054F8                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:000054F8
.text$mn:000054F8 arg_0           = dword ptr  8
.text$mn:000054F8
.text$mn:000054F8                 push    ebp
.text$mn:000054F9                 mov     ebp, esp
.text$mn:000054FB                 mov     eax, [ebp+arg_0]
.text$mn:000054FE                 pop     ebp
.text$mn:000054FF                 retn
.text$mn:000054FF ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000054FF
.text$mn:000054FF _text$mn        ends
.text$mn:000054FF
.text$mn:00005500 ; ===========================================================================
.text$mn:00005500
.text$mn:00005500 ; Segment type: Pure code
.text$mn:00005500 ; Segment permissions: Read/Execute
.text$mn:00005500 _text$mn        segment para public 'CODE' use32
.text$mn:00005500                 assume cs:_text$mn
.text$mn:00005500                 ;org 5500h
.text$mn:00005500 ; COMDAT (pick any)
.text$mn:00005500                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005500
.text$mn:00005500 ; =============== S U B R O U T I N E =======================================
.text$mn:00005500
.text$mn:00005500 ; Attributes: bp-based frame
.text$mn:00005500
.text$mn:00005500 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> && __cdecl std::forward<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:00005500                 public ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
.text$mn:00005500 ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z proc near
.text$mn:00005500                                         ; CODE XREF: std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+2Ap
.text$mn:00005500                                         ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+Bp ...
.text$mn:00005500
.text$mn:00005500 arg_0           = dword ptr  8
.text$mn:00005500
.text$mn:00005500                 push    ebp
.text$mn:00005501                 mov     ebp, esp
.text$mn:00005503                 mov     eax, [ebp+arg_0]
.text$mn:00005506                 pop     ebp
.text$mn:00005507                 retn
.text$mn:00005507 ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z endp
.text$mn:00005507
.text$mn:00005507 _text$mn        ends
.text$mn:00005507
.text$mn:00005508 ; ===========================================================================
.text$mn:00005508
.text$mn:00005508 ; Segment type: Pure code
.text$mn:00005508 ; Segment permissions: Read/Execute
.text$mn:00005508 _text$mn        segment para public 'CODE' use32
.text$mn:00005508                 assume cs:_text$mn
.text$mn:00005508                 ;org 5508h
.text$mn:00005508 ; COMDAT (pick any)
.text$mn:00005508                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005508
.text$mn:00005508 ; =============== S U B R O U T I N E =======================================
.text$mn:00005508
.text$mn:00005508 ; Attributes: bp-based frame
.text$mn:00005508
.text$mn:00005508 ; class PluginCmdShortcut && __cdecl std::forward<class PluginCmdShortcut>(class PluginCmdShortcut &)
.text$mn:00005508                 public ??$forward@VPluginCmdShortcut@@@std@@YA$$QAVPluginCmdShortcut@@AAV1@@Z
.text$mn:00005508 ??$forward@VPluginCmdShortcut@@@std@@YA$$QAVPluginCmdShortcut@@AAV1@@Z proc near
.text$mn:00005508                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut &&)+Bp
.text$mn:00005508                                         ; std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut &&)+4Dp ...
.text$mn:00005508
.text$mn:00005508 arg_0           = dword ptr  8
.text$mn:00005508
.text$mn:00005508                 push    ebp
.text$mn:00005509                 mov     ebp, esp
.text$mn:0000550B                 mov     eax, [ebp+arg_0]
.text$mn:0000550E                 pop     ebp
.text$mn:0000550F                 retn
.text$mn:0000550F ??$forward@VPluginCmdShortcut@@@std@@YA$$QAVPluginCmdShortcut@@AAV1@@Z endp
.text$mn:0000550F
.text$mn:0000550F _text$mn        ends
.text$mn:0000550F
.text$mn:00005510 ; ===========================================================================
.text$mn:00005510
.text$mn:00005510 ; Segment type: Pure code
.text$mn:00005510 ; Segment permissions: Read/Execute
.text$mn:00005510 _text$mn        segment para public 'CODE' use32
.text$mn:00005510                 assume cs:_text$mn
.text$mn:00005510                 ;org 5510h
.text$mn:00005510 ; COMDAT (pick any)
.text$mn:00005510                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005510
.text$mn:00005510 ; =============== S U B R O U T I N E =======================================
.text$mn:00005510
.text$mn:00005510 ; Attributes: bp-based frame
.text$mn:00005510
.text$mn:00005510 ; bool && __cdecl std::forward<bool>(bool &)
.text$mn:00005510                 public ??$forward@_N@std@@YA$$QA_NAA_N@Z
.text$mn:00005510 ??$forward@_N@std@@YA$$QA_NAA_N@Z proc near
.text$mn:00005510                                         ; CODE XREF: std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+49p
.text$mn:00005510
.text$mn:00005510 arg_0           = dword ptr  8
.text$mn:00005510
.text$mn:00005510                 push    ebp
.text$mn:00005511                 mov     ebp, esp
.text$mn:00005513                 mov     eax, [ebp+arg_0]
.text$mn:00005516                 pop     ebp
.text$mn:00005517                 retn
.text$mn:00005517 ??$forward@_N@std@@YA$$QA_NAA_N@Z endp
.text$mn:00005517
.text$mn:00005517 _text$mn        ends
.text$mn:00005517
.text$mn:00005518 ; ===========================================================================
.text$mn:00005518
.text$mn:00005518 ; Segment type: Pure code
.text$mn:00005518 ; Segment permissions: Read/Execute
.text$mn:00005518 _text$mn        segment para public 'CODE' use32
.text$mn:00005518                 assume cs:_text$mn
.text$mn:00005518                 ;org 5518h
.text$mn:00005518 ; COMDAT (pick any)
.text$mn:00005518                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005518
.text$mn:00005518 ; =============== S U B R O U T I N E =======================================
.text$mn:00005518
.text$mn:00005518 ; Attributes: bp-based frame
.text$mn:00005518
.text$mn:00005518 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> && __cdecl std::move<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:00005518                 public ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
.text$mn:00005518 ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z proc near
.text$mn:00005518                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&,wchar_t const *)+37p
.text$mn:00005518
.text$mn:00005518 arg_0           = dword ptr  8
.text$mn:00005518
.text$mn:00005518                 push    ebp
.text$mn:00005519                 mov     ebp, esp
.text$mn:0000551B                 mov     eax, [ebp+arg_0]
.text$mn:0000551E                 pop     ebp
.text$mn:0000551F                 retn
.text$mn:0000551F ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z endp
.text$mn:0000551F
.text$mn:0000551F _text$mn        ends
.text$mn:0000551F
.text$mn:00005520 ; ===========================================================================
.text$mn:00005520
.text$mn:00005520 ; Segment type: Pure code
.text$mn:00005520 ; Segment permissions: Read/Execute
.text$mn:00005520 _text$mn        segment para public 'CODE' use32
.text$mn:00005520                 assume cs:_text$mn
.text$mn:00005520                 ;org 5520h
.text$mn:00005520 ; COMDAT (pick any)
.text$mn:00005520                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005520
.text$mn:00005520 ; =============== S U B R O U T I N E =======================================
.text$mn:00005520
.text$mn:00005520 ; Attributes: bp-based frame
.text$mn:00005520
.text$mn:00005520 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00005520                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00005520 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00005520                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00005520
.text$mn:00005520 var_10          = dword ptr -10h
.text$mn:00005520 var_C           = dword ptr -0Ch
.text$mn:00005520 var_4           = dword ptr -4
.text$mn:00005520
.text$mn:00005520                 push    ebp
.text$mn:00005521                 mov     ebp, esp
.text$mn:00005523                 push    0FFFFFFFFh
.text$mn:00005525                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000552A                 mov     eax, large fs:0
.text$mn:00005530                 push    eax
.text$mn:00005531                 push    ecx
.text$mn:00005532                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005537                 xor     eax, ebp
.text$mn:00005539                 push    eax
.text$mn:0000553A                 lea     eax, [ebp+var_C]
.text$mn:0000553D                 mov     large fs:0, eax
.text$mn:00005543                 mov     [ebp+var_10], ecx
.text$mn:00005546                 mov     ecx, [ebp+var_10]
.text$mn:00005549                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:0000554E                 mov     [ebp+var_4], 0
.text$mn:00005555                 mov     ecx, [ebp+var_10]
.text$mn:00005558                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:0000555D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005564                 mov     eax, [ebp+var_10]
.text$mn:00005567                 mov     ecx, [ebp+var_C]
.text$mn:0000556A                 mov     large fs:0, ecx
.text$mn:00005571                 pop     ecx
.text$mn:00005572                 mov     esp, ebp
.text$mn:00005574                 pop     ebp
.text$mn:00005575                 retn    4
.text$mn:00005575 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00005575
.text$mn:00005575 _text$mn        ends
.text$mn:00005575
.text$x:00005578 ; ===========================================================================
.text$x:00005578
.text$x:00005578 ; Segment type: Pure code
.text$x:00005578 ; Segment permissions: Read/Execute
.text$x:00005578 _text$x         segment para public 'CODE' use32
.text$x:00005578                 assume cs:_text$x
.text$x:00005578                 ;org 5578h
.text$x:00005578 ; COMDAT (pick associative to section at 5520)
.text$x:00005578                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005578
.text$x:00005578 ; =============== S U B R O U T I N E =======================================
.text$x:00005578
.text$x:00005578
.text$x:00005578 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00005578                                         ; DATA XREF: .xdata$x:0000C420o
.text$x:00005578                 mov     ecx, [ebp-10h]
.text$x:0000557B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000557B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:0000557B
.text$x:00005580
.text$x:00005580 ; =============== S U B R O U T I N E =======================================
.text$x:00005580
.text$x:00005580
.text$x:00005580 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00005580                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00005580
.text$x:00005580 arg_4           = dword ptr  8
.text$x:00005580
.text$x:00005580                 mov     edx, [esp+arg_4]
.text$x:00005584                 lea     eax, [edx+0Ch]
.text$x:00005587                 mov     ecx, [edx-8]
.text$x:0000558A                 xor     ecx, eax
.text$x:0000558C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005591                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00005596                 jmp     ___CxxFrameHandler3
.text$x:00005596 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00005596
.text$x:00005596 ; ---------------------------------------------------------------------------
.text$x:0000559B                 align 4
.text$x:0000559B _text$x         ends
.text$x:0000559B
.text$mn:0000559C ; ===========================================================================
.text$mn:0000559C
.text$mn:0000559C ; Segment type: Pure code
.text$mn:0000559C ; Segment permissions: Read/Execute
.text$mn:0000559C _text$mn        segment para public 'CODE' use32
.text$mn:0000559C                 assume cs:_text$mn
.text$mn:0000559C                 ;org 559Ch
.text$mn:0000559C ; COMDAT (pick any)
.text$mn:0000559C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000559C
.text$mn:0000559C ; =============== S U B R O U T I N E =======================================
.text$mn:0000559C
.text$mn:0000559C ; Attributes: bp-based frame
.text$mn:0000559C
.text$mn:0000559C ; int __stdcall std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(struct std::_Container_base12 *)
.text$mn:0000559C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000559C ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000559C                                         ; DATA XREF: .xdata$x:0000DD10o
.text$mn:0000559C
.text$mn:0000559C var_10          = dword ptr -10h
.text$mn:0000559C var_C           = dword ptr -0Ch
.text$mn:0000559C var_4           = dword ptr -4
.text$mn:0000559C arg_0           = dword ptr  8
.text$mn:0000559C
.text$mn:0000559C                 push    ebp
.text$mn:0000559D                 mov     ebp, esp
.text$mn:0000559F                 push    0FFFFFFFFh
.text$mn:000055A1                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000055A6                 mov     eax, large fs:0
.text$mn:000055AC                 push    eax
.text$mn:000055AD                 push    ecx
.text$mn:000055AE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000055B3                 xor     eax, ebp
.text$mn:000055B5                 push    eax
.text$mn:000055B6                 lea     eax, [ebp+var_C]
.text$mn:000055B9                 mov     large fs:0, eax
.text$mn:000055BF                 mov     [ebp+var_10], ecx
.text$mn:000055C2                 mov     eax, [ebp+arg_0]
.text$mn:000055C5                 push    eax             ; struct std::_Container_base12 *
.text$mn:000055C6                 mov     ecx, [ebp+var_10]
.text$mn:000055C9                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(std::_String_val<std::_Simple_types<wchar_t>> const &)
.text$mn:000055CE                 mov     [ebp+var_4], 0
.text$mn:000055D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000055DC                 mov     eax, [ebp+var_10]
.text$mn:000055DF                 mov     ecx, [ebp+var_C]
.text$mn:000055E2                 mov     large fs:0, ecx
.text$mn:000055E9                 pop     ecx
.text$mn:000055EA                 mov     esp, ebp
.text$mn:000055EC                 pop     ebp
.text$mn:000055ED                 retn    4
.text$mn:000055ED ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:000055ED
.text$mn:000055ED _text$mn        ends
.text$mn:000055ED
.text$x:000055F0 ; ===========================================================================
.text$x:000055F0
.text$x:000055F0 ; Segment type: Pure code
.text$x:000055F0 ; Segment permissions: Read/Execute
.text$x:000055F0 _text$x         segment para public 'CODE' use32
.text$x:000055F0                 assume cs:_text$x
.text$x:000055F0                 ;org 55F0h
.text$x:000055F0 ; COMDAT (pick associative to section at 559C)
.text$x:000055F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000055F0
.text$x:000055F0 ; =============== S U B R O U T I N E =======================================
.text$x:000055F0
.text$x:000055F0
.text$x:000055F0 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000055F0                                         ; DATA XREF: .xdata$x:0000C7C4o
.text$x:000055F0                 mov     ecx, [ebp-10h]
.text$x:000055F3                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:000055F3 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:000055F3
.text$x:000055F8
.text$x:000055F8 ; =============== S U B R O U T I N E =======================================
.text$x:000055F8
.text$x:000055F8
.text$x:000055F8 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:000055F8                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>> const &)+5o
.text$x:000055F8
.text$x:000055F8 arg_4           = dword ptr  8
.text$x:000055F8
.text$x:000055F8                 mov     edx, [esp+arg_4]
.text$x:000055FC                 lea     eax, [edx+0Ch]
.text$x:000055FF                 mov     ecx, [edx-8]
.text$x:00005602                 xor     ecx, eax
.text$x:00005604                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005609                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000560E                 jmp     ___CxxFrameHandler3
.text$x:0000560E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000560E
.text$x:0000560E ; ---------------------------------------------------------------------------
.text$x:00005613                 align 4
.text$x:00005613 _text$x         ends
.text$x:00005613
.text$mn:00005614 ; ===========================================================================
.text$mn:00005614
.text$mn:00005614 ; Segment type: Pure code
.text$mn:00005614 ; Segment permissions: Read/Execute
.text$mn:00005614 _text$mn        segment para public 'CODE' use32
.text$mn:00005614                 assume cs:_text$mn
.text$mn:00005614                 ;org 5614h
.text$mn:00005614 ; COMDAT (pick any)
.text$mn:00005614                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005614
.text$mn:00005614 ; =============== S U B R O U T I N E =======================================
.text$mn:00005614
.text$mn:00005614 ; Attributes: bp-based frame
.text$mn:00005614
.text$mn:00005614 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00005614                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005614 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00005614                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+38p
.text$mn:00005614                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+43p ...
.text$mn:00005614
.text$mn:00005614 var_10          = dword ptr -10h
.text$mn:00005614 var_C           = dword ptr -0Ch
.text$mn:00005614 var_4           = dword ptr -4
.text$mn:00005614
.text$mn:00005614                 push    ebp
.text$mn:00005615                 mov     ebp, esp
.text$mn:00005617                 push    0FFFFFFFFh
.text$mn:00005619                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:0000561E                 mov     eax, large fs:0
.text$mn:00005624                 push    eax
.text$mn:00005625                 push    ecx
.text$mn:00005626                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000562B                 xor     eax, ebp
.text$mn:0000562D                 push    eax
.text$mn:0000562E                 lea     eax, [ebp+var_C]
.text$mn:00005631                 mov     large fs:0, eax
.text$mn:00005637                 mov     [ebp+var_10], ecx
.text$mn:0000563A                 mov     ecx, [ebp+var_10]
.text$mn:0000563D                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00005642                 mov     [ebp+var_4], 0
.text$mn:00005649                 mov     ecx, [ebp+var_10]
.text$mn:0000564C                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00005651                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005658                 mov     eax, [ebp+var_10]
.text$mn:0000565B                 mov     ecx, [ebp+var_C]
.text$mn:0000565E                 mov     large fs:0, ecx
.text$mn:00005665                 pop     ecx
.text$mn:00005666                 mov     esp, ebp
.text$mn:00005668                 pop     ebp
.text$mn:00005669                 retn    4
.text$mn:00005669 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00005669
.text$mn:00005669 _text$mn        ends
.text$mn:00005669
.text$x:0000566C ; ===========================================================================
.text$x:0000566C
.text$x:0000566C ; Segment type: Pure code
.text$x:0000566C ; Segment permissions: Read/Execute
.text$x:0000566C _text$x         segment para public 'CODE' use32
.text$x:0000566C                 assume cs:_text$x
.text$x:0000566C                 ;org 566Ch
.text$x:0000566C ; COMDAT (pick associative to section at 5614)
.text$x:0000566C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000566C
.text$x:0000566C ; =============== S U B R O U T I N E =======================================
.text$x:0000566C
.text$x:0000566C
.text$x:0000566C __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:0000566C                                         ; DATA XREF: .xdata$x:0000C76Co
.text$x:0000566C                 mov     ecx, [ebp-10h]
.text$x:0000566F                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:0000566F __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:0000566F
.text$x:00005674
.text$x:00005674 ; =============== S U B R O U T I N E =======================================
.text$x:00005674
.text$x:00005674
.text$x:00005674 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00005674                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00005674
.text$x:00005674 arg_4           = dword ptr  8
.text$x:00005674
.text$x:00005674                 mov     edx, [esp+arg_4]
.text$x:00005678                 lea     eax, [edx+0Ch]
.text$x:0000567B                 mov     ecx, [edx-8]
.text$x:0000567E                 xor     ecx, eax
.text$x:00005680                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005685                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:0000568A                 jmp     ___CxxFrameHandler3
.text$x:0000568A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:0000568A
.text$x:0000568A ; ---------------------------------------------------------------------------
.text$x:0000568F                 align 10h
.text$x:0000568F _text$x         ends
.text$x:0000568F
.text$mn:00005690 ; ===========================================================================
.text$mn:00005690
.text$mn:00005690 ; Segment type: Pure code
.text$mn:00005690 ; Segment permissions: Read/Execute
.text$mn:00005690 _text$mn        segment para public 'CODE' use32
.text$mn:00005690                 assume cs:_text$mn
.text$mn:00005690                 ;org 5690h
.text$mn:00005690 ; COMDAT (pick any)
.text$mn:00005690                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005690
.text$mn:00005690 ; =============== S U B R O U T I N E =======================================
.text$mn:00005690
.text$mn:00005690 ; Attributes: bp-based frame
.text$mn:00005690
.text$mn:00005690 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00005690                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00005690 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00005690                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00005690
.text$mn:00005690 var_10          = dword ptr -10h
.text$mn:00005690 var_C           = dword ptr -0Ch
.text$mn:00005690 var_4           = dword ptr -4
.text$mn:00005690
.text$mn:00005690                 push    ebp
.text$mn:00005691                 mov     ebp, esp
.text$mn:00005693                 push    0FFFFFFFFh
.text$mn:00005695                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000569A                 mov     eax, large fs:0
.text$mn:000056A0                 push    eax
.text$mn:000056A1                 push    ecx
.text$mn:000056A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000056A7                 xor     eax, ebp
.text$mn:000056A9                 push    eax
.text$mn:000056AA                 lea     eax, [ebp+var_C]
.text$mn:000056AD                 mov     large fs:0, eax
.text$mn:000056B3                 mov     [ebp+var_10], ecx
.text$mn:000056B6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000056B9                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000056BE                 mov     [ebp+var_4], 0
.text$mn:000056C5                 mov     eax, [ebp+var_10]
.text$mn:000056C8                 mov     dword ptr [eax+14h], 0
.text$mn:000056CF                 mov     ecx, [ebp+var_10]
.text$mn:000056D2                 mov     dword ptr [ecx+18h], 0
.text$mn:000056D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000056E0                 mov     eax, [ebp+var_10]
.text$mn:000056E3                 mov     ecx, [ebp+var_C]
.text$mn:000056E6                 mov     large fs:0, ecx
.text$mn:000056ED                 pop     ecx
.text$mn:000056EE                 mov     esp, ebp
.text$mn:000056F0                 pop     ebp
.text$mn:000056F1                 retn
.text$mn:000056F1 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000056F1
.text$mn:000056F1 ; ---------------------------------------------------------------------------
.text$mn:000056F2                 align 4
.text$mn:000056F2 _text$mn        ends
.text$mn:000056F2
.text$x:000056F4 ; ===========================================================================
.text$x:000056F4
.text$x:000056F4 ; Segment type: Pure code
.text$x:000056F4 ; Segment permissions: Read/Execute
.text$x:000056F4 _text$x         segment para public 'CODE' use32
.text$x:000056F4                 assume cs:_text$x
.text$x:000056F4                 ;org 56F4h
.text$x:000056F4 ; COMDAT (pick associative to section at 5690)
.text$x:000056F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000056F4
.text$x:000056F4 ; =============== S U B R O U T I N E =======================================
.text$x:000056F4
.text$x:000056F4
.text$x:000056F4 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000056F4                                         ; DATA XREF: .xdata$x:0000C3C8o
.text$x:000056F4                 mov     ecx, [ebp-10h]  ; this
.text$x:000056F7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000056F7 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000056F7
.text$x:000056FC
.text$x:000056FC ; =============== S U B R O U T I N E =======================================
.text$x:000056FC
.text$x:000056FC
.text$x:000056FC __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000056FC                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000056FC
.text$x:000056FC arg_4           = dword ptr  8
.text$x:000056FC
.text$x:000056FC                 mov     edx, [esp+arg_4]
.text$x:00005700                 lea     eax, [edx+0Ch]
.text$x:00005703                 mov     ecx, [edx-8]
.text$x:00005706                 xor     ecx, eax
.text$x:00005708                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000570D                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00005712                 jmp     ___CxxFrameHandler3
.text$x:00005712 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00005712
.text$x:00005712 ; ---------------------------------------------------------------------------
.text$x:00005717                 align 4
.text$x:00005717 _text$x         ends
.text$x:00005717
.text$mn:00005718 ; ===========================================================================
.text$mn:00005718
.text$mn:00005718 ; Segment type: Pure code
.text$mn:00005718 ; Segment permissions: Read/Execute
.text$mn:00005718 _text$mn        segment para public 'CODE' use32
.text$mn:00005718                 assume cs:_text$mn
.text$mn:00005718                 ;org 5718h
.text$mn:00005718 ; COMDAT (pick any)
.text$mn:00005718                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005718
.text$mn:00005718 ; =============== S U B R O U T I N E =======================================
.text$mn:00005718
.text$mn:00005718 ; Attributes: bp-based frame
.text$mn:00005718
.text$mn:00005718 ; int __stdcall std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(struct std::_Container_base12 *)
.text$mn:00005718                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z
.text$mn:00005718 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005718                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>> const &)+2Dp
.text$mn:00005718                                         ; DATA XREF: .xdata$x:0000DD68o
.text$mn:00005718
.text$mn:00005718 var_10          = dword ptr -10h
.text$mn:00005718 var_C           = dword ptr -0Ch
.text$mn:00005718 var_4           = dword ptr -4
.text$mn:00005718 arg_0           = dword ptr  8
.text$mn:00005718
.text$mn:00005718                 push    ebp
.text$mn:00005719                 mov     ebp, esp
.text$mn:0000571B                 push    0FFFFFFFFh
.text$mn:0000571D                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z
.text$mn:00005722                 mov     eax, large fs:0
.text$mn:00005728                 push    eax
.text$mn:00005729                 push    ecx
.text$mn:0000572A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000572F                 xor     eax, ebp
.text$mn:00005731                 push    eax
.text$mn:00005732                 lea     eax, [ebp+var_C]
.text$mn:00005735                 mov     large fs:0, eax
.text$mn:0000573B                 mov     [ebp+var_10], ecx
.text$mn:0000573E                 mov     eax, [ebp+arg_0]
.text$mn:00005741                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005742                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005745                 call    ??0_Container_base12@std@@QAE@ABU01@@Z ; std::_Container_base12::_Container_base12(std::_Container_base12 const &)
.text$mn:0000574A                 mov     [ebp+var_4], 0
.text$mn:00005751                 mov     ecx, [ebp+arg_0]
.text$mn:00005754                 add     ecx, 4
.text$mn:00005757                 mov     edx, [ebp+var_10]
.text$mn:0000575A                 add     edx, 4
.text$mn:0000575D                 mov     eax, [ecx]
.text$mn:0000575F                 mov     [edx], eax
.text$mn:00005761                 mov     eax, [ecx+4]
.text$mn:00005764                 mov     [edx+4], eax
.text$mn:00005767                 mov     eax, [ecx+8]
.text$mn:0000576A                 mov     [edx+8], eax
.text$mn:0000576D                 mov     ecx, [ecx+0Ch]
.text$mn:00005770                 mov     [edx+0Ch], ecx
.text$mn:00005773                 mov     edx, [ebp+var_10]
.text$mn:00005776                 mov     eax, [ebp+arg_0]
.text$mn:00005779                 mov     ecx, [eax+14h]
.text$mn:0000577C                 mov     [edx+14h], ecx
.text$mn:0000577F                 mov     edx, [ebp+var_10]
.text$mn:00005782                 mov     eax, [ebp+arg_0]
.text$mn:00005785                 mov     ecx, [eax+18h]
.text$mn:00005788                 mov     [edx+18h], ecx
.text$mn:0000578B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005792                 mov     eax, [ebp+var_10]
.text$mn:00005795                 mov     ecx, [ebp+var_C]
.text$mn:00005798                 mov     large fs:0, ecx
.text$mn:0000579F                 pop     ecx
.text$mn:000057A0                 mov     esp, ebp
.text$mn:000057A2                 pop     ebp
.text$mn:000057A3                 retn    4
.text$mn:000057A3 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z endp
.text$mn:000057A3
.text$mn:000057A3 ; ---------------------------------------------------------------------------
.text$mn:000057A6                 align 4
.text$mn:000057A6 _text$mn        ends
.text$mn:000057A6
.text$x:000057A8 ; ===========================================================================
.text$x:000057A8
.text$x:000057A8 ; Segment type: Pure code
.text$x:000057A8 ; Segment permissions: Read/Execute
.text$x:000057A8 _text$x         segment para public 'CODE' use32
.text$x:000057A8                 assume cs:_text$x
.text$x:000057A8                 ;org 57A8h
.text$x:000057A8 ; COMDAT (pick associative to section at 5718)
.text$x:000057A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000057A8
.text$x:000057A8 ; =============== S U B R O U T I N E =======================================
.text$x:000057A8
.text$x:000057A8
.text$x:000057A8 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000057A8                                         ; DATA XREF: .xdata$x:0000C740o
.text$x:000057A8                 mov     ecx, [ebp-10h]  ; this
.text$x:000057AB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000057AB __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:000057AB
.text$x:000057B0
.text$x:000057B0 ; =============== S U B R O U T I N E =======================================
.text$x:000057B0
.text$x:000057B0
.text$x:000057B0 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z proc near
.text$x:000057B0                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(std::_String_val<std::_Simple_types<wchar_t>> const &)+5o
.text$x:000057B0
.text$x:000057B0 arg_4           = dword ptr  8
.text$x:000057B0
.text$x:000057B0                 mov     edx, [esp+arg_4]
.text$x:000057B4                 lea     eax, [edx+0Ch]
.text$x:000057B7                 mov     ecx, [edx-8]
.text$x:000057BA                 xor     ecx, eax
.text$x:000057BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000057C1                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z
.text$x:000057C6                 jmp     ___CxxFrameHandler3
.text$x:000057C6 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z endp
.text$x:000057C6
.text$x:000057C6 ; ---------------------------------------------------------------------------
.text$x:000057CB                 align 4
.text$x:000057CB _text$x         ends
.text$x:000057CB
.text$mn:000057CC ; ===========================================================================
.text$mn:000057CC
.text$mn:000057CC ; Segment type: Pure code
.text$mn:000057CC ; Segment permissions: Read/Execute
.text$mn:000057CC _text$mn        segment para public 'CODE' use32
.text$mn:000057CC                 assume cs:_text$mn
.text$mn:000057CC                 ;org 57CCh
.text$mn:000057CC ; COMDAT (pick any)
.text$mn:000057CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000057CC
.text$mn:000057CC ; =============== S U B R O U T I N E =======================================
.text$mn:000057CC
.text$mn:000057CC ; Attributes: bp-based frame
.text$mn:000057CC
.text$mn:000057CC ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:000057CC                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000057CC ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:000057CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:000057CC
.text$mn:000057CC var_10          = dword ptr -10h
.text$mn:000057CC var_C           = dword ptr -0Ch
.text$mn:000057CC var_4           = dword ptr -4
.text$mn:000057CC
.text$mn:000057CC                 push    ebp
.text$mn:000057CD                 mov     ebp, esp
.text$mn:000057CF                 push    0FFFFFFFFh
.text$mn:000057D1                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000057D6                 mov     eax, large fs:0
.text$mn:000057DC                 push    eax
.text$mn:000057DD                 push    ecx
.text$mn:000057DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000057E3                 xor     eax, ebp
.text$mn:000057E5                 push    eax
.text$mn:000057E6                 lea     eax, [ebp+var_C]
.text$mn:000057E9                 mov     large fs:0, eax
.text$mn:000057EF                 mov     [ebp+var_10], ecx
.text$mn:000057F2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000057F5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000057FA                 mov     [ebp+var_4], 0
.text$mn:00005801                 mov     eax, [ebp+var_10]
.text$mn:00005804                 mov     dword ptr [eax+14h], 0
.text$mn:0000580B                 mov     ecx, [ebp+var_10]
.text$mn:0000580E                 mov     dword ptr [ecx+18h], 0
.text$mn:00005815                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000581C                 mov     eax, [ebp+var_10]
.text$mn:0000581F                 mov     ecx, [ebp+var_C]
.text$mn:00005822                 mov     large fs:0, ecx
.text$mn:00005829                 pop     ecx
.text$mn:0000582A                 mov     esp, ebp
.text$mn:0000582C                 pop     ebp
.text$mn:0000582D                 retn
.text$mn:0000582D ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:0000582D
.text$mn:0000582D ; ---------------------------------------------------------------------------
.text$mn:0000582E                 align 10h
.text$mn:0000582E _text$mn        ends
.text$mn:0000582E
.text$x:00005830 ; ===========================================================================
.text$x:00005830
.text$x:00005830 ; Segment type: Pure code
.text$x:00005830 ; Segment permissions: Read/Execute
.text$x:00005830 _text$x         segment para public 'CODE' use32
.text$x:00005830                 assume cs:_text$x
.text$x:00005830                 ;org 5830h
.text$x:00005830 ; COMDAT (pick associative to section at 57CC)
.text$x:00005830                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005830
.text$x:00005830 ; =============== S U B R O U T I N E =======================================
.text$x:00005830
.text$x:00005830
.text$x:00005830 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00005830                                         ; DATA XREF: .xdata$x:0000C6E8o
.text$x:00005830                 mov     ecx, [ebp-10h]  ; this
.text$x:00005833                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005833 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00005833
.text$x:00005838
.text$x:00005838 ; =============== S U B R O U T I N E =======================================
.text$x:00005838
.text$x:00005838
.text$x:00005838 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00005838                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00005838
.text$x:00005838 arg_4           = dword ptr  8
.text$x:00005838
.text$x:00005838                 mov     edx, [esp+arg_4]
.text$x:0000583C                 lea     eax, [edx+0Ch]
.text$x:0000583F                 mov     ecx, [edx-8]
.text$x:00005842                 xor     ecx, eax
.text$x:00005844                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005849                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000584E                 jmp     ___CxxFrameHandler3
.text$x:0000584E __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000584E
.text$x:0000584E ; ---------------------------------------------------------------------------
.text$x:00005853                 align 4
.text$x:00005853 _text$x         ends
.text$x:00005853
.text$mn:00005854 ; ===========================================================================
.text$mn:00005854
.text$mn:00005854 ; Segment type: Pure code
.text$mn:00005854 ; Segment permissions: Read/Execute
.text$mn:00005854 _text$mn        segment para public 'CODE' use32
.text$mn:00005854                 assume cs:_text$mn
.text$mn:00005854                 ;org 5854h
.text$mn:00005854 ; COMDAT (pick any)
.text$mn:00005854                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005854
.text$mn:00005854 ; =============== S U B R O U T I N E =======================================
.text$mn:00005854
.text$mn:00005854 ; Attributes: bp-based frame
.text$mn:00005854
.text$mn:00005854 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>> const &)
.text$mn:00005854                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.text$mn:00005854 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z proc near
.text$mn:00005854                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+34p
.text$mn:00005854
.text$mn:00005854 var_10          = dword ptr -10h
.text$mn:00005854 var_C           = dword ptr -0Ch
.text$mn:00005854 var_4           = dword ptr -4
.text$mn:00005854
.text$mn:00005854                 push    ebp
.text$mn:00005855                 mov     ebp, esp
.text$mn:00005857                 push    0FFFFFFFFh
.text$mn:00005859                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.text$mn:0000585E                 mov     eax, large fs:0
.text$mn:00005864                 push    eax
.text$mn:00005865                 push    ecx
.text$mn:00005866                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000586B                 xor     eax, ebp
.text$mn:0000586D                 push    eax
.text$mn:0000586E                 lea     eax, [ebp+var_C]
.text$mn:00005871                 mov     large fs:0, eax
.text$mn:00005877                 mov     [ebp+var_10], ecx
.text$mn:0000587A                 mov     ecx, [ebp+var_10]
.text$mn:0000587D                 call    ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00005882                 mov     [ebp+var_4], 0
.text$mn:00005889                 mov     ecx, [ebp+var_10]
.text$mn:0000588C                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Alloc_proxy(void)
.text$mn:00005891                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005898                 mov     eax, [ebp+var_10]
.text$mn:0000589B                 mov     ecx, [ebp+var_C]
.text$mn:0000589E                 mov     large fs:0, ecx
.text$mn:000058A5                 pop     ecx
.text$mn:000058A6                 mov     esp, ebp
.text$mn:000058A8                 pop     ebp
.text$mn:000058A9                 retn    4
.text$mn:000058A9 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z endp
.text$mn:000058A9
.text$mn:000058A9 _text$mn        ends
.text$mn:000058A9
.text$x:000058AC ; ===========================================================================
.text$x:000058AC
.text$x:000058AC ; Segment type: Pure code
.text$x:000058AC ; Segment permissions: Read/Execute
.text$x:000058AC _text$x         segment para public 'CODE' use32
.text$x:000058AC                 assume cs:_text$x
.text$x:000058AC                 ;org 58ACh
.text$x:000058AC ; COMDAT (pick associative to section at 5854)
.text$x:000058AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000058AC
.text$x:000058AC ; =============== S U B R O U T I N E =======================================
.text$x:000058AC
.text$x:000058AC
.text$x:000058AC __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0 proc near
.text$x:000058AC                                         ; DATA XREF: .xdata$x:0000CBF0o
.text$x:000058AC                 mov     ecx, [ebp-10h]
.text$x:000058AF                 jmp     ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:000058AF __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0 endp
.text$x:000058AF
.text$x:000058B4
.text$x:000058B4 ; =============== S U B R O U T I N E =======================================
.text$x:000058B4
.text$x:000058B4
.text$x:000058B4 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z proc near
.text$x:000058B4                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+5o
.text$x:000058B4
.text$x:000058B4 arg_4           = dword ptr  8
.text$x:000058B4
.text$x:000058B4                 mov     edx, [esp+arg_4]
.text$x:000058B8                 lea     eax, [edx+0Ch]
.text$x:000058BB                 mov     ecx, [edx-8]
.text$x:000058BE                 xor     ecx, eax
.text$x:000058C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000058C5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.text$x:000058CA                 jmp     ___CxxFrameHandler3
.text$x:000058CA __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z endp
.text$x:000058CA
.text$x:000058CA ; ---------------------------------------------------------------------------
.text$x:000058CF                 align 10h
.text$x:000058CF _text$x         ends
.text$x:000058CF
.text$mn:000058D0 ; ===========================================================================
.text$mn:000058D0
.text$mn:000058D0 ; Segment type: Pure code
.text$mn:000058D0 ; Segment permissions: Read/Execute
.text$mn:000058D0 _text$mn        segment para public 'CODE' use32
.text$mn:000058D0                 assume cs:_text$mn
.text$mn:000058D0                 ;org 58D0h
.text$mn:000058D0 ; COMDAT (pick any)
.text$mn:000058D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000058D0
.text$mn:000058D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000058D0
.text$mn:000058D0 ; Attributes: bp-based frame
.text$mn:000058D0
.text$mn:000058D0 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:000058D0                 public ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:000058D0 ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000058D0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+29p
.text$mn:000058D0
.text$mn:000058D0 var_10          = dword ptr -10h
.text$mn:000058D0 var_C           = dword ptr -0Ch
.text$mn:000058D0 var_4           = dword ptr -4
.text$mn:000058D0
.text$mn:000058D0                 push    ebp
.text$mn:000058D1                 mov     ebp, esp
.text$mn:000058D3                 push    0FFFFFFFFh
.text$mn:000058D5                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:000058DA                 mov     eax, large fs:0
.text$mn:000058E0                 push    eax
.text$mn:000058E1                 push    ecx
.text$mn:000058E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000058E7                 xor     eax, ebp
.text$mn:000058E9                 push    eax
.text$mn:000058EA                 lea     eax, [ebp+var_C]
.text$mn:000058ED                 mov     large fs:0, eax
.text$mn:000058F3                 mov     [ebp+var_10], ecx
.text$mn:000058F6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000058F9                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000058FE                 mov     [ebp+var_4], 0
.text$mn:00005905                 mov     eax, [ebp+var_10]
.text$mn:00005908                 mov     dword ptr [eax+4], 0
.text$mn:0000590F                 mov     ecx, [ebp+var_10]
.text$mn:00005912                 mov     dword ptr [ecx+8], 0
.text$mn:00005919                 mov     edx, [ebp+var_10]
.text$mn:0000591C                 mov     dword ptr [edx+0Ch], 0
.text$mn:00005923                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000592A                 mov     eax, [ebp+var_10]
.text$mn:0000592D                 mov     ecx, [ebp+var_C]
.text$mn:00005930                 mov     large fs:0, ecx
.text$mn:00005937                 pop     ecx
.text$mn:00005938                 mov     esp, ebp
.text$mn:0000593A                 pop     ebp
.text$mn:0000593B                 retn
.text$mn:0000593B ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000593B
.text$mn:0000593B _text$mn        ends
.text$mn:0000593B
.text$x:0000593C ; ===========================================================================
.text$x:0000593C
.text$x:0000593C ; Segment type: Pure code
.text$x:0000593C ; Segment permissions: Read/Execute
.text$x:0000593C _text$x         segment para public 'CODE' use32
.text$x:0000593C                 assume cs:_text$x
.text$x:0000593C                 ;org 593Ch
.text$x:0000593C ; COMDAT (pick associative to section at 58D0)
.text$x:0000593C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000593C
.text$x:0000593C ; =============== S U B R O U T I N E =======================================
.text$x:0000593C
.text$x:0000593C
.text$x:0000593C __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000593C                                         ; DATA XREF: .xdata$x:0000CB98o
.text$x:0000593C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000593F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000593F __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000593F
.text$x:00005944
.text$x:00005944 ; =============== S U B R O U T I N E =======================================
.text$x:00005944
.text$x:00005944
.text$x:00005944 __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005944                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:00005944
.text$x:00005944 arg_4           = dword ptr  8
.text$x:00005944
.text$x:00005944                 mov     edx, [esp+arg_4]
.text$x:00005948                 lea     eax, [edx+0Ch]
.text$x:0000594B                 mov     ecx, [edx-8]
.text$x:0000594E                 xor     ecx, eax
.text$x:00005950                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005955                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$x:0000595A                 jmp     ___CxxFrameHandler3
.text$x:0000595A __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000595A
.text$x:0000595A ; ---------------------------------------------------------------------------
.text$x:0000595F                 align 10h
.text$x:0000595F _text$x         ends
.text$x:0000595F
.text$mn:00005960 ; ===========================================================================
.text$mn:00005960
.text$mn:00005960 ; Segment type: Pure code
.text$mn:00005960 ; Segment permissions: Read/Execute
.text$mn:00005960 _text$mn        segment para public 'CODE' use32
.text$mn:00005960                 assume cs:_text$mn
.text$mn:00005960                 ;org 5960h
.text$mn:00005960 ; COMDAT (pick any)
.text$mn:00005960                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005960
.text$mn:00005960 ; =============== S U B R O U T I N E =======================================
.text$mn:00005960
.text$mn:00005960 ; Attributes: bp-based frame
.text$mn:00005960
.text$mn:00005960 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00005960                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00005960 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00005960                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00005960
.text$mn:00005960 var_4           = dword ptr -4
.text$mn:00005960
.text$mn:00005960                 push    ebp
.text$mn:00005961                 mov     ebp, esp
.text$mn:00005963                 push    ecx
.text$mn:00005964                 mov     [ebp+var_4], ecx
.text$mn:00005967                 mov     ecx, [ebp+var_4]
.text$mn:0000596A                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000596F                 mov     eax, [ebp+var_4]
.text$mn:00005972                 mov     esp, ebp
.text$mn:00005974                 pop     ebp
.text$mn:00005975                 retn
.text$mn:00005975 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00005975
.text$mn:00005975 ; ---------------------------------------------------------------------------
.text$mn:00005976                 align 4
.text$mn:00005976 _text$mn        ends
.text$mn:00005976
.text$mn:00005978 ; ===========================================================================
.text$mn:00005978
.text$mn:00005978 ; Segment type: Pure code
.text$mn:00005978 ; Segment permissions: Read/Execute
.text$mn:00005978 _text$mn        segment para public 'CODE' use32
.text$mn:00005978                 assume cs:_text$mn
.text$mn:00005978                 ;org 5978h
.text$mn:00005978 ; COMDAT (pick any)
.text$mn:00005978                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005978
.text$mn:00005978 ; =============== S U B R O U T I N E =======================================
.text$mn:00005978
.text$mn:00005978 ; Attributes: bp-based frame
.text$mn:00005978
.text$mn:00005978 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct PluginInfo *>>::_Wrap_alloc<class std::allocator<struct PluginInfo *>>(void)
.text$mn:00005978                 public ??0?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAE@XZ
.text$mn:00005978 ??0?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAE@XZ proc near
.text$mn:00005978                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<PluginInfo *,std::allocator<PluginInfo *>>>::_Getal(void)+Ap
.text$mn:00005978
.text$mn:00005978 var_4           = dword ptr -4
.text$mn:00005978
.text$mn:00005978                 push    ebp
.text$mn:00005979                 mov     ebp, esp
.text$mn:0000597B                 push    ecx
.text$mn:0000597C                 mov     [ebp+var_4], ecx
.text$mn:0000597F                 mov     ecx, [ebp+var_4]
.text$mn:00005982                 call    ??0?$allocator@PAUPluginInfo@@@std@@QAE@XZ ; std::allocator<PluginInfo *>::allocator<PluginInfo *>(void)
.text$mn:00005987                 mov     eax, [ebp+var_4]
.text$mn:0000598A                 mov     esp, ebp
.text$mn:0000598C                 pop     ebp
.text$mn:0000598D                 retn
.text$mn:0000598D ??0?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAE@XZ endp
.text$mn:0000598D
.text$mn:0000598D ; ---------------------------------------------------------------------------
.text$mn:0000598E                 align 10h
.text$mn:0000598E _text$mn        ends
.text$mn:0000598E
.text$mn:00005990 ; ===========================================================================
.text$mn:00005990
.text$mn:00005990 ; Segment type: Pure code
.text$mn:00005990 ; Segment permissions: Read/Execute
.text$mn:00005990 _text$mn        segment para public 'CODE' use32
.text$mn:00005990                 assume cs:_text$mn
.text$mn:00005990                 ;org 5990h
.text$mn:00005990 ; COMDAT (pick any)
.text$mn:00005990                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005990
.text$mn:00005990 ; =============== S U B R O U T I N E =======================================
.text$mn:00005990
.text$mn:00005990 ; Attributes: bp-based frame
.text$mn:00005990
.text$mn:00005990 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class TiXmlDocument *>>::_Wrap_alloc<class std::allocator<class TiXmlDocument *>>(void)
.text$mn:00005990                 public ??0?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAE@XZ
.text$mn:00005990 ??0?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAE@XZ proc near
.text$mn:00005990                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<TiXmlDocument *,std::allocator<TiXmlDocument *>>>::_Getal(void)+Ap
.text$mn:00005990
.text$mn:00005990 var_4           = dword ptr -4
.text$mn:00005990
.text$mn:00005990                 push    ebp
.text$mn:00005991                 mov     ebp, esp
.text$mn:00005993                 push    ecx
.text$mn:00005994                 mov     [ebp+var_4], ecx
.text$mn:00005997                 mov     ecx, [ebp+var_4]
.text$mn:0000599A                 call    ??0?$allocator@PAVTiXmlDocument@@@std@@QAE@XZ ; std::allocator<TiXmlDocument *>::allocator<TiXmlDocument *>(void)
.text$mn:0000599F                 mov     eax, [ebp+var_4]
.text$mn:000059A2                 mov     esp, ebp
.text$mn:000059A4                 pop     ebp
.text$mn:000059A5                 retn
.text$mn:000059A5 ??0?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAE@XZ endp
.text$mn:000059A5
.text$mn:000059A5 ; ---------------------------------------------------------------------------
.text$mn:000059A6                 align 4
.text$mn:000059A6 _text$mn        ends
.text$mn:000059A6
.text$mn:000059A8 ; ===========================================================================
.text$mn:000059A8
.text$mn:000059A8 ; Segment type: Pure code
.text$mn:000059A8 ; Segment permissions: Read/Execute
.text$mn:000059A8 _text$mn        segment para public 'CODE' use32
.text$mn:000059A8                 assume cs:_text$mn
.text$mn:000059A8                 ;org 59A8h
.text$mn:000059A8 ; COMDAT (pick any)
.text$mn:000059A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000059A8
.text$mn:000059A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000059A8
.text$mn:000059A8 ; Attributes: bp-based frame
.text$mn:000059A8
.text$mn:000059A8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>(void)
.text$mn:000059A8                 public ??0?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAE@XZ
.text$mn:000059A8 ??0?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000059A8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>::_Getal(void)+Ap
.text$mn:000059A8
.text$mn:000059A8 var_4           = dword ptr -4
.text$mn:000059A8
.text$mn:000059A8                 push    ebp
.text$mn:000059A9                 mov     ebp, esp
.text$mn:000059AB                 push    ecx
.text$mn:000059AC                 mov     [ebp+var_4], ecx
.text$mn:000059AF                 mov     ecx, [ebp+var_4]
.text$mn:000059B2                 call    ??0?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAE@XZ ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(void)
.text$mn:000059B7                 mov     eax, [ebp+var_4]
.text$mn:000059BA                 mov     esp, ebp
.text$mn:000059BC                 pop     ebp
.text$mn:000059BD                 retn
.text$mn:000059BD ??0?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAE@XZ endp
.text$mn:000059BD
.text$mn:000059BD ; ---------------------------------------------------------------------------
.text$mn:000059BE                 align 10h
.text$mn:000059BE _text$mn        ends
.text$mn:000059BE
.text$mn:000059C0 ; ===========================================================================
.text$mn:000059C0
.text$mn:000059C0 ; Segment type: Pure code
.text$mn:000059C0 ; Segment permissions: Read/Execute
.text$mn:000059C0 _text$mn        segment para public 'CODE' use32
.text$mn:000059C0                 assume cs:_text$mn
.text$mn:000059C0                 ;org 59C0h
.text$mn:000059C0 ; COMDAT (pick any)
.text$mn:000059C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000059C0
.text$mn:000059C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000059C0
.text$mn:000059C0 ; Attributes: bp-based frame
.text$mn:000059C0
.text$mn:000059C0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct PluginCommand>>::_Wrap_alloc<class std::allocator<struct PluginCommand>>(void)
.text$mn:000059C0                 public ??0?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAE@XZ
.text$mn:000059C0 ??0?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAE@XZ proc near
.text$mn:000059C0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<PluginCommand,std::allocator<PluginCommand>>>::_Getal(void)+Ap
.text$mn:000059C0
.text$mn:000059C0 var_4           = dword ptr -4
.text$mn:000059C0
.text$mn:000059C0                 push    ebp
.text$mn:000059C1                 mov     ebp, esp
.text$mn:000059C3                 push    ecx
.text$mn:000059C4                 mov     [ebp+var_4], ecx
.text$mn:000059C7                 mov     ecx, [ebp+var_4]
.text$mn:000059CA                 call    ??0?$allocator@UPluginCommand@@@std@@QAE@XZ ; std::allocator<PluginCommand>::allocator<PluginCommand>(void)
.text$mn:000059CF                 mov     eax, [ebp+var_4]
.text$mn:000059D2                 mov     esp, ebp
.text$mn:000059D4                 pop     ebp
.text$mn:000059D5                 retn
.text$mn:000059D5 ??0?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAE@XZ endp
.text$mn:000059D5
.text$mn:000059D5 ; ---------------------------------------------------------------------------
.text$mn:000059D6                 align 4
.text$mn:000059D6 _text$mn        ends
.text$mn:000059D6
.text$mn:000059D8 ; ===========================================================================
.text$mn:000059D8
.text$mn:000059D8 ; Segment type: Pure code
.text$mn:000059D8 ; Segment permissions: Read/Execute
.text$mn:000059D8 _text$mn        segment para public 'CODE' use32
.text$mn:000059D8                 assume cs:_text$mn
.text$mn:000059D8                 ;org 59D8h
.text$mn:000059D8 ; COMDAT (pick any)
.text$mn:000059D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000059D8
.text$mn:000059D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000059D8
.text$mn:000059D8 ; Attributes: bp-based frame
.text$mn:000059D8
.text$mn:000059D8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:000059D8                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:000059D8 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000059D8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Alloc_proxy(void)+Cp
.text$mn:000059D8                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Free_proxy(void)+Cp
.text$mn:000059D8
.text$mn:000059D8 var_4           = dword ptr -4
.text$mn:000059D8
.text$mn:000059D8                 push    ebp
.text$mn:000059D9                 mov     ebp, esp
.text$mn:000059DB                 push    ecx
.text$mn:000059DC                 mov     [ebp+var_4], ecx
.text$mn:000059DF                 mov     ecx, [ebp+var_4]
.text$mn:000059E2                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000059E7                 mov     eax, [ebp+var_4]
.text$mn:000059EA                 mov     esp, ebp
.text$mn:000059EC                 pop     ebp
.text$mn:000059ED                 retn
.text$mn:000059ED ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:000059ED
.text$mn:000059ED ; ---------------------------------------------------------------------------
.text$mn:000059EE                 align 10h
.text$mn:000059EE _text$mn        ends
.text$mn:000059EE
.text$mn:000059F0 ; ===========================================================================
.text$mn:000059F0
.text$mn:000059F0 ; Segment type: Pure code
.text$mn:000059F0 ; Segment permissions: Read/Execute
.text$mn:000059F0 _text$mn        segment para public 'CODE' use32
.text$mn:000059F0                 assume cs:_text$mn
.text$mn:000059F0                 ;org 59F0h
.text$mn:000059F0 ; COMDAT (pick any)
.text$mn:000059F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000059F0
.text$mn:000059F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000059F0
.text$mn:000059F0 ; Attributes: bp-based frame
.text$mn:000059F0
.text$mn:000059F0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:000059F0                 public ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:000059F0 ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000059F0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)+Ap
.text$mn:000059F0
.text$mn:000059F0 var_4           = dword ptr -4
.text$mn:000059F0
.text$mn:000059F0                 push    ebp
.text$mn:000059F1                 mov     ebp, esp
.text$mn:000059F3                 push    ecx
.text$mn:000059F4                 mov     [ebp+var_4], ecx
.text$mn:000059F7                 mov     ecx, [ebp+var_4]
.text$mn:000059FA                 call    ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void)
.text$mn:000059FF                 mov     eax, [ebp+var_4]
.text$mn:00005A02                 mov     esp, ebp
.text$mn:00005A04                 pop     ebp
.text$mn:00005A05                 retn
.text$mn:00005A05 ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00005A05
.text$mn:00005A05 ; ---------------------------------------------------------------------------
.text$mn:00005A06                 align 4
.text$mn:00005A06 _text$mn        ends
.text$mn:00005A06
.text$mn:00005A08 ; ===========================================================================
.text$mn:00005A08
.text$mn:00005A08 ; Segment type: Pure code
.text$mn:00005A08 ; Segment permissions: Read/Execute
.text$mn:00005A08 _text$mn        segment para public 'CODE' use32
.text$mn:00005A08                 assume cs:_text$mn
.text$mn:00005A08                 ;org 5A08h
.text$mn:00005A08 ; COMDAT (pick any)
.text$mn:00005A08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A08
.text$mn:00005A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A08
.text$mn:00005A08 ; Attributes: bp-based frame
.text$mn:00005A08
.text$mn:00005A08 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>>::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>>(void)
.text$mn:00005A08                 public ??0?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAE@XZ
.text$mn:00005A08 ??0?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAE@XZ proc near
.text$mn:00005A08                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>>::_Getal(void)+Ap
.text$mn:00005A08
.text$mn:00005A08 var_4           = dword ptr -4
.text$mn:00005A08
.text$mn:00005A08                 push    ebp
.text$mn:00005A09                 mov     ebp, esp
.text$mn:00005A0B                 push    ecx
.text$mn:00005A0C                 mov     [ebp+var_4], ecx
.text$mn:00005A0F                 mov     ecx, [ebp+var_4]
.text$mn:00005A12                 call    ??0?$allocator@VPluginCmdShortcut@@@std@@QAE@XZ ; std::allocator<PluginCmdShortcut>::allocator<PluginCmdShortcut>(void)
.text$mn:00005A17                 mov     eax, [ebp+var_4]
.text$mn:00005A1A                 mov     esp, ebp
.text$mn:00005A1C                 pop     ebp
.text$mn:00005A1D                 retn
.text$mn:00005A1D ??0?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAE@XZ endp
.text$mn:00005A1D
.text$mn:00005A1D ; ---------------------------------------------------------------------------
.text$mn:00005A1E                 align 10h
.text$mn:00005A1E _text$mn        ends
.text$mn:00005A1E
.text$mn:00005A20 ; ===========================================================================
.text$mn:00005A20
.text$mn:00005A20 ; Segment type: Pure code
.text$mn:00005A20 ; Segment permissions: Read/Execute
.text$mn:00005A20 _text$mn        segment para public 'CODE' use32
.text$mn:00005A20                 assume cs:_text$mn
.text$mn:00005A20                 ;org 5A20h
.text$mn:00005A20 ; COMDAT (pick any)
.text$mn:00005A20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A20
.text$mn:00005A20 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A20
.text$mn:00005A20 ; Attributes: bp-based frame
.text$mn:00005A20
.text$mn:00005A20 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(class std::allocator<wchar_t> const &)
.text$mn:00005A20                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005A20 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00005A20                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00005A20
.text$mn:00005A20 var_4           = dword ptr -4
.text$mn:00005A20 arg_0           = dword ptr  8
.text$mn:00005A20
.text$mn:00005A20                 push    ebp
.text$mn:00005A21                 mov     ebp, esp
.text$mn:00005A23                 push    ecx
.text$mn:00005A24                 mov     [ebp+var_4], ecx
.text$mn:00005A27                 mov     eax, [ebp+arg_0]
.text$mn:00005A2A                 push    eax
.text$mn:00005A2B                 mov     ecx, [ebp+var_4]
.text$mn:00005A2E                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00005A33                 mov     eax, [ebp+var_4]
.text$mn:00005A36                 mov     esp, ebp
.text$mn:00005A38                 pop     ebp
.text$mn:00005A39                 retn    4
.text$mn:00005A39 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00005A39
.text$mn:00005A39 _text$mn        ends
.text$mn:00005A39
.text$mn:00005A3C ; ===========================================================================
.text$mn:00005A3C
.text$mn:00005A3C ; Segment type: Pure code
.text$mn:00005A3C ; Segment permissions: Read/Execute
.text$mn:00005A3C _text$mn        segment para public 'CODE' use32
.text$mn:00005A3C                 assume cs:_text$mn
.text$mn:00005A3C                 ;org 5A3Ch
.text$mn:00005A3C ; COMDAT (pick any)
.text$mn:00005A3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A3C
.text$mn:00005A3C ; =============== S U B R O U T I N E =======================================
.text$mn:00005A3C
.text$mn:00005A3C ; Attributes: bp-based frame
.text$mn:00005A3C
.text$mn:00005A3C ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00005A3C                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00005A3C ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00005A3C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00005A3C
.text$mn:00005A3C var_4           = dword ptr -4
.text$mn:00005A3C
.text$mn:00005A3C                 push    ebp
.text$mn:00005A3D                 mov     ebp, esp
.text$mn:00005A3F                 push    ecx
.text$mn:00005A40                 mov     [ebp+var_4], ecx
.text$mn:00005A43                 mov     ecx, [ebp+var_4]
.text$mn:00005A46                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005A4B                 mov     eax, [ebp+var_4]
.text$mn:00005A4E                 mov     esp, ebp
.text$mn:00005A50                 pop     ebp
.text$mn:00005A51                 retn
.text$mn:00005A51 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00005A51
.text$mn:00005A51 ; ---------------------------------------------------------------------------
.text$mn:00005A52                 align 4
.text$mn:00005A52 _text$mn        ends
.text$mn:00005A52
.text$mn:00005A54 ; ===========================================================================
.text$mn:00005A54
.text$mn:00005A54 ; Segment type: Pure code
.text$mn:00005A54 ; Segment permissions: Read/Execute
.text$mn:00005A54 _text$mn        segment para public 'CODE' use32
.text$mn:00005A54                 assume cs:_text$mn
.text$mn:00005A54                 ;org 5A54h
.text$mn:00005A54 ; COMDAT (pick any)
.text$mn:00005A54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A54
.text$mn:00005A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A54
.text$mn:00005A54 ; Attributes: bp-based frame
.text$mn:00005A54
.text$mn:00005A54 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00005A54                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00005A54 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00005A54                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00005A54
.text$mn:00005A54 var_4           = dword ptr -4
.text$mn:00005A54
.text$mn:00005A54                 push    ebp
.text$mn:00005A55                 mov     ebp, esp
.text$mn:00005A57                 push    ecx
.text$mn:00005A58                 mov     [ebp+var_4], ecx
.text$mn:00005A5B                 mov     eax, [ebp+var_4]
.text$mn:00005A5E                 mov     esp, ebp
.text$mn:00005A60                 pop     ebp
.text$mn:00005A61                 retn
.text$mn:00005A61 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00005A61
.text$mn:00005A61 ; ---------------------------------------------------------------------------
.text$mn:00005A62                 align 4
.text$mn:00005A62 _text$mn        ends
.text$mn:00005A62
.text$mn:00005A64 ; ===========================================================================
.text$mn:00005A64
.text$mn:00005A64 ; Segment type: Pure code
.text$mn:00005A64 ; Segment permissions: Read/Execute
.text$mn:00005A64 _text$mn        segment para public 'CODE' use32
.text$mn:00005A64                 assume cs:_text$mn
.text$mn:00005A64                 ;org 5A64h
.text$mn:00005A64 ; COMDAT (pick any)
.text$mn:00005A64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A64
.text$mn:00005A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A64
.text$mn:00005A64 ; Attributes: bp-based frame
.text$mn:00005A64
.text$mn:00005A64 ; public: __thiscall std::allocator<struct PluginInfo *>::allocator<struct PluginInfo *>(void)
.text$mn:00005A64                 public ??0?$allocator@PAUPluginInfo@@@std@@QAE@XZ
.text$mn:00005A64 ??0?$allocator@PAUPluginInfo@@@std@@QAE@XZ proc near
.text$mn:00005A64                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginInfo *>>::_Wrap_alloc<std::allocator<PluginInfo *>>(void)+Ap
.text$mn:00005A64
.text$mn:00005A64 var_4           = dword ptr -4
.text$mn:00005A64
.text$mn:00005A64                 push    ebp
.text$mn:00005A65                 mov     ebp, esp
.text$mn:00005A67                 push    ecx
.text$mn:00005A68                 mov     [ebp+var_4], ecx
.text$mn:00005A6B                 mov     eax, [ebp+var_4]
.text$mn:00005A6E                 mov     esp, ebp
.text$mn:00005A70                 pop     ebp
.text$mn:00005A71                 retn
.text$mn:00005A71 ??0?$allocator@PAUPluginInfo@@@std@@QAE@XZ endp
.text$mn:00005A71
.text$mn:00005A71 ; ---------------------------------------------------------------------------
.text$mn:00005A72                 align 4
.text$mn:00005A72 _text$mn        ends
.text$mn:00005A72
.text$mn:00005A74 ; ===========================================================================
.text$mn:00005A74
.text$mn:00005A74 ; Segment type: Pure code
.text$mn:00005A74 ; Segment permissions: Read/Execute
.text$mn:00005A74 _text$mn        segment para public 'CODE' use32
.text$mn:00005A74                 assume cs:_text$mn
.text$mn:00005A74                 ;org 5A74h
.text$mn:00005A74 ; COMDAT (pick any)
.text$mn:00005A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A74
.text$mn:00005A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A74
.text$mn:00005A74 ; Attributes: bp-based frame
.text$mn:00005A74
.text$mn:00005A74 ; public: __thiscall std::allocator<class TiXmlDocument *>::allocator<class TiXmlDocument *>(void)
.text$mn:00005A74                 public ??0?$allocator@PAVTiXmlDocument@@@std@@QAE@XZ
.text$mn:00005A74 ??0?$allocator@PAVTiXmlDocument@@@std@@QAE@XZ proc near
.text$mn:00005A74                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::_Wrap_alloc<std::allocator<TiXmlDocument *>>(void)+Ap
.text$mn:00005A74
.text$mn:00005A74 var_4           = dword ptr -4
.text$mn:00005A74
.text$mn:00005A74                 push    ebp
.text$mn:00005A75                 mov     ebp, esp
.text$mn:00005A77                 push    ecx
.text$mn:00005A78                 mov     [ebp+var_4], ecx
.text$mn:00005A7B                 mov     eax, [ebp+var_4]
.text$mn:00005A7E                 mov     esp, ebp
.text$mn:00005A80                 pop     ebp
.text$mn:00005A81                 retn
.text$mn:00005A81 ??0?$allocator@PAVTiXmlDocument@@@std@@QAE@XZ endp
.text$mn:00005A81
.text$mn:00005A81 ; ---------------------------------------------------------------------------
.text$mn:00005A82                 align 4
.text$mn:00005A82 _text$mn        ends
.text$mn:00005A82
.text$mn:00005A84 ; ===========================================================================
.text$mn:00005A84
.text$mn:00005A84 ; Segment type: Pure code
.text$mn:00005A84 ; Segment permissions: Read/Execute
.text$mn:00005A84 _text$mn        segment para public 'CODE' use32
.text$mn:00005A84                 assume cs:_text$mn
.text$mn:00005A84                 ;org 5A84h
.text$mn:00005A84 ; COMDAT (pick any)
.text$mn:00005A84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A84
.text$mn:00005A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A84
.text$mn:00005A84 ; Attributes: bp-based frame
.text$mn:00005A84
.text$mn:00005A84 ; public: __thiscall std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>(void)
.text$mn:00005A84                 public ??0?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAE@XZ
.text$mn:00005A84 ??0?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAE@XZ proc near
.text$mn:00005A84                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>(void)+Ap
.text$mn:00005A84
.text$mn:00005A84 var_4           = dword ptr -4
.text$mn:00005A84
.text$mn:00005A84                 push    ebp
.text$mn:00005A85                 mov     ebp, esp
.text$mn:00005A87                 push    ecx
.text$mn:00005A88                 mov     [ebp+var_4], ecx
.text$mn:00005A8B                 mov     eax, [ebp+var_4]
.text$mn:00005A8E                 mov     esp, ebp
.text$mn:00005A90                 pop     ebp
.text$mn:00005A91                 retn
.text$mn:00005A91 ??0?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAE@XZ endp
.text$mn:00005A91
.text$mn:00005A91 ; ---------------------------------------------------------------------------
.text$mn:00005A92                 align 4
.text$mn:00005A92 _text$mn        ends
.text$mn:00005A92
.text$mn:00005A94 ; ===========================================================================
.text$mn:00005A94
.text$mn:00005A94 ; Segment type: Pure code
.text$mn:00005A94 ; Segment permissions: Read/Execute
.text$mn:00005A94 _text$mn        segment para public 'CODE' use32
.text$mn:00005A94                 assume cs:_text$mn
.text$mn:00005A94                 ;org 5A94h
.text$mn:00005A94 ; COMDAT (pick any)
.text$mn:00005A94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A94
.text$mn:00005A94 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A94
.text$mn:00005A94 ; Attributes: bp-based frame
.text$mn:00005A94
.text$mn:00005A94 ; public: __thiscall std::allocator<struct PluginCommand>::allocator<struct PluginCommand>(void)
.text$mn:00005A94                 public ??0?$allocator@UPluginCommand@@@std@@QAE@XZ
.text$mn:00005A94 ??0?$allocator@UPluginCommand@@@std@@QAE@XZ proc near
.text$mn:00005A94                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCommand>>::_Wrap_alloc<std::allocator<PluginCommand>>(void)+Ap
.text$mn:00005A94
.text$mn:00005A94 var_4           = dword ptr -4
.text$mn:00005A94
.text$mn:00005A94                 push    ebp
.text$mn:00005A95                 mov     ebp, esp
.text$mn:00005A97                 push    ecx
.text$mn:00005A98                 mov     [ebp+var_4], ecx
.text$mn:00005A9B                 mov     eax, [ebp+var_4]
.text$mn:00005A9E                 mov     esp, ebp
.text$mn:00005AA0                 pop     ebp
.text$mn:00005AA1                 retn
.text$mn:00005AA1 ??0?$allocator@UPluginCommand@@@std@@QAE@XZ endp
.text$mn:00005AA1
.text$mn:00005AA1 ; ---------------------------------------------------------------------------
.text$mn:00005AA2                 align 4
.text$mn:00005AA2 _text$mn        ends
.text$mn:00005AA2
.text$mn:00005AA4 ; ===========================================================================
.text$mn:00005AA4
.text$mn:00005AA4 ; Segment type: Pure code
.text$mn:00005AA4 ; Segment permissions: Read/Execute
.text$mn:00005AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00005AA4                 assume cs:_text$mn
.text$mn:00005AA4                 ;org 5AA4h
.text$mn:00005AA4 ; COMDAT (pick any)
.text$mn:00005AA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AA4
.text$mn:00005AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AA4
.text$mn:00005AA4 ; Attributes: bp-based frame
.text$mn:00005AA4
.text$mn:00005AA4 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00005AA4                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00005AA4 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00005AA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00005AA4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00005AA4
.text$mn:00005AA4 var_4           = dword ptr -4
.text$mn:00005AA4
.text$mn:00005AA4                 push    ebp
.text$mn:00005AA5                 mov     ebp, esp
.text$mn:00005AA7                 push    ecx
.text$mn:00005AA8                 mov     [ebp+var_4], ecx
.text$mn:00005AAB                 mov     eax, [ebp+var_4]
.text$mn:00005AAE                 mov     esp, ebp
.text$mn:00005AB0                 pop     ebp
.text$mn:00005AB1                 retn
.text$mn:00005AB1 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00005AB1
.text$mn:00005AB1 ; ---------------------------------------------------------------------------
.text$mn:00005AB2                 align 4
.text$mn:00005AB2 _text$mn        ends
.text$mn:00005AB2
.text$mn:00005AB4 ; ===========================================================================
.text$mn:00005AB4
.text$mn:00005AB4 ; Segment type: Pure code
.text$mn:00005AB4 ; Segment permissions: Read/Execute
.text$mn:00005AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00005AB4                 assume cs:_text$mn
.text$mn:00005AB4                 ;org 5AB4h
.text$mn:00005AB4 ; COMDAT (pick any)
.text$mn:00005AB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AB4
.text$mn:00005AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AB4
.text$mn:00005AB4 ; Attributes: bp-based frame
.text$mn:00005AB4
.text$mn:00005AB4 ; public: __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(void)
.text$mn:00005AB4                 public ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
.text$mn:00005AB4 ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ proc near
.text$mn:00005AB4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+Ap
.text$mn:00005AB4                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+2Bp
.text$mn:00005AB4
.text$mn:00005AB4 var_4           = dword ptr -4
.text$mn:00005AB4
.text$mn:00005AB4                 push    ebp
.text$mn:00005AB5                 mov     ebp, esp
.text$mn:00005AB7                 push    ecx
.text$mn:00005AB8                 mov     [ebp+var_4], ecx
.text$mn:00005ABB                 mov     eax, [ebp+var_4]
.text$mn:00005ABE                 mov     esp, ebp
.text$mn:00005AC0                 pop     ebp
.text$mn:00005AC1                 retn
.text$mn:00005AC1 ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ endp
.text$mn:00005AC1
.text$mn:00005AC1 ; ---------------------------------------------------------------------------
.text$mn:00005AC2                 align 4
.text$mn:00005AC2 _text$mn        ends
.text$mn:00005AC2
.text$mn:00005AC4 ; ===========================================================================
.text$mn:00005AC4
.text$mn:00005AC4 ; Segment type: Pure code
.text$mn:00005AC4 ; Segment permissions: Read/Execute
.text$mn:00005AC4 _text$mn        segment para public 'CODE' use32
.text$mn:00005AC4                 assume cs:_text$mn
.text$mn:00005AC4                 ;org 5AC4h
.text$mn:00005AC4 ; COMDAT (pick any)
.text$mn:00005AC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AC4
.text$mn:00005AC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AC4
.text$mn:00005AC4 ; Attributes: bp-based frame
.text$mn:00005AC4
.text$mn:00005AC4 ; public: __thiscall std::allocator<class PluginCmdShortcut>::allocator<class PluginCmdShortcut>(void)
.text$mn:00005AC4                 public ??0?$allocator@VPluginCmdShortcut@@@std@@QAE@XZ
.text$mn:00005AC4 ??0?$allocator@VPluginCmdShortcut@@@std@@QAE@XZ proc near
.text$mn:00005AC4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::_Wrap_alloc<std::allocator<PluginCmdShortcut>>(void)+Ap
.text$mn:00005AC4
.text$mn:00005AC4 var_4           = dword ptr -4
.text$mn:00005AC4
.text$mn:00005AC4                 push    ebp
.text$mn:00005AC5                 mov     ebp, esp
.text$mn:00005AC7                 push    ecx
.text$mn:00005AC8                 mov     [ebp+var_4], ecx
.text$mn:00005ACB                 mov     eax, [ebp+var_4]
.text$mn:00005ACE                 mov     esp, ebp
.text$mn:00005AD0                 pop     ebp
.text$mn:00005AD1                 retn
.text$mn:00005AD1 ??0?$allocator@VPluginCmdShortcut@@@std@@QAE@XZ endp
.text$mn:00005AD1
.text$mn:00005AD1 ; ---------------------------------------------------------------------------
.text$mn:00005AD2                 align 4
.text$mn:00005AD2 _text$mn        ends
.text$mn:00005AD2
.text$mn:00005AD4 ; ===========================================================================
.text$mn:00005AD4
.text$mn:00005AD4 ; Segment type: Pure code
.text$mn:00005AD4 ; Segment permissions: Read/Execute
.text$mn:00005AD4 _text$mn        segment para public 'CODE' use32
.text$mn:00005AD4                 assume cs:_text$mn
.text$mn:00005AD4                 ;org 5AD4h
.text$mn:00005AD4 ; COMDAT (pick any)
.text$mn:00005AD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AD4
.text$mn:00005AD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AD4
.text$mn:00005AD4 ; Attributes: bp-based frame
.text$mn:00005AD4
.text$mn:00005AD4 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:00005AD4                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:00005AD4 ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:00005AD4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)+Ep
.text$mn:00005AD4                                         ; std::allocator<wchar_t>::select_on_container_copy_construction(void)+Ep
.text$mn:00005AD4
.text$mn:00005AD4 var_4           = dword ptr -4
.text$mn:00005AD4
.text$mn:00005AD4                 push    ebp
.text$mn:00005AD5                 mov     ebp, esp
.text$mn:00005AD7                 push    ecx
.text$mn:00005AD8                 mov     [ebp+var_4], ecx
.text$mn:00005ADB                 mov     eax, [ebp+var_4]
.text$mn:00005ADE                 mov     esp, ebp
.text$mn:00005AE0                 pop     ebp
.text$mn:00005AE1                 retn    4
.text$mn:00005AE1 ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:00005AE1
.text$mn:00005AE1 _text$mn        ends
.text$mn:00005AE1
.text$mn:00005AE4 ; ===========================================================================
.text$mn:00005AE4
.text$mn:00005AE4 ; Segment type: Pure code
.text$mn:00005AE4 ; Segment permissions: Read/Execute
.text$mn:00005AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00005AE4                 assume cs:_text$mn
.text$mn:00005AE4                 ;org 5AE4h
.text$mn:00005AE4 ; COMDAT (pick any)
.text$mn:00005AE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AE4
.text$mn:00005AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AE4
.text$mn:00005AE4 ; Attributes: bp-based frame
.text$mn:00005AE4
.text$mn:00005AE4 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005AE4                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00005AE4 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00005AE4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp ...
.text$mn:00005AE4
.text$mn:00005AE4 var_4           = dword ptr -4
.text$mn:00005AE4
.text$mn:00005AE4                 push    ebp
.text$mn:00005AE5                 mov     ebp, esp
.text$mn:00005AE7                 push    ecx
.text$mn:00005AE8                 mov     [ebp+var_4], ecx
.text$mn:00005AEB                 mov     eax, [ebp+var_4]
.text$mn:00005AEE                 mov     esp, ebp
.text$mn:00005AF0                 pop     ebp
.text$mn:00005AF1                 retn
.text$mn:00005AF1 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00005AF1
.text$mn:00005AF1 ; ---------------------------------------------------------------------------
.text$mn:00005AF2                 align 4
.text$mn:00005AF2 _text$mn        ends
.text$mn:00005AF2
.text$mn:00005AF4 ; ===========================================================================
.text$mn:00005AF4
.text$mn:00005AF4 ; Segment type: Pure code
.text$mn:00005AF4 ; Segment permissions: Read/Execute
.text$mn:00005AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00005AF4                 assume cs:_text$mn
.text$mn:00005AF4                 ;org 5AF4h
.text$mn:00005AF4 ; COMDAT (pick any)
.text$mn:00005AF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AF4
.text$mn:00005AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AF4
.text$mn:00005AF4 ; Attributes: bp-based frame
.text$mn:00005AF4
.text$mn:00005AF4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00005AF4                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00005AF4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00005AF4                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00005AF4                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00005AF4
.text$mn:00005AF4 var_14          = dword ptr -14h
.text$mn:00005AF4 var_D           = byte ptr -0Dh
.text$mn:00005AF4 var_C           = dword ptr -0Ch
.text$mn:00005AF4 var_4           = dword ptr -4
.text$mn:00005AF4 Str             = dword ptr  8
.text$mn:00005AF4
.text$mn:00005AF4                 push    ebp
.text$mn:00005AF5                 mov     ebp, esp
.text$mn:00005AF7                 push    0FFFFFFFFh
.text$mn:00005AF9                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00005AFE                 mov     eax, large fs:0
.text$mn:00005B04                 push    eax
.text$mn:00005B05                 sub     esp, 8
.text$mn:00005B08                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005B0D                 xor     eax, ebp
.text$mn:00005B0F                 push    eax
.text$mn:00005B10                 lea     eax, [ebp+var_C]
.text$mn:00005B13                 mov     large fs:0, eax
.text$mn:00005B19                 mov     [ebp+var_14], ecx
.text$mn:00005B1C                 lea     ecx, [ebp+var_D]
.text$mn:00005B1F                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00005B24                 push    eax
.text$mn:00005B25                 mov     ecx, [ebp+var_14]
.text$mn:00005B28                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00005B2D                 mov     [ebp+var_4], 0
.text$mn:00005B34                 push    0               ; Size
.text$mn:00005B36                 push    0               ; char
.text$mn:00005B38                 mov     ecx, [ebp+var_14]
.text$mn:00005B3B                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00005B40                 mov     eax, [ebp+Str]
.text$mn:00005B43                 push    eax             ; Str
.text$mn:00005B44                 mov     ecx, [ebp+var_14]
.text$mn:00005B47                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00005B4C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005B53                 mov     eax, [ebp+var_14]
.text$mn:00005B56                 mov     ecx, [ebp+var_C]
.text$mn:00005B59                 mov     large fs:0, ecx
.text$mn:00005B60                 pop     ecx
.text$mn:00005B61                 mov     esp, ebp
.text$mn:00005B63                 pop     ebp
.text$mn:00005B64                 retn    4
.text$mn:00005B64 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00005B64
.text$mn:00005B64 ; ---------------------------------------------------------------------------
.text$mn:00005B67                 align 4
.text$mn:00005B67 _text$mn        ends
.text$mn:00005B67
.text$x:00005B68 ; ===========================================================================
.text$x:00005B68
.text$x:00005B68 ; Segment type: Pure code
.text$x:00005B68 ; Segment permissions: Read/Execute
.text$x:00005B68 _text$x         segment para public 'CODE' use32
.text$x:00005B68                 assume cs:_text$x
.text$x:00005B68                 ;org 5B68h
.text$x:00005B68 ; COMDAT (pick associative to section at 5AF4)
.text$x:00005B68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005B68
.text$x:00005B68 ; =============== S U B R O U T I N E =======================================
.text$x:00005B68
.text$x:00005B68
.text$x:00005B68 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00005B68                                         ; DATA XREF: .xdata$x:0000C478o
.text$x:00005B68                 mov     ecx, [ebp-14h]
.text$x:00005B6B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00005B6B __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00005B6B
.text$x:00005B70
.text$x:00005B70 ; =============== S U B R O U T I N E =======================================
.text$x:00005B70
.text$x:00005B70
.text$x:00005B70 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00005B70                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00005B70
.text$x:00005B70 arg_4           = dword ptr  8
.text$x:00005B70
.text$x:00005B70                 mov     edx, [esp+arg_4]
.text$x:00005B74                 lea     eax, [edx+0Ch]
.text$x:00005B77                 mov     ecx, [edx-0Ch]
.text$x:00005B7A                 xor     ecx, eax
.text$x:00005B7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B81                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00005B86                 jmp     ___CxxFrameHandler3
.text$x:00005B86 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00005B86
.text$x:00005B86 ; ---------------------------------------------------------------------------
.text$x:00005B8B                 align 4
.text$x:00005B8B _text$x         ends
.text$x:00005B8B
.text$mn:00005B8C ; ===========================================================================
.text$mn:00005B8C
.text$mn:00005B8C ; Segment type: Pure code
.text$mn:00005B8C ; Segment permissions: Read/Execute
.text$mn:00005B8C _text$mn        segment para public 'CODE' use32
.text$mn:00005B8C                 assume cs:_text$mn
.text$mn:00005B8C                 ;org 5B8Ch
.text$mn:00005B8C ; COMDAT (pick any)
.text$mn:00005B8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B8C
.text$mn:00005B8C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B8C
.text$mn:00005B8C ; Attributes: bp-based frame
.text$mn:00005B8C
.text$mn:00005B8C ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:00005B8C                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$mn:00005B8C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z proc near
.text$mn:00005B8C                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+143p
.text$mn:00005B8C                                         ; PluginsManager::loadPlugins(wchar_t const *)+277p ...
.text$mn:00005B8C
.text$mn:00005B8C var_14          = dword ptr -14h
.text$mn:00005B8C var_D           = byte ptr -0Dh
.text$mn:00005B8C var_C           = dword ptr -0Ch
.text$mn:00005B8C var_4           = dword ptr -4
.text$mn:00005B8C arg_0           = dword ptr  8
.text$mn:00005B8C
.text$mn:00005B8C                 push    ebp
.text$mn:00005B8D                 mov     ebp, esp
.text$mn:00005B8F                 push    0FFFFFFFFh
.text$mn:00005B91                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$mn:00005B96                 mov     eax, large fs:0
.text$mn:00005B9C                 push    eax
.text$mn:00005B9D                 sub     esp, 8
.text$mn:00005BA0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005BA5                 xor     eax, ebp
.text$mn:00005BA7                 push    eax
.text$mn:00005BA8                 lea     eax, [ebp+var_C]
.text$mn:00005BAB                 mov     large fs:0, eax
.text$mn:00005BB1                 mov     [ebp+var_14], ecx
.text$mn:00005BB4                 lea     eax, [ebp+var_D]
.text$mn:00005BB7                 push    eax
.text$mn:00005BB8                 mov     ecx, [ebp+arg_0]
.text$mn:00005BBB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00005BC0                 push    eax
.text$mn:00005BC1                 mov     ecx, [ebp+var_14]
.text$mn:00005BC4                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00005BC9                 mov     [ebp+var_4], 0
.text$mn:00005BD0                 push    0
.text$mn:00005BD2                 push    0
.text$mn:00005BD4                 mov     ecx, [ebp+var_14]
.text$mn:00005BD7                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00005BDC                 mov     ecx, [ebp+arg_0]
.text$mn:00005BDF                 push    ecx
.text$mn:00005BE0                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00005BE5                 add     esp, 4
.text$mn:00005BE8                 push    eax
.text$mn:00005BE9                 mov     ecx, [ebp+var_14]
.text$mn:00005BEC                 call    ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00005BF1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005BF8                 mov     eax, [ebp+var_14]
.text$mn:00005BFB                 mov     ecx, [ebp+var_C]
.text$mn:00005BFE                 mov     large fs:0, ecx
.text$mn:00005C05                 pop     ecx
.text$mn:00005C06                 mov     esp, ebp
.text$mn:00005C08                 pop     ebp
.text$mn:00005C09                 retn    4
.text$mn:00005C09 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z endp
.text$mn:00005C09
.text$mn:00005C09 _text$mn        ends
.text$mn:00005C09
.text$x:00005C0C ; ===========================================================================
.text$x:00005C0C
.text$x:00005C0C ; Segment type: Pure code
.text$x:00005C0C ; Segment permissions: Read/Execute
.text$x:00005C0C _text$x         segment para public 'CODE' use32
.text$x:00005C0C                 assume cs:_text$x
.text$x:00005C0C                 ;org 5C0Ch
.text$x:00005C0C ; COMDAT (pick associative to section at 5B8C)
.text$x:00005C0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005C0C
.text$x:00005C0C ; =============== S U B R O U T I N E =======================================
.text$x:00005C0C
.text$x:00005C0C
.text$x:00005C0C __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:00005C0C                                         ; DATA XREF: .xdata$x:0000C874o
.text$x:00005C0C                 mov     ecx, [ebp-14h]
.text$x:00005C0F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00005C0F __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:00005C0F
.text$x:00005C14
.text$x:00005C14 ; =============== S U B R O U T I N E =======================================
.text$x:00005C14
.text$x:00005C14
.text$x:00005C14 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z proc near
.text$x:00005C14                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5o
.text$x:00005C14
.text$x:00005C14 arg_4           = dword ptr  8
.text$x:00005C14
.text$x:00005C14                 mov     edx, [esp+arg_4]
.text$x:00005C18                 lea     eax, [edx+0Ch]
.text$x:00005C1B                 mov     ecx, [edx-0Ch]
.text$x:00005C1E                 xor     ecx, eax
.text$x:00005C20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005C25                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$x:00005C2A                 jmp     ___CxxFrameHandler3
.text$x:00005C2A __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z endp
.text$x:00005C2A
.text$x:00005C2A ; ---------------------------------------------------------------------------
.text$x:00005C2F                 align 10h
.text$x:00005C2F _text$x         ends
.text$x:00005C2F
.text$mn:00005C30 ; ===========================================================================
.text$mn:00005C30
.text$mn:00005C30 ; Segment type: Pure code
.text$mn:00005C30 ; Segment permissions: Read/Execute
.text$mn:00005C30 _text$mn        segment para public 'CODE' use32
.text$mn:00005C30                 assume cs:_text$mn
.text$mn:00005C30                 ;org 5C30h
.text$mn:00005C30 ; COMDAT (pick any)
.text$mn:00005C30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C30
.text$mn:00005C30 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C30
.text$mn:00005C30 ; Attributes: bp-based frame
.text$mn:00005C30
.text$mn:00005C30 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00005C30                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00005C30 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:00005C30                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+769p
.text$mn:00005C30                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+8C7p ...
.text$mn:00005C30
.text$mn:00005C30 var_14          = dword ptr -14h
.text$mn:00005C30 var_E           = byte ptr -0Eh
.text$mn:00005C30 var_D           = byte ptr -0Dh
.text$mn:00005C30 var_C           = dword ptr -0Ch
.text$mn:00005C30 var_4           = dword ptr -4
.text$mn:00005C30 arg_0           = dword ptr  8
.text$mn:00005C30
.text$mn:00005C30                 push    ebp
.text$mn:00005C31                 mov     ebp, esp
.text$mn:00005C33                 push    0FFFFFFFFh
.text$mn:00005C35                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00005C3A                 mov     eax, large fs:0
.text$mn:00005C40                 push    eax
.text$mn:00005C41                 sub     esp, 8
.text$mn:00005C44                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005C49                 xor     eax, ebp
.text$mn:00005C4B                 push    eax
.text$mn:00005C4C                 lea     eax, [ebp+var_C]
.text$mn:00005C4F                 mov     large fs:0, eax
.text$mn:00005C55                 mov     [ebp+var_14], ecx
.text$mn:00005C58                 lea     eax, [ebp+var_D]
.text$mn:00005C5B                 push    eax
.text$mn:00005C5C                 lea     ecx, [ebp+var_E]
.text$mn:00005C5F                 push    ecx
.text$mn:00005C60                 mov     ecx, [ebp+arg_0]
.text$mn:00005C63                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00005C68                 mov     ecx, eax
.text$mn:00005C6A                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)
.text$mn:00005C6F                 push    eax
.text$mn:00005C70                 mov     ecx, [ebp+var_14]
.text$mn:00005C73                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00005C78                 mov     [ebp+var_4], 0
.text$mn:00005C7F                 push    0
.text$mn:00005C81                 push    0
.text$mn:00005C83                 mov     ecx, [ebp+var_14]
.text$mn:00005C86                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00005C8B                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00005C91                 push    edx
.text$mn:00005C92                 push    0
.text$mn:00005C94                 mov     eax, [ebp+arg_0]
.text$mn:00005C97                 push    eax
.text$mn:00005C98                 mov     ecx, [ebp+var_14]
.text$mn:00005C9B                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00005CA0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005CA7                 mov     eax, [ebp+var_14]
.text$mn:00005CAA                 mov     ecx, [ebp+var_C]
.text$mn:00005CAD                 mov     large fs:0, ecx
.text$mn:00005CB4                 pop     ecx
.text$mn:00005CB5                 mov     esp, ebp
.text$mn:00005CB7                 pop     ebp
.text$mn:00005CB8                 retn    4
.text$mn:00005CB8 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:00005CB8
.text$mn:00005CB8 ; ---------------------------------------------------------------------------
.text$mn:00005CBB                 align 4
.text$mn:00005CBB _text$mn        ends
.text$mn:00005CBB
.text$x:00005CBC ; ===========================================================================
.text$x:00005CBC
.text$x:00005CBC ; Segment type: Pure code
.text$x:00005CBC ; Segment permissions: Read/Execute
.text$x:00005CBC _text$x         segment para public 'CODE' use32
.text$x:00005CBC                 assume cs:_text$x
.text$x:00005CBC                 ;org 5CBCh
.text$x:00005CBC ; COMDAT (pick associative to section at 5C30)
.text$x:00005CBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005CBC
.text$x:00005CBC ; =============== S U B R O U T I N E =======================================
.text$x:00005CBC
.text$x:00005CBC
.text$x:00005CBC __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005CBC                                         ; DATA XREF: .xdata$x:0000C7F0o
.text$x:00005CBC                 mov     ecx, [ebp-14h]
.text$x:00005CBF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00005CBF __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005CBF
.text$x:00005CC4
.text$x:00005CC4 ; =============== S U B R O U T I N E =======================================
.text$x:00005CC4
.text$x:00005CC4
.text$x:00005CC4 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:00005CC4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00005CC4
.text$x:00005CC4 arg_4           = dword ptr  8
.text$x:00005CC4
.text$x:00005CC4                 mov     edx, [esp+arg_4]
.text$x:00005CC8                 lea     eax, [edx+0Ch]
.text$x:00005CCB                 mov     ecx, [edx-0Ch]
.text$x:00005CCE                 xor     ecx, eax
.text$x:00005CD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005CD5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$x:00005CDA                 jmp     ___CxxFrameHandler3
.text$x:00005CDA __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$x:00005CDA
.text$x:00005CDA ; ---------------------------------------------------------------------------
.text$x:00005CDF                 align 10h
.text$x:00005CDF _text$x         ends
.text$x:00005CDF
.text$mn:00005CE0 ; ===========================================================================
.text$mn:00005CE0
.text$mn:00005CE0 ; Segment type: Pure code
.text$mn:00005CE0 ; Segment permissions: Read/Execute
.text$mn:00005CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00005CE0                 assume cs:_text$mn
.text$mn:00005CE0                 ;org 5CE0h
.text$mn:00005CE0 ; COMDAT (pick any)
.text$mn:00005CE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005CE0
.text$mn:00005CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CE0
.text$mn:00005CE0 ; Attributes: bp-based frame
.text$mn:00005CE0
.text$mn:00005CE0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:00005CE0                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00005CE0 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:00005CE0                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+10Cp
.text$mn:00005CE0                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+165p ...
.text$mn:00005CE0
.text$mn:00005CE0 var_14          = dword ptr -14h
.text$mn:00005CE0 var_D           = byte ptr -0Dh
.text$mn:00005CE0 var_C           = dword ptr -0Ch
.text$mn:00005CE0 var_4           = dword ptr -4
.text$mn:00005CE0 Str             = dword ptr  8
.text$mn:00005CE0
.text$mn:00005CE0                 push    ebp
.text$mn:00005CE1                 mov     ebp, esp
.text$mn:00005CE3                 push    0FFFFFFFFh
.text$mn:00005CE5                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00005CEA                 mov     eax, large fs:0
.text$mn:00005CF0                 push    eax
.text$mn:00005CF1                 sub     esp, 8
.text$mn:00005CF4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005CF9                 xor     eax, ebp
.text$mn:00005CFB                 push    eax
.text$mn:00005CFC                 lea     eax, [ebp+var_C]
.text$mn:00005CFF                 mov     large fs:0, eax
.text$mn:00005D05                 mov     [ebp+var_14], ecx
.text$mn:00005D08                 lea     ecx, [ebp+var_D]
.text$mn:00005D0B                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005D10                 push    eax
.text$mn:00005D11                 mov     ecx, [ebp+var_14]
.text$mn:00005D14                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00005D19                 mov     [ebp+var_4], 0
.text$mn:00005D20                 push    0
.text$mn:00005D22                 push    0
.text$mn:00005D24                 mov     ecx, [ebp+var_14]
.text$mn:00005D27                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00005D2C                 mov     eax, [ebp+Str]
.text$mn:00005D2F                 push    eax             ; Str
.text$mn:00005D30                 mov     ecx, [ebp+var_14]
.text$mn:00005D33                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00005D38                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005D3F                 mov     eax, [ebp+var_14]
.text$mn:00005D42                 mov     ecx, [ebp+var_C]
.text$mn:00005D45                 mov     large fs:0, ecx
.text$mn:00005D4C                 pop     ecx
.text$mn:00005D4D                 mov     esp, ebp
.text$mn:00005D4F                 pop     ebp
.text$mn:00005D50                 retn    4
.text$mn:00005D50 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:00005D50
.text$mn:00005D50 ; ---------------------------------------------------------------------------
.text$mn:00005D53                 align 4
.text$mn:00005D53 _text$mn        ends
.text$mn:00005D53
.text$x:00005D54 ; ===========================================================================
.text$x:00005D54
.text$x:00005D54 ; Segment type: Pure code
.text$x:00005D54 ; Segment permissions: Read/Execute
.text$x:00005D54 _text$x         segment para public 'CODE' use32
.text$x:00005D54                 assume cs:_text$x
.text$x:00005D54                 ;org 5D54h
.text$x:00005D54 ; COMDAT (pick associative to section at 5CE0)
.text$x:00005D54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005D54
.text$x:00005D54 ; =============== S U B R O U T I N E =======================================
.text$x:00005D54
.text$x:00005D54
.text$x:00005D54 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00005D54                                         ; DATA XREF: .xdata$x:0000C848o
.text$x:00005D54                 mov     ecx, [ebp-14h]
.text$x:00005D57                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00005D57 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00005D57
.text$x:00005D5C
.text$x:00005D5C ; =============== S U B R O U T I N E =======================================
.text$x:00005D5C
.text$x:00005D5C
.text$x:00005D5C __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:00005D5C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:00005D5C
.text$x:00005D5C arg_4           = dword ptr  8
.text$x:00005D5C
.text$x:00005D5C                 mov     edx, [esp+arg_4]
.text$x:00005D60                 lea     eax, [edx+0Ch]
.text$x:00005D63                 mov     ecx, [edx-0Ch]
.text$x:00005D66                 xor     ecx, eax
.text$x:00005D68                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005D6D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:00005D72                 jmp     ___CxxFrameHandler3
.text$x:00005D72 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:00005D72
.text$x:00005D72 ; ---------------------------------------------------------------------------
.text$x:00005D77                 align 4
.text$x:00005D77 _text$x         ends
.text$x:00005D77
.text$mn:00005D78 ; ===========================================================================
.text$mn:00005D78
.text$mn:00005D78 ; Segment type: Pure code
.text$mn:00005D78 ; Segment permissions: Read/Execute
.text$mn:00005D78 _text$mn        segment para public 'CODE' use32
.text$mn:00005D78                 assume cs:_text$mn
.text$mn:00005D78                 ;org 5D78h
.text$mn:00005D78 ; COMDAT (pick any)
.text$mn:00005D78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005D78
.text$mn:00005D78 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D78
.text$mn:00005D78 ; Attributes: bp-based frame
.text$mn:00005D78
.text$mn:00005D78 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00005D78                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00005D78 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00005D78                                         ; CODE XREF: PluginInfo::PluginInfo(void)+71p
.text$mn:00005D78
.text$mn:00005D78 var_14          = dword ptr -14h
.text$mn:00005D78 var_D           = byte ptr -0Dh
.text$mn:00005D78 var_C           = dword ptr -0Ch
.text$mn:00005D78 var_4           = dword ptr -4
.text$mn:00005D78
.text$mn:00005D78                 push    ebp
.text$mn:00005D79                 mov     ebp, esp
.text$mn:00005D7B                 push    0FFFFFFFFh
.text$mn:00005D7D                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00005D82                 mov     eax, large fs:0
.text$mn:00005D88                 push    eax
.text$mn:00005D89                 sub     esp, 8
.text$mn:00005D8C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005D91                 xor     eax, ebp
.text$mn:00005D93                 push    eax
.text$mn:00005D94                 lea     eax, [ebp+var_C]
.text$mn:00005D97                 mov     large fs:0, eax
.text$mn:00005D9D                 mov     [ebp+var_14], ecx
.text$mn:00005DA0                 lea     ecx, [ebp+var_D]
.text$mn:00005DA3                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00005DA8                 push    eax
.text$mn:00005DA9                 mov     ecx, [ebp+var_14]
.text$mn:00005DAC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00005DB1                 mov     [ebp+var_4], 0
.text$mn:00005DB8                 push    0
.text$mn:00005DBA                 push    0
.text$mn:00005DBC                 mov     ecx, [ebp+var_14]
.text$mn:00005DBF                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00005DC4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005DCB                 mov     eax, [ebp+var_14]
.text$mn:00005DCE                 mov     ecx, [ebp+var_C]
.text$mn:00005DD1                 mov     large fs:0, ecx
.text$mn:00005DD8                 pop     ecx
.text$mn:00005DD9                 mov     esp, ebp
.text$mn:00005DDB                 pop     ebp
.text$mn:00005DDC                 retn
.text$mn:00005DDC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00005DDC
.text$mn:00005DDC ; ---------------------------------------------------------------------------
.text$mn:00005DDD                 align 10h
.text$mn:00005DDD _text$mn        ends
.text$mn:00005DDD
.text$x:00005DE0 ; ===========================================================================
.text$x:00005DE0
.text$x:00005DE0 ; Segment type: Pure code
.text$x:00005DE0 ; Segment permissions: Read/Execute
.text$x:00005DE0 _text$x         segment para public 'CODE' use32
.text$x:00005DE0                 assume cs:_text$x
.text$x:00005DE0                 ;org 5DE0h
.text$x:00005DE0 ; COMDAT (pick associative to section at 5D78)
.text$x:00005DE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005DE0
.text$x:00005DE0 ; =============== S U B R O U T I N E =======================================
.text$x:00005DE0
.text$x:00005DE0
.text$x:00005DE0 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00005DE0                                         ; DATA XREF: .xdata$x:0000C81Co
.text$x:00005DE0                 mov     ecx, [ebp-14h]
.text$x:00005DE3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00005DE3 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00005DE3
.text$x:00005DE8
.text$x:00005DE8 ; =============== S U B R O U T I N E =======================================
.text$x:00005DE8
.text$x:00005DE8
.text$x:00005DE8 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00005DE8                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00005DE8
.text$x:00005DE8 arg_4           = dword ptr  8
.text$x:00005DE8
.text$x:00005DE8                 mov     edx, [esp+arg_4]
.text$x:00005DEC                 lea     eax, [edx+0Ch]
.text$x:00005DEF                 mov     ecx, [edx-0Ch]
.text$x:00005DF2                 xor     ecx, eax
.text$x:00005DF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005DF9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00005DFE                 jmp     ___CxxFrameHandler3
.text$x:00005DFE __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00005DFE
.text$x:00005DFE ; ---------------------------------------------------------------------------
.text$x:00005E03                 align 4
.text$x:00005E03 _text$x         ends
.text$x:00005E03
.text$mn:00005E04 ; ===========================================================================
.text$mn:00005E04
.text$mn:00005E04 ; Segment type: Pure code
.text$mn:00005E04 ; Segment permissions: Read/Execute
.text$mn:00005E04 _text$mn        segment para public 'CODE' use32
.text$mn:00005E04                 assume cs:_text$mn
.text$mn:00005E04                 ;org 5E04h
.text$mn:00005E04 ; COMDAT (pick any)
.text$mn:00005E04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005E04
.text$mn:00005E04 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E04
.text$mn:00005E04 ; Attributes: bp-based frame
.text$mn:00005E04
.text$mn:00005E04 ; public: __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:00005E04                 public ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:00005E04 ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$mn:00005E04                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+56p
.text$mn:00005E04                                         ; PluginsManager::loadPlugins(wchar_t const *)+68p
.text$mn:00005E04
.text$mn:00005E04 var_14          = dword ptr -14h
.text$mn:00005E04 var_D           = byte ptr -0Dh
.text$mn:00005E04 var_C           = dword ptr -0Ch
.text$mn:00005E04 var_4           = dword ptr -4
.text$mn:00005E04
.text$mn:00005E04                 push    ebp
.text$mn:00005E05                 mov     ebp, esp
.text$mn:00005E07                 push    0FFFFFFFFh
.text$mn:00005E09                 push    offset __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:00005E0E                 mov     eax, large fs:0
.text$mn:00005E14                 push    eax
.text$mn:00005E15                 sub     esp, 8
.text$mn:00005E18                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005E1D                 xor     eax, ebp
.text$mn:00005E1F                 push    eax
.text$mn:00005E20                 lea     eax, [ebp+var_C]
.text$mn:00005E23                 mov     large fs:0, eax
.text$mn:00005E29                 mov     [ebp+var_14], ecx
.text$mn:00005E2C                 lea     ecx, [ebp+var_D]
.text$mn:00005E2F                 call    ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(void)
.text$mn:00005E34                 push    eax
.text$mn:00005E35                 mov     ecx, [ebp+var_14]
.text$mn:00005E38                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)
.text$mn:00005E3D                 mov     [ebp+var_4], 0
.text$mn:00005E44                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005E4B                 mov     eax, [ebp+var_14]
.text$mn:00005E4E                 mov     ecx, [ebp+var_C]
.text$mn:00005E51                 mov     large fs:0, ecx
.text$mn:00005E58                 pop     ecx
.text$mn:00005E59                 mov     esp, ebp
.text$mn:00005E5B                 pop     ebp
.text$mn:00005E5C                 retn
.text$mn:00005E5C ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$mn:00005E5C
.text$mn:00005E5C ; ---------------------------------------------------------------------------
.text$mn:00005E5D                 align 10h
.text$mn:00005E5D _text$mn        ends
.text$mn:00005E5D
.text$x:00005E60 ; ===========================================================================
.text$x:00005E60
.text$x:00005E60 ; Segment type: Pure code
.text$x:00005E60 ; Segment permissions: Read/Execute
.text$x:00005E60 _text$x         segment para public 'CODE' use32
.text$x:00005E60                 assume cs:_text$x
.text$x:00005E60                 ;org 5E60h
.text$x:00005E60 ; COMDAT (pick associative to section at 5E04)
.text$x:00005E60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005E60
.text$x:00005E60 ; =============== S U B R O U T I N E =======================================
.text$x:00005E60
.text$x:00005E60
.text$x:00005E60 __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:00005E60                                         ; DATA XREF: .xdata$x:0000CC48o
.text$x:00005E60                 mov     ecx, [ebp-14h]
.text$x:00005E63                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)
.text$x:00005E63 __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:00005E63
.text$x:00005E68
.text$x:00005E68 ; =============== S U B R O U T I N E =======================================
.text$x:00005E68
.text$x:00005E68
.text$x:00005E68 __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$x:00005E68                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:00005E68
.text$x:00005E68 arg_4           = dword ptr  8
.text$x:00005E68
.text$x:00005E68                 mov     edx, [esp+arg_4]
.text$x:00005E6C                 lea     eax, [edx+0Ch]
.text$x:00005E6F                 mov     ecx, [edx-0Ch]
.text$x:00005E72                 xor     ecx, eax
.text$x:00005E74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005E79                 mov     eax, offset __ehfuncinfo$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$x:00005E7E                 jmp     ___CxxFrameHandler3
.text$x:00005E7E __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$x:00005E7E
.text$x:00005E7E ; ---------------------------------------------------------------------------
.text$x:00005E83                 align 4
.text$x:00005E83 _text$x         ends
.text$x:00005E83
.text$mn:00005E84 ; ===========================================================================
.text$mn:00005E84
.text$mn:00005E84 ; Segment type: Pure code
.text$mn:00005E84 ; Segment permissions: Read/Execute
.text$mn:00005E84 _text$mn        segment para public 'CODE' use32
.text$mn:00005E84                 assume cs:_text$mn
.text$mn:00005E84                 ;org 5E84h
.text$mn:00005E84 ; COMDAT (pick any)
.text$mn:00005E84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005E84
.text$mn:00005E84 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E84
.text$mn:00005E84 ; Attributes: bp-based frame
.text$mn:00005E84
.text$mn:00005E84 ; _DWORD __thiscall CommandShortcut::CommandShortcut(CommandShortcut *this, const struct CommandShortcut *)
.text$mn:00005E84                 public ??0CommandShortcut@@QAE@ABV0@@Z
.text$mn:00005E84 ??0CommandShortcut@@QAE@ABV0@@Z proc near
.text$mn:00005E84                                         ; CODE XREF: PluginCmdShortcut::PluginCmdShortcut(PluginCmdShortcut const &)+2Dp
.text$mn:00005E84
.text$mn:00005E84 var_10          = dword ptr -10h
.text$mn:00005E84 var_C           = dword ptr -0Ch
.text$mn:00005E84 var_4           = dword ptr -4
.text$mn:00005E84 arg_0           = dword ptr  8
.text$mn:00005E84
.text$mn:00005E84                 push    ebp
.text$mn:00005E85                 mov     ebp, esp
.text$mn:00005E87                 push    0FFFFFFFFh
.text$mn:00005E89                 push    offset __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z
.text$mn:00005E8E                 mov     eax, large fs:0
.text$mn:00005E94                 push    eax
.text$mn:00005E95                 push    ecx
.text$mn:00005E96                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005E9B                 xor     eax, ebp
.text$mn:00005E9D                 push    eax
.text$mn:00005E9E                 lea     eax, [ebp+var_C]
.text$mn:00005EA1                 mov     large fs:0, eax
.text$mn:00005EA7                 mov     [ebp+var_10], ecx
.text$mn:00005EAA                 mov     eax, [ebp+arg_0]
.text$mn:00005EAD                 push    eax             ; Shortcut *
.text$mn:00005EAE                 mov     ecx, [ebp+var_10]
.text$mn:00005EB1                 call    ??0Shortcut@@QAE@ABV0@@Z ; Shortcut::Shortcut(Shortcut const &)
.text$mn:00005EB6                 mov     [ebp+var_4], 0
.text$mn:00005EBD                 mov     ecx, [ebp+var_10]
.text$mn:00005EC0                 mov     dword ptr [ecx], offset ??_7CommandShortcut@@6B@ ; const CommandShortcut::`vftable'
.text$mn:00005EC6                 mov     edx, [ebp+var_10]
.text$mn:00005EC9                 mov     eax, [ebp+arg_0]
.text$mn:00005ECC                 mov     ecx, [eax+128h]
.text$mn:00005ED2                 mov     [edx+128h], ecx
.text$mn:00005ED8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005EDF                 mov     eax, [ebp+var_10]
.text$mn:00005EE2                 mov     ecx, [ebp+var_C]
.text$mn:00005EE5                 mov     large fs:0, ecx
.text$mn:00005EEC                 pop     ecx
.text$mn:00005EED                 mov     esp, ebp
.text$mn:00005EEF                 pop     ebp
.text$mn:00005EF0                 retn    4
.text$mn:00005EF0 ??0CommandShortcut@@QAE@ABV0@@Z endp
.text$mn:00005EF0
.text$mn:00005EF0 ; ---------------------------------------------------------------------------
.text$mn:00005EF3                 align 4
.text$mn:00005EF3 _text$mn        ends
.text$mn:00005EF3
.text$x:00005EF4 ; ===========================================================================
.text$x:00005EF4
.text$x:00005EF4 ; Segment type: Pure code
.text$x:00005EF4 ; Segment permissions: Read/Execute
.text$x:00005EF4 _text$x         segment para public 'CODE' use32
.text$x:00005EF4                 assume cs:_text$x
.text$x:00005EF4                 ;org 5EF4h
.text$x:00005EF4 ; COMDAT (pick associative to section at 5E84)
.text$x:00005EF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005EF4
.text$x:00005EF4 ; =============== S U B R O U T I N E =======================================
.text$x:00005EF4
.text$x:00005EF4
.text$x:00005EF4 __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0 proc near
.text$x:00005EF4                                         ; DATA XREF: .xdata$x:0000CA94o
.text$x:00005EF4                 mov     ecx, [ebp-10h]  ; this
.text$x:00005EF7                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00005EF7 __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0 endp
.text$x:00005EF7
.text$x:00005EFC
.text$x:00005EFC ; =============== S U B R O U T I N E =======================================
.text$x:00005EFC
.text$x:00005EFC
.text$x:00005EFC __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z proc near
.text$x:00005EFC                                         ; DATA XREF: CommandShortcut::CommandShortcut(CommandShortcut const &)+5o
.text$x:00005EFC
.text$x:00005EFC arg_4           = dword ptr  8
.text$x:00005EFC
.text$x:00005EFC                 mov     edx, [esp+arg_4]
.text$x:00005F00                 lea     eax, [edx+0Ch]
.text$x:00005F03                 mov     ecx, [edx-8]
.text$x:00005F06                 xor     ecx, eax
.text$x:00005F08                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005F0D                 mov     eax, offset __ehfuncinfo$??0CommandShortcut@@QAE@ABV0@@Z
.text$x:00005F12                 jmp     ___CxxFrameHandler3
.text$x:00005F12 __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z endp
.text$x:00005F12
.text$x:00005F12 ; ---------------------------------------------------------------------------
.text$x:00005F17                 align 4
.text$x:00005F17 _text$x         ends
.text$x:00005F17
.text$mn:00005F18 ; ===========================================================================
.text$mn:00005F18
.text$mn:00005F18 ; Segment type: Pure code
.text$mn:00005F18 ; Segment permissions: Read/Execute
.text$mn:00005F18 _text$mn        segment para public 'CODE' use32
.text$mn:00005F18                 assume cs:_text$mn
.text$mn:00005F18                 ;org 5F18h
.text$mn:00005F18 ; COMDAT (pick any)
.text$mn:00005F18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005F18
.text$mn:00005F18 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F18
.text$mn:00005F18 ; Attributes: bp-based frame
.text$mn:00005F18
.text$mn:00005F18 ; public: __thiscall CommandShortcut::CommandShortcut(class Shortcut, long)
.text$mn:00005F18                 public ??0CommandShortcut@@QAE@VShortcut@@J@Z
.text$mn:00005F18 ??0CommandShortcut@@QAE@VShortcut@@J@Z proc near
.text$mn:00005F18                                         ; CODE XREF: PluginCmdShortcut::PluginCmdShortcut(Shortcut,int,wchar_t const *,ushort)+5Ep
.text$mn:00005F18
.text$mn:00005F18 var_10          = dword ptr -10h
.text$mn:00005F18 var_C           = dword ptr -0Ch
.text$mn:00005F18 var_4           = dword ptr -4
.text$mn:00005F18 arg_0           = byte ptr  8
.text$mn:00005F18 arg_128         = dword ptr  130h
.text$mn:00005F18
.text$mn:00005F18                 push    ebp
.text$mn:00005F19                 mov     ebp, esp
.text$mn:00005F1B                 push    0FFFFFFFFh
.text$mn:00005F1D                 push    offset __ehhandler$??0CommandShortcut@@QAE@VShortcut@@J@Z
.text$mn:00005F22                 mov     eax, large fs:0
.text$mn:00005F28                 push    eax
.text$mn:00005F29                 push    ecx
.text$mn:00005F2A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005F2F                 xor     eax, ebp
.text$mn:00005F31                 push    eax
.text$mn:00005F32                 lea     eax, [ebp+var_C]
.text$mn:00005F35                 mov     large fs:0, eax
.text$mn:00005F3B                 mov     [ebp+var_10], ecx
.text$mn:00005F3E                 mov     [ebp+var_4], 0
.text$mn:00005F45                 lea     eax, [ebp+arg_0]
.text$mn:00005F48                 push    eax             ; Shortcut *
.text$mn:00005F49                 mov     ecx, [ebp+var_10]
.text$mn:00005F4C                 call    ??0Shortcut@@QAE@ABV0@@Z ; Shortcut::Shortcut(Shortcut const &)
.text$mn:00005F51                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005F55                 mov     ecx, [ebp+var_10]
.text$mn:00005F58                 mov     dword ptr [ecx], offset ??_7CommandShortcut@@6B@ ; const CommandShortcut::`vftable'
.text$mn:00005F5E                 mov     edx, [ebp+var_10]
.text$mn:00005F61                 mov     eax, [ebp+arg_128]
.text$mn:00005F67                 mov     [edx+128h], eax
.text$mn:00005F6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005F74                 lea     ecx, [ebp+arg_0] ; this
.text$mn:00005F77                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:00005F7C                 mov     eax, [ebp+var_10]
.text$mn:00005F7F                 mov     ecx, [ebp+var_C]
.text$mn:00005F82                 mov     large fs:0, ecx
.text$mn:00005F89                 pop     ecx
.text$mn:00005F8A                 mov     esp, ebp
.text$mn:00005F8C                 pop     ebp
.text$mn:00005F8D                 retn    12Ch
.text$mn:00005F8D ??0CommandShortcut@@QAE@VShortcut@@J@Z endp
.text$mn:00005F8D
.text$mn:00005F8D _text$mn        ends
.text$mn:00005F8D
.text$x:00005F90 ; ===========================================================================
.text$x:00005F90
.text$x:00005F90 ; Segment type: Pure code
.text$x:00005F90 ; Segment permissions: Read/Execute
.text$x:00005F90 _text$x         segment para public 'CODE' use32
.text$x:00005F90                 assume cs:_text$x
.text$x:00005F90                 ;org 5F90h
.text$x:00005F90 ; COMDAT (pick associative to section at 5F18)
.text$x:00005F90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005F90
.text$x:00005F90 ; =============== S U B R O U T I N E =======================================
.text$x:00005F90
.text$x:00005F90
.text$x:00005F90 __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$0 proc near
.text$x:00005F90                                         ; DATA XREF: .xdata$x:0000CA34o
.text$x:00005F90                 lea     ecx, [ebp+8]    ; this
.text$x:00005F93                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00005F93 __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$0 endp
.text$x:00005F93
.text$x:00005F98
.text$x:00005F98 ; =============== S U B R O U T I N E =======================================
.text$x:00005F98
.text$x:00005F98
.text$x:00005F98 __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$1 proc near
.text$x:00005F98                                         ; DATA XREF: .xdata$x:0000CA3Co
.text$x:00005F98                 mov     ecx, [ebp-10h]  ; this
.text$x:00005F9B                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00005F9B __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$1 endp
.text$x:00005F9B
.text$x:00005FA0
.text$x:00005FA0 ; =============== S U B R O U T I N E =======================================
.text$x:00005FA0
.text$x:00005FA0
.text$x:00005FA0 __ehhandler$??0CommandShortcut@@QAE@VShortcut@@J@Z proc near
.text$x:00005FA0                                         ; DATA XREF: CommandShortcut::CommandShortcut(Shortcut,long)+5o
.text$x:00005FA0
.text$x:00005FA0 arg_4           = dword ptr  8
.text$x:00005FA0
.text$x:00005FA0                 mov     edx, [esp+arg_4]
.text$x:00005FA4                 lea     eax, [edx+0Ch]
.text$x:00005FA7                 mov     ecx, [edx-8]
.text$x:00005FAA                 xor     ecx, eax
.text$x:00005FAC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005FB1                 mov     eax, offset __ehfuncinfo$??0CommandShortcut@@QAE@VShortcut@@J@Z
.text$x:00005FB6                 jmp     ___CxxFrameHandler3
.text$x:00005FB6 __ehhandler$??0CommandShortcut@@QAE@VShortcut@@J@Z endp
.text$x:00005FB6
.text$x:00005FB6 ; ---------------------------------------------------------------------------
.text$x:00005FBB                 align 4
.text$x:00005FBB _text$x         ends
.text$x:00005FBB
.text$mn:00005FBC ; ===========================================================================
.text$mn:00005FBC
.text$mn:00005FBC ; Segment type: Pure code
.text$mn:00005FBC ; Segment permissions: Read/Execute
.text$mn:00005FBC _text$mn        segment para public 'CODE' use32
.text$mn:00005FBC                 assume cs:_text$mn
.text$mn:00005FBC                 ;org 5FBCh
.text$mn:00005FBC ; COMDAT (pick any)
.text$mn:00005FBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005FBC
.text$mn:00005FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00005FBC
.text$mn:00005FBC ; Attributes: bp-based frame
.text$mn:00005FBC
.text$mn:00005FBC ; _DWORD __thiscall ExternalLangContainer::ExternalLangContainer(ExternalLangContainer *this, const wchar_t *Source, const wchar_t *)
.text$mn:00005FBC                 public ??0ExternalLangContainer@@QAE@PB_W0@Z
.text$mn:00005FBC ??0ExternalLangContainer@@QAE@PB_W0@Z proc near
.text$mn:00005FBC                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+56Dp
.text$mn:00005FBC
.text$mn:00005FBC Dest            = dword ptr -4
.text$mn:00005FBC Source          = dword ptr  8
.text$mn:00005FBC arg_4           = dword ptr  0Ch
.text$mn:00005FBC
.text$mn:00005FBC                 push    ebp
.text$mn:00005FBD                 mov     ebp, esp
.text$mn:00005FBF                 push    ecx
.text$mn:00005FC0                 mov     [ebp+Dest], ecx
.text$mn:00005FC3                 push    10h             ; Count
.text$mn:00005FC5                 mov     eax, [ebp+Source]
.text$mn:00005FC8                 push    eax             ; Source
.text$mn:00005FC9                 mov     ecx, [ebp+Dest]
.text$mn:00005FCC                 push    ecx             ; Dest
.text$mn:00005FCD                 call    _wcsncpy
.text$mn:00005FD2                 add     esp, 0Ch
.text$mn:00005FD5                 push    20h ; ' '       ; Count
.text$mn:00005FD7                 mov     edx, [ebp+arg_4]
.text$mn:00005FDA                 push    edx             ; Source
.text$mn:00005FDB                 mov     eax, [ebp+Dest]
.text$mn:00005FDE                 add     eax, 20h ; ' '
.text$mn:00005FE1                 push    eax             ; Dest
.text$mn:00005FE2                 call    _wcsncpy
.text$mn:00005FE7                 add     esp, 0Ch
.text$mn:00005FEA                 mov     eax, [ebp+Dest]
.text$mn:00005FED                 mov     esp, ebp
.text$mn:00005FEF                 pop     ebp
.text$mn:00005FF0                 retn    8
.text$mn:00005FF0 ??0ExternalLangContainer@@QAE@PB_W0@Z endp
.text$mn:00005FF0
.text$mn:00005FF0 ; ---------------------------------------------------------------------------
.text$mn:00005FF3                 align 4
.text$mn:00005FF3 _text$mn        ends
.text$mn:00005FF3
.text$mn:00005FF4 ; ===========================================================================
.text$mn:00005FF4
.text$mn:00005FF4 ; Segment type: Pure code
.text$mn:00005FF4 ; Segment permissions: Read/Execute
.text$mn:00005FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00005FF4                 assume cs:_text$mn
.text$mn:00005FF4                 ;org 5FF4h
.text$mn:00005FF4 ; COMDAT (pick any)
.text$mn:00005FF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005FF4
.text$mn:00005FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FF4
.text$mn:00005FF4 ; Attributes: bp-based frame
.text$mn:00005FF4
.text$mn:00005FF4 ; int __stdcall PluginCmdShortcut::PluginCmdShortcut(struct CommandShortcut *)
.text$mn:00005FF4                 public ??0PluginCmdShortcut@@QAE@ABV0@@Z
.text$mn:00005FF4 ??0PluginCmdShortcut@@QAE@ABV0@@Z proc near
.text$mn:00005FF4                                         ; CODE XREF: std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut &>(PluginCmdShortcut *,PluginCmdShortcut &)+59p
.text$mn:00005FF4                                         ; std::allocator<PluginCmdShortcut>::construct<PluginCmdShortcut,PluginCmdShortcut>(PluginCmdShortcut *,PluginCmdShortcut &&)+59p ...
.text$mn:00005FF4
.text$mn:00005FF4 var_10          = dword ptr -10h
.text$mn:00005FF4 var_C           = dword ptr -0Ch
.text$mn:00005FF4 var_4           = dword ptr -4
.text$mn:00005FF4 arg_0           = dword ptr  8
.text$mn:00005FF4
.text$mn:00005FF4                 push    ebp
.text$mn:00005FF5                 mov     ebp, esp
.text$mn:00005FF7                 push    0FFFFFFFFh
.text$mn:00005FF9                 push    offset __ehhandler$??0PluginCmdShortcut@@QAE@ABV0@@Z
.text$mn:00005FFE                 mov     eax, large fs:0
.text$mn:00006004                 push    eax
.text$mn:00006005                 push    ecx
.text$mn:00006006                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000600B                 xor     eax, ebp
.text$mn:0000600D                 push    eax
.text$mn:0000600E                 lea     eax, [ebp+var_C]
.text$mn:00006011                 mov     large fs:0, eax
.text$mn:00006017                 mov     [ebp+var_10], ecx
.text$mn:0000601A                 mov     eax, [ebp+arg_0]
.text$mn:0000601D                 push    eax             ; struct CommandShortcut *
.text$mn:0000601E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006021                 call    ??0CommandShortcut@@QAE@ABV0@@Z ; CommandShortcut::CommandShortcut(CommandShortcut const &)
.text$mn:00006026                 mov     [ebp+var_4], 0
.text$mn:0000602D                 mov     ecx, [ebp+var_10]
.text$mn:00006030                 mov     dword ptr [ecx], offset ??_7PluginCmdShortcut@@6B@ ; const PluginCmdShortcut::`vftable'
.text$mn:00006036                 mov     edx, [ebp+var_10]
.text$mn:00006039                 mov     eax, [ebp+arg_0]
.text$mn:0000603C                 mov     ecx, [eax+12Ch]
.text$mn:00006042                 mov     [edx+12Ch], ecx
.text$mn:00006048                 mov     edx, [ebp+arg_0]
.text$mn:0000604B                 add     edx, 130h
.text$mn:00006051                 push    edx
.text$mn:00006052                 mov     ecx, [ebp+var_10]
.text$mn:00006055                 add     ecx, 130h
.text$mn:0000605B                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00006060                 mov     byte ptr [ebp+var_4], 1
.text$mn:00006064                 mov     eax, [ebp+var_10]
.text$mn:00006067                 mov     ecx, [ebp+arg_0]
.text$mn:0000606A                 mov     edx, [ecx+14Ch]
.text$mn:00006070                 mov     [eax+14Ch], edx
.text$mn:00006076                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000607D                 mov     eax, [ebp+var_10]
.text$mn:00006080                 mov     ecx, [ebp+var_C]
.text$mn:00006083                 mov     large fs:0, ecx
.text$mn:0000608A                 pop     ecx
.text$mn:0000608B                 mov     esp, ebp
.text$mn:0000608D                 pop     ebp
.text$mn:0000608E                 retn    4
.text$mn:0000608E ??0PluginCmdShortcut@@QAE@ABV0@@Z endp
.text$mn:0000608E
.text$mn:0000608E ; ---------------------------------------------------------------------------
.text$mn:00006091                 align 4
.text$mn:00006091 _text$mn        ends
.text$mn:00006091
.text$x:00006094 ; ===========================================================================
.text$x:00006094
.text$x:00006094 ; Segment type: Pure code
.text$x:00006094 ; Segment permissions: Read/Execute
.text$x:00006094 _text$x         segment para public 'CODE' use32
.text$x:00006094                 assume cs:_text$x
.text$x:00006094                 ;org 6094h
.text$x:00006094 ; COMDAT (pick associative to section at 5FF4)
.text$x:00006094                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006094
.text$x:00006094 ; =============== S U B R O U T I N E =======================================
.text$x:00006094
.text$x:00006094
.text$x:00006094 __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$0 proc near
.text$x:00006094                                         ; DATA XREF: .xdata$x:0000CB38o
.text$x:00006094                 mov     ecx, [ebp-10h]  ; this
.text$x:00006097                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:00006097 __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$0 endp
.text$x:00006097
.text$x:0000609C
.text$x:0000609C ; =============== S U B R O U T I N E =======================================
.text$x:0000609C
.text$x:0000609C
.text$x:0000609C __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$1 proc near
.text$x:0000609C                                         ; DATA XREF: .xdata$x:0000CB40o
.text$x:0000609C                 mov     ecx, [ebp-10h]
.text$x:0000609F                 add     ecx, 130h
.text$x:000060A5                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000060A5 __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$1 endp
.text$x:000060A5
.text$x:000060AA
.text$x:000060AA ; =============== S U B R O U T I N E =======================================
.text$x:000060AA
.text$x:000060AA
.text$x:000060AA __ehhandler$??0PluginCmdShortcut@@QAE@ABV0@@Z proc near
.text$x:000060AA                                         ; DATA XREF: PluginCmdShortcut::PluginCmdShortcut(PluginCmdShortcut const &)+5o
.text$x:000060AA
.text$x:000060AA arg_4           = dword ptr  8
.text$x:000060AA
.text$x:000060AA                 mov     edx, [esp+arg_4]
.text$x:000060AE                 lea     eax, [edx+0Ch]
.text$x:000060B1                 mov     ecx, [edx-8]
.text$x:000060B4                 xor     ecx, eax
.text$x:000060B6                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000060BB                 mov     eax, offset __ehfuncinfo$??0PluginCmdShortcut@@QAE@ABV0@@Z
.text$x:000060C0                 jmp     ___CxxFrameHandler3
.text$x:000060C0 __ehhandler$??0PluginCmdShortcut@@QAE@ABV0@@Z endp
.text$x:000060C0
.text$x:000060C0 ; ---------------------------------------------------------------------------
.text$x:000060C5                 align 4
.text$x:000060C5 _text$x         ends
.text$x:000060C5
.text$mn:000060C8 ; ===========================================================================
.text$mn:000060C8
.text$mn:000060C8 ; Segment type: Pure code
.text$mn:000060C8 ; Segment permissions: Read/Execute
.text$mn:000060C8 _text$mn        segment para public 'CODE' use32
.text$mn:000060C8                 assume cs:_text$mn
.text$mn:000060C8                 ;org 60C8h
.text$mn:000060C8 ; COMDAT (pick any)
.text$mn:000060C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000060C8
.text$mn:000060C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000060C8
.text$mn:000060C8 ; Attributes: bp-based frame
.text$mn:000060C8
.text$mn:000060C8 ; int __stdcall PluginCmdShortcut::PluginCmdShortcut(char, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, wchar_t *Str, __int16)
.text$mn:000060C8                 public ??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z
.text$mn:000060C8 ??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z proc near
.text$mn:000060C8                                         ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+343p
.text$mn:000060C8                                         ; PluginsManager::addInMenuFromPMIndex(int)+44Bp
.text$mn:000060C8
.text$mn:000060C8 var_20          = dword ptr -20h
.text$mn:000060C8 var_1C          = dword ptr -1Ch
.text$mn:000060C8 var_18          = dword ptr -18h
.text$mn:000060C8 var_14          = dword ptr -14h
.text$mn:000060C8 var_10          = dword ptr -10h
.text$mn:000060C8 var_C           = dword ptr -0Ch
.text$mn:000060C8 var_4           = dword ptr -4
.text$mn:000060C8 arg_0           = byte ptr  8
.text$mn:000060C8 arg_128         = dword ptr  130h
.text$mn:000060C8 Str             = dword ptr  134h
.text$mn:000060C8 arg_130         = word ptr  138h
.text$mn:000060C8
.text$mn:000060C8                 push    ebp
.text$mn:000060C9                 mov     ebp, esp
.text$mn:000060CB                 push    0FFFFFFFFh
.text$mn:000060CD                 push    offset __ehhandler$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z
.text$mn:000060D2                 mov     eax, large fs:0
.text$mn:000060D8                 push    eax
.text$mn:000060D9                 sub     esp, 14h
.text$mn:000060DC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000060E1                 xor     eax, ebp
.text$mn:000060E3                 push    eax
.text$mn:000060E4                 lea     eax, [ebp+var_C]
.text$mn:000060E7                 mov     large fs:0, eax
.text$mn:000060ED                 mov     [ebp+var_10], ecx
.text$mn:000060F0                 mov     [ebp+var_4], 0
.text$mn:000060F7                 mov     eax, [ebp+arg_128]
.text$mn:000060FD                 push    eax
.text$mn:000060FE                 sub     esp, 128h
.text$mn:00006104                 mov     ecx, esp
.text$mn:00006106                 mov     [ebp+var_18], esp
.text$mn:00006109                 lea     edx, [ebp+arg_0]
.text$mn:0000610C                 push    edx             ; Shortcut *
.text$mn:0000610D                 call    ??0Shortcut@@QAE@ABV0@@Z ; Shortcut::Shortcut(Shortcut const &)
.text$mn:00006112                 mov     [ebp+var_14], eax
.text$mn:00006115                 mov     eax, [ebp+var_14]
.text$mn:00006118                 mov     [ebp+var_1C], eax
.text$mn:0000611B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000611F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00006123                 mov     ecx, [ebp+var_10]
.text$mn:00006126                 call    ??0CommandShortcut@@QAE@VShortcut@@J@Z ; CommandShortcut::CommandShortcut(Shortcut,long)
.text$mn:0000612B                 mov     [ebp+var_20], eax
.text$mn:0000612E                 mov     byte ptr [ebp+var_4], 2
.text$mn:00006132                 mov     ecx, [ebp+var_10]
.text$mn:00006135                 mov     dword ptr [ecx], offset ??_7PluginCmdShortcut@@6B@ ; const PluginCmdShortcut::`vftable'
.text$mn:0000613B                 mov     edx, [ebp+var_10]
.text$mn:0000613E                 mov     eax, [ebp+arg_128]
.text$mn:00006144                 mov     [edx+12Ch], eax
.text$mn:0000614A                 mov     ecx, [ebp+Str]
.text$mn:00006150                 push    ecx             ; Str
.text$mn:00006151                 mov     ecx, [ebp+var_10]
.text$mn:00006154                 add     ecx, 130h
.text$mn:0000615A                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000615F                 mov     byte ptr [ebp+var_4], 3
.text$mn:00006163                 movzx   edx, [ebp+arg_130]
.text$mn:0000616A                 mov     eax, [ebp+var_10]
.text$mn:0000616D                 mov     [eax+14Ch], edx
.text$mn:00006173                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000617A                 lea     ecx, [ebp+arg_0] ; this
.text$mn:0000617D                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:00006182                 mov     eax, [ebp+var_10]
.text$mn:00006185                 mov     ecx, [ebp+var_C]
.text$mn:00006188                 mov     large fs:0, ecx
.text$mn:0000618F                 pop     ecx
.text$mn:00006190                 mov     esp, ebp
.text$mn:00006192                 pop     ebp
.text$mn:00006193                 retn    134h
.text$mn:00006193 ??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z endp
.text$mn:00006193
.text$mn:00006193 ; ---------------------------------------------------------------------------
.text$mn:00006196                 align 4
.text$mn:00006196 _text$mn        ends
.text$mn:00006196
.text$x:00006198 ; ===========================================================================
.text$x:00006198
.text$x:00006198 ; Segment type: Pure code
.text$x:00006198 ; Segment permissions: Read/Execute
.text$x:00006198 _text$x         segment para public 'CODE' use32
.text$x:00006198                 assume cs:_text$x
.text$x:00006198                 ;org 6198h
.text$x:00006198 ; COMDAT (pick associative to section at 60C8)
.text$x:00006198                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006198
.text$x:00006198 ; =============== S U B R O U T I N E =======================================
.text$x:00006198
.text$x:00006198
.text$x:00006198 __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$0 proc near
.text$x:00006198                                         ; DATA XREF: .xdata$x:0000CAC0o
.text$x:00006198                 lea     ecx, [ebp+8]    ; this
.text$x:0000619B                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:0000619B __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$0 endp
.text$x:0000619B
.text$x:000061A0
.text$x:000061A0 ; =============== S U B R O U T I N E =======================================
.text$x:000061A0
.text$x:000061A0
.text$x:000061A0 __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$1 proc near
.text$x:000061A0                                         ; DATA XREF: .xdata$x:0000CAC8o
.text$x:000061A0                 mov     ecx, [ebp-18h]  ; this
.text$x:000061A3                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:000061A3 __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$1 endp
.text$x:000061A3
.text$x:000061A8
.text$x:000061A8 ; =============== S U B R O U T I N E =======================================
.text$x:000061A8
.text$x:000061A8
.text$x:000061A8 __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$2 proc near
.text$x:000061A8                                         ; DATA XREF: .xdata$x:0000CAD0o
.text$x:000061A8                 mov     ecx, [ebp-10h]  ; this
.text$x:000061AB                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:000061AB __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$2 endp
.text$x:000061AB
.text$x:000061B0
.text$x:000061B0 ; =============== S U B R O U T I N E =======================================
.text$x:000061B0
.text$x:000061B0
.text$x:000061B0 __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$3 proc near
.text$x:000061B0                                         ; DATA XREF: .xdata$x:0000CAD8o
.text$x:000061B0                 mov     ecx, [ebp-10h]
.text$x:000061B3                 add     ecx, 130h
.text$x:000061B9                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000061B9 __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$3 endp
.text$x:000061B9
.text$x:000061BE
.text$x:000061BE ; =============== S U B R O U T I N E =======================================
.text$x:000061BE
.text$x:000061BE
.text$x:000061BE __ehhandler$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z proc near
.text$x:000061BE                                         ; DATA XREF: PluginCmdShortcut::PluginCmdShortcut(Shortcut,int,wchar_t const *,ushort)+5o
.text$x:000061BE
.text$x:000061BE arg_4           = dword ptr  8
.text$x:000061BE
.text$x:000061BE                 mov     edx, [esp+arg_4]
.text$x:000061C2                 lea     eax, [edx+0Ch]
.text$x:000061C5                 mov     ecx, [edx-18h]
.text$x:000061C8                 xor     ecx, eax
.text$x:000061CA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000061CF                 mov     eax, offset __ehfuncinfo$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z
.text$x:000061D4                 jmp     ___CxxFrameHandler3
.text$x:000061D4 __ehhandler$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z endp
.text$x:000061D4
.text$x:000061D4 ; ---------------------------------------------------------------------------
.text$x:000061D9                 align 4
.text$x:000061D9 _text$x         ends
.text$x:000061D9
.text$mn:000061DC ; ===========================================================================
.text$mn:000061DC
.text$mn:000061DC ; Segment type: Pure code
.text$mn:000061DC ; Segment permissions: Read/Execute
.text$mn:000061DC _text$mn        segment para public 'CODE' use32
.text$mn:000061DC                 assume cs:_text$mn
.text$mn:000061DC                 ;org 61DCh
.text$mn:000061DC ; COMDAT (pick any)
.text$mn:000061DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000061DC
.text$mn:000061DC ; =============== S U B R O U T I N E =======================================
.text$mn:000061DC
.text$mn:000061DC ; Attributes: bp-based frame
.text$mn:000061DC
.text$mn:000061DC ; public: __thiscall PluginCommand::PluginCommand(struct PluginCommand const &)
.text$mn:000061DC                 public ??0PluginCommand@@QAE@ABU0@@Z
.text$mn:000061DC ??0PluginCommand@@QAE@ABU0@@Z proc near ; CODE XREF: std::allocator<PluginCommand>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)+56p
.text$mn:000061DC
.text$mn:000061DC var_10          = dword ptr -10h
.text$mn:000061DC var_C           = dword ptr -0Ch
.text$mn:000061DC var_4           = dword ptr -4
.text$mn:000061DC arg_0           = dword ptr  8
.text$mn:000061DC
.text$mn:000061DC                 push    ebp
.text$mn:000061DD                 mov     ebp, esp
.text$mn:000061DF                 push    0FFFFFFFFh
.text$mn:000061E1                 push    offset __ehhandler$??0PluginCommand@@QAE@ABU0@@Z
.text$mn:000061E6                 mov     eax, large fs:0
.text$mn:000061EC                 push    eax
.text$mn:000061ED                 push    ecx
.text$mn:000061EE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000061F3                 xor     eax, ebp
.text$mn:000061F5                 push    eax
.text$mn:000061F6                 lea     eax, [ebp+var_C]
.text$mn:000061F9                 mov     large fs:0, eax
.text$mn:000061FF                 mov     [ebp+var_10], ecx
.text$mn:00006202                 mov     eax, [ebp+arg_0]
.text$mn:00006205                 push    eax
.text$mn:00006206                 mov     ecx, [ebp+var_10]
.text$mn:00006209                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000620E                 mov     [ebp+var_4], 0
.text$mn:00006215                 mov     ecx, [ebp+var_10]
.text$mn:00006218                 mov     edx, [ebp+arg_0]
.text$mn:0000621B                 mov     eax, [edx+1Ch]
.text$mn:0000621E                 mov     [ecx+1Ch], eax
.text$mn:00006221                 mov     ecx, [ebp+var_10]
.text$mn:00006224                 mov     edx, [ebp+arg_0]
.text$mn:00006227                 mov     eax, [edx+20h]
.text$mn:0000622A                 mov     [ecx+20h], eax
.text$mn:0000622D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006234                 mov     eax, [ebp+var_10]
.text$mn:00006237                 mov     ecx, [ebp+var_C]
.text$mn:0000623A                 mov     large fs:0, ecx
.text$mn:00006241                 pop     ecx
.text$mn:00006242                 mov     esp, ebp
.text$mn:00006244                 pop     ebp
.text$mn:00006245                 retn    4
.text$mn:00006245 ??0PluginCommand@@QAE@ABU0@@Z endp
.text$mn:00006245
.text$mn:00006245 _text$mn        ends
.text$mn:00006245
.text$x:00006248 ; ===========================================================================
.text$x:00006248
.text$x:00006248 ; Segment type: Pure code
.text$x:00006248 ; Segment permissions: Read/Execute
.text$x:00006248 _text$x         segment para public 'CODE' use32
.text$x:00006248                 assume cs:_text$x
.text$x:00006248                 ;org 6248h
.text$x:00006248 ; COMDAT (pick associative to section at 61DC)
.text$x:00006248                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006248
.text$x:00006248 ; =============== S U B R O U T I N E =======================================
.text$x:00006248
.text$x:00006248
.text$x:00006248 __unwindfunclet$??0PluginCommand@@QAE@ABU0@@Z$0 proc near
.text$x:00006248                                         ; DATA XREF: .xdata$x:0000CFECo
.text$x:00006248                 mov     ecx, [ebp-10h]
.text$x:0000624B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000624B __unwindfunclet$??0PluginCommand@@QAE@ABU0@@Z$0 endp
.text$x:0000624B
.text$x:00006250
.text$x:00006250 ; =============== S U B R O U T I N E =======================================
.text$x:00006250
.text$x:00006250
.text$x:00006250 __ehhandler$??0PluginCommand@@QAE@ABU0@@Z proc near
.text$x:00006250                                         ; DATA XREF: PluginCommand::PluginCommand(PluginCommand const &)+5o
.text$x:00006250
.text$x:00006250 arg_4           = dword ptr  8
.text$x:00006250
.text$x:00006250                 mov     edx, [esp+arg_4]
.text$x:00006254                 lea     eax, [edx+0Ch]
.text$x:00006257                 mov     ecx, [edx-8]
.text$x:0000625A                 xor     ecx, eax
.text$x:0000625C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006261                 mov     eax, offset __ehfuncinfo$??0PluginCommand@@QAE@ABU0@@Z
.text$x:00006266                 jmp     ___CxxFrameHandler3
.text$x:00006266 __ehhandler$??0PluginCommand@@QAE@ABU0@@Z endp
.text$x:00006266
.text$x:00006266 ; ---------------------------------------------------------------------------
.text$x:0000626B                 align 4
.text$x:0000626B _text$x         ends
.text$x:0000626B
.text$mn:0000626C ; ===========================================================================
.text$mn:0000626C
.text$mn:0000626C ; Segment type: Pure code
.text$mn:0000626C ; Segment permissions: Read/Execute
.text$mn:0000626C _text$mn        segment para public 'CODE' use32
.text$mn:0000626C                 assume cs:_text$mn
.text$mn:0000626C                 ;org 626Ch
.text$mn:0000626C ; COMDAT (pick any)
.text$mn:0000626C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000626C
.text$mn:0000626C ; =============== S U B R O U T I N E =======================================
.text$mn:0000626C
.text$mn:0000626C ; Attributes: bp-based frame
.text$mn:0000626C
.text$mn:0000626C ; int __stdcall PluginCommand::PluginCommand(wchar_t *Str, int, int)
.text$mn:0000626C                 public ??0PluginCommand@@QAE@PB_WHP6AXXZ@Z
.text$mn:0000626C ??0PluginCommand@@QAE@PB_WHP6AXXZ@Z proc near
.text$mn:0000626C                                         ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+189p
.text$mn:0000626C
.text$mn:0000626C var_10          = dword ptr -10h
.text$mn:0000626C var_C           = dword ptr -0Ch
.text$mn:0000626C var_4           = dword ptr -4
.text$mn:0000626C Str             = dword ptr  8
.text$mn:0000626C arg_4           = dword ptr  0Ch
.text$mn:0000626C arg_8           = dword ptr  10h
.text$mn:0000626C
.text$mn:0000626C                 push    ebp
.text$mn:0000626D                 mov     ebp, esp
.text$mn:0000626F                 push    0FFFFFFFFh
.text$mn:00006271                 push    offset __ehhandler$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z
.text$mn:00006276                 mov     eax, large fs:0
.text$mn:0000627C                 push    eax
.text$mn:0000627D                 push    ecx
.text$mn:0000627E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006283                 xor     eax, ebp
.text$mn:00006285                 push    eax
.text$mn:00006286                 lea     eax, [ebp+var_C]
.text$mn:00006289                 mov     large fs:0, eax
.text$mn:0000628F                 mov     [ebp+var_10], ecx
.text$mn:00006292                 mov     eax, [ebp+Str]
.text$mn:00006295                 push    eax             ; Str
.text$mn:00006296                 mov     ecx, [ebp+var_10]
.text$mn:00006299                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000629E                 mov     [ebp+var_4], 0
.text$mn:000062A5                 mov     ecx, [ebp+var_10]
.text$mn:000062A8                 mov     edx, [ebp+arg_4]
.text$mn:000062AB                 mov     [ecx+1Ch], edx
.text$mn:000062AE                 mov     eax, [ebp+var_10]
.text$mn:000062B1                 mov     ecx, [ebp+arg_8]
.text$mn:000062B4                 mov     [eax+20h], ecx
.text$mn:000062B7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000062BE                 mov     eax, [ebp+var_10]
.text$mn:000062C1                 mov     ecx, [ebp+var_C]
.text$mn:000062C4                 mov     large fs:0, ecx
.text$mn:000062CB                 pop     ecx
.text$mn:000062CC                 mov     esp, ebp
.text$mn:000062CE                 pop     ebp
.text$mn:000062CF                 retn    0Ch
.text$mn:000062CF ??0PluginCommand@@QAE@PB_WHP6AXXZ@Z endp
.text$mn:000062CF
.text$mn:000062CF ; ---------------------------------------------------------------------------
.text$mn:000062D2                 align 4
.text$mn:000062D2 _text$mn        ends
.text$mn:000062D2
.text$x:000062D4 ; ===========================================================================
.text$x:000062D4
.text$x:000062D4 ; Segment type: Pure code
.text$x:000062D4 ; Segment permissions: Read/Execute
.text$x:000062D4 _text$x         segment para public 'CODE' use32
.text$x:000062D4                 assume cs:_text$x
.text$x:000062D4                 ;org 62D4h
.text$x:000062D4 ; COMDAT (pick associative to section at 626C)
.text$x:000062D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000062D4
.text$x:000062D4 ; =============== S U B R O U T I N E =======================================
.text$x:000062D4
.text$x:000062D4
.text$x:000062D4 __unwindfunclet$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z$0 proc near
.text$x:000062D4                                         ; DATA XREF: .xdata$x:0000CF94o
.text$x:000062D4                 mov     ecx, [ebp-10h]
.text$x:000062D7                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000062D7 __unwindfunclet$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z$0 endp
.text$x:000062D7
.text$x:000062DC
.text$x:000062DC ; =============== S U B R O U T I N E =======================================
.text$x:000062DC
.text$x:000062DC
.text$x:000062DC __ehhandler$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z proc near
.text$x:000062DC                                         ; DATA XREF: PluginCommand::PluginCommand(wchar_t const *,int,void (*)(void))+5o
.text$x:000062DC
.text$x:000062DC arg_4           = dword ptr  8
.text$x:000062DC
.text$x:000062DC                 mov     edx, [esp+arg_4]
.text$x:000062E0                 lea     eax, [edx+0Ch]
.text$x:000062E3                 mov     ecx, [edx-8]
.text$x:000062E6                 xor     ecx, eax
.text$x:000062E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000062ED                 mov     eax, offset __ehfuncinfo$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z
.text$x:000062F2                 jmp     ___CxxFrameHandler3
.text$x:000062F2 __ehhandler$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z endp
.text$x:000062F2
.text$x:000062F2 ; ---------------------------------------------------------------------------
.text$x:000062F7                 align 4
.text$x:000062F7 _text$x         ends
.text$x:000062F7
.text$mn:000062F8 ; ===========================================================================
.text$mn:000062F8
.text$mn:000062F8 ; Segment type: Pure code
.text$mn:000062F8 ; Segment permissions: Read/Execute
.text$mn:000062F8 _text$mn        segment para public 'CODE' use32
.text$mn:000062F8                 assume cs:_text$mn
.text$mn:000062F8                 ;org 62F8h
.text$mn:000062F8 ; COMDAT (pick any)
.text$mn:000062F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000062F8
.text$mn:000062F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000062F8
.text$mn:000062F8 ; Attributes: bp-based frame
.text$mn:000062F8
.text$mn:000062F8 ; _DWORD __thiscall PluginInfo::PluginInfo(PluginInfo *__hidden this)
.text$mn:000062F8                 public ??0PluginInfo@@QAE@XZ
.text$mn:000062F8 ??0PluginInfo@@QAE@XZ proc near         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+8Ep
.text$mn:000062F8
.text$mn:000062F8 var_10          = dword ptr -10h
.text$mn:000062F8 var_C           = dword ptr -0Ch
.text$mn:000062F8 var_4           = dword ptr -4
.text$mn:000062F8
.text$mn:000062F8                 push    ebp
.text$mn:000062F9                 mov     ebp, esp
.text$mn:000062FB                 push    0FFFFFFFFh
.text$mn:000062FD                 push    offset __ehhandler$??0PluginInfo@@QAE@XZ
.text$mn:00006302                 mov     eax, large fs:0
.text$mn:00006308                 push    eax
.text$mn:00006309                 push    ecx
.text$mn:0000630A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000630F                 xor     eax, ebp
.text$mn:00006311                 push    eax
.text$mn:00006312                 lea     eax, [ebp+var_C]
.text$mn:00006315                 mov     large fs:0, eax
.text$mn:0000631B                 mov     [ebp+var_10], ecx
.text$mn:0000631E                 mov     eax, [ebp+var_10]
.text$mn:00006321                 mov     dword ptr [eax], 0
.text$mn:00006327                 mov     ecx, [ebp+var_10]
.text$mn:0000632A                 mov     dword ptr [ecx+4], 0
.text$mn:00006331                 mov     edx, [ebp+var_10]
.text$mn:00006334                 mov     dword ptr [edx+8], 0
.text$mn:0000633B                 mov     eax, [ebp+var_10]
.text$mn:0000633E                 mov     dword ptr [eax+0Ch], 0
.text$mn:00006345                 mov     ecx, [ebp+var_10]
.text$mn:00006348                 mov     dword ptr [ecx+14h], 0
.text$mn:0000634F                 mov     edx, [ebp+var_10]
.text$mn:00006352                 mov     dword ptr [edx+20h], 0
.text$mn:00006359                 mov     eax, [ebp+var_10]
.text$mn:0000635C                 mov     dword ptr [eax+24h], 0
.text$mn:00006363                 mov     ecx, [ebp+var_10]
.text$mn:00006366                 add     ecx, 28h ; '('
.text$mn:00006369                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000636E                 mov     [ebp+var_4], 0
.text$mn:00006375                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000637C                 mov     eax, [ebp+var_10]
.text$mn:0000637F                 mov     ecx, [ebp+var_C]
.text$mn:00006382                 mov     large fs:0, ecx
.text$mn:00006389                 pop     ecx
.text$mn:0000638A                 mov     esp, ebp
.text$mn:0000638C                 pop     ebp
.text$mn:0000638D                 retn
.text$mn:0000638D ??0PluginInfo@@QAE@XZ endp
.text$mn:0000638D
.text$mn:0000638D ; ---------------------------------------------------------------------------
.text$mn:0000638E                 align 10h
.text$mn:0000638E _text$mn        ends
.text$mn:0000638E
.text$x:00006390 ; ===========================================================================
.text$x:00006390
.text$x:00006390 ; Segment type: Pure code
.text$x:00006390 ; Segment permissions: Read/Execute
.text$x:00006390 _text$x         segment para public 'CODE' use32
.text$x:00006390                 assume cs:_text$x
.text$x:00006390                 ;org 6390h
.text$x:00006390 ; COMDAT (pick associative to section at 62F8)
.text$x:00006390                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006390
.text$x:00006390 ; =============== S U B R O U T I N E =======================================
.text$x:00006390
.text$x:00006390
.text$x:00006390 __unwindfunclet$??0PluginInfo@@QAE@XZ$0 proc near
.text$x:00006390                                         ; DATA XREF: .xdata$x:0000D018o
.text$x:00006390                 mov     ecx, [ebp-10h]
.text$x:00006393                 add     ecx, 28h ; '('
.text$x:00006396                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006396 __unwindfunclet$??0PluginInfo@@QAE@XZ$0 endp
.text$x:00006396
.text$x:0000639B
.text$x:0000639B ; =============== S U B R O U T I N E =======================================
.text$x:0000639B
.text$x:0000639B
.text$x:0000639B __ehhandler$??0PluginInfo@@QAE@XZ proc near
.text$x:0000639B                                         ; DATA XREF: PluginInfo::PluginInfo(void)+5o
.text$x:0000639B
.text$x:0000639B arg_4           = dword ptr  8
.text$x:0000639B
.text$x:0000639B                 mov     edx, [esp+arg_4]
.text$x:0000639F                 lea     eax, [edx+0Ch]
.text$x:000063A2                 mov     ecx, [edx-8]
.text$x:000063A5                 xor     ecx, eax
.text$x:000063A7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000063AC                 mov     eax, offset __ehfuncinfo$??0PluginInfo@@QAE@XZ
.text$x:000063B1                 jmp     ___CxxFrameHandler3
.text$x:000063B1 __ehhandler$??0PluginInfo@@QAE@XZ endp
.text$x:000063B1
.text$x:000063B1 ; ---------------------------------------------------------------------------
.text$x:000063B6                 align 4
.text$x:000063B6 _text$x         ends
.text$x:000063B6
.text$mn:000063B8 ; ===========================================================================
.text$mn:000063B8
.text$mn:000063B8 ; Segment type: Pure code
.text$mn:000063B8 ; Segment permissions: Read/Execute
.text$mn:000063B8 _text$mn        segment para public 'CODE' use32
.text$mn:000063B8                 assume cs:_text$mn
.text$mn:000063B8                 ;org 63B8h
.text$mn:000063B8 ; COMDAT (pick any)
.text$mn:000063B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000063B8
.text$mn:000063B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000063B8
.text$mn:000063B8 ; Attributes: bp-based frame
.text$mn:000063B8
.text$mn:000063B8 ; int __stdcall Shortcut::Shortcut(Shortcut *)
.text$mn:000063B8                 public ??0Shortcut@@QAE@ABV0@@Z
.text$mn:000063B8 ??0Shortcut@@QAE@ABV0@@Z proc near      ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+426p
.text$mn:000063B8                                         ; CommandShortcut::CommandShortcut(CommandShortcut const &)+2Dp ...
.text$mn:000063B8
.text$mn:000063B8 var_10          = dword ptr -10h
.text$mn:000063B8 var_C           = dword ptr -0Ch
.text$mn:000063B8 var_4           = dword ptr -4
.text$mn:000063B8 arg_0           = dword ptr  8
.text$mn:000063B8
.text$mn:000063B8                 push    ebp
.text$mn:000063B9                 mov     ebp, esp
.text$mn:000063BB                 push    0FFFFFFFFh
.text$mn:000063BD                 push    offset __ehhandler$??0Shortcut@@QAE@ABV0@@Z
.text$mn:000063C2                 mov     eax, large fs:0
.text$mn:000063C8                 push    eax
.text$mn:000063C9                 push    ecx
.text$mn:000063CA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000063CF                 xor     eax, ebp
.text$mn:000063D1                 push    eax
.text$mn:000063D2                 lea     eax, [ebp+var_C]
.text$mn:000063D5                 mov     large fs:0, eax
.text$mn:000063DB                 mov     [ebp+var_10], ecx
.text$mn:000063DE                 mov     ecx, [ebp+var_10]
.text$mn:000063E1                 call    ??0StaticDialog@@QAE@XZ ; StaticDialog::StaticDialog(void)
.text$mn:000063E6                 mov     [ebp+var_4], 0
.text$mn:000063ED                 mov     eax, [ebp+var_10]
.text$mn:000063F0                 mov     dword ptr [eax], offset ??_7Shortcut@@6B@ ; const Shortcut::`vftable'
.text$mn:000063F6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000063F9                 call    ?getMenuName@Shortcut@@QBEPB_WXZ ; Shortcut::getMenuName(void)
.text$mn:000063FE                 push    eax             ; wchar_t *
.text$mn:000063FF                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006402                 call    ?setName@Shortcut@@QAEXPB_W@Z ; Shortcut::setName(wchar_t const *)
.text$mn:00006407                 mov     ecx, [ebp+arg_0]
.text$mn:0000640A                 mov     edx, [ecx+20h]
.text$mn:0000640D                 mov     eax, [ebp+var_10]
.text$mn:00006410                 mov     [eax+20h], edx
.text$mn:00006413                 mov     ecx, [ebp+var_10]
.text$mn:00006416                 mov     edx, [ebp+arg_0]
.text$mn:00006419                 mov     al, [edx+24h]
.text$mn:0000641C                 mov     [ecx+24h], al
.text$mn:0000641F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006426                 mov     eax, [ebp+var_10]
.text$mn:00006429                 mov     ecx, [ebp+var_C]
.text$mn:0000642C                 mov     large fs:0, ecx
.text$mn:00006433                 pop     ecx
.text$mn:00006434                 mov     esp, ebp
.text$mn:00006436                 pop     ebp
.text$mn:00006437                 retn    4
.text$mn:00006437 ??0Shortcut@@QAE@ABV0@@Z endp
.text$mn:00006437
.text$mn:00006437 ; ---------------------------------------------------------------------------
.text$mn:0000643A                 align 4
.text$mn:0000643A _text$mn        ends
.text$mn:0000643A
.text$x:0000643C ; ===========================================================================
.text$x:0000643C
.text$x:0000643C ; Segment type: Pure code
.text$x:0000643C ; Segment permissions: Read/Execute
.text$x:0000643C _text$x         segment para public 'CODE' use32
.text$x:0000643C                 assume cs:_text$x
.text$x:0000643C                 ;org 643Ch
.text$x:0000643C ; COMDAT (pick associative to section at 63B8)
.text$x:0000643C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000643C
.text$x:0000643C ; =============== S U B R O U T I N E =======================================
.text$x:0000643C
.text$x:0000643C
.text$x:0000643C __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0 proc near
.text$x:0000643C                                         ; DATA XREF: .xdata$x:0000C9DCo
.text$x:0000643C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000643F                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:0000643F __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0 endp
.text$x:0000643F
.text$x:00006444
.text$x:00006444 ; =============== S U B R O U T I N E =======================================
.text$x:00006444
.text$x:00006444
.text$x:00006444 __ehhandler$??0Shortcut@@QAE@ABV0@@Z proc near
.text$x:00006444                                         ; DATA XREF: Shortcut::Shortcut(Shortcut const &)+5o
.text$x:00006444
.text$x:00006444 arg_4           = dword ptr  8
.text$x:00006444
.text$x:00006444                 mov     edx, [esp+arg_4]
.text$x:00006448                 lea     eax, [edx+0Ch]
.text$x:0000644B                 mov     ecx, [edx-8]
.text$x:0000644E                 xor     ecx, eax
.text$x:00006450                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006455                 mov     eax, offset __ehfuncinfo$??0Shortcut@@QAE@ABV0@@Z
.text$x:0000645A                 jmp     ___CxxFrameHandler3
.text$x:0000645A __ehhandler$??0Shortcut@@QAE@ABV0@@Z endp
.text$x:0000645A
.text$x:0000645A ; ---------------------------------------------------------------------------
.text$x:0000645F                 align 10h
.text$x:0000645F _text$x         ends
.text$x:0000645F
.text$mn:00006460 ; ===========================================================================
.text$mn:00006460
.text$mn:00006460 ; Segment type: Pure code
.text$mn:00006460 ; Segment permissions: Read/Execute
.text$mn:00006460 _text$mn        segment para public 'CODE' use32
.text$mn:00006460                 assume cs:_text$mn
.text$mn:00006460                 ;org 6460h
.text$mn:00006460 ; COMDAT (pick any)
.text$mn:00006460                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006460
.text$mn:00006460 ; =============== S U B R O U T I N E =======================================
.text$mn:00006460
.text$mn:00006460 ; Attributes: bp-based frame
.text$mn:00006460
.text$mn:00006460 ; int __stdcall Shortcut::Shortcut(wchar_t *, char, char, char, char)
.text$mn:00006460                 public ??0Shortcut@@QAE@PB_W_N11E@Z
.text$mn:00006460 ??0Shortcut@@QAE@PB_W_N11E@Z proc near  ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+31Ep
.text$mn:00006460                                         ; PluginsManager::addInMenuFromPMIndex(int)+3DCp
.text$mn:00006460
.text$mn:00006460 var_10          = dword ptr -10h
.text$mn:00006460 var_C           = dword ptr -0Ch
.text$mn:00006460 var_4           = dword ptr -4
.text$mn:00006460 arg_0           = dword ptr  8
.text$mn:00006460 arg_4           = byte ptr  0Ch
.text$mn:00006460 arg_8           = byte ptr  10h
.text$mn:00006460 arg_C           = byte ptr  14h
.text$mn:00006460 arg_10          = byte ptr  18h
.text$mn:00006460
.text$mn:00006460                 push    ebp
.text$mn:00006461                 mov     ebp, esp
.text$mn:00006463                 push    0FFFFFFFFh
.text$mn:00006465                 push    offset __ehhandler$??0Shortcut@@QAE@PB_W_N11E@Z
.text$mn:0000646A                 mov     eax, large fs:0
.text$mn:00006470                 push    eax
.text$mn:00006471                 push    ecx
.text$mn:00006472                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006477                 xor     eax, ebp
.text$mn:00006479                 push    eax
.text$mn:0000647A                 lea     eax, [ebp+var_C]
.text$mn:0000647D                 mov     large fs:0, eax
.text$mn:00006483                 mov     [ebp+var_10], ecx
.text$mn:00006486                 mov     ecx, [ebp+var_10]
.text$mn:00006489                 call    ??0StaticDialog@@QAE@XZ ; StaticDialog::StaticDialog(void)
.text$mn:0000648E                 mov     [ebp+var_4], 0
.text$mn:00006495                 mov     eax, [ebp+var_10]
.text$mn:00006498                 mov     dword ptr [eax], offset ??_7Shortcut@@6B@ ; const Shortcut::`vftable'
.text$mn:0000649E                 mov     ecx, [ebp+var_10]
.text$mn:000064A1                 mov     byte ptr [ecx+24h], 0
.text$mn:000064A5                 mov     edx, 2
.text$mn:000064AA                 imul    eax, edx, 0
.text$mn:000064AD                 xor     ecx, ecx
.text$mn:000064AF                 mov     edx, [ebp+var_10]
.text$mn:000064B2                 mov     [edx+eax+26h], cx
.text$mn:000064B7                 cmp     [ebp+arg_0], 0
.text$mn:000064BB                 jz      short loc_64CB
.text$mn:000064BD                 mov     eax, [ebp+arg_0]
.text$mn:000064C0                 push    eax             ; wchar_t *
.text$mn:000064C1                 mov     ecx, [ebp+var_10] ; this
.text$mn:000064C4                 call    ?setName@Shortcut@@QAEXPB_W@Z ; Shortcut::setName(wchar_t const *)
.text$mn:000064C9                 jmp     short loc_64D8
.text$mn:000064CB ; ---------------------------------------------------------------------------
.text$mn:000064CB
.text$mn:000064CB loc_64CB:                               ; CODE XREF: Shortcut::Shortcut(wchar_t const *,bool,bool,bool,uchar)+5Bj
.text$mn:000064CB                 push    offset ??_C@_11LOCGONAA@?$AA?$AA@ ; wchar_t *
.text$mn:000064D0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000064D3                 call    ?setName@Shortcut@@QAEXPB_W@Z ; Shortcut::setName(wchar_t const *)
.text$mn:000064D8
.text$mn:000064D8 loc_64D8:                               ; CODE XREF: Shortcut::Shortcut(wchar_t const *,bool,bool,bool,uchar)+69j
.text$mn:000064D8                 mov     ecx, [ebp+var_10]
.text$mn:000064DB                 mov     dl, [ebp+arg_4]
.text$mn:000064DE                 mov     [ecx+20h], dl
.text$mn:000064E1                 mov     eax, [ebp+var_10]
.text$mn:000064E4                 mov     cl, [ebp+arg_8]
.text$mn:000064E7                 mov     [eax+21h], cl
.text$mn:000064EA                 mov     edx, [ebp+var_10]
.text$mn:000064ED                 mov     al, [ebp+arg_C]
.text$mn:000064F0                 mov     [edx+22h], al
.text$mn:000064F3                 mov     ecx, [ebp+var_10]
.text$mn:000064F6                 mov     dl, [ebp+arg_10]
.text$mn:000064F9                 mov     [ecx+23h], dl
.text$mn:000064FC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006503                 mov     eax, [ebp+var_10]
.text$mn:00006506                 mov     ecx, [ebp+var_C]
.text$mn:00006509                 mov     large fs:0, ecx
.text$mn:00006510                 pop     ecx
.text$mn:00006511                 mov     esp, ebp
.text$mn:00006513                 pop     ebp
.text$mn:00006514                 retn    14h
.text$mn:00006514 ??0Shortcut@@QAE@PB_W_N11E@Z endp
.text$mn:00006514
.text$mn:00006514 ; ---------------------------------------------------------------------------
.text$mn:00006517                 align 4
.text$mn:00006517 _text$mn        ends
.text$mn:00006517
.text$x:00006518 ; ===========================================================================
.text$x:00006518
.text$x:00006518 ; Segment type: Pure code
.text$x:00006518 ; Segment permissions: Read/Execute
.text$x:00006518 _text$x         segment para public 'CODE' use32
.text$x:00006518                 assume cs:_text$x
.text$x:00006518                 ;org 6518h
.text$x:00006518 ; COMDAT (pick associative to section at 6460)
.text$x:00006518                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006518
.text$x:00006518 ; =============== S U B R O U T I N E =======================================
.text$x:00006518
.text$x:00006518
.text$x:00006518 __unwindfunclet$??0Shortcut@@QAE@PB_W_N11E@Z$0 proc near
.text$x:00006518                                         ; DATA XREF: .xdata$x:0000C9B0o
.text$x:00006518                 mov     ecx, [ebp-10h]  ; this
.text$x:0000651B                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:0000651B __unwindfunclet$??0Shortcut@@QAE@PB_W_N11E@Z$0 endp
.text$x:0000651B
.text$x:00006520
.text$x:00006520 ; =============== S U B R O U T I N E =======================================
.text$x:00006520
.text$x:00006520
.text$x:00006520 __ehhandler$??0Shortcut@@QAE@PB_W_N11E@Z proc near
.text$x:00006520                                         ; DATA XREF: Shortcut::Shortcut(wchar_t const *,bool,bool,bool,uchar)+5o
.text$x:00006520
.text$x:00006520 arg_4           = dword ptr  8
.text$x:00006520
.text$x:00006520                 mov     edx, [esp+arg_4]
.text$x:00006524                 lea     eax, [edx+0Ch]
.text$x:00006527                 mov     ecx, [edx-8]
.text$x:0000652A                 xor     ecx, eax
.text$x:0000652C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006531                 mov     eax, offset __ehfuncinfo$??0Shortcut@@QAE@PB_W_N11E@Z
.text$x:00006536                 jmp     ___CxxFrameHandler3
.text$x:00006536 __ehhandler$??0Shortcut@@QAE@PB_W_N11E@Z endp
.text$x:00006536
.text$x:00006536 ; ---------------------------------------------------------------------------
.text$x:0000653B                 align 4
.text$x:0000653B _text$x         ends
.text$x:0000653B
.text$mn:0000653C ; ===========================================================================
.text$mn:0000653C
.text$mn:0000653C ; Segment type: Pure code
.text$mn:0000653C ; Segment permissions: Read/Execute
.text$mn:0000653C _text$mn        segment para public 'CODE' use32
.text$mn:0000653C                 assume cs:_text$mn
.text$mn:0000653C                 ;org 653Ch
.text$mn:0000653C ; COMDAT (pick any)
.text$mn:0000653C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000653C
.text$mn:0000653C ; =============== S U B R O U T I N E =======================================
.text$mn:0000653C
.text$mn:0000653C ; Attributes: bp-based frame
.text$mn:0000653C
.text$mn:0000653C ; public: __thiscall StaticDialog::StaticDialog(void)
.text$mn:0000653C                 public ??0StaticDialog@@QAE@XZ
.text$mn:0000653C ??0StaticDialog@@QAE@XZ proc near       ; CODE XREF: Shortcut::Shortcut(Shortcut const &)+29p
.text$mn:0000653C                                         ; Shortcut::Shortcut(wchar_t const *,bool,bool,bool,uchar)+29p
.text$mn:0000653C
.text$mn:0000653C var_10          = dword ptr -10h
.text$mn:0000653C var_C           = dword ptr -0Ch
.text$mn:0000653C var_4           = dword ptr -4
.text$mn:0000653C
.text$mn:0000653C                 push    ebp
.text$mn:0000653D                 mov     ebp, esp
.text$mn:0000653F                 push    0FFFFFFFFh
.text$mn:00006541                 push    offset __ehhandler$??0StaticDialog@@QAE@XZ
.text$mn:00006546                 mov     eax, large fs:0
.text$mn:0000654C                 push    eax
.text$mn:0000654D                 push    ecx
.text$mn:0000654E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006553                 xor     eax, ebp
.text$mn:00006555                 push    eax
.text$mn:00006556                 lea     eax, [ebp+var_C]
.text$mn:00006559                 mov     large fs:0, eax
.text$mn:0000655F                 mov     [ebp+var_10], ecx
.text$mn:00006562                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006565                 call    ??0Window@@QAE@XZ ; Window::Window(void)
.text$mn:0000656A                 mov     [ebp+var_4], 0
.text$mn:00006571                 mov     eax, [ebp+var_10]
.text$mn:00006574                 mov     dword ptr [eax], offset ??_7StaticDialog@@6B@ ; const StaticDialog::`vftable'
.text$mn:0000657A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006581                 mov     eax, [ebp+var_10]
.text$mn:00006584                 mov     ecx, [ebp+var_C]
.text$mn:00006587                 mov     large fs:0, ecx
.text$mn:0000658E                 pop     ecx
.text$mn:0000658F                 mov     esp, ebp
.text$mn:00006591                 pop     ebp
.text$mn:00006592                 retn
.text$mn:00006592 ??0StaticDialog@@QAE@XZ endp
.text$mn:00006592
.text$mn:00006592 ; ---------------------------------------------------------------------------
.text$mn:00006593                 align 4
.text$mn:00006593 _text$mn        ends
.text$mn:00006593
.text$x:00006594 ; ===========================================================================
.text$x:00006594
.text$x:00006594 ; Segment type: Pure code
.text$x:00006594 ; Segment permissions: Read/Execute
.text$x:00006594 _text$x         segment para public 'CODE' use32
.text$x:00006594                 assume cs:_text$x
.text$x:00006594                 ;org 6594h
.text$x:00006594 ; COMDAT (pick associative to section at 653C)
.text$x:00006594                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006594
.text$x:00006594 ; =============== S U B R O U T I N E =======================================
.text$x:00006594
.text$x:00006594
.text$x:00006594 __unwindfunclet$??0StaticDialog@@QAE@XZ$0 proc near
.text$x:00006594                                         ; DATA XREF: .xdata$x:0000C958o
.text$x:00006594                 mov     ecx, [ebp-10h]  ; this
.text$x:00006597                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:00006597 __unwindfunclet$??0StaticDialog@@QAE@XZ$0 endp
.text$x:00006597
.text$x:0000659C
.text$x:0000659C ; =============== S U B R O U T I N E =======================================
.text$x:0000659C
.text$x:0000659C
.text$x:0000659C __ehhandler$??0StaticDialog@@QAE@XZ proc near
.text$x:0000659C                                         ; DATA XREF: StaticDialog::StaticDialog(void)+5o
.text$x:0000659C
.text$x:0000659C arg_4           = dword ptr  8
.text$x:0000659C
.text$x:0000659C                 mov     edx, [esp+arg_4]
.text$x:000065A0                 lea     eax, [edx+0Ch]
.text$x:000065A3                 mov     ecx, [edx-8]
.text$x:000065A6                 xor     ecx, eax
.text$x:000065A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000065AD                 mov     eax, offset __ehfuncinfo$??0StaticDialog@@QAE@XZ
.text$x:000065B2                 jmp     ___CxxFrameHandler3
.text$x:000065B2 __ehhandler$??0StaticDialog@@QAE@XZ endp
.text$x:000065B2
.text$x:000065B2 ; ---------------------------------------------------------------------------
.text$x:000065B7                 align 4
.text$x:000065B7 _text$x         ends
.text$x:000065B7
.text$mn:000065B8 ; ===========================================================================
.text$mn:000065B8
.text$mn:000065B8 ; Segment type: Pure code
.text$mn:000065B8 ; Segment permissions: Read/Execute
.text$mn:000065B8 _text$mn        segment para public 'CODE' use32
.text$mn:000065B8                 assume cs:_text$mn
.text$mn:000065B8                 ;org 65B8h
.text$mn:000065B8 ; COMDAT (pick any)
.text$mn:000065B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000065B8
.text$mn:000065B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000065B8
.text$mn:000065B8 ; Attributes: bp-based frame
.text$mn:000065B8
.text$mn:000065B8 ; _DWORD __thiscall Window::Window(Window *__hidden this)
.text$mn:000065B8                 public ??0Window@@QAE@XZ
.text$mn:000065B8 ??0Window@@QAE@XZ proc near             ; CODE XREF: StaticDialog::StaticDialog(void)+29p
.text$mn:000065B8
.text$mn:000065B8 var_4           = dword ptr -4
.text$mn:000065B8
.text$mn:000065B8                 push    ebp
.text$mn:000065B9                 mov     ebp, esp
.text$mn:000065BB                 push    ecx
.text$mn:000065BC                 mov     [ebp+var_4], ecx
.text$mn:000065BF                 mov     eax, [ebp+var_4]
.text$mn:000065C2                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:000065C8                 mov     ecx, [ebp+var_4]
.text$mn:000065CB                 mov     dword ptr [ecx+4], 0
.text$mn:000065D2                 mov     edx, [ebp+var_4]
.text$mn:000065D5                 mov     dword ptr [edx+8], 0
.text$mn:000065DC                 mov     eax, [ebp+var_4]
.text$mn:000065DF                 mov     dword ptr [eax+0Ch], 0
.text$mn:000065E6                 mov     eax, [ebp+var_4]
.text$mn:000065E9                 mov     esp, ebp
.text$mn:000065EB                 pop     ebp
.text$mn:000065EC                 retn
.text$mn:000065EC ??0Window@@QAE@XZ endp
.text$mn:000065EC
.text$mn:000065EC ; ---------------------------------------------------------------------------
.text$mn:000065ED                 align 10h
.text$mn:000065ED _text$mn        ends
.text$mn:000065ED
.text$mn:000065F0 ; ===========================================================================
.text$mn:000065F0
.text$mn:000065F0 ; Segment type: Pure code
.text$mn:000065F0 ; Segment permissions: Read/Execute
.text$mn:000065F0 _text$mn        segment para public 'CODE' use32
.text$mn:000065F0                 assume cs:_text$mn
.text$mn:000065F0                 ;org 65F0h
.text$mn:000065F0 ; COMDAT (pick any)
.text$mn:000065F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000065F0
.text$mn:000065F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000065F0
.text$mn:000065F0 ; Attributes: bp-based frame
.text$mn:000065F0
.text$mn:000065F0 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *this, const struct std::_Container_base12 *)
.text$mn:000065F0                 public ??0_Container_base12@std@@QAE@ABU01@@Z
.text$mn:000065F0 ??0_Container_base12@std@@QAE@ABU01@@Z proc near
.text$mn:000065F0                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(std::_String_val<std::_Simple_types<wchar_t>> const &)+2Dp
.text$mn:000065F0                                         ; DATA XREF: .xdata$x:0000DDA8o
.text$mn:000065F0
.text$mn:000065F0 var_4           = dword ptr -4
.text$mn:000065F0
.text$mn:000065F0                 push    ebp
.text$mn:000065F1                 mov     ebp, esp
.text$mn:000065F3                 push    ecx
.text$mn:000065F4                 mov     [ebp+var_4], ecx
.text$mn:000065F7                 mov     eax, [ebp+var_4]
.text$mn:000065FA                 mov     dword ptr [eax], 0
.text$mn:00006600                 mov     eax, [ebp+var_4]
.text$mn:00006603                 mov     esp, ebp
.text$mn:00006605                 pop     ebp
.text$mn:00006606                 retn    4
.text$mn:00006606 ??0_Container_base12@std@@QAE@ABU01@@Z endp
.text$mn:00006606
.text$mn:00006606 ; ---------------------------------------------------------------------------
.text$mn:00006609                 align 4
.text$mn:00006609 _text$mn        ends
.text$mn:00006609
.text$mn:0000660C ; ===========================================================================
.text$mn:0000660C
.text$mn:0000660C ; Segment type: Pure code
.text$mn:0000660C ; Segment permissions: Read/Execute
.text$mn:0000660C _text$mn        segment para public 'CODE' use32
.text$mn:0000660C                 assume cs:_text$mn
.text$mn:0000660C                 ;org 660Ch
.text$mn:0000660C ; COMDAT (pick any)
.text$mn:0000660C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000660C
.text$mn:0000660C ; =============== S U B R O U T I N E =======================================
.text$mn:0000660C
.text$mn:0000660C ; Attributes: bp-based frame
.text$mn:0000660C
.text$mn:0000660C ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000660C                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:0000660C ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:0000660C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:0000660C                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p ...
.text$mn:0000660C
.text$mn:0000660C var_4           = dword ptr -4
.text$mn:0000660C
.text$mn:0000660C                 push    ebp
.text$mn:0000660D                 mov     ebp, esp
.text$mn:0000660F                 push    ecx
.text$mn:00006610                 mov     [ebp+var_4], ecx
.text$mn:00006613                 mov     eax, [ebp+var_4]
.text$mn:00006616                 mov     dword ptr [eax], 0
.text$mn:0000661C                 mov     eax, [ebp+var_4]
.text$mn:0000661F                 mov     esp, ebp
.text$mn:00006621                 pop     ebp
.text$mn:00006622                 retn
.text$mn:00006622 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00006622
.text$mn:00006622 ; ---------------------------------------------------------------------------
.text$mn:00006623                 align 4
.text$mn:00006623 _text$mn        ends
.text$mn:00006623
.text$mn:00006624 ; ===========================================================================
.text$mn:00006624
.text$mn:00006624 ; Segment type: Pure code
.text$mn:00006624 ; Segment permissions: Read/Execute
.text$mn:00006624 _text$mn        segment para public 'CODE' use32
.text$mn:00006624                 assume cs:_text$mn
.text$mn:00006624                 ;org 6624h
.text$mn:00006624 ; COMDAT (pick any)
.text$mn:00006624                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006624
.text$mn:00006624 ; =============== S U B R O U T I N E =======================================
.text$mn:00006624
.text$mn:00006624 ; Attributes: bp-based frame
.text$mn:00006624
.text$mn:00006624 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00006624                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00006624 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00006624                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00006624                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p ...
.text$mn:00006624
.text$mn:00006624 var_4           = dword ptr -4
.text$mn:00006624
.text$mn:00006624                 push    ebp
.text$mn:00006625                 mov     ebp, esp
.text$mn:00006627                 push    ecx
.text$mn:00006628                 mov     [ebp+var_4], ecx
.text$mn:0000662B                 mov     eax, [ebp+var_4]
.text$mn:0000662E                 mov     dword ptr [eax], 0
.text$mn:00006634                 mov     ecx, [ebp+var_4]
.text$mn:00006637                 mov     dword ptr [ecx+4], 0
.text$mn:0000663E                 mov     eax, [ebp+var_4]
.text$mn:00006641                 mov     esp, ebp
.text$mn:00006643                 pop     ebp
.text$mn:00006644                 retn
.text$mn:00006644 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00006644
.text$mn:00006644 ; ---------------------------------------------------------------------------
.text$mn:00006645                 align 4
.text$mn:00006645 _text$mn        ends
.text$mn:00006645
.text$mn:00006648 ; ===========================================================================
.text$mn:00006648
.text$mn:00006648 ; Segment type: Pure code
.text$mn:00006648 ; Segment permissions: Read/Execute
.text$mn:00006648 _text$mn        segment para public 'CODE' use32
.text$mn:00006648                 assume cs:_text$mn
.text$mn:00006648                 ;org 6648h
.text$mn:00006648 ; COMDAT (pick any)
.text$mn:00006648                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006648
.text$mn:00006648 ; =============== S U B R O U T I N E =======================================
.text$mn:00006648
.text$mn:00006648 ; Attributes: bp-based frame
.text$mn:00006648
.text$mn:00006648 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00006648                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00006648 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00006648                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00006648                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00006648
.text$mn:00006648 var_10          = dword ptr -10h
.text$mn:00006648 var_C           = dword ptr -0Ch
.text$mn:00006648 var_4           = dword ptr -4
.text$mn:00006648
.text$mn:00006648                 push    ebp
.text$mn:00006649                 mov     ebp, esp
.text$mn:0000664B                 push    0FFFFFFFFh
.text$mn:0000664D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00006652                 mov     eax, large fs:0
.text$mn:00006658                 push    eax
.text$mn:00006659                 push    ecx
.text$mn:0000665A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000665F                 xor     eax, ebp
.text$mn:00006661                 push    eax
.text$mn:00006662                 lea     eax, [ebp+var_C]
.text$mn:00006665                 mov     large fs:0, eax
.text$mn:0000666B                 mov     [ebp+var_10], ecx
.text$mn:0000666E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006671                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00006676                 mov     [ebp+var_4], 0
.text$mn:0000667D                 mov     eax, [ebp+var_10]
.text$mn:00006680                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00006686                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000668D                 mov     eax, [ebp+var_10]
.text$mn:00006690                 mov     ecx, [ebp+var_C]
.text$mn:00006693                 mov     large fs:0, ecx
.text$mn:0000669A                 pop     ecx
.text$mn:0000669B                 mov     esp, ebp
.text$mn:0000669D                 pop     ebp
.text$mn:0000669E                 retn
.text$mn:0000669E ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:0000669E
.text$mn:0000669E ; ---------------------------------------------------------------------------
.text$mn:0000669F                 align 10h
.text$mn:0000669F _text$mn        ends
.text$mn:0000669F
.text$x:000066A0 ; ===========================================================================
.text$x:000066A0
.text$x:000066A0 ; Segment type: Pure code
.text$x:000066A0 ; Segment permissions: Read/Execute
.text$x:000066A0 _text$x         segment para public 'CODE' use32
.text$x:000066A0                 assume cs:_text$x
.text$x:000066A0                 ;org 66A0h
.text$x:000066A0 ; COMDAT (pick associative to section at 6648)
.text$x:000066A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000066A0
.text$x:000066A0 ; =============== S U B R O U T I N E =======================================
.text$x:000066A0
.text$x:000066A0
.text$x:000066A0 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000066A0                                         ; DATA XREF: .xdata$x:0000C55Co
.text$x:000066A0                 mov     ecx, [ebp-10h]  ; this
.text$x:000066A3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000066A3 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000066A3
.text$x:000066A8
.text$x:000066A8 ; =============== S U B R O U T I N E =======================================
.text$x:000066A8
.text$x:000066A8
.text$x:000066A8 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000066A8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000066A8
.text$x:000066A8 arg_4           = dword ptr  8
.text$x:000066A8
.text$x:000066A8                 mov     edx, [esp+arg_4]
.text$x:000066AC                 lea     eax, [edx+0Ch]
.text$x:000066AF                 mov     ecx, [edx-8]
.text$x:000066B2                 xor     ecx, eax
.text$x:000066B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000066B9                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000066BE                 jmp     ___CxxFrameHandler3
.text$x:000066BE __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000066BE
.text$x:000066BE ; ---------------------------------------------------------------------------
.text$x:000066C3                 align 4
.text$x:000066C3 _text$x         ends
.text$x:000066C3
.text$mn:000066C4 ; ===========================================================================
.text$mn:000066C4
.text$mn:000066C4 ; Segment type: Pure code
.text$mn:000066C4 ; Segment permissions: Read/Execute
.text$mn:000066C4 _text$mn        segment para public 'CODE' use32
.text$mn:000066C4                 assume cs:_text$mn
.text$mn:000066C4                 ;org 66C4h
.text$mn:000066C4 ; COMDAT (pick any)
.text$mn:000066C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000066C4
.text$mn:000066C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000066C4
.text$mn:000066C4 ; Attributes: bp-based frame
.text$mn:000066C4
.text$mn:000066C4 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000066C4                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000066C4 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000066C4                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000066C4
.text$mn:000066C4 var_10          = dword ptr -10h
.text$mn:000066C4 var_C           = dword ptr -0Ch
.text$mn:000066C4 var_4           = dword ptr -4
.text$mn:000066C4
.text$mn:000066C4                 push    ebp
.text$mn:000066C5                 mov     ebp, esp
.text$mn:000066C7                 push    0FFFFFFFFh
.text$mn:000066C9                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000066CE                 mov     eax, large fs:0
.text$mn:000066D4                 push    eax
.text$mn:000066D5                 push    ecx
.text$mn:000066D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000066DB                 xor     eax, ebp
.text$mn:000066DD                 push    eax
.text$mn:000066DE                 lea     eax, [ebp+var_C]
.text$mn:000066E1                 mov     large fs:0, eax
.text$mn:000066E7                 mov     [ebp+var_10], ecx
.text$mn:000066EA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000066ED                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000066F2                 mov     [ebp+var_4], 0
.text$mn:000066F9                 mov     eax, [ebp+var_10]
.text$mn:000066FC                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00006702                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006709                 mov     eax, [ebp+var_10]
.text$mn:0000670C                 mov     ecx, [ebp+var_C]
.text$mn:0000670F                 mov     large fs:0, ecx
.text$mn:00006716                 pop     ecx
.text$mn:00006717                 mov     esp, ebp
.text$mn:00006719                 pop     ebp
.text$mn:0000671A                 retn
.text$mn:0000671A ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:0000671A
.text$mn:0000671A ; ---------------------------------------------------------------------------
.text$mn:0000671B                 align 4
.text$mn:0000671B _text$mn        ends
.text$mn:0000671B
.text$x:0000671C ; ===========================================================================
.text$x:0000671C
.text$x:0000671C ; Segment type: Pure code
.text$x:0000671C ; Segment permissions: Read/Execute
.text$x:0000671C _text$x         segment para public 'CODE' use32
.text$x:0000671C                 assume cs:_text$x
.text$x:0000671C                 ;org 671Ch
.text$x:0000671C ; COMDAT (pick associative to section at 66C4)
.text$x:0000671C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000671C
.text$x:0000671C ; =============== S U B R O U T I N E =======================================
.text$x:0000671C
.text$x:0000671C
.text$x:0000671C __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:0000671C                                         ; DATA XREF: .xdata$x:0000C5E0o
.text$x:0000671C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000671F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000671F __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:0000671F
.text$x:00006724
.text$x:00006724 ; =============== S U B R O U T I N E =======================================
.text$x:00006724
.text$x:00006724
.text$x:00006724 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00006724                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00006724
.text$x:00006724 arg_4           = dword ptr  8
.text$x:00006724
.text$x:00006724                 mov     edx, [esp+arg_4]
.text$x:00006728                 lea     eax, [edx+0Ch]
.text$x:0000672B                 mov     ecx, [edx-8]
.text$x:0000672E                 xor     ecx, eax
.text$x:00006730                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006735                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000673A                 jmp     ___CxxFrameHandler3
.text$x:0000673A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000673A
.text$x:0000673A ; ---------------------------------------------------------------------------
.text$x:0000673F                 align 10h
.text$x:0000673F _text$x         ends
.text$x:0000673F
.text$mn:00006740 ; ===========================================================================
.text$mn:00006740
.text$mn:00006740 ; Segment type: Pure code
.text$mn:00006740 ; Segment permissions: Read/Execute
.text$mn:00006740 _text$mn        segment para public 'CODE' use32
.text$mn:00006740                 assume cs:_text$mn
.text$mn:00006740                 ;org 6740h
.text$mn:00006740 ; COMDAT (pick any)
.text$mn:00006740                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006740
.text$mn:00006740 ; =============== S U B R O U T I N E =======================================
.text$mn:00006740
.text$mn:00006740 ; Attributes: bp-based frame
.text$mn:00006740
.text$mn:00006740 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00006740                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00006740 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00006740                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00006740
.text$mn:00006740 var_10          = dword ptr -10h
.text$mn:00006740 var_C           = dword ptr -0Ch
.text$mn:00006740 var_4           = dword ptr -4
.text$mn:00006740
.text$mn:00006740                 push    ebp
.text$mn:00006741                 mov     ebp, esp
.text$mn:00006743                 push    0FFFFFFFFh
.text$mn:00006745                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000674A                 mov     eax, large fs:0
.text$mn:00006750                 push    eax
.text$mn:00006751                 push    ecx
.text$mn:00006752                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006757                 xor     eax, ebp
.text$mn:00006759                 push    eax
.text$mn:0000675A                 lea     eax, [ebp+var_C]
.text$mn:0000675D                 mov     large fs:0, eax
.text$mn:00006763                 mov     [ebp+var_10], ecx
.text$mn:00006766                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006769                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000676E                 mov     [ebp+var_4], 0
.text$mn:00006775                 mov     eax, [ebp+var_10]
.text$mn:00006778                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:0000677E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006785                 mov     eax, [ebp+var_10]
.text$mn:00006788                 mov     ecx, [ebp+var_C]
.text$mn:0000678B                 mov     large fs:0, ecx
.text$mn:00006792                 pop     ecx
.text$mn:00006793                 mov     esp, ebp
.text$mn:00006795                 pop     ebp
.text$mn:00006796                 retn
.text$mn:00006796 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00006796
.text$mn:00006796 ; ---------------------------------------------------------------------------
.text$mn:00006797                 align 4
.text$mn:00006797 _text$mn        ends
.text$mn:00006797
.text$x:00006798 ; ===========================================================================
.text$x:00006798
.text$x:00006798 ; Segment type: Pure code
.text$x:00006798 ; Segment permissions: Read/Execute
.text$x:00006798 _text$x         segment para public 'CODE' use32
.text$x:00006798                 assume cs:_text$x
.text$x:00006798                 ;org 6798h
.text$x:00006798 ; COMDAT (pick associative to section at 6740)
.text$x:00006798                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006798
.text$x:00006798 ; =============== S U B R O U T I N E =======================================
.text$x:00006798
.text$x:00006798
.text$x:00006798 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00006798                                         ; DATA XREF: .xdata$x:0000C664o
.text$x:00006798                 mov     ecx, [ebp-10h]  ; this
.text$x:0000679B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000679B __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:0000679B
.text$x:000067A0
.text$x:000067A0 ; =============== S U B R O U T I N E =======================================
.text$x:000067A0
.text$x:000067A0
.text$x:000067A0 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000067A0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000067A0
.text$x:000067A0 arg_4           = dword ptr  8
.text$x:000067A0
.text$x:000067A0                 mov     edx, [esp+arg_4]
.text$x:000067A4                 lea     eax, [edx+0Ch]
.text$x:000067A7                 mov     ecx, [edx-8]
.text$x:000067AA                 xor     ecx, eax
.text$x:000067AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000067B1                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000067B6                 jmp     ___CxxFrameHandler3
.text$x:000067B6 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000067B6
.text$x:000067B6 ; ---------------------------------------------------------------------------
.text$x:000067BB                 align 4
.text$x:000067BB _text$x         ends
.text$x:000067BB
.text$mn:000067BC ; ===========================================================================
.text$mn:000067BC
.text$mn:000067BC ; Segment type: Pure code
.text$mn:000067BC ; Segment permissions: Read/Execute
.text$mn:000067BC _text$mn        segment para public 'CODE' use32
.text$mn:000067BC                 assume cs:_text$mn
.text$mn:000067BC                 ;org 67BCh
.text$mn:000067BC ; COMDAT (pick any)
.text$mn:000067BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000067BC
.text$mn:000067BC ; =============== S U B R O U T I N E =======================================
.text$mn:000067BC
.text$mn:000067BC ; Attributes: bp-based frame
.text$mn:000067BC
.text$mn:000067BC ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000067BC                 public ??0error_category@std@@QAE@XZ
.text$mn:000067BC ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000067BC
.text$mn:000067BC var_4           = dword ptr -4
.text$mn:000067BC
.text$mn:000067BC                 push    ebp
.text$mn:000067BD                 mov     ebp, esp
.text$mn:000067BF                 push    ecx
.text$mn:000067C0                 mov     [ebp+var_4], ecx
.text$mn:000067C3                 mov     eax, [ebp+var_4]
.text$mn:000067C6                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000067CC                 mov     eax, [ebp+var_4]
.text$mn:000067CF                 mov     esp, ebp
.text$mn:000067D1                 pop     ebp
.text$mn:000067D2                 retn
.text$mn:000067D2 ??0error_category@std@@QAE@XZ endp
.text$mn:000067D2
.text$mn:000067D2 ; ---------------------------------------------------------------------------
.text$mn:000067D3                 align 4
.text$mn:000067D3 _text$mn        ends
.text$mn:000067D3
.text$mn:000067D4 ; ===========================================================================
.text$mn:000067D4
.text$mn:000067D4 ; Segment type: Pure code
.text$mn:000067D4 ; Segment permissions: Read/Execute
.text$mn:000067D4 _text$mn        segment para public 'CODE' use32
.text$mn:000067D4                 assume cs:_text$mn
.text$mn:000067D4                 ;org 67D4h
.text$mn:000067D4 ; COMDAT (pick any)
.text$mn:000067D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000067D4
.text$mn:000067D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000067D4
.text$mn:000067D4 ; Attributes: bp-based frame
.text$mn:000067D4
.text$mn:000067D4 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000067D4                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000067D4 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000067D4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000067D4                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000067D4
.text$mn:000067D4 var_4           = dword ptr -4
.text$mn:000067D4 arg_0           = dword ptr  8
.text$mn:000067D4 arg_4           = dword ptr  0Ch
.text$mn:000067D4
.text$mn:000067D4                 push    ebp
.text$mn:000067D5                 mov     ebp, esp
.text$mn:000067D7                 push    ecx
.text$mn:000067D8                 mov     [ebp+var_4], ecx
.text$mn:000067DB                 mov     eax, [ebp+var_4]
.text$mn:000067DE                 mov     ecx, [ebp+arg_0]
.text$mn:000067E1                 mov     [eax], ecx
.text$mn:000067E3                 mov     edx, [ebp+var_4]
.text$mn:000067E6                 mov     eax, [ebp+arg_4]
.text$mn:000067E9                 mov     [edx+4], eax
.text$mn:000067EC                 mov     eax, [ebp+var_4]
.text$mn:000067EF                 mov     esp, ebp
.text$mn:000067F1                 pop     ebp
.text$mn:000067F2                 retn    8
.text$mn:000067F2 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000067F2
.text$mn:000067F2 ; ---------------------------------------------------------------------------
.text$mn:000067F5                 align 4
.text$mn:000067F5 _text$mn        ends
.text$mn:000067F5
.text$mn:000067F8 ; ===========================================================================
.text$mn:000067F8
.text$mn:000067F8 ; Segment type: Pure code
.text$mn:000067F8 ; Segment permissions: Read/Execute
.text$mn:000067F8 _text$mn        segment para public 'CODE' use32
.text$mn:000067F8                 assume cs:_text$mn
.text$mn:000067F8                 ;org 67F8h
.text$mn:000067F8 ; COMDAT (pick any)
.text$mn:000067F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000067F8
.text$mn:000067F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000067F8
.text$mn:000067F8 ; Attributes: bp-based frame
.text$mn:000067F8
.text$mn:000067F8 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:000067F8                 public ??0id@locale@std@@QAE@I@Z
.text$mn:000067F8 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:000067F8                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:000067F8
.text$mn:000067F8 var_4           = dword ptr -4
.text$mn:000067F8 arg_0           = dword ptr  8
.text$mn:000067F8
.text$mn:000067F8                 push    ebp
.text$mn:000067F9                 mov     ebp, esp
.text$mn:000067FB                 push    ecx
.text$mn:000067FC                 mov     [ebp+var_4], ecx
.text$mn:000067FF                 mov     eax, [ebp+var_4]
.text$mn:00006802                 mov     ecx, [ebp+arg_0]
.text$mn:00006805                 mov     [eax], ecx
.text$mn:00006807                 mov     eax, [ebp+var_4]
.text$mn:0000680A                 mov     esp, ebp
.text$mn:0000680C                 pop     ebp
.text$mn:0000680D                 retn    4
.text$mn:0000680D ??0id@locale@std@@QAE@I@Z endp
.text$mn:0000680D
.text$mn:0000680D _text$mn        ends
.text$mn:0000680D
.text$mn:00006810 ; ===========================================================================
.text$mn:00006810
.text$mn:00006810 ; Segment type: Pure code
.text$mn:00006810 ; Segment permissions: Read/Execute
.text$mn:00006810 _text$mn        segment para public 'CODE' use32
.text$mn:00006810                 assume cs:_text$mn
.text$mn:00006810                 ;org 6810h
.text$mn:00006810 ; COMDAT (pick any)
.text$mn:00006810                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006810
.text$mn:00006810 ; =============== S U B R O U T I N E =======================================
.text$mn:00006810
.text$mn:00006810 ; Attributes: bp-based frame
.text$mn:00006810
.text$mn:00006810 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00006810                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00006810 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006810                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00006810                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00006810
.text$mn:00006810 var_10          = dword ptr -10h
.text$mn:00006810 var_C           = dword ptr -0Ch
.text$mn:00006810 var_4           = dword ptr -4
.text$mn:00006810
.text$mn:00006810                 push    ebp
.text$mn:00006811                 mov     ebp, esp
.text$mn:00006813                 push    0FFFFFFFFh
.text$mn:00006815                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000681A                 mov     eax, large fs:0
.text$mn:00006820                 push    eax
.text$mn:00006821                 push    ecx
.text$mn:00006822                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006827                 xor     eax, ebp
.text$mn:00006829                 push    eax
.text$mn:0000682A                 lea     eax, [ebp+var_C]
.text$mn:0000682D                 mov     large fs:0, eax
.text$mn:00006833                 mov     [ebp+var_10], ecx
.text$mn:00006836                 mov     [ebp+var_4], 0
.text$mn:0000683D                 mov     ecx, [ebp+var_10]
.text$mn:00006840                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00006845                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000684C                 mov     ecx, [ebp+var_10]
.text$mn:0000684F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00006854                 mov     ecx, [ebp+var_C]
.text$mn:00006857                 mov     large fs:0, ecx
.text$mn:0000685E                 pop     ecx
.text$mn:0000685F                 mov     esp, ebp
.text$mn:00006861                 pop     ebp
.text$mn:00006862                 retn
.text$mn:00006862 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006862
.text$mn:00006862 ; ---------------------------------------------------------------------------
.text$mn:00006863                 align 4
.text$mn:00006863 _text$mn        ends
.text$mn:00006863
.text$x:00006864 ; ===========================================================================
.text$x:00006864
.text$x:00006864 ; Segment type: Pure code
.text$x:00006864 ; Segment permissions: Read/Execute
.text$x:00006864 _text$x         segment para public 'CODE' use32
.text$x:00006864                 assume cs:_text$x
.text$x:00006864                 ;org 6864h
.text$x:00006864 ; COMDAT (pick associative to section at 6810)
.text$x:00006864                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006864
.text$x:00006864 ; =============== S U B R O U T I N E =======================================
.text$x:00006864
.text$x:00006864
.text$x:00006864 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006864                                         ; DATA XREF: .xdata$x:0000C44Co
.text$x:00006864                 mov     ecx, [ebp-10h]
.text$x:00006867                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00006867 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006867
.text$x:0000686C
.text$x:0000686C ; =============== S U B R O U T I N E =======================================
.text$x:0000686C
.text$x:0000686C
.text$x:0000686C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000686C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:0000686C
.text$x:0000686C arg_4           = dword ptr  8
.text$x:0000686C
.text$x:0000686C                 mov     edx, [esp+arg_4]
.text$x:00006870                 lea     eax, [edx+0Ch]
.text$x:00006873                 mov     ecx, [edx-8]
.text$x:00006876                 xor     ecx, eax
.text$x:00006878                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000687D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00006882                 jmp     ___CxxFrameHandler3
.text$x:00006882 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00006882
.text$x:00006882 ; ---------------------------------------------------------------------------
.text$x:00006887                 align 4
.text$x:00006887 _text$x         ends
.text$x:00006887
.text$mn:00006888 ; ===========================================================================
.text$mn:00006888
.text$mn:00006888 ; Segment type: Pure code
.text$mn:00006888 ; Segment permissions: Read/Execute
.text$mn:00006888 _text$mn        segment para public 'CODE' use32
.text$mn:00006888                 assume cs:_text$mn
.text$mn:00006888                 ;org 6888h
.text$mn:00006888 ; COMDAT (pick any)
.text$mn:00006888                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006888
.text$mn:00006888 ; =============== S U B R O U T I N E =======================================
.text$mn:00006888
.text$mn:00006888 ; Attributes: bp-based frame
.text$mn:00006888
.text$mn:00006888 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00006888                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006888 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006888                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0+3j
.text$mn:00006888                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0+3j ...
.text$mn:00006888
.text$mn:00006888 var_10          = dword ptr -10h
.text$mn:00006888 var_C           = dword ptr -0Ch
.text$mn:00006888 var_4           = dword ptr -4
.text$mn:00006888
.text$mn:00006888                 push    ebp
.text$mn:00006889                 mov     ebp, esp
.text$mn:0000688B                 push    0FFFFFFFFh
.text$mn:0000688D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006892                 mov     eax, large fs:0
.text$mn:00006898                 push    eax
.text$mn:00006899                 push    ecx
.text$mn:0000689A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000689F                 xor     eax, ebp
.text$mn:000068A1                 push    eax
.text$mn:000068A2                 lea     eax, [ebp+var_C]
.text$mn:000068A5                 mov     large fs:0, eax
.text$mn:000068AB                 mov     [ebp+var_10], ecx
.text$mn:000068AE                 mov     [ebp+var_4], 0
.text$mn:000068B5                 mov     ecx, [ebp+var_10]
.text$mn:000068B8                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:000068BD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000068C4                 mov     ecx, [ebp+var_10]
.text$mn:000068C7                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000068CC                 mov     ecx, [ebp+var_C]
.text$mn:000068CF                 mov     large fs:0, ecx
.text$mn:000068D6                 pop     ecx
.text$mn:000068D7                 mov     esp, ebp
.text$mn:000068D9                 pop     ebp
.text$mn:000068DA                 retn
.text$mn:000068DA ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000068DA
.text$mn:000068DA ; ---------------------------------------------------------------------------
.text$mn:000068DB                 align 4
.text$mn:000068DB _text$mn        ends
.text$mn:000068DB
.text$x:000068DC ; ===========================================================================
.text$x:000068DC
.text$x:000068DC ; Segment type: Pure code
.text$x:000068DC ; Segment permissions: Read/Execute
.text$x:000068DC _text$x         segment para public 'CODE' use32
.text$x:000068DC                 assume cs:_text$x
.text$x:000068DC                 ;org 68DCh
.text$x:000068DC ; COMDAT (pick associative to section at 6888)
.text$x:000068DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000068DC
.text$x:000068DC ; =============== S U B R O U T I N E =======================================
.text$x:000068DC
.text$x:000068DC
.text$x:000068DC __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000068DC                                         ; DATA XREF: .xdata$x:0000C798o
.text$x:000068DC                 mov     ecx, [ebp-10h]
.text$x:000068DF                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:000068DF __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000068DF
.text$x:000068E4
.text$x:000068E4 ; =============== S U B R O U T I N E =======================================
.text$x:000068E4
.text$x:000068E4
.text$x:000068E4 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:000068E4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:000068E4
.text$x:000068E4 arg_4           = dword ptr  8
.text$x:000068E4
.text$x:000068E4                 mov     edx, [esp+arg_4]
.text$x:000068E8                 lea     eax, [edx+0Ch]
.text$x:000068EB                 mov     ecx, [edx-8]
.text$x:000068EE                 xor     ecx, eax
.text$x:000068F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000068F5                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:000068FA                 jmp     ___CxxFrameHandler3
.text$x:000068FA __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:000068FA
.text$x:000068FA ; ---------------------------------------------------------------------------
.text$x:000068FF                 align 10h
.text$x:000068FF _text$x         ends
.text$x:000068FF
.text$mn:00006900 ; ===========================================================================
.text$mn:00006900
.text$mn:00006900 ; Segment type: Pure code
.text$mn:00006900 ; Segment permissions: Read/Execute
.text$mn:00006900 _text$mn        segment para public 'CODE' use32
.text$mn:00006900                 assume cs:_text$mn
.text$mn:00006900                 ;org 6900h
.text$mn:00006900 ; COMDAT (pick any)
.text$mn:00006900                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006900
.text$mn:00006900 ; =============== S U B R O U T I N E =======================================
.text$mn:00006900
.text$mn:00006900 ; Attributes: bp-based frame
.text$mn:00006900
.text$mn:00006900 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00006900                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00006900 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00006900                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00006900                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00006900
.text$mn:00006900 var_10          = dword ptr -10h
.text$mn:00006900 var_C           = dword ptr -0Ch
.text$mn:00006900 var_4           = dword ptr -4
.text$mn:00006900
.text$mn:00006900                 push    ebp
.text$mn:00006901                 mov     ebp, esp
.text$mn:00006903                 push    0FFFFFFFFh
.text$mn:00006905                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000690A                 mov     eax, large fs:0
.text$mn:00006910                 push    eax
.text$mn:00006911                 push    ecx
.text$mn:00006912                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006917                 xor     eax, ebp
.text$mn:00006919                 push    eax
.text$mn:0000691A                 lea     eax, [ebp+var_C]
.text$mn:0000691D                 mov     large fs:0, eax
.text$mn:00006923                 mov     [ebp+var_10], ecx
.text$mn:00006926                 mov     [ebp+var_4], 0
.text$mn:0000692D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006934                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006937                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000693C                 mov     ecx, [ebp+var_C]
.text$mn:0000693F                 mov     large fs:0, ecx
.text$mn:00006946                 pop     ecx
.text$mn:00006947                 mov     esp, ebp
.text$mn:00006949                 pop     ebp
.text$mn:0000694A                 retn
.text$mn:0000694A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000694A
.text$mn:0000694A ; ---------------------------------------------------------------------------
.text$mn:0000694B                 align 4
.text$mn:0000694B _text$mn        ends
.text$mn:0000694B
.text$x:0000694C ; ===========================================================================
.text$x:0000694C
.text$x:0000694C ; Segment type: Pure code
.text$x:0000694C ; Segment permissions: Read/Execute
.text$x:0000694C _text$x         segment para public 'CODE' use32
.text$x:0000694C                 assume cs:_text$x
.text$x:0000694C                 ;org 694Ch
.text$x:0000694C ; COMDAT (pick associative to section at 6900)
.text$x:0000694C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000694C
.text$x:0000694C ; =============== S U B R O U T I N E =======================================
.text$x:0000694C
.text$x:0000694C
.text$x:0000694C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000694C                                         ; DATA XREF: .xdata$x:0000C3F4o
.text$x:0000694C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000694F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000694F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000694F
.text$x:00006954
.text$x:00006954 ; =============== S U B R O U T I N E =======================================
.text$x:00006954
.text$x:00006954
.text$x:00006954 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00006954                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00006954
.text$x:00006954 arg_4           = dword ptr  8
.text$x:00006954
.text$x:00006954                 mov     edx, [esp+arg_4]
.text$x:00006958                 lea     eax, [edx+0Ch]
.text$x:0000695B                 mov     ecx, [edx-8]
.text$x:0000695E                 xor     ecx, eax
.text$x:00006960                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006965                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000696A                 jmp     ___CxxFrameHandler3
.text$x:0000696A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000696A
.text$x:0000696A ; ---------------------------------------------------------------------------
.text$x:0000696F                 align 10h
.text$x:0000696F _text$x         ends
.text$x:0000696F
.text$mn:00006970 ; ===========================================================================
.text$mn:00006970
.text$mn:00006970 ; Segment type: Pure code
.text$mn:00006970 ; Segment permissions: Read/Execute
.text$mn:00006970 _text$mn        segment para public 'CODE' use32
.text$mn:00006970                 assume cs:_text$mn
.text$mn:00006970                 ;org 6970h
.text$mn:00006970 ; COMDAT (pick any)
.text$mn:00006970                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006970
.text$mn:00006970 ; =============== S U B R O U T I N E =======================================
.text$mn:00006970
.text$mn:00006970 ; Attributes: bp-based frame
.text$mn:00006970
.text$mn:00006970 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00006970                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00006970 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00006970                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006970                                         ; __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j ...
.text$mn:00006970
.text$mn:00006970 var_10          = dword ptr -10h
.text$mn:00006970 var_C           = dword ptr -0Ch
.text$mn:00006970 var_4           = dword ptr -4
.text$mn:00006970
.text$mn:00006970                 push    ebp
.text$mn:00006971                 mov     ebp, esp
.text$mn:00006973                 push    0FFFFFFFFh
.text$mn:00006975                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000697A                 mov     eax, large fs:0
.text$mn:00006980                 push    eax
.text$mn:00006981                 push    ecx
.text$mn:00006982                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006987                 xor     eax, ebp
.text$mn:00006989                 push    eax
.text$mn:0000698A                 lea     eax, [ebp+var_C]
.text$mn:0000698D                 mov     large fs:0, eax
.text$mn:00006993                 mov     [ebp+var_10], ecx
.text$mn:00006996                 mov     [ebp+var_4], 0
.text$mn:0000699D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000069A4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000069A7                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000069AC                 mov     ecx, [ebp+var_C]
.text$mn:000069AF                 mov     large fs:0, ecx
.text$mn:000069B6                 pop     ecx
.text$mn:000069B7                 mov     esp, ebp
.text$mn:000069B9                 pop     ebp
.text$mn:000069BA                 retn
.text$mn:000069BA ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:000069BA
.text$mn:000069BA ; ---------------------------------------------------------------------------
.text$mn:000069BB                 align 4
.text$mn:000069BB _text$mn        ends
.text$mn:000069BB
.text$x:000069BC ; ===========================================================================
.text$x:000069BC
.text$x:000069BC ; Segment type: Pure code
.text$x:000069BC ; Segment permissions: Read/Execute
.text$x:000069BC _text$x         segment para public 'CODE' use32
.text$x:000069BC                 assume cs:_text$x
.text$x:000069BC                 ;org 69BCh
.text$x:000069BC ; COMDAT (pick associative to section at 6970)
.text$x:000069BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000069BC
.text$x:000069BC ; =============== S U B R O U T I N E =======================================
.text$x:000069BC
.text$x:000069BC
.text$x:000069BC __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:000069BC                                         ; DATA XREF: .xdata$x:0000C714o
.text$x:000069BC                 mov     ecx, [ebp-10h]  ; this
.text$x:000069BF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000069BF __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:000069BF
.text$x:000069C4
.text$x:000069C4 ; =============== S U B R O U T I N E =======================================
.text$x:000069C4
.text$x:000069C4
.text$x:000069C4 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:000069C4                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:000069C4
.text$x:000069C4 arg_4           = dword ptr  8
.text$x:000069C4
.text$x:000069C4                 mov     edx, [esp+arg_4]
.text$x:000069C8                 lea     eax, [edx+0Ch]
.text$x:000069CB                 mov     ecx, [edx-8]
.text$x:000069CE                 xor     ecx, eax
.text$x:000069D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000069D5                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:000069DA                 jmp     ___CxxFrameHandler3
.text$x:000069DA __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:000069DA
.text$x:000069DA ; ---------------------------------------------------------------------------
.text$x:000069DF                 align 10h
.text$x:000069DF _text$x         ends
.text$x:000069DF
.text$mn:000069E0 ; ===========================================================================
.text$mn:000069E0
.text$mn:000069E0 ; Segment type: Pure code
.text$mn:000069E0 ; Segment permissions: Read/Execute
.text$mn:000069E0 _text$mn        segment para public 'CODE' use32
.text$mn:000069E0                 assume cs:_text$mn
.text$mn:000069E0                 ;org 69E0h
.text$mn:000069E0 ; COMDAT (pick any)
.text$mn:000069E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000069E0
.text$mn:000069E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000069E0
.text$mn:000069E0 ; Attributes: bp-based frame
.text$mn:000069E0
.text$mn:000069E0 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::~_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>(void)
.text$mn:000069E0                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:000069E0 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$mn:000069E0                                         ; CODE XREF: __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0+3j
.text$mn:000069E0                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+3Fp ...
.text$mn:000069E0
.text$mn:000069E0 var_10          = dword ptr -10h
.text$mn:000069E0 var_C           = dword ptr -0Ch
.text$mn:000069E0 var_4           = dword ptr -4
.text$mn:000069E0
.text$mn:000069E0                 push    ebp
.text$mn:000069E1                 mov     ebp, esp
.text$mn:000069E3                 push    0FFFFFFFFh
.text$mn:000069E5                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.text$mn:000069EA                 mov     eax, large fs:0
.text$mn:000069F0                 push    eax
.text$mn:000069F1                 push    ecx
.text$mn:000069F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000069F7                 xor     eax, ebp
.text$mn:000069F9                 push    eax
.text$mn:000069FA                 lea     eax, [ebp+var_C]
.text$mn:000069FD                 mov     large fs:0, eax
.text$mn:00006A03                 mov     [ebp+var_10], ecx
.text$mn:00006A06                 mov     [ebp+var_4], 0
.text$mn:00006A0D                 mov     ecx, [ebp+var_10]
.text$mn:00006A10                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Free_proxy(void)
.text$mn:00006A15                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006A1C                 mov     ecx, [ebp+var_10]
.text$mn:00006A1F                 call    ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00006A24                 mov     ecx, [ebp+var_C]
.text$mn:00006A27                 mov     large fs:0, ecx
.text$mn:00006A2E                 pop     ecx
.text$mn:00006A2F                 mov     esp, ebp
.text$mn:00006A31                 pop     ebp
.text$mn:00006A32                 retn
.text$mn:00006A32 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ endp
.text$mn:00006A32
.text$mn:00006A32 ; ---------------------------------------------------------------------------
.text$mn:00006A33                 align 4
.text$mn:00006A33 _text$mn        ends
.text$mn:00006A33
.text$x:00006A34 ; ===========================================================================
.text$x:00006A34
.text$x:00006A34 ; Segment type: Pure code
.text$x:00006A34 ; Segment permissions: Read/Execute
.text$x:00006A34 _text$x         segment para public 'CODE' use32
.text$x:00006A34                 assume cs:_text$x
.text$x:00006A34                 ;org 6A34h
.text$x:00006A34 ; COMDAT (pick associative to section at 69E0)
.text$x:00006A34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006A34
.text$x:00006A34 ; =============== S U B R O U T I N E =======================================
.text$x:00006A34
.text$x:00006A34
.text$x:00006A34 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006A34                                         ; DATA XREF: .xdata$x:0000CC1Co
.text$x:00006A34                 mov     ecx, [ebp-10h]
.text$x:00006A37                 jmp     ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$x:00006A37 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ$0 endp
.text$x:00006A37
.text$x:00006A3C
.text$x:00006A3C ; =============== S U B R O U T I N E =======================================
.text$x:00006A3C
.text$x:00006A3C
.text$x:00006A3C __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ proc near
.text$x:00006A3C                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)+5o
.text$x:00006A3C
.text$x:00006A3C arg_4           = dword ptr  8
.text$x:00006A3C
.text$x:00006A3C                 mov     edx, [esp+arg_4]
.text$x:00006A40                 lea     eax, [edx+0Ch]
.text$x:00006A43                 mov     ecx, [edx-8]
.text$x:00006A46                 xor     ecx, eax
.text$x:00006A48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A4D                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.text$x:00006A52                 jmp     ___CxxFrameHandler3
.text$x:00006A52 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ endp
.text$x:00006A52
.text$x:00006A52 ; ---------------------------------------------------------------------------
.text$x:00006A57                 align 4
.text$x:00006A57 _text$x         ends
.text$x:00006A57
.text$mn:00006A58 ; ===========================================================================
.text$mn:00006A58
.text$mn:00006A58 ; Segment type: Pure code
.text$mn:00006A58 ; Segment permissions: Read/Execute
.text$mn:00006A58 _text$mn        segment para public 'CODE' use32
.text$mn:00006A58                 assume cs:_text$mn
.text$mn:00006A58                 ;org 6A58h
.text$mn:00006A58 ; COMDAT (pick any)
.text$mn:00006A58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006A58
.text$mn:00006A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A58
.text$mn:00006A58 ; Attributes: bp-based frame
.text$mn:00006A58
.text$mn:00006A58 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::~_Vector_val<struct std::_Simple_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:00006A58                 public ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:00006A58 ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006A58                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0+3j
.text$mn:00006A58                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)+3Fp ...
.text$mn:00006A58
.text$mn:00006A58 var_10          = dword ptr -10h
.text$mn:00006A58 var_C           = dword ptr -0Ch
.text$mn:00006A58 var_4           = dword ptr -4
.text$mn:00006A58
.text$mn:00006A58                 push    ebp
.text$mn:00006A59                 mov     ebp, esp
.text$mn:00006A5B                 push    0FFFFFFFFh
.text$mn:00006A5D                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$mn:00006A62                 mov     eax, large fs:0
.text$mn:00006A68                 push    eax
.text$mn:00006A69                 push    ecx
.text$mn:00006A6A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006A6F                 xor     eax, ebp
.text$mn:00006A71                 push    eax
.text$mn:00006A72                 lea     eax, [ebp+var_C]
.text$mn:00006A75                 mov     large fs:0, eax
.text$mn:00006A7B                 mov     [ebp+var_10], ecx
.text$mn:00006A7E                 mov     [ebp+var_4], 0
.text$mn:00006A85                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006A8C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006A8F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00006A94                 mov     ecx, [ebp+var_C]
.text$mn:00006A97                 mov     large fs:0, ecx
.text$mn:00006A9E                 pop     ecx
.text$mn:00006A9F                 mov     esp, ebp
.text$mn:00006AA1                 pop     ebp
.text$mn:00006AA2                 retn
.text$mn:00006AA2 ??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006AA2
.text$mn:00006AA2 ; ---------------------------------------------------------------------------
.text$mn:00006AA3                 align 4
.text$mn:00006AA3 _text$mn        ends
.text$mn:00006AA3
.text$x:00006AA4 ; ===========================================================================
.text$x:00006AA4
.text$x:00006AA4 ; Segment type: Pure code
.text$x:00006AA4 ; Segment permissions: Read/Execute
.text$x:00006AA4 _text$x         segment para public 'CODE' use32
.text$x:00006AA4                 assume cs:_text$x
.text$x:00006AA4                 ;org 6AA4h
.text$x:00006AA4 ; COMDAT (pick associative to section at 6A58)
.text$x:00006AA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006AA4
.text$x:00006AA4 ; =============== S U B R O U T I N E =======================================
.text$x:00006AA4
.text$x:00006AA4
.text$x:00006AA4 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006AA4                                         ; DATA XREF: .xdata$x:0000CBC4o
.text$x:00006AA4                 mov     ecx, [ebp-10h]  ; this
.text$x:00006AA7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00006AA7 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006AA7
.text$x:00006AAC
.text$x:00006AAC ; =============== S U B R O U T I N E =======================================
.text$x:00006AAC
.text$x:00006AAC
.text$x:00006AAC __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006AAC                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:00006AAC
.text$x:00006AAC arg_4           = dword ptr  8
.text$x:00006AAC
.text$x:00006AAC                 mov     edx, [esp+arg_4]
.text$x:00006AB0                 lea     eax, [edx+0Ch]
.text$x:00006AB3                 mov     ecx, [edx-8]
.text$x:00006AB6                 xor     ecx, eax
.text$x:00006AB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006ABD                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.text$x:00006AC2                 jmp     ___CxxFrameHandler3
.text$x:00006AC2 __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ endp
.text$x:00006AC2
.text$x:00006AC2 ; ---------------------------------------------------------------------------
.text$x:00006AC7                 align 4
.text$x:00006AC7 _text$x         ends
.text$x:00006AC7
.text$mn:00006AC8 ; ===========================================================================
.text$mn:00006AC8
.text$mn:00006AC8 ; Segment type: Pure code
.text$mn:00006AC8 ; Segment permissions: Read/Execute
.text$mn:00006AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00006AC8                 assume cs:_text$mn
.text$mn:00006AC8                 ;org 6AC8h
.text$mn:00006AC8 ; COMDAT (pick any)
.text$mn:00006AC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006AC8
.text$mn:00006AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AC8
.text$mn:00006AC8 ; Attributes: bp-based frame
.text$mn:00006AC8
.text$mn:00006AC8 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00006AC8                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00006AC8 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00006AC8                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00006AC8                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00006AC8
.text$mn:00006AC8 var_10          = dword ptr -10h
.text$mn:00006AC8 var_C           = dword ptr -0Ch
.text$mn:00006AC8 var_4           = dword ptr -4
.text$mn:00006AC8
.text$mn:00006AC8                 push    ebp
.text$mn:00006AC9                 mov     ebp, esp
.text$mn:00006ACB                 push    0FFFFFFFFh
.text$mn:00006ACD                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00006AD2                 mov     eax, large fs:0
.text$mn:00006AD8                 push    eax
.text$mn:00006AD9                 push    ecx
.text$mn:00006ADA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006ADF                 xor     eax, ebp
.text$mn:00006AE1                 push    eax
.text$mn:00006AE2                 lea     eax, [ebp+var_C]
.text$mn:00006AE5                 mov     large fs:0, eax
.text$mn:00006AEB                 mov     [ebp+var_10], ecx
.text$mn:00006AEE                 mov     [ebp+var_4], 0
.text$mn:00006AF5                 push    0               ; Size
.text$mn:00006AF7                 push    1               ; char
.text$mn:00006AF9                 mov     ecx, [ebp+var_10]
.text$mn:00006AFC                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006B01                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006B08                 mov     ecx, [ebp+var_10]
.text$mn:00006B0B                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00006B10                 mov     ecx, [ebp+var_C]
.text$mn:00006B13                 mov     large fs:0, ecx
.text$mn:00006B1A                 pop     ecx
.text$mn:00006B1B                 mov     esp, ebp
.text$mn:00006B1D                 pop     ebp
.text$mn:00006B1E                 retn
.text$mn:00006B1E ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00006B1E
.text$mn:00006B1E ; ---------------------------------------------------------------------------
.text$mn:00006B1F                 align 10h
.text$mn:00006B1F _text$mn        ends
.text$mn:00006B1F
.text$x:00006B20 ; ===========================================================================
.text$x:00006B20
.text$x:00006B20 ; Segment type: Pure code
.text$x:00006B20 ; Segment permissions: Read/Execute
.text$x:00006B20 _text$x         segment para public 'CODE' use32
.text$x:00006B20                 assume cs:_text$x
.text$x:00006B20                 ;org 6B20h
.text$x:00006B20 ; COMDAT (pick associative to section at 6AC8)
.text$x:00006B20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006B20
.text$x:00006B20 ; =============== S U B R O U T I N E =======================================
.text$x:00006B20
.text$x:00006B20
.text$x:00006B20 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00006B20                                         ; DATA XREF: .xdata$x:0000C4A4o
.text$x:00006B20                 mov     ecx, [ebp-10h]
.text$x:00006B23                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00006B23 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00006B23
.text$x:00006B28
.text$x:00006B28 ; =============== S U B R O U T I N E =======================================
.text$x:00006B28
.text$x:00006B28
.text$x:00006B28 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00006B28                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00006B28
.text$x:00006B28 arg_4           = dword ptr  8
.text$x:00006B28
.text$x:00006B28                 mov     edx, [esp+arg_4]
.text$x:00006B2C                 lea     eax, [edx+0Ch]
.text$x:00006B2F                 mov     ecx, [edx-8]
.text$x:00006B32                 xor     ecx, eax
.text$x:00006B34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006B39                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00006B3E                 jmp     ___CxxFrameHandler3
.text$x:00006B3E __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00006B3E
.text$x:00006B3E ; ---------------------------------------------------------------------------
.text$x:00006B43                 align 4
.text$x:00006B43 _text$x         ends
.text$x:00006B43
.text$mn:00006B44 ; ===========================================================================
.text$mn:00006B44
.text$mn:00006B44 ; Segment type: Pure code
.text$mn:00006B44 ; Segment permissions: Read/Execute
.text$mn:00006B44 _text$mn        segment para public 'CODE' use32
.text$mn:00006B44                 assume cs:_text$mn
.text$mn:00006B44                 ;org 6B44h
.text$mn:00006B44 ; COMDAT (pick any)
.text$mn:00006B44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006B44
.text$mn:00006B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B44
.text$mn:00006B44 ; Attributes: bp-based frame
.text$mn:00006B44
.text$mn:00006B44 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00006B44                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00006B44 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00006B44                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+60Ap
.text$mn:00006B44                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+789p ...
.text$mn:00006B44
.text$mn:00006B44 var_10          = dword ptr -10h
.text$mn:00006B44 var_C           = dword ptr -0Ch
.text$mn:00006B44 var_4           = dword ptr -4
.text$mn:00006B44
.text$mn:00006B44                 push    ebp
.text$mn:00006B45                 mov     ebp, esp
.text$mn:00006B47                 push    0FFFFFFFFh
.text$mn:00006B49                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00006B4E                 mov     eax, large fs:0
.text$mn:00006B54                 push    eax
.text$mn:00006B55                 push    ecx
.text$mn:00006B56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006B5B                 xor     eax, ebp
.text$mn:00006B5D                 push    eax
.text$mn:00006B5E                 lea     eax, [ebp+var_C]
.text$mn:00006B61                 mov     large fs:0, eax
.text$mn:00006B67                 mov     [ebp+var_10], ecx
.text$mn:00006B6A                 mov     [ebp+var_4], 0
.text$mn:00006B71                 push    0
.text$mn:00006B73                 push    1
.text$mn:00006B75                 mov     ecx, [ebp+var_10]
.text$mn:00006B78                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00006B7D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006B84                 mov     ecx, [ebp+var_10]
.text$mn:00006B87                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00006B8C                 mov     ecx, [ebp+var_C]
.text$mn:00006B8F                 mov     large fs:0, ecx
.text$mn:00006B96                 pop     ecx
.text$mn:00006B97                 mov     esp, ebp
.text$mn:00006B99                 pop     ebp
.text$mn:00006B9A                 retn
.text$mn:00006B9A ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00006B9A
.text$mn:00006B9A ; ---------------------------------------------------------------------------
.text$mn:00006B9B                 align 4
.text$mn:00006B9B _text$mn        ends
.text$mn:00006B9B
.text$x:00006B9C ; ===========================================================================
.text$x:00006B9C
.text$x:00006B9C ; Segment type: Pure code
.text$x:00006B9C ; Segment permissions: Read/Execute
.text$x:00006B9C _text$x         segment para public 'CODE' use32
.text$x:00006B9C                 assume cs:_text$x
.text$x:00006B9C                 ;org 6B9Ch
.text$x:00006B9C ; COMDAT (pick associative to section at 6B44)
.text$x:00006B9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006B9C
.text$x:00006B9C ; =============== S U B R O U T I N E =======================================
.text$x:00006B9C
.text$x:00006B9C
.text$x:00006B9C __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00006B9C                                         ; DATA XREF: .xdata$x:0000C8A0o
.text$x:00006B9C                 mov     ecx, [ebp-10h]
.text$x:00006B9F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00006B9F __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00006B9F
.text$x:00006BA4
.text$x:00006BA4 ; =============== S U B R O U T I N E =======================================
.text$x:00006BA4
.text$x:00006BA4
.text$x:00006BA4 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00006BA4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00006BA4
.text$x:00006BA4 arg_4           = dword ptr  8
.text$x:00006BA4
.text$x:00006BA4                 mov     edx, [esp+arg_4]
.text$x:00006BA8                 lea     eax, [edx+0Ch]
.text$x:00006BAB                 mov     ecx, [edx-8]
.text$x:00006BAE                 xor     ecx, eax
.text$x:00006BB0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006BB5                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00006BBA                 jmp     ___CxxFrameHandler3
.text$x:00006BBA __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00006BBA
.text$x:00006BBA ; ---------------------------------------------------------------------------
.text$x:00006BBF                 align 10h
.text$x:00006BBF _text$x         ends
.text$x:00006BBF
.text$mn:00006BC0 ; ===========================================================================
.text$mn:00006BC0
.text$mn:00006BC0 ; Segment type: Pure code
.text$mn:00006BC0 ; Segment permissions: Read/Execute
.text$mn:00006BC0 _text$mn        segment para public 'CODE' use32
.text$mn:00006BC0                 assume cs:_text$mn
.text$mn:00006BC0                 ;org 6BC0h
.text$mn:00006BC0 ; COMDAT (pick any)
.text$mn:00006BC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006BC0
.text$mn:00006BC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BC0
.text$mn:00006BC0 ; Attributes: bp-based frame
.text$mn:00006BC0
.text$mn:00006BC0 ; public: __thiscall std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>::~pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>(void)
.text$mn:00006BC0                 public ??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ
.text$mn:00006BC0 ??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ proc near
.text$mn:00006BC0                                         ; CODE XREF: std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::`scalar deleting destructor'(uint)+Ap
.text$mn:00006BC0                                         ; PluginList::add(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool)+62p ...
.text$mn:00006BC0
.text$mn:00006BC0 var_10          = dword ptr -10h
.text$mn:00006BC0 var_C           = dword ptr -0Ch
.text$mn:00006BC0 var_4           = dword ptr -4
.text$mn:00006BC0
.text$mn:00006BC0                 push    ebp
.text$mn:00006BC1                 mov     ebp, esp
.text$mn:00006BC3                 push    0FFFFFFFFh
.text$mn:00006BC5                 push    offset __ehhandler$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ
.text$mn:00006BCA                 mov     eax, large fs:0
.text$mn:00006BD0                 push    eax
.text$mn:00006BD1                 push    ecx
.text$mn:00006BD2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006BD7                 xor     eax, ebp
.text$mn:00006BD9                 push    eax
.text$mn:00006BDA                 lea     eax, [ebp+var_C]
.text$mn:00006BDD                 mov     large fs:0, eax
.text$mn:00006BE3                 mov     [ebp+var_10], ecx
.text$mn:00006BE6                 mov     [ebp+var_4], 0
.text$mn:00006BED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006BF4                 mov     ecx, [ebp+var_10]
.text$mn:00006BF7                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00006BFC                 mov     ecx, [ebp+var_C]
.text$mn:00006BFF                 mov     large fs:0, ecx
.text$mn:00006C06                 pop     ecx
.text$mn:00006C07                 mov     esp, ebp
.text$mn:00006C09                 pop     ebp
.text$mn:00006C0A                 retn
.text$mn:00006C0A ??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ endp
.text$mn:00006C0A
.text$mn:00006C0A ; ---------------------------------------------------------------------------
.text$mn:00006C0B                 align 4
.text$mn:00006C0B _text$mn        ends
.text$mn:00006C0B
.text$x:00006C0C ; ===========================================================================
.text$x:00006C0C
.text$x:00006C0C ; Segment type: Pure code
.text$x:00006C0C ; Segment permissions: Read/Execute
.text$x:00006C0C _text$x         segment para public 'CODE' use32
.text$x:00006C0C                 assume cs:_text$x
.text$x:00006C0C                 ;org 6C0Ch
.text$x:00006C0C ; COMDAT (pick associative to section at 6BC0)
.text$x:00006C0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006C0C
.text$x:00006C0C ; =============== S U B R O U T I N E =======================================
.text$x:00006C0C
.text$x:00006C0C
.text$x:00006C0C __unwindfunclet$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ$0 proc near
.text$x:00006C0C                                         ; DATA XREF: .xdata$x:0000CDDCo
.text$x:00006C0C                 mov     ecx, [ebp-10h]
.text$x:00006C0F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006C0F __unwindfunclet$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ$0 endp
.text$x:00006C0F
.text$x:00006C14
.text$x:00006C14 ; =============== S U B R O U T I N E =======================================
.text$x:00006C14
.text$x:00006C14
.text$x:00006C14 __ehhandler$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ proc near
.text$x:00006C14                                         ; DATA XREF: std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::~pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(void)+5o
.text$x:00006C14
.text$x:00006C14 arg_4           = dword ptr  8
.text$x:00006C14
.text$x:00006C14                 mov     edx, [esp+arg_4]
.text$x:00006C18                 lea     eax, [edx+0Ch]
.text$x:00006C1B                 mov     ecx, [edx-8]
.text$x:00006C1E                 xor     ecx, eax
.text$x:00006C20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C25                 mov     eax, offset __ehfuncinfo$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ
.text$x:00006C2A                 jmp     ___CxxFrameHandler3
.text$x:00006C2A __ehhandler$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ endp
.text$x:00006C2A
.text$x:00006C2A ; ---------------------------------------------------------------------------
.text$x:00006C2F                 align 10h
.text$x:00006C2F _text$x         ends
.text$x:00006C2F
.text$mn:00006C30 ; ===========================================================================
.text$mn:00006C30
.text$mn:00006C30 ; Segment type: Pure code
.text$mn:00006C30 ; Segment permissions: Read/Execute
.text$mn:00006C30 _text$mn        segment para public 'CODE' use32
.text$mn:00006C30                 assume cs:_text$mn
.text$mn:00006C30                 ;org 6C30h
.text$mn:00006C30 ; COMDAT (pick any)
.text$mn:00006C30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006C30
.text$mn:00006C30 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C30
.text$mn:00006C30 ; Attributes: bp-based frame
.text$mn:00006C30
.text$mn:00006C30 ; public: __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::~vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>(void)
.text$mn:00006C30                 public ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:00006C30 ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$mn:00006C30                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+5C4p
.text$mn:00006C30                                         ; PluginsManager::loadPlugins(wchar_t const *)+5D6p ...
.text$mn:00006C30
.text$mn:00006C30 var_10          = dword ptr -10h
.text$mn:00006C30 var_C           = dword ptr -0Ch
.text$mn:00006C30 var_4           = dword ptr -4
.text$mn:00006C30
.text$mn:00006C30                 push    ebp
.text$mn:00006C31                 mov     ebp, esp
.text$mn:00006C33                 push    0FFFFFFFFh
.text$mn:00006C35                 push    offset __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$mn:00006C3A                 mov     eax, large fs:0
.text$mn:00006C40                 push    eax
.text$mn:00006C41                 push    ecx
.text$mn:00006C42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006C47                 xor     eax, ebp
.text$mn:00006C49                 push    eax
.text$mn:00006C4A                 lea     eax, [ebp+var_C]
.text$mn:00006C4D                 mov     large fs:0, eax
.text$mn:00006C53                 mov     [ebp+var_10], ecx
.text$mn:00006C56                 mov     [ebp+var_4], 0
.text$mn:00006C5D                 mov     ecx, [ebp+var_10]
.text$mn:00006C60                 call    ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Tidy(void)
.text$mn:00006C65                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006C6C                 mov     ecx, [ebp+var_10]
.text$mn:00006C6F                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)
.text$mn:00006C74                 mov     ecx, [ebp+var_C]
.text$mn:00006C77                 mov     large fs:0, ecx
.text$mn:00006C7E                 pop     ecx
.text$mn:00006C7F                 mov     esp, ebp
.text$mn:00006C81                 pop     ebp
.text$mn:00006C82                 retn
.text$mn:00006C82 ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$mn:00006C82
.text$mn:00006C82 ; ---------------------------------------------------------------------------
.text$mn:00006C83                 align 4
.text$mn:00006C83 _text$mn        ends
.text$mn:00006C83
.text$x:00006C84 ; ===========================================================================
.text$x:00006C84
.text$x:00006C84 ; Segment type: Pure code
.text$x:00006C84 ; Segment permissions: Read/Execute
.text$x:00006C84 _text$x         segment para public 'CODE' use32
.text$x:00006C84                 assume cs:_text$x
.text$x:00006C84                 ;org 6C84h
.text$x:00006C84 ; COMDAT (pick associative to section at 6C30)
.text$x:00006C84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006C84
.text$x:00006C84 ; =============== S U B R O U T I N E =======================================
.text$x:00006C84
.text$x:00006C84
.text$x:00006C84 __unwindfunclet$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:00006C84                                         ; DATA XREF: .xdata$x:0000CC74o
.text$x:00006C84                 mov     ecx, [ebp-10h]
.text$x:00006C87                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)
.text$x:00006C87 __unwindfunclet$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0 endp
.text$x:00006C87
.text$x:00006C8C
.text$x:00006C8C ; =============== S U B R O U T I N E =======================================
.text$x:00006C8C
.text$x:00006C8C
.text$x:00006C8C __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ proc near
.text$x:00006C8C                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+5o
.text$x:00006C8C
.text$x:00006C8C arg_4           = dword ptr  8
.text$x:00006C8C
.text$x:00006C8C                 mov     edx, [esp+arg_4]
.text$x:00006C90                 lea     eax, [edx+0Ch]
.text$x:00006C93                 mov     ecx, [edx-8]
.text$x:00006C96                 xor     ecx, eax
.text$x:00006C98                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C9D                 mov     eax, offset __ehfuncinfo$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.text$x:00006CA2                 jmp     ___CxxFrameHandler3
.text$x:00006CA2 __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ endp
.text$x:00006CA2
.text$x:00006CA2 ; ---------------------------------------------------------------------------
.text$x:00006CA7                 align 4
.text$x:00006CA7 _text$x         ends
.text$x:00006CA7
.text$mn:00006CA8 ; ===========================================================================
.text$mn:00006CA8
.text$mn:00006CA8 ; Segment type: Pure code
.text$mn:00006CA8 ; Segment permissions: Read/Execute
.text$mn:00006CA8 _text$mn        segment para public 'CODE' use32
.text$mn:00006CA8                 assume cs:_text$mn
.text$mn:00006CA8                 ;org 6CA8h
.text$mn:00006CA8 ; COMDAT (pick any)
.text$mn:00006CA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006CA8
.text$mn:00006CA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CA8
.text$mn:00006CA8 ; Attributes: bp-based frame
.text$mn:00006CA8
.text$mn:00006CA8 ; _DWORD __thiscall CommandShortcut::~CommandShortcut(CommandShortcut *__hidden this)
.text$mn:00006CA8                 public ??1CommandShortcut@@UAE@XZ
.text$mn:00006CA8 ??1CommandShortcut@@UAE@XZ proc near    ; CODE XREF: __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$0+3j
.text$mn:00006CA8                                         ; __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$2+3j ...
.text$mn:00006CA8
.text$mn:00006CA8 var_10          = dword ptr -10h
.text$mn:00006CA8 var_C           = dword ptr -0Ch
.text$mn:00006CA8 var_4           = dword ptr -4
.text$mn:00006CA8
.text$mn:00006CA8                 push    ebp
.text$mn:00006CA9                 mov     ebp, esp
.text$mn:00006CAB                 push    0FFFFFFFFh
.text$mn:00006CAD                 push    offset __ehhandler$??1CommandShortcut@@UAE@XZ
.text$mn:00006CB2                 mov     eax, large fs:0
.text$mn:00006CB8                 push    eax
.text$mn:00006CB9                 push    ecx
.text$mn:00006CBA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006CBF                 xor     eax, ebp
.text$mn:00006CC1                 push    eax
.text$mn:00006CC2                 lea     eax, [ebp+var_C]
.text$mn:00006CC5                 mov     large fs:0, eax
.text$mn:00006CCB                 mov     [ebp+var_10], ecx
.text$mn:00006CCE                 mov     [ebp+var_4], 0
.text$mn:00006CD5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006CDC                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006CDF                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:00006CE4                 mov     ecx, [ebp+var_C]
.text$mn:00006CE7                 mov     large fs:0, ecx
.text$mn:00006CEE                 pop     ecx
.text$mn:00006CEF                 mov     esp, ebp
.text$mn:00006CF1                 pop     ebp
.text$mn:00006CF2                 retn
.text$mn:00006CF2 ??1CommandShortcut@@UAE@XZ endp
.text$mn:00006CF2
.text$mn:00006CF2 ; ---------------------------------------------------------------------------
.text$mn:00006CF3                 align 4
.text$mn:00006CF3 _text$mn        ends
.text$mn:00006CF3
.text$x:00006CF4 ; ===========================================================================
.text$x:00006CF4
.text$x:00006CF4 ; Segment type: Pure code
.text$x:00006CF4 ; Segment permissions: Read/Execute
.text$x:00006CF4 _text$x         segment para public 'CODE' use32
.text$x:00006CF4                 assume cs:_text$x
.text$x:00006CF4                 ;org 6CF4h
.text$x:00006CF4 ; COMDAT (pick associative to section at 6CA8)
.text$x:00006CF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006CF4
.text$x:00006CF4 ; =============== S U B R O U T I N E =======================================
.text$x:00006CF4
.text$x:00006CF4
.text$x:00006CF4 __unwindfunclet$??1CommandShortcut@@UAE@XZ$0 proc near
.text$x:00006CF4                                         ; DATA XREF: .xdata$x:0000CA68o
.text$x:00006CF4                 mov     ecx, [ebp-10h]  ; this
.text$x:00006CF7                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00006CF7 __unwindfunclet$??1CommandShortcut@@UAE@XZ$0 endp
.text$x:00006CF7
.text$x:00006CFC
.text$x:00006CFC ; =============== S U B R O U T I N E =======================================
.text$x:00006CFC
.text$x:00006CFC
.text$x:00006CFC __ehhandler$??1CommandShortcut@@UAE@XZ proc near
.text$x:00006CFC                                         ; DATA XREF: CommandShortcut::~CommandShortcut(void)+5o
.text$x:00006CFC
.text$x:00006CFC arg_4           = dword ptr  8
.text$x:00006CFC
.text$x:00006CFC                 mov     edx, [esp+arg_4]
.text$x:00006D00                 lea     eax, [edx+0Ch]
.text$x:00006D03                 mov     ecx, [edx-8]
.text$x:00006D06                 xor     ecx, eax
.text$x:00006D08                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D0D                 mov     eax, offset __ehfuncinfo$??1CommandShortcut@@UAE@XZ
.text$x:00006D12                 jmp     ___CxxFrameHandler3
.text$x:00006D12 __ehhandler$??1CommandShortcut@@UAE@XZ endp
.text$x:00006D12
.text$x:00006D12 ; ---------------------------------------------------------------------------
.text$x:00006D17                 align 4
.text$x:00006D17 _text$x         ends
.text$x:00006D17
.text$mn:00006D18 ; ===========================================================================
.text$mn:00006D18
.text$mn:00006D18 ; Segment type: Pure code
.text$mn:00006D18 ; Segment permissions: Read/Execute
.text$mn:00006D18 _text$mn        segment para public 'CODE' use32
.text$mn:00006D18                 assume cs:_text$mn
.text$mn:00006D18                 ;org 6D18h
.text$mn:00006D18 ; COMDAT (pick any)
.text$mn:00006D18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006D18
.text$mn:00006D18 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D18
.text$mn:00006D18 ; Attributes: bp-based frame
.text$mn:00006D18
.text$mn:00006D18 ; _DWORD __thiscall PluginCmdShortcut::~PluginCmdShortcut(PluginCmdShortcut *__hidden this)
.text$mn:00006D18                 public ??1PluginCmdShortcut@@UAE@XZ
.text$mn:00006D18 ??1PluginCmdShortcut@@UAE@XZ proc near  ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+3BBp
.text$mn:00006D18                                         ; PluginsManager::addInMenuFromPMIndex(int)+476p ...
.text$mn:00006D18
.text$mn:00006D18 var_10          = dword ptr -10h
.text$mn:00006D18 var_C           = dword ptr -0Ch
.text$mn:00006D18 var_4           = dword ptr -4
.text$mn:00006D18
.text$mn:00006D18                 push    ebp
.text$mn:00006D19                 mov     ebp, esp
.text$mn:00006D1B                 push    0FFFFFFFFh
.text$mn:00006D1D                 push    offset __ehhandler$??1PluginCmdShortcut@@UAE@XZ
.text$mn:00006D22                 mov     eax, large fs:0
.text$mn:00006D28                 push    eax
.text$mn:00006D29                 push    ecx
.text$mn:00006D2A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006D2F                 xor     eax, ebp
.text$mn:00006D31                 push    eax
.text$mn:00006D32                 lea     eax, [ebp+var_C]
.text$mn:00006D35                 mov     large fs:0, eax
.text$mn:00006D3B                 mov     [ebp+var_10], ecx
.text$mn:00006D3E                 mov     [ebp+var_4], 1
.text$mn:00006D45                 mov     byte ptr [ebp+var_4], 0
.text$mn:00006D49                 mov     ecx, [ebp+var_10]
.text$mn:00006D4C                 add     ecx, 130h
.text$mn:00006D52                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00006D57                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006D5E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006D61                 call    ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$mn:00006D66                 mov     ecx, [ebp+var_C]
.text$mn:00006D69                 mov     large fs:0, ecx
.text$mn:00006D70                 pop     ecx
.text$mn:00006D71                 mov     esp, ebp
.text$mn:00006D73                 pop     ebp
.text$mn:00006D74                 retn
.text$mn:00006D74 ??1PluginCmdShortcut@@UAE@XZ endp
.text$mn:00006D74
.text$mn:00006D74 ; ---------------------------------------------------------------------------
.text$mn:00006D75                 align 4
.text$mn:00006D75 _text$mn        ends
.text$mn:00006D75
.text$x:00006D78 ; ===========================================================================
.text$x:00006D78
.text$x:00006D78 ; Segment type: Pure code
.text$x:00006D78 ; Segment permissions: Read/Execute
.text$x:00006D78 _text$x         segment para public 'CODE' use32
.text$x:00006D78                 assume cs:_text$x
.text$x:00006D78                 ;org 6D78h
.text$x:00006D78 ; COMDAT (pick associative to section at 6D18)
.text$x:00006D78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006D78
.text$x:00006D78 ; =============== S U B R O U T I N E =======================================
.text$x:00006D78
.text$x:00006D78
.text$x:00006D78 __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$0 proc near
.text$x:00006D78                                         ; DATA XREF: .xdata$x:0000CB04o
.text$x:00006D78                 mov     ecx, [ebp-10h]  ; this
.text$x:00006D7B                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:00006D7B __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$0 endp
.text$x:00006D7B
.text$x:00006D80
.text$x:00006D80 ; =============== S U B R O U T I N E =======================================
.text$x:00006D80
.text$x:00006D80
.text$x:00006D80 __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$1 proc near
.text$x:00006D80                                         ; DATA XREF: .xdata$x:0000CB0Co
.text$x:00006D80                 mov     ecx, [ebp-10h]
.text$x:00006D83                 add     ecx, 130h
.text$x:00006D89                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006D89 __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$1 endp
.text$x:00006D89
.text$x:00006D8E
.text$x:00006D8E ; =============== S U B R O U T I N E =======================================
.text$x:00006D8E
.text$x:00006D8E
.text$x:00006D8E __ehhandler$??1PluginCmdShortcut@@UAE@XZ proc near
.text$x:00006D8E                                         ; DATA XREF: PluginCmdShortcut::~PluginCmdShortcut(void)+5o
.text$x:00006D8E
.text$x:00006D8E arg_4           = dword ptr  8
.text$x:00006D8E
.text$x:00006D8E                 mov     edx, [esp+arg_4]
.text$x:00006D92                 lea     eax, [edx+0Ch]
.text$x:00006D95                 mov     ecx, [edx-8]
.text$x:00006D98                 xor     ecx, eax
.text$x:00006D9A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D9F                 mov     eax, offset __ehfuncinfo$??1PluginCmdShortcut@@UAE@XZ
.text$x:00006DA4                 jmp     ___CxxFrameHandler3
.text$x:00006DA4 __ehhandler$??1PluginCmdShortcut@@UAE@XZ endp
.text$x:00006DA4
.text$x:00006DA4 ; ---------------------------------------------------------------------------
.text$x:00006DA9                 align 4
.text$x:00006DA9 _text$x         ends
.text$x:00006DA9
.text$mn:00006DAC ; ===========================================================================
.text$mn:00006DAC
.text$mn:00006DAC ; Segment type: Pure code
.text$mn:00006DAC ; Segment permissions: Read/Execute
.text$mn:00006DAC _text$mn        segment para public 'CODE' use32
.text$mn:00006DAC                 assume cs:_text$mn
.text$mn:00006DAC                 ;org 6DACh
.text$mn:00006DAC ; COMDAT (pick any)
.text$mn:00006DAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006DAC
.text$mn:00006DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00006DAC
.text$mn:00006DAC ; Attributes: bp-based frame
.text$mn:00006DAC
.text$mn:00006DAC ; _DWORD __thiscall PluginCommand::~PluginCommand(PluginCommand *__hidden this)
.text$mn:00006DAC                 public ??1PluginCommand@@QAE@XZ
.text$mn:00006DAC ??1PluginCommand@@QAE@XZ proc near      ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+1C6p
.text$mn:00006DAC                                         ; __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$0+3j ...
.text$mn:00006DAC
.text$mn:00006DAC var_10          = dword ptr -10h
.text$mn:00006DAC var_C           = dword ptr -0Ch
.text$mn:00006DAC var_4           = dword ptr -4
.text$mn:00006DAC
.text$mn:00006DAC                 push    ebp
.text$mn:00006DAD                 mov     ebp, esp
.text$mn:00006DAF                 push    0FFFFFFFFh
.text$mn:00006DB1                 push    offset __ehhandler$??1PluginCommand@@QAE@XZ
.text$mn:00006DB6                 mov     eax, large fs:0
.text$mn:00006DBC                 push    eax
.text$mn:00006DBD                 push    ecx
.text$mn:00006DBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006DC3                 xor     eax, ebp
.text$mn:00006DC5                 push    eax
.text$mn:00006DC6                 lea     eax, [ebp+var_C]
.text$mn:00006DC9                 mov     large fs:0, eax
.text$mn:00006DCF                 mov     [ebp+var_10], ecx
.text$mn:00006DD2                 mov     [ebp+var_4], 0
.text$mn:00006DD9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006DE0                 mov     ecx, [ebp+var_10]
.text$mn:00006DE3                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00006DE8                 mov     ecx, [ebp+var_C]
.text$mn:00006DEB                 mov     large fs:0, ecx
.text$mn:00006DF2                 pop     ecx
.text$mn:00006DF3                 mov     esp, ebp
.text$mn:00006DF5                 pop     ebp
.text$mn:00006DF6                 retn
.text$mn:00006DF6 ??1PluginCommand@@QAE@XZ endp
.text$mn:00006DF6
.text$mn:00006DF6 ; ---------------------------------------------------------------------------
.text$mn:00006DF7                 align 4
.text$mn:00006DF7 _text$mn        ends
.text$mn:00006DF7
.text$x:00006DF8 ; ===========================================================================
.text$x:00006DF8
.text$x:00006DF8 ; Segment type: Pure code
.text$x:00006DF8 ; Segment permissions: Read/Execute
.text$x:00006DF8 _text$x         segment para public 'CODE' use32
.text$x:00006DF8                 assume cs:_text$x
.text$x:00006DF8                 ;org 6DF8h
.text$x:00006DF8 ; COMDAT (pick associative to section at 6DAC)
.text$x:00006DF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006DF8
.text$x:00006DF8 ; =============== S U B R O U T I N E =======================================
.text$x:00006DF8
.text$x:00006DF8
.text$x:00006DF8 __unwindfunclet$??1PluginCommand@@QAE@XZ$0 proc near
.text$x:00006DF8                                         ; DATA XREF: .xdata$x:0000CFC0o
.text$x:00006DF8                 mov     ecx, [ebp-10h]
.text$x:00006DFB                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006DFB __unwindfunclet$??1PluginCommand@@QAE@XZ$0 endp
.text$x:00006DFB
.text$x:00006E00
.text$x:00006E00 ; =============== S U B R O U T I N E =======================================
.text$x:00006E00
.text$x:00006E00
.text$x:00006E00 __ehhandler$??1PluginCommand@@QAE@XZ proc near
.text$x:00006E00                                         ; DATA XREF: PluginCommand::~PluginCommand(void)+5o
.text$x:00006E00
.text$x:00006E00 arg_4           = dword ptr  8
.text$x:00006E00
.text$x:00006E00                 mov     edx, [esp+arg_4]
.text$x:00006E04                 lea     eax, [edx+0Ch]
.text$x:00006E07                 mov     ecx, [edx-8]
.text$x:00006E0A                 xor     ecx, eax
.text$x:00006E0C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006E11                 mov     eax, offset __ehfuncinfo$??1PluginCommand@@QAE@XZ
.text$x:00006E16                 jmp     ___CxxFrameHandler3
.text$x:00006E16 __ehhandler$??1PluginCommand@@QAE@XZ endp
.text$x:00006E16
.text$x:00006E16 ; ---------------------------------------------------------------------------
.text$x:00006E1B                 align 4
.text$x:00006E1B _text$x         ends
.text$x:00006E1B
.text$mn:00006E1C ; ===========================================================================
.text$mn:00006E1C
.text$mn:00006E1C ; Segment type: Pure code
.text$mn:00006E1C ; Segment permissions: Read/Execute
.text$mn:00006E1C _text$mn        segment para public 'CODE' use32
.text$mn:00006E1C                 assume cs:_text$mn
.text$mn:00006E1C                 ;org 6E1Ch
.text$mn:00006E1C ; COMDAT (pick any)
.text$mn:00006E1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006E1C
.text$mn:00006E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E1C
.text$mn:00006E1C ; Attributes: bp-based frame
.text$mn:00006E1C
.text$mn:00006E1C ; _DWORD __thiscall PluginInfo::~PluginInfo(PluginInfo *__hidden this)
.text$mn:00006E1C                 public ??1PluginInfo@@QAE@XZ
.text$mn:00006E1C ??1PluginInfo@@QAE@XZ proc near         ; CODE XREF: PluginInfo::`scalar deleting destructor'(uint)+Ap
.text$mn:00006E1C
.text$mn:00006E1C var_10          = dword ptr -10h
.text$mn:00006E1C var_C           = dword ptr -0Ch
.text$mn:00006E1C var_4           = dword ptr -4
.text$mn:00006E1C
.text$mn:00006E1C                 push    ebp
.text$mn:00006E1D                 mov     ebp, esp
.text$mn:00006E1F                 push    0FFFFFFFFh
.text$mn:00006E21                 push    offset __ehhandler$??1PluginInfo@@QAE@XZ
.text$mn:00006E26                 mov     eax, large fs:0
.text$mn:00006E2C                 push    eax
.text$mn:00006E2D                 push    ecx
.text$mn:00006E2E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006E33                 xor     eax, ebp
.text$mn:00006E35                 push    eax
.text$mn:00006E36                 lea     eax, [ebp+var_C]
.text$mn:00006E39                 mov     large fs:0, eax
.text$mn:00006E3F                 mov     [ebp+var_10], ecx
.text$mn:00006E42                 mov     [ebp+var_4], 0
.text$mn:00006E49                 mov     eax, [ebp+var_10]
.text$mn:00006E4C                 cmp     dword ptr [eax+4], 0
.text$mn:00006E50                 jz      short loc_6E5F
.text$mn:00006E52                 mov     ecx, [ebp+var_10]
.text$mn:00006E55                 mov     edx, [ecx+4]
.text$mn:00006E58                 push    edx             ; hMenu
.text$mn:00006E59                 call    dword ptr ds:__imp__DestroyMenu@4 ; DestroyMenu(x)
.text$mn:00006E5F
.text$mn:00006E5F loc_6E5F:                               ; CODE XREF: PluginInfo::~PluginInfo(void)+34j
.text$mn:00006E5F                 mov     eax, [ebp+var_10]
.text$mn:00006E62                 cmp     dword ptr [eax], 0
.text$mn:00006E65                 jz      short loc_6E73
.text$mn:00006E67                 mov     ecx, [ebp+var_10]
.text$mn:00006E6A                 mov     edx, [ecx]
.text$mn:00006E6C                 push    edx             ; hLibModule
.text$mn:00006E6D                 call    dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
.text$mn:00006E73
.text$mn:00006E73 loc_6E73:                               ; CODE XREF: PluginInfo::~PluginInfo(void)+49j
.text$mn:00006E73                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006E7A                 mov     ecx, [ebp+var_10]
.text$mn:00006E7D                 add     ecx, 28h ; '('
.text$mn:00006E80                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00006E85                 mov     ecx, [ebp+var_C]
.text$mn:00006E88                 mov     large fs:0, ecx
.text$mn:00006E8F                 pop     ecx
.text$mn:00006E90                 mov     esp, ebp
.text$mn:00006E92                 pop     ebp
.text$mn:00006E93                 retn
.text$mn:00006E93 ??1PluginInfo@@QAE@XZ endp
.text$mn:00006E93
.text$mn:00006E93 _text$mn        ends
.text$mn:00006E93
.text$x:00006E94 ; ===========================================================================
.text$x:00006E94
.text$x:00006E94 ; Segment type: Pure code
.text$x:00006E94 ; Segment permissions: Read/Execute
.text$x:00006E94 _text$x         segment para public 'CODE' use32
.text$x:00006E94                 assume cs:_text$x
.text$x:00006E94                 ;org 6E94h
.text$x:00006E94 ; COMDAT (pick associative to section at 6E1C)
.text$x:00006E94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006E94
.text$x:00006E94 ; =============== S U B R O U T I N E =======================================
.text$x:00006E94
.text$x:00006E94
.text$x:00006E94 __unwindfunclet$??1PluginInfo@@QAE@XZ$0 proc near
.text$x:00006E94                                         ; DATA XREF: .xdata$x:0000D044o
.text$x:00006E94                 mov     ecx, [ebp-10h]
.text$x:00006E97                 add     ecx, 28h ; '('
.text$x:00006E9A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006E9A __unwindfunclet$??1PluginInfo@@QAE@XZ$0 endp
.text$x:00006E9A
.text$x:00006E9F
.text$x:00006E9F ; =============== S U B R O U T I N E =======================================
.text$x:00006E9F
.text$x:00006E9F
.text$x:00006E9F __ehhandler$??1PluginInfo@@QAE@XZ proc near
.text$x:00006E9F                                         ; DATA XREF: PluginInfo::~PluginInfo(void)+5o
.text$x:00006E9F
.text$x:00006E9F arg_4           = dword ptr  8
.text$x:00006E9F
.text$x:00006E9F                 mov     edx, [esp+arg_4]
.text$x:00006EA3                 lea     eax, [edx+0Ch]
.text$x:00006EA6                 mov     ecx, [edx-8]
.text$x:00006EA9                 xor     ecx, eax
.text$x:00006EAB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006EB0                 mov     eax, offset __ehfuncinfo$??1PluginInfo@@QAE@XZ
.text$x:00006EB5                 jmp     ___CxxFrameHandler3
.text$x:00006EB5 __ehhandler$??1PluginInfo@@QAE@XZ endp
.text$x:00006EB5
.text$x:00006EB5 ; ---------------------------------------------------------------------------
.text$x:00006EBA                 align 4
.text$x:00006EBA _text$x         ends
.text$x:00006EBA
.text$mn:00006EBC ; ===========================================================================
.text$mn:00006EBC
.text$mn:00006EBC ; Segment type: Pure code
.text$mn:00006EBC ; Segment permissions: Read/Execute
.text$mn:00006EBC _text$mn        segment para public 'CODE' use32
.text$mn:00006EBC                 assume cs:_text$mn
.text$mn:00006EBC                 ;org 6EBCh
.text$mn:00006EBC ; COMDAT (pick any)
.text$mn:00006EBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006EBC
.text$mn:00006EBC ; =============== S U B R O U T I N E =======================================
.text$mn:00006EBC
.text$mn:00006EBC ; Attributes: bp-based frame
.text$mn:00006EBC
.text$mn:00006EBC ; _DWORD __thiscall Shortcut::~Shortcut(Shortcut *__hidden this)
.text$mn:00006EBC                 public ??1Shortcut@@UAE@XZ
.text$mn:00006EBC ??1Shortcut@@UAE@XZ proc near           ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+485p
.text$mn:00006EBC                                         ; __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$2+6j ...
.text$mn:00006EBC
.text$mn:00006EBC var_10          = dword ptr -10h
.text$mn:00006EBC var_C           = dword ptr -0Ch
.text$mn:00006EBC var_4           = dword ptr -4
.text$mn:00006EBC
.text$mn:00006EBC                 push    ebp
.text$mn:00006EBD                 mov     ebp, esp
.text$mn:00006EBF                 push    0FFFFFFFFh
.text$mn:00006EC1                 push    offset __ehhandler$??1Shortcut@@UAE@XZ
.text$mn:00006EC6                 mov     eax, large fs:0
.text$mn:00006ECC                 push    eax
.text$mn:00006ECD                 push    ecx
.text$mn:00006ECE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006ED3                 xor     eax, ebp
.text$mn:00006ED5                 push    eax
.text$mn:00006ED6                 lea     eax, [ebp+var_C]
.text$mn:00006ED9                 mov     large fs:0, eax
.text$mn:00006EDF                 mov     [ebp+var_10], ecx
.text$mn:00006EE2                 mov     [ebp+var_4], 0
.text$mn:00006EE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006EF0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006EF3                 call    ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$mn:00006EF8                 mov     ecx, [ebp+var_C]
.text$mn:00006EFB                 mov     large fs:0, ecx
.text$mn:00006F02                 pop     ecx
.text$mn:00006F03                 mov     esp, ebp
.text$mn:00006F05                 pop     ebp
.text$mn:00006F06                 retn
.text$mn:00006F06 ??1Shortcut@@UAE@XZ endp
.text$mn:00006F06
.text$mn:00006F06 ; ---------------------------------------------------------------------------
.text$mn:00006F07                 align 4
.text$mn:00006F07 _text$mn        ends
.text$mn:00006F07
.text$x:00006F08 ; ===========================================================================
.text$x:00006F08
.text$x:00006F08 ; Segment type: Pure code
.text$x:00006F08 ; Segment permissions: Read/Execute
.text$x:00006F08 _text$x         segment para public 'CODE' use32
.text$x:00006F08                 assume cs:_text$x
.text$x:00006F08                 ;org 6F08h
.text$x:00006F08 ; COMDAT (pick associative to section at 6EBC)
.text$x:00006F08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006F08
.text$x:00006F08 ; =============== S U B R O U T I N E =======================================
.text$x:00006F08
.text$x:00006F08
.text$x:00006F08 __unwindfunclet$??1Shortcut@@UAE@XZ$0 proc near
.text$x:00006F08                                         ; DATA XREF: .xdata$x:0000CA08o
.text$x:00006F08                 mov     ecx, [ebp-10h]  ; this
.text$x:00006F0B                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:00006F0B __unwindfunclet$??1Shortcut@@UAE@XZ$0 endp
.text$x:00006F0B
.text$x:00006F10
.text$x:00006F10 ; =============== S U B R O U T I N E =======================================
.text$x:00006F10
.text$x:00006F10
.text$x:00006F10 __ehhandler$??1Shortcut@@UAE@XZ proc near
.text$x:00006F10                                         ; DATA XREF: Shortcut::~Shortcut(void)+5o
.text$x:00006F10
.text$x:00006F10 arg_4           = dword ptr  8
.text$x:00006F10
.text$x:00006F10                 mov     edx, [esp+arg_4]
.text$x:00006F14                 lea     eax, [edx+0Ch]
.text$x:00006F17                 mov     ecx, [edx-8]
.text$x:00006F1A                 xor     ecx, eax
.text$x:00006F1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F21                 mov     eax, offset __ehfuncinfo$??1Shortcut@@UAE@XZ
.text$x:00006F26                 jmp     ___CxxFrameHandler3
.text$x:00006F26 __ehhandler$??1Shortcut@@UAE@XZ endp
.text$x:00006F26
.text$x:00006F26 ; ---------------------------------------------------------------------------
.text$x:00006F2B                 align 4
.text$x:00006F2B _text$x         ends
.text$x:00006F2B
.text$mn:00006F2C ; ===========================================================================
.text$mn:00006F2C
.text$mn:00006F2C ; Segment type: Pure code
.text$mn:00006F2C ; Segment permissions: Read/Execute
.text$mn:00006F2C _text$mn        segment para public 'CODE' use32
.text$mn:00006F2C                 assume cs:_text$mn
.text$mn:00006F2C                 ;org 6F2Ch
.text$mn:00006F2C ; COMDAT (pick any)
.text$mn:00006F2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006F2C
.text$mn:00006F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00006F2C
.text$mn:00006F2C ; Attributes: bp-based frame
.text$mn:00006F2C
.text$mn:00006F2C ; _DWORD __thiscall StaticDialog::~StaticDialog(StaticDialog *__hidden this)
.text$mn:00006F2C                 public ??1StaticDialog@@UAE@XZ
.text$mn:00006F2C ??1StaticDialog@@UAE@XZ proc near       ; CODE XREF: __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0+3j
.text$mn:00006F2C                                         ; __unwindfunclet$??0Shortcut@@QAE@PB_W_N11E@Z$0+3j ...
.text$mn:00006F2C
.text$mn:00006F2C var_10          = dword ptr -10h
.text$mn:00006F2C var_C           = dword ptr -0Ch
.text$mn:00006F2C var_4           = dword ptr -4
.text$mn:00006F2C
.text$mn:00006F2C                 push    ebp
.text$mn:00006F2D                 mov     ebp, esp
.text$mn:00006F2F                 push    0FFFFFFFFh
.text$mn:00006F31                 push    offset __ehhandler$??1StaticDialog@@UAE@XZ
.text$mn:00006F36                 mov     eax, large fs:0
.text$mn:00006F3C                 push    eax
.text$mn:00006F3D                 push    ecx
.text$mn:00006F3E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006F43                 xor     eax, ebp
.text$mn:00006F45                 push    eax
.text$mn:00006F46                 lea     eax, [ebp+var_C]
.text$mn:00006F49                 mov     large fs:0, eax
.text$mn:00006F4F                 mov     [ebp+var_10], ecx
.text$mn:00006F52                 mov     eax, [ebp+var_10]
.text$mn:00006F55                 mov     dword ptr [eax], offset ??_7StaticDialog@@6B@ ; const StaticDialog::`vftable'
.text$mn:00006F5B                 mov     [ebp+var_4], 0
.text$mn:00006F62                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006F65                 call    ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.text$mn:00006F6A                 movzx   ecx, al
.text$mn:00006F6D                 test    ecx, ecx
.text$mn:00006F6F                 jz      short loc_6F8A
.text$mn:00006F71                 push    0               ; dwNewLong
.text$mn:00006F73                 push    0FFFFFFEBh      ; nIndex
.text$mn:00006F75                 mov     edx, [ebp+var_10]
.text$mn:00006F78                 mov     eax, [edx+0Ch]
.text$mn:00006F7B                 push    eax             ; hWnd
.text$mn:00006F7C                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00006F82                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006F85                 call    ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.text$mn:00006F8A
.text$mn:00006F8A loc_6F8A:                               ; CODE XREF: StaticDialog::~StaticDialog(void)+43j
.text$mn:00006F8A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006F91                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006F94                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:00006F99                 mov     ecx, [ebp+var_C]
.text$mn:00006F9C                 mov     large fs:0, ecx
.text$mn:00006FA3                 pop     ecx
.text$mn:00006FA4                 mov     esp, ebp
.text$mn:00006FA6                 pop     ebp
.text$mn:00006FA7                 retn
.text$mn:00006FA7 ??1StaticDialog@@UAE@XZ endp
.text$mn:00006FA7
.text$mn:00006FA7 _text$mn        ends
.text$mn:00006FA7
.text$x:00006FA8 ; ===========================================================================
.text$x:00006FA8
.text$x:00006FA8 ; Segment type: Pure code
.text$x:00006FA8 ; Segment permissions: Read/Execute
.text$x:00006FA8 _text$x         segment para public 'CODE' use32
.text$x:00006FA8                 assume cs:_text$x
.text$x:00006FA8                 ;org 6FA8h
.text$x:00006FA8 ; COMDAT (pick associative to section at 6F2C)
.text$x:00006FA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006FA8
.text$x:00006FA8 ; =============== S U B R O U T I N E =======================================
.text$x:00006FA8
.text$x:00006FA8
.text$x:00006FA8 __unwindfunclet$??1StaticDialog@@UAE@XZ$0 proc near
.text$x:00006FA8                                         ; DATA XREF: .xdata$x:0000C984o
.text$x:00006FA8                 mov     ecx, [ebp-10h]  ; this
.text$x:00006FAB                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:00006FAB __unwindfunclet$??1StaticDialog@@UAE@XZ$0 endp
.text$x:00006FAB
.text$x:00006FB0
.text$x:00006FB0 ; =============== S U B R O U T I N E =======================================
.text$x:00006FB0
.text$x:00006FB0
.text$x:00006FB0 __ehhandler$??1StaticDialog@@UAE@XZ proc near
.text$x:00006FB0                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+5o
.text$x:00006FB0
.text$x:00006FB0 arg_4           = dword ptr  8
.text$x:00006FB0
.text$x:00006FB0                 mov     edx, [esp+arg_4]
.text$x:00006FB4                 lea     eax, [edx+0Ch]
.text$x:00006FB7                 mov     ecx, [edx-8]
.text$x:00006FBA                 xor     ecx, eax
.text$x:00006FBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006FC1                 mov     eax, offset __ehfuncinfo$??1StaticDialog@@UAE@XZ
.text$x:00006FC6                 jmp     ___CxxFrameHandler3
.text$x:00006FC6 __ehhandler$??1StaticDialog@@UAE@XZ endp
.text$x:00006FC6
.text$x:00006FC6 ; ---------------------------------------------------------------------------
.text$x:00006FCB                 align 4
.text$x:00006FCB _text$x         ends
.text$x:00006FCB
.text$mn:00006FCC ; ===========================================================================
.text$mn:00006FCC
.text$mn:00006FCC ; Segment type: Pure code
.text$mn:00006FCC ; Segment permissions: Read/Execute
.text$mn:00006FCC _text$mn        segment para public 'CODE' use32
.text$mn:00006FCC                 assume cs:_text$mn
.text$mn:00006FCC                 ;org 6FCCh
.text$mn:00006FCC ; COMDAT (pick any)
.text$mn:00006FCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006FCC
.text$mn:00006FCC ; =============== S U B R O U T I N E =======================================
.text$mn:00006FCC
.text$mn:00006FCC ; Attributes: bp-based frame
.text$mn:00006FCC
.text$mn:00006FCC ; _DWORD __thiscall Window::~Window(Window *__hidden this)
.text$mn:00006FCC                 public ??1Window@@UAE@XZ
.text$mn:00006FCC ??1Window@@UAE@XZ proc near             ; CODE XREF: __unwindfunclet$??0StaticDialog@@QAE@XZ$0+3j
.text$mn:00006FCC                                         ; StaticDialog::~StaticDialog(void)+68p ...
.text$mn:00006FCC
.text$mn:00006FCC var_4           = dword ptr -4
.text$mn:00006FCC
.text$mn:00006FCC                 push    ebp
.text$mn:00006FCD                 mov     ebp, esp
.text$mn:00006FCF                 push    ecx
.text$mn:00006FD0                 mov     [ebp+var_4], ecx
.text$mn:00006FD3                 mov     eax, [ebp+var_4]
.text$mn:00006FD6                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00006FDC                 mov     esp, ebp
.text$mn:00006FDE                 pop     ebp
.text$mn:00006FDF                 retn
.text$mn:00006FDF ??1Window@@UAE@XZ endp
.text$mn:00006FDF
.text$mn:00006FDF _text$mn        ends
.text$mn:00006FDF
.text$mn:00006FE0 ; ===========================================================================
.text$mn:00006FE0
.text$mn:00006FE0 ; Segment type: Pure code
.text$mn:00006FE0 ; Segment permissions: Read/Execute
.text$mn:00006FE0 _text$mn        segment para public 'CODE' use32
.text$mn:00006FE0                 assume cs:_text$mn
.text$mn:00006FE0                 ;org 6FE0h
.text$mn:00006FE0 ; COMDAT (pick any)
.text$mn:00006FE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006FE0
.text$mn:00006FE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FE0
.text$mn:00006FE0 ; Attributes: bp-based frame
.text$mn:00006FE0
.text$mn:00006FE0 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00006FE0                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00006FE0 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00006FE0                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00006FE0                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z$0+3j ...
.text$mn:00006FE0
.text$mn:00006FE0 var_4           = dword ptr -4
.text$mn:00006FE0
.text$mn:00006FE0                 push    ebp
.text$mn:00006FE1                 mov     ebp, esp
.text$mn:00006FE3                 push    ecx
.text$mn:00006FE4                 mov     [ebp+var_4], ecx
.text$mn:00006FE7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006FEA                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006FEF                 mov     esp, ebp
.text$mn:00006FF1                 pop     ebp
.text$mn:00006FF2                 retn
.text$mn:00006FF2 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00006FF2
.text$mn:00006FF2 ; ---------------------------------------------------------------------------
.text$mn:00006FF3                 align 4
.text$mn:00006FF3 _text$mn        ends
.text$mn:00006FF3
.text$mn:00006FF4 ; ===========================================================================
.text$mn:00006FF4
.text$mn:00006FF4 ; Segment type: Pure code
.text$mn:00006FF4 ; Segment permissions: Read/Execute
.text$mn:00006FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00006FF4                 assume cs:_text$mn
.text$mn:00006FF4                 ;org 6FF4h
.text$mn:00006FF4 ; COMDAT (pick any)
.text$mn:00006FF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006FF4
.text$mn:00006FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FF4
.text$mn:00006FF4 ; Attributes: bp-based frame
.text$mn:00006FF4
.text$mn:00006FF4 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00006FF4                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00006FF4 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00006FF4                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00006FF4                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00006FF4
.text$mn:00006FF4 var_10          = dword ptr -10h
.text$mn:00006FF4 var_C           = dword ptr -0Ch
.text$mn:00006FF4 var_4           = dword ptr -4
.text$mn:00006FF4
.text$mn:00006FF4                 push    ebp
.text$mn:00006FF5                 mov     ebp, esp
.text$mn:00006FF7                 push    0FFFFFFFFh
.text$mn:00006FF9                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00006FFE                 mov     eax, large fs:0
.text$mn:00007004                 push    eax
.text$mn:00007005                 push    ecx
.text$mn:00007006                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000700B                 xor     eax, ebp
.text$mn:0000700D                 push    eax
.text$mn:0000700E                 lea     eax, [ebp+var_C]
.text$mn:00007011                 mov     large fs:0, eax
.text$mn:00007017                 mov     [ebp+var_10], ecx
.text$mn:0000701A                 mov     [ebp+var_4], 0
.text$mn:00007021                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007028                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000702B                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00007030                 mov     ecx, [ebp+var_C]
.text$mn:00007033                 mov     large fs:0, ecx
.text$mn:0000703A                 pop     ecx
.text$mn:0000703B                 mov     esp, ebp
.text$mn:0000703D                 pop     ebp
.text$mn:0000703E                 retn
.text$mn:0000703E ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000703E
.text$mn:0000703E ; ---------------------------------------------------------------------------
.text$mn:0000703F                 align 10h
.text$mn:0000703F _text$mn        ends
.text$mn:0000703F
.text$x:00007040 ; ===========================================================================
.text$x:00007040
.text$x:00007040 ; Segment type: Pure code
.text$x:00007040 ; Segment permissions: Read/Execute
.text$x:00007040 _text$x         segment para public 'CODE' use32
.text$x:00007040                 assume cs:_text$x
.text$x:00007040                 ;org 7040h
.text$x:00007040 ; COMDAT (pick associative to section at 6FF4)
.text$x:00007040                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007040
.text$x:00007040 ; =============== S U B R O U T I N E =======================================
.text$x:00007040
.text$x:00007040
.text$x:00007040 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00007040                                         ; DATA XREF: .xdata$x:0000C5B4o
.text$x:00007040                 mov     ecx, [ebp-10h]  ; this
.text$x:00007043                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00007043 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00007043
.text$x:00007048
.text$x:00007048 ; =============== S U B R O U T I N E =======================================
.text$x:00007048
.text$x:00007048
.text$x:00007048 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00007048                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00007048
.text$x:00007048 arg_4           = dword ptr  8
.text$x:00007048
.text$x:00007048                 mov     edx, [esp+arg_4]
.text$x:0000704C                 lea     eax, [edx+0Ch]
.text$x:0000704F                 mov     ecx, [edx-8]
.text$x:00007052                 xor     ecx, eax
.text$x:00007054                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007059                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:0000705E                 jmp     ___CxxFrameHandler3
.text$x:0000705E __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:0000705E
.text$x:0000705E ; ---------------------------------------------------------------------------
.text$x:00007063                 align 4
.text$x:00007063 _text$x         ends
.text$x:00007063
.text$mn:00007064 ; ===========================================================================
.text$mn:00007064
.text$mn:00007064 ; Segment type: Pure code
.text$mn:00007064 ; Segment permissions: Read/Execute
.text$mn:00007064 _text$mn        segment para public 'CODE' use32
.text$mn:00007064                 assume cs:_text$mn
.text$mn:00007064                 ;org 7064h
.text$mn:00007064 ; COMDAT (pick any)
.text$mn:00007064                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007064
.text$mn:00007064 ; =============== S U B R O U T I N E =======================================
.text$mn:00007064
.text$mn:00007064 ; Attributes: bp-based frame
.text$mn:00007064
.text$mn:00007064 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00007064                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00007064 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00007064                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00007064                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00007064
.text$mn:00007064 var_10          = dword ptr -10h
.text$mn:00007064 var_C           = dword ptr -0Ch
.text$mn:00007064 var_4           = dword ptr -4
.text$mn:00007064
.text$mn:00007064                 push    ebp
.text$mn:00007065                 mov     ebp, esp
.text$mn:00007067                 push    0FFFFFFFFh
.text$mn:00007069                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000706E                 mov     eax, large fs:0
.text$mn:00007074                 push    eax
.text$mn:00007075                 push    ecx
.text$mn:00007076                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000707B                 xor     eax, ebp
.text$mn:0000707D                 push    eax
.text$mn:0000707E                 lea     eax, [ebp+var_C]
.text$mn:00007081                 mov     large fs:0, eax
.text$mn:00007087                 mov     [ebp+var_10], ecx
.text$mn:0000708A                 mov     [ebp+var_4], 0
.text$mn:00007091                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007098                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000709B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000070A0                 mov     ecx, [ebp+var_C]
.text$mn:000070A3                 mov     large fs:0, ecx
.text$mn:000070AA                 pop     ecx
.text$mn:000070AB                 mov     esp, ebp
.text$mn:000070AD                 pop     ebp
.text$mn:000070AE                 retn
.text$mn:000070AE ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:000070AE
.text$mn:000070AE ; ---------------------------------------------------------------------------
.text$mn:000070AF                 align 10h
.text$mn:000070AF _text$mn        ends
.text$mn:000070AF
.text$x:000070B0 ; ===========================================================================
.text$x:000070B0
.text$x:000070B0 ; Segment type: Pure code
.text$x:000070B0 ; Segment permissions: Read/Execute
.text$x:000070B0 _text$x         segment para public 'CODE' use32
.text$x:000070B0                 assume cs:_text$x
.text$x:000070B0                 ;org 70B0h
.text$x:000070B0 ; COMDAT (pick associative to section at 7064)
.text$x:000070B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000070B0
.text$x:000070B0 ; =============== S U B R O U T I N E =======================================
.text$x:000070B0
.text$x:000070B0
.text$x:000070B0 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:000070B0                                         ; DATA XREF: .xdata$x:0000C638o
.text$x:000070B0                 mov     ecx, [ebp-10h]  ; this
.text$x:000070B3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000070B3 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:000070B3
.text$x:000070B8
.text$x:000070B8 ; =============== S U B R O U T I N E =======================================
.text$x:000070B8
.text$x:000070B8
.text$x:000070B8 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:000070B8                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:000070B8
.text$x:000070B8 arg_4           = dword ptr  8
.text$x:000070B8
.text$x:000070B8                 mov     edx, [esp+arg_4]
.text$x:000070BC                 lea     eax, [edx+0Ch]
.text$x:000070BF                 mov     ecx, [edx-8]
.text$x:000070C2                 xor     ecx, eax
.text$x:000070C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000070C9                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:000070CE                 jmp     ___CxxFrameHandler3
.text$x:000070CE __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:000070CE
.text$x:000070CE ; ---------------------------------------------------------------------------
.text$x:000070D3                 align 4
.text$x:000070D3 _text$x         ends
.text$x:000070D3
.text$mn:000070D4 ; ===========================================================================
.text$mn:000070D4
.text$mn:000070D4 ; Segment type: Pure code
.text$mn:000070D4 ; Segment permissions: Read/Execute
.text$mn:000070D4 _text$mn        segment para public 'CODE' use32
.text$mn:000070D4                 assume cs:_text$mn
.text$mn:000070D4                 ;org 70D4h
.text$mn:000070D4 ; COMDAT (pick any)
.text$mn:000070D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000070D4
.text$mn:000070D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000070D4
.text$mn:000070D4 ; Attributes: bp-based frame
.text$mn:000070D4
.text$mn:000070D4 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000070D4                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:000070D4 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:000070D4                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000070D4                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000070D4
.text$mn:000070D4 var_10          = dword ptr -10h
.text$mn:000070D4 var_C           = dword ptr -0Ch
.text$mn:000070D4 var_4           = dword ptr -4
.text$mn:000070D4
.text$mn:000070D4                 push    ebp
.text$mn:000070D5                 mov     ebp, esp
.text$mn:000070D7                 push    0FFFFFFFFh
.text$mn:000070D9                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:000070DE                 mov     eax, large fs:0
.text$mn:000070E4                 push    eax
.text$mn:000070E5                 push    ecx
.text$mn:000070E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000070EB                 xor     eax, ebp
.text$mn:000070ED                 push    eax
.text$mn:000070EE                 lea     eax, [ebp+var_C]
.text$mn:000070F1                 mov     large fs:0, eax
.text$mn:000070F7                 mov     [ebp+var_10], ecx
.text$mn:000070FA                 mov     [ebp+var_4], 0
.text$mn:00007101                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007108                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000710B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007110                 mov     ecx, [ebp+var_C]
.text$mn:00007113                 mov     large fs:0, ecx
.text$mn:0000711A                 pop     ecx
.text$mn:0000711B                 mov     esp, ebp
.text$mn:0000711D                 pop     ebp
.text$mn:0000711E                 retn
.text$mn:0000711E ??1_System_error_category@std@@UAE@XZ endp
.text$mn:0000711E
.text$mn:0000711E ; ---------------------------------------------------------------------------
.text$mn:0000711F                 align 10h
.text$mn:0000711F _text$mn        ends
.text$mn:0000711F
.text$x:00007120 ; ===========================================================================
.text$x:00007120
.text$x:00007120 ; Segment type: Pure code
.text$x:00007120 ; Segment permissions: Read/Execute
.text$x:00007120 _text$x         segment para public 'CODE' use32
.text$x:00007120                 assume cs:_text$x
.text$x:00007120                 ;org 7120h
.text$x:00007120 ; COMDAT (pick associative to section at 70D4)
.text$x:00007120                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007120
.text$x:00007120 ; =============== S U B R O U T I N E =======================================
.text$x:00007120
.text$x:00007120
.text$x:00007120 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00007120                                         ; DATA XREF: .xdata$x:0000C6BCo
.text$x:00007120                 mov     ecx, [ebp-10h]  ; this
.text$x:00007123                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00007123 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00007123
.text$x:00007128
.text$x:00007128 ; =============== S U B R O U T I N E =======================================
.text$x:00007128
.text$x:00007128
.text$x:00007128 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00007128                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00007128
.text$x:00007128 arg_4           = dword ptr  8
.text$x:00007128
.text$x:00007128                 mov     edx, [esp+arg_4]
.text$x:0000712C                 lea     eax, [edx+0Ch]
.text$x:0000712F                 mov     ecx, [edx-8]
.text$x:00007132                 xor     ecx, eax
.text$x:00007134                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007139                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:0000713E                 jmp     ___CxxFrameHandler3
.text$x:0000713E __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:0000713E
.text$x:0000713E ; ---------------------------------------------------------------------------
.text$x:00007143                 align 4
.text$x:00007143 _text$x         ends
.text$x:00007143
.text$mn:00007144 ; ===========================================================================
.text$mn:00007144
.text$mn:00007144 ; Segment type: Pure code
.text$mn:00007144 ; Segment permissions: Read/Execute
.text$mn:00007144 _text$mn        segment para public 'CODE' use32
.text$mn:00007144                 assume cs:_text$mn
.text$mn:00007144                 ;org 7144h
.text$mn:00007144 ; COMDAT (pick any)
.text$mn:00007144                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007144
.text$mn:00007144 ; =============== S U B R O U T I N E =======================================
.text$mn:00007144
.text$mn:00007144 ; Attributes: bp-based frame
.text$mn:00007144
.text$mn:00007144 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00007144                 public ??1error_category@std@@UAE@XZ
.text$mn:00007144 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00007144                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00007144
.text$mn:00007144 var_4           = dword ptr -4
.text$mn:00007144
.text$mn:00007144                 push    ebp
.text$mn:00007145                 mov     ebp, esp
.text$mn:00007147                 push    ecx
.text$mn:00007148                 mov     [ebp+var_4], ecx
.text$mn:0000714B                 mov     eax, [ebp+var_4]
.text$mn:0000714E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00007154                 mov     esp, ebp
.text$mn:00007156                 pop     ebp
.text$mn:00007157                 retn
.text$mn:00007157 ??1error_category@std@@UAE@XZ endp
.text$mn:00007157
.text$mn:00007157 _text$mn        ends
.text$mn:00007157
.text$mn:00007158 ; ===========================================================================
.text$mn:00007158
.text$mn:00007158 ; Segment type: Pure code
.text$mn:00007158 ; Segment permissions: Read/Execute
.text$mn:00007158 _text$mn        segment para public 'CODE' use32
.text$mn:00007158                 assume cs:_text$mn
.text$mn:00007158                 ;org 7158h
.text$mn:00007158 ; COMDAT (pick any)
.text$mn:00007158                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007158
.text$mn:00007158 ; =============== S U B R O U T I N E =======================================
.text$mn:00007158
.text$mn:00007158 ; Attributes: bp-based frame
.text$mn:00007158
.text$mn:00007158 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00007158                 public ??2@YAPAXIPAX@Z
.text$mn:00007158 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00007158                                         ; std::allocator<PluginInfo *>::construct<PluginInfo *,PluginInfo * &>(PluginInfo * *,PluginInfo * &)+2Ep ...
.text$mn:00007158
.text$mn:00007158 arg_4           = dword ptr  0Ch
.text$mn:00007158
.text$mn:00007158                 push    ebp
.text$mn:00007159                 mov     ebp, esp
.text$mn:0000715B                 mov     eax, [ebp+arg_4]
.text$mn:0000715E                 pop     ebp
.text$mn:0000715F                 retn
.text$mn:0000715F ??2@YAPAXIPAX@Z endp
.text$mn:0000715F
.text$mn:0000715F _text$mn        ends
.text$mn:0000715F
.text$mn:00007160 ; ===========================================================================
.text$mn:00007160
.text$mn:00007160 ; Segment type: Pure code
.text$mn:00007160 ; Segment permissions: Read/Execute
.text$mn:00007160 _text$mn        segment para public 'CODE' use32
.text$mn:00007160                 assume cs:_text$mn
.text$mn:00007160                 ;org 7160h
.text$mn:00007160 ; COMDAT (pick any)
.text$mn:00007160                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007160
.text$mn:00007160 ; =============== S U B R O U T I N E =======================================
.text$mn:00007160
.text$mn:00007160 ; Attributes: bp-based frame
.text$mn:00007160
.text$mn:00007160 ; void __cdecl operator delete(void *)
.text$mn:00007160                 public ??3@YAXPAX0@Z
.text$mn:00007160 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00007160                                         ; __unwindfunclet$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z$0+8p ...
.text$mn:00007160                 push    ebp
.text$mn:00007161                 mov     ebp, esp
.text$mn:00007163                 pop     ebp
.text$mn:00007164                 retn
.text$mn:00007164 ??3@YAXPAX0@Z   endp
.text$mn:00007164
.text$mn:00007164 ; ---------------------------------------------------------------------------
.text$mn:00007165                 align 4
.text$mn:00007165 _text$mn        ends
.text$mn:00007165
.text$mn:00007168 ; ===========================================================================
.text$mn:00007168
.text$mn:00007168 ; Segment type: Pure code
.text$mn:00007168 ; Segment permissions: Read/Execute
.text$mn:00007168 _text$mn        segment para public 'CODE' use32
.text$mn:00007168                 assume cs:_text$mn
.text$mn:00007168                 ;org 7168h
.text$mn:00007168 ; COMDAT (pick any)
.text$mn:00007168                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007168
.text$mn:00007168 ; =============== S U B R O U T I N E =======================================
.text$mn:00007168
.text$mn:00007168 ; Attributes: bp-based frame
.text$mn:00007168
.text$mn:00007168 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:00007168                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00007168 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00007168                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+DFp
.text$mn:00007168
.text$mn:00007168 var_4           = dword ptr -4
.text$mn:00007168 Str             = dword ptr  8
.text$mn:00007168
.text$mn:00007168                 push    ebp
.text$mn:00007169                 mov     ebp, esp
.text$mn:0000716B                 push    ecx
.text$mn:0000716C                 mov     [ebp+var_4], ecx
.text$mn:0000716F                 mov     eax, [ebp+Str]
.text$mn:00007172                 push    eax             ; Str
.text$mn:00007173                 mov     ecx, [ebp+var_4]
.text$mn:00007176                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:0000717B                 mov     esp, ebp
.text$mn:0000717D                 pop     ebp
.text$mn:0000717E                 retn    4
.text$mn:0000717E ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:0000717E
.text$mn:0000717E ; ---------------------------------------------------------------------------
.text$mn:00007181                 align 4
.text$mn:00007181 _text$mn        ends
.text$mn:00007181
.text$mn:00007184 ; ===========================================================================
.text$mn:00007184
.text$mn:00007184 ; Segment type: Pure code
.text$mn:00007184 ; Segment permissions: Read/Execute
.text$mn:00007184 _text$mn        segment para public 'CODE' use32
.text$mn:00007184                 assume cs:_text$mn
.text$mn:00007184                 ;org 7184h
.text$mn:00007184 ; COMDAT (pick any)
.text$mn:00007184                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007184
.text$mn:00007184 ; =============== S U B R O U T I N E =======================================
.text$mn:00007184
.text$mn:00007184 ; Attributes: bp-based frame
.text$mn:00007184
.text$mn:00007184 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00007184                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00007184 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00007184                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00007184                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00007184
.text$mn:00007184 var_8           = dword ptr -8
.text$mn:00007184 var_4           = dword ptr -4
.text$mn:00007184 arg_0           = dword ptr  8
.text$mn:00007184
.text$mn:00007184                 push    ebp
.text$mn:00007185                 mov     ebp, esp
.text$mn:00007187                 sub     esp, 8
.text$mn:0000718A                 mov     [ebp+var_8], ecx
.text$mn:0000718D                 mov     eax, [ebp+var_8]
.text$mn:00007190                 cmp     eax, [ebp+arg_0]
.text$mn:00007193                 jnz     short loc_719E
.text$mn:00007195                 mov     [ebp+var_4], 1
.text$mn:0000719C                 jmp     short loc_71A5
.text$mn:0000719E ; ---------------------------------------------------------------------------
.text$mn:0000719E
.text$mn:0000719E loc_719E:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000719E                 mov     [ebp+var_4], 0
.text$mn:000071A5
.text$mn:000071A5 loc_71A5:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:000071A5                 mov     al, byte ptr [ebp+var_4]
.text$mn:000071A8                 mov     esp, ebp
.text$mn:000071AA                 pop     ebp
.text$mn:000071AB                 retn    4
.text$mn:000071AB ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:000071AB
.text$mn:000071AB ; ---------------------------------------------------------------------------
.text$mn:000071AE                 align 10h
.text$mn:000071AE _text$mn        ends
.text$mn:000071AE
.text$mn:000071B0 ; ===========================================================================
.text$mn:000071B0
.text$mn:000071B0 ; Segment type: Pure code
.text$mn:000071B0 ; Segment permissions: Read/Execute
.text$mn:000071B0 _text$mn        segment para public 'CODE' use32
.text$mn:000071B0                 assume cs:_text$mn
.text$mn:000071B0                 ;org 71B0h
.text$mn:000071B0 ; COMDAT (pick any)
.text$mn:000071B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000071B0
.text$mn:000071B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000071B0
.text$mn:000071B0 ; Attributes: bp-based frame
.text$mn:000071B0
.text$mn:000071B0 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:000071B0                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:000071B0 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:000071B0                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:000071B0
.text$mn:000071B0 var_8           = dword ptr -8
.text$mn:000071B0 var_4           = dword ptr -4
.text$mn:000071B0 arg_0           = dword ptr  8
.text$mn:000071B0
.text$mn:000071B0                 push    ebp
.text$mn:000071B1                 mov     ebp, esp
.text$mn:000071B3                 sub     esp, 8
.text$mn:000071B6                 push    esi
.text$mn:000071B7                 mov     [ebp+var_4], ecx
.text$mn:000071BA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000071BD                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000071C2                 push    eax
.text$mn:000071C3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000071C6                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000071CB                 mov     ecx, eax
.text$mn:000071CD                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000071D2                 movzx   eax, al
.text$mn:000071D5                 test    eax, eax
.text$mn:000071D7                 jz      short loc_71F8
.text$mn:000071D9                 mov     ecx, [ebp+var_4] ; this
.text$mn:000071DC                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000071E1                 mov     esi, eax
.text$mn:000071E3                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000071E6                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000071EB                 cmp     esi, eax
.text$mn:000071ED                 jnz     short loc_71F8
.text$mn:000071EF                 mov     [ebp+var_8], 1
.text$mn:000071F6                 jmp     short loc_71FF
.text$mn:000071F8 ; ---------------------------------------------------------------------------
.text$mn:000071F8
.text$mn:000071F8 loc_71F8:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000071F8                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000071F8                 mov     [ebp+var_8], 0
.text$mn:000071FF
.text$mn:000071FF loc_71FF:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000071FF                 mov     al, byte ptr [ebp+var_8]
.text$mn:00007202                 pop     esi
.text$mn:00007203                 mov     esp, ebp
.text$mn:00007205                 pop     ebp
.text$mn:00007206                 retn    4
.text$mn:00007206 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00007206
.text$mn:00007206 ; ---------------------------------------------------------------------------
.text$mn:00007209                 align 4
.text$mn:00007209 _text$mn        ends
.text$mn:00007209
.text$mn:0000720C ; ===========================================================================
.text$mn:0000720C
.text$mn:0000720C ; Segment type: Pure code
.text$mn:0000720C ; Segment permissions: Read/Execute
.text$mn:0000720C _text$mn        segment para public 'CODE' use32
.text$mn:0000720C                 assume cs:_text$mn
.text$mn:0000720C                 ;org 720Ch
.text$mn:0000720C ; COMDAT (pick any)
.text$mn:0000720C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000720C
.text$mn:0000720C ; =============== S U B R O U T I N E =======================================
.text$mn:0000720C
.text$mn:0000720C ; Attributes: bp-based frame
.text$mn:0000720C
.text$mn:0000720C ; public: wchar_t const & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator[](unsigned int)const
.text$mn:0000720C                 public ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z
.text$mn:0000720C ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z proc near
.text$mn:0000720C                                         ; CODE XREF: PluginCmdShortcut::isValid(void)+25p
.text$mn:0000720C
.text$mn:0000720C var_4           = dword ptr -4
.text$mn:0000720C arg_0           = dword ptr  8
.text$mn:0000720C
.text$mn:0000720C                 push    ebp
.text$mn:0000720D                 mov     ebp, esp
.text$mn:0000720F                 push    ecx
.text$mn:00007210                 mov     [ebp+var_4], ecx
.text$mn:00007213                 mov     eax, [ebp+var_4]
.text$mn:00007216                 mov     ecx, [eax+14h]
.text$mn:00007219                 cmp     ecx, [ebp+arg_0]
.text$mn:0000721C                 jnb     short loc_7235
.text$mn:0000721E                 push    6A2h            ; unsigned int
.text$mn:00007223                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007228                 push    offset ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "string subscript out of range"
.text$mn:0000722D                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007232                 add     esp, 0Ch
.text$mn:00007235
.text$mn:00007235 loc_7235:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+10j
.text$mn:00007235                 mov     ecx, [ebp+var_4]
.text$mn:00007238                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000723D                 mov     edx, [ebp+arg_0]
.text$mn:00007240                 lea     eax, [eax+edx*2]
.text$mn:00007243                 mov     esp, ebp
.text$mn:00007245                 pop     ebp
.text$mn:00007246                 retn    4
.text$mn:00007246 ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z endp
.text$mn:00007246
.text$mn:00007246 ; ---------------------------------------------------------------------------
.text$mn:00007249                 align 4
.text$mn:00007249 _text$mn        ends
.text$mn:00007249
.text$mn:0000724C ; ===========================================================================
.text$mn:0000724C
.text$mn:0000724C ; Segment type: Pure code
.text$mn:0000724C ; Segment permissions: Read/Execute
.text$mn:0000724C _text$mn        segment para public 'CODE' use32
.text$mn:0000724C                 assume cs:_text$mn
.text$mn:0000724C                 ;org 724Ch
.text$mn:0000724C ; COMDAT (pick any)
.text$mn:0000724C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000724C
.text$mn:0000724C ; =============== S U B R O U T I N E =======================================
.text$mn:0000724C
.text$mn:0000724C ; Attributes: bp-based frame
.text$mn:0000724C
.text$mn:0000724C ; public: struct PluginInfo * & __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::operator[](unsigned int)
.text$mn:0000724C                 public ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z
.text$mn:0000724C ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z proc near
.text$mn:0000724C                                         ; CODE XREF: PluginsManager::unloadPlugin(int,HWND__ *)+2Bp
.text$mn:0000724C                                         ; PluginsManager::unloadPlugin(int,HWND__ *)+44p ...
.text$mn:0000724C
.text$mn:0000724C var_4           = dword ptr -4
.text$mn:0000724C arg_0           = dword ptr  8
.text$mn:0000724C
.text$mn:0000724C                 push    ebp
.text$mn:0000724D                 mov     ebp, esp
.text$mn:0000724F                 push    ecx
.text$mn:00007250                 mov     [ebp+var_4], ecx
.text$mn:00007253                 mov     ecx, [ebp+var_4]
.text$mn:00007256                 call    ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::size(void)
.text$mn:0000725B                 cmp     eax, [ebp+arg_0]
.text$mn:0000725E                 ja      short loc_72C8
.text$mn:00007260                 push    4B1h            ; unsigned int
.text$mn:00007265                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000726A                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000726F                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007274                 add     esp, 0Ch
.text$mn:00007277                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000727C                 test    eax, eax
.text$mn:0000727E                 jz      short loc_7284
.text$mn:00007280                 xor     ecx, ecx
.text$mn:00007282                 jnz     short loc_72AA
.text$mn:00007284
.text$mn:00007284 loc_7284:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+32j
.text$mn:00007284                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00007289                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000728E                 push    0
.text$mn:00007290                 push    4B2h
.text$mn:00007295                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000729A                 push    2
.text$mn:0000729C                 call    __CrtDbgReportW
.text$mn:000072A1                 add     esp, 18h
.text$mn:000072A4                 cmp     eax, 1
.text$mn:000072A7                 jnz     short loc_72AA
.text$mn:000072A9                 int     3               ; Trap to Debugger
.text$mn:000072AA
.text$mn:000072AA loc_72AA:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+36j
.text$mn:000072AA                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+5Bj
.text$mn:000072AA                 push    0
.text$mn:000072AC                 push    4B2h
.text$mn:000072B1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000072B6                 push    offset ??_C@_1LC@MEDJDKJA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAI?$AAn?$AAf?$AAo?$AA?5?$AA?$CK?$AA?0@ ; "std::vector<struct PluginInfo *,class s"...
.text$mn:000072BB                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000072C0                 call    __invalid_parameter
.text$mn:000072C5                 add     esp, 14h
.text$mn:000072C8
.text$mn:000072C8 loc_72C8:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+12j
.text$mn:000072C8                 mov     eax, [ebp+var_4]
.text$mn:000072CB                 mov     ecx, [eax+4]
.text$mn:000072CE                 mov     edx, [ebp+arg_0]
.text$mn:000072D1                 lea     eax, [ecx+edx*4]
.text$mn:000072D4                 mov     esp, ebp
.text$mn:000072D6                 pop     ebp
.text$mn:000072D7                 retn    4
.text$mn:000072D7 ??A?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEAAPAUPluginInfo@@I@Z endp
.text$mn:000072D7
.text$mn:000072D7 ; ---------------------------------------------------------------------------
.text$mn:000072DA                 align 4
.text$mn:000072DA _text$mn        ends
.text$mn:000072DA
.text$mn:000072DC ; ===========================================================================
.text$mn:000072DC
.text$mn:000072DC ; Segment type: Pure code
.text$mn:000072DC ; Segment permissions: Read/Execute
.text$mn:000072DC _text$mn        segment para public 'CODE' use32
.text$mn:000072DC                 assume cs:_text$mn
.text$mn:000072DC                 ;org 72DCh
.text$mn:000072DC ; COMDAT (pick any)
.text$mn:000072DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000072DC
.text$mn:000072DC ; =============== S U B R O U T I N E =======================================
.text$mn:000072DC
.text$mn:000072DC ; Attributes: bp-based frame
.text$mn:000072DC
.text$mn:000072DC ; public: struct PluginCommand & __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::operator[](unsigned int)
.text$mn:000072DC                 public ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z
.text$mn:000072DC ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z proc near
.text$mn:000072DC                                         ; CODE XREF: PluginsManager::runPluginCommand(uint)+5Cp
.text$mn:000072DC                                         ; PluginsManager::runPluginCommand(uint)+7Fp ...
.text$mn:000072DC
.text$mn:000072DC var_4           = dword ptr -4
.text$mn:000072DC arg_0           = dword ptr  8
.text$mn:000072DC
.text$mn:000072DC                 push    ebp
.text$mn:000072DD                 mov     ebp, esp
.text$mn:000072DF                 push    ecx
.text$mn:000072E0                 mov     [ebp+var_4], ecx
.text$mn:000072E3                 mov     ecx, [ebp+var_4]
.text$mn:000072E6                 call    ?size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::size(void)
.text$mn:000072EB                 cmp     eax, [ebp+arg_0]
.text$mn:000072EE                 ja      short loc_7358
.text$mn:000072F0                 push    4B1h            ; unsigned int
.text$mn:000072F5                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000072FA                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:000072FF                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007304                 add     esp, 0Ch
.text$mn:00007307                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000730C                 test    eax, eax
.text$mn:0000730E                 jz      short loc_7314
.text$mn:00007310                 xor     ecx, ecx
.text$mn:00007312                 jnz     short loc_733A
.text$mn:00007314
.text$mn:00007314 loc_7314:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+32j
.text$mn:00007314                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00007319                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000731E                 push    0
.text$mn:00007320                 push    4B2h
.text$mn:00007325                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000732A                 push    2
.text$mn:0000732C                 call    __CrtDbgReportW
.text$mn:00007331                 add     esp, 18h
.text$mn:00007334                 cmp     eax, 1
.text$mn:00007337                 jnz     short loc_733A
.text$mn:00007339                 int     3               ; Trap to Debugger
.text$mn:0000733A
.text$mn:0000733A loc_733A:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+36j
.text$mn:0000733A                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+5Bj
.text$mn:0000733A                 push    0
.text$mn:0000733C                 push    4B2h
.text$mn:00007341                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007346                 push    offset ??_C@_1LG@PIMEHHBL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd@ ; "std::vector<struct PluginCommand,class "...
.text$mn:0000734B                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00007350                 call    __invalid_parameter
.text$mn:00007355                 add     esp, 14h
.text$mn:00007358
.text$mn:00007358 loc_7358:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+12j
.text$mn:00007358                 imul    eax, [ebp+arg_0], 24h
.text$mn:0000735C                 mov     ecx, [ebp+var_4]
.text$mn:0000735F                 add     eax, [ecx+4]
.text$mn:00007362                 mov     esp, ebp
.text$mn:00007364                 pop     ebp
.text$mn:00007365                 retn    4
.text$mn:00007365 ??A?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEAAUPluginCommand@@I@Z endp
.text$mn:00007365
.text$mn:00007365 _text$mn        ends
.text$mn:00007365
.text$mn:00007368 ; ===========================================================================
.text$mn:00007368
.text$mn:00007368 ; Segment type: Pure code
.text$mn:00007368 ; Segment permissions: Read/Execute
.text$mn:00007368 _text$mn        segment para public 'CODE' use32
.text$mn:00007368                 assume cs:_text$mn
.text$mn:00007368                 ;org 7368h
.text$mn:00007368 ; COMDAT (pick any)
.text$mn:00007368                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007368
.text$mn:00007368 ; =============== S U B R O U T I N E =======================================
.text$mn:00007368
.text$mn:00007368 ; Attributes: bp-based frame
.text$mn:00007368
.text$mn:00007368 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::operator[](unsigned int)
.text$mn:00007368                 public ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z
.text$mn:00007368 ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z proc near
.text$mn:00007368                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+519p
.text$mn:00007368                                         ; PluginsManager::loadPlugins(wchar_t const *)+586p ...
.text$mn:00007368
.text$mn:00007368 var_4           = dword ptr -4
.text$mn:00007368 arg_0           = dword ptr  8
.text$mn:00007368
.text$mn:00007368                 push    ebp
.text$mn:00007369                 mov     ebp, esp
.text$mn:0000736B                 push    ecx
.text$mn:0000736C                 mov     [ebp+var_4], ecx
.text$mn:0000736F                 mov     ecx, [ebp+var_4]
.text$mn:00007372                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:00007377                 cmp     eax, [ebp+arg_0]
.text$mn:0000737A                 ja      short loc_73E4
.text$mn:0000737C                 push    4B1h            ; unsigned int
.text$mn:00007381                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007386                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000738B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007390                 add     esp, 0Ch
.text$mn:00007393                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00007398                 test    eax, eax
.text$mn:0000739A                 jz      short loc_73A0
.text$mn:0000739C                 xor     ecx, ecx
.text$mn:0000739E                 jnz     short loc_73C6
.text$mn:000073A0
.text$mn:000073A0 loc_73A0:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+32j
.text$mn:000073A0                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:000073A5                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000073AA                 push    0
.text$mn:000073AC                 push    4B2h
.text$mn:000073B1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000073B6                 push    2
.text$mn:000073B8                 call    __CrtDbgReportW
.text$mn:000073BD                 add     esp, 18h
.text$mn:000073C0                 cmp     eax, 1
.text$mn:000073C3                 jnz     short loc_73C6
.text$mn:000073C5                 int     3               ; Trap to Debugger
.text$mn:000073C6
.text$mn:000073C6 loc_73C6:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+36j
.text$mn:000073C6                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+5Bj
.text$mn:000073C6                 push    0
.text$mn:000073C8                 push    4B2h
.text$mn:000073CD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000073D2                 push    offset ??_C@_1BOI@OCMBMPPD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@ ; "std::vector<class std::basic_string<wch"...
.text$mn:000073D7                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000073DC                 call    __invalid_parameter
.text$mn:000073E1                 add     esp, 14h
.text$mn:000073E4
.text$mn:000073E4 loc_73E4:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+12j
.text$mn:000073E4                 imul    eax, [ebp+arg_0], 1Ch
.text$mn:000073E8                 mov     ecx, [ebp+var_4]
.text$mn:000073EB                 add     eax, [ecx+4]
.text$mn:000073EE                 mov     esp, ebp
.text$mn:000073F0                 pop     ebp
.text$mn:000073F1                 retn    4
.text$mn:000073F1 ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z endp
.text$mn:000073F1
.text$mn:000073F1 _text$mn        ends
.text$mn:000073F1
.text$mn:000073F4 ; ===========================================================================
.text$mn:000073F4
.text$mn:000073F4 ; Segment type: Pure code
.text$mn:000073F4 ; Segment permissions: Read/Execute
.text$mn:000073F4 _text$mn        segment para public 'CODE' use32
.text$mn:000073F4                 assume cs:_text$mn
.text$mn:000073F4                 ;org 73F4h
.text$mn:000073F4 ; COMDAT (pick any)
.text$mn:000073F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000073F4
.text$mn:000073F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000073F4
.text$mn:000073F4 ; Attributes: bp-based frame
.text$mn:000073F4
.text$mn:000073F4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const & __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::operator[](unsigned int)const
.text$mn:000073F4                 public ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z
.text$mn:000073F4 ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z proc near
.text$mn:000073F4                                         ; CODE XREF: PluginsManager::isInLoadedDlls(wchar_t const *)+35p
.text$mn:000073F4
.text$mn:000073F4 var_4           = dword ptr -4
.text$mn:000073F4 arg_0           = dword ptr  8
.text$mn:000073F4
.text$mn:000073F4                 push    ebp
.text$mn:000073F5                 mov     ebp, esp
.text$mn:000073F7                 push    ecx
.text$mn:000073F8                 mov     [ebp+var_4], ecx
.text$mn:000073FB                 mov     ecx, [ebp+var_4]
.text$mn:000073FE                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:00007403                 cmp     eax, [ebp+arg_0]
.text$mn:00007406                 ja      short loc_7470
.text$mn:00007408                 push    4A1h            ; unsigned int
.text$mn:0000740D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007412                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00007417                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000741C                 add     esp, 0Ch
.text$mn:0000741F                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00007424                 test    eax, eax
.text$mn:00007426                 jz      short loc_742C
.text$mn:00007428                 xor     ecx, ecx
.text$mn:0000742A                 jnz     short loc_7452
.text$mn:0000742C
.text$mn:0000742C loc_742C:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+32j
.text$mn:0000742C                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00007431                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00007436                 push    0
.text$mn:00007438                 push    4A2h
.text$mn:0000743D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007442                 push    2
.text$mn:00007444                 call    __CrtDbgReportW
.text$mn:00007449                 add     esp, 18h
.text$mn:0000744C                 cmp     eax, 1
.text$mn:0000744F                 jnz     short loc_7452
.text$mn:00007451                 int     3               ; Trap to Debugger
.text$mn:00007452
.text$mn:00007452 loc_7452:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+36j
.text$mn:00007452                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+5Bj
.text$mn:00007452                 push    0
.text$mn:00007454                 push    4A2h
.text$mn:00007459                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000745E                 push    offset ??_C@_1BOI@OCMBMPPD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@ ; "std::vector<class std::basic_string<wch"...
.text$mn:00007463                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00007468                 call    __invalid_parameter
.text$mn:0000746D                 add     esp, 14h
.text$mn:00007470
.text$mn:00007470 loc_7470:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+12j
.text$mn:00007470                 imul    eax, [ebp+arg_0], 1Ch
.text$mn:00007474                 mov     ecx, [ebp+var_4]
.text$mn:00007477                 add     eax, [ecx+4]
.text$mn:0000747A                 mov     esp, ebp
.text$mn:0000747C                 pop     ebp
.text$mn:0000747D                 retn    4
.text$mn:0000747D ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z endp
.text$mn:0000747D
.text$mn:0000747D _text$mn        ends
.text$mn:0000747D
.text$mn:00007480 ; ===========================================================================
.text$mn:00007480
.text$mn:00007480 ; Segment type: Pure code
.text$mn:00007480 ; Segment permissions: Read/Execute
.text$mn:00007480 _text$mn        segment para public 'CODE' use32
.text$mn:00007480                 assume cs:_text$mn
.text$mn:00007480                 ;org 7480h
.text$mn:00007480 ; COMDAT (pick any)
.text$mn:00007480                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007480
.text$mn:00007480 ; =============== S U B R O U T I N E =======================================
.text$mn:00007480
.text$mn:00007480 ; Attributes: bp-based frame
.text$mn:00007480
.text$mn:00007480 ; public: class PluginCmdShortcut const & __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::operator[](unsigned int)const
.text$mn:00007480                 public ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEABVPluginCmdShortcut@@I@Z
.text$mn:00007480 ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEABVPluginCmdShortcut@@I@Z proc near
.text$mn:00007480                                         ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+57p
.text$mn:00007480                                         ; PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+6Fp
.text$mn:00007480
.text$mn:00007480 var_4           = dword ptr -4
.text$mn:00007480 arg_0           = dword ptr  8
.text$mn:00007480
.text$mn:00007480                 push    ebp
.text$mn:00007481                 mov     ebp, esp
.text$mn:00007483                 push    ecx
.text$mn:00007484                 mov     [ebp+var_4], ecx
.text$mn:00007487                 mov     ecx, [ebp+var_4]
.text$mn:0000748A                 call    ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::size(void)
.text$mn:0000748F                 cmp     eax, [ebp+arg_0]
.text$mn:00007492                 ja      short loc_74FC
.text$mn:00007494                 push    4A1h            ; unsigned int
.text$mn:00007499                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000749E                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:000074A3                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000074A8                 add     esp, 0Ch
.text$mn:000074AB                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:000074B0                 test    eax, eax
.text$mn:000074B2                 jz      short loc_74B8
.text$mn:000074B4                 xor     ecx, ecx
.text$mn:000074B6                 jnz     short loc_74DE
.text$mn:000074B8
.text$mn:000074B8 loc_74B8:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+32j
.text$mn:000074B8                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:000074BD                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000074C2                 push    0
.text$mn:000074C4                 push    4A2h
.text$mn:000074C9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000074CE                 push    2
.text$mn:000074D0                 call    __CrtDbgReportW
.text$mn:000074D5                 add     esp, 18h
.text$mn:000074D8                 cmp     eax, 1
.text$mn:000074DB                 jnz     short loc_74DE
.text$mn:000074DD                 int     3               ; Trap to Debugger
.text$mn:000074DE
.text$mn:000074DE loc_74DE:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+36j
.text$mn:000074DE                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+5Bj
.text$mn:000074DE                 push    0
.text$mn:000074E0                 push    4A2h
.text$mn:000074E5                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000074EA                 push    offset ??_C@_1MC@MGKONNEA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAC?$AAm?$AAd?$AAS?$AAh?$AAo?$AAr?$AAt@ ; "std::vector<class PluginCmdShortcut,cla"...
.text$mn:000074EF                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000074F4                 call    __invalid_parameter
.text$mn:000074F9                 add     esp, 14h
.text$mn:000074FC
.text$mn:000074FC loc_74FC:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+12j
.text$mn:000074FC                 imul    eax, [ebp+arg_0], 150h
.text$mn:00007503                 mov     ecx, [ebp+var_4]
.text$mn:00007506                 add     eax, [ecx+4]
.text$mn:00007509                 mov     esp, ebp
.text$mn:0000750B                 pop     ebp
.text$mn:0000750C                 retn    4
.text$mn:0000750C ??A?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEABVPluginCmdShortcut@@I@Z endp
.text$mn:0000750C
.text$mn:0000750C ; ---------------------------------------------------------------------------
.text$mn:0000750F                 align 10h
.text$mn:0000750F _text$mn        ends
.text$mn:0000750F
.text$mn:00007510 ; ===========================================================================
.text$mn:00007510
.text$mn:00007510 ; Segment type: Pure code
.text$mn:00007510 ; Segment permissions: Read/Execute
.text$mn:00007510 _text$mn        segment para public 'CODE' use32
.text$mn:00007510                 assume cs:_text$mn
.text$mn:00007510                 ;org 7510h
.text$mn:00007510 ; COMDAT (pick any)
.text$mn:00007510                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007510
.text$mn:00007510 ; =============== S U B R O U T I N E =======================================
.text$mn:00007510
.text$mn:00007510 ; Attributes: bp-based frame
.text$mn:00007510
.text$mn:00007510 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator+=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00007510                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:00007510 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00007510                                         ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+3A0p
.text$mn:00007510
.text$mn:00007510 var_4           = dword ptr -4
.text$mn:00007510 arg_0           = dword ptr  8
.text$mn:00007510
.text$mn:00007510                 push    ebp
.text$mn:00007511                 mov     ebp, esp
.text$mn:00007513                 push    ecx
.text$mn:00007514                 mov     [ebp+var_4], ecx
.text$mn:00007517                 mov     eax, [ebp+arg_0]
.text$mn:0000751A                 push    eax
.text$mn:0000751B                 mov     ecx, [ebp+var_4]
.text$mn:0000751E                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00007523                 mov     esp, ebp
.text$mn:00007525                 pop     ebp
.text$mn:00007526                 retn    4
.text$mn:00007526 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00007526
.text$mn:00007526 ; ---------------------------------------------------------------------------
.text$mn:00007529                 align 4
.text$mn:00007529 _text$mn        ends
.text$mn:00007529
.text$mn:0000752C ; ===========================================================================
.text$mn:0000752C
.text$mn:0000752C ; Segment type: Pure code
.text$mn:0000752C ; Segment permissions: Read/Execute
.text$mn:0000752C _text$mn        segment para public 'CODE' use32
.text$mn:0000752C                 assume cs:_text$mn
.text$mn:0000752C                 ;org 752Ch
.text$mn:0000752C ; COMDAT (pick any)
.text$mn:0000752C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000752C
.text$mn:0000752C ; =============== S U B R O U T I N E =======================================
.text$mn:0000752C
.text$mn:0000752C ; Attributes: bp-based frame
.text$mn:0000752C
.text$mn:0000752C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t *Str)
.text$mn:0000752C                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:0000752C ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:0000752C                                         ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+Fp
.text$mn:0000752C                                         ; __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+21p ...
.text$mn:0000752C
.text$mn:0000752C var_4           = dword ptr -4
.text$mn:0000752C Str             = dword ptr  8
.text$mn:0000752C
.text$mn:0000752C                 push    ebp
.text$mn:0000752D                 mov     ebp, esp
.text$mn:0000752F                 push    ecx
.text$mn:00007530                 mov     [ebp+var_4], ecx
.text$mn:00007533                 mov     eax, [ebp+Str]
.text$mn:00007536                 push    eax             ; Str
.text$mn:00007537                 mov     ecx, [ebp+var_4]
.text$mn:0000753A                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:0000753F                 mov     esp, ebp
.text$mn:00007541                 pop     ebp
.text$mn:00007542                 retn    4
.text$mn:00007542 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:00007542
.text$mn:00007542 ; ---------------------------------------------------------------------------
.text$mn:00007545                 align 4
.text$mn:00007545 _text$mn        ends
.text$mn:00007545
.text$mn:00007548 ; ===========================================================================
.text$mn:00007548
.text$mn:00007548 ; Segment type: Pure code
.text$mn:00007548 ; Segment permissions: Read/Execute
.text$mn:00007548 _text$mn        segment para public 'CODE' use32
.text$mn:00007548                 assume cs:_text$mn
.text$mn:00007548                 ;org 7548h
.text$mn:00007548 ; COMDAT (pick any)
.text$mn:00007548                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007548
.text$mn:00007548 ; =============== S U B R O U T I N E =======================================
.text$mn:00007548
.text$mn:00007548 ; Attributes: bp-based frame
.text$mn:00007548
.text$mn:00007548 ; public: void * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::`scalar deleting destructor'(unsigned int)
.text$mn:00007548                 public ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z
.text$mn:00007548 ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z proc near
.text$mn:00007548                                         ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+Cp
.text$mn:00007548
.text$mn:00007548 var_4           = dword ptr -4
.text$mn:00007548 arg_0           = dword ptr  8
.text$mn:00007548
.text$mn:00007548                 push    ebp
.text$mn:00007549                 mov     ebp, esp
.text$mn:0000754B                 push    ecx
.text$mn:0000754C                 mov     [ebp+var_4], ecx
.text$mn:0000754F                 mov     ecx, [ebp+var_4]
.text$mn:00007552                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00007557                 mov     eax, [ebp+arg_0]
.text$mn:0000755A                 and     eax, 1
.text$mn:0000755D                 jz      short loc_756B
.text$mn:0000755F                 mov     ecx, [ebp+var_4]
.text$mn:00007562                 push    ecx             ; void *
.text$mn:00007563                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007568                 add     esp, 4
.text$mn:0000756B
.text$mn:0000756B loc_756B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::`scalar deleting destructor'(uint)+15j
.text$mn:0000756B                 mov     eax, [ebp+var_4]
.text$mn:0000756E                 mov     esp, ebp
.text$mn:00007570                 pop     ebp
.text$mn:00007571                 retn    4
.text$mn:00007571 ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z endp
.text$mn:00007571
.text$mn:00007571 _text$mn        ends
.text$mn:00007571
.text$mn:00007574 ; ===========================================================================
.text$mn:00007574
.text$mn:00007574 ; Segment type: Pure code
.text$mn:00007574 ; Segment permissions: Read/Execute
.text$mn:00007574 _text$mn        segment para public 'CODE' use32
.text$mn:00007574                 assume cs:_text$mn
.text$mn:00007574                 ;org 7574h
.text$mn:00007574 ; COMDAT (pick any)
.text$mn:00007574                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007574
.text$mn:00007574 ; =============== S U B R O U T I N E =======================================
.text$mn:00007574
.text$mn:00007574 ; Attributes: bp-based frame
.text$mn:00007574
.text$mn:00007574 ; public: void * __thiscall std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>::`scalar deleting destructor'(unsigned int)
.text$mn:00007574                 public ??_G?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAEPAXI@Z
.text$mn:00007574 ??_G?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAEPAXI@Z proc near
.text$mn:00007574                                         ; CODE XREF: std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+Cp
.text$mn:00007574
.text$mn:00007574 var_4           = dword ptr -4
.text$mn:00007574 arg_0           = dword ptr  8
.text$mn:00007574
.text$mn:00007574                 push    ebp
.text$mn:00007575                 mov     ebp, esp
.text$mn:00007577                 push    ecx
.text$mn:00007578                 mov     [ebp+var_4], ecx
.text$mn:0000757B                 mov     ecx, [ebp+var_4]
.text$mn:0000757E                 call    ??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::~pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(void)
.text$mn:00007583                 mov     eax, [ebp+arg_0]
.text$mn:00007586                 and     eax, 1
.text$mn:00007589                 jz      short loc_7597
.text$mn:0000758B                 mov     ecx, [ebp+var_4]
.text$mn:0000758E                 push    ecx             ; void *
.text$mn:0000758F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007594                 add     esp, 4
.text$mn:00007597
.text$mn:00007597 loc_7597:                               ; CODE XREF: std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::`scalar deleting destructor'(uint)+15j
.text$mn:00007597                 mov     eax, [ebp+var_4]
.text$mn:0000759A                 mov     esp, ebp
.text$mn:0000759C                 pop     ebp
.text$mn:0000759D                 retn    4
.text$mn:0000759D ??_G?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAEPAXI@Z endp
.text$mn:0000759D
.text$mn:0000759D _text$mn        ends
.text$mn:0000759D
.text$mn:000075A0 ; ===========================================================================
.text$mn:000075A0
.text$mn:000075A0 ; Segment type: Pure code
.text$mn:000075A0 ; Segment permissions: Read/Execute
.text$mn:000075A0 _text$mn        segment para public 'CODE' use32
.text$mn:000075A0                 assume cs:_text$mn
.text$mn:000075A0                 ;org 75A0h
.text$mn:000075A0 ; COMDAT (pick any)
.text$mn:000075A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000075A0
.text$mn:000075A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000075A0
.text$mn:000075A0 ; Attributes: bp-based frame
.text$mn:000075A0
.text$mn:000075A0 ; public: virtual void * __thiscall CommandShortcut::`scalar deleting destructor'(unsigned int)
.text$mn:000075A0                 public ??_GCommandShortcut@@UAEPAXI@Z
.text$mn:000075A0 ??_GCommandShortcut@@UAEPAXI@Z proc near
.text$mn:000075A0
.text$mn:000075A0 var_4           = dword ptr -4
.text$mn:000075A0 arg_0           = dword ptr  8
.text$mn:000075A0
.text$mn:000075A0                 push    ebp
.text$mn:000075A1                 mov     ebp, esp
.text$mn:000075A3                 push    ecx
.text$mn:000075A4                 mov     [ebp+var_4], ecx
.text$mn:000075A7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000075AA                 call    ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$mn:000075AF                 mov     eax, [ebp+arg_0]
.text$mn:000075B2                 and     eax, 1
.text$mn:000075B5                 jz      short loc_75C3
.text$mn:000075B7                 mov     ecx, [ebp+var_4]
.text$mn:000075BA                 push    ecx             ; void *
.text$mn:000075BB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000075C0                 add     esp, 4
.text$mn:000075C3
.text$mn:000075C3 loc_75C3:                               ; CODE XREF: CommandShortcut::`scalar deleting destructor'(uint)+15j
.text$mn:000075C3                 mov     eax, [ebp+var_4]
.text$mn:000075C6                 mov     esp, ebp
.text$mn:000075C8                 pop     ebp
.text$mn:000075C9                 retn    4
.text$mn:000075C9 ??_GCommandShortcut@@UAEPAXI@Z endp
.text$mn:000075C9
.text$mn:000075C9 _text$mn        ends
.text$mn:000075C9
.text$mn:000075CC ; ===========================================================================
.text$mn:000075CC
.text$mn:000075CC ; Segment type: Pure code
.text$mn:000075CC ; Segment permissions: Read/Execute
.text$mn:000075CC _text$mn        segment para public 'CODE' use32
.text$mn:000075CC                 assume cs:_text$mn
.text$mn:000075CC                 ;org 75CCh
.text$mn:000075CC ; COMDAT (pick any)
.text$mn:000075CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000075CC
.text$mn:000075CC ; =============== S U B R O U T I N E =======================================
.text$mn:000075CC
.text$mn:000075CC ; Attributes: bp-based frame
.text$mn:000075CC
.text$mn:000075CC ; public: virtual void * __thiscall PluginCmdShortcut::`scalar deleting destructor'(unsigned int)
.text$mn:000075CC                 public ??_GPluginCmdShortcut@@UAEPAXI@Z
.text$mn:000075CC ??_GPluginCmdShortcut@@UAEPAXI@Z proc near
.text$mn:000075CC
.text$mn:000075CC var_4           = dword ptr -4
.text$mn:000075CC arg_0           = dword ptr  8
.text$mn:000075CC
.text$mn:000075CC                 push    ebp
.text$mn:000075CD                 mov     ebp, esp
.text$mn:000075CF                 push    ecx
.text$mn:000075D0                 mov     [ebp+var_4], ecx
.text$mn:000075D3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000075D6                 call    ??1PluginCmdShortcut@@UAE@XZ ; PluginCmdShortcut::~PluginCmdShortcut(void)
.text$mn:000075DB                 mov     eax, [ebp+arg_0]
.text$mn:000075DE                 and     eax, 1
.text$mn:000075E1                 jz      short loc_75EF
.text$mn:000075E3                 mov     ecx, [ebp+var_4]
.text$mn:000075E6                 push    ecx             ; void *
.text$mn:000075E7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000075EC                 add     esp, 4
.text$mn:000075EF
.text$mn:000075EF loc_75EF:                               ; CODE XREF: PluginCmdShortcut::`scalar deleting destructor'(uint)+15j
.text$mn:000075EF                 mov     eax, [ebp+var_4]
.text$mn:000075F2                 mov     esp, ebp
.text$mn:000075F4                 pop     ebp
.text$mn:000075F5                 retn    4
.text$mn:000075F5 ??_GPluginCmdShortcut@@UAEPAXI@Z endp
.text$mn:000075F5
.text$mn:000075F5 _text$mn        ends
.text$mn:000075F5
.text$mn:000075F8 ; ===========================================================================
.text$mn:000075F8
.text$mn:000075F8 ; Segment type: Pure code
.text$mn:000075F8 ; Segment permissions: Read/Execute
.text$mn:000075F8 _text$mn        segment para public 'CODE' use32
.text$mn:000075F8                 assume cs:_text$mn
.text$mn:000075F8                 ;org 75F8h
.text$mn:000075F8 ; COMDAT (pick any)
.text$mn:000075F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000075F8
.text$mn:000075F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000075F8
.text$mn:000075F8 ; Attributes: bp-based frame
.text$mn:000075F8
.text$mn:000075F8 ; public: void * __thiscall PluginCommand::`scalar deleting destructor'(unsigned int)
.text$mn:000075F8                 public ??_GPluginCommand@@QAEPAXI@Z
.text$mn:000075F8 ??_GPluginCommand@@QAEPAXI@Z proc near  ; CODE XREF: std::allocator<PluginCommand>::destroy<PluginCommand>(PluginCommand *)+Cp
.text$mn:000075F8
.text$mn:000075F8 var_4           = dword ptr -4
.text$mn:000075F8 arg_0           = dword ptr  8
.text$mn:000075F8
.text$mn:000075F8                 push    ebp
.text$mn:000075F9                 mov     ebp, esp
.text$mn:000075FB                 push    ecx
.text$mn:000075FC                 mov     [ebp+var_4], ecx
.text$mn:000075FF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007602                 call    ??1PluginCommand@@QAE@XZ ; PluginCommand::~PluginCommand(void)
.text$mn:00007607                 mov     eax, [ebp+arg_0]
.text$mn:0000760A                 and     eax, 1
.text$mn:0000760D                 jz      short loc_761B
.text$mn:0000760F                 mov     ecx, [ebp+var_4]
.text$mn:00007612                 push    ecx             ; void *
.text$mn:00007613                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007618                 add     esp, 4
.text$mn:0000761B
.text$mn:0000761B loc_761B:                               ; CODE XREF: PluginCommand::`scalar deleting destructor'(uint)+15j
.text$mn:0000761B                 mov     eax, [ebp+var_4]
.text$mn:0000761E                 mov     esp, ebp
.text$mn:00007620                 pop     ebp
.text$mn:00007621                 retn    4
.text$mn:00007621 ??_GPluginCommand@@QAEPAXI@Z endp
.text$mn:00007621
.text$mn:00007621 _text$mn        ends
.text$mn:00007621
.text$mn:00007624 ; ===========================================================================
.text$mn:00007624
.text$mn:00007624 ; Segment type: Pure code
.text$mn:00007624 ; Segment permissions: Read/Execute
.text$mn:00007624 _text$mn        segment para public 'CODE' use32
.text$mn:00007624                 assume cs:_text$mn
.text$mn:00007624                 ;org 7624h
.text$mn:00007624 ; COMDAT (pick any)
.text$mn:00007624                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007624
.text$mn:00007624 ; =============== S U B R O U T I N E =======================================
.text$mn:00007624
.text$mn:00007624 ; Attributes: bp-based frame
.text$mn:00007624
.text$mn:00007624 ; public: void * __thiscall PluginInfo::`scalar deleting destructor'(unsigned int)
.text$mn:00007624                 public ??_GPluginInfo@@QAEPAXI@Z
.text$mn:00007624 ??_GPluginInfo@@QAEPAXI@Z proc near     ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+9Fp
.text$mn:00007624                                         ; __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2+AFp
.text$mn:00007624
.text$mn:00007624 var_4           = dword ptr -4
.text$mn:00007624 arg_0           = dword ptr  8
.text$mn:00007624
.text$mn:00007624                 push    ebp
.text$mn:00007625                 mov     ebp, esp
.text$mn:00007627                 push    ecx
.text$mn:00007628                 mov     [ebp+var_4], ecx
.text$mn:0000762B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000762E                 call    ??1PluginInfo@@QAE@XZ ; PluginInfo::~PluginInfo(void)
.text$mn:00007633                 mov     eax, [ebp+arg_0]
.text$mn:00007636                 and     eax, 1
.text$mn:00007639                 jz      short loc_7647
.text$mn:0000763B                 mov     ecx, [ebp+var_4]
.text$mn:0000763E                 push    ecx             ; void *
.text$mn:0000763F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007644                 add     esp, 4
.text$mn:00007647
.text$mn:00007647 loc_7647:                               ; CODE XREF: PluginInfo::`scalar deleting destructor'(uint)+15j
.text$mn:00007647                 mov     eax, [ebp+var_4]
.text$mn:0000764A                 mov     esp, ebp
.text$mn:0000764C                 pop     ebp
.text$mn:0000764D                 retn    4
.text$mn:0000764D ??_GPluginInfo@@QAEPAXI@Z endp
.text$mn:0000764D
.text$mn:0000764D _text$mn        ends
.text$mn:0000764D
.text$mn:00007650 ; ===========================================================================
.text$mn:00007650
.text$mn:00007650 ; Segment type: Pure code
.text$mn:00007650 ; Segment permissions: Read/Execute
.text$mn:00007650 _text$mn        segment para public 'CODE' use32
.text$mn:00007650                 assume cs:_text$mn
.text$mn:00007650                 ;org 7650h
.text$mn:00007650 ; COMDAT (pick any)
.text$mn:00007650                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007650
.text$mn:00007650 ; =============== S U B R O U T I N E =======================================
.text$mn:00007650
.text$mn:00007650 ; Attributes: bp-based frame
.text$mn:00007650
.text$mn:00007650 ; public: virtual void * __thiscall Shortcut::`scalar deleting destructor'(unsigned int)
.text$mn:00007650                 public ??_GShortcut@@UAEPAXI@Z
.text$mn:00007650 ??_GShortcut@@UAEPAXI@Z proc near
.text$mn:00007650
.text$mn:00007650 var_4           = dword ptr -4
.text$mn:00007650 arg_0           = dword ptr  8
.text$mn:00007650
.text$mn:00007650                 push    ebp
.text$mn:00007651                 mov     ebp, esp
.text$mn:00007653                 push    ecx
.text$mn:00007654                 mov     [ebp+var_4], ecx
.text$mn:00007657                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000765A                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:0000765F                 mov     eax, [ebp+arg_0]
.text$mn:00007662                 and     eax, 1
.text$mn:00007665                 jz      short loc_7673
.text$mn:00007667                 mov     ecx, [ebp+var_4]
.text$mn:0000766A                 push    ecx             ; void *
.text$mn:0000766B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007670                 add     esp, 4
.text$mn:00007673
.text$mn:00007673 loc_7673:                               ; CODE XREF: Shortcut::`scalar deleting destructor'(uint)+15j
.text$mn:00007673                 mov     eax, [ebp+var_4]
.text$mn:00007676                 mov     esp, ebp
.text$mn:00007678                 pop     ebp
.text$mn:00007679                 retn    4
.text$mn:00007679 ??_GShortcut@@UAEPAXI@Z endp
.text$mn:00007679
.text$mn:00007679 _text$mn        ends
.text$mn:00007679
.text$mn:0000767C ; ===========================================================================
.text$mn:0000767C
.text$mn:0000767C ; Segment type: Pure code
.text$mn:0000767C ; Segment permissions: Read/Execute
.text$mn:0000767C _text$mn        segment para public 'CODE' use32
.text$mn:0000767C                 assume cs:_text$mn
.text$mn:0000767C                 ;org 767Ch
.text$mn:0000767C ; COMDAT (pick any)
.text$mn:0000767C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000767C
.text$mn:0000767C ; =============== S U B R O U T I N E =======================================
.text$mn:0000767C
.text$mn:0000767C ; Attributes: bp-based frame
.text$mn:0000767C
.text$mn:0000767C ; public: virtual void * __thiscall StaticDialog::`scalar deleting destructor'(unsigned int)
.text$mn:0000767C                 public ??_GStaticDialog@@UAEPAXI@Z
.text$mn:0000767C ??_GStaticDialog@@UAEPAXI@Z proc near
.text$mn:0000767C
.text$mn:0000767C var_4           = dword ptr -4
.text$mn:0000767C arg_0           = dword ptr  8
.text$mn:0000767C
.text$mn:0000767C                 push    ebp
.text$mn:0000767D                 mov     ebp, esp
.text$mn:0000767F                 push    ecx
.text$mn:00007680                 mov     [ebp+var_4], ecx
.text$mn:00007683                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007686                 call    ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$mn:0000768B                 mov     eax, [ebp+arg_0]
.text$mn:0000768E                 and     eax, 1
.text$mn:00007691                 jz      short loc_769F
.text$mn:00007693                 mov     ecx, [ebp+var_4]
.text$mn:00007696                 push    ecx             ; void *
.text$mn:00007697                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000769C                 add     esp, 4
.text$mn:0000769F
.text$mn:0000769F loc_769F:                               ; CODE XREF: StaticDialog::`scalar deleting destructor'(uint)+15j
.text$mn:0000769F                 mov     eax, [ebp+var_4]
.text$mn:000076A2                 mov     esp, ebp
.text$mn:000076A4                 pop     ebp
.text$mn:000076A5                 retn    4
.text$mn:000076A5 ??_GStaticDialog@@UAEPAXI@Z endp
.text$mn:000076A5
.text$mn:000076A5 _text$mn        ends
.text$mn:000076A5
.text$mn:000076A8 ; ===========================================================================
.text$mn:000076A8
.text$mn:000076A8 ; Segment type: Pure code
.text$mn:000076A8 ; Segment permissions: Read/Execute
.text$mn:000076A8 _text$mn        segment para public 'CODE' use32
.text$mn:000076A8                 assume cs:_text$mn
.text$mn:000076A8                 ;org 76A8h
.text$mn:000076A8 ; COMDAT (pick any)
.text$mn:000076A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000076A8
.text$mn:000076A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000076A8
.text$mn:000076A8 ; Attributes: bp-based frame
.text$mn:000076A8
.text$mn:000076A8 ; public: virtual void * __thiscall Window::`scalar deleting destructor'(unsigned int)
.text$mn:000076A8                 public ??_GWindow@@UAEPAXI@Z
.text$mn:000076A8 ??_GWindow@@UAEPAXI@Z proc near
.text$mn:000076A8
.text$mn:000076A8 var_4           = dword ptr -4
.text$mn:000076A8 arg_0           = dword ptr  8
.text$mn:000076A8
.text$mn:000076A8                 push    ebp
.text$mn:000076A9                 mov     ebp, esp
.text$mn:000076AB                 push    ecx
.text$mn:000076AC                 mov     [ebp+var_4], ecx
.text$mn:000076AF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000076B2                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:000076B7                 mov     eax, [ebp+arg_0]
.text$mn:000076BA                 and     eax, 1
.text$mn:000076BD                 jz      short loc_76CB
.text$mn:000076BF                 mov     ecx, [ebp+var_4]
.text$mn:000076C2                 push    ecx             ; void *
.text$mn:000076C3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000076C8                 add     esp, 4
.text$mn:000076CB
.text$mn:000076CB loc_76CB:                               ; CODE XREF: Window::`scalar deleting destructor'(uint)+15j
.text$mn:000076CB                 mov     eax, [ebp+var_4]
.text$mn:000076CE                 mov     esp, ebp
.text$mn:000076D0                 pop     ebp
.text$mn:000076D1                 retn    4
.text$mn:000076D1 ??_GWindow@@UAEPAXI@Z endp
.text$mn:000076D1
.text$mn:000076D1 _text$mn        ends
.text$mn:000076D1
.text$mn:000076D4 ; ===========================================================================
.text$mn:000076D4
.text$mn:000076D4 ; Segment type: Pure code
.text$mn:000076D4 ; Segment permissions: Read/Execute
.text$mn:000076D4 _text$mn        segment para public 'CODE' use32
.text$mn:000076D4                 assume cs:_text$mn
.text$mn:000076D4                 ;org 76D4h
.text$mn:000076D4 ; COMDAT (pick any)
.text$mn:000076D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000076D4
.text$mn:000076D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000076D4
.text$mn:000076D4 ; Attributes: bp-based frame
.text$mn:000076D4
.text$mn:000076D4 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000076D4                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:000076D4 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:000076D4
.text$mn:000076D4 var_4           = dword ptr -4
.text$mn:000076D4 arg_0           = dword ptr  8
.text$mn:000076D4
.text$mn:000076D4                 push    ebp
.text$mn:000076D5                 mov     ebp, esp
.text$mn:000076D7                 push    ecx
.text$mn:000076D8                 mov     [ebp+var_4], ecx
.text$mn:000076DB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000076DE                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000076E3                 mov     eax, [ebp+arg_0]
.text$mn:000076E6                 and     eax, 1
.text$mn:000076E9                 jz      short loc_76F7
.text$mn:000076EB                 mov     ecx, [ebp+var_4]
.text$mn:000076EE                 push    ecx             ; void *
.text$mn:000076EF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000076F4                 add     esp, 4
.text$mn:000076F7
.text$mn:000076F7 loc_76F7:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000076F7                 mov     eax, [ebp+var_4]
.text$mn:000076FA                 mov     esp, ebp
.text$mn:000076FC                 pop     ebp
.text$mn:000076FD                 retn    4
.text$mn:000076FD ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:000076FD
.text$mn:000076FD _text$mn        ends
.text$mn:000076FD
.text$mn:00007700 ; ===========================================================================
.text$mn:00007700
.text$mn:00007700 ; Segment type: Pure code
.text$mn:00007700 ; Segment permissions: Read/Execute
.text$mn:00007700 _text$mn        segment para public 'CODE' use32
.text$mn:00007700                 assume cs:_text$mn
.text$mn:00007700                 ;org 7700h
.text$mn:00007700 ; COMDAT (pick any)
.text$mn:00007700                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007700
.text$mn:00007700 ; =============== S U B R O U T I N E =======================================
.text$mn:00007700
.text$mn:00007700 ; Attributes: bp-based frame
.text$mn:00007700
.text$mn:00007700 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00007700                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00007700 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00007700
.text$mn:00007700 var_4           = dword ptr -4
.text$mn:00007700 arg_0           = dword ptr  8
.text$mn:00007700
.text$mn:00007700                 push    ebp
.text$mn:00007701                 mov     ebp, esp
.text$mn:00007703                 push    ecx
.text$mn:00007704                 mov     [ebp+var_4], ecx
.text$mn:00007707                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000770A                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000770F                 mov     eax, [ebp+arg_0]
.text$mn:00007712                 and     eax, 1
.text$mn:00007715                 jz      short loc_7723
.text$mn:00007717                 mov     ecx, [ebp+var_4]
.text$mn:0000771A                 push    ecx             ; void *
.text$mn:0000771B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007720                 add     esp, 4
.text$mn:00007723
.text$mn:00007723 loc_7723:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00007723                 mov     eax, [ebp+var_4]
.text$mn:00007726                 mov     esp, ebp
.text$mn:00007728                 pop     ebp
.text$mn:00007729                 retn    4
.text$mn:00007729 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00007729
.text$mn:00007729 _text$mn        ends
.text$mn:00007729
.text$mn:0000772C ; ===========================================================================
.text$mn:0000772C
.text$mn:0000772C ; Segment type: Pure code
.text$mn:0000772C ; Segment permissions: Read/Execute
.text$mn:0000772C _text$mn        segment para public 'CODE' use32
.text$mn:0000772C                 assume cs:_text$mn
.text$mn:0000772C                 ;org 772Ch
.text$mn:0000772C ; COMDAT (pick any)
.text$mn:0000772C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000772C
.text$mn:0000772C ; =============== S U B R O U T I N E =======================================
.text$mn:0000772C
.text$mn:0000772C ; Attributes: bp-based frame
.text$mn:0000772C
.text$mn:0000772C ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000772C                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:0000772C ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000772C
.text$mn:0000772C var_4           = dword ptr -4
.text$mn:0000772C arg_0           = dword ptr  8
.text$mn:0000772C
.text$mn:0000772C                 push    ebp
.text$mn:0000772D                 mov     ebp, esp
.text$mn:0000772F                 push    ecx
.text$mn:00007730                 mov     [ebp+var_4], ecx
.text$mn:00007733                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007736                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000773B                 mov     eax, [ebp+arg_0]
.text$mn:0000773E                 and     eax, 1
.text$mn:00007741                 jz      short loc_774F
.text$mn:00007743                 mov     ecx, [ebp+var_4]
.text$mn:00007746                 push    ecx             ; void *
.text$mn:00007747                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000774C                 add     esp, 4
.text$mn:0000774F
.text$mn:0000774F loc_774F:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000774F                 mov     eax, [ebp+var_4]
.text$mn:00007752                 mov     esp, ebp
.text$mn:00007754                 pop     ebp
.text$mn:00007755                 retn    4
.text$mn:00007755 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00007755
.text$mn:00007755 _text$mn        ends
.text$mn:00007755
.text$mn:00007758 ; ===========================================================================
.text$mn:00007758
.text$mn:00007758 ; Segment type: Pure code
.text$mn:00007758 ; Segment permissions: Read/Execute
.text$mn:00007758 _text$mn        segment para public 'CODE' use32
.text$mn:00007758                 assume cs:_text$mn
.text$mn:00007758                 ;org 7758h
.text$mn:00007758 ; COMDAT (pick any)
.text$mn:00007758                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007758
.text$mn:00007758 ; =============== S U B R O U T I N E =======================================
.text$mn:00007758
.text$mn:00007758 ; Attributes: bp-based frame
.text$mn:00007758
.text$mn:00007758 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00007758                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00007758 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00007758
.text$mn:00007758 var_4           = dword ptr -4
.text$mn:00007758 arg_0           = dword ptr  8
.text$mn:00007758
.text$mn:00007758                 push    ebp
.text$mn:00007759                 mov     ebp, esp
.text$mn:0000775B                 push    ecx
.text$mn:0000775C                 mov     [ebp+var_4], ecx
.text$mn:0000775F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007762                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00007767                 mov     eax, [ebp+arg_0]
.text$mn:0000776A                 and     eax, 1
.text$mn:0000776D                 jz      short loc_777B
.text$mn:0000776F                 mov     ecx, [ebp+var_4]
.text$mn:00007772                 push    ecx             ; void *
.text$mn:00007773                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007778                 add     esp, 4
.text$mn:0000777B
.text$mn:0000777B loc_777B:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000777B                 mov     eax, [ebp+var_4]
.text$mn:0000777E                 mov     esp, ebp
.text$mn:00007780                 pop     ebp
.text$mn:00007781                 retn    4
.text$mn:00007781 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00007781
.text$mn:00007781 _text$mn        ends
.text$mn:00007781
.text$di:00007784 ; ===========================================================================
.text$di:00007784
.text$di:00007784 ; Segment type: Pure code
.text$di:00007784 ; Segment permissions: Read/Execute
.text$di:00007784 _text$di        segment para public 'CODE' use32
.text$di:00007784                 assume cs:_text$di
.text$di:00007784                 ;org 7784h
.text$di:00007784 ; COMDAT (pick any)
.text$di:00007784                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007784
.text$di:00007784 ; =============== S U B R O U T I N E =======================================
.text$di:00007784
.text$di:00007784 ; Attributes: bp-based frame
.text$di:00007784
.text$di:00007784 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00007784 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00007784                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00007784                 push    ebp
.text$di:00007785                 mov     ebp, esp
.text$di:00007787                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:0000778C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00007791                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00007796                 call    _atexit
.text$di:0000779B                 add     esp, 4
.text$di:0000779E                 pop     ebp
.text$di:0000779F                 retn
.text$di:0000779F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:0000779F
.text$di:0000779F _text$di        ends
.text$di:0000779F
.text$di:000077A0 ; ===========================================================================
.text$di:000077A0
.text$di:000077A0 ; Segment type: Pure code
.text$di:000077A0 ; Segment permissions: Read/Execute
.text$di:000077A0 _text$di        segment para public 'CODE' use32
.text$di:000077A0                 assume cs:_text$di
.text$di:000077A0                 ;org 77A0h
.text$di:000077A0 ; COMDAT (pick any)
.text$di:000077A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000077A0
.text$di:000077A0 ; =============== S U B R O U T I N E =======================================
.text$di:000077A0
.text$di:000077A0 ; Attributes: bp-based frame
.text$di:000077A0
.text$di:000077A0 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000077A0 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000077A0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000077A0                 push    ebp
.text$di:000077A1                 mov     ebp, esp
.text$di:000077A3                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000077A8                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000077AD                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000077B2                 call    _atexit
.text$di:000077B7                 add     esp, 4
.text$di:000077BA                 pop     ebp
.text$di:000077BB                 retn
.text$di:000077BB ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000077BB
.text$di:000077BB _text$di        ends
.text$di:000077BB
.text$di:000077BC ; ===========================================================================
.text$di:000077BC
.text$di:000077BC ; Segment type: Pure code
.text$di:000077BC ; Segment permissions: Read/Execute
.text$di:000077BC _text$di        segment para public 'CODE' use32
.text$di:000077BC                 assume cs:_text$di
.text$di:000077BC                 ;org 77BCh
.text$di:000077BC ; COMDAT (pick any)
.text$di:000077BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000077BC
.text$di:000077BC ; =============== S U B R O U T I N E =======================================
.text$di:000077BC
.text$di:000077BC ; Attributes: bp-based frame
.text$di:000077BC
.text$di:000077BC ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:000077BC ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:000077BC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:000077BC                 push    ebp
.text$di:000077BD                 mov     ebp, esp
.text$di:000077BF                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000077C4                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000077C9                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000077CE                 call    _atexit
.text$di:000077D3                 add     esp, 4
.text$di:000077D6                 pop     ebp
.text$di:000077D7                 retn
.text$di:000077D7 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:000077D7
.text$di:000077D7 _text$di        ends
.text$di:000077D7
.text$di:000077D8 ; ===========================================================================
.text$di:000077D8
.text$di:000077D8 ; Segment type: Pure code
.text$di:000077D8 ; Segment permissions: Read/Execute
.text$di:000077D8 _text$di        segment para public 'CODE' use32
.text$di:000077D8                 assume cs:_text$di
.text$di:000077D8                 ;org 77D8h
.text$di:000077D8 ; COMDAT (pick any)
.text$di:000077D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000077D8
.text$di:000077D8 ; =============== S U B R O U T I N E =======================================
.text$di:000077D8
.text$di:000077D8 ; Attributes: bp-based frame
.text$di:000077D8
.text$di:000077D8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:000077D8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000077D8                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:000077D8                 push    ebp
.text$di:000077D9                 mov     ebp, esp
.text$di:000077DB                 push    0               ; unsigned int
.text$di:000077DD                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000077E2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000077E7                 pop     ebp
.text$di:000077E8                 retn
.text$di:000077E8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000077E8
.text$di:000077E8 ; ---------------------------------------------------------------------------
.text$di:000077E9                 align 4
.text$di:000077E9 _text$di        ends
.text$di:000077E9
.text$di:000077EC ; ===========================================================================
.text$di:000077EC
.text$di:000077EC ; Segment type: Pure code
.text$di:000077EC ; Segment permissions: Read/Execute
.text$di:000077EC _text$di        segment para public 'CODE' use32
.text$di:000077EC                 assume cs:_text$di
.text$di:000077EC                 ;org 77ECh
.text$di:000077EC ; COMDAT (pick any)
.text$di:000077EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000077EC
.text$di:000077EC ; =============== S U B R O U T I N E =======================================
.text$di:000077EC
.text$di:000077EC ; Attributes: bp-based frame
.text$di:000077EC
.text$di:000077EC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:000077EC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000077EC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:000077EC                 push    ebp
.text$di:000077ED                 mov     ebp, esp
.text$di:000077EF                 push    0               ; unsigned int
.text$di:000077F1                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000077F6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000077FB                 pop     ebp
.text$di:000077FC                 retn
.text$di:000077FC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000077FC
.text$di:000077FC ; ---------------------------------------------------------------------------
.text$di:000077FD                 align 10h
.text$di:000077FD _text$di        ends
.text$di:000077FD
.text$di:00007800 ; ===========================================================================
.text$di:00007800
.text$di:00007800 ; Segment type: Pure code
.text$di:00007800 ; Segment permissions: Read/Execute
.text$di:00007800 _text$di        segment para public 'CODE' use32
.text$di:00007800                 assume cs:_text$di
.text$di:00007800                 ;org 7800h
.text$di:00007800 ; COMDAT (pick any)
.text$di:00007800                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007800
.text$di:00007800 ; =============== S U B R O U T I N E =======================================
.text$di:00007800
.text$di:00007800 ; Attributes: bp-based frame
.text$di:00007800
.text$di:00007800 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00007800 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00007800                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00007800                 push    ebp
.text$di:00007801                 mov     ebp, esp
.text$di:00007803                 push    0               ; unsigned int
.text$di:00007805                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:0000780A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000780F                 pop     ebp
.text$di:00007810                 retn
.text$di:00007810 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00007810
.text$di:00007810 ; ---------------------------------------------------------------------------
.text$di:00007811                 align 4
.text$di:00007811 _text$di        ends
.text$di:00007811
.text$di:00007814 ; ===========================================================================
.text$di:00007814
.text$di:00007814 ; Segment type: Pure code
.text$di:00007814 ; Segment permissions: Read/Execute
.text$di:00007814 _text$di        segment para public 'CODE' use32
.text$di:00007814                 assume cs:_text$di
.text$di:00007814                 ;org 7814h
.text$di:00007814 ; COMDAT (pick any)
.text$di:00007814                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007814
.text$di:00007814 ; =============== S U B R O U T I N E =======================================
.text$di:00007814
.text$di:00007814 ; Attributes: bp-based frame
.text$di:00007814
.text$di:00007814 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00007814 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00007814                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00007814                 push    ebp
.text$di:00007815                 mov     ebp, esp
.text$di:00007817                 push    0               ; unsigned int
.text$di:00007819                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:0000781E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00007823                 pop     ebp
.text$di:00007824                 retn
.text$di:00007824 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00007824
.text$di:00007824 ; ---------------------------------------------------------------------------
.text$di:00007825                 align 4
.text$di:00007825 _text$di        ends
.text$di:00007825
.text$di:00007828 ; ===========================================================================
.text$di:00007828
.text$di:00007828 ; Segment type: Pure code
.text$di:00007828 ; Segment permissions: Read/Execute
.text$di:00007828 _text$di        segment para public 'CODE' use32
.text$di:00007828                 assume cs:_text$di
.text$di:00007828                 ;org 7828h
.text$di:00007828 ; COMDAT (pick any)
.text$di:00007828                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007828
.text$di:00007828 ; =============== S U B R O U T I N E =======================================
.text$di:00007828
.text$di:00007828 ; Attributes: bp-based frame
.text$di:00007828
.text$di:00007828 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00007828 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00007828
.text$di:00007828 var_1           = byte ptr -1
.text$di:00007828
.text$di:00007828                 push    ebp
.text$di:00007829                 mov     ebp, esp
.text$di:0000782B                 push    ecx
.text$di:0000782C                 xor     eax, eax
.text$di:0000782E                 mov     [ebp+var_1], al
.text$di:00007831                 mov     esp, ebp
.text$di:00007833                 pop     ebp
.text$di:00007834                 retn
.text$di:00007834 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00007834
.text$di:00007834 ; ---------------------------------------------------------------------------
.text$di:00007835                 align 4
.text$di:00007835 _text$di        ends
.text$di:00007835
.text$di:00007838 ; ===========================================================================
.text$di:00007838
.text$di:00007838 ; Segment type: Pure code
.text$di:00007838 ; Segment permissions: Read/Execute
.text$di:00007838 _text$di        segment para public 'CODE' use32
.text$di:00007838                 assume cs:_text$di
.text$di:00007838                 ;org 7838h
.text$di:00007838 ; COMDAT (pick any)
.text$di:00007838                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007838
.text$di:00007838 ; =============== S U B R O U T I N E =======================================
.text$di:00007838
.text$di:00007838 ; Attributes: bp-based frame
.text$di:00007838
.text$di:00007838 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00007838 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00007838                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00007838
.text$di:00007838 var_1           = byte ptr -1
.text$di:00007838
.text$di:00007838                 push    ebp
.text$di:00007839                 mov     ebp, esp
.text$di:0000783B                 push    ecx
.text$di:0000783C                 xor     eax, eax
.text$di:0000783E                 mov     [ebp+var_1], al
.text$di:00007841                 mov     esp, ebp
.text$di:00007843                 pop     ebp
.text$di:00007844                 retn
.text$di:00007844 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00007844
.text$di:00007844 ; ---------------------------------------------------------------------------
.text$di:00007845                 align 4
.text$di:00007845 _text$di        ends
.text$di:00007845
.text$yd:00007848 ; ===========================================================================
.text$yd:00007848
.text$yd:00007848 ; Segment type: Pure code
.text$yd:00007848 ; Segment permissions: Read/Execute
.text$yd:00007848 _text$yd        segment para public 'CODE' use32
.text$yd:00007848                 assume cs:_text$yd
.text$yd:00007848                 ;org 7848h
.text$yd:00007848 ; COMDAT (pick any)
.text$yd:00007848                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00007848
.text$yd:00007848 ; =============== S U B R O U T I N E =======================================
.text$yd:00007848
.text$yd:00007848 ; Attributes: bp-based frame
.text$yd:00007848
.text$yd:00007848 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00007848 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00007848                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00007848                 push    ebp
.text$yd:00007849                 mov     ebp, esp
.text$yd:0000784B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00007850                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00007855                 pop     ebp
.text$yd:00007856                 retn
.text$yd:00007856 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00007856
.text$yd:00007856 ; ---------------------------------------------------------------------------
.text$yd:00007857                 align 4
.text$yd:00007857 _text$yd        ends
.text$yd:00007857
.text$yd:00007858 ; ===========================================================================
.text$yd:00007858
.text$yd:00007858 ; Segment type: Pure code
.text$yd:00007858 ; Segment permissions: Read/Execute
.text$yd:00007858 _text$yd        segment para public 'CODE' use32
.text$yd:00007858                 assume cs:_text$yd
.text$yd:00007858                 ;org 7858h
.text$yd:00007858 ; COMDAT (pick any)
.text$yd:00007858                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00007858
.text$yd:00007858 ; =============== S U B R O U T I N E =======================================
.text$yd:00007858
.text$yd:00007858 ; Attributes: bp-based frame
.text$yd:00007858
.text$yd:00007858 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00007858 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00007858                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00007858                 push    ebp
.text$yd:00007859                 mov     ebp, esp
.text$yd:0000785B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00007860                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00007865                 pop     ebp
.text$yd:00007866                 retn
.text$yd:00007866 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00007866
.text$yd:00007866 ; ---------------------------------------------------------------------------
.text$yd:00007867                 align 4
.text$yd:00007867 _text$yd        ends
.text$yd:00007867
.text$yd:00007868 ; ===========================================================================
.text$yd:00007868
.text$yd:00007868 ; Segment type: Pure code
.text$yd:00007868 ; Segment permissions: Read/Execute
.text$yd:00007868 _text$yd        segment para public 'CODE' use32
.text$yd:00007868                 assume cs:_text$yd
.text$yd:00007868                 ;org 7868h
.text$yd:00007868 ; COMDAT (pick any)
.text$yd:00007868                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00007868
.text$yd:00007868 ; =============== S U B R O U T I N E =======================================
.text$yd:00007868
.text$yd:00007868 ; Attributes: bp-based frame
.text$yd:00007868
.text$yd:00007868 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00007868 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00007868                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00007868                 push    ebp
.text$yd:00007869                 mov     ebp, esp
.text$yd:0000786B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00007870                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00007875                 pop     ebp
.text$yd:00007876                 retn
.text$yd:00007876 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00007876
.text$yd:00007876 ; ---------------------------------------------------------------------------
.text$yd:00007877                 align 4
.text$yd:00007877 _text$yd        ends
.text$yd:00007877
.text$mn:00007878 ; ===========================================================================
.text$mn:00007878
.text$mn:00007878 ; Segment type: Pure code
.text$mn:00007878 ; Segment permissions: Read/Execute
.text$mn:00007878 _text$mn        segment para public 'CODE' use32
.text$mn:00007878                 assume cs:_text$mn
.text$mn:00007878                 ;org 7878h
.text$mn:00007878 ; COMDAT (pick any)
.text$mn:00007878                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007878
.text$mn:00007878 ; =============== S U B R O U T I N E =======================================
.text$mn:00007878
.text$mn:00007878 ; Attributes: bp-based frame
.text$mn:00007878
.text$mn:00007878 ; bool __thiscall NppParameters::ExternalLangHasRoom(NppParameters *__hidden this)
.text$mn:00007878                 public ?ExternalLangHasRoom@NppParameters@@QBE_NXZ
.text$mn:00007878 ?ExternalLangHasRoom@NppParameters@@QBE_NXZ proc near
.text$mn:00007878                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+533p
.text$mn:00007878
.text$mn:00007878 var_8           = dword ptr -8
.text$mn:00007878 var_4           = dword ptr -4
.text$mn:00007878
.text$mn:00007878                 push    ebp
.text$mn:00007879                 mov     ebp, esp
.text$mn:0000787B                 sub     esp, 8
.text$mn:0000787E                 mov     [ebp+var_8], ecx
.text$mn:00007881                 mov     eax, [ebp+var_8]
.text$mn:00007884                 cmp     dword ptr [eax+0B30h], 1Eh
.text$mn:0000788B                 jge     short loc_7896
.text$mn:0000788D                 mov     [ebp+var_4], 1
.text$mn:00007894                 jmp     short loc_789D
.text$mn:00007896 ; ---------------------------------------------------------------------------
.text$mn:00007896
.text$mn:00007896 loc_7896:                               ; CODE XREF: NppParameters::ExternalLangHasRoom(void)+13j
.text$mn:00007896                 mov     [ebp+var_4], 0
.text$mn:0000789D
.text$mn:0000789D loc_789D:                               ; CODE XREF: NppParameters::ExternalLangHasRoom(void)+1Cj
.text$mn:0000789D                 mov     al, byte ptr [ebp+var_4]
.text$mn:000078A0                 mov     esp, ebp
.text$mn:000078A2                 pop     ebp
.text$mn:000078A3                 retn
.text$mn:000078A3 ?ExternalLangHasRoom@NppParameters@@QBE_NXZ endp
.text$mn:000078A3
.text$mn:000078A3 _text$mn        ends
.text$mn:000078A3
.text$mn:000078A4 ; ===========================================================================
.text$mn:000078A4
.text$mn:000078A4 ; Segment type: Pure code
.text$mn:000078A4 ; Segment permissions: Read/Execute
.text$mn:000078A4 _text$mn        segment para public 'CODE' use32
.text$mn:000078A4                 assume cs:_text$mn
.text$mn:000078A4                 ;org 78A4h
.text$mn:000078A4 ; COMDAT (pick any)
.text$mn:000078A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000078A4
.text$mn:000078A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000078A4
.text$mn:000078A4 ; Attributes: bp-based frame
.text$mn:000078A4
.text$mn:000078A4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000078A4                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000078A4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000078A4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000078A4
.text$mn:000078A4 var_10          = byte ptr -10h
.text$mn:000078A4 var_8           = dword ptr -8
.text$mn:000078A4 var_1           = byte ptr -1
.text$mn:000078A4
.text$mn:000078A4                 push    ebp
.text$mn:000078A5                 mov     ebp, esp
.text$mn:000078A7                 sub     esp, 10h
.text$mn:000078AA                 mov     [ebp+var_8], ecx
.text$mn:000078AD                 lea     ecx, [ebp+var_1]
.text$mn:000078B0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000078B5                 push    1
.text$mn:000078B7                 lea     ecx, [ebp+var_1]
.text$mn:000078BA                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000078BF                 mov     ecx, [ebp+var_8]
.text$mn:000078C2                 mov     [ecx], eax
.text$mn:000078C4                 lea     ecx, [ebp+var_10] ; this
.text$mn:000078C7                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000078CC                 push    eax             ; int
.text$mn:000078CD                 mov     edx, [ebp+var_8]
.text$mn:000078D0                 mov     eax, [edx]
.text$mn:000078D2                 push    eax             ; void *
.text$mn:000078D3                 lea     ecx, [ebp+var_1]
.text$mn:000078D6                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000078DB                 mov     ecx, [ebp+var_8]
.text$mn:000078DE                 mov     edx, [ecx]
.text$mn:000078E0                 mov     eax, [ebp+var_8]
.text$mn:000078E3                 mov     [edx], eax
.text$mn:000078E5                 mov     esp, ebp
.text$mn:000078E7                 pop     ebp
.text$mn:000078E8                 retn
.text$mn:000078E8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000078E8
.text$mn:000078E8 ; ---------------------------------------------------------------------------
.text$mn:000078E9                 align 4
.text$mn:000078E9 _text$mn        ends
.text$mn:000078E9
.text$mn:000078EC ; ===========================================================================
.text$mn:000078EC
.text$mn:000078EC ; Segment type: Pure code
.text$mn:000078EC ; Segment permissions: Read/Execute
.text$mn:000078EC _text$mn        segment para public 'CODE' use32
.text$mn:000078EC                 assume cs:_text$mn
.text$mn:000078EC                 ;org 78ECh
.text$mn:000078EC ; COMDAT (pick any)
.text$mn:000078EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000078EC
.text$mn:000078EC ; =============== S U B R O U T I N E =======================================
.text$mn:000078EC
.text$mn:000078EC ; Attributes: bp-based frame
.text$mn:000078EC
.text$mn:000078EC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:000078EC                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:000078EC ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000078EC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:000078EC
.text$mn:000078EC var_10          = byte ptr -10h
.text$mn:000078EC var_8           = dword ptr -8
.text$mn:000078EC var_1           = byte ptr -1
.text$mn:000078EC
.text$mn:000078EC                 push    ebp
.text$mn:000078ED                 mov     ebp, esp
.text$mn:000078EF                 sub     esp, 10h
.text$mn:000078F2                 mov     [ebp+var_8], ecx
.text$mn:000078F5                 lea     ecx, [ebp+var_1]
.text$mn:000078F8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000078FD                 push    1
.text$mn:000078FF                 lea     ecx, [ebp+var_1]
.text$mn:00007902                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00007907                 mov     ecx, [ebp+var_8]
.text$mn:0000790A                 mov     [ecx], eax
.text$mn:0000790C                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000790F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00007914                 push    eax             ; int
.text$mn:00007915                 mov     edx, [ebp+var_8]
.text$mn:00007918                 mov     eax, [edx]
.text$mn:0000791A                 push    eax             ; void *
.text$mn:0000791B                 lea     ecx, [ebp+var_1]
.text$mn:0000791E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00007923                 mov     ecx, [ebp+var_8]
.text$mn:00007926                 mov     edx, [ecx]
.text$mn:00007928                 mov     eax, [ebp+var_8]
.text$mn:0000792B                 mov     [edx], eax
.text$mn:0000792D                 mov     esp, ebp
.text$mn:0000792F                 pop     ebp
.text$mn:00007930                 retn
.text$mn:00007930 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007930
.text$mn:00007930 ; ---------------------------------------------------------------------------
.text$mn:00007931                 align 4
.text$mn:00007931 _text$mn        ends
.text$mn:00007931
.text$mn:00007934 ; ===========================================================================
.text$mn:00007934
.text$mn:00007934 ; Segment type: Pure code
.text$mn:00007934 ; Segment permissions: Read/Execute
.text$mn:00007934 _text$mn        segment para public 'CODE' use32
.text$mn:00007934                 assume cs:_text$mn
.text$mn:00007934                 ;org 7934h
.text$mn:00007934 ; COMDAT (pick any)
.text$mn:00007934                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007934
.text$mn:00007934 ; =============== S U B R O U T I N E =======================================
.text$mn:00007934
.text$mn:00007934 ; Attributes: bp-based frame
.text$mn:00007934
.text$mn:00007934 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Alloc_proxy(void)
.text$mn:00007934                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:00007934 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:00007934                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+38p
.text$mn:00007934
.text$mn:00007934 var_10          = byte ptr -10h
.text$mn:00007934 var_8           = dword ptr -8
.text$mn:00007934 var_1           = byte ptr -1
.text$mn:00007934
.text$mn:00007934                 push    ebp
.text$mn:00007935                 mov     ebp, esp
.text$mn:00007937                 sub     esp, 10h
.text$mn:0000793A                 mov     [ebp+var_8], ecx
.text$mn:0000793D                 lea     ecx, [ebp+var_1]
.text$mn:00007940                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00007945                 push    1
.text$mn:00007947                 lea     ecx, [ebp+var_1]
.text$mn:0000794A                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000794F                 mov     ecx, [ebp+var_8]
.text$mn:00007952                 mov     [ecx], eax
.text$mn:00007954                 lea     ecx, [ebp+var_10] ; this
.text$mn:00007957                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:0000795C                 push    eax             ; int
.text$mn:0000795D                 mov     edx, [ebp+var_8]
.text$mn:00007960                 mov     eax, [edx]
.text$mn:00007962                 push    eax             ; void *
.text$mn:00007963                 lea     ecx, [ebp+var_1]
.text$mn:00007966                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000796B                 mov     ecx, [ebp+var_8]
.text$mn:0000796E                 mov     edx, [ecx]
.text$mn:00007970                 mov     eax, [ebp+var_8]
.text$mn:00007973                 mov     [edx], eax
.text$mn:00007975                 mov     esp, ebp
.text$mn:00007977                 pop     ebp
.text$mn:00007978                 retn
.text$mn:00007978 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:00007978
.text$mn:00007978 ; ---------------------------------------------------------------------------
.text$mn:00007979                 align 4
.text$mn:00007979 _text$mn        ends
.text$mn:00007979
.text$mn:0000797C ; ===========================================================================
.text$mn:0000797C
.text$mn:0000797C ; Segment type: Pure code
.text$mn:0000797C ; Segment permissions: Read/Execute
.text$mn:0000797C _text$mn        segment para public 'CODE' use32
.text$mn:0000797C                 assume cs:_text$mn
.text$mn:0000797C                 ;org 797Ch
.text$mn:0000797C ; COMDAT (pick any)
.text$mn:0000797C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000797C
.text$mn:0000797C ; =============== S U B R O U T I N E =======================================
.text$mn:0000797C
.text$mn:0000797C ; Attributes: bp-based frame
.text$mn:0000797C
.text$mn:0000797C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Assign_rv(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:0000797C                 public ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z
.text$mn:0000797C ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z proc near
.text$mn:0000797C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+60p
.text$mn:0000797C
.text$mn:0000797C var_8           = dword ptr -8
.text$mn:0000797C var_1           = byte ptr -1
.text$mn:0000797C arg_0           = dword ptr  8
.text$mn:0000797C
.text$mn:0000797C                 push    ebp
.text$mn:0000797D                 mov     ebp, esp
.text$mn:0000797F                 sub     esp, 8
.text$mn:00007982                 mov     [ebp+var_8], ecx
.text$mn:00007985                 mov     eax, [ebp+arg_0]
.text$mn:00007988                 cmp     dword ptr [eax+18h], 8
.text$mn:0000798C                 jnb     short loc_79B0
.text$mn:0000798E                 mov     ecx, [ebp+arg_0]
.text$mn:00007991                 mov     edx, [ecx+14h]
.text$mn:00007994                 add     edx, 1
.text$mn:00007997                 push    edx             ; int
.text$mn:00007998                 mov     eax, [ebp+arg_0]
.text$mn:0000799B                 add     eax, 4
.text$mn:0000799E                 push    eax             ; Src
.text$mn:0000799F                 mov     ecx, [ebp+var_8]
.text$mn:000079A2                 add     ecx, 4
.text$mn:000079A5                 push    ecx             ; Dst
.text$mn:000079A6                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000079AB                 add     esp, 0Ch
.text$mn:000079AE                 jmp     short loc_79DB
.text$mn:000079B0 ; ---------------------------------------------------------------------------
.text$mn:000079B0
.text$mn:000079B0 loc_79B0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+10j
.text$mn:000079B0                 mov     edx, [ebp+arg_0]
.text$mn:000079B3                 add     edx, 4
.text$mn:000079B6                 push    edx             ; int
.text$mn:000079B7                 mov     eax, [ebp+var_8]
.text$mn:000079BA                 add     eax, 4
.text$mn:000079BD                 push    eax             ; void *
.text$mn:000079BE                 lea     ecx, [ebp+var_1]
.text$mn:000079C1                 push    ecx
.text$mn:000079C2                 mov     ecx, [ebp+var_8]
.text$mn:000079C5                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000079CA                 mov     ecx, eax
.text$mn:000079CC                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000079D1                 mov     edx, [ebp+arg_0]
.text$mn:000079D4                 mov     dword ptr [edx+4], 0
.text$mn:000079DB
.text$mn:000079DB loc_79DB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+32j
.text$mn:000079DB                 mov     eax, [ebp+var_8]
.text$mn:000079DE                 mov     ecx, [ebp+arg_0]
.text$mn:000079E1                 mov     edx, [ecx+14h]
.text$mn:000079E4                 mov     [eax+14h], edx
.text$mn:000079E7                 mov     eax, [ebp+var_8]
.text$mn:000079EA                 mov     ecx, [ebp+arg_0]
.text$mn:000079ED                 mov     edx, [ecx+18h]
.text$mn:000079F0                 mov     [eax+18h], edx
.text$mn:000079F3                 push    0
.text$mn:000079F5                 push    0
.text$mn:000079F7                 mov     ecx, [ebp+arg_0]
.text$mn:000079FA                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000079FF                 mov     esp, ebp
.text$mn:00007A01                 pop     ebp
.text$mn:00007A02                 retn    4
.text$mn:00007A02 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z endp
.text$mn:00007A02
.text$mn:00007A02 ; ---------------------------------------------------------------------------
.text$mn:00007A05                 align 4
.text$mn:00007A05 _text$mn        ends
.text$mn:00007A05
.text$mn:00007A08 ; ===========================================================================
.text$mn:00007A08
.text$mn:00007A08 ; Segment type: Pure code
.text$mn:00007A08 ; Segment permissions: Read/Execute
.text$mn:00007A08 _text$mn        segment para public 'CODE' use32
.text$mn:00007A08                 assume cs:_text$mn
.text$mn:00007A08                 ;org 7A08h
.text$mn:00007A08 ; COMDAT (pick any)
.text$mn:00007A08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A08
.text$mn:00007A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A08
.text$mn:00007A08 ; Attributes: bp-based frame
.text$mn:00007A08
.text$mn:00007A08 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00007A08                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00007A08 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00007A08                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+80p
.text$mn:00007A08                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *)+80p ...
.text$mn:00007A08
.text$mn:00007A08 var_4           = dword ptr -4
.text$mn:00007A08
.text$mn:00007A08                 push    ebp
.text$mn:00007A09                 mov     ebp, esp
.text$mn:00007A0B                 push    ecx
.text$mn:00007A0C                 mov     [ebp+var_4], ecx
.text$mn:00007A0F                 mov     eax, [ebp+var_4]
.text$mn:00007A12                 mov     dword ptr [eax], 0
.text$mn:00007A18                 mov     esp, ebp
.text$mn:00007A1A                 pop     ebp
.text$mn:00007A1B                 retn
.text$mn:00007A1B ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00007A1B
.text$mn:00007A1B _text$mn        ends
.text$mn:00007A1B
.text$mn:00007A1C ; ===========================================================================
.text$mn:00007A1C
.text$mn:00007A1C ; Segment type: Pure code
.text$mn:00007A1C ; Segment permissions: Read/Execute
.text$mn:00007A1C _text$mn        segment para public 'CODE' use32
.text$mn:00007A1C                 assume cs:_text$mn
.text$mn:00007A1C                 ;org 7A1Ch
.text$mn:00007A1C ; COMDAT (pick any)
.text$mn:00007A1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A1C
.text$mn:00007A1C ; =============== S U B R O U T I N E =======================================
.text$mn:00007A1C
.text$mn:00007A1C ; Attributes: bp-based frame
.text$mn:00007A1C
.text$mn:00007A1C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00007A1C                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00007A1C ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00007A1C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00007A1C
.text$mn:00007A1C var_20          = dword ptr -20h
.text$mn:00007A1C var_1C          = dword ptr -1Ch
.text$mn:00007A1C var_18          = dword ptr -18h
.text$mn:00007A1C var_11          = byte ptr -11h
.text$mn:00007A1C var_10          = dword ptr -10h
.text$mn:00007A1C var_C           = byte ptr -0Ch
.text$mn:00007A1C var_4           = dword ptr -4
.text$mn:00007A1C arg_0           = dword ptr  8
.text$mn:00007A1C
.text$mn:00007A1C ; FUNCTION CHUNK AT .text$mn:00007B3E SIZE 00000009 BYTES
.text$mn:00007A1C
.text$mn:00007A1C                 push    ebp
.text$mn:00007A1D                 mov     ebp, esp
.text$mn:00007A1F                 push    0FFFFFFFFh
.text$mn:00007A21                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00007A26                 mov     eax, large fs:0
.text$mn:00007A2C                 push    eax
.text$mn:00007A2D                 push    ecx
.text$mn:00007A2E                 sub     esp, 10h
.text$mn:00007A31                 push    ebx
.text$mn:00007A32                 push    esi
.text$mn:00007A33                 push    edi
.text$mn:00007A34                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007A39                 xor     eax, ebp
.text$mn:00007A3B                 push    eax
.text$mn:00007A3C                 lea     eax, [ebp+var_C]
.text$mn:00007A3F                 mov     large fs:0, eax
.text$mn:00007A45                 mov     [ebp+var_10], esp
.text$mn:00007A48                 mov     [ebp+var_18], ecx
.text$mn:00007A4B                 mov     eax, [ebp+arg_0]
.text$mn:00007A4E                 or      eax, 0Fh
.text$mn:00007A51                 mov     [ebp+var_1C], eax
.text$mn:00007A54                 mov     ecx, [ebp+var_18]
.text$mn:00007A57                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00007A5C                 cmp     eax, [ebp+var_1C]
.text$mn:00007A5F                 jnb     short loc_7A69
.text$mn:00007A61                 mov     ecx, [ebp+arg_0]
.text$mn:00007A64                 mov     [ebp+var_1C], ecx
.text$mn:00007A67                 jmp     short loc_7ABB
.text$mn:00007A69 ; ---------------------------------------------------------------------------
.text$mn:00007A69
.text$mn:00007A69 loc_7A69:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00007A69                 mov     edx, [ebp+var_18]
.text$mn:00007A6C                 mov     ecx, [edx+18h]
.text$mn:00007A6F                 shr     ecx, 1
.text$mn:00007A71                 mov     eax, [ebp+var_1C]
.text$mn:00007A74                 xor     edx, edx
.text$mn:00007A76                 mov     esi, 3
.text$mn:00007A7B                 div     esi
.text$mn:00007A7D                 cmp     ecx, eax
.text$mn:00007A7F                 ja      short loc_7A83
.text$mn:00007A81                 jmp     short loc_7ABB
.text$mn:00007A83 ; ---------------------------------------------------------------------------
.text$mn:00007A83
.text$mn:00007A83 loc_7A83:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00007A83                 mov     ecx, [ebp+var_18]
.text$mn:00007A86                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00007A8B                 mov     edx, [ebp+var_18]
.text$mn:00007A8E                 mov     ecx, [edx+18h]
.text$mn:00007A91                 shr     ecx, 1
.text$mn:00007A93                 sub     eax, ecx
.text$mn:00007A95                 mov     edx, [ebp+var_18]
.text$mn:00007A98                 cmp     [edx+18h], eax
.text$mn:00007A9B                 ja      short loc_7AB0
.text$mn:00007A9D                 mov     eax, [ebp+var_18]
.text$mn:00007AA0                 mov     ecx, [eax+18h]
.text$mn:00007AA3                 shr     ecx, 1
.text$mn:00007AA5                 mov     edx, [ebp+var_18]
.text$mn:00007AA8                 add     ecx, [edx+18h]
.text$mn:00007AAB                 mov     [ebp+var_1C], ecx
.text$mn:00007AAE                 jmp     short loc_7ABB
.text$mn:00007AB0 ; ---------------------------------------------------------------------------
.text$mn:00007AB0
.text$mn:00007AB0 loc_7AB0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00007AB0                 mov     ecx, [ebp+var_18]
.text$mn:00007AB3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00007AB8                 mov     [ebp+var_1C], eax
.text$mn:00007ABB
.text$mn:00007ABB loc_7ABB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00007ABB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00007ABB                 mov     [ebp+var_4], 0
.text$mn:00007AC2                 mov     eax, [ebp+var_1C]
.text$mn:00007AC5                 add     eax, 1
.text$mn:00007AC8                 push    eax
.text$mn:00007AC9                 lea     ecx, [ebp+var_11]
.text$mn:00007ACC                 push    ecx
.text$mn:00007ACD                 mov     ecx, [ebp+var_18]
.text$mn:00007AD0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007AD5                 mov     ecx, eax
.text$mn:00007AD7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00007ADC                 mov     [ebp+var_20], eax
.text$mn:00007ADF                 jmp     short loc_7B3E
.text$mn:00007ADF ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00007ADF
.text$mn:00007AE1
.text$mn:00007AE1 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AE1
.text$mn:00007AE1
.text$mn:00007AE1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00007AE1                                         ; DATA XREF: .xdata$x:0000C4D8o
.text$mn:00007AE1
.text$mn:00007AE1 ; FUNCTION CHUNK AT .text$mn:00007B28 SIZE 00000009 BYTES
.text$mn:00007AE1 ; FUNCTION CHUNK AT .text$mn:00007B38 SIZE 00000006 BYTES
.text$mn:00007AE1
.text$mn:00007AE1                 mov     [ebp-10h], esp
.text$mn:00007AE4                 mov     edx, [ebp+8]
.text$mn:00007AE7                 mov     [ebp-1Ch], edx
.text$mn:00007AEA                 mov     byte ptr [ebp-4], 2
.text$mn:00007AEE                 mov     eax, [ebp-1Ch]
.text$mn:00007AF1                 add     eax, 1
.text$mn:00007AF4                 push    eax
.text$mn:00007AF5                 lea     ecx, [ebp-12h]
.text$mn:00007AF8                 push    ecx
.text$mn:00007AF9                 mov     ecx, [ebp-18h]
.text$mn:00007AFC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007B01                 mov     ecx, eax
.text$mn:00007B03                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00007B08                 mov     [ebp-20h], eax
.text$mn:00007B0B                 jmp     short loc_7B28
.text$mn:00007B0B __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00007B0B
.text$mn:00007B0D
.text$mn:00007B0D ; =============== S U B R O U T I N E =======================================
.text$mn:00007B0D
.text$mn:00007B0D ; Attributes: noreturn
.text$mn:00007B0D
.text$mn:00007B0D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00007B0D                                         ; DATA XREF: .xdata$x:0000C4E8o
.text$mn:00007B0D                 push    0               ; Size
.text$mn:00007B0F                 push    1               ; char
.text$mn:00007B11                 mov     ecx, [ebp-18h]
.text$mn:00007B14                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00007B19                 push    0
.text$mn:00007B1B                 push    0
.text$mn:00007B1D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00007B1D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00007B1D
.text$mn:00007B22 ; ---------------------------------------------------------------------------
.text$mn:00007B22                 mov     eax, offset $LN17
.text$mn:00007B27                 retn
.text$mn:00007B28 ; ---------------------------------------------------------------------------
.text$mn:00007B28 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007B28
.text$mn:00007B28 loc_7B28:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00007B28                 mov     dword ptr [ebp-4], 1
.text$mn:00007B2F                 jmp     short loc_7B38
.text$mn:00007B2F ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007B31
.text$mn:00007B31 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B31
.text$mn:00007B31
.text$mn:00007B31 $LN17           proc near               ; DATA XREF: .text$mn:00007B22o
.text$mn:00007B31                 mov     dword ptr [ebp-4], 1
.text$mn:00007B31 $LN17           endp ; sp-analysis failed
.text$mn:00007B31
.text$mn:00007B38 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007B38
.text$mn:00007B38 loc_7B38:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00007B38                 mov     eax, offset $LN19
.text$mn:00007B3D                 retn
.text$mn:00007B3D ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007B3E ; ---------------------------------------------------------------------------
.text$mn:00007B3E ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00007B3E
.text$mn:00007B3E loc_7B3E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00007B3E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007B45                 jmp     short loc_7B4E
.text$mn:00007B45 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00007B47
.text$mn:00007B47 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B47
.text$mn:00007B47
.text$mn:00007B47 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_7B38o
.text$mn:00007B47                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00007B4E
.text$mn:00007B4E loc_7B4E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00007B4E                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00007B52                 jbe     short loc_7B6D
.text$mn:00007B54                 mov     edx, [ebp+0Ch]
.text$mn:00007B57                 push    edx             ; Size
.text$mn:00007B58                 mov     ecx, [ebp-18h]
.text$mn:00007B5B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007B60                 push    eax             ; Src
.text$mn:00007B61                 mov     eax, [ebp-20h]
.text$mn:00007B64                 push    eax             ; Dst
.text$mn:00007B65                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007B6A                 add     esp, 0Ch
.text$mn:00007B6D
.text$mn:00007B6D loc_7B6D:                               ; CODE XREF: $LN19+Bj
.text$mn:00007B6D                 push    0               ; Size
.text$mn:00007B6F                 push    1               ; char
.text$mn:00007B71                 mov     ecx, [ebp-18h]
.text$mn:00007B74                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00007B79                 lea     ecx, [ebp-20h]
.text$mn:00007B7C                 push    ecx             ; int
.text$mn:00007B7D                 mov     edx, [ebp-18h]
.text$mn:00007B80                 add     edx, 4
.text$mn:00007B83                 push    edx             ; void *
.text$mn:00007B84                 lea     eax, [ebp-13h]
.text$mn:00007B87                 push    eax
.text$mn:00007B88                 mov     ecx, [ebp-18h]
.text$mn:00007B8B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007B90                 mov     ecx, eax
.text$mn:00007B92                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00007B97                 mov     ecx, [ebp-18h]
.text$mn:00007B9A                 mov     edx, [ebp-1Ch]
.text$mn:00007B9D                 mov     [ecx+18h], edx
.text$mn:00007BA0                 mov     eax, [ebp+0Ch]
.text$mn:00007BA3                 push    eax
.text$mn:00007BA4                 mov     ecx, [ebp-18h]
.text$mn:00007BA7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007BAC                 mov     ecx, [ebp-0Ch]
.text$mn:00007BAF                 mov     large fs:0, ecx
.text$mn:00007BB6                 pop     ecx
.text$mn:00007BB7                 pop     edi
.text$mn:00007BB8                 pop     esi
.text$mn:00007BB9                 pop     ebx
.text$mn:00007BBA                 mov     esp, ebp
.text$mn:00007BBC                 pop     ebp
.text$mn:00007BBD                 retn    8
.text$mn:00007BBD $LN19           endp ; sp-analysis failed
.text$mn:00007BBD
.text$mn:00007BBD _text$mn        ends
.text$mn:00007BBD
.text$x:00007BC0 ; ===========================================================================
.text$x:00007BC0
.text$x:00007BC0 ; Segment type: Pure code
.text$x:00007BC0 ; Segment permissions: Read/Execute
.text$x:00007BC0 _text$x         segment para public 'CODE' use32
.text$x:00007BC0                 assume cs:_text$x
.text$x:00007BC0                 ;org 7BC0h
.text$x:00007BC0 ; COMDAT (pick associative to section at 7A1C)
.text$x:00007BC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007BC0
.text$x:00007BC0 ; =============== S U B R O U T I N E =======================================
.text$x:00007BC0
.text$x:00007BC0
.text$x:00007BC0 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00007BC0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00007BC0
.text$x:00007BC0 arg_4           = dword ptr  8
.text$x:00007BC0
.text$x:00007BC0                 mov     edx, [esp+arg_4]
.text$x:00007BC4                 lea     eax, [edx+0Ch]
.text$x:00007BC7                 mov     ecx, [edx-24h]
.text$x:00007BCA                 xor     ecx, eax
.text$x:00007BCC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007BD1                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00007BD6                 jmp     ___CxxFrameHandler3
.text$x:00007BD6 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00007BD6
.text$x:00007BD6 ; ---------------------------------------------------------------------------
.text$x:00007BDB                 align 4
.text$x:00007BDB _text$x         ends
.text$x:00007BDB
.text$mn:00007BDC ; ===========================================================================
.text$mn:00007BDC
.text$mn:00007BDC ; Segment type: Pure code
.text$mn:00007BDC ; Segment permissions: Read/Execute
.text$mn:00007BDC _text$mn        segment para public 'CODE' use32
.text$mn:00007BDC                 assume cs:_text$mn
.text$mn:00007BDC                 ;org 7BDCh
.text$mn:00007BDC ; COMDAT (pick any)
.text$mn:00007BDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007BDC
.text$mn:00007BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00007BDC
.text$mn:00007BDC ; Attributes: bp-based frame
.text$mn:00007BDC
.text$mn:00007BDC ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00007BDC                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00007BDC ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00007BDC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00007BDC
.text$mn:00007BDC var_20          = dword ptr -20h
.text$mn:00007BDC var_1C          = dword ptr -1Ch
.text$mn:00007BDC var_18          = dword ptr -18h
.text$mn:00007BDC var_11          = byte ptr -11h
.text$mn:00007BDC var_10          = dword ptr -10h
.text$mn:00007BDC var_C           = byte ptr -0Ch
.text$mn:00007BDC var_4           = dword ptr -4
.text$mn:00007BDC arg_0           = dword ptr  8
.text$mn:00007BDC
.text$mn:00007BDC ; FUNCTION CHUNK AT .text$mn:00007CFE SIZE 00000009 BYTES
.text$mn:00007BDC
.text$mn:00007BDC                 push    ebp
.text$mn:00007BDD                 mov     ebp, esp
.text$mn:00007BDF                 push    0FFFFFFFFh
.text$mn:00007BE1                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00007BE6                 mov     eax, large fs:0
.text$mn:00007BEC                 push    eax
.text$mn:00007BED                 push    ecx
.text$mn:00007BEE                 sub     esp, 10h
.text$mn:00007BF1                 push    ebx
.text$mn:00007BF2                 push    esi
.text$mn:00007BF3                 push    edi
.text$mn:00007BF4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007BF9                 xor     eax, ebp
.text$mn:00007BFB                 push    eax
.text$mn:00007BFC                 lea     eax, [ebp+var_C]
.text$mn:00007BFF                 mov     large fs:0, eax
.text$mn:00007C05                 mov     [ebp+var_10], esp
.text$mn:00007C08                 mov     [ebp+var_18], ecx
.text$mn:00007C0B                 mov     eax, [ebp+arg_0]
.text$mn:00007C0E                 or      eax, 7
.text$mn:00007C11                 mov     [ebp+var_1C], eax
.text$mn:00007C14                 mov     ecx, [ebp+var_18]
.text$mn:00007C17                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00007C1C                 cmp     eax, [ebp+var_1C]
.text$mn:00007C1F                 jnb     short loc_7C29
.text$mn:00007C21                 mov     ecx, [ebp+arg_0]
.text$mn:00007C24                 mov     [ebp+var_1C], ecx
.text$mn:00007C27                 jmp     short loc_7C7B
.text$mn:00007C29 ; ---------------------------------------------------------------------------
.text$mn:00007C29
.text$mn:00007C29 loc_7C29:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00007C29                 mov     edx, [ebp+var_18]
.text$mn:00007C2C                 mov     ecx, [edx+18h]
.text$mn:00007C2F                 shr     ecx, 1
.text$mn:00007C31                 mov     eax, [ebp+var_1C]
.text$mn:00007C34                 xor     edx, edx
.text$mn:00007C36                 mov     esi, 3
.text$mn:00007C3B                 div     esi
.text$mn:00007C3D                 cmp     ecx, eax
.text$mn:00007C3F                 ja      short loc_7C43
.text$mn:00007C41                 jmp     short loc_7C7B
.text$mn:00007C43 ; ---------------------------------------------------------------------------
.text$mn:00007C43
.text$mn:00007C43 loc_7C43:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:00007C43                 mov     ecx, [ebp+var_18]
.text$mn:00007C46                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00007C4B                 mov     edx, [ebp+var_18]
.text$mn:00007C4E                 mov     ecx, [edx+18h]
.text$mn:00007C51                 shr     ecx, 1
.text$mn:00007C53                 sub     eax, ecx
.text$mn:00007C55                 mov     edx, [ebp+var_18]
.text$mn:00007C58                 cmp     [edx+18h], eax
.text$mn:00007C5B                 ja      short loc_7C70
.text$mn:00007C5D                 mov     eax, [ebp+var_18]
.text$mn:00007C60                 mov     ecx, [eax+18h]
.text$mn:00007C63                 shr     ecx, 1
.text$mn:00007C65                 mov     edx, [ebp+var_18]
.text$mn:00007C68                 add     ecx, [edx+18h]
.text$mn:00007C6B                 mov     [ebp+var_1C], ecx
.text$mn:00007C6E                 jmp     short loc_7C7B
.text$mn:00007C70 ; ---------------------------------------------------------------------------
.text$mn:00007C70
.text$mn:00007C70 loc_7C70:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00007C70                 mov     ecx, [ebp+var_18]
.text$mn:00007C73                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00007C78                 mov     [ebp+var_1C], eax
.text$mn:00007C7B
.text$mn:00007C7B loc_7C7B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:00007C7B                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:00007C7B                 mov     [ebp+var_4], 0
.text$mn:00007C82                 mov     eax, [ebp+var_1C]
.text$mn:00007C85                 add     eax, 1
.text$mn:00007C88                 push    eax
.text$mn:00007C89                 lea     ecx, [ebp+var_11]
.text$mn:00007C8C                 push    ecx
.text$mn:00007C8D                 mov     ecx, [ebp+var_18]
.text$mn:00007C90                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007C95                 mov     ecx, eax
.text$mn:00007C97                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00007C9C                 mov     [ebp+var_20], eax
.text$mn:00007C9F                 jmp     short loc_7CFE
.text$mn:00007C9F ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:00007C9F
.text$mn:00007CA1
.text$mn:00007CA1 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CA1
.text$mn:00007CA1
.text$mn:00007CA1 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:00007CA1                                         ; DATA XREF: .xdata$x:0000C8D4o
.text$mn:00007CA1
.text$mn:00007CA1 ; FUNCTION CHUNK AT .text$mn:00007CE8 SIZE 00000009 BYTES
.text$mn:00007CA1 ; FUNCTION CHUNK AT .text$mn:00007CF8 SIZE 00000006 BYTES
.text$mn:00007CA1
.text$mn:00007CA1                 mov     [ebp-10h], esp
.text$mn:00007CA4                 mov     edx, [ebp+8]
.text$mn:00007CA7                 mov     [ebp-1Ch], edx
.text$mn:00007CAA                 mov     byte ptr [ebp-4], 2
.text$mn:00007CAE                 mov     eax, [ebp-1Ch]
.text$mn:00007CB1                 add     eax, 1
.text$mn:00007CB4                 push    eax
.text$mn:00007CB5                 lea     ecx, [ebp-12h]
.text$mn:00007CB8                 push    ecx
.text$mn:00007CB9                 mov     ecx, [ebp-18h]
.text$mn:00007CBC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007CC1                 mov     ecx, eax
.text$mn:00007CC3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00007CC8                 mov     [ebp-20h], eax
.text$mn:00007CCB                 jmp     short loc_7CE8
.text$mn:00007CCB __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00007CCB
.text$mn:00007CCD
.text$mn:00007CCD ; =============== S U B R O U T I N E =======================================
.text$mn:00007CCD
.text$mn:00007CCD ; Attributes: noreturn
.text$mn:00007CCD
.text$mn:00007CCD __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00007CCD                                         ; DATA XREF: .xdata$x:0000C8E4o
.text$mn:00007CCD                 push    0
.text$mn:00007CCF                 push    1
.text$mn:00007CD1                 mov     ecx, [ebp-18h]
.text$mn:00007CD4                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00007CD9                 push    0
.text$mn:00007CDB                 push    0
.text$mn:00007CDD                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00007CDD __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00007CDD
.text$mn:00007CE2 ; ---------------------------------------------------------------------------
.text$mn:00007CE2                 mov     eax, offset $LN17_0
.text$mn:00007CE7                 retn
.text$mn:00007CE8 ; ---------------------------------------------------------------------------
.text$mn:00007CE8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00007CE8
.text$mn:00007CE8 loc_7CE8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00007CE8                 mov     dword ptr [ebp-4], 1
.text$mn:00007CEF                 jmp     short loc_7CF8
.text$mn:00007CEF ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00007CF1
.text$mn:00007CF1 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CF1
.text$mn:00007CF1
.text$mn:00007CF1 $LN17_0         proc near               ; DATA XREF: .text$mn:00007CE2o
.text$mn:00007CF1                 mov     dword ptr [ebp-4], 1
.text$mn:00007CF1 $LN17_0         endp ; sp-analysis failed
.text$mn:00007CF1
.text$mn:00007CF8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00007CF8
.text$mn:00007CF8 loc_7CF8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00007CF8                 mov     eax, offset $LN19_0
.text$mn:00007CFD                 retn
.text$mn:00007CFD ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00007CFE ; ---------------------------------------------------------------------------
.text$mn:00007CFE ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00007CFE
.text$mn:00007CFE loc_7CFE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00007CFE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007D05                 jmp     short loc_7D0E
.text$mn:00007D05 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00007D07
.text$mn:00007D07 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D07
.text$mn:00007D07
.text$mn:00007D07 $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_7CF8o
.text$mn:00007D07                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00007D0E
.text$mn:00007D0E loc_7D0E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00007D0E                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00007D12                 jbe     short loc_7D2D
.text$mn:00007D14                 mov     edx, [ebp+0Ch]
.text$mn:00007D17                 push    edx             ; int
.text$mn:00007D18                 mov     ecx, [ebp-18h]
.text$mn:00007D1B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007D20                 push    eax             ; Src
.text$mn:00007D21                 mov     eax, [ebp-20h]
.text$mn:00007D24                 push    eax             ; Dst
.text$mn:00007D25                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00007D2A                 add     esp, 0Ch
.text$mn:00007D2D
.text$mn:00007D2D loc_7D2D:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00007D2D                 push    0
.text$mn:00007D2F                 push    1
.text$mn:00007D31                 mov     ecx, [ebp-18h]
.text$mn:00007D34                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00007D39                 lea     ecx, [ebp-20h]
.text$mn:00007D3C                 push    ecx             ; int
.text$mn:00007D3D                 mov     edx, [ebp-18h]
.text$mn:00007D40                 add     edx, 4
.text$mn:00007D43                 push    edx             ; void *
.text$mn:00007D44                 lea     eax, [ebp-13h]
.text$mn:00007D47                 push    eax
.text$mn:00007D48                 mov     ecx, [ebp-18h]
.text$mn:00007D4B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007D50                 mov     ecx, eax
.text$mn:00007D52                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00007D57                 mov     ecx, [ebp-18h]
.text$mn:00007D5A                 mov     edx, [ebp-1Ch]
.text$mn:00007D5D                 mov     [ecx+18h], edx
.text$mn:00007D60                 mov     eax, [ebp+0Ch]
.text$mn:00007D63                 push    eax
.text$mn:00007D64                 mov     ecx, [ebp-18h]
.text$mn:00007D67                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00007D6C                 mov     ecx, [ebp-0Ch]
.text$mn:00007D6F                 mov     large fs:0, ecx
.text$mn:00007D76                 pop     ecx
.text$mn:00007D77                 pop     edi
.text$mn:00007D78                 pop     esi
.text$mn:00007D79                 pop     ebx
.text$mn:00007D7A                 mov     esp, ebp
.text$mn:00007D7C                 pop     ebp
.text$mn:00007D7D                 retn    8
.text$mn:00007D7D $LN19_0         endp ; sp-analysis failed
.text$mn:00007D7D
.text$mn:00007D7D _text$mn        ends
.text$mn:00007D7D
.text$x:00007D80 ; ===========================================================================
.text$x:00007D80
.text$x:00007D80 ; Segment type: Pure code
.text$x:00007D80 ; Segment permissions: Read/Execute
.text$x:00007D80 _text$x         segment para public 'CODE' use32
.text$x:00007D80                 assume cs:_text$x
.text$x:00007D80                 ;org 7D80h
.text$x:00007D80 ; COMDAT (pick associative to section at 7BDC)
.text$x:00007D80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007D80
.text$x:00007D80 ; =============== S U B R O U T I N E =======================================
.text$x:00007D80
.text$x:00007D80
.text$x:00007D80 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00007D80                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00007D80
.text$x:00007D80 arg_4           = dword ptr  8
.text$x:00007D80
.text$x:00007D80                 mov     edx, [esp+arg_4]
.text$x:00007D84                 lea     eax, [edx+0Ch]
.text$x:00007D87                 mov     ecx, [edx-24h]
.text$x:00007D8A                 xor     ecx, eax
.text$x:00007D8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007D91                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00007D96                 jmp     ___CxxFrameHandler3
.text$x:00007D96 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00007D96
.text$x:00007D96 ; ---------------------------------------------------------------------------
.text$x:00007D9B                 align 4
.text$x:00007D9B _text$x         ends
.text$x:00007D9B
.text$mn:00007D9C ; ===========================================================================
.text$mn:00007D9C
.text$mn:00007D9C ; Segment type: Pure code
.text$mn:00007D9C ; Segment permissions: Read/Execute
.text$mn:00007D9C _text$mn        segment para public 'CODE' use32
.text$mn:00007D9C                 assume cs:_text$mn
.text$mn:00007D9C                 ;org 7D9Ch
.text$mn:00007D9C ; COMDAT (pick any)
.text$mn:00007D9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D9C
.text$mn:00007D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00007D9C
.text$mn:00007D9C ; Attributes: bp-based frame
.text$mn:00007D9C
.text$mn:00007D9C ; protected: void __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::_Destroy(struct PluginInfo * *, struct PluginInfo * *)
.text$mn:00007D9C                 public ?_Destroy@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXPAPAUPluginInfo@@0@Z
.text$mn:00007D9C ?_Destroy@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXPAPAUPluginInfo@@0@Z proc near
.text$mn:00007D9C                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reallocate(uint)+CBp
.text$mn:00007D9C
.text$mn:00007D9C var_8           = dword ptr -8
.text$mn:00007D9C var_1           = byte ptr -1
.text$mn:00007D9C arg_0           = dword ptr  8
.text$mn:00007D9C arg_4           = dword ptr  0Ch
.text$mn:00007D9C
.text$mn:00007D9C                 push    ebp
.text$mn:00007D9D                 mov     ebp, esp
.text$mn:00007D9F                 sub     esp, 8
.text$mn:00007DA2                 mov     [ebp+var_8], ecx
.text$mn:00007DA5                 lea     eax, [ebp+var_1]
.text$mn:00007DA8                 push    eax
.text$mn:00007DA9                 mov     ecx, [ebp+var_8]
.text$mn:00007DAC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginInfo *,std::allocator<PluginInfo *>>>::_Getal(void)
.text$mn:00007DB1                 lea     ecx, [ebp+var_1]
.text$mn:00007DB4                 push    ecx
.text$mn:00007DB5                 mov     edx, [ebp+arg_4]
.text$mn:00007DB8                 push    edx
.text$mn:00007DB9                 mov     eax, [ebp+arg_0]
.text$mn:00007DBC                 push    eax
.text$mn:00007DBD                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@YAXPAPAUPluginInfo@@0AAU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginInfo *>>>(PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &)
.text$mn:00007DC2                 add     esp, 0Ch
.text$mn:00007DC5                 mov     esp, ebp
.text$mn:00007DC7                 pop     ebp
.text$mn:00007DC8                 retn    8
.text$mn:00007DC8 ?_Destroy@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXPAPAUPluginInfo@@0@Z endp
.text$mn:00007DC8
.text$mn:00007DC8 ; ---------------------------------------------------------------------------
.text$mn:00007DCB                 align 4
.text$mn:00007DCB _text$mn        ends
.text$mn:00007DCB
.text$mn:00007DCC ; ===========================================================================
.text$mn:00007DCC
.text$mn:00007DCC ; Segment type: Pure code
.text$mn:00007DCC ; Segment permissions: Read/Execute
.text$mn:00007DCC _text$mn        segment para public 'CODE' use32
.text$mn:00007DCC                 assume cs:_text$mn
.text$mn:00007DCC                 ;org 7DCCh
.text$mn:00007DCC ; COMDAT (pick any)
.text$mn:00007DCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007DCC
.text$mn:00007DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00007DCC
.text$mn:00007DCC ; Attributes: bp-based frame
.text$mn:00007DCC
.text$mn:00007DCC ; protected: void __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::_Destroy(class TiXmlDocument * *, class TiXmlDocument * *)
.text$mn:00007DCC                 public ?_Destroy@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXPAPAVTiXmlDocument@@0@Z
.text$mn:00007DCC ?_Destroy@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXPAPAVTiXmlDocument@@0@Z proc near
.text$mn:00007DCC                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reallocate(uint)+CBp
.text$mn:00007DCC
.text$mn:00007DCC var_8           = dword ptr -8
.text$mn:00007DCC var_1           = byte ptr -1
.text$mn:00007DCC arg_0           = dword ptr  8
.text$mn:00007DCC arg_4           = dword ptr  0Ch
.text$mn:00007DCC
.text$mn:00007DCC                 push    ebp
.text$mn:00007DCD                 mov     ebp, esp
.text$mn:00007DCF                 sub     esp, 8
.text$mn:00007DD2                 mov     [ebp+var_8], ecx
.text$mn:00007DD5                 lea     eax, [ebp+var_1]
.text$mn:00007DD8                 push    eax
.text$mn:00007DD9                 mov     ecx, [ebp+var_8]
.text$mn:00007DDC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TiXmlDocument *,std::allocator<TiXmlDocument *>>>::_Getal(void)
.text$mn:00007DE1                 lea     ecx, [ebp+var_1]
.text$mn:00007DE4                 push    ecx
.text$mn:00007DE5                 mov     edx, [ebp+arg_4]
.text$mn:00007DE8                 push    edx
.text$mn:00007DE9                 mov     eax, [ebp+arg_0]
.text$mn:00007DEC                 push    eax
.text$mn:00007DED                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@YAXPAPAVTiXmlDocument@@0AAU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<TiXmlDocument *>>>(TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &)
.text$mn:00007DF2                 add     esp, 0Ch
.text$mn:00007DF5                 mov     esp, ebp
.text$mn:00007DF7                 pop     ebp
.text$mn:00007DF8                 retn    8
.text$mn:00007DF8 ?_Destroy@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXPAPAVTiXmlDocument@@0@Z endp
.text$mn:00007DF8
.text$mn:00007DF8 ; ---------------------------------------------------------------------------
.text$mn:00007DFB                 align 4
.text$mn:00007DFB _text$mn        ends
.text$mn:00007DFB
.text$mn:00007DFC ; ===========================================================================
.text$mn:00007DFC
.text$mn:00007DFC ; Segment type: Pure code
.text$mn:00007DFC ; Segment permissions: Read/Execute
.text$mn:00007DFC _text$mn        segment para public 'CODE' use32
.text$mn:00007DFC                 assume cs:_text$mn
.text$mn:00007DFC                 ;org 7DFCh
.text$mn:00007DFC ; COMDAT (pick any)
.text$mn:00007DFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007DFC
.text$mn:00007DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00007DFC
.text$mn:00007DFC ; Attributes: bp-based frame
.text$mn:00007DFC
.text$mn:00007DFC ; protected: void __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::_Destroy(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)
.text$mn:00007DFC                 public ?_Destroy@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z
.text$mn:00007DFC ?_Destroy@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z proc near
.text$mn:00007DFC                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reallocate(uint)+CBp
.text$mn:00007DFC
.text$mn:00007DFC var_8           = dword ptr -8
.text$mn:00007DFC var_1           = byte ptr -1
.text$mn:00007DFC arg_0           = dword ptr  8
.text$mn:00007DFC arg_4           = dword ptr  0Ch
.text$mn:00007DFC
.text$mn:00007DFC                 push    ebp
.text$mn:00007DFD                 mov     ebp, esp
.text$mn:00007DFF                 sub     esp, 8
.text$mn:00007E02                 mov     [ebp+var_8], ecx
.text$mn:00007E05                 lea     eax, [ebp+var_1]
.text$mn:00007E08                 push    eax
.text$mn:00007E09                 mov     ecx, [ebp+var_8]
.text$mn:00007E0C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>::_Getal(void)
.text$mn:00007E11                 lea     ecx, [ebp+var_1]
.text$mn:00007E14                 push    ecx
.text$mn:00007E15                 mov     edx, [ebp+arg_4]
.text$mn:00007E18                 push    edx
.text$mn:00007E19                 mov     eax, [ebp+arg_0]
.text$mn:00007E1C                 push    eax
.text$mn:00007E1D                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@YAXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &)
.text$mn:00007E22                 add     esp, 0Ch
.text$mn:00007E25                 mov     esp, ebp
.text$mn:00007E27                 pop     ebp
.text$mn:00007E28                 retn    8
.text$mn:00007E28 ?_Destroy@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z endp
.text$mn:00007E28
.text$mn:00007E28 ; ---------------------------------------------------------------------------
.text$mn:00007E2B                 align 4
.text$mn:00007E2B _text$mn        ends
.text$mn:00007E2B
.text$mn:00007E2C ; ===========================================================================
.text$mn:00007E2C
.text$mn:00007E2C ; Segment type: Pure code
.text$mn:00007E2C ; Segment permissions: Read/Execute
.text$mn:00007E2C _text$mn        segment para public 'CODE' use32
.text$mn:00007E2C                 assume cs:_text$mn
.text$mn:00007E2C                 ;org 7E2Ch
.text$mn:00007E2C ; COMDAT (pick any)
.text$mn:00007E2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E2C
.text$mn:00007E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00007E2C
.text$mn:00007E2C ; Attributes: bp-based frame
.text$mn:00007E2C
.text$mn:00007E2C ; protected: void __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::_Destroy(struct PluginCommand *, struct PluginCommand *)
.text$mn:00007E2C                 public ?_Destroy@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXPAUPluginCommand@@0@Z
.text$mn:00007E2C ?_Destroy@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXPAUPluginCommand@@0@Z proc near
.text$mn:00007E2C                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reallocate(uint)+CBp
.text$mn:00007E2C
.text$mn:00007E2C var_8           = dword ptr -8
.text$mn:00007E2C var_1           = byte ptr -1
.text$mn:00007E2C arg_0           = dword ptr  8
.text$mn:00007E2C arg_4           = dword ptr  0Ch
.text$mn:00007E2C
.text$mn:00007E2C                 push    ebp
.text$mn:00007E2D                 mov     ebp, esp
.text$mn:00007E2F                 sub     esp, 8
.text$mn:00007E32                 mov     [ebp+var_8], ecx
.text$mn:00007E35                 lea     eax, [ebp+var_1]
.text$mn:00007E38                 push    eax
.text$mn:00007E39                 mov     ecx, [ebp+var_8]
.text$mn:00007E3C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCommand,std::allocator<PluginCommand>>>::_Getal(void)
.text$mn:00007E41                 lea     ecx, [ebp+var_1]
.text$mn:00007E44                 push    ecx
.text$mn:00007E45                 mov     edx, [ebp+arg_4]
.text$mn:00007E48                 push    edx
.text$mn:00007E49                 mov     eax, [ebp+arg_0]
.text$mn:00007E4C                 push    eax
.text$mn:00007E4D                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@@std@@YAXPAUPluginCommand@@0AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCommand>>>(PluginCommand *,PluginCommand *,std::_Wrap_alloc<std::allocator<PluginCommand>> &)
.text$mn:00007E52                 add     esp, 0Ch
.text$mn:00007E55                 mov     esp, ebp
.text$mn:00007E57                 pop     ebp
.text$mn:00007E58                 retn    8
.text$mn:00007E58 ?_Destroy@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXPAUPluginCommand@@0@Z endp
.text$mn:00007E58
.text$mn:00007E58 ; ---------------------------------------------------------------------------
.text$mn:00007E5B                 align 4
.text$mn:00007E5B _text$mn        ends
.text$mn:00007E5B
.text$mn:00007E5C ; ===========================================================================
.text$mn:00007E5C
.text$mn:00007E5C ; Segment type: Pure code
.text$mn:00007E5C ; Segment permissions: Read/Execute
.text$mn:00007E5C _text$mn        segment para public 'CODE' use32
.text$mn:00007E5C                 assume cs:_text$mn
.text$mn:00007E5C                 ;org 7E5Ch
.text$mn:00007E5C ; COMDAT (pick any)
.text$mn:00007E5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E5C
.text$mn:00007E5C ; =============== S U B R O U T I N E =======================================
.text$mn:00007E5C
.text$mn:00007E5C ; Attributes: bp-based frame
.text$mn:00007E5C
.text$mn:00007E5C ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Destroy(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)
.text$mn:00007E5C                 public ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:00007E5C ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$mn:00007E5C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+CBp
.text$mn:00007E5C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Tidy(void)+2Bp
.text$mn:00007E5C
.text$mn:00007E5C var_8           = dword ptr -8
.text$mn:00007E5C var_1           = byte ptr -1
.text$mn:00007E5C arg_0           = dword ptr  8
.text$mn:00007E5C arg_4           = dword ptr  0Ch
.text$mn:00007E5C
.text$mn:00007E5C                 push    ebp
.text$mn:00007E5D                 mov     ebp, esp
.text$mn:00007E5F                 sub     esp, 8
.text$mn:00007E62                 mov     [ebp+var_8], ecx
.text$mn:00007E65                 lea     eax, [ebp+var_1]
.text$mn:00007E68                 push    eax
.text$mn:00007E69                 mov     ecx, [ebp+var_8]
.text$mn:00007E6C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:00007E71                 lea     ecx, [ebp+var_1]
.text$mn:00007E74                 push    ecx
.text$mn:00007E75                 mov     edx, [ebp+arg_4]
.text$mn:00007E78                 push    edx
.text$mn:00007E79                 mov     eax, [ebp+arg_0]
.text$mn:00007E7C                 push    eax
.text$mn:00007E7D                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)
.text$mn:00007E82                 add     esp, 0Ch
.text$mn:00007E85                 mov     esp, ebp
.text$mn:00007E87                 pop     ebp
.text$mn:00007E88                 retn    8
.text$mn:00007E88 ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$mn:00007E88
.text$mn:00007E88 ; ---------------------------------------------------------------------------
.text$mn:00007E8B                 align 4
.text$mn:00007E8B _text$mn        ends
.text$mn:00007E8B
.text$mn:00007E8C ; ===========================================================================
.text$mn:00007E8C
.text$mn:00007E8C ; Segment type: Pure code
.text$mn:00007E8C ; Segment permissions: Read/Execute
.text$mn:00007E8C _text$mn        segment para public 'CODE' use32
.text$mn:00007E8C                 assume cs:_text$mn
.text$mn:00007E8C                 ;org 7E8Ch
.text$mn:00007E8C ; COMDAT (pick any)
.text$mn:00007E8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007E8C
.text$mn:00007E8C ; =============== S U B R O U T I N E =======================================
.text$mn:00007E8C
.text$mn:00007E8C ; Attributes: bp-based frame
.text$mn:00007E8C
.text$mn:00007E8C ; protected: void __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::_Destroy(class PluginCmdShortcut *, class PluginCmdShortcut *)
.text$mn:00007E8C                 public ?_Destroy@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXPAVPluginCmdShortcut@@0@Z
.text$mn:00007E8C ?_Destroy@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXPAVPluginCmdShortcut@@0@Z proc near
.text$mn:00007E8C                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reallocate(uint)+CBp
.text$mn:00007E8C
.text$mn:00007E8C var_8           = dword ptr -8
.text$mn:00007E8C var_1           = byte ptr -1
.text$mn:00007E8C arg_0           = dword ptr  8
.text$mn:00007E8C arg_4           = dword ptr  0Ch
.text$mn:00007E8C
.text$mn:00007E8C                 push    ebp
.text$mn:00007E8D                 mov     ebp, esp
.text$mn:00007E8F                 sub     esp, 8
.text$mn:00007E92                 mov     [ebp+var_8], ecx
.text$mn:00007E95                 lea     eax, [ebp+var_1]
.text$mn:00007E98                 push    eax
.text$mn:00007E99                 mov     ecx, [ebp+var_8]
.text$mn:00007E9C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>>::_Getal(void)
.text$mn:00007EA1                 lea     ecx, [ebp+var_1]
.text$mn:00007EA4                 push    ecx
.text$mn:00007EA5                 mov     edx, [ebp+arg_4]
.text$mn:00007EA8                 push    edx
.text$mn:00007EA9                 mov     eax, [ebp+arg_0]
.text$mn:00007EAC                 push    eax
.text$mn:00007EAD                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@YAXPAVPluginCmdShortcut@@0AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>>(PluginCmdShortcut *,PluginCmdShortcut *,std::_Wrap_alloc<std::allocator<PluginCmdShortcut>> &)
.text$mn:00007EB2                 add     esp, 0Ch
.text$mn:00007EB5                 mov     esp, ebp
.text$mn:00007EB7                 pop     ebp
.text$mn:00007EB8                 retn    8
.text$mn:00007EB8 ?_Destroy@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXPAVPluginCmdShortcut@@0@Z endp
.text$mn:00007EB8
.text$mn:00007EB8 ; ---------------------------------------------------------------------------
.text$mn:00007EBB                 align 4
.text$mn:00007EBB _text$mn        ends
.text$mn:00007EBB
.text$mn:00007EBC ; ===========================================================================
.text$mn:00007EBC
.text$mn:00007EBC ; Segment type: Pure code
.text$mn:00007EBC ; Segment permissions: Read/Execute
.text$mn:00007EBC _text$mn        segment para public 'CODE' use32
.text$mn:00007EBC                 assume cs:_text$mn
.text$mn:00007EBC                 ;org 7EBCh
.text$mn:00007EBC ; COMDAT (pick any)
.text$mn:00007EBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007EBC
.text$mn:00007EBC ; =============== S U B R O U T I N E =======================================
.text$mn:00007EBC
.text$mn:00007EBC ; Attributes: bp-based frame
.text$mn:00007EBC
.text$mn:00007EBC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00007EBC                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00007EBC ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00007EBC                                         ; CODE XREF: $LN19+60p
.text$mn:00007EBC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00007EBC
.text$mn:00007EBC var_8           = dword ptr -8
.text$mn:00007EBC var_1           = byte ptr -1
.text$mn:00007EBC arg_0           = dword ptr  8
.text$mn:00007EBC
.text$mn:00007EBC                 push    ebp
.text$mn:00007EBD                 mov     ebp, esp
.text$mn:00007EBF                 sub     esp, 8
.text$mn:00007EC2                 mov     [ebp+var_8], ecx
.text$mn:00007EC5                 mov     [ebp+var_1], 0
.text$mn:00007EC9                 mov     eax, [ebp+var_8]
.text$mn:00007ECC                 mov     ecx, [ebp+arg_0]
.text$mn:00007ECF                 mov     [eax+14h], ecx
.text$mn:00007ED2                 lea     edx, [ebp+var_1]
.text$mn:00007ED5                 push    edx
.text$mn:00007ED6                 mov     ecx, [ebp+var_8]
.text$mn:00007ED9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007EDE                 add     eax, [ebp+arg_0]
.text$mn:00007EE1                 push    eax
.text$mn:00007EE2                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00007EE7                 add     esp, 8
.text$mn:00007EEA                 mov     esp, ebp
.text$mn:00007EEC                 pop     ebp
.text$mn:00007EED                 retn    4
.text$mn:00007EED ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00007EED
.text$mn:00007EED _text$mn        ends
.text$mn:00007EED
.text$mn:00007EF0 ; ===========================================================================
.text$mn:00007EF0
.text$mn:00007EF0 ; Segment type: Pure code
.text$mn:00007EF0 ; Segment permissions: Read/Execute
.text$mn:00007EF0 _text$mn        segment para public 'CODE' use32
.text$mn:00007EF0                 assume cs:_text$mn
.text$mn:00007EF0                 ;org 7EF0h
.text$mn:00007EF0 ; COMDAT (pick any)
.text$mn:00007EF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007EF0
.text$mn:00007EF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EF0
.text$mn:00007EF0 ; Attributes: bp-based frame
.text$mn:00007EF0
.text$mn:00007EF0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00007EF0                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00007EF0 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00007EF0                                         ; CODE XREF: $LN19_0+60p
.text$mn:00007EF0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00007EF0
.text$mn:00007EF0 var_8           = dword ptr -8
.text$mn:00007EF0 var_2           = word ptr -2
.text$mn:00007EF0 arg_0           = dword ptr  8
.text$mn:00007EF0
.text$mn:00007EF0                 push    ebp
.text$mn:00007EF1                 mov     ebp, esp
.text$mn:00007EF3                 sub     esp, 8
.text$mn:00007EF6                 mov     [ebp+var_8], ecx
.text$mn:00007EF9                 xor     eax, eax
.text$mn:00007EFB                 mov     [ebp+var_2], ax
.text$mn:00007EFF                 mov     ecx, [ebp+var_8]
.text$mn:00007F02                 mov     edx, [ebp+arg_0]
.text$mn:00007F05                 mov     [ecx+14h], edx
.text$mn:00007F08                 lea     eax, [ebp+var_2]
.text$mn:00007F0B                 push    eax
.text$mn:00007F0C                 mov     ecx, [ebp+var_8]
.text$mn:00007F0F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007F14                 mov     ecx, [ebp+arg_0]
.text$mn:00007F17                 lea     edx, [eax+ecx*2]
.text$mn:00007F1A                 push    edx
.text$mn:00007F1B                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00007F20                 add     esp, 8
.text$mn:00007F23                 mov     esp, ebp
.text$mn:00007F25                 pop     ebp
.text$mn:00007F26                 retn    4
.text$mn:00007F26 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00007F26
.text$mn:00007F26 ; ---------------------------------------------------------------------------
.text$mn:00007F29                 align 4
.text$mn:00007F29 _text$mn        ends
.text$mn:00007F29
.text$mn:00007F2C ; ===========================================================================
.text$mn:00007F2C
.text$mn:00007F2C ; Segment type: Pure code
.text$mn:00007F2C ; Segment permissions: Read/Execute
.text$mn:00007F2C _text$mn        segment para public 'CODE' use32
.text$mn:00007F2C                 assume cs:_text$mn
.text$mn:00007F2C                 ;org 7F2Ch
.text$mn:00007F2C ; COMDAT (pick any)
.text$mn:00007F2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007F2C
.text$mn:00007F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00007F2C
.text$mn:00007F2C ; Attributes: bp-based frame
.text$mn:00007F2C
.text$mn:00007F2C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00007F2C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00007F2C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007F2C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00007F2C
.text$mn:00007F2C var_8           = dword ptr -8
.text$mn:00007F2C var_1           = byte ptr -1
.text$mn:00007F2C
.text$mn:00007F2C                 push    ebp
.text$mn:00007F2D                 mov     ebp, esp
.text$mn:00007F2F                 sub     esp, 8
.text$mn:00007F32                 mov     [ebp+var_8], ecx
.text$mn:00007F35                 lea     ecx, [ebp+var_1]
.text$mn:00007F38                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00007F3D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007F40                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007F45                 mov     eax, [ebp+var_8]
.text$mn:00007F48                 mov     ecx, [eax]
.text$mn:00007F4A                 push    ecx
.text$mn:00007F4B                 lea     ecx, [ebp+var_1]
.text$mn:00007F4E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00007F53                 push    1               ; int
.text$mn:00007F55                 mov     edx, [ebp+var_8]
.text$mn:00007F58                 mov     eax, [edx]
.text$mn:00007F5A                 push    eax             ; void *
.text$mn:00007F5B                 lea     ecx, [ebp+var_1]
.text$mn:00007F5E                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00007F63                 mov     ecx, [ebp+var_8]
.text$mn:00007F66                 mov     dword ptr [ecx], 0
.text$mn:00007F6C                 mov     esp, ebp
.text$mn:00007F6E                 pop     ebp
.text$mn:00007F6F                 retn
.text$mn:00007F6F ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007F6F
.text$mn:00007F6F _text$mn        ends
.text$mn:00007F6F
.text$mn:00007F70 ; ===========================================================================
.text$mn:00007F70
.text$mn:00007F70 ; Segment type: Pure code
.text$mn:00007F70 ; Segment permissions: Read/Execute
.text$mn:00007F70 _text$mn        segment para public 'CODE' use32
.text$mn:00007F70                 assume cs:_text$mn
.text$mn:00007F70                 ;org 7F70h
.text$mn:00007F70 ; COMDAT (pick any)
.text$mn:00007F70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007F70
.text$mn:00007F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F70
.text$mn:00007F70 ; Attributes: bp-based frame
.text$mn:00007F70
.text$mn:00007F70 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00007F70                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00007F70 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007F70                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00007F70
.text$mn:00007F70 var_8           = dword ptr -8
.text$mn:00007F70 var_1           = byte ptr -1
.text$mn:00007F70
.text$mn:00007F70                 push    ebp
.text$mn:00007F71                 mov     ebp, esp
.text$mn:00007F73                 sub     esp, 8
.text$mn:00007F76                 mov     [ebp+var_8], ecx
.text$mn:00007F79                 lea     ecx, [ebp+var_1]
.text$mn:00007F7C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00007F81                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007F84                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007F89                 mov     eax, [ebp+var_8]
.text$mn:00007F8C                 mov     ecx, [eax]
.text$mn:00007F8E                 push    ecx
.text$mn:00007F8F                 lea     ecx, [ebp+var_1]
.text$mn:00007F92                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00007F97                 push    1               ; int
.text$mn:00007F99                 mov     edx, [ebp+var_8]
.text$mn:00007F9C                 mov     eax, [edx]
.text$mn:00007F9E                 push    eax             ; void *
.text$mn:00007F9F                 lea     ecx, [ebp+var_1]
.text$mn:00007FA2                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00007FA7                 mov     ecx, [ebp+var_8]
.text$mn:00007FAA                 mov     dword ptr [ecx], 0
.text$mn:00007FB0                 mov     esp, ebp
.text$mn:00007FB2                 pop     ebp
.text$mn:00007FB3                 retn
.text$mn:00007FB3 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007FB3
.text$mn:00007FB3 _text$mn        ends
.text$mn:00007FB3
.text$mn:00007FB4 ; ===========================================================================
.text$mn:00007FB4
.text$mn:00007FB4 ; Segment type: Pure code
.text$mn:00007FB4 ; Segment permissions: Read/Execute
.text$mn:00007FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00007FB4                 assume cs:_text$mn
.text$mn:00007FB4                 ;org 7FB4h
.text$mn:00007FB4 ; COMDAT (pick any)
.text$mn:00007FB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007FB4
.text$mn:00007FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FB4
.text$mn:00007FB4 ; Attributes: bp-based frame
.text$mn:00007FB4
.text$mn:00007FB4 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Free_proxy(void)
.text$mn:00007FB4                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ
.text$mn:00007FB4 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:00007FB4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>(void)+30p
.text$mn:00007FB4
.text$mn:00007FB4 var_8           = dword ptr -8
.text$mn:00007FB4 var_1           = byte ptr -1
.text$mn:00007FB4
.text$mn:00007FB4                 push    ebp
.text$mn:00007FB5                 mov     ebp, esp
.text$mn:00007FB7                 sub     esp, 8
.text$mn:00007FBA                 mov     [ebp+var_8], ecx
.text$mn:00007FBD                 lea     ecx, [ebp+var_1]
.text$mn:00007FC0                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00007FC5                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007FC8                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007FCD                 mov     eax, [ebp+var_8]
.text$mn:00007FD0                 mov     ecx, [eax]
.text$mn:00007FD2                 push    ecx
.text$mn:00007FD3                 lea     ecx, [ebp+var_1]
.text$mn:00007FD6                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00007FDB                 push    1               ; int
.text$mn:00007FDD                 mov     edx, [ebp+var_8]
.text$mn:00007FE0                 mov     eax, [edx]
.text$mn:00007FE2                 push    eax             ; void *
.text$mn:00007FE3                 lea     ecx, [ebp+var_1]
.text$mn:00007FE6                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00007FEB                 mov     ecx, [ebp+var_8]
.text$mn:00007FEE                 mov     dword ptr [ecx], 0
.text$mn:00007FF4                 mov     esp, ebp
.text$mn:00007FF6                 pop     ebp
.text$mn:00007FF7                 retn
.text$mn:00007FF7 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:00007FF7
.text$mn:00007FF7 _text$mn        ends
.text$mn:00007FF7
.text$mn:00007FF8 ; ===========================================================================
.text$mn:00007FF8
.text$mn:00007FF8 ; Segment type: Pure code
.text$mn:00007FF8 ; Segment permissions: Read/Execute
.text$mn:00007FF8 _text$mn        segment para public 'CODE' use32
.text$mn:00007FF8                 assume cs:_text$mn
.text$mn:00007FF8                 ;org 7FF8h
.text$mn:00007FF8 ; COMDAT (pick any)
.text$mn:00007FF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007FF8
.text$mn:00007FF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FF8
.text$mn:00007FF8 ; Attributes: bp-based frame
.text$mn:00007FF8
.text$mn:00007FF8 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00007FF8                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00007FF8 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00007FF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00007FF8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00007FF8
.text$mn:00007FF8 var_4           = dword ptr -4
.text$mn:00007FF8 arg_0           = dword ptr  8
.text$mn:00007FF8
.text$mn:00007FF8                 push    ebp
.text$mn:00007FF9                 mov     ebp, esp
.text$mn:00007FFB                 push    ecx
.text$mn:00007FFC                 mov     [ebp+var_4], ecx
.text$mn:00007FFF                 mov     ecx, [ebp+arg_0]
.text$mn:00008002                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00008007                 mov     eax, [ebp+arg_0]
.text$mn:0000800A                 mov     esp, ebp
.text$mn:0000800C                 pop     ebp
.text$mn:0000800D                 retn    4
.text$mn:0000800D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:0000800D
.text$mn:0000800D _text$mn        ends
.text$mn:0000800D
.text$mn:00008010 ; ===========================================================================
.text$mn:00008010
.text$mn:00008010 ; Segment type: Pure code
.text$mn:00008010 ; Segment permissions: Read/Execute
.text$mn:00008010 _text$mn        segment para public 'CODE' use32
.text$mn:00008010                 assume cs:_text$mn
.text$mn:00008010                 ;org 8010h
.text$mn:00008010 ; COMDAT (pick any)
.text$mn:00008010                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008010
.text$mn:00008010 ; =============== S U B R O U T I N E =======================================
.text$mn:00008010
.text$mn:00008010 ; Attributes: bp-based frame
.text$mn:00008010
.text$mn:00008010 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00008010                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00008010 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00008010                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Fp
.text$mn:00008010                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p ...
.text$mn:00008010
.text$mn:00008010 var_4           = dword ptr -4
.text$mn:00008010 arg_0           = dword ptr  8
.text$mn:00008010
.text$mn:00008010                 push    ebp
.text$mn:00008011                 mov     ebp, esp
.text$mn:00008013                 push    ecx
.text$mn:00008014                 mov     [ebp+var_4], ecx
.text$mn:00008017                 mov     ecx, [ebp+arg_0]
.text$mn:0000801A                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:0000801F                 mov     eax, [ebp+arg_0]
.text$mn:00008022                 mov     esp, ebp
.text$mn:00008024                 pop     ebp
.text$mn:00008025                 retn    4
.text$mn:00008025 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00008025
.text$mn:00008025 _text$mn        ends
.text$mn:00008025
.text$mn:00008028 ; ===========================================================================
.text$mn:00008028
.text$mn:00008028 ; Segment type: Pure code
.text$mn:00008028 ; Segment permissions: Read/Execute
.text$mn:00008028 _text$mn        segment para public 'CODE' use32
.text$mn:00008028                 assume cs:_text$mn
.text$mn:00008028                 ;org 8028h
.text$mn:00008028 ; COMDAT (pick any)
.text$mn:00008028                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008028
.text$mn:00008028 ; =============== S U B R O U T I N E =======================================
.text$mn:00008028
.text$mn:00008028 ; Attributes: bp-based frame
.text$mn:00008028
.text$mn:00008028 ; public: struct std::_Wrap_alloc<class std::allocator<struct PluginInfo *>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct PluginInfo *, class std::allocator<struct PluginInfo *>>>::_Getal(void)const
.text$mn:00008028                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ
.text$mn:00008028 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ proc near
.text$mn:00008028                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Umove<PluginInfo * *>(PluginInfo * *,PluginInfo * *,PluginInfo * *)+10p
.text$mn:00008028                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Destroy(PluginInfo * *,PluginInfo * *)+10p ...
.text$mn:00008028
.text$mn:00008028 var_4           = dword ptr -4
.text$mn:00008028 arg_0           = dword ptr  8
.text$mn:00008028
.text$mn:00008028                 push    ebp
.text$mn:00008029                 mov     ebp, esp
.text$mn:0000802B                 push    ecx
.text$mn:0000802C                 mov     [ebp+var_4], ecx
.text$mn:0000802F                 mov     ecx, [ebp+arg_0]
.text$mn:00008032                 call    ??0?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<PluginInfo *>>::_Wrap_alloc<std::allocator<PluginInfo *>>(void)
.text$mn:00008037                 mov     eax, [ebp+arg_0]
.text$mn:0000803A                 mov     esp, ebp
.text$mn:0000803C                 pop     ebp
.text$mn:0000803D                 retn    4
.text$mn:0000803D ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ endp
.text$mn:0000803D
.text$mn:0000803D _text$mn        ends
.text$mn:0000803D
.text$mn:00008040 ; ===========================================================================
.text$mn:00008040
.text$mn:00008040 ; Segment type: Pure code
.text$mn:00008040 ; Segment permissions: Read/Execute
.text$mn:00008040 _text$mn        segment para public 'CODE' use32
.text$mn:00008040                 assume cs:_text$mn
.text$mn:00008040                 ;org 8040h
.text$mn:00008040 ; COMDAT (pick any)
.text$mn:00008040                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008040
.text$mn:00008040 ; =============== S U B R O U T I N E =======================================
.text$mn:00008040
.text$mn:00008040 ; Attributes: bp-based frame
.text$mn:00008040
.text$mn:00008040 ; public: struct std::_Wrap_alloc<class std::allocator<class TiXmlDocument *>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>>::_Getal(void)const
.text$mn:00008040                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ
.text$mn:00008040 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ proc near
.text$mn:00008040                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Umove<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *)+10p
.text$mn:00008040                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Destroy(TiXmlDocument * *,TiXmlDocument * *)+10p ...
.text$mn:00008040
.text$mn:00008040 var_4           = dword ptr -4
.text$mn:00008040 arg_0           = dword ptr  8
.text$mn:00008040
.text$mn:00008040                 push    ebp
.text$mn:00008041                 mov     ebp, esp
.text$mn:00008043                 push    ecx
.text$mn:00008044                 mov     [ebp+var_4], ecx
.text$mn:00008047                 mov     ecx, [ebp+arg_0]
.text$mn:0000804A                 call    ??0?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::_Wrap_alloc<std::allocator<TiXmlDocument *>>(void)
.text$mn:0000804F                 mov     eax, [ebp+arg_0]
.text$mn:00008052                 mov     esp, ebp
.text$mn:00008054                 pop     ebp
.text$mn:00008055                 retn    4
.text$mn:00008055 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ endp
.text$mn:00008055
.text$mn:00008055 _text$mn        ends
.text$mn:00008055
.text$mn:00008058 ; ===========================================================================
.text$mn:00008058
.text$mn:00008058 ; Segment type: Pure code
.text$mn:00008058 ; Segment permissions: Read/Execute
.text$mn:00008058 _text$mn        segment para public 'CODE' use32
.text$mn:00008058                 assume cs:_text$mn
.text$mn:00008058                 ;org 8058h
.text$mn:00008058 ; COMDAT (pick any)
.text$mn:00008058                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008058
.text$mn:00008058 ; =============== S U B R O U T I N E =======================================
.text$mn:00008058
.text$mn:00008058 ; Attributes: bp-based frame
.text$mn:00008058
.text$mn:00008058 ; public: struct std::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>>::_Getal(void)const
.text$mn:00008058                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ
.text$mn:00008058 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ proc near
.text$mn:00008058                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Umove<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+10p
.text$mn:00008058                                         ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Destroy(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+10p ...
.text$mn:00008058
.text$mn:00008058 var_4           = dword ptr -4
.text$mn:00008058 arg_0           = dword ptr  8
.text$mn:00008058
.text$mn:00008058                 push    ebp
.text$mn:00008059                 mov     ebp, esp
.text$mn:0000805B                 push    ecx
.text$mn:0000805C                 mov     [ebp+var_4], ecx
.text$mn:0000805F                 mov     ecx, [ebp+arg_0]
.text$mn:00008062                 call    ??0?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>(void)
.text$mn:00008067                 mov     eax, [ebp+arg_0]
.text$mn:0000806A                 mov     esp, ebp
.text$mn:0000806C                 pop     ebp
.text$mn:0000806D                 retn    4
.text$mn:0000806D ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ endp
.text$mn:0000806D
.text$mn:0000806D _text$mn        ends
.text$mn:0000806D
.text$mn:00008070 ; ===========================================================================
.text$mn:00008070
.text$mn:00008070 ; Segment type: Pure code
.text$mn:00008070 ; Segment permissions: Read/Execute
.text$mn:00008070 _text$mn        segment para public 'CODE' use32
.text$mn:00008070                 assume cs:_text$mn
.text$mn:00008070                 ;org 8070h
.text$mn:00008070 ; COMDAT (pick any)
.text$mn:00008070                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008070
.text$mn:00008070 ; =============== S U B R O U T I N E =======================================
.text$mn:00008070
.text$mn:00008070 ; Attributes: bp-based frame
.text$mn:00008070
.text$mn:00008070 ; public: struct std::_Wrap_alloc<class std::allocator<struct PluginCommand>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct PluginCommand, class std::allocator<struct PluginCommand>>>::_Getal(void)const
.text$mn:00008070                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ
.text$mn:00008070 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ proc near
.text$mn:00008070                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Umove<PluginCommand *>(PluginCommand *,PluginCommand *,PluginCommand *)+10p
.text$mn:00008070                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Destroy(PluginCommand *,PluginCommand *)+10p ...
.text$mn:00008070
.text$mn:00008070 var_4           = dword ptr -4
.text$mn:00008070 arg_0           = dword ptr  8
.text$mn:00008070
.text$mn:00008070                 push    ebp
.text$mn:00008071                 mov     ebp, esp
.text$mn:00008073                 push    ecx
.text$mn:00008074                 mov     [ebp+var_4], ecx
.text$mn:00008077                 mov     ecx, [ebp+arg_0]
.text$mn:0000807A                 call    ??0?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<PluginCommand>>::_Wrap_alloc<std::allocator<PluginCommand>>(void)
.text$mn:0000807F                 mov     eax, [ebp+arg_0]
.text$mn:00008082                 mov     esp, ebp
.text$mn:00008084                 pop     ebp
.text$mn:00008085                 retn    4
.text$mn:00008085 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ endp
.text$mn:00008085
.text$mn:00008085 _text$mn        ends
.text$mn:00008085
.text$mn:00008088 ; ===========================================================================
.text$mn:00008088
.text$mn:00008088 ; Segment type: Pure code
.text$mn:00008088 ; Segment permissions: Read/Execute
.text$mn:00008088 _text$mn        segment para public 'CODE' use32
.text$mn:00008088                 assume cs:_text$mn
.text$mn:00008088                 ;org 8088h
.text$mn:00008088 ; COMDAT (pick any)
.text$mn:00008088                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008088
.text$mn:00008088 ; =============== S U B R O U T I N E =======================================
.text$mn:00008088
.text$mn:00008088 ; Attributes: bp-based frame
.text$mn:00008088
.text$mn:00008088 ; public: struct std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>>::_Getal(void)const
.text$mn:00008088                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
.text$mn:00008088 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ proc near
.text$mn:00008088                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+10p
.text$mn:00008088                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+10p ...
.text$mn:00008088
.text$mn:00008088 var_4           = dword ptr -4
.text$mn:00008088 arg_0           = dword ptr  8
.text$mn:00008088
.text$mn:00008088                 push    ebp
.text$mn:00008089                 mov     ebp, esp
.text$mn:0000808B                 push    ecx
.text$mn:0000808C                 mov     [ebp+var_4], ecx
.text$mn:0000808F                 mov     ecx, [ebp+arg_0]
.text$mn:00008092                 call    ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)
.text$mn:00008097                 mov     eax, [ebp+arg_0]
.text$mn:0000809A                 mov     esp, ebp
.text$mn:0000809C                 pop     ebp
.text$mn:0000809D                 retn    4
.text$mn:0000809D ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ endp
.text$mn:0000809D
.text$mn:0000809D _text$mn        ends
.text$mn:0000809D
.text$mn:000080A0 ; ===========================================================================
.text$mn:000080A0
.text$mn:000080A0 ; Segment type: Pure code
.text$mn:000080A0 ; Segment permissions: Read/Execute
.text$mn:000080A0 _text$mn        segment para public 'CODE' use32
.text$mn:000080A0                 assume cs:_text$mn
.text$mn:000080A0                 ;org 80A0h
.text$mn:000080A0 ; COMDAT (pick any)
.text$mn:000080A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000080A0
.text$mn:000080A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000080A0
.text$mn:000080A0 ; Attributes: bp-based frame
.text$mn:000080A0
.text$mn:000080A0 ; public: struct std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>>::_Getal(void)const
.text$mn:000080A0                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ
.text$mn:000080A0 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ proc near
.text$mn:000080A0                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Umove<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *)+10p
.text$mn:000080A0                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Destroy(PluginCmdShortcut *,PluginCmdShortcut *)+10p ...
.text$mn:000080A0
.text$mn:000080A0 var_4           = dword ptr -4
.text$mn:000080A0 arg_0           = dword ptr  8
.text$mn:000080A0
.text$mn:000080A0                 push    ebp
.text$mn:000080A1                 mov     ebp, esp
.text$mn:000080A3                 push    ecx
.text$mn:000080A4                 mov     [ebp+var_4], ecx
.text$mn:000080A7                 mov     ecx, [ebp+arg_0]
.text$mn:000080AA                 call    ??0?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::_Wrap_alloc<std::allocator<PluginCmdShortcut>>(void)
.text$mn:000080AF                 mov     eax, [ebp+arg_0]
.text$mn:000080B2                 mov     esp, ebp
.text$mn:000080B4                 pop     ebp
.text$mn:000080B5                 retn    4
.text$mn:000080B5 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ endp
.text$mn:000080B5
.text$mn:000080B5 _text$mn        ends
.text$mn:000080B5
.text$mn:000080B8 ; ===========================================================================
.text$mn:000080B8
.text$mn:000080B8 ; Segment type: Pure code
.text$mn:000080B8 ; Segment permissions: Read/Execute
.text$mn:000080B8 _text$mn        segment para public 'CODE' use32
.text$mn:000080B8                 assume cs:_text$mn
.text$mn:000080B8                 ;org 80B8h
.text$mn:000080B8 ; COMDAT (pick any)
.text$mn:000080B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000080B8
.text$mn:000080B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000080B8
.text$mn:000080B8 ; Attributes: bp-based frame
.text$mn:000080B8
.text$mn:000080B8 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:000080B8                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:000080B8 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:000080B8                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+3Cp
.text$mn:000080B8                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *)+3Cp ...
.text$mn:000080B8
.text$mn:000080B8 var_8           = dword ptr -8
.text$mn:000080B8 var_4           = dword ptr -4
.text$mn:000080B8
.text$mn:000080B8                 push    ebp
.text$mn:000080B9                 mov     ebp, esp
.text$mn:000080BB                 sub     esp, 8
.text$mn:000080BE                 mov     [ebp+var_4], ecx
.text$mn:000080C1                 mov     eax, [ebp+var_4]
.text$mn:000080C4                 cmp     dword ptr [eax], 0
.text$mn:000080C7                 jnz     short loc_80D2
.text$mn:000080C9                 mov     [ebp+var_8], 0
.text$mn:000080D0                 jmp     short loc_80DD
.text$mn:000080D2 ; ---------------------------------------------------------------------------
.text$mn:000080D2
.text$mn:000080D2 loc_80D2:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:000080D2                 mov     ecx, [ebp+var_4]
.text$mn:000080D5                 mov     edx, [ecx]
.text$mn:000080D7                 add     edx, 4
.text$mn:000080DA                 mov     [ebp+var_8], edx
.text$mn:000080DD
.text$mn:000080DD loc_80DD:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:000080DD                 mov     eax, [ebp+var_8]
.text$mn:000080E0                 mov     esp, ebp
.text$mn:000080E2                 pop     ebp
.text$mn:000080E3                 retn
.text$mn:000080E3 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:000080E3
.text$mn:000080E3 _text$mn        ends
.text$mn:000080E3
.text$mn:000080E4 ; ===========================================================================
.text$mn:000080E4
.text$mn:000080E4 ; Segment type: Pure code
.text$mn:000080E4 ; Segment permissions: Read/Execute
.text$mn:000080E4 _text$mn        segment para public 'CODE' use32
.text$mn:000080E4                 assume cs:_text$mn
.text$mn:000080E4                 ;org 80E4h
.text$mn:000080E4 ; COMDAT (pick any)
.text$mn:000080E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000080E4
.text$mn:000080E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000080E4
.text$mn:000080E4 ; Attributes: bp-based frame
.text$mn:000080E4
.text$mn:000080E4 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:000080E4                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:000080E4 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:000080E4                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+71p
.text$mn:000080E4                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+8Ap ...
.text$mn:000080E4
.text$mn:000080E4 var_4           = dword ptr -4
.text$mn:000080E4
.text$mn:000080E4                 push    ebp
.text$mn:000080E5                 mov     ebp, esp
.text$mn:000080E7                 push    ecx
.text$mn:000080E8                 mov     [ebp+var_4], ecx
.text$mn:000080EB                 mov     eax, [ebp+var_4]
.text$mn:000080EE                 add     eax, 4
.text$mn:000080F1                 mov     esp, ebp
.text$mn:000080F3                 pop     ebp
.text$mn:000080F4                 retn
.text$mn:000080F4 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:000080F4
.text$mn:000080F4 ; ---------------------------------------------------------------------------
.text$mn:000080F5                 align 4
.text$mn:000080F5 _text$mn        ends
.text$mn:000080F5
.text$mn:000080F8 ; ===========================================================================
.text$mn:000080F8
.text$mn:000080F8 ; Segment type: Pure code
.text$mn:000080F8 ; Segment permissions: Read/Execute
.text$mn:000080F8 _text$mn        segment para public 'CODE' use32
.text$mn:000080F8                 assume cs:_text$mn
.text$mn:000080F8                 ;org 80F8h
.text$mn:000080F8 ; COMDAT (pick any)
.text$mn:000080F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000080F8
.text$mn:000080F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000080F8
.text$mn:000080F8 ; Attributes: bp-based frame
.text$mn:000080F8
.text$mn:000080F8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000080F8                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000080F8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000080F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000080F8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000080F8
.text$mn:000080F8 var_C           = dword ptr -0Ch
.text$mn:000080F8 Size            = dword ptr -8
.text$mn:000080F8 var_4           = dword ptr -4
.text$mn:000080F8 arg_0           = dword ptr  8
.text$mn:000080F8 arg_4           = byte ptr  0Ch
.text$mn:000080F8
.text$mn:000080F8                 push    ebp
.text$mn:000080F9                 mov     ebp, esp
.text$mn:000080FB                 sub     esp, 0Ch
.text$mn:000080FE                 mov     [ebp+var_4], ecx
.text$mn:00008101                 mov     ecx, [ebp+var_4]
.text$mn:00008104                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00008109                 cmp     eax, [ebp+arg_0]
.text$mn:0000810C                 jnb     short loc_8116
.text$mn:0000810E                 mov     ecx, [ebp+var_4]
.text$mn:00008111                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00008116
.text$mn:00008116 loc_8116:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00008116                 mov     eax, [ebp+var_4]
.text$mn:00008119                 mov     ecx, [eax+18h]
.text$mn:0000811C                 cmp     ecx, [ebp+arg_0]
.text$mn:0000811F                 jnb     short loc_8136
.text$mn:00008121                 mov     edx, [ebp+var_4]
.text$mn:00008124                 mov     eax, [edx+14h]
.text$mn:00008127                 push    eax
.text$mn:00008128                 mov     ecx, [ebp+arg_0]
.text$mn:0000812B                 push    ecx
.text$mn:0000812C                 mov     ecx, [ebp+var_4]
.text$mn:0000812F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00008134                 jmp     short loc_8180
.text$mn:00008136 ; ---------------------------------------------------------------------------
.text$mn:00008136
.text$mn:00008136 loc_8136:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00008136                 movzx   edx, [ebp+arg_4]
.text$mn:0000813A                 test    edx, edx
.text$mn:0000813C                 jz      short loc_8170
.text$mn:0000813E                 cmp     [ebp+arg_0], 10h
.text$mn:00008142                 jnb     short loc_8170
.text$mn:00008144                 mov     eax, [ebp+var_4]
.text$mn:00008147                 mov     ecx, [ebp+arg_0]
.text$mn:0000814A                 cmp     ecx, [eax+14h]
.text$mn:0000814D                 jnb     short loc_8157
.text$mn:0000814F                 mov     edx, [ebp+arg_0]
.text$mn:00008152                 mov     [ebp+Size], edx
.text$mn:00008155                 jmp     short loc_8160
.text$mn:00008157 ; ---------------------------------------------------------------------------
.text$mn:00008157
.text$mn:00008157 loc_8157:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00008157                 mov     eax, [ebp+var_4]
.text$mn:0000815A                 mov     ecx, [eax+14h]
.text$mn:0000815D                 mov     [ebp+Size], ecx
.text$mn:00008160
.text$mn:00008160 loc_8160:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00008160                 mov     edx, [ebp+Size]
.text$mn:00008163                 push    edx             ; Size
.text$mn:00008164                 push    1               ; char
.text$mn:00008166                 mov     ecx, [ebp+var_4]
.text$mn:00008169                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000816E                 jmp     short loc_8180
.text$mn:00008170 ; ---------------------------------------------------------------------------
.text$mn:00008170
.text$mn:00008170 loc_8170:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00008170                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00008170                 cmp     [ebp+arg_0], 0
.text$mn:00008174                 jnz     short loc_8180
.text$mn:00008176                 push    0
.text$mn:00008178                 mov     ecx, [ebp+var_4]
.text$mn:0000817B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00008180
.text$mn:00008180 loc_8180:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00008180                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00008180                 cmp     [ebp+arg_0], 0
.text$mn:00008184                 jbe     short loc_818F
.text$mn:00008186                 mov     [ebp+var_C], 1
.text$mn:0000818D                 jmp     short loc_8196
.text$mn:0000818F ; ---------------------------------------------------------------------------
.text$mn:0000818F
.text$mn:0000818F loc_818F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000818F                 mov     [ebp+var_C], 0
.text$mn:00008196
.text$mn:00008196 loc_8196:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00008196                 mov     al, byte ptr [ebp+var_C]
.text$mn:00008199                 mov     esp, ebp
.text$mn:0000819B                 pop     ebp
.text$mn:0000819C                 retn    8
.text$mn:0000819C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:0000819C
.text$mn:0000819C ; ---------------------------------------------------------------------------
.text$mn:0000819F                 align 10h
.text$mn:0000819F _text$mn        ends
.text$mn:0000819F
.text$mn:000081A0 ; ===========================================================================
.text$mn:000081A0
.text$mn:000081A0 ; Segment type: Pure code
.text$mn:000081A0 ; Segment permissions: Read/Execute
.text$mn:000081A0 _text$mn        segment para public 'CODE' use32
.text$mn:000081A0                 assume cs:_text$mn
.text$mn:000081A0                 ;org 81A0h
.text$mn:000081A0 ; COMDAT (pick any)
.text$mn:000081A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000081A0
.text$mn:000081A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000081A0
.text$mn:000081A0 ; Attributes: bp-based frame
.text$mn:000081A0
.text$mn:000081A0 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:000081A0                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:000081A0 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:000081A0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Dp
.text$mn:000081A0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+8Ep ...
.text$mn:000081A0
.text$mn:000081A0 var_C           = dword ptr -0Ch
.text$mn:000081A0 var_8           = dword ptr -8
.text$mn:000081A0 var_4           = dword ptr -4
.text$mn:000081A0 arg_0           = dword ptr  8
.text$mn:000081A0 arg_4           = byte ptr  0Ch
.text$mn:000081A0
.text$mn:000081A0                 push    ebp
.text$mn:000081A1                 mov     ebp, esp
.text$mn:000081A3                 sub     esp, 0Ch
.text$mn:000081A6                 mov     [ebp+var_4], ecx
.text$mn:000081A9                 mov     ecx, [ebp+var_4]
.text$mn:000081AC                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000081B1                 cmp     eax, [ebp+arg_0]
.text$mn:000081B4                 jnb     short loc_81BE
.text$mn:000081B6                 mov     ecx, [ebp+var_4]
.text$mn:000081B9                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000081BE
.text$mn:000081BE loc_81BE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:000081BE                 mov     eax, [ebp+var_4]
.text$mn:000081C1                 mov     ecx, [eax+18h]
.text$mn:000081C4                 cmp     ecx, [ebp+arg_0]
.text$mn:000081C7                 jnb     short loc_81DE
.text$mn:000081C9                 mov     edx, [ebp+var_4]
.text$mn:000081CC                 mov     eax, [edx+14h]
.text$mn:000081CF                 push    eax
.text$mn:000081D0                 mov     ecx, [ebp+arg_0]
.text$mn:000081D3                 push    ecx
.text$mn:000081D4                 mov     ecx, [ebp+var_4]
.text$mn:000081D7                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:000081DC                 jmp     short loc_8228
.text$mn:000081DE ; ---------------------------------------------------------------------------
.text$mn:000081DE
.text$mn:000081DE loc_81DE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:000081DE                 movzx   edx, [ebp+arg_4]
.text$mn:000081E2                 test    edx, edx
.text$mn:000081E4                 jz      short loc_8218
.text$mn:000081E6                 cmp     [ebp+arg_0], 8
.text$mn:000081EA                 jnb     short loc_8218
.text$mn:000081EC                 mov     eax, [ebp+var_4]
.text$mn:000081EF                 mov     ecx, [ebp+arg_0]
.text$mn:000081F2                 cmp     ecx, [eax+14h]
.text$mn:000081F5                 jnb     short loc_81FF
.text$mn:000081F7                 mov     edx, [ebp+arg_0]
.text$mn:000081FA                 mov     [ebp+var_8], edx
.text$mn:000081FD                 jmp     short loc_8208
.text$mn:000081FF ; ---------------------------------------------------------------------------
.text$mn:000081FF
.text$mn:000081FF loc_81FF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:000081FF                 mov     eax, [ebp+var_4]
.text$mn:00008202                 mov     ecx, [eax+14h]
.text$mn:00008205                 mov     [ebp+var_8], ecx
.text$mn:00008208
.text$mn:00008208 loc_8208:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00008208                 mov     edx, [ebp+var_8]
.text$mn:0000820B                 push    edx
.text$mn:0000820C                 push    1
.text$mn:0000820E                 mov     ecx, [ebp+var_4]
.text$mn:00008211                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00008216                 jmp     short loc_8228
.text$mn:00008218 ; ---------------------------------------------------------------------------
.text$mn:00008218
.text$mn:00008218 loc_8218:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00008218                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00008218                 cmp     [ebp+arg_0], 0
.text$mn:0000821C                 jnz     short loc_8228
.text$mn:0000821E                 push    0
.text$mn:00008220                 mov     ecx, [ebp+var_4]
.text$mn:00008223                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00008228
.text$mn:00008228 loc_8228:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00008228                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00008228                 cmp     [ebp+arg_0], 0
.text$mn:0000822C                 jbe     short loc_8237
.text$mn:0000822E                 mov     [ebp+var_C], 1
.text$mn:00008235                 jmp     short loc_823E
.text$mn:00008237 ; ---------------------------------------------------------------------------
.text$mn:00008237
.text$mn:00008237 loc_8237:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00008237                 mov     [ebp+var_C], 0
.text$mn:0000823E
.text$mn:0000823E loc_823E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:0000823E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00008241                 mov     esp, ebp
.text$mn:00008243                 pop     ebp
.text$mn:00008244                 retn    8
.text$mn:00008244 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00008244
.text$mn:00008244 ; ---------------------------------------------------------------------------
.text$mn:00008247                 align 4
.text$mn:00008247 _text$mn        ends
.text$mn:00008247
.text$mn:00008248 ; ===========================================================================
.text$mn:00008248
.text$mn:00008248 ; Segment type: Pure code
.text$mn:00008248 ; Segment permissions: Read/Execute
.text$mn:00008248 _text$mn        segment para public 'CODE' use32
.text$mn:00008248                 assume cs:_text$mn
.text$mn:00008248                 ;org 8248h
.text$mn:00008248 ; COMDAT (pick any)
.text$mn:00008248                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008248
.text$mn:00008248 ; =============== S U B R O U T I N E =======================================
.text$mn:00008248
.text$mn:00008248 ; Attributes: bp-based frame
.text$mn:00008248
.text$mn:00008248 ; protected: unsigned int __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::_Grow_to(unsigned int)const
.text$mn:00008248                 public ?_Grow_to@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEII@Z
.text$mn:00008248 ?_Grow_to@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEII@Z proc near
.text$mn:00008248                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reserve(uint)+45p
.text$mn:00008248
.text$mn:00008248 var_C           = dword ptr -0Ch
.text$mn:00008248 var_8           = dword ptr -8
.text$mn:00008248 var_4           = dword ptr -4
.text$mn:00008248 arg_0           = dword ptr  8
.text$mn:00008248
.text$mn:00008248                 push    ebp
.text$mn:00008249                 mov     ebp, esp
.text$mn:0000824B                 sub     esp, 0Ch
.text$mn:0000824E                 mov     [ebp+var_8], ecx
.text$mn:00008251                 mov     ecx, [ebp+var_8]
.text$mn:00008254                 call    ?capacity@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::capacity(void)
.text$mn:00008259                 mov     [ebp+var_4], eax
.text$mn:0000825C                 mov     ecx, [ebp+var_8]
.text$mn:0000825F                 call    ?max_size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::max_size(void)
.text$mn:00008264                 mov     ecx, [ebp+var_4]
.text$mn:00008267                 shr     ecx, 1
.text$mn:00008269                 sub     eax, ecx
.text$mn:0000826B                 cmp     eax, [ebp+var_4]
.text$mn:0000826E                 jnb     short loc_8279
.text$mn:00008270                 mov     [ebp+var_C], 0
.text$mn:00008277                 jmp     short loc_8284
.text$mn:00008279 ; ---------------------------------------------------------------------------
.text$mn:00008279
.text$mn:00008279 loc_8279:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Grow_to(uint)+26j
.text$mn:00008279                 mov     edx, [ebp+var_4]
.text$mn:0000827C                 shr     edx, 1
.text$mn:0000827E                 add     edx, [ebp+var_4]
.text$mn:00008281                 mov     [ebp+var_C], edx
.text$mn:00008284
.text$mn:00008284 loc_8284:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Grow_to(uint)+2Fj
.text$mn:00008284                 mov     eax, [ebp+var_C]
.text$mn:00008287                 mov     [ebp+var_4], eax
.text$mn:0000828A                 mov     ecx, [ebp+var_4]
.text$mn:0000828D                 cmp     ecx, [ebp+arg_0]
.text$mn:00008290                 jnb     short loc_8298
.text$mn:00008292                 mov     edx, [ebp+arg_0]
.text$mn:00008295                 mov     [ebp+var_4], edx
.text$mn:00008298
.text$mn:00008298 loc_8298:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Grow_to(uint)+48j
.text$mn:00008298                 mov     eax, [ebp+var_4]
.text$mn:0000829B                 mov     esp, ebp
.text$mn:0000829D                 pop     ebp
.text$mn:0000829E                 retn    4
.text$mn:0000829E ?_Grow_to@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEII@Z endp
.text$mn:0000829E
.text$mn:0000829E ; ---------------------------------------------------------------------------
.text$mn:000082A1                 align 4
.text$mn:000082A1 _text$mn        ends
.text$mn:000082A1
.text$mn:000082A4 ; ===========================================================================
.text$mn:000082A4
.text$mn:000082A4 ; Segment type: Pure code
.text$mn:000082A4 ; Segment permissions: Read/Execute
.text$mn:000082A4 _text$mn        segment para public 'CODE' use32
.text$mn:000082A4                 assume cs:_text$mn
.text$mn:000082A4                 ;org 82A4h
.text$mn:000082A4 ; COMDAT (pick any)
.text$mn:000082A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000082A4
.text$mn:000082A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000082A4
.text$mn:000082A4 ; Attributes: bp-based frame
.text$mn:000082A4
.text$mn:000082A4 ; protected: unsigned int __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::_Grow_to(unsigned int)const
.text$mn:000082A4                 public ?_Grow_to@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEII@Z
.text$mn:000082A4 ?_Grow_to@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEII@Z proc near
.text$mn:000082A4                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reserve(uint)+45p
.text$mn:000082A4
.text$mn:000082A4 var_C           = dword ptr -0Ch
.text$mn:000082A4 var_8           = dword ptr -8
.text$mn:000082A4 var_4           = dword ptr -4
.text$mn:000082A4 arg_0           = dword ptr  8
.text$mn:000082A4
.text$mn:000082A4                 push    ebp
.text$mn:000082A5                 mov     ebp, esp
.text$mn:000082A7                 sub     esp, 0Ch
.text$mn:000082AA                 mov     [ebp+var_8], ecx
.text$mn:000082AD                 mov     ecx, [ebp+var_8]
.text$mn:000082B0                 call    ?capacity@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::capacity(void)
.text$mn:000082B5                 mov     [ebp+var_4], eax
.text$mn:000082B8                 mov     ecx, [ebp+var_8]
.text$mn:000082BB                 call    ?max_size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::max_size(void)
.text$mn:000082C0                 mov     ecx, [ebp+var_4]
.text$mn:000082C3                 shr     ecx, 1
.text$mn:000082C5                 sub     eax, ecx
.text$mn:000082C7                 cmp     eax, [ebp+var_4]
.text$mn:000082CA                 jnb     short loc_82D5
.text$mn:000082CC                 mov     [ebp+var_C], 0
.text$mn:000082D3                 jmp     short loc_82E0
.text$mn:000082D5 ; ---------------------------------------------------------------------------
.text$mn:000082D5
.text$mn:000082D5 loc_82D5:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Grow_to(uint)+26j
.text$mn:000082D5                 mov     edx, [ebp+var_4]
.text$mn:000082D8                 shr     edx, 1
.text$mn:000082DA                 add     edx, [ebp+var_4]
.text$mn:000082DD                 mov     [ebp+var_C], edx
.text$mn:000082E0
.text$mn:000082E0 loc_82E0:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Grow_to(uint)+2Fj
.text$mn:000082E0                 mov     eax, [ebp+var_C]
.text$mn:000082E3                 mov     [ebp+var_4], eax
.text$mn:000082E6                 mov     ecx, [ebp+var_4]
.text$mn:000082E9                 cmp     ecx, [ebp+arg_0]
.text$mn:000082EC                 jnb     short loc_82F4
.text$mn:000082EE                 mov     edx, [ebp+arg_0]
.text$mn:000082F1                 mov     [ebp+var_4], edx
.text$mn:000082F4
.text$mn:000082F4 loc_82F4:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Grow_to(uint)+48j
.text$mn:000082F4                 mov     eax, [ebp+var_4]
.text$mn:000082F7                 mov     esp, ebp
.text$mn:000082F9                 pop     ebp
.text$mn:000082FA                 retn    4
.text$mn:000082FA ?_Grow_to@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEII@Z endp
.text$mn:000082FA
.text$mn:000082FA ; ---------------------------------------------------------------------------
.text$mn:000082FD                 align 10h
.text$mn:000082FD _text$mn        ends
.text$mn:000082FD
.text$mn:00008300 ; ===========================================================================
.text$mn:00008300
.text$mn:00008300 ; Segment type: Pure code
.text$mn:00008300 ; Segment permissions: Read/Execute
.text$mn:00008300 _text$mn        segment para public 'CODE' use32
.text$mn:00008300                 assume cs:_text$mn
.text$mn:00008300                 ;org 8300h
.text$mn:00008300 ; COMDAT (pick any)
.text$mn:00008300                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008300
.text$mn:00008300 ; =============== S U B R O U T I N E =======================================
.text$mn:00008300
.text$mn:00008300 ; Attributes: bp-based frame
.text$mn:00008300
.text$mn:00008300 ; protected: unsigned int __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::_Grow_to(unsigned int)const
.text$mn:00008300                 public ?_Grow_to@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEII@Z
.text$mn:00008300 ?_Grow_to@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEII@Z proc near
.text$mn:00008300                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reserve(uint)+45p
.text$mn:00008300
.text$mn:00008300 var_C           = dword ptr -0Ch
.text$mn:00008300 var_8           = dword ptr -8
.text$mn:00008300 var_4           = dword ptr -4
.text$mn:00008300 arg_0           = dword ptr  8
.text$mn:00008300
.text$mn:00008300                 push    ebp
.text$mn:00008301                 mov     ebp, esp
.text$mn:00008303                 sub     esp, 0Ch
.text$mn:00008306                 mov     [ebp+var_8], ecx
.text$mn:00008309                 mov     ecx, [ebp+var_8]
.text$mn:0000830C                 call    ?capacity@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::capacity(void)
.text$mn:00008311                 mov     [ebp+var_4], eax
.text$mn:00008314                 mov     ecx, [ebp+var_8]
.text$mn:00008317                 call    ?max_size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::max_size(void)
.text$mn:0000831C                 mov     ecx, [ebp+var_4]
.text$mn:0000831F                 shr     ecx, 1
.text$mn:00008321                 sub     eax, ecx
.text$mn:00008323                 cmp     eax, [ebp+var_4]
.text$mn:00008326                 jnb     short loc_8331
.text$mn:00008328                 mov     [ebp+var_C], 0
.text$mn:0000832F                 jmp     short loc_833C
.text$mn:00008331 ; ---------------------------------------------------------------------------
.text$mn:00008331
.text$mn:00008331 loc_8331:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Grow_to(uint)+26j
.text$mn:00008331                 mov     edx, [ebp+var_4]
.text$mn:00008334                 shr     edx, 1
.text$mn:00008336                 add     edx, [ebp+var_4]
.text$mn:00008339                 mov     [ebp+var_C], edx
.text$mn:0000833C
.text$mn:0000833C loc_833C:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Grow_to(uint)+2Fj
.text$mn:0000833C                 mov     eax, [ebp+var_C]
.text$mn:0000833F                 mov     [ebp+var_4], eax
.text$mn:00008342                 mov     ecx, [ebp+var_4]
.text$mn:00008345                 cmp     ecx, [ebp+arg_0]
.text$mn:00008348                 jnb     short loc_8350
.text$mn:0000834A                 mov     edx, [ebp+arg_0]
.text$mn:0000834D                 mov     [ebp+var_4], edx
.text$mn:00008350
.text$mn:00008350 loc_8350:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Grow_to(uint)+48j
.text$mn:00008350                 mov     eax, [ebp+var_4]
.text$mn:00008353                 mov     esp, ebp
.text$mn:00008355                 pop     ebp
.text$mn:00008356                 retn    4
.text$mn:00008356 ?_Grow_to@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEII@Z endp
.text$mn:00008356
.text$mn:00008356 ; ---------------------------------------------------------------------------
.text$mn:00008359                 align 4
.text$mn:00008359 _text$mn        ends
.text$mn:00008359
.text$mn:0000835C ; ===========================================================================
.text$mn:0000835C
.text$mn:0000835C ; Segment type: Pure code
.text$mn:0000835C ; Segment permissions: Read/Execute
.text$mn:0000835C _text$mn        segment para public 'CODE' use32
.text$mn:0000835C                 assume cs:_text$mn
.text$mn:0000835C                 ;org 835Ch
.text$mn:0000835C ; COMDAT (pick any)
.text$mn:0000835C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000835C
.text$mn:0000835C ; =============== S U B R O U T I N E =======================================
.text$mn:0000835C
.text$mn:0000835C ; Attributes: bp-based frame
.text$mn:0000835C
.text$mn:0000835C ; protected: unsigned int __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::_Grow_to(unsigned int)const
.text$mn:0000835C                 public ?_Grow_to@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEII@Z
.text$mn:0000835C ?_Grow_to@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEII@Z proc near
.text$mn:0000835C                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reserve(uint)+45p
.text$mn:0000835C
.text$mn:0000835C var_C           = dword ptr -0Ch
.text$mn:0000835C var_8           = dword ptr -8
.text$mn:0000835C var_4           = dword ptr -4
.text$mn:0000835C arg_0           = dword ptr  8
.text$mn:0000835C
.text$mn:0000835C                 push    ebp
.text$mn:0000835D                 mov     ebp, esp
.text$mn:0000835F                 sub     esp, 0Ch
.text$mn:00008362                 mov     [ebp+var_8], ecx
.text$mn:00008365                 mov     ecx, [ebp+var_8]
.text$mn:00008368                 call    ?capacity@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::capacity(void)
.text$mn:0000836D                 mov     [ebp+var_4], eax
.text$mn:00008370                 mov     ecx, [ebp+var_8]
.text$mn:00008373                 call    ?max_size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::max_size(void)
.text$mn:00008378                 mov     ecx, [ebp+var_4]
.text$mn:0000837B                 shr     ecx, 1
.text$mn:0000837D                 sub     eax, ecx
.text$mn:0000837F                 cmp     eax, [ebp+var_4]
.text$mn:00008382                 jnb     short loc_838D
.text$mn:00008384                 mov     [ebp+var_C], 0
.text$mn:0000838B                 jmp     short loc_8398
.text$mn:0000838D ; ---------------------------------------------------------------------------
.text$mn:0000838D
.text$mn:0000838D loc_838D:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Grow_to(uint)+26j
.text$mn:0000838D                 mov     edx, [ebp+var_4]
.text$mn:00008390                 shr     edx, 1
.text$mn:00008392                 add     edx, [ebp+var_4]
.text$mn:00008395                 mov     [ebp+var_C], edx
.text$mn:00008398
.text$mn:00008398 loc_8398:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Grow_to(uint)+2Fj
.text$mn:00008398                 mov     eax, [ebp+var_C]
.text$mn:0000839B                 mov     [ebp+var_4], eax
.text$mn:0000839E                 mov     ecx, [ebp+var_4]
.text$mn:000083A1                 cmp     ecx, [ebp+arg_0]
.text$mn:000083A4                 jnb     short loc_83AC
.text$mn:000083A6                 mov     edx, [ebp+arg_0]
.text$mn:000083A9                 mov     [ebp+var_4], edx
.text$mn:000083AC
.text$mn:000083AC loc_83AC:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Grow_to(uint)+48j
.text$mn:000083AC                 mov     eax, [ebp+var_4]
.text$mn:000083AF                 mov     esp, ebp
.text$mn:000083B1                 pop     ebp
.text$mn:000083B2                 retn    4
.text$mn:000083B2 ?_Grow_to@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEII@Z endp
.text$mn:000083B2
.text$mn:000083B2 ; ---------------------------------------------------------------------------
.text$mn:000083B5                 align 4
.text$mn:000083B5 _text$mn        ends
.text$mn:000083B5
.text$mn:000083B8 ; ===========================================================================
.text$mn:000083B8
.text$mn:000083B8 ; Segment type: Pure code
.text$mn:000083B8 ; Segment permissions: Read/Execute
.text$mn:000083B8 _text$mn        segment para public 'CODE' use32
.text$mn:000083B8                 assume cs:_text$mn
.text$mn:000083B8                 ;org 83B8h
.text$mn:000083B8 ; COMDAT (pick any)
.text$mn:000083B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000083B8
.text$mn:000083B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000083B8
.text$mn:000083B8 ; Attributes: bp-based frame
.text$mn:000083B8
.text$mn:000083B8 ; protected: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Grow_to(unsigned int)const
.text$mn:000083B8                 public ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z
.text$mn:000083B8 ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z proc near
.text$mn:000083B8                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+45p
.text$mn:000083B8
.text$mn:000083B8 var_C           = dword ptr -0Ch
.text$mn:000083B8 var_8           = dword ptr -8
.text$mn:000083B8 var_4           = dword ptr -4
.text$mn:000083B8 arg_0           = dword ptr  8
.text$mn:000083B8
.text$mn:000083B8                 push    ebp
.text$mn:000083B9                 mov     ebp, esp
.text$mn:000083BB                 sub     esp, 0Ch
.text$mn:000083BE                 mov     [ebp+var_8], ecx
.text$mn:000083C1                 mov     ecx, [ebp+var_8]
.text$mn:000083C4                 call    ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::capacity(void)
.text$mn:000083C9                 mov     [ebp+var_4], eax
.text$mn:000083CC                 mov     ecx, [ebp+var_8]
.text$mn:000083CF                 call    ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)
.text$mn:000083D4                 mov     ecx, [ebp+var_4]
.text$mn:000083D7                 shr     ecx, 1
.text$mn:000083D9                 sub     eax, ecx
.text$mn:000083DB                 cmp     eax, [ebp+var_4]
.text$mn:000083DE                 jnb     short loc_83E9
.text$mn:000083E0                 mov     [ebp+var_C], 0
.text$mn:000083E7                 jmp     short loc_83F4
.text$mn:000083E9 ; ---------------------------------------------------------------------------
.text$mn:000083E9
.text$mn:000083E9 loc_83E9:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+26j
.text$mn:000083E9                 mov     edx, [ebp+var_4]
.text$mn:000083EC                 shr     edx, 1
.text$mn:000083EE                 add     edx, [ebp+var_4]
.text$mn:000083F1                 mov     [ebp+var_C], edx
.text$mn:000083F4
.text$mn:000083F4 loc_83F4:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+2Fj
.text$mn:000083F4                 mov     eax, [ebp+var_C]
.text$mn:000083F7                 mov     [ebp+var_4], eax
.text$mn:000083FA                 mov     ecx, [ebp+var_4]
.text$mn:000083FD                 cmp     ecx, [ebp+arg_0]
.text$mn:00008400                 jnb     short loc_8408
.text$mn:00008402                 mov     edx, [ebp+arg_0]
.text$mn:00008405                 mov     [ebp+var_4], edx
.text$mn:00008408
.text$mn:00008408 loc_8408:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+48j
.text$mn:00008408                 mov     eax, [ebp+var_4]
.text$mn:0000840B                 mov     esp, ebp
.text$mn:0000840D                 pop     ebp
.text$mn:0000840E                 retn    4
.text$mn:0000840E ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z endp
.text$mn:0000840E
.text$mn:0000840E ; ---------------------------------------------------------------------------
.text$mn:00008411                 align 4
.text$mn:00008411 _text$mn        ends
.text$mn:00008411
.text$mn:00008414 ; ===========================================================================
.text$mn:00008414
.text$mn:00008414 ; Segment type: Pure code
.text$mn:00008414 ; Segment permissions: Read/Execute
.text$mn:00008414 _text$mn        segment para public 'CODE' use32
.text$mn:00008414                 assume cs:_text$mn
.text$mn:00008414                 ;org 8414h
.text$mn:00008414 ; COMDAT (pick any)
.text$mn:00008414                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008414
.text$mn:00008414 ; =============== S U B R O U T I N E =======================================
.text$mn:00008414
.text$mn:00008414 ; Attributes: bp-based frame
.text$mn:00008414
.text$mn:00008414 ; protected: unsigned int __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::_Grow_to(unsigned int)const
.text$mn:00008414                 public ?_Grow_to@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEII@Z
.text$mn:00008414 ?_Grow_to@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEII@Z proc near
.text$mn:00008414                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reserve(uint)+45p
.text$mn:00008414
.text$mn:00008414 var_C           = dword ptr -0Ch
.text$mn:00008414 var_8           = dword ptr -8
.text$mn:00008414 var_4           = dword ptr -4
.text$mn:00008414 arg_0           = dword ptr  8
.text$mn:00008414
.text$mn:00008414                 push    ebp
.text$mn:00008415                 mov     ebp, esp
.text$mn:00008417                 sub     esp, 0Ch
.text$mn:0000841A                 mov     [ebp+var_8], ecx
.text$mn:0000841D                 mov     ecx, [ebp+var_8]
.text$mn:00008420                 call    ?capacity@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::capacity(void)
.text$mn:00008425                 mov     [ebp+var_4], eax
.text$mn:00008428                 mov     ecx, [ebp+var_8]
.text$mn:0000842B                 call    ?max_size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::max_size(void)
.text$mn:00008430                 mov     ecx, [ebp+var_4]
.text$mn:00008433                 shr     ecx, 1
.text$mn:00008435                 sub     eax, ecx
.text$mn:00008437                 cmp     eax, [ebp+var_4]
.text$mn:0000843A                 jnb     short loc_8445
.text$mn:0000843C                 mov     [ebp+var_C], 0
.text$mn:00008443                 jmp     short loc_8450
.text$mn:00008445 ; ---------------------------------------------------------------------------
.text$mn:00008445
.text$mn:00008445 loc_8445:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Grow_to(uint)+26j
.text$mn:00008445                 mov     edx, [ebp+var_4]
.text$mn:00008448                 shr     edx, 1
.text$mn:0000844A                 add     edx, [ebp+var_4]
.text$mn:0000844D                 mov     [ebp+var_C], edx
.text$mn:00008450
.text$mn:00008450 loc_8450:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Grow_to(uint)+2Fj
.text$mn:00008450                 mov     eax, [ebp+var_C]
.text$mn:00008453                 mov     [ebp+var_4], eax
.text$mn:00008456                 mov     ecx, [ebp+var_4]
.text$mn:00008459                 cmp     ecx, [ebp+arg_0]
.text$mn:0000845C                 jnb     short loc_8464
.text$mn:0000845E                 mov     edx, [ebp+arg_0]
.text$mn:00008461                 mov     [ebp+var_4], edx
.text$mn:00008464
.text$mn:00008464 loc_8464:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Grow_to(uint)+48j
.text$mn:00008464                 mov     eax, [ebp+var_4]
.text$mn:00008467                 mov     esp, ebp
.text$mn:00008469                 pop     ebp
.text$mn:0000846A                 retn    4
.text$mn:0000846A ?_Grow_to@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEII@Z endp
.text$mn:0000846A
.text$mn:0000846A ; ---------------------------------------------------------------------------
.text$mn:0000846D                 align 10h
.text$mn:0000846D _text$mn        ends
.text$mn:0000846D
.text$mn:00008470 ; ===========================================================================
.text$mn:00008470
.text$mn:00008470 ; Segment type: Pure code
.text$mn:00008470 ; Segment permissions: Read/Execute
.text$mn:00008470 _text$mn        segment para public 'CODE' use32
.text$mn:00008470                 assume cs:_text$mn
.text$mn:00008470                 ;org 8470h
.text$mn:00008470 ; COMDAT (pick any)
.text$mn:00008470                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008470
.text$mn:00008470 ; =============== S U B R O U T I N E =======================================
.text$mn:00008470
.text$mn:00008470 ; Attributes: bp-based frame
.text$mn:00008470
.text$mn:00008470 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00008470                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00008470 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00008470                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00008470
.text$mn:00008470 var_4           = dword ptr -4
.text$mn:00008470 arg_0           = dword ptr  8
.text$mn:00008470
.text$mn:00008470                 push    ebp
.text$mn:00008471                 mov     ebp, esp
.text$mn:00008473                 push    ecx
.text$mn:00008474                 mov     [ebp+var_4], ecx
.text$mn:00008477                 cmp     [ebp+arg_0], 0
.text$mn:0000847B                 jz      short loc_849D
.text$mn:0000847D                 mov     ecx, [ebp+var_4]
.text$mn:00008480                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00008485                 cmp     [ebp+arg_0], eax
.text$mn:00008488                 jb      short loc_849D
.text$mn:0000848A                 mov     ecx, [ebp+var_4]
.text$mn:0000848D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00008492                 mov     ecx, [ebp+var_4]
.text$mn:00008495                 add     eax, [ecx+14h]
.text$mn:00008498                 cmp     eax, [ebp+arg_0]
.text$mn:0000849B                 ja      short loc_84A3
.text$mn:0000849D
.text$mn:0000849D loc_849D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:0000849D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:0000849D                 xor     al, al
.text$mn:0000849F                 jmp     short loc_84A5
.text$mn:000084A1 ; ---------------------------------------------------------------------------
.text$mn:000084A1                 jmp     short loc_84A5
.text$mn:000084A3 ; ---------------------------------------------------------------------------
.text$mn:000084A3
.text$mn:000084A3 loc_84A3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000084A3                 mov     al, 1
.text$mn:000084A5
.text$mn:000084A5 loc_84A5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000084A5                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000084A5                 mov     esp, ebp
.text$mn:000084A7                 pop     ebp
.text$mn:000084A8                 retn    4
.text$mn:000084A8 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000084A8
.text$mn:000084A8 ; ---------------------------------------------------------------------------
.text$mn:000084AB                 align 4
.text$mn:000084AB _text$mn        ends
.text$mn:000084AB
.text$mn:000084AC ; ===========================================================================
.text$mn:000084AC
.text$mn:000084AC ; Segment type: Pure code
.text$mn:000084AC ; Segment permissions: Read/Execute
.text$mn:000084AC _text$mn        segment para public 'CODE' use32
.text$mn:000084AC                 assume cs:_text$mn
.text$mn:000084AC                 ;org 84ACh
.text$mn:000084AC ; COMDAT (pick any)
.text$mn:000084AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000084AC
.text$mn:000084AC ; =============== S U B R O U T I N E =======================================
.text$mn:000084AC
.text$mn:000084AC ; Attributes: bp-based frame
.text$mn:000084AC
.text$mn:000084AC ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000084AC                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:000084AC ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:000084AC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+2Cp
.text$mn:000084AC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:000084AC
.text$mn:000084AC var_4           = dword ptr -4
.text$mn:000084AC arg_0           = dword ptr  8
.text$mn:000084AC
.text$mn:000084AC                 push    ebp
.text$mn:000084AD                 mov     ebp, esp
.text$mn:000084AF                 push    ecx
.text$mn:000084B0                 mov     [ebp+var_4], ecx
.text$mn:000084B3                 cmp     [ebp+arg_0], 0
.text$mn:000084B7                 jz      short loc_84DC
.text$mn:000084B9                 mov     ecx, [ebp+var_4]
.text$mn:000084BC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000084C1                 cmp     [ebp+arg_0], eax
.text$mn:000084C4                 jb      short loc_84DC
.text$mn:000084C6                 mov     ecx, [ebp+var_4]
.text$mn:000084C9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000084CE                 mov     ecx, [ebp+var_4]
.text$mn:000084D1                 mov     edx, [ecx+14h]
.text$mn:000084D4                 lea     eax, [eax+edx*2]
.text$mn:000084D7                 cmp     eax, [ebp+arg_0]
.text$mn:000084DA                 ja      short loc_84E2
.text$mn:000084DC
.text$mn:000084DC loc_84DC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:000084DC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:000084DC                 xor     al, al
.text$mn:000084DE                 jmp     short loc_84E4
.text$mn:000084E0 ; ---------------------------------------------------------------------------
.text$mn:000084E0                 jmp     short loc_84E4
.text$mn:000084E2 ; ---------------------------------------------------------------------------
.text$mn:000084E2
.text$mn:000084E2 loc_84E2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:000084E2                 mov     al, 1
.text$mn:000084E4
.text$mn:000084E4 loc_84E4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:000084E4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:000084E4                 mov     esp, ebp
.text$mn:000084E6                 pop     ebp
.text$mn:000084E7                 retn    4
.text$mn:000084E7 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:000084E7
.text$mn:000084E7 ; ---------------------------------------------------------------------------
.text$mn:000084EA                 align 4
.text$mn:000084EA _text$mn        ends
.text$mn:000084EA
.text$mn:000084EC ; ===========================================================================
.text$mn:000084EC
.text$mn:000084EC ; Segment type: Pure code
.text$mn:000084EC ; Segment permissions: Read/Execute
.text$mn:000084EC _text$mn        segment para public 'CODE' use32
.text$mn:000084EC                 assume cs:_text$mn
.text$mn:000084EC                 ;org 84ECh
.text$mn:000084EC ; COMDAT (pick any)
.text$mn:000084EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000084EC
.text$mn:000084EC ; =============== S U B R O U T I N E =======================================
.text$mn:000084EC
.text$mn:000084EC ; Attributes: bp-based frame
.text$mn:000084EC
.text$mn:000084EC ; protected: bool __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::_Inside(struct PluginInfo * const *)const
.text$mn:000084EC                 public ?_Inside@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBE_NPBQAUPluginInfo@@@Z
.text$mn:000084EC ?_Inside@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBE_NPBQAUPluginInfo@@@Z proc near
.text$mn:000084EC                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+19p
.text$mn:000084EC
.text$mn:000084EC var_8           = dword ptr -8
.text$mn:000084EC var_4           = dword ptr -4
.text$mn:000084EC arg_0           = dword ptr  8
.text$mn:000084EC
.text$mn:000084EC                 push    ebp
.text$mn:000084ED                 mov     ebp, esp
.text$mn:000084EF                 sub     esp, 8
.text$mn:000084F2                 mov     [ebp+var_4], ecx
.text$mn:000084F5                 mov     eax, [ebp+var_4]
.text$mn:000084F8                 mov     ecx, [ebp+arg_0]
.text$mn:000084FB                 cmp     ecx, [eax+8]
.text$mn:000084FE                 jnb     short loc_8514
.text$mn:00008500                 mov     edx, [ebp+var_4]
.text$mn:00008503                 mov     eax, [edx+4]
.text$mn:00008506                 cmp     eax, [ebp+arg_0]
.text$mn:00008509                 ja      short loc_8514
.text$mn:0000850B                 mov     [ebp+var_8], 1
.text$mn:00008512                 jmp     short loc_851B
.text$mn:00008514 ; ---------------------------------------------------------------------------
.text$mn:00008514
.text$mn:00008514 loc_8514:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Inside(PluginInfo * const *)+12j
.text$mn:00008514                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Inside(PluginInfo * const *)+1Dj
.text$mn:00008514                 mov     [ebp+var_8], 0
.text$mn:0000851B
.text$mn:0000851B loc_851B:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Inside(PluginInfo * const *)+26j
.text$mn:0000851B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000851E                 mov     esp, ebp
.text$mn:00008520                 pop     ebp
.text$mn:00008521                 retn    4
.text$mn:00008521 ?_Inside@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBE_NPBQAUPluginInfo@@@Z endp
.text$mn:00008521
.text$mn:00008521 _text$mn        ends
.text$mn:00008521
.text$mn:00008524 ; ===========================================================================
.text$mn:00008524
.text$mn:00008524 ; Segment type: Pure code
.text$mn:00008524 ; Segment permissions: Read/Execute
.text$mn:00008524 _text$mn        segment para public 'CODE' use32
.text$mn:00008524                 assume cs:_text$mn
.text$mn:00008524                 ;org 8524h
.text$mn:00008524 ; COMDAT (pick any)
.text$mn:00008524                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008524
.text$mn:00008524 ; =============== S U B R O U T I N E =======================================
.text$mn:00008524
.text$mn:00008524 ; Attributes: bp-based frame
.text$mn:00008524
.text$mn:00008524 ; protected: bool __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::_Inside(class TiXmlDocument * const *)const
.text$mn:00008524                 public ?_Inside@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBE_NPBQAVTiXmlDocument@@@Z
.text$mn:00008524 ?_Inside@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBE_NPBQAVTiXmlDocument@@@Z proc near
.text$mn:00008524                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+19p
.text$mn:00008524
.text$mn:00008524 var_8           = dword ptr -8
.text$mn:00008524 var_4           = dword ptr -4
.text$mn:00008524 arg_0           = dword ptr  8
.text$mn:00008524
.text$mn:00008524                 push    ebp
.text$mn:00008525                 mov     ebp, esp
.text$mn:00008527                 sub     esp, 8
.text$mn:0000852A                 mov     [ebp+var_4], ecx
.text$mn:0000852D                 mov     eax, [ebp+var_4]
.text$mn:00008530                 mov     ecx, [ebp+arg_0]
.text$mn:00008533                 cmp     ecx, [eax+8]
.text$mn:00008536                 jnb     short loc_854C
.text$mn:00008538                 mov     edx, [ebp+var_4]
.text$mn:0000853B                 mov     eax, [edx+4]
.text$mn:0000853E                 cmp     eax, [ebp+arg_0]
.text$mn:00008541                 ja      short loc_854C
.text$mn:00008543                 mov     [ebp+var_8], 1
.text$mn:0000854A                 jmp     short loc_8553
.text$mn:0000854C ; ---------------------------------------------------------------------------
.text$mn:0000854C
.text$mn:0000854C loc_854C:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Inside(TiXmlDocument * const *)+12j
.text$mn:0000854C                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Inside(TiXmlDocument * const *)+1Dj
.text$mn:0000854C                 mov     [ebp+var_8], 0
.text$mn:00008553
.text$mn:00008553 loc_8553:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Inside(TiXmlDocument * const *)+26j
.text$mn:00008553                 mov     al, byte ptr [ebp+var_8]
.text$mn:00008556                 mov     esp, ebp
.text$mn:00008558                 pop     ebp
.text$mn:00008559                 retn    4
.text$mn:00008559 ?_Inside@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBE_NPBQAVTiXmlDocument@@@Z endp
.text$mn:00008559
.text$mn:00008559 _text$mn        ends
.text$mn:00008559
.text$mn:0000855C ; ===========================================================================
.text$mn:0000855C
.text$mn:0000855C ; Segment type: Pure code
.text$mn:0000855C ; Segment permissions: Read/Execute
.text$mn:0000855C _text$mn        segment para public 'CODE' use32
.text$mn:0000855C                 assume cs:_text$mn
.text$mn:0000855C                 ;org 855Ch
.text$mn:0000855C ; COMDAT (pick any)
.text$mn:0000855C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000855C
.text$mn:0000855C ; =============== S U B R O U T I N E =======================================
.text$mn:0000855C
.text$mn:0000855C ; Attributes: bp-based frame
.text$mn:0000855C
.text$mn:0000855C ; protected: bool __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::_Inside(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> const *)const
.text$mn:0000855C                 public ?_Inside@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBE_NPBU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@@Z
.text$mn:0000855C ?_Inside@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBE_NPBU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@@Z proc near
.text$mn:0000855C                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+19p
.text$mn:0000855C
.text$mn:0000855C var_8           = dword ptr -8
.text$mn:0000855C var_4           = dword ptr -4
.text$mn:0000855C arg_0           = dword ptr  8
.text$mn:0000855C
.text$mn:0000855C                 push    ebp
.text$mn:0000855D                 mov     ebp, esp
.text$mn:0000855F                 sub     esp, 8
.text$mn:00008562                 mov     [ebp+var_4], ecx
.text$mn:00008565                 mov     eax, [ebp+var_4]
.text$mn:00008568                 mov     ecx, [ebp+arg_0]
.text$mn:0000856B                 cmp     ecx, [eax+8]
.text$mn:0000856E                 jnb     short loc_8584
.text$mn:00008570                 mov     edx, [ebp+var_4]
.text$mn:00008573                 mov     eax, [edx+4]
.text$mn:00008576                 cmp     eax, [ebp+arg_0]
.text$mn:00008579                 ja      short loc_8584
.text$mn:0000857B                 mov     [ebp+var_8], 1
.text$mn:00008582                 jmp     short loc_858B
.text$mn:00008584 ; ---------------------------------------------------------------------------
.text$mn:00008584
.text$mn:00008584 loc_8584:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Inside(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> const *)+12j
.text$mn:00008584                                         ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Inside(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> const *)+1Dj
.text$mn:00008584                 mov     [ebp+var_8], 0
.text$mn:0000858B
.text$mn:0000858B loc_858B:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Inside(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> const *)+26j
.text$mn:0000858B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000858E                 mov     esp, ebp
.text$mn:00008590                 pop     ebp
.text$mn:00008591                 retn    4
.text$mn:00008591 ?_Inside@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBE_NPBU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@@Z endp
.text$mn:00008591
.text$mn:00008591 _text$mn        ends
.text$mn:00008591
.text$mn:00008594 ; ===========================================================================
.text$mn:00008594
.text$mn:00008594 ; Segment type: Pure code
.text$mn:00008594 ; Segment permissions: Read/Execute
.text$mn:00008594 _text$mn        segment para public 'CODE' use32
.text$mn:00008594                 assume cs:_text$mn
.text$mn:00008594                 ;org 8594h
.text$mn:00008594 ; COMDAT (pick any)
.text$mn:00008594                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008594
.text$mn:00008594 ; =============== S U B R O U T I N E =======================================
.text$mn:00008594
.text$mn:00008594 ; Attributes: bp-based frame
.text$mn:00008594
.text$mn:00008594 ; protected: bool __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::_Inside(struct PluginCommand const *)const
.text$mn:00008594                 public ?_Inside@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBE_NPBUPluginCommand@@@Z
.text$mn:00008594 ?_Inside@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBE_NPBUPluginCommand@@@Z proc near
.text$mn:00008594                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+19p
.text$mn:00008594
.text$mn:00008594 var_8           = dword ptr -8
.text$mn:00008594 var_4           = dword ptr -4
.text$mn:00008594 arg_0           = dword ptr  8
.text$mn:00008594
.text$mn:00008594                 push    ebp
.text$mn:00008595                 mov     ebp, esp
.text$mn:00008597                 sub     esp, 8
.text$mn:0000859A                 mov     [ebp+var_4], ecx
.text$mn:0000859D                 mov     eax, [ebp+var_4]
.text$mn:000085A0                 mov     ecx, [ebp+arg_0]
.text$mn:000085A3                 cmp     ecx, [eax+8]
.text$mn:000085A6                 jnb     short loc_85BC
.text$mn:000085A8                 mov     edx, [ebp+var_4]
.text$mn:000085AB                 mov     eax, [edx+4]
.text$mn:000085AE                 cmp     eax, [ebp+arg_0]
.text$mn:000085B1                 ja      short loc_85BC
.text$mn:000085B3                 mov     [ebp+var_8], 1
.text$mn:000085BA                 jmp     short loc_85C3
.text$mn:000085BC ; ---------------------------------------------------------------------------
.text$mn:000085BC
.text$mn:000085BC loc_85BC:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Inside(PluginCommand const *)+12j
.text$mn:000085BC                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Inside(PluginCommand const *)+1Dj
.text$mn:000085BC                 mov     [ebp+var_8], 0
.text$mn:000085C3
.text$mn:000085C3 loc_85C3:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Inside(PluginCommand const *)+26j
.text$mn:000085C3                 mov     al, byte ptr [ebp+var_8]
.text$mn:000085C6                 mov     esp, ebp
.text$mn:000085C8                 pop     ebp
.text$mn:000085C9                 retn    4
.text$mn:000085C9 ?_Inside@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBE_NPBUPluginCommand@@@Z endp
.text$mn:000085C9
.text$mn:000085C9 _text$mn        ends
.text$mn:000085C9
.text$mn:000085CC ; ===========================================================================
.text$mn:000085CC
.text$mn:000085CC ; Segment type: Pure code
.text$mn:000085CC ; Segment permissions: Read/Execute
.text$mn:000085CC _text$mn        segment para public 'CODE' use32
.text$mn:000085CC                 assume cs:_text$mn
.text$mn:000085CC                 ;org 85CCh
.text$mn:000085CC ; COMDAT (pick any)
.text$mn:000085CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000085CC
.text$mn:000085CC ; =============== S U B R O U T I N E =======================================
.text$mn:000085CC
.text$mn:000085CC ; Attributes: bp-based frame
.text$mn:000085CC
.text$mn:000085CC ; protected: bool __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Inside(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const *)const
.text$mn:000085CC                 public ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
.text$mn:000085CC ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z proc near
.text$mn:000085CC                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+19p
.text$mn:000085CC                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+19p
.text$mn:000085CC
.text$mn:000085CC var_8           = dword ptr -8
.text$mn:000085CC var_4           = dword ptr -4
.text$mn:000085CC arg_0           = dword ptr  8
.text$mn:000085CC
.text$mn:000085CC                 push    ebp
.text$mn:000085CD                 mov     ebp, esp
.text$mn:000085CF                 sub     esp, 8
.text$mn:000085D2                 mov     [ebp+var_4], ecx
.text$mn:000085D5                 mov     eax, [ebp+var_4]
.text$mn:000085D8                 mov     ecx, [ebp+arg_0]
.text$mn:000085DB                 cmp     ecx, [eax+8]
.text$mn:000085DE                 jnb     short loc_85F4
.text$mn:000085E0                 mov     edx, [ebp+var_4]
.text$mn:000085E3                 mov     eax, [edx+4]
.text$mn:000085E6                 cmp     eax, [ebp+arg_0]
.text$mn:000085E9                 ja      short loc_85F4
.text$mn:000085EB                 mov     [ebp+var_8], 1
.text$mn:000085F2                 jmp     short loc_85FB
.text$mn:000085F4 ; ---------------------------------------------------------------------------
.text$mn:000085F4
.text$mn:000085F4 loc_85F4:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)+12j
.text$mn:000085F4                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)+1Dj
.text$mn:000085F4                 mov     [ebp+var_8], 0
.text$mn:000085FB
.text$mn:000085FB loc_85FB:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)+26j
.text$mn:000085FB                 mov     al, byte ptr [ebp+var_8]
.text$mn:000085FE                 mov     esp, ebp
.text$mn:00008600                 pop     ebp
.text$mn:00008601                 retn    4
.text$mn:00008601 ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z endp
.text$mn:00008601
.text$mn:00008601 _text$mn        ends
.text$mn:00008601
.text$mn:00008604 ; ===========================================================================
.text$mn:00008604
.text$mn:00008604 ; Segment type: Pure code
.text$mn:00008604 ; Segment permissions: Read/Execute
.text$mn:00008604 _text$mn        segment para public 'CODE' use32
.text$mn:00008604                 assume cs:_text$mn
.text$mn:00008604                 ;org 8604h
.text$mn:00008604 ; COMDAT (pick any)
.text$mn:00008604                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008604
.text$mn:00008604 ; =============== S U B R O U T I N E =======================================
.text$mn:00008604
.text$mn:00008604 ; Attributes: bp-based frame
.text$mn:00008604
.text$mn:00008604 ; protected: bool __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::_Inside(class PluginCmdShortcut const *)const
.text$mn:00008604                 public ?_Inside@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBE_NPBVPluginCmdShortcut@@@Z
.text$mn:00008604 ?_Inside@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBE_NPBVPluginCmdShortcut@@@Z proc near
.text$mn:00008604                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+19p
.text$mn:00008604
.text$mn:00008604 var_8           = dword ptr -8
.text$mn:00008604 var_4           = dword ptr -4
.text$mn:00008604 arg_0           = dword ptr  8
.text$mn:00008604
.text$mn:00008604                 push    ebp
.text$mn:00008605                 mov     ebp, esp
.text$mn:00008607                 sub     esp, 8
.text$mn:0000860A                 mov     [ebp+var_4], ecx
.text$mn:0000860D                 mov     eax, [ebp+var_4]
.text$mn:00008610                 mov     ecx, [ebp+arg_0]
.text$mn:00008613                 cmp     ecx, [eax+8]
.text$mn:00008616                 jnb     short loc_862C
.text$mn:00008618                 mov     edx, [ebp+var_4]
.text$mn:0000861B                 mov     eax, [edx+4]
.text$mn:0000861E                 cmp     eax, [ebp+arg_0]
.text$mn:00008621                 ja      short loc_862C
.text$mn:00008623                 mov     [ebp+var_8], 1
.text$mn:0000862A                 jmp     short loc_8633
.text$mn:0000862C ; ---------------------------------------------------------------------------
.text$mn:0000862C
.text$mn:0000862C loc_862C:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Inside(PluginCmdShortcut const *)+12j
.text$mn:0000862C                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Inside(PluginCmdShortcut const *)+1Dj
.text$mn:0000862C                 mov     [ebp+var_8], 0
.text$mn:00008633
.text$mn:00008633 loc_8633:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Inside(PluginCmdShortcut const *)+26j
.text$mn:00008633                 mov     al, byte ptr [ebp+var_8]
.text$mn:00008636                 mov     esp, ebp
.text$mn:00008638                 pop     ebp
.text$mn:00008639                 retn    4
.text$mn:00008639 ?_Inside@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBE_NPBVPluginCmdShortcut@@@Z endp
.text$mn:00008639
.text$mn:00008639 _text$mn        ends
.text$mn:00008639
.text$mn:0000863C ; ===========================================================================
.text$mn:0000863C
.text$mn:0000863C ; Segment type: Pure code
.text$mn:0000863C ; Segment permissions: Read/Execute
.text$mn:0000863C _text$mn        segment para public 'CODE' use32
.text$mn:0000863C                 assume cs:_text$mn
.text$mn:0000863C                 ;org 863Ch
.text$mn:0000863C ; COMDAT (pick any)
.text$mn:0000863C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000863C
.text$mn:0000863C ; =============== S U B R O U T I N E =======================================
.text$mn:0000863C
.text$mn:0000863C ; Attributes: bp-based frame
.text$mn:0000863C
.text$mn:0000863C ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000863C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:0000863C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:0000863C                                         ; CODE XREF: $LN19+14p
.text$mn:0000863C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:0000863C
.text$mn:0000863C var_8           = dword ptr -8
.text$mn:0000863C var_4           = dword ptr -4
.text$mn:0000863C
.text$mn:0000863C                 push    ebp
.text$mn:0000863D                 mov     ebp, esp
.text$mn:0000863F                 sub     esp, 8
.text$mn:00008642                 mov     [ebp+var_4], ecx
.text$mn:00008645                 mov     eax, [ebp+var_4]
.text$mn:00008648                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000864C                 jb      short loc_8662
.text$mn:0000864E                 mov     ecx, [ebp+var_4]
.text$mn:00008651                 mov     edx, [ecx+4]
.text$mn:00008654                 push    edx
.text$mn:00008655                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000865A                 add     esp, 4
.text$mn:0000865D                 mov     [ebp+var_8], eax
.text$mn:00008660                 jmp     short loc_866B
.text$mn:00008662 ; ---------------------------------------------------------------------------
.text$mn:00008662
.text$mn:00008662 loc_8662:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00008662                 mov     eax, [ebp+var_4]
.text$mn:00008665                 add     eax, 4
.text$mn:00008668                 mov     [ebp+var_8], eax
.text$mn:0000866B
.text$mn:0000866B loc_866B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000866B                 mov     eax, [ebp+var_8]
.text$mn:0000866E                 mov     esp, ebp
.text$mn:00008670                 pop     ebp
.text$mn:00008671                 retn
.text$mn:00008671 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00008671
.text$mn:00008671 ; ---------------------------------------------------------------------------
.text$mn:00008672                 align 4
.text$mn:00008672 _text$mn        ends
.text$mn:00008672
.text$mn:00008674 ; ===========================================================================
.text$mn:00008674
.text$mn:00008674 ; Segment type: Pure code
.text$mn:00008674 ; Segment permissions: Read/Execute
.text$mn:00008674 _text$mn        segment para public 'CODE' use32
.text$mn:00008674                 assume cs:_text$mn
.text$mn:00008674                 ;org 8674h
.text$mn:00008674 ; COMDAT (pick any)
.text$mn:00008674                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008674
.text$mn:00008674 ; =============== S U B R O U T I N E =======================================
.text$mn:00008674
.text$mn:00008674 ; Attributes: bp-based frame
.text$mn:00008674
.text$mn:00008674 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00008674                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00008674 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00008674                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00008674
.text$mn:00008674 var_8           = dword ptr -8
.text$mn:00008674 var_4           = dword ptr -4
.text$mn:00008674
.text$mn:00008674                 push    ebp
.text$mn:00008675                 mov     ebp, esp
.text$mn:00008677                 sub     esp, 8
.text$mn:0000867A                 mov     [ebp+var_4], ecx
.text$mn:0000867D                 mov     eax, [ebp+var_4]
.text$mn:00008680                 cmp     dword ptr [eax+18h], 10h
.text$mn:00008684                 jb      short loc_869A
.text$mn:00008686                 mov     ecx, [ebp+var_4]
.text$mn:00008689                 mov     edx, [ecx+4]
.text$mn:0000868C                 push    edx
.text$mn:0000868D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00008692                 add     esp, 4
.text$mn:00008695                 mov     [ebp+var_8], eax
.text$mn:00008698                 jmp     short loc_86A3
.text$mn:0000869A ; ---------------------------------------------------------------------------
.text$mn:0000869A
.text$mn:0000869A loc_869A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000869A                 mov     eax, [ebp+var_4]
.text$mn:0000869D                 add     eax, 4
.text$mn:000086A0                 mov     [ebp+var_8], eax
.text$mn:000086A3
.text$mn:000086A3 loc_86A3:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000086A3                 mov     eax, [ebp+var_8]
.text$mn:000086A6                 mov     esp, ebp
.text$mn:000086A8                 pop     ebp
.text$mn:000086A9                 retn
.text$mn:000086A9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000086A9
.text$mn:000086A9 ; ---------------------------------------------------------------------------
.text$mn:000086AA                 align 4
.text$mn:000086AA _text$mn        ends
.text$mn:000086AA
.text$mn:000086AC ; ===========================================================================
.text$mn:000086AC
.text$mn:000086AC ; Segment type: Pure code
.text$mn:000086AC ; Segment permissions: Read/Execute
.text$mn:000086AC _text$mn        segment para public 'CODE' use32
.text$mn:000086AC                 assume cs:_text$mn
.text$mn:000086AC                 ;org 86ACh
.text$mn:000086AC ; COMDAT (pick any)
.text$mn:000086AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000086AC
.text$mn:000086AC ; =============== S U B R O U T I N E =======================================
.text$mn:000086AC
.text$mn:000086AC ; Attributes: bp-based frame
.text$mn:000086AC
.text$mn:000086AC ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000086AC                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:000086AC ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:000086AC                                         ; CODE XREF: $LN19_0+14p
.text$mn:000086AC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:000086AC
.text$mn:000086AC var_8           = dword ptr -8
.text$mn:000086AC var_4           = dword ptr -4
.text$mn:000086AC
.text$mn:000086AC                 push    ebp
.text$mn:000086AD                 mov     ebp, esp
.text$mn:000086AF                 sub     esp, 8
.text$mn:000086B2                 mov     [ebp+var_4], ecx
.text$mn:000086B5                 mov     eax, [ebp+var_4]
.text$mn:000086B8                 cmp     dword ptr [eax+18h], 8
.text$mn:000086BC                 jb      short loc_86D2
.text$mn:000086BE                 mov     ecx, [ebp+var_4]
.text$mn:000086C1                 mov     edx, [ecx+4]
.text$mn:000086C4                 push    edx
.text$mn:000086C5                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000086CA                 add     esp, 4
.text$mn:000086CD                 mov     [ebp+var_8], eax
.text$mn:000086D0                 jmp     short loc_86DB
.text$mn:000086D2 ; ---------------------------------------------------------------------------
.text$mn:000086D2
.text$mn:000086D2 loc_86D2:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000086D2                 mov     eax, [ebp+var_4]
.text$mn:000086D5                 add     eax, 4
.text$mn:000086D8                 mov     [ebp+var_8], eax
.text$mn:000086DB
.text$mn:000086DB loc_86DB:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000086DB                 mov     eax, [ebp+var_8]
.text$mn:000086DE                 mov     esp, ebp
.text$mn:000086E0                 pop     ebp
.text$mn:000086E1                 retn
.text$mn:000086E1 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:000086E1
.text$mn:000086E1 ; ---------------------------------------------------------------------------
.text$mn:000086E2                 align 4
.text$mn:000086E2 _text$mn        ends
.text$mn:000086E2
.text$mn:000086E4 ; ===========================================================================
.text$mn:000086E4
.text$mn:000086E4 ; Segment type: Pure code
.text$mn:000086E4 ; Segment permissions: Read/Execute
.text$mn:000086E4 _text$mn        segment para public 'CODE' use32
.text$mn:000086E4                 assume cs:_text$mn
.text$mn:000086E4                 ;org 86E4h
.text$mn:000086E4 ; COMDAT (pick any)
.text$mn:000086E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000086E4
.text$mn:000086E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000086E4
.text$mn:000086E4 ; Attributes: bp-based frame
.text$mn:000086E4
.text$mn:000086E4 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:000086E4                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:000086E4 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:000086E4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+2Cp
.text$mn:000086E4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+80p ...
.text$mn:000086E4
.text$mn:000086E4 var_8           = dword ptr -8
.text$mn:000086E4 var_4           = dword ptr -4
.text$mn:000086E4
.text$mn:000086E4                 push    ebp
.text$mn:000086E5                 mov     ebp, esp
.text$mn:000086E7                 sub     esp, 8
.text$mn:000086EA                 mov     [ebp+var_4], ecx
.text$mn:000086ED                 mov     eax, [ebp+var_4]
.text$mn:000086F0                 cmp     dword ptr [eax+18h], 8
.text$mn:000086F4                 jb      short loc_870A
.text$mn:000086F6                 mov     ecx, [ebp+var_4]
.text$mn:000086F9                 mov     edx, [ecx+4]
.text$mn:000086FC                 push    edx
.text$mn:000086FD                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00008702                 add     esp, 4
.text$mn:00008705                 mov     [ebp+var_8], eax
.text$mn:00008708                 jmp     short loc_8713
.text$mn:0000870A ; ---------------------------------------------------------------------------
.text$mn:0000870A
.text$mn:0000870A loc_870A:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000870A                 mov     eax, [ebp+var_4]
.text$mn:0000870D                 add     eax, 4
.text$mn:00008710                 mov     [ebp+var_8], eax
.text$mn:00008713
.text$mn:00008713 loc_8713:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00008713                 mov     eax, [ebp+var_8]
.text$mn:00008716                 mov     esp, ebp
.text$mn:00008718                 pop     ebp
.text$mn:00008719                 retn
.text$mn:00008719 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00008719
.text$mn:00008719 ; ---------------------------------------------------------------------------
.text$mn:0000871A                 align 4
.text$mn:0000871A _text$mn        ends
.text$mn:0000871A
.text$mn:0000871C ; ===========================================================================
.text$mn:0000871C
.text$mn:0000871C ; Segment type: Pure code
.text$mn:0000871C ; Segment permissions: Read/Execute
.text$mn:0000871C _text$mn        segment para public 'CODE' use32
.text$mn:0000871C                 assume cs:_text$mn
.text$mn:0000871C                 ;org 871Ch
.text$mn:0000871C ; COMDAT (pick any)
.text$mn:0000871C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000871C
.text$mn:0000871C ; =============== S U B R O U T I N E =======================================
.text$mn:0000871C
.text$mn:0000871C ; Attributes: bp-based frame
.text$mn:0000871C
.text$mn:0000871C ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:0000871C                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000871C ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:0000871C                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:0000871C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:0000871C
.text$mn:0000871C var_18          = byte ptr -18h
.text$mn:0000871C var_14          = dword ptr -14h
.text$mn:0000871C var_10          = dword ptr -10h
.text$mn:0000871C var_C           = dword ptr -0Ch
.text$mn:0000871C var_4           = dword ptr -4
.text$mn:0000871C
.text$mn:0000871C                 push    ebp
.text$mn:0000871D                 mov     ebp, esp
.text$mn:0000871F                 push    0FFFFFFFFh
.text$mn:00008721                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00008726                 mov     eax, large fs:0
.text$mn:0000872C                 push    eax
.text$mn:0000872D                 sub     esp, 0Ch
.text$mn:00008730                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008735                 xor     eax, ebp
.text$mn:00008737                 push    eax
.text$mn:00008738                 lea     eax, [ebp+var_C]
.text$mn:0000873B                 mov     large fs:0, eax
.text$mn:00008741                 mov     [ebp+var_14], ecx
.text$mn:00008744                 mov     eax, [ebp+var_14]
.text$mn:00008747                 cmp     dword ptr [eax], 0
.text$mn:0000874A                 jz      short loc_87A7
.text$mn:0000874C                 push    3               ; int
.text$mn:0000874E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008751                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008756                 mov     [ebp+var_4], 0
.text$mn:0000875D                 mov     ecx, [ebp+var_14]
.text$mn:00008760                 mov     edx, [ecx]
.text$mn:00008762                 add     edx, 4
.text$mn:00008765                 mov     [ebp+var_10], edx
.text$mn:00008768                 jmp     short loc_8777
.text$mn:0000876A ; ---------------------------------------------------------------------------
.text$mn:0000876A
.text$mn:0000876A loc_876A:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000876A                 mov     eax, [ebp+var_10]
.text$mn:0000876D                 mov     ecx, [eax]
.text$mn:0000876F                 mov     edx, [ebp+var_10]
.text$mn:00008772                 mov     eax, [ecx+4]
.text$mn:00008775                 mov     [edx], eax
.text$mn:00008777
.text$mn:00008777 loc_8777:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00008777                 mov     ecx, [ebp+var_10]
.text$mn:0000877A                 cmp     dword ptr [ecx], 0
.text$mn:0000877D                 jz      short loc_878C
.text$mn:0000877F                 mov     edx, [ebp+var_10]
.text$mn:00008782                 mov     eax, [edx]
.text$mn:00008784                 mov     dword ptr [eax], 0
.text$mn:0000878A                 jmp     short loc_876A
.text$mn:0000878C ; ---------------------------------------------------------------------------
.text$mn:0000878C
.text$mn:0000878C loc_878C:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000878C                 mov     ecx, [ebp+var_14]
.text$mn:0000878F                 mov     edx, [ecx]
.text$mn:00008791                 mov     dword ptr [edx+4], 0
.text$mn:00008798                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000879F                 lea     ecx, [ebp+var_18] ; this
.text$mn:000087A2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000087A7
.text$mn:000087A7 loc_87A7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000087A7                 mov     ecx, [ebp+var_C]
.text$mn:000087AA                 mov     large fs:0, ecx
.text$mn:000087B1                 pop     ecx
.text$mn:000087B2                 mov     esp, ebp
.text$mn:000087B4                 pop     ebp
.text$mn:000087B5                 retn
.text$mn:000087B5 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000087B5
.text$mn:000087B5 ; ---------------------------------------------------------------------------
.text$mn:000087B6                 align 4
.text$mn:000087B6 _text$mn        ends
.text$mn:000087B6
.text$x:000087B8 ; ===========================================================================
.text$x:000087B8
.text$x:000087B8 ; Segment type: Pure code
.text$x:000087B8 ; Segment permissions: Read/Execute
.text$x:000087B8 _text$x         segment para public 'CODE' use32
.text$x:000087B8                 assume cs:_text$x
.text$x:000087B8                 ;org 87B8h
.text$x:000087B8 ; COMDAT (pick associative to section at 871C)
.text$x:000087B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000087B8
.text$x:000087B8 ; =============== S U B R O U T I N E =======================================
.text$x:000087B8
.text$x:000087B8
.text$x:000087B8 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000087B8                                         ; DATA XREF: .xdata$x:0000C39Co
.text$x:000087B8                 lea     ecx, [ebp-18h]  ; this
.text$x:000087BB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000087BB __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000087BB
.text$x:000087C0
.text$x:000087C0 ; =============== S U B R O U T I N E =======================================
.text$x:000087C0
.text$x:000087C0
.text$x:000087C0 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000087C0                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000087C0
.text$x:000087C0 arg_4           = dword ptr  8
.text$x:000087C0
.text$x:000087C0                 mov     edx, [esp+arg_4]
.text$x:000087C4                 lea     eax, [edx+0Ch]
.text$x:000087C7                 mov     ecx, [edx-10h]
.text$x:000087CA                 xor     ecx, eax
.text$x:000087CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000087D1                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000087D6                 jmp     ___CxxFrameHandler3
.text$x:000087D6 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000087D6
.text$x:000087D6 ; ---------------------------------------------------------------------------
.text$x:000087DB                 align 4
.text$x:000087DB _text$x         ends
.text$x:000087DB
.text$mn:000087DC ; ===========================================================================
.text$mn:000087DC
.text$mn:000087DC ; Segment type: Pure code
.text$mn:000087DC ; Segment permissions: Read/Execute
.text$mn:000087DC _text$mn        segment para public 'CODE' use32
.text$mn:000087DC                 assume cs:_text$mn
.text$mn:000087DC                 ;org 87DCh
.text$mn:000087DC ; COMDAT (pick any)
.text$mn:000087DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000087DC
.text$mn:000087DC ; =============== S U B R O U T I N E =======================================
.text$mn:000087DC
.text$mn:000087DC ; Attributes: bp-based frame
.text$mn:000087DC
.text$mn:000087DC ; protected: void __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::_Orphan_range(struct PluginInfo * *, struct PluginInfo * *)const
.text$mn:000087DC                 public ?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z
.text$mn:000087DC ?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z proc near
.text$mn:000087DC                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+66p
.text$mn:000087DC                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+CCp
.text$mn:000087DC
.text$mn:000087DC var_18          = byte ptr -18h
.text$mn:000087DC var_14          = dword ptr -14h
.text$mn:000087DC var_10          = dword ptr -10h
.text$mn:000087DC var_C           = dword ptr -0Ch
.text$mn:000087DC var_4           = dword ptr -4
.text$mn:000087DC arg_0           = dword ptr  8
.text$mn:000087DC arg_4           = dword ptr  0Ch
.text$mn:000087DC
.text$mn:000087DC                 push    ebp
.text$mn:000087DD                 mov     ebp, esp
.text$mn:000087DF                 push    0FFFFFFFFh
.text$mn:000087E1                 push    offset __ehhandler$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z
.text$mn:000087E6                 mov     eax, large fs:0
.text$mn:000087EC                 push    eax
.text$mn:000087ED                 sub     esp, 0Ch
.text$mn:000087F0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000087F5                 xor     eax, ebp
.text$mn:000087F7                 push    eax
.text$mn:000087F8                 lea     eax, [ebp+var_C]
.text$mn:000087FB                 mov     large fs:0, eax
.text$mn:00008801                 mov     [ebp+var_14], ecx
.text$mn:00008804                 push    3               ; int
.text$mn:00008806                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008809                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000880E                 mov     [ebp+var_4], 0
.text$mn:00008815                 mov     ecx, [ebp+var_14] ; this
.text$mn:00008818                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000881D                 mov     [ebp+var_10], eax
.text$mn:00008820                 cmp     [ebp+var_10], 0
.text$mn:00008824                 jz      short loc_8874
.text$mn:00008826
.text$mn:00008826 loc_8826:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *):loc_8872j
.text$mn:00008826                 mov     eax, [ebp+var_10]
.text$mn:00008829                 cmp     dword ptr [eax], 0
.text$mn:0000882C                 jz      short loc_8874
.text$mn:0000882E                 mov     ecx, [ebp+var_10]
.text$mn:00008831                 mov     edx, [ecx]
.text$mn:00008833                 mov     eax, [edx+8]
.text$mn:00008836                 cmp     eax, [ebp+arg_0]
.text$mn:00008839                 jb      short loc_8848
.text$mn:0000883B                 mov     ecx, [ebp+var_10]
.text$mn:0000883E                 mov     edx, [ecx]
.text$mn:00008840                 mov     eax, [ebp+arg_4]
.text$mn:00008843                 cmp     eax, [edx+8]
.text$mn:00008846                 jnb     short loc_8857
.text$mn:00008848
.text$mn:00008848 loc_8848:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+5Dj
.text$mn:00008848                 mov     ecx, [ebp+var_10]
.text$mn:0000884B                 mov     ecx, [ecx]      ; this
.text$mn:0000884D                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008852                 mov     [ebp+var_10], eax
.text$mn:00008855                 jmp     short loc_8872
.text$mn:00008857 ; ---------------------------------------------------------------------------
.text$mn:00008857
.text$mn:00008857 loc_8857:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+6Aj
.text$mn:00008857                 mov     edx, [ebp+var_10]
.text$mn:0000885A                 mov     ecx, [edx]      ; this
.text$mn:0000885C                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00008861                 mov     eax, [ebp+var_10]
.text$mn:00008864                 mov     ecx, [eax]      ; this
.text$mn:00008866                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000886B                 mov     ecx, [ebp+var_10]
.text$mn:0000886E                 mov     edx, [eax]
.text$mn:00008870                 mov     [ecx], edx
.text$mn:00008872
.text$mn:00008872 loc_8872:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+79j
.text$mn:00008872                 jmp     short loc_8826
.text$mn:00008874 ; ---------------------------------------------------------------------------
.text$mn:00008874
.text$mn:00008874 loc_8874:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+48j
.text$mn:00008874                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+50j
.text$mn:00008874                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000887B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000887E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008883                 mov     ecx, [ebp+var_C]
.text$mn:00008886                 mov     large fs:0, ecx
.text$mn:0000888D                 pop     ecx
.text$mn:0000888E                 mov     esp, ebp
.text$mn:00008890                 pop     ebp
.text$mn:00008891                 retn    8
.text$mn:00008891 ?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z endp
.text$mn:00008891
.text$mn:00008891 _text$mn        ends
.text$mn:00008891
.text$x:00008894 ; ===========================================================================
.text$x:00008894
.text$x:00008894 ; Segment type: Pure code
.text$x:00008894 ; Segment permissions: Read/Execute
.text$x:00008894 _text$x         segment para public 'CODE' use32
.text$x:00008894                 assume cs:_text$x
.text$x:00008894                 ;org 8894h
.text$x:00008894 ; COMDAT (pick associative to section at 87DC)
.text$x:00008894                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008894
.text$x:00008894 ; =============== S U B R O U T I N E =======================================
.text$x:00008894
.text$x:00008894
.text$x:00008894 __unwindfunclet$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z$0 proc near
.text$x:00008894                                         ; DATA XREF: .xdata$x:0000D4F8o
.text$x:00008894                 lea     ecx, [ebp-18h]  ; this
.text$x:00008897                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008897 __unwindfunclet$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z$0 endp
.text$x:00008897
.text$x:0000889C
.text$x:0000889C ; =============== S U B R O U T I N E =======================================
.text$x:0000889C
.text$x:0000889C
.text$x:0000889C __ehhandler$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z proc near
.text$x:0000889C                                         ; DATA XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+5o
.text$x:0000889C
.text$x:0000889C arg_4           = dword ptr  8
.text$x:0000889C
.text$x:0000889C                 mov     edx, [esp+arg_4]
.text$x:000088A0                 lea     eax, [edx+0Ch]
.text$x:000088A3                 mov     ecx, [edx-10h]
.text$x:000088A6                 xor     ecx, eax
.text$x:000088A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000088AD                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z
.text$x:000088B2                 jmp     ___CxxFrameHandler3
.text$x:000088B2 __ehhandler$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z endp
.text$x:000088B2
.text$x:000088B2 ; ---------------------------------------------------------------------------
.text$x:000088B7                 align 4
.text$x:000088B7 _text$x         ends
.text$x:000088B7
.text$mn:000088B8 ; ===========================================================================
.text$mn:000088B8
.text$mn:000088B8 ; Segment type: Pure code
.text$mn:000088B8 ; Segment permissions: Read/Execute
.text$mn:000088B8 _text$mn        segment para public 'CODE' use32
.text$mn:000088B8                 assume cs:_text$mn
.text$mn:000088B8                 ;org 88B8h
.text$mn:000088B8 ; COMDAT (pick any)
.text$mn:000088B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000088B8
.text$mn:000088B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000088B8
.text$mn:000088B8 ; Attributes: bp-based frame
.text$mn:000088B8
.text$mn:000088B8 ; protected: void __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::_Orphan_range(class TiXmlDocument * *, class TiXmlDocument * *)const
.text$mn:000088B8                 public ?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z
.text$mn:000088B8 ?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z proc near
.text$mn:000088B8                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+66p
.text$mn:000088B8                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+CCp
.text$mn:000088B8
.text$mn:000088B8 var_18          = byte ptr -18h
.text$mn:000088B8 var_14          = dword ptr -14h
.text$mn:000088B8 var_10          = dword ptr -10h
.text$mn:000088B8 var_C           = dword ptr -0Ch
.text$mn:000088B8 var_4           = dword ptr -4
.text$mn:000088B8 arg_0           = dword ptr  8
.text$mn:000088B8 arg_4           = dword ptr  0Ch
.text$mn:000088B8
.text$mn:000088B8                 push    ebp
.text$mn:000088B9                 mov     ebp, esp
.text$mn:000088BB                 push    0FFFFFFFFh
.text$mn:000088BD                 push    offset __ehhandler$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z
.text$mn:000088C2                 mov     eax, large fs:0
.text$mn:000088C8                 push    eax
.text$mn:000088C9                 sub     esp, 0Ch
.text$mn:000088CC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000088D1                 xor     eax, ebp
.text$mn:000088D3                 push    eax
.text$mn:000088D4                 lea     eax, [ebp+var_C]
.text$mn:000088D7                 mov     large fs:0, eax
.text$mn:000088DD                 mov     [ebp+var_14], ecx
.text$mn:000088E0                 push    3               ; int
.text$mn:000088E2                 lea     ecx, [ebp+var_18] ; this
.text$mn:000088E5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000088EA                 mov     [ebp+var_4], 0
.text$mn:000088F1                 mov     ecx, [ebp+var_14] ; this
.text$mn:000088F4                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:000088F9                 mov     [ebp+var_10], eax
.text$mn:000088FC                 cmp     [ebp+var_10], 0
.text$mn:00008900                 jz      short loc_8950
.text$mn:00008902
.text$mn:00008902 loc_8902:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *):loc_894Ej
.text$mn:00008902                 mov     eax, [ebp+var_10]
.text$mn:00008905                 cmp     dword ptr [eax], 0
.text$mn:00008908                 jz      short loc_8950
.text$mn:0000890A                 mov     ecx, [ebp+var_10]
.text$mn:0000890D                 mov     edx, [ecx]
.text$mn:0000890F                 mov     eax, [edx+8]
.text$mn:00008912                 cmp     eax, [ebp+arg_0]
.text$mn:00008915                 jb      short loc_8924
.text$mn:00008917                 mov     ecx, [ebp+var_10]
.text$mn:0000891A                 mov     edx, [ecx]
.text$mn:0000891C                 mov     eax, [ebp+arg_4]
.text$mn:0000891F                 cmp     eax, [edx+8]
.text$mn:00008922                 jnb     short loc_8933
.text$mn:00008924
.text$mn:00008924 loc_8924:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *)+5Dj
.text$mn:00008924                 mov     ecx, [ebp+var_10]
.text$mn:00008927                 mov     ecx, [ecx]      ; this
.text$mn:00008929                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000892E                 mov     [ebp+var_10], eax
.text$mn:00008931                 jmp     short loc_894E
.text$mn:00008933 ; ---------------------------------------------------------------------------
.text$mn:00008933
.text$mn:00008933 loc_8933:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *)+6Aj
.text$mn:00008933                 mov     edx, [ebp+var_10]
.text$mn:00008936                 mov     ecx, [edx]      ; this
.text$mn:00008938                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000893D                 mov     eax, [ebp+var_10]
.text$mn:00008940                 mov     ecx, [eax]      ; this
.text$mn:00008942                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008947                 mov     ecx, [ebp+var_10]
.text$mn:0000894A                 mov     edx, [eax]
.text$mn:0000894C                 mov     [ecx], edx
.text$mn:0000894E
.text$mn:0000894E loc_894E:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *)+79j
.text$mn:0000894E                 jmp     short loc_8902
.text$mn:00008950 ; ---------------------------------------------------------------------------
.text$mn:00008950
.text$mn:00008950 loc_8950:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *)+48j
.text$mn:00008950                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *)+50j
.text$mn:00008950                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008957                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000895A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000895F                 mov     ecx, [ebp+var_C]
.text$mn:00008962                 mov     large fs:0, ecx
.text$mn:00008969                 pop     ecx
.text$mn:0000896A                 mov     esp, ebp
.text$mn:0000896C                 pop     ebp
.text$mn:0000896D                 retn    8
.text$mn:0000896D ?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z endp
.text$mn:0000896D
.text$mn:0000896D _text$mn        ends
.text$mn:0000896D
.text$x:00008970 ; ===========================================================================
.text$x:00008970
.text$x:00008970 ; Segment type: Pure code
.text$x:00008970 ; Segment permissions: Read/Execute
.text$x:00008970 _text$x         segment para public 'CODE' use32
.text$x:00008970                 assume cs:_text$x
.text$x:00008970                 ;org 8970h
.text$x:00008970 ; COMDAT (pick associative to section at 88B8)
.text$x:00008970                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008970
.text$x:00008970 ; =============== S U B R O U T I N E =======================================
.text$x:00008970
.text$x:00008970
.text$x:00008970 __unwindfunclet$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z$0 proc near
.text$x:00008970                                         ; DATA XREF: .xdata$x:0000CEB8o
.text$x:00008970                 lea     ecx, [ebp-18h]  ; this
.text$x:00008973                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008973 __unwindfunclet$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z$0 endp
.text$x:00008973
.text$x:00008978
.text$x:00008978 ; =============== S U B R O U T I N E =======================================
.text$x:00008978
.text$x:00008978
.text$x:00008978 __ehhandler$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z proc near
.text$x:00008978                                         ; DATA XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *)+5o
.text$x:00008978
.text$x:00008978 arg_4           = dword ptr  8
.text$x:00008978
.text$x:00008978                 mov     edx, [esp+arg_4]
.text$x:0000897C                 lea     eax, [edx+0Ch]
.text$x:0000897F                 mov     ecx, [edx-10h]
.text$x:00008982                 xor     ecx, eax
.text$x:00008984                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008989                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z
.text$x:0000898E                 jmp     ___CxxFrameHandler3
.text$x:0000898E __ehhandler$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z endp
.text$x:0000898E
.text$x:0000898E ; ---------------------------------------------------------------------------
.text$x:00008993                 align 4
.text$x:00008993 _text$x         ends
.text$x:00008993
.text$mn:00008994 ; ===========================================================================
.text$mn:00008994
.text$mn:00008994 ; Segment type: Pure code
.text$mn:00008994 ; Segment permissions: Read/Execute
.text$mn:00008994 _text$mn        segment para public 'CODE' use32
.text$mn:00008994                 assume cs:_text$mn
.text$mn:00008994                 ;org 8994h
.text$mn:00008994 ; COMDAT (pick any)
.text$mn:00008994                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008994
.text$mn:00008994 ; =============== S U B R O U T I N E =======================================
.text$mn:00008994
.text$mn:00008994 ; Attributes: bp-based frame
.text$mn:00008994
.text$mn:00008994 ; protected: void __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::_Orphan_range(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *, struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> *)const
.text$mn:00008994                 public ?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z
.text$mn:00008994 ?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z proc near
.text$mn:00008994                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+6Ap
.text$mn:00008994                                         ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+D9p
.text$mn:00008994
.text$mn:00008994 var_18          = byte ptr -18h
.text$mn:00008994 var_14          = dword ptr -14h
.text$mn:00008994 var_10          = dword ptr -10h
.text$mn:00008994 var_C           = dword ptr -0Ch
.text$mn:00008994 var_4           = dword ptr -4
.text$mn:00008994 arg_0           = dword ptr  8
.text$mn:00008994 arg_4           = dword ptr  0Ch
.text$mn:00008994
.text$mn:00008994                 push    ebp
.text$mn:00008995                 mov     ebp, esp
.text$mn:00008997                 push    0FFFFFFFFh
.text$mn:00008999                 push    offset __ehhandler$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z
.text$mn:0000899E                 mov     eax, large fs:0
.text$mn:000089A4                 push    eax
.text$mn:000089A5                 sub     esp, 0Ch
.text$mn:000089A8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000089AD                 xor     eax, ebp
.text$mn:000089AF                 push    eax
.text$mn:000089B0                 lea     eax, [ebp+var_C]
.text$mn:000089B3                 mov     large fs:0, eax
.text$mn:000089B9                 mov     [ebp+var_14], ecx
.text$mn:000089BC                 push    3               ; int
.text$mn:000089BE                 lea     ecx, [ebp+var_18] ; this
.text$mn:000089C1                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000089C6                 mov     [ebp+var_4], 0
.text$mn:000089CD                 mov     ecx, [ebp+var_14] ; this
.text$mn:000089D0                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:000089D5                 mov     [ebp+var_10], eax
.text$mn:000089D8                 cmp     [ebp+var_10], 0
.text$mn:000089DC                 jz      short loc_8A2C
.text$mn:000089DE
.text$mn:000089DE loc_89DE:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Orphan_range(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *):loc_8A2Aj
.text$mn:000089DE                 mov     eax, [ebp+var_10]
.text$mn:000089E1                 cmp     dword ptr [eax], 0
.text$mn:000089E4                 jz      short loc_8A2C
.text$mn:000089E6                 mov     ecx, [ebp+var_10]
.text$mn:000089E9                 mov     edx, [ecx]
.text$mn:000089EB                 mov     eax, [edx+8]
.text$mn:000089EE                 cmp     eax, [ebp+arg_0]
.text$mn:000089F1                 jb      short loc_8A00
.text$mn:000089F3                 mov     ecx, [ebp+var_10]
.text$mn:000089F6                 mov     edx, [ecx]
.text$mn:000089F8                 mov     eax, [ebp+arg_4]
.text$mn:000089FB                 cmp     eax, [edx+8]
.text$mn:000089FE                 jnb     short loc_8A0F
.text$mn:00008A00
.text$mn:00008A00 loc_8A00:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Orphan_range(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+5Dj
.text$mn:00008A00                 mov     ecx, [ebp+var_10]
.text$mn:00008A03                 mov     ecx, [ecx]      ; this
.text$mn:00008A05                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008A0A                 mov     [ebp+var_10], eax
.text$mn:00008A0D                 jmp     short loc_8A2A
.text$mn:00008A0F ; ---------------------------------------------------------------------------
.text$mn:00008A0F
.text$mn:00008A0F loc_8A0F:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Orphan_range(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+6Aj
.text$mn:00008A0F                 mov     edx, [ebp+var_10]
.text$mn:00008A12                 mov     ecx, [edx]      ; this
.text$mn:00008A14                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00008A19                 mov     eax, [ebp+var_10]
.text$mn:00008A1C                 mov     ecx, [eax]      ; this
.text$mn:00008A1E                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008A23                 mov     ecx, [ebp+var_10]
.text$mn:00008A26                 mov     edx, [eax]
.text$mn:00008A28                 mov     [ecx], edx
.text$mn:00008A2A
.text$mn:00008A2A loc_8A2A:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Orphan_range(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+79j
.text$mn:00008A2A                 jmp     short loc_89DE
.text$mn:00008A2C ; ---------------------------------------------------------------------------
.text$mn:00008A2C
.text$mn:00008A2C loc_8A2C:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Orphan_range(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+48j
.text$mn:00008A2C                                         ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Orphan_range(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+50j
.text$mn:00008A2C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008A33                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008A36                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008A3B                 mov     ecx, [ebp+var_C]
.text$mn:00008A3E                 mov     large fs:0, ecx
.text$mn:00008A45                 pop     ecx
.text$mn:00008A46                 mov     esp, ebp
.text$mn:00008A48                 pop     ebp
.text$mn:00008A49                 retn    8
.text$mn:00008A49 ?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z endp
.text$mn:00008A49
.text$mn:00008A49 _text$mn        ends
.text$mn:00008A49
.text$x:00008A4C ; ===========================================================================
.text$x:00008A4C
.text$x:00008A4C ; Segment type: Pure code
.text$x:00008A4C ; Segment permissions: Read/Execute
.text$x:00008A4C _text$x         segment para public 'CODE' use32
.text$x:00008A4C                 assume cs:_text$x
.text$x:00008A4C                 ;org 8A4Ch
.text$x:00008A4C ; COMDAT (pick associative to section at 8994)
.text$x:00008A4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008A4C
.text$x:00008A4C ; =============== S U B R O U T I N E =======================================
.text$x:00008A4C
.text$x:00008A4C
.text$x:00008A4C __unwindfunclet$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z$0 proc near
.text$x:00008A4C                                         ; DATA XREF: .xdata$x:0000CDB0o
.text$x:00008A4C                 lea     ecx, [ebp-18h]  ; this
.text$x:00008A4F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008A4F __unwindfunclet$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z$0 endp
.text$x:00008A4F
.text$x:00008A54
.text$x:00008A54 ; =============== S U B R O U T I N E =======================================
.text$x:00008A54
.text$x:00008A54
.text$x:00008A54 __ehhandler$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z proc near
.text$x:00008A54                                         ; DATA XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Orphan_range(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)+5o
.text$x:00008A54
.text$x:00008A54 arg_4           = dword ptr  8
.text$x:00008A54
.text$x:00008A54                 mov     edx, [esp+arg_4]
.text$x:00008A58                 lea     eax, [edx+0Ch]
.text$x:00008A5B                 mov     ecx, [edx-10h]
.text$x:00008A5E                 xor     ecx, eax
.text$x:00008A60                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008A65                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z
.text$x:00008A6A                 jmp     ___CxxFrameHandler3
.text$x:00008A6A __ehhandler$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z endp
.text$x:00008A6A
.text$x:00008A6A ; ---------------------------------------------------------------------------
.text$x:00008A6F                 align 10h
.text$x:00008A6F _text$x         ends
.text$x:00008A6F
.text$mn:00008A70 ; ===========================================================================
.text$mn:00008A70
.text$mn:00008A70 ; Segment type: Pure code
.text$mn:00008A70 ; Segment permissions: Read/Execute
.text$mn:00008A70 _text$mn        segment para public 'CODE' use32
.text$mn:00008A70                 assume cs:_text$mn
.text$mn:00008A70                 ;org 8A70h
.text$mn:00008A70 ; COMDAT (pick any)
.text$mn:00008A70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008A70
.text$mn:00008A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A70
.text$mn:00008A70 ; Attributes: bp-based frame
.text$mn:00008A70
.text$mn:00008A70 ; protected: void __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::_Orphan_range(struct PluginCommand *, struct PluginCommand *)const
.text$mn:00008A70                 public ?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z
.text$mn:00008A70 ?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z proc near
.text$mn:00008A70                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+6Fp
.text$mn:00008A70                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+DCp
.text$mn:00008A70
.text$mn:00008A70 var_18          = byte ptr -18h
.text$mn:00008A70 var_14          = dword ptr -14h
.text$mn:00008A70 var_10          = dword ptr -10h
.text$mn:00008A70 var_C           = dword ptr -0Ch
.text$mn:00008A70 var_4           = dword ptr -4
.text$mn:00008A70 arg_0           = dword ptr  8
.text$mn:00008A70 arg_4           = dword ptr  0Ch
.text$mn:00008A70
.text$mn:00008A70                 push    ebp
.text$mn:00008A71                 mov     ebp, esp
.text$mn:00008A73                 push    0FFFFFFFFh
.text$mn:00008A75                 push    offset __ehhandler$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z
.text$mn:00008A7A                 mov     eax, large fs:0
.text$mn:00008A80                 push    eax
.text$mn:00008A81                 sub     esp, 0Ch
.text$mn:00008A84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008A89                 xor     eax, ebp
.text$mn:00008A8B                 push    eax
.text$mn:00008A8C                 lea     eax, [ebp+var_C]
.text$mn:00008A8F                 mov     large fs:0, eax
.text$mn:00008A95                 mov     [ebp+var_14], ecx
.text$mn:00008A98                 push    3               ; int
.text$mn:00008A9A                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008A9D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008AA2                 mov     [ebp+var_4], 0
.text$mn:00008AA9                 mov     ecx, [ebp+var_14] ; this
.text$mn:00008AAC                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00008AB1                 mov     [ebp+var_10], eax
.text$mn:00008AB4                 cmp     [ebp+var_10], 0
.text$mn:00008AB8                 jz      short loc_8B08
.text$mn:00008ABA
.text$mn:00008ABA loc_8ABA:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Orphan_range(PluginCommand *,PluginCommand *):loc_8B06j
.text$mn:00008ABA                 mov     eax, [ebp+var_10]
.text$mn:00008ABD                 cmp     dword ptr [eax], 0
.text$mn:00008AC0                 jz      short loc_8B08
.text$mn:00008AC2                 mov     ecx, [ebp+var_10]
.text$mn:00008AC5                 mov     edx, [ecx]
.text$mn:00008AC7                 mov     eax, [edx+8]
.text$mn:00008ACA                 cmp     eax, [ebp+arg_0]
.text$mn:00008ACD                 jb      short loc_8ADC
.text$mn:00008ACF                 mov     ecx, [ebp+var_10]
.text$mn:00008AD2                 mov     edx, [ecx]
.text$mn:00008AD4                 mov     eax, [ebp+arg_4]
.text$mn:00008AD7                 cmp     eax, [edx+8]
.text$mn:00008ADA                 jnb     short loc_8AEB
.text$mn:00008ADC
.text$mn:00008ADC loc_8ADC:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Orphan_range(PluginCommand *,PluginCommand *)+5Dj
.text$mn:00008ADC                 mov     ecx, [ebp+var_10]
.text$mn:00008ADF                 mov     ecx, [ecx]      ; this
.text$mn:00008AE1                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008AE6                 mov     [ebp+var_10], eax
.text$mn:00008AE9                 jmp     short loc_8B06
.text$mn:00008AEB ; ---------------------------------------------------------------------------
.text$mn:00008AEB
.text$mn:00008AEB loc_8AEB:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Orphan_range(PluginCommand *,PluginCommand *)+6Aj
.text$mn:00008AEB                 mov     edx, [ebp+var_10]
.text$mn:00008AEE                 mov     ecx, [edx]      ; this
.text$mn:00008AF0                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00008AF5                 mov     eax, [ebp+var_10]
.text$mn:00008AF8                 mov     ecx, [eax]      ; this
.text$mn:00008AFA                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008AFF                 mov     ecx, [ebp+var_10]
.text$mn:00008B02                 mov     edx, [eax]
.text$mn:00008B04                 mov     [ecx], edx
.text$mn:00008B06
.text$mn:00008B06 loc_8B06:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Orphan_range(PluginCommand *,PluginCommand *)+79j
.text$mn:00008B06                 jmp     short loc_8ABA
.text$mn:00008B08 ; ---------------------------------------------------------------------------
.text$mn:00008B08
.text$mn:00008B08 loc_8B08:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Orphan_range(PluginCommand *,PluginCommand *)+48j
.text$mn:00008B08                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Orphan_range(PluginCommand *,PluginCommand *)+50j
.text$mn:00008B08                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008B0F                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008B12                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008B17                 mov     ecx, [ebp+var_C]
.text$mn:00008B1A                 mov     large fs:0, ecx
.text$mn:00008B21                 pop     ecx
.text$mn:00008B22                 mov     esp, ebp
.text$mn:00008B24                 pop     ebp
.text$mn:00008B25                 retn    8
.text$mn:00008B25 ?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z endp
.text$mn:00008B25
.text$mn:00008B25 _text$mn        ends
.text$mn:00008B25
.text$x:00008B28 ; ===========================================================================
.text$x:00008B28
.text$x:00008B28 ; Segment type: Pure code
.text$x:00008B28 ; Segment permissions: Read/Execute
.text$x:00008B28 _text$x         segment para public 'CODE' use32
.text$x:00008B28                 assume cs:_text$x
.text$x:00008B28                 ;org 8B28h
.text$x:00008B28 ; COMDAT (pick associative to section at 8A70)
.text$x:00008B28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008B28
.text$x:00008B28 ; =============== S U B R O U T I N E =======================================
.text$x:00008B28
.text$x:00008B28
.text$x:00008B28 __unwindfunclet$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z$0 proc near
.text$x:00008B28                                         ; DATA XREF: .xdata$x:0000D57Co
.text$x:00008B28                 lea     ecx, [ebp-18h]  ; this
.text$x:00008B2B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008B2B __unwindfunclet$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z$0 endp
.text$x:00008B2B
.text$x:00008B30
.text$x:00008B30 ; =============== S U B R O U T I N E =======================================
.text$x:00008B30
.text$x:00008B30
.text$x:00008B30 __ehhandler$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z proc near
.text$x:00008B30                                         ; DATA XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Orphan_range(PluginCommand *,PluginCommand *)+5o
.text$x:00008B30
.text$x:00008B30 arg_4           = dword ptr  8
.text$x:00008B30
.text$x:00008B30                 mov     edx, [esp+arg_4]
.text$x:00008B34                 lea     eax, [edx+0Ch]
.text$x:00008B37                 mov     ecx, [edx-10h]
.text$x:00008B3A                 xor     ecx, eax
.text$x:00008B3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008B41                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z
.text$x:00008B46                 jmp     ___CxxFrameHandler3
.text$x:00008B46 __ehhandler$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z endp
.text$x:00008B46
.text$x:00008B46 ; ---------------------------------------------------------------------------
.text$x:00008B4B                 align 4
.text$x:00008B4B _text$x         ends
.text$x:00008B4B
.text$mn:00008B4C ; ===========================================================================
.text$mn:00008B4C
.text$mn:00008B4C ; Segment type: Pure code
.text$mn:00008B4C ; Segment permissions: Read/Execute
.text$mn:00008B4C _text$mn        segment para public 'CODE' use32
.text$mn:00008B4C                 assume cs:_text$mn
.text$mn:00008B4C                 ;org 8B4Ch
.text$mn:00008B4C ; COMDAT (pick any)
.text$mn:00008B4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008B4C
.text$mn:00008B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00008B4C
.text$mn:00008B4C ; Attributes: bp-based frame
.text$mn:00008B4C
.text$mn:00008B4C ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Orphan_range(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> *)const
.text$mn:00008B4C                 public ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:00008B4C ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$mn:00008B4C                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+6Fp
.text$mn:00008B4C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+DCp ...
.text$mn:00008B4C
.text$mn:00008B4C var_18          = byte ptr -18h
.text$mn:00008B4C var_14          = dword ptr -14h
.text$mn:00008B4C var_10          = dword ptr -10h
.text$mn:00008B4C var_C           = dword ptr -0Ch
.text$mn:00008B4C var_4           = dword ptr -4
.text$mn:00008B4C arg_0           = dword ptr  8
.text$mn:00008B4C arg_4           = dword ptr  0Ch
.text$mn:00008B4C
.text$mn:00008B4C                 push    ebp
.text$mn:00008B4D                 mov     ebp, esp
.text$mn:00008B4F                 push    0FFFFFFFFh
.text$mn:00008B51                 push    offset __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$mn:00008B56                 mov     eax, large fs:0
.text$mn:00008B5C                 push    eax
.text$mn:00008B5D                 sub     esp, 0Ch
.text$mn:00008B60                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008B65                 xor     eax, ebp
.text$mn:00008B67                 push    eax
.text$mn:00008B68                 lea     eax, [ebp+var_C]
.text$mn:00008B6B                 mov     large fs:0, eax
.text$mn:00008B71                 mov     [ebp+var_14], ecx
.text$mn:00008B74                 push    3               ; int
.text$mn:00008B76                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008B79                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008B7E                 mov     [ebp+var_4], 0
.text$mn:00008B85                 mov     ecx, [ebp+var_14] ; this
.text$mn:00008B88                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00008B8D                 mov     [ebp+var_10], eax
.text$mn:00008B90                 cmp     [ebp+var_10], 0
.text$mn:00008B94                 jz      short loc_8BE4
.text$mn:00008B96
.text$mn:00008B96 loc_8B96:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *):loc_8BE2j
.text$mn:00008B96                 mov     eax, [ebp+var_10]
.text$mn:00008B99                 cmp     dword ptr [eax], 0
.text$mn:00008B9C                 jz      short loc_8BE4
.text$mn:00008B9E                 mov     ecx, [ebp+var_10]
.text$mn:00008BA1                 mov     edx, [ecx]
.text$mn:00008BA3                 mov     eax, [edx+8]
.text$mn:00008BA6                 cmp     eax, [ebp+arg_0]
.text$mn:00008BA9                 jb      short loc_8BB8
.text$mn:00008BAB                 mov     ecx, [ebp+var_10]
.text$mn:00008BAE                 mov     edx, [ecx]
.text$mn:00008BB0                 mov     eax, [ebp+arg_4]
.text$mn:00008BB3                 cmp     eax, [edx+8]
.text$mn:00008BB6                 jnb     short loc_8BC7
.text$mn:00008BB8
.text$mn:00008BB8 loc_8BB8:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+5Dj
.text$mn:00008BB8                 mov     ecx, [ebp+var_10]
.text$mn:00008BBB                 mov     ecx, [ecx]      ; this
.text$mn:00008BBD                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008BC2                 mov     [ebp+var_10], eax
.text$mn:00008BC5                 jmp     short loc_8BE2
.text$mn:00008BC7 ; ---------------------------------------------------------------------------
.text$mn:00008BC7
.text$mn:00008BC7 loc_8BC7:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+6Aj
.text$mn:00008BC7                 mov     edx, [ebp+var_10]
.text$mn:00008BCA                 mov     ecx, [edx]      ; this
.text$mn:00008BCC                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00008BD1                 mov     eax, [ebp+var_10]
.text$mn:00008BD4                 mov     ecx, [eax]      ; this
.text$mn:00008BD6                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008BDB                 mov     ecx, [ebp+var_10]
.text$mn:00008BDE                 mov     edx, [eax]
.text$mn:00008BE0                 mov     [ecx], edx
.text$mn:00008BE2
.text$mn:00008BE2 loc_8BE2:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+79j
.text$mn:00008BE2                 jmp     short loc_8B96
.text$mn:00008BE4 ; ---------------------------------------------------------------------------
.text$mn:00008BE4
.text$mn:00008BE4 loc_8BE4:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+48j
.text$mn:00008BE4                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+50j
.text$mn:00008BE4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008BEB                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008BEE                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008BF3                 mov     ecx, [ebp+var_C]
.text$mn:00008BF6                 mov     large fs:0, ecx
.text$mn:00008BFD                 pop     ecx
.text$mn:00008BFE                 mov     esp, ebp
.text$mn:00008C00                 pop     ebp
.text$mn:00008C01                 retn    8
.text$mn:00008C01 ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$mn:00008C01
.text$mn:00008C01 _text$mn        ends
.text$mn:00008C01
.text$x:00008C04 ; ===========================================================================
.text$x:00008C04
.text$x:00008C04 ; Segment type: Pure code
.text$x:00008C04 ; Segment permissions: Read/Execute
.text$x:00008C04 _text$x         segment para public 'CODE' use32
.text$x:00008C04                 assume cs:_text$x
.text$x:00008C04                 ;org 8C04h
.text$x:00008C04 ; COMDAT (pick associative to section at 8B4C)
.text$x:00008C04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008C04
.text$x:00008C04 ; =============== S U B R O U T I N E =======================================
.text$x:00008C04
.text$x:00008C04
.text$x:00008C04 __unwindfunclet$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0 proc near
.text$x:00008C04                                         ; DATA XREF: .xdata$x:0000CCF8o
.text$x:00008C04                 lea     ecx, [ebp-18h]  ; this
.text$x:00008C07                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008C07 __unwindfunclet$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0 endp
.text$x:00008C07
.text$x:00008C0C
.text$x:00008C0C ; =============== S U B R O U T I N E =======================================
.text$x:00008C0C
.text$x:00008C0C
.text$x:00008C0C __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z proc near
.text$x:00008C0C                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)+5o
.text$x:00008C0C
.text$x:00008C0C arg_4           = dword ptr  8
.text$x:00008C0C
.text$x:00008C0C                 mov     edx, [esp+arg_4]
.text$x:00008C10                 lea     eax, [edx+0Ch]
.text$x:00008C13                 mov     ecx, [edx-10h]
.text$x:00008C16                 xor     ecx, eax
.text$x:00008C18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008C1D                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.text$x:00008C22                 jmp     ___CxxFrameHandler3
.text$x:00008C22 __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z endp
.text$x:00008C22
.text$x:00008C22 ; ---------------------------------------------------------------------------
.text$x:00008C27                 align 4
.text$x:00008C27 _text$x         ends
.text$x:00008C27
.text$mn:00008C28 ; ===========================================================================
.text$mn:00008C28
.text$mn:00008C28 ; Segment type: Pure code
.text$mn:00008C28 ; Segment permissions: Read/Execute
.text$mn:00008C28 _text$mn        segment para public 'CODE' use32
.text$mn:00008C28                 assume cs:_text$mn
.text$mn:00008C28                 ;org 8C28h
.text$mn:00008C28 ; COMDAT (pick any)
.text$mn:00008C28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008C28
.text$mn:00008C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C28
.text$mn:00008C28 ; Attributes: bp-based frame
.text$mn:00008C28
.text$mn:00008C28 ; protected: void __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::_Orphan_range(class PluginCmdShortcut *, class PluginCmdShortcut *)const
.text$mn:00008C28                 public ?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z
.text$mn:00008C28 ?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z proc near
.text$mn:00008C28                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+6Fp
.text$mn:00008C28                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+D8p
.text$mn:00008C28
.text$mn:00008C28 var_18          = byte ptr -18h
.text$mn:00008C28 var_14          = dword ptr -14h
.text$mn:00008C28 var_10          = dword ptr -10h
.text$mn:00008C28 var_C           = dword ptr -0Ch
.text$mn:00008C28 var_4           = dword ptr -4
.text$mn:00008C28 arg_0           = dword ptr  8
.text$mn:00008C28 arg_4           = dword ptr  0Ch
.text$mn:00008C28
.text$mn:00008C28                 push    ebp
.text$mn:00008C29                 mov     ebp, esp
.text$mn:00008C2B                 push    0FFFFFFFFh
.text$mn:00008C2D                 push    offset __ehhandler$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z
.text$mn:00008C32                 mov     eax, large fs:0
.text$mn:00008C38                 push    eax
.text$mn:00008C39                 sub     esp, 0Ch
.text$mn:00008C3C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008C41                 xor     eax, ebp
.text$mn:00008C43                 push    eax
.text$mn:00008C44                 lea     eax, [ebp+var_C]
.text$mn:00008C47                 mov     large fs:0, eax
.text$mn:00008C4D                 mov     [ebp+var_14], ecx
.text$mn:00008C50                 push    3               ; int
.text$mn:00008C52                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008C55                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008C5A                 mov     [ebp+var_4], 0
.text$mn:00008C61                 mov     ecx, [ebp+var_14] ; this
.text$mn:00008C64                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00008C69                 mov     [ebp+var_10], eax
.text$mn:00008C6C                 cmp     [ebp+var_10], 0
.text$mn:00008C70                 jz      short loc_8CC0
.text$mn:00008C72
.text$mn:00008C72 loc_8C72:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Orphan_range(PluginCmdShortcut *,PluginCmdShortcut *):loc_8CBEj
.text$mn:00008C72                 mov     eax, [ebp+var_10]
.text$mn:00008C75                 cmp     dword ptr [eax], 0
.text$mn:00008C78                 jz      short loc_8CC0
.text$mn:00008C7A                 mov     ecx, [ebp+var_10]
.text$mn:00008C7D                 mov     edx, [ecx]
.text$mn:00008C7F                 mov     eax, [edx+8]
.text$mn:00008C82                 cmp     eax, [ebp+arg_0]
.text$mn:00008C85                 jb      short loc_8C94
.text$mn:00008C87                 mov     ecx, [ebp+var_10]
.text$mn:00008C8A                 mov     edx, [ecx]
.text$mn:00008C8C                 mov     eax, [ebp+arg_4]
.text$mn:00008C8F                 cmp     eax, [edx+8]
.text$mn:00008C92                 jnb     short loc_8CA3
.text$mn:00008C94
.text$mn:00008C94 loc_8C94:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Orphan_range(PluginCmdShortcut *,PluginCmdShortcut *)+5Dj
.text$mn:00008C94                 mov     ecx, [ebp+var_10]
.text$mn:00008C97                 mov     ecx, [ecx]      ; this
.text$mn:00008C99                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008C9E                 mov     [ebp+var_10], eax
.text$mn:00008CA1                 jmp     short loc_8CBE
.text$mn:00008CA3 ; ---------------------------------------------------------------------------
.text$mn:00008CA3
.text$mn:00008CA3 loc_8CA3:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Orphan_range(PluginCmdShortcut *,PluginCmdShortcut *)+6Aj
.text$mn:00008CA3                 mov     edx, [ebp+var_10]
.text$mn:00008CA6                 mov     ecx, [edx]      ; this
.text$mn:00008CA8                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00008CAD                 mov     eax, [ebp+var_10]
.text$mn:00008CB0                 mov     ecx, [eax]      ; this
.text$mn:00008CB2                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008CB7                 mov     ecx, [ebp+var_10]
.text$mn:00008CBA                 mov     edx, [eax]
.text$mn:00008CBC                 mov     [ecx], edx
.text$mn:00008CBE
.text$mn:00008CBE loc_8CBE:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Orphan_range(PluginCmdShortcut *,PluginCmdShortcut *)+79j
.text$mn:00008CBE                 jmp     short loc_8C72
.text$mn:00008CC0 ; ---------------------------------------------------------------------------
.text$mn:00008CC0
.text$mn:00008CC0 loc_8CC0:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Orphan_range(PluginCmdShortcut *,PluginCmdShortcut *)+48j
.text$mn:00008CC0                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Orphan_range(PluginCmdShortcut *,PluginCmdShortcut *)+50j
.text$mn:00008CC0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008CC7                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008CCA                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008CCF                 mov     ecx, [ebp+var_C]
.text$mn:00008CD2                 mov     large fs:0, ecx
.text$mn:00008CD9                 pop     ecx
.text$mn:00008CDA                 mov     esp, ebp
.text$mn:00008CDC                 pop     ebp
.text$mn:00008CDD                 retn    8
.text$mn:00008CDD ?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z endp
.text$mn:00008CDD
.text$mn:00008CDD _text$mn        ends
.text$mn:00008CDD
.text$x:00008CE0 ; ===========================================================================
.text$x:00008CE0
.text$x:00008CE0 ; Segment type: Pure code
.text$x:00008CE0 ; Segment permissions: Read/Execute
.text$x:00008CE0 _text$x         segment para public 'CODE' use32
.text$x:00008CE0                 assume cs:_text$x
.text$x:00008CE0                 ;org 8CE0h
.text$x:00008CE0 ; COMDAT (pick associative to section at 8C28)
.text$x:00008CE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008CE0
.text$x:00008CE0 ; =============== S U B R O U T I N E =======================================
.text$x:00008CE0
.text$x:00008CE0
.text$x:00008CE0 __unwindfunclet$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z$0 proc near
.text$x:00008CE0                                         ; DATA XREF: .xdata$x:0000CF68o
.text$x:00008CE0                 lea     ecx, [ebp-18h]  ; this
.text$x:00008CE3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008CE3 __unwindfunclet$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z$0 endp
.text$x:00008CE3
.text$x:00008CE8
.text$x:00008CE8 ; =============== S U B R O U T I N E =======================================
.text$x:00008CE8
.text$x:00008CE8
.text$x:00008CE8 __ehhandler$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z proc near
.text$x:00008CE8                                         ; DATA XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Orphan_range(PluginCmdShortcut *,PluginCmdShortcut *)+5o
.text$x:00008CE8
.text$x:00008CE8 arg_4           = dword ptr  8
.text$x:00008CE8
.text$x:00008CE8                 mov     edx, [esp+arg_4]
.text$x:00008CEC                 lea     eax, [edx+0Ch]
.text$x:00008CEF                 mov     ecx, [edx-10h]
.text$x:00008CF2                 xor     ecx, eax
.text$x:00008CF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008CF9                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z
.text$x:00008CFE                 jmp     ___CxxFrameHandler3
.text$x:00008CFE __ehhandler$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z endp
.text$x:00008CFE
.text$x:00008CFE ; ---------------------------------------------------------------------------
.text$x:00008D03                 align 4
.text$x:00008D03 _text$x         ends
.text$x:00008D03
.text$mn:00008D04 ; ===========================================================================
.text$mn:00008D04
.text$mn:00008D04 ; Segment type: Pure code
.text$mn:00008D04 ; Segment permissions: Read/Execute
.text$mn:00008D04 _text$mn        segment para public 'CODE' use32
.text$mn:00008D04                 assume cs:_text$mn
.text$mn:00008D04                 ;org 8D04h
.text$mn:00008D04 ; COMDAT (pick any)
.text$mn:00008D04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008D04
.text$mn:00008D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00008D04
.text$mn:00008D04 ; Attributes: bp-based frame
.text$mn:00008D04
.text$mn:00008D04 ; protected: void __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::_Reallocate(unsigned int)
.text$mn:00008D04                 public ?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z
.text$mn:00008D04 ?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z proc near
.text$mn:00008D04                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reserve(uint)+4Ep
.text$mn:00008D04
.text$mn:00008D04 var_20          = dword ptr -20h
.text$mn:00008D04 var_1C          = dword ptr -1Ch
.text$mn:00008D04 var_18          = dword ptr -18h
.text$mn:00008D04 var_13          = byte ptr -13h
.text$mn:00008D04 var_11          = byte ptr -11h
.text$mn:00008D04 var_10          = dword ptr -10h
.text$mn:00008D04 var_C           = dword ptr -0Ch
.text$mn:00008D04 var_4           = dword ptr -4
.text$mn:00008D04 arg_0           = dword ptr  8
.text$mn:00008D04
.text$mn:00008D04 ; FUNCTION CHUNK AT .text$mn:00008D9A SIZE 00000009 BYTES
.text$mn:00008D04 ; FUNCTION CHUNK AT .text$mn:00008DAA SIZE 00000097 BYTES
.text$mn:00008D04
.text$mn:00008D04                 push    ebp
.text$mn:00008D05                 mov     ebp, esp
.text$mn:00008D07                 push    0FFFFFFFFh
.text$mn:00008D09                 push    offset __ehhandler$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z
.text$mn:00008D0E                 mov     eax, large fs:0
.text$mn:00008D14                 push    eax
.text$mn:00008D15                 push    ecx
.text$mn:00008D16                 sub     esp, 10h
.text$mn:00008D19                 push    ebx
.text$mn:00008D1A                 push    esi
.text$mn:00008D1B                 push    edi
.text$mn:00008D1C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008D21                 xor     eax, ebp
.text$mn:00008D23                 push    eax
.text$mn:00008D24                 lea     eax, [ebp+var_C]
.text$mn:00008D27                 mov     large fs:0, eax
.text$mn:00008D2D                 mov     [ebp+var_10], esp
.text$mn:00008D30                 mov     [ebp+var_18], ecx
.text$mn:00008D33                 mov     eax, [ebp+arg_0]
.text$mn:00008D36                 push    eax
.text$mn:00008D37                 lea     ecx, [ebp+var_11]
.text$mn:00008D3A                 push    ecx
.text$mn:00008D3B                 mov     ecx, [ebp+var_18]
.text$mn:00008D3E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginInfo *,std::allocator<PluginInfo *>>>::_Getal(void)
.text$mn:00008D43                 mov     ecx, eax
.text$mn:00008D45                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEPAPAUPluginInfo@@I@Z ; std::_Wrap_alloc<std::allocator<PluginInfo *>>::allocate(uint)
.text$mn:00008D4A                 mov     [ebp+var_1C], eax
.text$mn:00008D4D                 mov     [ebp+var_4], 0
.text$mn:00008D54                 mov     edx, [ebp+var_1C]
.text$mn:00008D57                 push    edx
.text$mn:00008D58                 mov     eax, [ebp+var_18]
.text$mn:00008D5B                 mov     ecx, [eax+8]
.text$mn:00008D5E                 push    ecx
.text$mn:00008D5F                 mov     edx, [ebp+var_18]
.text$mn:00008D62                 mov     eax, [edx+4]
.text$mn:00008D65                 push    eax
.text$mn:00008D66                 mov     ecx, [ebp+var_18]
.text$mn:00008D69                 call    ??$_Umove@PAPAUPluginInfo@@@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEPAPAUPluginInfo@@PAPAU2@00@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Umove<PluginInfo * *>(PluginInfo * *,PluginInfo * *,PluginInfo * *)
.text$mn:00008D6E                 jmp     short loc_8D9A
.text$mn:00008D6E ?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z endp
.text$mn:00008D6E
.text$mn:00008D70
.text$mn:00008D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00008D70
.text$mn:00008D70 ; Attributes: noreturn
.text$mn:00008D70
.text$mn:00008D70 __catch$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00008D70                                         ; DATA XREF: .xdata$x:0000D4A8o
.text$mn:00008D70                 mov     ecx, [ebp+8]
.text$mn:00008D73                 push    ecx             ; int
.text$mn:00008D74                 mov     edx, [ebp-1Ch]
.text$mn:00008D77                 push    edx             ; void *
.text$mn:00008D78                 lea     eax, [ebp-12h]
.text$mn:00008D7B                 push    eax
.text$mn:00008D7C                 mov     ecx, [ebp-18h]
.text$mn:00008D7F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginInfo *,std::allocator<PluginInfo *>>>::_Getal(void)
.text$mn:00008D84                 mov     ecx, eax
.text$mn:00008D86                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@I@Z ; std::_Wrap_alloc<std::allocator<PluginInfo *>>::deallocate(PluginInfo * *,uint)
.text$mn:00008D8B                 push    0
.text$mn:00008D8D                 push    0
.text$mn:00008D8F                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00008D8F __catch$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00008D8F
.text$mn:00008D94 ; ---------------------------------------------------------------------------
.text$mn:00008D94                 mov     eax, offset $LN8_3
.text$mn:00008D99                 retn
.text$mn:00008D9A ; ---------------------------------------------------------------------------
.text$mn:00008D9A ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z
.text$mn:00008D9A
.text$mn:00008D9A loc_8D9A:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reallocate(uint)+6Aj
.text$mn:00008D9A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008DA1                 jmp     short loc_8DAA
.text$mn:00008DA1 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z
.text$mn:00008DA3
.text$mn:00008DA3 ; =============== S U B R O U T I N E =======================================
.text$mn:00008DA3
.text$mn:00008DA3
.text$mn:00008DA3 $LN8_3          proc near               ; DATA XREF: .text$mn:00008D94o
.text$mn:00008DA3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00008DA3 $LN8_3          endp ; sp-analysis failed
.text$mn:00008DA3
.text$mn:00008DAA ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z
.text$mn:00008DAA
.text$mn:00008DAA loc_8DAA:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reallocate(uint)+9Dj
.text$mn:00008DAA                 mov     ecx, [ebp+var_18]
.text$mn:00008DAD                 call    ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::size(void)
.text$mn:00008DB2                 mov     [ebp+var_20], eax
.text$mn:00008DB5                 mov     ecx, [ebp+var_18]
.text$mn:00008DB8                 cmp     dword ptr [ecx+4], 0
.text$mn:00008DBC                 jz      short loc_8DFE
.text$mn:00008DBE                 mov     edx, [ebp+var_18]
.text$mn:00008DC1                 mov     eax, [edx+8]
.text$mn:00008DC4                 push    eax
.text$mn:00008DC5                 mov     ecx, [ebp+var_18]
.text$mn:00008DC8                 mov     edx, [ecx+4]
.text$mn:00008DCB                 push    edx
.text$mn:00008DCC                 mov     ecx, [ebp+var_18]
.text$mn:00008DCF                 call    ?_Destroy@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXPAPAUPluginInfo@@0@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Destroy(PluginInfo * *,PluginInfo * *)
.text$mn:00008DD4                 mov     eax, [ebp+var_18]
.text$mn:00008DD7                 mov     ecx, [ebp+var_18]
.text$mn:00008DDA                 mov     edx, [eax+0Ch]
.text$mn:00008DDD                 sub     edx, [ecx+4]
.text$mn:00008DE0                 sar     edx, 2
.text$mn:00008DE3                 push    edx             ; int
.text$mn:00008DE4                 mov     eax, [ebp+var_18]
.text$mn:00008DE7                 mov     ecx, [eax+4]
.text$mn:00008DEA                 push    ecx             ; void *
.text$mn:00008DEB                 lea     edx, [ebp+var_13]
.text$mn:00008DEE                 push    edx
.text$mn:00008DEF                 mov     ecx, [ebp+var_18]
.text$mn:00008DF2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginInfo *,std::allocator<PluginInfo *>>>::_Getal(void)
.text$mn:00008DF7                 mov     ecx, eax
.text$mn:00008DF9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@I@Z ; std::_Wrap_alloc<std::allocator<PluginInfo *>>::deallocate(PluginInfo * *,uint)
.text$mn:00008DFE
.text$mn:00008DFE loc_8DFE:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reallocate(uint)+B8j
.text$mn:00008DFE                 mov     ecx, [ebp+var_18] ; this
.text$mn:00008E01                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00008E06                 mov     eax, [ebp+arg_0]
.text$mn:00008E09                 mov     ecx, [ebp+var_1C]
.text$mn:00008E0C                 lea     edx, [ecx+eax*4]
.text$mn:00008E0F                 mov     eax, [ebp+var_18]
.text$mn:00008E12                 mov     [eax+0Ch], edx
.text$mn:00008E15                 mov     ecx, [ebp+var_20]
.text$mn:00008E18                 mov     edx, [ebp+var_1C]
.text$mn:00008E1B                 lea     eax, [edx+ecx*4]
.text$mn:00008E1E                 mov     ecx, [ebp+var_18]
.text$mn:00008E21                 mov     [ecx+8], eax
.text$mn:00008E24                 mov     edx, [ebp+var_18]
.text$mn:00008E27                 mov     eax, [ebp+var_1C]
.text$mn:00008E2A                 mov     [edx+4], eax
.text$mn:00008E2D                 mov     ecx, [ebp+var_C]
.text$mn:00008E30                 mov     large fs:0, ecx
.text$mn:00008E37                 pop     ecx
.text$mn:00008E38                 pop     edi
.text$mn:00008E39                 pop     esi
.text$mn:00008E3A                 pop     ebx
.text$mn:00008E3B                 mov     esp, ebp
.text$mn:00008E3D                 pop     ebp
.text$mn:00008E3E                 retn    4
.text$mn:00008E3E ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z
.text$mn:00008E3E ; ---------------------------------------------------------------------------
.text$mn:00008E41                 align 4
.text$mn:00008E41 _text$mn        ends
.text$mn:00008E41
.text$x:00008E44 ; ===========================================================================
.text$x:00008E44
.text$x:00008E44 ; Segment type: Pure code
.text$x:00008E44 ; Segment permissions: Read/Execute
.text$x:00008E44 _text$x         segment para public 'CODE' use32
.text$x:00008E44                 assume cs:_text$x
.text$x:00008E44                 ;org 8E44h
.text$x:00008E44 ; COMDAT (pick associative to section at 8D04)
.text$x:00008E44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008E44
.text$x:00008E44 ; =============== S U B R O U T I N E =======================================
.text$x:00008E44
.text$x:00008E44
.text$x:00008E44 __ehhandler$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z proc near
.text$x:00008E44                                         ; DATA XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reallocate(uint)+5o
.text$x:00008E44
.text$x:00008E44 arg_4           = dword ptr  8
.text$x:00008E44
.text$x:00008E44                 mov     edx, [esp+arg_4]
.text$x:00008E48                 lea     eax, [edx+0Ch]
.text$x:00008E4B                 mov     ecx, [edx-24h]
.text$x:00008E4E                 xor     ecx, eax
.text$x:00008E50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008E55                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z
.text$x:00008E5A                 jmp     ___CxxFrameHandler3
.text$x:00008E5A __ehhandler$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z endp
.text$x:00008E5A
.text$x:00008E5A ; ---------------------------------------------------------------------------
.text$x:00008E5F                 align 10h
.text$x:00008E5F _text$x         ends
.text$x:00008E5F
.text$mn:00008E60 ; ===========================================================================
.text$mn:00008E60
.text$mn:00008E60 ; Segment type: Pure code
.text$mn:00008E60 ; Segment permissions: Read/Execute
.text$mn:00008E60 _text$mn        segment para public 'CODE' use32
.text$mn:00008E60                 assume cs:_text$mn
.text$mn:00008E60                 ;org 8E60h
.text$mn:00008E60 ; COMDAT (pick any)
.text$mn:00008E60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008E60
.text$mn:00008E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E60
.text$mn:00008E60 ; Attributes: bp-based frame
.text$mn:00008E60
.text$mn:00008E60 ; protected: void __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::_Reallocate(unsigned int)
.text$mn:00008E60                 public ?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z
.text$mn:00008E60 ?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z proc near
.text$mn:00008E60                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reserve(uint)+4Ep
.text$mn:00008E60
.text$mn:00008E60 var_20          = dword ptr -20h
.text$mn:00008E60 var_1C          = dword ptr -1Ch
.text$mn:00008E60 var_18          = dword ptr -18h
.text$mn:00008E60 var_13          = byte ptr -13h
.text$mn:00008E60 var_11          = byte ptr -11h
.text$mn:00008E60 var_10          = dword ptr -10h
.text$mn:00008E60 var_C           = dword ptr -0Ch
.text$mn:00008E60 var_4           = dword ptr -4
.text$mn:00008E60 arg_0           = dword ptr  8
.text$mn:00008E60
.text$mn:00008E60 ; FUNCTION CHUNK AT .text$mn:00008EF6 SIZE 00000009 BYTES
.text$mn:00008E60 ; FUNCTION CHUNK AT .text$mn:00008F06 SIZE 00000097 BYTES
.text$mn:00008E60
.text$mn:00008E60                 push    ebp
.text$mn:00008E61                 mov     ebp, esp
.text$mn:00008E63                 push    0FFFFFFFFh
.text$mn:00008E65                 push    offset __ehhandler$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z
.text$mn:00008E6A                 mov     eax, large fs:0
.text$mn:00008E70                 push    eax
.text$mn:00008E71                 push    ecx
.text$mn:00008E72                 sub     esp, 10h
.text$mn:00008E75                 push    ebx
.text$mn:00008E76                 push    esi
.text$mn:00008E77                 push    edi
.text$mn:00008E78                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008E7D                 xor     eax, ebp
.text$mn:00008E7F                 push    eax
.text$mn:00008E80                 lea     eax, [ebp+var_C]
.text$mn:00008E83                 mov     large fs:0, eax
.text$mn:00008E89                 mov     [ebp+var_10], esp
.text$mn:00008E8C                 mov     [ebp+var_18], ecx
.text$mn:00008E8F                 mov     eax, [ebp+arg_0]
.text$mn:00008E92                 push    eax
.text$mn:00008E93                 lea     ecx, [ebp+var_11]
.text$mn:00008E96                 push    ecx
.text$mn:00008E97                 mov     ecx, [ebp+var_18]
.text$mn:00008E9A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TiXmlDocument *,std::allocator<TiXmlDocument *>>>::_Getal(void)
.text$mn:00008E9F                 mov     ecx, eax
.text$mn:00008EA1                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEPAPAVTiXmlDocument@@I@Z ; std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::allocate(uint)
.text$mn:00008EA6                 mov     [ebp+var_1C], eax
.text$mn:00008EA9                 mov     [ebp+var_4], 0
.text$mn:00008EB0                 mov     edx, [ebp+var_1C]
.text$mn:00008EB3                 push    edx
.text$mn:00008EB4                 mov     eax, [ebp+var_18]
.text$mn:00008EB7                 mov     ecx, [eax+8]
.text$mn:00008EBA                 push    ecx
.text$mn:00008EBB                 mov     edx, [ebp+var_18]
.text$mn:00008EBE                 mov     eax, [edx+4]
.text$mn:00008EC1                 push    eax
.text$mn:00008EC2                 mov     ecx, [ebp+var_18]
.text$mn:00008EC5                 call    ??$_Umove@PAPAVTiXmlDocument@@@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEPAPAVTiXmlDocument@@PAPAV2@00@Z ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Umove<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *)
.text$mn:00008ECA                 jmp     short loc_8EF6
.text$mn:00008ECA ?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z endp
.text$mn:00008ECA
.text$mn:00008ECC
.text$mn:00008ECC ; =============== S U B R O U T I N E =======================================
.text$mn:00008ECC
.text$mn:00008ECC ; Attributes: noreturn
.text$mn:00008ECC
.text$mn:00008ECC __catch$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00008ECC                                         ; DATA XREF: .xdata$x:0000CE68o
.text$mn:00008ECC                 mov     ecx, [ebp+8]
.text$mn:00008ECF                 push    ecx             ; int
.text$mn:00008ED0                 mov     edx, [ebp-1Ch]
.text$mn:00008ED3                 push    edx             ; void *
.text$mn:00008ED4                 lea     eax, [ebp-12h]
.text$mn:00008ED7                 push    eax
.text$mn:00008ED8                 mov     ecx, [ebp-18h]
.text$mn:00008EDB                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TiXmlDocument *,std::allocator<TiXmlDocument *>>>::_Getal(void)
.text$mn:00008EE0                 mov     ecx, eax
.text$mn:00008EE2                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@I@Z ; std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::deallocate(TiXmlDocument * *,uint)
.text$mn:00008EE7                 push    0
.text$mn:00008EE9                 push    0
.text$mn:00008EEB                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00008EEB __catch$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00008EEB
.text$mn:00008EF0 ; ---------------------------------------------------------------------------
.text$mn:00008EF0                 mov     eax, offset $LN8_1
.text$mn:00008EF5                 retn
.text$mn:00008EF6 ; ---------------------------------------------------------------------------
.text$mn:00008EF6 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z
.text$mn:00008EF6
.text$mn:00008EF6 loc_8EF6:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reallocate(uint)+6Aj
.text$mn:00008EF6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008EFD                 jmp     short loc_8F06
.text$mn:00008EFD ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z
.text$mn:00008EFF
.text$mn:00008EFF ; =============== S U B R O U T I N E =======================================
.text$mn:00008EFF
.text$mn:00008EFF
.text$mn:00008EFF $LN8_1          proc near               ; DATA XREF: .text$mn:00008EF0o
.text$mn:00008EFF                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00008EFF $LN8_1          endp ; sp-analysis failed
.text$mn:00008EFF
.text$mn:00008F06 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z
.text$mn:00008F06
.text$mn:00008F06 loc_8F06:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reallocate(uint)+9Dj
.text$mn:00008F06                 mov     ecx, [ebp+var_18]
.text$mn:00008F09                 call    ?size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::size(void)
.text$mn:00008F0E                 mov     [ebp+var_20], eax
.text$mn:00008F11                 mov     ecx, [ebp+var_18]
.text$mn:00008F14                 cmp     dword ptr [ecx+4], 0
.text$mn:00008F18                 jz      short loc_8F5A
.text$mn:00008F1A                 mov     edx, [ebp+var_18]
.text$mn:00008F1D                 mov     eax, [edx+8]
.text$mn:00008F20                 push    eax
.text$mn:00008F21                 mov     ecx, [ebp+var_18]
.text$mn:00008F24                 mov     edx, [ecx+4]
.text$mn:00008F27                 push    edx
.text$mn:00008F28                 mov     ecx, [ebp+var_18]
.text$mn:00008F2B                 call    ?_Destroy@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXPAPAVTiXmlDocument@@0@Z ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Destroy(TiXmlDocument * *,TiXmlDocument * *)
.text$mn:00008F30                 mov     eax, [ebp+var_18]
.text$mn:00008F33                 mov     ecx, [ebp+var_18]
.text$mn:00008F36                 mov     edx, [eax+0Ch]
.text$mn:00008F39                 sub     edx, [ecx+4]
.text$mn:00008F3C                 sar     edx, 2
.text$mn:00008F3F                 push    edx             ; int
.text$mn:00008F40                 mov     eax, [ebp+var_18]
.text$mn:00008F43                 mov     ecx, [eax+4]
.text$mn:00008F46                 push    ecx             ; void *
.text$mn:00008F47                 lea     edx, [ebp+var_13]
.text$mn:00008F4A                 push    edx
.text$mn:00008F4B                 mov     ecx, [ebp+var_18]
.text$mn:00008F4E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TiXmlDocument *,std::allocator<TiXmlDocument *>>>::_Getal(void)
.text$mn:00008F53                 mov     ecx, eax
.text$mn:00008F55                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@I@Z ; std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::deallocate(TiXmlDocument * *,uint)
.text$mn:00008F5A
.text$mn:00008F5A loc_8F5A:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reallocate(uint)+B8j
.text$mn:00008F5A                 mov     ecx, [ebp+var_18] ; this
.text$mn:00008F5D                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00008F62                 mov     eax, [ebp+arg_0]
.text$mn:00008F65                 mov     ecx, [ebp+var_1C]
.text$mn:00008F68                 lea     edx, [ecx+eax*4]
.text$mn:00008F6B                 mov     eax, [ebp+var_18]
.text$mn:00008F6E                 mov     [eax+0Ch], edx
.text$mn:00008F71                 mov     ecx, [ebp+var_20]
.text$mn:00008F74                 mov     edx, [ebp+var_1C]
.text$mn:00008F77                 lea     eax, [edx+ecx*4]
.text$mn:00008F7A                 mov     ecx, [ebp+var_18]
.text$mn:00008F7D                 mov     [ecx+8], eax
.text$mn:00008F80                 mov     edx, [ebp+var_18]
.text$mn:00008F83                 mov     eax, [ebp+var_1C]
.text$mn:00008F86                 mov     [edx+4], eax
.text$mn:00008F89                 mov     ecx, [ebp+var_C]
.text$mn:00008F8C                 mov     large fs:0, ecx
.text$mn:00008F93                 pop     ecx
.text$mn:00008F94                 pop     edi
.text$mn:00008F95                 pop     esi
.text$mn:00008F96                 pop     ebx
.text$mn:00008F97                 mov     esp, ebp
.text$mn:00008F99                 pop     ebp
.text$mn:00008F9A                 retn    4
.text$mn:00008F9A ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z
.text$mn:00008F9A ; ---------------------------------------------------------------------------
.text$mn:00008F9D                 align 10h
.text$mn:00008F9D _text$mn        ends
.text$mn:00008F9D
.text$x:00008FA0 ; ===========================================================================
.text$x:00008FA0
.text$x:00008FA0 ; Segment type: Pure code
.text$x:00008FA0 ; Segment permissions: Read/Execute
.text$x:00008FA0 _text$x         segment para public 'CODE' use32
.text$x:00008FA0                 assume cs:_text$x
.text$x:00008FA0                 ;org 8FA0h
.text$x:00008FA0 ; COMDAT (pick associative to section at 8E60)
.text$x:00008FA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008FA0
.text$x:00008FA0 ; =============== S U B R O U T I N E =======================================
.text$x:00008FA0
.text$x:00008FA0
.text$x:00008FA0 __ehhandler$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z proc near
.text$x:00008FA0                                         ; DATA XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reallocate(uint)+5o
.text$x:00008FA0
.text$x:00008FA0 arg_4           = dword ptr  8
.text$x:00008FA0
.text$x:00008FA0                 mov     edx, [esp+arg_4]
.text$x:00008FA4                 lea     eax, [edx+0Ch]
.text$x:00008FA7                 mov     ecx, [edx-24h]
.text$x:00008FAA                 xor     ecx, eax
.text$x:00008FAC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008FB1                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z
.text$x:00008FB6                 jmp     ___CxxFrameHandler3
.text$x:00008FB6 __ehhandler$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z endp
.text$x:00008FB6
.text$x:00008FB6 ; ---------------------------------------------------------------------------
.text$x:00008FBB                 align 4
.text$x:00008FBB _text$x         ends
.text$x:00008FBB
.text$mn:00008FBC ; ===========================================================================
.text$mn:00008FBC
.text$mn:00008FBC ; Segment type: Pure code
.text$mn:00008FBC ; Segment permissions: Read/Execute
.text$mn:00008FBC _text$mn        segment para public 'CODE' use32
.text$mn:00008FBC                 assume cs:_text$mn
.text$mn:00008FBC                 ;org 8FBCh
.text$mn:00008FBC ; COMDAT (pick any)
.text$mn:00008FBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008FBC
.text$mn:00008FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00008FBC
.text$mn:00008FBC ; Attributes: bp-based frame
.text$mn:00008FBC
.text$mn:00008FBC ; protected: void __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::_Reallocate(unsigned int)
.text$mn:00008FBC                 public ?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z
.text$mn:00008FBC ?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z proc near
.text$mn:00008FBC                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reserve(uint)+4Ep
.text$mn:00008FBC
.text$mn:00008FBC var_20          = dword ptr -20h
.text$mn:00008FBC var_1C          = dword ptr -1Ch
.text$mn:00008FBC var_18          = dword ptr -18h
.text$mn:00008FBC var_13          = byte ptr -13h
.text$mn:00008FBC var_11          = byte ptr -11h
.text$mn:00008FBC var_10          = dword ptr -10h
.text$mn:00008FBC var_C           = dword ptr -0Ch
.text$mn:00008FBC var_4           = dword ptr -4
.text$mn:00008FBC arg_0           = dword ptr  8
.text$mn:00008FBC
.text$mn:00008FBC ; FUNCTION CHUNK AT .text$mn:00009052 SIZE 00000009 BYTES
.text$mn:00008FBC ; FUNCTION CHUNK AT .text$mn:00009062 SIZE 00000097 BYTES
.text$mn:00008FBC
.text$mn:00008FBC                 push    ebp
.text$mn:00008FBD                 mov     ebp, esp
.text$mn:00008FBF                 push    0FFFFFFFFh
.text$mn:00008FC1                 push    offset __ehhandler$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z
.text$mn:00008FC6                 mov     eax, large fs:0
.text$mn:00008FCC                 push    eax
.text$mn:00008FCD                 push    ecx
.text$mn:00008FCE                 sub     esp, 10h
.text$mn:00008FD1                 push    ebx
.text$mn:00008FD2                 push    esi
.text$mn:00008FD3                 push    edi
.text$mn:00008FD4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008FD9                 xor     eax, ebp
.text$mn:00008FDB                 push    eax
.text$mn:00008FDC                 lea     eax, [ebp+var_C]
.text$mn:00008FDF                 mov     large fs:0, eax
.text$mn:00008FE5                 mov     [ebp+var_10], esp
.text$mn:00008FE8                 mov     [ebp+var_18], ecx
.text$mn:00008FEB                 mov     eax, [ebp+arg_0]
.text$mn:00008FEE                 push    eax
.text$mn:00008FEF                 lea     ecx, [ebp+var_11]
.text$mn:00008FF2                 push    ecx
.text$mn:00008FF3                 mov     ecx, [ebp+var_18]
.text$mn:00008FF6                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>::_Getal(void)
.text$mn:00008FFB                 mov     ecx, eax
.text$mn:00008FFD                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::allocate(uint)
.text$mn:00009002                 mov     [ebp+var_1C], eax
.text$mn:00009005                 mov     [ebp+var_4], 0
.text$mn:0000900C                 mov     edx, [ebp+var_1C]
.text$mn:0000900F                 push    edx
.text$mn:00009010                 mov     eax, [ebp+var_18]
.text$mn:00009013                 mov     ecx, [eax+8]
.text$mn:00009016                 push    ecx
.text$mn:00009017                 mov     edx, [ebp+var_18]
.text$mn:0000901A                 mov     eax, [edx+4]
.text$mn:0000901D                 push    eax
.text$mn:0000901E                 mov     ecx, [ebp+var_18]
.text$mn:00009021                 call    ??$_Umove@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@PAU21@00@Z ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Umove<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:00009026                 jmp     short loc_9052
.text$mn:00009026 ?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z endp
.text$mn:00009026
.text$mn:00009028
.text$mn:00009028 ; =============== S U B R O U T I N E =======================================
.text$mn:00009028
.text$mn:00009028 ; Attributes: noreturn
.text$mn:00009028
.text$mn:00009028 __catch$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z$0 proc near
.text$mn:00009028                                         ; DATA XREF: .xdata$x:0000CD60o
.text$mn:00009028                 mov     ecx, [ebp+8]
.text$mn:0000902B                 push    ecx             ; int
.text$mn:0000902C                 mov     edx, [ebp-1Ch]
.text$mn:0000902F                 push    edx             ; void *
.text$mn:00009030                 lea     eax, [ebp-12h]
.text$mn:00009033                 push    eax
.text$mn:00009034                 mov     ecx, [ebp-18h]
.text$mn:00009037                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>::_Getal(void)
.text$mn:0000903C                 mov     ecx, eax
.text$mn:0000903E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::deallocate(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,uint)
.text$mn:00009043                 push    0
.text$mn:00009045                 push    0
.text$mn:00009047                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00009047 __catch$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z$0 endp
.text$mn:00009047
.text$mn:0000904C ; ---------------------------------------------------------------------------
.text$mn:0000904C                 mov     eax, offset $LN8_0
.text$mn:00009051                 retn
.text$mn:00009052 ; ---------------------------------------------------------------------------
.text$mn:00009052 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z
.text$mn:00009052
.text$mn:00009052 loc_9052:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reallocate(uint)+6Aj
.text$mn:00009052                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009059                 jmp     short loc_9062
.text$mn:00009059 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z
.text$mn:0000905B
.text$mn:0000905B ; =============== S U B R O U T I N E =======================================
.text$mn:0000905B
.text$mn:0000905B
.text$mn:0000905B $LN8_0          proc near               ; DATA XREF: .text$mn:0000904Co
.text$mn:0000905B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000905B $LN8_0          endp ; sp-analysis failed
.text$mn:0000905B
.text$mn:00009062 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z
.text$mn:00009062
.text$mn:00009062 loc_9062:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reallocate(uint)+9Dj
.text$mn:00009062                 mov     ecx, [ebp+var_18]
.text$mn:00009065                 call    ?size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::size(void)
.text$mn:0000906A                 mov     [ebp+var_20], eax
.text$mn:0000906D                 mov     ecx, [ebp+var_18]
.text$mn:00009070                 cmp     dword ptr [ecx+4], 0
.text$mn:00009074                 jz      short loc_90B6
.text$mn:00009076                 mov     edx, [ebp+var_18]
.text$mn:00009079                 mov     eax, [edx+8]
.text$mn:0000907C                 push    eax
.text$mn:0000907D                 mov     ecx, [ebp+var_18]
.text$mn:00009080                 mov     edx, [ecx+4]
.text$mn:00009083                 push    edx
.text$mn:00009084                 mov     ecx, [ebp+var_18]
.text$mn:00009087                 call    ?_Destroy@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Destroy(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:0000908C                 mov     eax, [ebp+var_18]
.text$mn:0000908F                 mov     ecx, [ebp+var_18]
.text$mn:00009092                 mov     edx, [eax+0Ch]
.text$mn:00009095                 sub     edx, [ecx+4]
.text$mn:00009098                 sar     edx, 5
.text$mn:0000909B                 push    edx             ; int
.text$mn:0000909C                 mov     eax, [ebp+var_18]
.text$mn:0000909F                 mov     ecx, [eax+4]
.text$mn:000090A2                 push    ecx             ; void *
.text$mn:000090A3                 lea     edx, [ebp+var_13]
.text$mn:000090A6                 push    edx
.text$mn:000090A7                 mov     ecx, [ebp+var_18]
.text$mn:000090AA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>::_Getal(void)
.text$mn:000090AF                 mov     ecx, eax
.text$mn:000090B1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::deallocate(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,uint)
.text$mn:000090B6
.text$mn:000090B6 loc_90B6:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reallocate(uint)+B8j
.text$mn:000090B6                 mov     ecx, [ebp+var_18] ; this
.text$mn:000090B9                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000090BE                 mov     eax, [ebp+arg_0]
.text$mn:000090C1                 shl     eax, 5
.text$mn:000090C4                 add     eax, [ebp+var_1C]
.text$mn:000090C7                 mov     ecx, [ebp+var_18]
.text$mn:000090CA                 mov     [ecx+0Ch], eax
.text$mn:000090CD                 mov     edx, [ebp+var_20]
.text$mn:000090D0                 shl     edx, 5
.text$mn:000090D3                 add     edx, [ebp+var_1C]
.text$mn:000090D6                 mov     eax, [ebp+var_18]
.text$mn:000090D9                 mov     [eax+8], edx
.text$mn:000090DC                 mov     ecx, [ebp+var_18]
.text$mn:000090DF                 mov     edx, [ebp+var_1C]
.text$mn:000090E2                 mov     [ecx+4], edx
.text$mn:000090E5                 mov     ecx, [ebp+var_C]
.text$mn:000090E8                 mov     large fs:0, ecx
.text$mn:000090EF                 pop     ecx
.text$mn:000090F0                 pop     edi
.text$mn:000090F1                 pop     esi
.text$mn:000090F2                 pop     ebx
.text$mn:000090F3                 mov     esp, ebp
.text$mn:000090F5                 pop     ebp
.text$mn:000090F6                 retn    4
.text$mn:000090F6 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z
.text$mn:000090F6 ; ---------------------------------------------------------------------------
.text$mn:000090F9                 align 4
.text$mn:000090F9 _text$mn        ends
.text$mn:000090F9
.text$x:000090FC ; ===========================================================================
.text$x:000090FC
.text$x:000090FC ; Segment type: Pure code
.text$x:000090FC ; Segment permissions: Read/Execute
.text$x:000090FC _text$x         segment para public 'CODE' use32
.text$x:000090FC                 assume cs:_text$x
.text$x:000090FC                 ;org 90FCh
.text$x:000090FC ; COMDAT (pick associative to section at 8FBC)
.text$x:000090FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000090FC
.text$x:000090FC ; =============== S U B R O U T I N E =======================================
.text$x:000090FC
.text$x:000090FC
.text$x:000090FC __ehhandler$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z proc near
.text$x:000090FC                                         ; DATA XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reallocate(uint)+5o
.text$x:000090FC
.text$x:000090FC arg_4           = dword ptr  8
.text$x:000090FC
.text$x:000090FC                 mov     edx, [esp+arg_4]
.text$x:00009100                 lea     eax, [edx+0Ch]
.text$x:00009103                 mov     ecx, [edx-24h]
.text$x:00009106                 xor     ecx, eax
.text$x:00009108                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000910D                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z
.text$x:00009112                 jmp     ___CxxFrameHandler3
.text$x:00009112 __ehhandler$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z endp
.text$x:00009112
.text$x:00009112 ; ---------------------------------------------------------------------------
.text$x:00009117                 align 4
.text$x:00009117 _text$x         ends
.text$x:00009117
.text$mn:00009118 ; ===========================================================================
.text$mn:00009118
.text$mn:00009118 ; Segment type: Pure code
.text$mn:00009118 ; Segment permissions: Read/Execute
.text$mn:00009118 _text$mn        segment para public 'CODE' use32
.text$mn:00009118                 assume cs:_text$mn
.text$mn:00009118                 ;org 9118h
.text$mn:00009118 ; COMDAT (pick any)
.text$mn:00009118                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009118
.text$mn:00009118 ; =============== S U B R O U T I N E =======================================
.text$mn:00009118
.text$mn:00009118 ; Attributes: bp-based frame
.text$mn:00009118
.text$mn:00009118 ; protected: void __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::_Reallocate(unsigned int)
.text$mn:00009118                 public ?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z
.text$mn:00009118 ?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z proc near
.text$mn:00009118                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reserve(uint)+4Ep
.text$mn:00009118
.text$mn:00009118 var_20          = dword ptr -20h
.text$mn:00009118 var_1C          = dword ptr -1Ch
.text$mn:00009118 var_18          = dword ptr -18h
.text$mn:00009118 var_13          = byte ptr -13h
.text$mn:00009118 var_11          = byte ptr -11h
.text$mn:00009118 var_10          = dword ptr -10h
.text$mn:00009118 var_C           = dword ptr -0Ch
.text$mn:00009118 var_4           = dword ptr -4
.text$mn:00009118 arg_0           = dword ptr  8
.text$mn:00009118
.text$mn:00009118 ; FUNCTION CHUNK AT .text$mn:000091AE SIZE 00000009 BYTES
.text$mn:00009118 ; FUNCTION CHUNK AT .text$mn:000091BE SIZE 00000098 BYTES
.text$mn:00009118
.text$mn:00009118                 push    ebp
.text$mn:00009119                 mov     ebp, esp
.text$mn:0000911B                 push    0FFFFFFFFh
.text$mn:0000911D                 push    offset __ehhandler$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z
.text$mn:00009122                 mov     eax, large fs:0
.text$mn:00009128                 push    eax
.text$mn:00009129                 push    ecx
.text$mn:0000912A                 sub     esp, 10h
.text$mn:0000912D                 push    ebx
.text$mn:0000912E                 push    esi
.text$mn:0000912F                 push    edi
.text$mn:00009130                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009135                 xor     eax, ebp
.text$mn:00009137                 push    eax
.text$mn:00009138                 lea     eax, [ebp+var_C]
.text$mn:0000913B                 mov     large fs:0, eax
.text$mn:00009141                 mov     [ebp+var_10], esp
.text$mn:00009144                 mov     [ebp+var_18], ecx
.text$mn:00009147                 mov     eax, [ebp+arg_0]
.text$mn:0000914A                 push    eax
.text$mn:0000914B                 lea     ecx, [ebp+var_11]
.text$mn:0000914E                 push    ecx
.text$mn:0000914F                 mov     ecx, [ebp+var_18]
.text$mn:00009152                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCommand,std::allocator<PluginCommand>>>::_Getal(void)
.text$mn:00009157                 mov     ecx, eax
.text$mn:00009159                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEPAUPluginCommand@@I@Z ; std::_Wrap_alloc<std::allocator<PluginCommand>>::allocate(uint)
.text$mn:0000915E                 mov     [ebp+var_1C], eax
.text$mn:00009161                 mov     [ebp+var_4], 0
.text$mn:00009168                 mov     edx, [ebp+var_1C]
.text$mn:0000916B                 push    edx
.text$mn:0000916C                 mov     eax, [ebp+var_18]
.text$mn:0000916F                 mov     ecx, [eax+8]
.text$mn:00009172                 push    ecx
.text$mn:00009173                 mov     edx, [ebp+var_18]
.text$mn:00009176                 mov     eax, [edx+4]
.text$mn:00009179                 push    eax
.text$mn:0000917A                 mov     ecx, [ebp+var_18]
.text$mn:0000917D                 call    ??$_Umove@PAUPluginCommand@@@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEPAUPluginCommand@@PAU2@00@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Umove<PluginCommand *>(PluginCommand *,PluginCommand *,PluginCommand *)
.text$mn:00009182                 jmp     short loc_91AE
.text$mn:00009182 ?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z endp
.text$mn:00009182
.text$mn:00009184
.text$mn:00009184 ; =============== S U B R O U T I N E =======================================
.text$mn:00009184
.text$mn:00009184 ; Attributes: noreturn
.text$mn:00009184
.text$mn:00009184 __catch$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00009184                                         ; DATA XREF: .xdata$x:0000D52Co
.text$mn:00009184                 mov     ecx, [ebp+8]
.text$mn:00009187                 push    ecx             ; int
.text$mn:00009188                 mov     edx, [ebp-1Ch]
.text$mn:0000918B                 push    edx             ; void *
.text$mn:0000918C                 lea     eax, [ebp-12h]
.text$mn:0000918F                 push    eax
.text$mn:00009190                 mov     ecx, [ebp-18h]
.text$mn:00009193                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCommand,std::allocator<PluginCommand>>>::_Getal(void)
.text$mn:00009198                 mov     ecx, eax
.text$mn:0000919A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@I@Z ; std::_Wrap_alloc<std::allocator<PluginCommand>>::deallocate(PluginCommand *,uint)
.text$mn:0000919F                 push    0
.text$mn:000091A1                 push    0
.text$mn:000091A3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000091A3 __catch$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:000091A3
.text$mn:000091A8 ; ---------------------------------------------------------------------------
.text$mn:000091A8                 mov     eax, offset $LN8_4
.text$mn:000091AD                 retn
.text$mn:000091AE ; ---------------------------------------------------------------------------
.text$mn:000091AE ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z
.text$mn:000091AE
.text$mn:000091AE loc_91AE:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reallocate(uint)+6Aj
.text$mn:000091AE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000091B5                 jmp     short loc_91BE
.text$mn:000091B5 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z
.text$mn:000091B7
.text$mn:000091B7 ; =============== S U B R O U T I N E =======================================
.text$mn:000091B7
.text$mn:000091B7
.text$mn:000091B7 $LN8_4          proc near               ; DATA XREF: .text$mn:000091A8o
.text$mn:000091B7                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000091B7 $LN8_4          endp ; sp-analysis failed
.text$mn:000091B7
.text$mn:000091BE ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z
.text$mn:000091BE
.text$mn:000091BE loc_91BE:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reallocate(uint)+9Dj
.text$mn:000091BE                 mov     ecx, [ebp+var_18]
.text$mn:000091C1                 call    ?size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::size(void)
.text$mn:000091C6                 mov     [ebp+var_20], eax
.text$mn:000091C9                 mov     ecx, [ebp+var_18]
.text$mn:000091CC                 cmp     dword ptr [ecx+4], 0
.text$mn:000091D0                 jz      short loc_9217
.text$mn:000091D2                 mov     edx, [ebp+var_18]
.text$mn:000091D5                 mov     eax, [edx+8]
.text$mn:000091D8                 push    eax
.text$mn:000091D9                 mov     ecx, [ebp+var_18]
.text$mn:000091DC                 mov     edx, [ecx+4]
.text$mn:000091DF                 push    edx
.text$mn:000091E0                 mov     ecx, [ebp+var_18]
.text$mn:000091E3                 call    ?_Destroy@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXPAUPluginCommand@@0@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Destroy(PluginCommand *,PluginCommand *)
.text$mn:000091E8                 mov     eax, [ebp+var_18]
.text$mn:000091EB                 mov     ecx, [ebp+var_18]
.text$mn:000091EE                 mov     eax, [eax+0Ch]
.text$mn:000091F1                 sub     eax, [ecx+4]
.text$mn:000091F4                 cdq
.text$mn:000091F5                 mov     ecx, 24h ; '$'
.text$mn:000091FA                 idiv    ecx
.text$mn:000091FC                 push    eax             ; int
.text$mn:000091FD                 mov     edx, [ebp+var_18]
.text$mn:00009200                 mov     eax, [edx+4]
.text$mn:00009203                 push    eax             ; void *
.text$mn:00009204                 lea     ecx, [ebp+var_13]
.text$mn:00009207                 push    ecx
.text$mn:00009208                 mov     ecx, [ebp+var_18]
.text$mn:0000920B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCommand,std::allocator<PluginCommand>>>::_Getal(void)
.text$mn:00009210                 mov     ecx, eax
.text$mn:00009212                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@I@Z ; std::_Wrap_alloc<std::allocator<PluginCommand>>::deallocate(PluginCommand *,uint)
.text$mn:00009217
.text$mn:00009217 loc_9217:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reallocate(uint)+B8j
.text$mn:00009217                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000921A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000921F                 imul    edx, [ebp+arg_0], 24h
.text$mn:00009223                 add     edx, [ebp+var_1C]
.text$mn:00009226                 mov     eax, [ebp+var_18]
.text$mn:00009229                 mov     [eax+0Ch], edx
.text$mn:0000922C                 imul    ecx, [ebp+var_20], 24h
.text$mn:00009230                 add     ecx, [ebp+var_1C]
.text$mn:00009233                 mov     edx, [ebp+var_18]
.text$mn:00009236                 mov     [edx+8], ecx
.text$mn:00009239                 mov     eax, [ebp+var_18]
.text$mn:0000923C                 mov     ecx, [ebp+var_1C]
.text$mn:0000923F                 mov     [eax+4], ecx
.text$mn:00009242                 mov     ecx, [ebp+var_C]
.text$mn:00009245                 mov     large fs:0, ecx
.text$mn:0000924C                 pop     ecx
.text$mn:0000924D                 pop     edi
.text$mn:0000924E                 pop     esi
.text$mn:0000924F                 pop     ebx
.text$mn:00009250                 mov     esp, ebp
.text$mn:00009252                 pop     ebp
.text$mn:00009253                 retn    4
.text$mn:00009253 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z
.text$mn:00009253 ; ---------------------------------------------------------------------------
.text$mn:00009256                 align 4
.text$mn:00009256 _text$mn        ends
.text$mn:00009256
.text$x:00009258 ; ===========================================================================
.text$x:00009258
.text$x:00009258 ; Segment type: Pure code
.text$x:00009258 ; Segment permissions: Read/Execute
.text$x:00009258 _text$x         segment para public 'CODE' use32
.text$x:00009258                 assume cs:_text$x
.text$x:00009258                 ;org 9258h
.text$x:00009258 ; COMDAT (pick associative to section at 9118)
.text$x:00009258                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009258
.text$x:00009258 ; =============== S U B R O U T I N E =======================================
.text$x:00009258
.text$x:00009258
.text$x:00009258 __ehhandler$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z proc near
.text$x:00009258                                         ; DATA XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reallocate(uint)+5o
.text$x:00009258
.text$x:00009258 arg_4           = dword ptr  8
.text$x:00009258
.text$x:00009258                 mov     edx, [esp+arg_4]
.text$x:0000925C                 lea     eax, [edx+0Ch]
.text$x:0000925F                 mov     ecx, [edx-24h]
.text$x:00009262                 xor     ecx, eax
.text$x:00009264                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009269                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z
.text$x:0000926E                 jmp     ___CxxFrameHandler3
.text$x:0000926E __ehhandler$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z endp
.text$x:0000926E
.text$x:0000926E ; ---------------------------------------------------------------------------
.text$x:00009273                 align 4
.text$x:00009273 _text$x         ends
.text$x:00009273
.text$mn:00009274 ; ===========================================================================
.text$mn:00009274
.text$mn:00009274 ; Segment type: Pure code
.text$mn:00009274 ; Segment permissions: Read/Execute
.text$mn:00009274 _text$mn        segment para public 'CODE' use32
.text$mn:00009274                 assume cs:_text$mn
.text$mn:00009274                 ;org 9274h
.text$mn:00009274 ; COMDAT (pick any)
.text$mn:00009274                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009274
.text$mn:00009274 ; =============== S U B R O U T I N E =======================================
.text$mn:00009274
.text$mn:00009274 ; Attributes: bp-based frame
.text$mn:00009274
.text$mn:00009274 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Reallocate(unsigned int)
.text$mn:00009274                 public ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:00009274 ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z proc near
.text$mn:00009274                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+4Ep
.text$mn:00009274
.text$mn:00009274 var_20          = dword ptr -20h
.text$mn:00009274 var_1C          = dword ptr -1Ch
.text$mn:00009274 var_18          = dword ptr -18h
.text$mn:00009274 var_13          = byte ptr -13h
.text$mn:00009274 var_11          = byte ptr -11h
.text$mn:00009274 var_10          = dword ptr -10h
.text$mn:00009274 var_C           = dword ptr -0Ch
.text$mn:00009274 var_4           = dword ptr -4
.text$mn:00009274 arg_0           = dword ptr  8
.text$mn:00009274
.text$mn:00009274 ; FUNCTION CHUNK AT .text$mn:0000930A SIZE 00000009 BYTES
.text$mn:00009274 ; FUNCTION CHUNK AT .text$mn:0000931A SIZE 00000098 BYTES
.text$mn:00009274
.text$mn:00009274                 push    ebp
.text$mn:00009275                 mov     ebp, esp
.text$mn:00009277                 push    0FFFFFFFFh
.text$mn:00009279                 push    offset __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000927E                 mov     eax, large fs:0
.text$mn:00009284                 push    eax
.text$mn:00009285                 push    ecx
.text$mn:00009286                 sub     esp, 10h
.text$mn:00009289                 push    ebx
.text$mn:0000928A                 push    esi
.text$mn:0000928B                 push    edi
.text$mn:0000928C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009291                 xor     eax, ebp
.text$mn:00009293                 push    eax
.text$mn:00009294                 lea     eax, [ebp+var_C]
.text$mn:00009297                 mov     large fs:0, eax
.text$mn:0000929D                 mov     [ebp+var_10], esp
.text$mn:000092A0                 mov     [ebp+var_18], ecx
.text$mn:000092A3                 mov     eax, [ebp+arg_0]
.text$mn:000092A6                 push    eax
.text$mn:000092A7                 lea     ecx, [ebp+var_11]
.text$mn:000092AA                 push    ecx
.text$mn:000092AB                 mov     ecx, [ebp+var_18]
.text$mn:000092AE                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:000092B3                 mov     ecx, eax
.text$mn:000092B5                 call    ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::allocate(uint)
.text$mn:000092BA                 mov     [ebp+var_1C], eax
.text$mn:000092BD                 mov     [ebp+var_4], 0
.text$mn:000092C4                 mov     edx, [ebp+var_1C]
.text$mn:000092C7                 push    edx
.text$mn:000092C8                 mov     eax, [ebp+var_18]
.text$mn:000092CB                 mov     ecx, [eax+8]
.text$mn:000092CE                 push    ecx
.text$mn:000092CF                 mov     edx, [ebp+var_18]
.text$mn:000092D2                 mov     eax, [edx+4]
.text$mn:000092D5                 push    eax
.text$mn:000092D6                 mov     ecx, [ebp+var_18]
.text$mn:000092D9                 call    ??$_Umove@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PAV21@00@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:000092DE                 jmp     short loc_930A
.text$mn:000092DE ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z endp
.text$mn:000092DE
.text$mn:000092E0
.text$mn:000092E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000092E0
.text$mn:000092E0 ; Attributes: noreturn
.text$mn:000092E0
.text$mn:000092E0 __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0 proc near
.text$mn:000092E0                                         ; DATA XREF: .xdata$x:0000CCA8o
.text$mn:000092E0                 mov     ecx, [ebp+8]
.text$mn:000092E3                 push    ecx             ; int
.text$mn:000092E4                 mov     edx, [ebp-1Ch]
.text$mn:000092E7                 push    edx             ; void *
.text$mn:000092E8                 lea     eax, [ebp-12h]
.text$mn:000092EB                 push    eax
.text$mn:000092EC                 mov     ecx, [ebp-18h]
.text$mn:000092EF                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:000092F4                 mov     ecx, eax
.text$mn:000092F6                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:000092FB                 push    0
.text$mn:000092FD                 push    0
.text$mn:000092FF                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000092FF __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0 endp
.text$mn:000092FF
.text$mn:00009304 ; ---------------------------------------------------------------------------
.text$mn:00009304                 mov     eax, offset $LN8
.text$mn:00009309                 retn
.text$mn:0000930A ; ---------------------------------------------------------------------------
.text$mn:0000930A ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000930A
.text$mn:0000930A loc_930A:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+6Aj
.text$mn:0000930A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009311                 jmp     short loc_931A
.text$mn:00009311 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:00009313
.text$mn:00009313 ; =============== S U B R O U T I N E =======================================
.text$mn:00009313
.text$mn:00009313
.text$mn:00009313 $LN8            proc near               ; DATA XREF: .text$mn:00009304o
.text$mn:00009313                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00009313 $LN8            endp ; sp-analysis failed
.text$mn:00009313
.text$mn:0000931A ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:0000931A
.text$mn:0000931A loc_931A:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+9Dj
.text$mn:0000931A                 mov     ecx, [ebp+var_18]
.text$mn:0000931D                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:00009322                 mov     [ebp+var_20], eax
.text$mn:00009325                 mov     ecx, [ebp+var_18]
.text$mn:00009328                 cmp     dword ptr [ecx+4], 0
.text$mn:0000932C                 jz      short loc_9373
.text$mn:0000932E                 mov     edx, [ebp+var_18]
.text$mn:00009331                 mov     eax, [edx+8]
.text$mn:00009334                 push    eax
.text$mn:00009335                 mov     ecx, [ebp+var_18]
.text$mn:00009338                 mov     edx, [ecx+4]
.text$mn:0000933B                 push    edx
.text$mn:0000933C                 mov     ecx, [ebp+var_18]
.text$mn:0000933F                 call    ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00009344                 mov     eax, [ebp+var_18]
.text$mn:00009347                 mov     ecx, [ebp+var_18]
.text$mn:0000934A                 mov     eax, [eax+0Ch]
.text$mn:0000934D                 sub     eax, [ecx+4]
.text$mn:00009350                 cdq
.text$mn:00009351                 mov     ecx, 1Ch
.text$mn:00009356                 idiv    ecx
.text$mn:00009358                 push    eax             ; int
.text$mn:00009359                 mov     edx, [ebp+var_18]
.text$mn:0000935C                 mov     eax, [edx+4]
.text$mn:0000935F                 push    eax             ; void *
.text$mn:00009360                 lea     ecx, [ebp+var_13]
.text$mn:00009363                 push    ecx
.text$mn:00009364                 mov     ecx, [ebp+var_18]
.text$mn:00009367                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000936C                 mov     ecx, eax
.text$mn:0000936E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:00009373
.text$mn:00009373 loc_9373:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+B8j
.text$mn:00009373                 mov     ecx, [ebp+var_18] ; this
.text$mn:00009376                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000937B                 imul    edx, [ebp+arg_0], 1Ch
.text$mn:0000937F                 add     edx, [ebp+var_1C]
.text$mn:00009382                 mov     eax, [ebp+var_18]
.text$mn:00009385                 mov     [eax+0Ch], edx
.text$mn:00009388                 imul    ecx, [ebp+var_20], 1Ch
.text$mn:0000938C                 add     ecx, [ebp+var_1C]
.text$mn:0000938F                 mov     edx, [ebp+var_18]
.text$mn:00009392                 mov     [edx+8], ecx
.text$mn:00009395                 mov     eax, [ebp+var_18]
.text$mn:00009398                 mov     ecx, [ebp+var_1C]
.text$mn:0000939B                 mov     [eax+4], ecx
.text$mn:0000939E                 mov     ecx, [ebp+var_C]
.text$mn:000093A1                 mov     large fs:0, ecx
.text$mn:000093A8                 pop     ecx
.text$mn:000093A9                 pop     edi
.text$mn:000093AA                 pop     esi
.text$mn:000093AB                 pop     ebx
.text$mn:000093AC                 mov     esp, ebp
.text$mn:000093AE                 pop     ebp
.text$mn:000093AF                 retn    4
.text$mn:000093AF ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:000093AF ; ---------------------------------------------------------------------------
.text$mn:000093B2                 align 4
.text$mn:000093B2 _text$mn        ends
.text$mn:000093B2
.text$x:000093B4 ; ===========================================================================
.text$x:000093B4
.text$x:000093B4 ; Segment type: Pure code
.text$x:000093B4 ; Segment permissions: Read/Execute
.text$x:000093B4 _text$x         segment para public 'CODE' use32
.text$x:000093B4                 assume cs:_text$x
.text$x:000093B4                 ;org 93B4h
.text$x:000093B4 ; COMDAT (pick associative to section at 9274)
.text$x:000093B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000093B4
.text$x:000093B4 ; =============== S U B R O U T I N E =======================================
.text$x:000093B4
.text$x:000093B4
.text$x:000093B4 __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z proc near
.text$x:000093B4                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+5o
.text$x:000093B4
.text$x:000093B4 arg_4           = dword ptr  8
.text$x:000093B4
.text$x:000093B4                 mov     edx, [esp+arg_4]
.text$x:000093B8                 lea     eax, [edx+0Ch]
.text$x:000093BB                 mov     ecx, [edx-24h]
.text$x:000093BE                 xor     ecx, eax
.text$x:000093C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000093C5                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$x:000093CA                 jmp     ___CxxFrameHandler3
.text$x:000093CA __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z endp
.text$x:000093CA
.text$x:000093CA ; ---------------------------------------------------------------------------
.text$x:000093CF                 align 10h
.text$x:000093CF _text$x         ends
.text$x:000093CF
.text$mn:000093D0 ; ===========================================================================
.text$mn:000093D0
.text$mn:000093D0 ; Segment type: Pure code
.text$mn:000093D0 ; Segment permissions: Read/Execute
.text$mn:000093D0 _text$mn        segment para public 'CODE' use32
.text$mn:000093D0                 assume cs:_text$mn
.text$mn:000093D0                 ;org 93D0h
.text$mn:000093D0 ; COMDAT (pick any)
.text$mn:000093D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000093D0
.text$mn:000093D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000093D0
.text$mn:000093D0 ; Attributes: bp-based frame
.text$mn:000093D0
.text$mn:000093D0 ; protected: void __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::_Reallocate(unsigned int)
.text$mn:000093D0                 public ?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z
.text$mn:000093D0 ?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z proc near
.text$mn:000093D0                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reserve(uint)+4Ep
.text$mn:000093D0
.text$mn:000093D0 var_20          = dword ptr -20h
.text$mn:000093D0 var_1C          = dword ptr -1Ch
.text$mn:000093D0 var_18          = dword ptr -18h
.text$mn:000093D0 var_13          = byte ptr -13h
.text$mn:000093D0 var_11          = byte ptr -11h
.text$mn:000093D0 var_10          = dword ptr -10h
.text$mn:000093D0 var_C           = dword ptr -0Ch
.text$mn:000093D0 var_4           = dword ptr -4
.text$mn:000093D0 arg_0           = dword ptr  8
.text$mn:000093D0
.text$mn:000093D0 ; FUNCTION CHUNK AT .text$mn:00009466 SIZE 00000009 BYTES
.text$mn:000093D0 ; FUNCTION CHUNK AT .text$mn:00009476 SIZE 0000009E BYTES
.text$mn:000093D0
.text$mn:000093D0                 push    ebp
.text$mn:000093D1                 mov     ebp, esp
.text$mn:000093D3                 push    0FFFFFFFFh
.text$mn:000093D5                 push    offset __ehhandler$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z
.text$mn:000093DA                 mov     eax, large fs:0
.text$mn:000093E0                 push    eax
.text$mn:000093E1                 push    ecx
.text$mn:000093E2                 sub     esp, 10h
.text$mn:000093E5                 push    ebx
.text$mn:000093E6                 push    esi
.text$mn:000093E7                 push    edi
.text$mn:000093E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000093ED                 xor     eax, ebp
.text$mn:000093EF                 push    eax
.text$mn:000093F0                 lea     eax, [ebp+var_C]
.text$mn:000093F3                 mov     large fs:0, eax
.text$mn:000093F9                 mov     [ebp+var_10], esp
.text$mn:000093FC                 mov     [ebp+var_18], ecx
.text$mn:000093FF                 mov     eax, [ebp+arg_0]
.text$mn:00009402                 push    eax
.text$mn:00009403                 lea     ecx, [ebp+var_11]
.text$mn:00009406                 push    ecx
.text$mn:00009407                 mov     ecx, [ebp+var_18]
.text$mn:0000940A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>>::_Getal(void)
.text$mn:0000940F                 mov     ecx, eax
.text$mn:00009411                 call    ?allocate@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEPAVPluginCmdShortcut@@I@Z ; std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::allocate(uint)
.text$mn:00009416                 mov     [ebp+var_1C], eax
.text$mn:00009419                 mov     [ebp+var_4], 0
.text$mn:00009420                 mov     edx, [ebp+var_1C]
.text$mn:00009423                 push    edx
.text$mn:00009424                 mov     eax, [ebp+var_18]
.text$mn:00009427                 mov     ecx, [eax+8]
.text$mn:0000942A                 push    ecx
.text$mn:0000942B                 mov     edx, [ebp+var_18]
.text$mn:0000942E                 mov     eax, [edx+4]
.text$mn:00009431                 push    eax
.text$mn:00009432                 mov     ecx, [ebp+var_18]
.text$mn:00009435                 call    ??$_Umove@PAVPluginCmdShortcut@@@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEPAVPluginCmdShortcut@@PAV2@00@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Umove<PluginCmdShortcut *>(PluginCmdShortcut *,PluginCmdShortcut *,PluginCmdShortcut *)
.text$mn:0000943A                 jmp     short loc_9466
.text$mn:0000943A ?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z endp
.text$mn:0000943A
.text$mn:0000943C
.text$mn:0000943C ; =============== S U B R O U T I N E =======================================
.text$mn:0000943C
.text$mn:0000943C ; Attributes: noreturn
.text$mn:0000943C
.text$mn:0000943C __catch$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:0000943C                                         ; DATA XREF: .xdata$x:0000CF18o
.text$mn:0000943C                 mov     ecx, [ebp+8]
.text$mn:0000943F                 push    ecx             ; int
.text$mn:00009440                 mov     edx, [ebp-1Ch]
.text$mn:00009443                 push    edx             ; void *
.text$mn:00009444                 lea     eax, [ebp-12h]
.text$mn:00009447                 push    eax
.text$mn:00009448                 mov     ecx, [ebp-18h]
.text$mn:0000944B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>>::_Getal(void)
.text$mn:00009450                 mov     ecx, eax
.text$mn:00009452                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@I@Z ; std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::deallocate(PluginCmdShortcut *,uint)
.text$mn:00009457                 push    0
.text$mn:00009459                 push    0
.text$mn:0000945B                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000945B __catch$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:0000945B
.text$mn:00009460 ; ---------------------------------------------------------------------------
.text$mn:00009460                 mov     eax, offset $LN8_2
.text$mn:00009465                 retn
.text$mn:00009466 ; ---------------------------------------------------------------------------
.text$mn:00009466 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z
.text$mn:00009466
.text$mn:00009466 loc_9466:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reallocate(uint)+6Aj
.text$mn:00009466                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000946D                 jmp     short loc_9476
.text$mn:0000946D ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z
.text$mn:0000946F
.text$mn:0000946F ; =============== S U B R O U T I N E =======================================
.text$mn:0000946F
.text$mn:0000946F
.text$mn:0000946F $LN8_2          proc near               ; DATA XREF: .text$mn:00009460o
.text$mn:0000946F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000946F $LN8_2          endp ; sp-analysis failed
.text$mn:0000946F
.text$mn:00009476 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z
.text$mn:00009476
.text$mn:00009476 loc_9476:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reallocate(uint)+9Dj
.text$mn:00009476                 mov     ecx, [ebp+var_18]
.text$mn:00009479                 call    ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::size(void)
.text$mn:0000947E                 mov     [ebp+var_20], eax
.text$mn:00009481                 mov     ecx, [ebp+var_18]
.text$mn:00009484                 cmp     dword ptr [ecx+4], 0
.text$mn:00009488                 jz      short loc_94CF
.text$mn:0000948A                 mov     edx, [ebp+var_18]
.text$mn:0000948D                 mov     eax, [edx+8]
.text$mn:00009490                 push    eax
.text$mn:00009491                 mov     ecx, [ebp+var_18]
.text$mn:00009494                 mov     edx, [ecx+4]
.text$mn:00009497                 push    edx
.text$mn:00009498                 mov     ecx, [ebp+var_18]
.text$mn:0000949B                 call    ?_Destroy@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXPAVPluginCmdShortcut@@0@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Destroy(PluginCmdShortcut *,PluginCmdShortcut *)
.text$mn:000094A0                 mov     eax, [ebp+var_18]
.text$mn:000094A3                 mov     ecx, [ebp+var_18]
.text$mn:000094A6                 mov     eax, [eax+0Ch]
.text$mn:000094A9                 sub     eax, [ecx+4]
.text$mn:000094AC                 cdq
.text$mn:000094AD                 mov     ecx, 150h
.text$mn:000094B2                 idiv    ecx
.text$mn:000094B4                 push    eax             ; int
.text$mn:000094B5                 mov     edx, [ebp+var_18]
.text$mn:000094B8                 mov     eax, [edx+4]
.text$mn:000094BB                 push    eax             ; void *
.text$mn:000094BC                 lea     ecx, [ebp+var_13]
.text$mn:000094BF                 push    ecx
.text$mn:000094C0                 mov     ecx, [ebp+var_18]
.text$mn:000094C3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>>::_Getal(void)
.text$mn:000094C8                 mov     ecx, eax
.text$mn:000094CA                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@I@Z ; std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::deallocate(PluginCmdShortcut *,uint)
.text$mn:000094CF
.text$mn:000094CF loc_94CF:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reallocate(uint)+B8j
.text$mn:000094CF                 mov     ecx, [ebp+var_18] ; this
.text$mn:000094D2                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000094D7                 imul    edx, [ebp+arg_0], 150h
.text$mn:000094DE                 add     edx, [ebp+var_1C]
.text$mn:000094E1                 mov     eax, [ebp+var_18]
.text$mn:000094E4                 mov     [eax+0Ch], edx
.text$mn:000094E7                 imul    ecx, [ebp+var_20], 150h
.text$mn:000094EE                 add     ecx, [ebp+var_1C]
.text$mn:000094F1                 mov     edx, [ebp+var_18]
.text$mn:000094F4                 mov     [edx+8], ecx
.text$mn:000094F7                 mov     eax, [ebp+var_18]
.text$mn:000094FA                 mov     ecx, [ebp+var_1C]
.text$mn:000094FD                 mov     [eax+4], ecx
.text$mn:00009500                 mov     ecx, [ebp+var_C]
.text$mn:00009503                 mov     large fs:0, ecx
.text$mn:0000950A                 pop     ecx
.text$mn:0000950B                 pop     edi
.text$mn:0000950C                 pop     esi
.text$mn:0000950D                 pop     ebx
.text$mn:0000950E                 mov     esp, ebp
.text$mn:00009510                 pop     ebp
.text$mn:00009511                 retn    4
.text$mn:00009511 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z
.text$mn:00009511 _text$mn        ends
.text$mn:00009511
.text$x:00009514 ; ===========================================================================
.text$x:00009514
.text$x:00009514 ; Segment type: Pure code
.text$x:00009514 ; Segment permissions: Read/Execute
.text$x:00009514 _text$x         segment para public 'CODE' use32
.text$x:00009514                 assume cs:_text$x
.text$x:00009514                 ;org 9514h
.text$x:00009514 ; COMDAT (pick associative to section at 93D0)
.text$x:00009514                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009514
.text$x:00009514 ; =============== S U B R O U T I N E =======================================
.text$x:00009514
.text$x:00009514
.text$x:00009514 __ehhandler$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z proc near
.text$x:00009514                                         ; DATA XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reallocate(uint)+5o
.text$x:00009514
.text$x:00009514 arg_4           = dword ptr  8
.text$x:00009514
.text$x:00009514                 mov     edx, [esp+arg_4]
.text$x:00009518                 lea     eax, [edx+0Ch]
.text$x:0000951B                 mov     ecx, [edx-24h]
.text$x:0000951E                 xor     ecx, eax
.text$x:00009520                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009525                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z
.text$x:0000952A                 jmp     ___CxxFrameHandler3
.text$x:0000952A __ehhandler$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z endp
.text$x:0000952A
.text$x:0000952A ; ---------------------------------------------------------------------------
.text$x:0000952F                 align 10h
.text$x:0000952F _text$x         ends
.text$x:0000952F
.text$mn:00009530 ; ===========================================================================
.text$mn:00009530
.text$mn:00009530 ; Segment type: Pure code
.text$mn:00009530 ; Segment permissions: Read/Execute
.text$mn:00009530 _text$mn        segment para public 'CODE' use32
.text$mn:00009530                 assume cs:_text$mn
.text$mn:00009530                 ;org 9530h
.text$mn:00009530 ; COMDAT (pick any)
.text$mn:00009530                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009530
.text$mn:00009530 ; =============== S U B R O U T I N E =======================================
.text$mn:00009530
.text$mn:00009530 ; Attributes: bp-based frame
.text$mn:00009530
.text$mn:00009530 ; protected: void __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::_Reserve(unsigned int)
.text$mn:00009530                 public ?_Reserve@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z
.text$mn:00009530 ?_Reserve@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z proc near
.text$mn:00009530                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+50p
.text$mn:00009530                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+B6p
.text$mn:00009530
.text$mn:00009530 var_4           = dword ptr -4
.text$mn:00009530 arg_0           = dword ptr  8
.text$mn:00009530
.text$mn:00009530                 push    ebp
.text$mn:00009531                 mov     ebp, esp
.text$mn:00009533                 push    ecx
.text$mn:00009534                 push    esi
.text$mn:00009535                 mov     [ebp+var_4], ecx
.text$mn:00009538                 mov     ecx, [ebp+var_4]
.text$mn:0000953B                 call    ?_Unused_capacity@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Unused_capacity(void)
.text$mn:00009540                 cmp     eax, [ebp+arg_0]
.text$mn:00009543                 jnb     short loc_9583
.text$mn:00009545                 mov     ecx, [ebp+var_4]
.text$mn:00009548                 call    ?max_size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::max_size(void)
.text$mn:0000954D                 mov     esi, eax
.text$mn:0000954F                 mov     ecx, [ebp+var_4]
.text$mn:00009552                 call    ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::size(void)
.text$mn:00009557                 sub     esi, eax
.text$mn:00009559                 cmp     esi, [ebp+arg_0]
.text$mn:0000955C                 jnb     short loc_9566
.text$mn:0000955E                 mov     ecx, [ebp+var_4]
.text$mn:00009561                 call    ?_Xlen@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Xlen(void)
.text$mn:00009566
.text$mn:00009566 loc_9566:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reserve(uint)+2Cj
.text$mn:00009566                 mov     ecx, [ebp+var_4]
.text$mn:00009569                 call    ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::size(void)
.text$mn:0000956E                 add     eax, [ebp+arg_0]
.text$mn:00009571                 push    eax
.text$mn:00009572                 mov     ecx, [ebp+var_4]
.text$mn:00009575                 call    ?_Grow_to@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEII@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Grow_to(uint)
.text$mn:0000957A                 push    eax
.text$mn:0000957B                 mov     ecx, [ebp+var_4]
.text$mn:0000957E                 call    ?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reallocate(uint)
.text$mn:00009583
.text$mn:00009583 loc_9583:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reserve(uint)+13j
.text$mn:00009583                 pop     esi
.text$mn:00009584                 mov     esp, ebp
.text$mn:00009586                 pop     ebp
.text$mn:00009587                 retn    4
.text$mn:00009587 ?_Reserve@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z endp
.text$mn:00009587
.text$mn:00009587 ; ---------------------------------------------------------------------------
.text$mn:0000958A                 align 4
.text$mn:0000958A _text$mn        ends
.text$mn:0000958A
.text$mn:0000958C ; ===========================================================================
.text$mn:0000958C
.text$mn:0000958C ; Segment type: Pure code
.text$mn:0000958C ; Segment permissions: Read/Execute
.text$mn:0000958C _text$mn        segment para public 'CODE' use32
.text$mn:0000958C                 assume cs:_text$mn
.text$mn:0000958C                 ;org 958Ch
.text$mn:0000958C ; COMDAT (pick any)
.text$mn:0000958C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000958C
.text$mn:0000958C ; =============== S U B R O U T I N E =======================================
.text$mn:0000958C
.text$mn:0000958C ; Attributes: bp-based frame
.text$mn:0000958C
.text$mn:0000958C ; protected: void __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::_Reserve(unsigned int)
.text$mn:0000958C                 public ?_Reserve@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z
.text$mn:0000958C ?_Reserve@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z proc near
.text$mn:0000958C                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+50p
.text$mn:0000958C                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+B6p
.text$mn:0000958C
.text$mn:0000958C var_4           = dword ptr -4
.text$mn:0000958C arg_0           = dword ptr  8
.text$mn:0000958C
.text$mn:0000958C                 push    ebp
.text$mn:0000958D                 mov     ebp, esp
.text$mn:0000958F                 push    ecx
.text$mn:00009590                 push    esi
.text$mn:00009591                 mov     [ebp+var_4], ecx
.text$mn:00009594                 mov     ecx, [ebp+var_4]
.text$mn:00009597                 call    ?_Unused_capacity@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Unused_capacity(void)
.text$mn:0000959C                 cmp     eax, [ebp+arg_0]
.text$mn:0000959F                 jnb     short loc_95DF
.text$mn:000095A1                 mov     ecx, [ebp+var_4]
.text$mn:000095A4                 call    ?max_size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::max_size(void)
.text$mn:000095A9                 mov     esi, eax
.text$mn:000095AB                 mov     ecx, [ebp+var_4]
.text$mn:000095AE                 call    ?size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::size(void)
.text$mn:000095B3                 sub     esi, eax
.text$mn:000095B5                 cmp     esi, [ebp+arg_0]
.text$mn:000095B8                 jnb     short loc_95C2
.text$mn:000095BA                 mov     ecx, [ebp+var_4]
.text$mn:000095BD                 call    ?_Xlen@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXXZ ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Xlen(void)
.text$mn:000095C2
.text$mn:000095C2 loc_95C2:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reserve(uint)+2Cj
.text$mn:000095C2                 mov     ecx, [ebp+var_4]
.text$mn:000095C5                 call    ?size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::size(void)
.text$mn:000095CA                 add     eax, [ebp+arg_0]
.text$mn:000095CD                 push    eax
.text$mn:000095CE                 mov     ecx, [ebp+var_4]
.text$mn:000095D1                 call    ?_Grow_to@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEII@Z ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Grow_to(uint)
.text$mn:000095D6                 push    eax
.text$mn:000095D7                 mov     ecx, [ebp+var_4]
.text$mn:000095DA                 call    ?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reallocate(uint)
.text$mn:000095DF
.text$mn:000095DF loc_95DF:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reserve(uint)+13j
.text$mn:000095DF                 pop     esi
.text$mn:000095E0                 mov     esp, ebp
.text$mn:000095E2                 pop     ebp
.text$mn:000095E3                 retn    4
.text$mn:000095E3 ?_Reserve@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z endp
.text$mn:000095E3
.text$mn:000095E3 ; ---------------------------------------------------------------------------
.text$mn:000095E6                 align 4
.text$mn:000095E6 _text$mn        ends
.text$mn:000095E6
.text$mn:000095E8 ; ===========================================================================
.text$mn:000095E8
.text$mn:000095E8 ; Segment type: Pure code
.text$mn:000095E8 ; Segment permissions: Read/Execute
.text$mn:000095E8 _text$mn        segment para public 'CODE' use32
.text$mn:000095E8                 assume cs:_text$mn
.text$mn:000095E8                 ;org 95E8h
.text$mn:000095E8 ; COMDAT (pick any)
.text$mn:000095E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000095E8
.text$mn:000095E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000095E8
.text$mn:000095E8 ; Attributes: bp-based frame
.text$mn:000095E8
.text$mn:000095E8 ; protected: void __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::_Reserve(unsigned int)
.text$mn:000095E8                 public ?_Reserve@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z
.text$mn:000095E8 ?_Reserve@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z proc near
.text$mn:000095E8                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+54p
.text$mn:000095E8                                         ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+C3p
.text$mn:000095E8
.text$mn:000095E8 var_4           = dword ptr -4
.text$mn:000095E8 arg_0           = dword ptr  8
.text$mn:000095E8
.text$mn:000095E8                 push    ebp
.text$mn:000095E9                 mov     ebp, esp
.text$mn:000095EB                 push    ecx
.text$mn:000095EC                 push    esi
.text$mn:000095ED                 mov     [ebp+var_4], ecx
.text$mn:000095F0                 mov     ecx, [ebp+var_4]
.text$mn:000095F3                 call    ?_Unused_capacity@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Unused_capacity(void)
.text$mn:000095F8                 cmp     eax, [ebp+arg_0]
.text$mn:000095FB                 jnb     short loc_963B
.text$mn:000095FD                 mov     ecx, [ebp+var_4]
.text$mn:00009600                 call    ?max_size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::max_size(void)
.text$mn:00009605                 mov     esi, eax
.text$mn:00009607                 mov     ecx, [ebp+var_4]
.text$mn:0000960A                 call    ?size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::size(void)
.text$mn:0000960F                 sub     esi, eax
.text$mn:00009611                 cmp     esi, [ebp+arg_0]
.text$mn:00009614                 jnb     short loc_961E
.text$mn:00009616                 mov     ecx, [ebp+var_4]
.text$mn:00009619                 call    ?_Xlen@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXXZ ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Xlen(void)
.text$mn:0000961E
.text$mn:0000961E loc_961E:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reserve(uint)+2Cj
.text$mn:0000961E                 mov     ecx, [ebp+var_4]
.text$mn:00009621                 call    ?size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::size(void)
.text$mn:00009626                 add     eax, [ebp+arg_0]
.text$mn:00009629                 push    eax
.text$mn:0000962A                 mov     ecx, [ebp+var_4]
.text$mn:0000962D                 call    ?_Grow_to@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEII@Z ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Grow_to(uint)
.text$mn:00009632                 push    eax
.text$mn:00009633                 mov     ecx, [ebp+var_4]
.text$mn:00009636                 call    ?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reallocate(uint)
.text$mn:0000963B
.text$mn:0000963B loc_963B:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reserve(uint)+13j
.text$mn:0000963B                 pop     esi
.text$mn:0000963C                 mov     esp, ebp
.text$mn:0000963E                 pop     ebp
.text$mn:0000963F                 retn    4
.text$mn:0000963F ?_Reserve@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z endp
.text$mn:0000963F
.text$mn:0000963F ; ---------------------------------------------------------------------------
.text$mn:00009642                 align 4
.text$mn:00009642 _text$mn        ends
.text$mn:00009642
.text$mn:00009644 ; ===========================================================================
.text$mn:00009644
.text$mn:00009644 ; Segment type: Pure code
.text$mn:00009644 ; Segment permissions: Read/Execute
.text$mn:00009644 _text$mn        segment para public 'CODE' use32
.text$mn:00009644                 assume cs:_text$mn
.text$mn:00009644                 ;org 9644h
.text$mn:00009644 ; COMDAT (pick any)
.text$mn:00009644                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009644
.text$mn:00009644 ; =============== S U B R O U T I N E =======================================
.text$mn:00009644
.text$mn:00009644 ; Attributes: bp-based frame
.text$mn:00009644
.text$mn:00009644 ; protected: void __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::_Reserve(unsigned int)
.text$mn:00009644                 public ?_Reserve@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z
.text$mn:00009644 ?_Reserve@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z proc near
.text$mn:00009644                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+59p
.text$mn:00009644                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+C6p
.text$mn:00009644
.text$mn:00009644 var_4           = dword ptr -4
.text$mn:00009644 arg_0           = dword ptr  8
.text$mn:00009644
.text$mn:00009644                 push    ebp
.text$mn:00009645                 mov     ebp, esp
.text$mn:00009647                 push    ecx
.text$mn:00009648                 push    esi
.text$mn:00009649                 mov     [ebp+var_4], ecx
.text$mn:0000964C                 mov     ecx, [ebp+var_4]
.text$mn:0000964F                 call    ?_Unused_capacity@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Unused_capacity(void)
.text$mn:00009654                 cmp     eax, [ebp+arg_0]
.text$mn:00009657                 jnb     short loc_9697
.text$mn:00009659                 mov     ecx, [ebp+var_4]
.text$mn:0000965C                 call    ?max_size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::max_size(void)
.text$mn:00009661                 mov     esi, eax
.text$mn:00009663                 mov     ecx, [ebp+var_4]
.text$mn:00009666                 call    ?size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::size(void)
.text$mn:0000966B                 sub     esi, eax
.text$mn:0000966D                 cmp     esi, [ebp+arg_0]
.text$mn:00009670                 jnb     short loc_967A
.text$mn:00009672                 mov     ecx, [ebp+var_4]
.text$mn:00009675                 call    ?_Xlen@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Xlen(void)
.text$mn:0000967A
.text$mn:0000967A loc_967A:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reserve(uint)+2Cj
.text$mn:0000967A                 mov     ecx, [ebp+var_4]
.text$mn:0000967D                 call    ?size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::vector<PluginCommand,std::allocator<PluginCommand>>::size(void)
.text$mn:00009682                 add     eax, [ebp+arg_0]
.text$mn:00009685                 push    eax
.text$mn:00009686                 mov     ecx, [ebp+var_4]
.text$mn:00009689                 call    ?_Grow_to@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEII@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Grow_to(uint)
.text$mn:0000968E                 push    eax
.text$mn:0000968F                 mov     ecx, [ebp+var_4]
.text$mn:00009692                 call    ?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reallocate(uint)
.text$mn:00009697
.text$mn:00009697 loc_9697:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reserve(uint)+13j
.text$mn:00009697                 pop     esi
.text$mn:00009698                 mov     esp, ebp
.text$mn:0000969A                 pop     ebp
.text$mn:0000969B                 retn    4
.text$mn:0000969B ?_Reserve@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z endp
.text$mn:0000969B
.text$mn:0000969B ; ---------------------------------------------------------------------------
.text$mn:0000969E                 align 10h
.text$mn:0000969E _text$mn        ends
.text$mn:0000969E
.text$mn:000096A0 ; ===========================================================================
.text$mn:000096A0
.text$mn:000096A0 ; Segment type: Pure code
.text$mn:000096A0 ; Segment permissions: Read/Execute
.text$mn:000096A0 _text$mn        segment para public 'CODE' use32
.text$mn:000096A0                 assume cs:_text$mn
.text$mn:000096A0                 ;org 96A0h
.text$mn:000096A0 ; COMDAT (pick any)
.text$mn:000096A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000096A0
.text$mn:000096A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000096A0
.text$mn:000096A0 ; Attributes: bp-based frame
.text$mn:000096A0
.text$mn:000096A0 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Reserve(unsigned int)
.text$mn:000096A0                 public ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.text$mn:000096A0 ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z proc near
.text$mn:000096A0                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+59p
.text$mn:000096A0                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+C6p ...
.text$mn:000096A0
.text$mn:000096A0 var_4           = dword ptr -4
.text$mn:000096A0 arg_0           = dword ptr  8
.text$mn:000096A0
.text$mn:000096A0                 push    ebp
.text$mn:000096A1                 mov     ebp, esp
.text$mn:000096A3                 push    ecx
.text$mn:000096A4                 push    esi
.text$mn:000096A5                 mov     [ebp+var_4], ecx
.text$mn:000096A8                 mov     ecx, [ebp+var_4]
.text$mn:000096AB                 call    ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Unused_capacity(void)
.text$mn:000096B0                 cmp     eax, [ebp+arg_0]
.text$mn:000096B3                 jnb     short loc_96F3
.text$mn:000096B5                 mov     ecx, [ebp+var_4]
.text$mn:000096B8                 call    ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)
.text$mn:000096BD                 mov     esi, eax
.text$mn:000096BF                 mov     ecx, [ebp+var_4]
.text$mn:000096C2                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:000096C7                 sub     esi, eax
.text$mn:000096C9                 cmp     esi, [ebp+arg_0]
.text$mn:000096CC                 jnb     short loc_96D6
.text$mn:000096CE                 mov     ecx, [ebp+var_4]
.text$mn:000096D1                 call    ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Xlen(void)
.text$mn:000096D6
.text$mn:000096D6 loc_96D6:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+2Cj
.text$mn:000096D6                 mov     ecx, [ebp+var_4]
.text$mn:000096D9                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:000096DE                 add     eax, [ebp+arg_0]
.text$mn:000096E1                 push    eax
.text$mn:000096E2                 mov     ecx, [ebp+var_4]
.text$mn:000096E5                 call    ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEII@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)
.text$mn:000096EA                 push    eax
.text$mn:000096EB                 mov     ecx, [ebp+var_4]
.text$mn:000096EE                 call    ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)
.text$mn:000096F3
.text$mn:000096F3 loc_96F3:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+13j
.text$mn:000096F3                 pop     esi
.text$mn:000096F4                 mov     esp, ebp
.text$mn:000096F6                 pop     ebp
.text$mn:000096F7                 retn    4
.text$mn:000096F7 ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z endp
.text$mn:000096F7
.text$mn:000096F7 ; ---------------------------------------------------------------------------
.text$mn:000096FA                 align 4
.text$mn:000096FA _text$mn        ends
.text$mn:000096FA
.text$mn:000096FC ; ===========================================================================
.text$mn:000096FC
.text$mn:000096FC ; Segment type: Pure code
.text$mn:000096FC ; Segment permissions: Read/Execute
.text$mn:000096FC _text$mn        segment para public 'CODE' use32
.text$mn:000096FC                 assume cs:_text$mn
.text$mn:000096FC                 ;org 96FCh
.text$mn:000096FC ; COMDAT (pick any)
.text$mn:000096FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000096FC
.text$mn:000096FC ; =============== S U B R O U T I N E =======================================
.text$mn:000096FC
.text$mn:000096FC ; Attributes: bp-based frame
.text$mn:000096FC
.text$mn:000096FC ; protected: void __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::_Reserve(unsigned int)
.text$mn:000096FC                 public ?_Reserve@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z
.text$mn:000096FC ?_Reserve@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z proc near
.text$mn:000096FC                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+59p
.text$mn:000096FC                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+C2p
.text$mn:000096FC
.text$mn:000096FC var_4           = dword ptr -4
.text$mn:000096FC arg_0           = dword ptr  8
.text$mn:000096FC
.text$mn:000096FC                 push    ebp
.text$mn:000096FD                 mov     ebp, esp
.text$mn:000096FF                 push    ecx
.text$mn:00009700                 push    esi
.text$mn:00009701                 mov     [ebp+var_4], ecx
.text$mn:00009704                 mov     ecx, [ebp+var_4]
.text$mn:00009707                 call    ?_Unused_capacity@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Unused_capacity(void)
.text$mn:0000970C                 cmp     eax, [ebp+arg_0]
.text$mn:0000970F                 jnb     short loc_974F
.text$mn:00009711                 mov     ecx, [ebp+var_4]
.text$mn:00009714                 call    ?max_size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::max_size(void)
.text$mn:00009719                 mov     esi, eax
.text$mn:0000971B                 mov     ecx, [ebp+var_4]
.text$mn:0000971E                 call    ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::size(void)
.text$mn:00009723                 sub     esi, eax
.text$mn:00009725                 cmp     esi, [ebp+arg_0]
.text$mn:00009728                 jnb     short loc_9732
.text$mn:0000972A                 mov     ecx, [ebp+var_4]
.text$mn:0000972D                 call    ?_Xlen@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Xlen(void)
.text$mn:00009732
.text$mn:00009732 loc_9732:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reserve(uint)+2Cj
.text$mn:00009732                 mov     ecx, [ebp+var_4]
.text$mn:00009735                 call    ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::size(void)
.text$mn:0000973A                 add     eax, [ebp+arg_0]
.text$mn:0000973D                 push    eax
.text$mn:0000973E                 mov     ecx, [ebp+var_4]
.text$mn:00009741                 call    ?_Grow_to@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEII@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Grow_to(uint)
.text$mn:00009746                 push    eax
.text$mn:00009747                 mov     ecx, [ebp+var_4]
.text$mn:0000974A                 call    ?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reallocate(uint)
.text$mn:0000974F
.text$mn:0000974F loc_974F:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reserve(uint)+13j
.text$mn:0000974F                 pop     esi
.text$mn:00009750                 mov     esp, ebp
.text$mn:00009752                 pop     ebp
.text$mn:00009753                 retn    4
.text$mn:00009753 ?_Reserve@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z endp
.text$mn:00009753
.text$mn:00009753 ; ---------------------------------------------------------------------------
.text$mn:00009756                 align 4
.text$mn:00009756 _text$mn        ends
.text$mn:00009756
.text$mn:00009758 ; ===========================================================================
.text$mn:00009758
.text$mn:00009758 ; Segment type: Pure code
.text$mn:00009758 ; Segment permissions: Read/Execute
.text$mn:00009758 _text$mn        segment para public 'CODE' use32
.text$mn:00009758                 assume cs:_text$mn
.text$mn:00009758                 ;org 9758h
.text$mn:00009758 ; COMDAT (pick any)
.text$mn:00009758                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009758
.text$mn:00009758 ; =============== S U B R O U T I N E =======================================
.text$mn:00009758
.text$mn:00009758 ; Attributes: bp-based frame
.text$mn:00009758
.text$mn:00009758 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00009758                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00009758 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00009758                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00009758                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00009758
.text$mn:00009758 var_C           = dword ptr -0Ch
.text$mn:00009758 var_8           = dword ptr -8
.text$mn:00009758 var_2           = byte ptr -2
.text$mn:00009758 var_1           = byte ptr -1
.text$mn:00009758 arg_0           = byte ptr  8
.text$mn:00009758 Size            = dword ptr  0Ch
.text$mn:00009758
.text$mn:00009758                 push    ebp
.text$mn:00009759                 mov     ebp, esp
.text$mn:0000975B                 sub     esp, 0Ch
.text$mn:0000975E                 mov     [ebp+var_8], ecx
.text$mn:00009761                 movzx   eax, [ebp+arg_0]
.text$mn:00009765                 test    eax, eax
.text$mn:00009767                 jnz     short loc_976B
.text$mn:00009769                 jmp     short loc_97DE
.text$mn:0000976B ; ---------------------------------------------------------------------------
.text$mn:0000976B
.text$mn:0000976B loc_976B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000976B                 mov     ecx, [ebp+var_8]
.text$mn:0000976E                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00009772                 jb      short loc_97DE
.text$mn:00009774                 mov     edx, [ebp+var_8]
.text$mn:00009777                 mov     eax, [edx+4]
.text$mn:0000977A                 mov     [ebp+var_C], eax
.text$mn:0000977D                 mov     ecx, [ebp+var_8]
.text$mn:00009780                 add     ecx, 4
.text$mn:00009783                 push    ecx
.text$mn:00009784                 lea     edx, [ebp+var_1]
.text$mn:00009787                 push    edx
.text$mn:00009788                 mov     ecx, [ebp+var_8]
.text$mn:0000978B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00009790                 mov     ecx, eax
.text$mn:00009792                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00009797                 cmp     [ebp+Size], 0
.text$mn:0000979B                 jbe     short loc_97BD
.text$mn:0000979D                 mov     eax, [ebp+Size]
.text$mn:000097A0                 push    eax             ; Size
.text$mn:000097A1                 mov     ecx, [ebp+var_C]
.text$mn:000097A4                 push    ecx
.text$mn:000097A5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000097AA                 add     esp, 4
.text$mn:000097AD                 push    eax             ; Src
.text$mn:000097AE                 mov     edx, [ebp+var_8]
.text$mn:000097B1                 add     edx, 4
.text$mn:000097B4                 push    edx             ; Dst
.text$mn:000097B5                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000097BA                 add     esp, 0Ch
.text$mn:000097BD
.text$mn:000097BD loc_97BD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000097BD                 mov     eax, [ebp+var_8]
.text$mn:000097C0                 mov     ecx, [eax+18h]
.text$mn:000097C3                 add     ecx, 1
.text$mn:000097C6                 push    ecx             ; int
.text$mn:000097C7                 mov     edx, [ebp+var_C]
.text$mn:000097CA                 push    edx             ; void *
.text$mn:000097CB                 lea     eax, [ebp+var_2]
.text$mn:000097CE                 push    eax
.text$mn:000097CF                 mov     ecx, [ebp+var_8]
.text$mn:000097D2                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000097D7                 mov     ecx, eax
.text$mn:000097D9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000097DE
.text$mn:000097DE loc_97DE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000097DE                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000097DE                 mov     ecx, [ebp+var_8]
.text$mn:000097E1                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000097E8                 mov     edx, [ebp+Size]
.text$mn:000097EB                 push    edx
.text$mn:000097EC                 mov     ecx, [ebp+var_8]
.text$mn:000097EF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000097F4                 mov     esp, ebp
.text$mn:000097F6                 pop     ebp
.text$mn:000097F7                 retn    8
.text$mn:000097F7 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000097F7
.text$mn:000097F7 ; ---------------------------------------------------------------------------
.text$mn:000097FA                 align 4
.text$mn:000097FA _text$mn        ends
.text$mn:000097FA
.text$mn:000097FC ; ===========================================================================
.text$mn:000097FC
.text$mn:000097FC ; Segment type: Pure code
.text$mn:000097FC ; Segment permissions: Read/Execute
.text$mn:000097FC _text$mn        segment para public 'CODE' use32
.text$mn:000097FC                 assume cs:_text$mn
.text$mn:000097FC                 ;org 97FCh
.text$mn:000097FC ; COMDAT (pick any)
.text$mn:000097FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000097FC
.text$mn:000097FC ; =============== S U B R O U T I N E =======================================
.text$mn:000097FC
.text$mn:000097FC ; Attributes: bp-based frame
.text$mn:000097FC
.text$mn:000097FC ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:000097FC                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:000097FC ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:000097FC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+4Bp
.text$mn:000097FC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+56p ...
.text$mn:000097FC
.text$mn:000097FC var_C           = dword ptr -0Ch
.text$mn:000097FC var_8           = dword ptr -8
.text$mn:000097FC var_2           = byte ptr -2
.text$mn:000097FC var_1           = byte ptr -1
.text$mn:000097FC arg_0           = byte ptr  8
.text$mn:000097FC arg_4           = dword ptr  0Ch
.text$mn:000097FC
.text$mn:000097FC                 push    ebp
.text$mn:000097FD                 mov     ebp, esp
.text$mn:000097FF                 sub     esp, 0Ch
.text$mn:00009802                 mov     [ebp+var_8], ecx
.text$mn:00009805                 movzx   eax, [ebp+arg_0]
.text$mn:00009809                 test    eax, eax
.text$mn:0000980B                 jnz     short loc_980F
.text$mn:0000980D                 jmp     short loc_9882
.text$mn:0000980F ; ---------------------------------------------------------------------------
.text$mn:0000980F
.text$mn:0000980F loc_980F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:0000980F                 mov     ecx, [ebp+var_8]
.text$mn:00009812                 cmp     dword ptr [ecx+18h], 8
.text$mn:00009816                 jb      short loc_9882
.text$mn:00009818                 mov     edx, [ebp+var_8]
.text$mn:0000981B                 mov     eax, [edx+4]
.text$mn:0000981E                 mov     [ebp+var_C], eax
.text$mn:00009821                 mov     ecx, [ebp+var_8]
.text$mn:00009824                 add     ecx, 4
.text$mn:00009827                 push    ecx
.text$mn:00009828                 lea     edx, [ebp+var_1]
.text$mn:0000982B                 push    edx
.text$mn:0000982C                 mov     ecx, [ebp+var_8]
.text$mn:0000982F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00009834                 mov     ecx, eax
.text$mn:00009836                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000983B                 cmp     [ebp+arg_4], 0
.text$mn:0000983F                 jbe     short loc_9861
.text$mn:00009841                 mov     eax, [ebp+arg_4]
.text$mn:00009844                 push    eax             ; int
.text$mn:00009845                 mov     ecx, [ebp+var_C]
.text$mn:00009848                 push    ecx
.text$mn:00009849                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000984E                 add     esp, 4
.text$mn:00009851                 push    eax             ; Src
.text$mn:00009852                 mov     edx, [ebp+var_8]
.text$mn:00009855                 add     edx, 4
.text$mn:00009858                 push    edx             ; Dst
.text$mn:00009859                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000985E                 add     esp, 0Ch
.text$mn:00009861
.text$mn:00009861 loc_9861:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00009861                 mov     eax, [ebp+var_8]
.text$mn:00009864                 mov     ecx, [eax+18h]
.text$mn:00009867                 add     ecx, 1
.text$mn:0000986A                 push    ecx             ; int
.text$mn:0000986B                 mov     edx, [ebp+var_C]
.text$mn:0000986E                 push    edx             ; void *
.text$mn:0000986F                 lea     eax, [ebp+var_2]
.text$mn:00009872                 push    eax
.text$mn:00009873                 mov     ecx, [ebp+var_8]
.text$mn:00009876                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000987B                 mov     ecx, eax
.text$mn:0000987D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00009882
.text$mn:00009882 loc_9882:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00009882                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00009882                 mov     ecx, [ebp+var_8]
.text$mn:00009885                 mov     dword ptr [ecx+18h], 7
.text$mn:0000988C                 mov     edx, [ebp+arg_4]
.text$mn:0000988F                 push    edx
.text$mn:00009890                 mov     ecx, [ebp+var_8]
.text$mn:00009893                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00009898                 mov     esp, ebp
.text$mn:0000989A                 pop     ebp
.text$mn:0000989B                 retn    8
.text$mn:0000989B ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:0000989B
.text$mn:0000989B ; ---------------------------------------------------------------------------
.text$mn:0000989E                 align 10h
.text$mn:0000989E _text$mn        ends
.text$mn:0000989E
.text$mn:000098A0 ; ===========================================================================
.text$mn:000098A0
.text$mn:000098A0 ; Segment type: Pure code
.text$mn:000098A0 ; Segment permissions: Read/Execute
.text$mn:000098A0 _text$mn        segment para public 'CODE' use32
.text$mn:000098A0                 assume cs:_text$mn
.text$mn:000098A0                 ;org 98A0h
.text$mn:000098A0 ; COMDAT (pick any)
.text$mn:000098A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000098A0
.text$mn:000098A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000098A0
.text$mn:000098A0 ; Attributes: bp-based frame
.text$mn:000098A0
.text$mn:000098A0 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Tidy(void)
.text$mn:000098A0                 public ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ
.text$mn:000098A0 ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ proc near
.text$mn:000098A0                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>(void)+30p
.text$mn:000098A0
.text$mn:000098A0 var_8           = dword ptr -8
.text$mn:000098A0 var_1           = byte ptr -1
.text$mn:000098A0
.text$mn:000098A0                 push    ebp
.text$mn:000098A1                 mov     ebp, esp
.text$mn:000098A3                 sub     esp, 8
.text$mn:000098A6                 mov     [ebp+var_8], ecx
.text$mn:000098A9                 mov     eax, [ebp+var_8]
.text$mn:000098AC                 cmp     dword ptr [eax+4], 0
.text$mn:000098B0                 jz      short loc_991F
.text$mn:000098B2                 mov     ecx, [ebp+var_8] ; this
.text$mn:000098B5                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000098BA                 mov     ecx, [ebp+var_8]
.text$mn:000098BD                 mov     edx, [ecx+8]
.text$mn:000098C0                 push    edx
.text$mn:000098C1                 mov     eax, [ebp+var_8]
.text$mn:000098C4                 mov     ecx, [eax+4]
.text$mn:000098C7                 push    ecx
.text$mn:000098C8                 mov     ecx, [ebp+var_8]
.text$mn:000098CB                 call    ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Destroy(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:000098D0                 mov     edx, [ebp+var_8]
.text$mn:000098D3                 mov     eax, [ebp+var_8]
.text$mn:000098D6                 mov     ecx, [edx+0Ch]
.text$mn:000098D9                 sub     ecx, [eax+4]
.text$mn:000098DC                 mov     eax, ecx
.text$mn:000098DE                 cdq
.text$mn:000098DF                 mov     ecx, 1Ch
.text$mn:000098E4                 idiv    ecx
.text$mn:000098E6                 push    eax             ; int
.text$mn:000098E7                 mov     edx, [ebp+var_8]
.text$mn:000098EA                 mov     eax, [edx+4]
.text$mn:000098ED                 push    eax             ; void *
.text$mn:000098EE                 lea     ecx, [ebp+var_1]
.text$mn:000098F1                 push    ecx
.text$mn:000098F2                 mov     ecx, [ebp+var_8]
.text$mn:000098F5                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:000098FA                 mov     ecx, eax
.text$mn:000098FC                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:00009901                 mov     edx, [ebp+var_8]
.text$mn:00009904                 mov     dword ptr [edx+4], 0
.text$mn:0000990B                 mov     eax, [ebp+var_8]
.text$mn:0000990E                 mov     dword ptr [eax+8], 0
.text$mn:00009915                 mov     ecx, [ebp+var_8]
.text$mn:00009918                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000991F
.text$mn:0000991F loc_991F:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Tidy(void)+10j
.text$mn:0000991F                 mov     esp, ebp
.text$mn:00009921                 pop     ebp
.text$mn:00009922                 retn
.text$mn:00009922 ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ endp
.text$mn:00009922
.text$mn:00009922 ; ---------------------------------------------------------------------------
.text$mn:00009923                 align 4
.text$mn:00009923 _text$mn        ends
.text$mn:00009923
.text$mn:00009924 ; ===========================================================================
.text$mn:00009924
.text$mn:00009924 ; Segment type: Pure code
.text$mn:00009924 ; Segment permissions: Read/Execute
.text$mn:00009924 _text$mn        segment para public 'CODE' use32
.text$mn:00009924                 assume cs:_text$mn
.text$mn:00009924                 ;org 9924h
.text$mn:00009924 ; COMDAT (pick any)
.text$mn:00009924                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009924
.text$mn:00009924 ; =============== S U B R O U T I N E =======================================
.text$mn:00009924
.text$mn:00009924 ; Attributes: bp-based frame
.text$mn:00009924
.text$mn:00009924 ; public: unsigned int __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::_Unused_capacity(void)const
.text$mn:00009924                 public ?_Unused_capacity@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ
.text$mn:00009924 ?_Unused_capacity@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:00009924                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reserve(uint)+Bp
.text$mn:00009924
.text$mn:00009924 var_4           = dword ptr -4
.text$mn:00009924
.text$mn:00009924                 push    ebp
.text$mn:00009925                 mov     ebp, esp
.text$mn:00009927                 push    ecx
.text$mn:00009928                 mov     [ebp+var_4], ecx
.text$mn:0000992B                 mov     eax, [ebp+var_4]
.text$mn:0000992E                 mov     ecx, [ebp+var_4]
.text$mn:00009931                 mov     eax, [eax+0Ch]
.text$mn:00009934                 sub     eax, [ecx+8]
.text$mn:00009937                 sar     eax, 2
.text$mn:0000993A                 mov     esp, ebp
.text$mn:0000993C                 pop     ebp
.text$mn:0000993D                 retn
.text$mn:0000993D ?_Unused_capacity@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ endp
.text$mn:0000993D
.text$mn:0000993D ; ---------------------------------------------------------------------------
.text$mn:0000993E                 align 10h
.text$mn:0000993E _text$mn        ends
.text$mn:0000993E
.text$mn:00009940 ; ===========================================================================
.text$mn:00009940
.text$mn:00009940 ; Segment type: Pure code
.text$mn:00009940 ; Segment permissions: Read/Execute
.text$mn:00009940 _text$mn        segment para public 'CODE' use32
.text$mn:00009940                 assume cs:_text$mn
.text$mn:00009940                 ;org 9940h
.text$mn:00009940 ; COMDAT (pick any)
.text$mn:00009940                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009940
.text$mn:00009940 ; =============== S U B R O U T I N E =======================================
.text$mn:00009940
.text$mn:00009940 ; Attributes: bp-based frame
.text$mn:00009940
.text$mn:00009940 ; public: unsigned int __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::_Unused_capacity(void)const
.text$mn:00009940                 public ?_Unused_capacity@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ
.text$mn:00009940 ?_Unused_capacity@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ proc near
.text$mn:00009940                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reserve(uint)+Bp
.text$mn:00009940
.text$mn:00009940 var_4           = dword ptr -4
.text$mn:00009940
.text$mn:00009940                 push    ebp
.text$mn:00009941                 mov     ebp, esp
.text$mn:00009943                 push    ecx
.text$mn:00009944                 mov     [ebp+var_4], ecx
.text$mn:00009947                 mov     eax, [ebp+var_4]
.text$mn:0000994A                 mov     ecx, [ebp+var_4]
.text$mn:0000994D                 mov     eax, [eax+0Ch]
.text$mn:00009950                 sub     eax, [ecx+8]
.text$mn:00009953                 sar     eax, 2
.text$mn:00009956                 mov     esp, ebp
.text$mn:00009958                 pop     ebp
.text$mn:00009959                 retn
.text$mn:00009959 ?_Unused_capacity@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ endp
.text$mn:00009959
.text$mn:00009959 ; ---------------------------------------------------------------------------
.text$mn:0000995A                 align 4
.text$mn:0000995A _text$mn        ends
.text$mn:0000995A
.text$mn:0000995C ; ===========================================================================
.text$mn:0000995C
.text$mn:0000995C ; Segment type: Pure code
.text$mn:0000995C ; Segment permissions: Read/Execute
.text$mn:0000995C _text$mn        segment para public 'CODE' use32
.text$mn:0000995C                 assume cs:_text$mn
.text$mn:0000995C                 ;org 995Ch
.text$mn:0000995C ; COMDAT (pick any)
.text$mn:0000995C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000995C
.text$mn:0000995C ; =============== S U B R O U T I N E =======================================
.text$mn:0000995C
.text$mn:0000995C ; Attributes: bp-based frame
.text$mn:0000995C
.text$mn:0000995C ; public: unsigned int __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::_Unused_capacity(void)const
.text$mn:0000995C                 public ?_Unused_capacity@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ
.text$mn:0000995C ?_Unused_capacity@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000995C                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reserve(uint)+Bp
.text$mn:0000995C
.text$mn:0000995C var_4           = dword ptr -4
.text$mn:0000995C
.text$mn:0000995C                 push    ebp
.text$mn:0000995D                 mov     ebp, esp
.text$mn:0000995F                 push    ecx
.text$mn:00009960                 mov     [ebp+var_4], ecx
.text$mn:00009963                 mov     eax, [ebp+var_4]
.text$mn:00009966                 mov     ecx, [ebp+var_4]
.text$mn:00009969                 mov     eax, [eax+0Ch]
.text$mn:0000996C                 sub     eax, [ecx+8]
.text$mn:0000996F                 sar     eax, 5
.text$mn:00009972                 mov     esp, ebp
.text$mn:00009974                 pop     ebp
.text$mn:00009975                 retn
.text$mn:00009975 ?_Unused_capacity@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ endp
.text$mn:00009975
.text$mn:00009975 ; ---------------------------------------------------------------------------
.text$mn:00009976                 align 4
.text$mn:00009976 _text$mn        ends
.text$mn:00009976
.text$mn:00009978 ; ===========================================================================
.text$mn:00009978
.text$mn:00009978 ; Segment type: Pure code
.text$mn:00009978 ; Segment permissions: Read/Execute
.text$mn:00009978 _text$mn        segment para public 'CODE' use32
.text$mn:00009978                 assume cs:_text$mn
.text$mn:00009978                 ;org 9978h
.text$mn:00009978 ; COMDAT (pick any)
.text$mn:00009978                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009978
.text$mn:00009978 ; =============== S U B R O U T I N E =======================================
.text$mn:00009978
.text$mn:00009978 ; Attributes: bp-based frame
.text$mn:00009978
.text$mn:00009978 ; public: unsigned int __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::_Unused_capacity(void)const
.text$mn:00009978                 public ?_Unused_capacity@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ
.text$mn:00009978 ?_Unused_capacity@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:00009978                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reserve(uint)+Bp
.text$mn:00009978
.text$mn:00009978 var_4           = dword ptr -4
.text$mn:00009978
.text$mn:00009978                 push    ebp
.text$mn:00009979                 mov     ebp, esp
.text$mn:0000997B                 push    ecx
.text$mn:0000997C                 mov     [ebp+var_4], ecx
.text$mn:0000997F                 mov     eax, [ebp+var_4]
.text$mn:00009982                 mov     ecx, [ebp+var_4]
.text$mn:00009985                 mov     eax, [eax+0Ch]
.text$mn:00009988                 sub     eax, [ecx+8]
.text$mn:0000998B                 cdq
.text$mn:0000998C                 mov     ecx, 24h ; '$'
.text$mn:00009991                 idiv    ecx
.text$mn:00009993                 mov     esp, ebp
.text$mn:00009995                 pop     ebp
.text$mn:00009996                 retn
.text$mn:00009996 ?_Unused_capacity@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ endp
.text$mn:00009996
.text$mn:00009996 ; ---------------------------------------------------------------------------
.text$mn:00009997                 align 4
.text$mn:00009997 _text$mn        ends
.text$mn:00009997
.text$mn:00009998 ; ===========================================================================
.text$mn:00009998
.text$mn:00009998 ; Segment type: Pure code
.text$mn:00009998 ; Segment permissions: Read/Execute
.text$mn:00009998 _text$mn        segment para public 'CODE' use32
.text$mn:00009998                 assume cs:_text$mn
.text$mn:00009998                 ;org 9998h
.text$mn:00009998 ; COMDAT (pick any)
.text$mn:00009998                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009998
.text$mn:00009998 ; =============== S U B R O U T I N E =======================================
.text$mn:00009998
.text$mn:00009998 ; Attributes: bp-based frame
.text$mn:00009998
.text$mn:00009998 ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Unused_capacity(void)const
.text$mn:00009998                 public ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:00009998 ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:00009998                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+Bp
.text$mn:00009998
.text$mn:00009998 var_4           = dword ptr -4
.text$mn:00009998
.text$mn:00009998                 push    ebp
.text$mn:00009999                 mov     ebp, esp
.text$mn:0000999B                 push    ecx
.text$mn:0000999C                 mov     [ebp+var_4], ecx
.text$mn:0000999F                 mov     eax, [ebp+var_4]
.text$mn:000099A2                 mov     ecx, [ebp+var_4]
.text$mn:000099A5                 mov     eax, [eax+0Ch]
.text$mn:000099A8                 sub     eax, [ecx+8]
.text$mn:000099AB                 cdq
.text$mn:000099AC                 mov     ecx, 1Ch
.text$mn:000099B1                 idiv    ecx
.text$mn:000099B3                 mov     esp, ebp
.text$mn:000099B5                 pop     ebp
.text$mn:000099B6                 retn
.text$mn:000099B6 ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:000099B6
.text$mn:000099B6 ; ---------------------------------------------------------------------------
.text$mn:000099B7                 align 4
.text$mn:000099B7 _text$mn        ends
.text$mn:000099B7
.text$mn:000099B8 ; ===========================================================================
.text$mn:000099B8
.text$mn:000099B8 ; Segment type: Pure code
.text$mn:000099B8 ; Segment permissions: Read/Execute
.text$mn:000099B8 _text$mn        segment para public 'CODE' use32
.text$mn:000099B8                 assume cs:_text$mn
.text$mn:000099B8                 ;org 99B8h
.text$mn:000099B8 ; COMDAT (pick any)
.text$mn:000099B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000099B8
.text$mn:000099B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000099B8
.text$mn:000099B8 ; Attributes: bp-based frame
.text$mn:000099B8
.text$mn:000099B8 ; public: unsigned int __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::_Unused_capacity(void)const
.text$mn:000099B8                 public ?_Unused_capacity@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ
.text$mn:000099B8 ?_Unused_capacity@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ proc near
.text$mn:000099B8                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reserve(uint)+Bp
.text$mn:000099B8
.text$mn:000099B8 var_4           = dword ptr -4
.text$mn:000099B8
.text$mn:000099B8                 push    ebp
.text$mn:000099B9                 mov     ebp, esp
.text$mn:000099BB                 push    ecx
.text$mn:000099BC                 mov     [ebp+var_4], ecx
.text$mn:000099BF                 mov     eax, [ebp+var_4]
.text$mn:000099C2                 mov     ecx, [ebp+var_4]
.text$mn:000099C5                 mov     eax, [eax+0Ch]
.text$mn:000099C8                 sub     eax, [ecx+8]
.text$mn:000099CB                 cdq
.text$mn:000099CC                 mov     ecx, 150h
.text$mn:000099D1                 idiv    ecx
.text$mn:000099D3                 mov     esp, ebp
.text$mn:000099D5                 pop     ebp
.text$mn:000099D6                 retn
.text$mn:000099D6 ?_Unused_capacity@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ endp
.text$mn:000099D6
.text$mn:000099D6 ; ---------------------------------------------------------------------------
.text$mn:000099D7                 align 4
.text$mn:000099D7 _text$mn        ends
.text$mn:000099D7
.text$mn:000099D8 ; ===========================================================================
.text$mn:000099D8
.text$mn:000099D8 ; Segment type: Pure code
.text$mn:000099D8 ; Segment permissions: Read/Execute
.text$mn:000099D8 _text$mn        segment para public 'CODE' use32
.text$mn:000099D8                 assume cs:_text$mn
.text$mn:000099D8                 ;org 99D8h
.text$mn:000099D8 ; COMDAT (pick any)
.text$mn:000099D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000099D8
.text$mn:000099D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000099D8
.text$mn:000099D8 ; Attributes: bp-based frame
.text$mn:000099D8
.text$mn:000099D8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000099D8                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000099D8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000099D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000099D8
.text$mn:000099D8 var_4           = dword ptr -4
.text$mn:000099D8
.text$mn:000099D8                 push    ebp
.text$mn:000099D9                 mov     ebp, esp
.text$mn:000099DB                 push    ecx
.text$mn:000099DC                 mov     [ebp+var_4], ecx
.text$mn:000099DF                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000099E4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000099E9                 mov     esp, ebp
.text$mn:000099EB                 pop     ebp
.text$mn:000099EC                 retn
.text$mn:000099EC ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000099EC
.text$mn:000099EC ; ---------------------------------------------------------------------------
.text$mn:000099ED                 align 10h
.text$mn:000099ED _text$mn        ends
.text$mn:000099ED
.text$mn:000099F0 ; ===========================================================================
.text$mn:000099F0
.text$mn:000099F0 ; Segment type: Pure code
.text$mn:000099F0 ; Segment permissions: Read/Execute
.text$mn:000099F0 _text$mn        segment para public 'CODE' use32
.text$mn:000099F0                 assume cs:_text$mn
.text$mn:000099F0                 ;org 99F0h
.text$mn:000099F0 ; COMDAT (pick any)
.text$mn:000099F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000099F0
.text$mn:000099F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000099F0
.text$mn:000099F0 ; Attributes: bp-based frame
.text$mn:000099F0
.text$mn:000099F0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:000099F0                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:000099F0 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:000099F0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:000099F0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Dp ...
.text$mn:000099F0
.text$mn:000099F0 var_4           = dword ptr -4
.text$mn:000099F0
.text$mn:000099F0                 push    ebp
.text$mn:000099F1                 mov     ebp, esp
.text$mn:000099F3                 push    ecx
.text$mn:000099F4                 mov     [ebp+var_4], ecx
.text$mn:000099F7                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000099FC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00009A01                 mov     esp, ebp
.text$mn:00009A03                 pop     ebp
.text$mn:00009A04                 retn
.text$mn:00009A04 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00009A04
.text$mn:00009A04 ; ---------------------------------------------------------------------------
.text$mn:00009A05                 align 4
.text$mn:00009A05 _text$mn        ends
.text$mn:00009A05
.text$mn:00009A08 ; ===========================================================================
.text$mn:00009A08
.text$mn:00009A08 ; Segment type: Pure code
.text$mn:00009A08 ; Segment permissions: Read/Execute
.text$mn:00009A08 _text$mn        segment para public 'CODE' use32
.text$mn:00009A08                 assume cs:_text$mn
.text$mn:00009A08                 ;org 9A08h
.text$mn:00009A08 ; COMDAT (pick any)
.text$mn:00009A08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A08
.text$mn:00009A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A08
.text$mn:00009A08 ; Attributes: bp-based frame
.text$mn:00009A08
.text$mn:00009A08 ; protected: void __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::_Xlen(void)const
.text$mn:00009A08                 public ?_Xlen@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXXZ
.text$mn:00009A08 ?_Xlen@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXXZ proc near
.text$mn:00009A08                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reserve(uint)+31p
.text$mn:00009A08
.text$mn:00009A08 var_4           = dword ptr -4
.text$mn:00009A08
.text$mn:00009A08                 push    ebp
.text$mn:00009A09                 mov     ebp, esp
.text$mn:00009A0B                 push    ecx
.text$mn:00009A0C                 mov     [ebp+var_4], ecx
.text$mn:00009A0F                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00009A14                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00009A19                 mov     esp, ebp
.text$mn:00009A1B                 pop     ebp
.text$mn:00009A1C                 retn
.text$mn:00009A1C ?_Xlen@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXXZ endp
.text$mn:00009A1C
.text$mn:00009A1C ; ---------------------------------------------------------------------------
.text$mn:00009A1D                 align 10h
.text$mn:00009A1D _text$mn        ends
.text$mn:00009A1D
.text$mn:00009A20 ; ===========================================================================
.text$mn:00009A20
.text$mn:00009A20 ; Segment type: Pure code
.text$mn:00009A20 ; Segment permissions: Read/Execute
.text$mn:00009A20 _text$mn        segment para public 'CODE' use32
.text$mn:00009A20                 assume cs:_text$mn
.text$mn:00009A20                 ;org 9A20h
.text$mn:00009A20 ; COMDAT (pick any)
.text$mn:00009A20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A20
.text$mn:00009A20 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A20
.text$mn:00009A20 ; Attributes: bp-based frame
.text$mn:00009A20
.text$mn:00009A20 ; protected: void __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::_Xlen(void)const
.text$mn:00009A20                 public ?_Xlen@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXXZ
.text$mn:00009A20 ?_Xlen@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXXZ proc near
.text$mn:00009A20                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reserve(uint)+31p
.text$mn:00009A20
.text$mn:00009A20 var_4           = dword ptr -4
.text$mn:00009A20
.text$mn:00009A20                 push    ebp
.text$mn:00009A21                 mov     ebp, esp
.text$mn:00009A23                 push    ecx
.text$mn:00009A24                 mov     [ebp+var_4], ecx
.text$mn:00009A27                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00009A2C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00009A31                 mov     esp, ebp
.text$mn:00009A33                 pop     ebp
.text$mn:00009A34                 retn
.text$mn:00009A34 ?_Xlen@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXXZ endp
.text$mn:00009A34
.text$mn:00009A34 ; ---------------------------------------------------------------------------
.text$mn:00009A35                 align 4
.text$mn:00009A35 _text$mn        ends
.text$mn:00009A35
.text$mn:00009A38 ; ===========================================================================
.text$mn:00009A38
.text$mn:00009A38 ; Segment type: Pure code
.text$mn:00009A38 ; Segment permissions: Read/Execute
.text$mn:00009A38 _text$mn        segment para public 'CODE' use32
.text$mn:00009A38                 assume cs:_text$mn
.text$mn:00009A38                 ;org 9A38h
.text$mn:00009A38 ; COMDAT (pick any)
.text$mn:00009A38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A38
.text$mn:00009A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A38
.text$mn:00009A38 ; Attributes: bp-based frame
.text$mn:00009A38
.text$mn:00009A38 ; protected: void __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::_Xlen(void)const
.text$mn:00009A38                 public ?_Xlen@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXXZ
.text$mn:00009A38 ?_Xlen@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXXZ proc near
.text$mn:00009A38                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reserve(uint)+31p
.text$mn:00009A38
.text$mn:00009A38 var_4           = dword ptr -4
.text$mn:00009A38
.text$mn:00009A38                 push    ebp
.text$mn:00009A39                 mov     ebp, esp
.text$mn:00009A3B                 push    ecx
.text$mn:00009A3C                 mov     [ebp+var_4], ecx
.text$mn:00009A3F                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00009A44                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00009A49                 mov     esp, ebp
.text$mn:00009A4B                 pop     ebp
.text$mn:00009A4C                 retn
.text$mn:00009A4C ?_Xlen@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXXZ endp
.text$mn:00009A4C
.text$mn:00009A4C ; ---------------------------------------------------------------------------
.text$mn:00009A4D                 align 10h
.text$mn:00009A4D _text$mn        ends
.text$mn:00009A4D
.text$mn:00009A50 ; ===========================================================================
.text$mn:00009A50
.text$mn:00009A50 ; Segment type: Pure code
.text$mn:00009A50 ; Segment permissions: Read/Execute
.text$mn:00009A50 _text$mn        segment para public 'CODE' use32
.text$mn:00009A50                 assume cs:_text$mn
.text$mn:00009A50                 ;org 9A50h
.text$mn:00009A50 ; COMDAT (pick any)
.text$mn:00009A50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A50
.text$mn:00009A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A50
.text$mn:00009A50 ; Attributes: bp-based frame
.text$mn:00009A50
.text$mn:00009A50 ; protected: void __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::_Xlen(void)const
.text$mn:00009A50                 public ?_Xlen@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXXZ
.text$mn:00009A50 ?_Xlen@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXXZ proc near
.text$mn:00009A50                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reserve(uint)+31p
.text$mn:00009A50
.text$mn:00009A50 var_4           = dword ptr -4
.text$mn:00009A50
.text$mn:00009A50                 push    ebp
.text$mn:00009A51                 mov     ebp, esp
.text$mn:00009A53                 push    ecx
.text$mn:00009A54                 mov     [ebp+var_4], ecx
.text$mn:00009A57                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00009A5C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00009A61                 mov     esp, ebp
.text$mn:00009A63                 pop     ebp
.text$mn:00009A64                 retn
.text$mn:00009A64 ?_Xlen@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXXZ endp
.text$mn:00009A64
.text$mn:00009A64 ; ---------------------------------------------------------------------------
.text$mn:00009A65                 align 4
.text$mn:00009A65 _text$mn        ends
.text$mn:00009A65
.text$mn:00009A68 ; ===========================================================================
.text$mn:00009A68
.text$mn:00009A68 ; Segment type: Pure code
.text$mn:00009A68 ; Segment permissions: Read/Execute
.text$mn:00009A68 _text$mn        segment para public 'CODE' use32
.text$mn:00009A68                 assume cs:_text$mn
.text$mn:00009A68                 ;org 9A68h
.text$mn:00009A68 ; COMDAT (pick any)
.text$mn:00009A68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A68
.text$mn:00009A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A68
.text$mn:00009A68 ; Attributes: bp-based frame
.text$mn:00009A68
.text$mn:00009A68 ; protected: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::_Xlen(void)const
.text$mn:00009A68                 public ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ
.text$mn:00009A68 ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ proc near
.text$mn:00009A68                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+31p
.text$mn:00009A68
.text$mn:00009A68 var_4           = dword ptr -4
.text$mn:00009A68
.text$mn:00009A68                 push    ebp
.text$mn:00009A69                 mov     ebp, esp
.text$mn:00009A6B                 push    ecx
.text$mn:00009A6C                 mov     [ebp+var_4], ecx
.text$mn:00009A6F                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00009A74                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00009A79                 mov     esp, ebp
.text$mn:00009A7B                 pop     ebp
.text$mn:00009A7C                 retn
.text$mn:00009A7C ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXXZ endp
.text$mn:00009A7C
.text$mn:00009A7C ; ---------------------------------------------------------------------------
.text$mn:00009A7D                 align 10h
.text$mn:00009A7D _text$mn        ends
.text$mn:00009A7D
.text$mn:00009A80 ; ===========================================================================
.text$mn:00009A80
.text$mn:00009A80 ; Segment type: Pure code
.text$mn:00009A80 ; Segment permissions: Read/Execute
.text$mn:00009A80 _text$mn        segment para public 'CODE' use32
.text$mn:00009A80                 assume cs:_text$mn
.text$mn:00009A80                 ;org 9A80h
.text$mn:00009A80 ; COMDAT (pick any)
.text$mn:00009A80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A80
.text$mn:00009A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A80
.text$mn:00009A80 ; Attributes: bp-based frame
.text$mn:00009A80
.text$mn:00009A80 ; protected: void __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::_Xlen(void)const
.text$mn:00009A80                 public ?_Xlen@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXXZ
.text$mn:00009A80 ?_Xlen@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXXZ proc near
.text$mn:00009A80                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reserve(uint)+31p
.text$mn:00009A80
.text$mn:00009A80 var_4           = dword ptr -4
.text$mn:00009A80
.text$mn:00009A80                 push    ebp
.text$mn:00009A81                 mov     ebp, esp
.text$mn:00009A83                 push    ecx
.text$mn:00009A84                 mov     [ebp+var_4], ecx
.text$mn:00009A87                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00009A8C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00009A91                 mov     esp, ebp
.text$mn:00009A93                 pop     ebp
.text$mn:00009A94                 retn
.text$mn:00009A94 ?_Xlen@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXXZ endp
.text$mn:00009A94
.text$mn:00009A94 ; ---------------------------------------------------------------------------
.text$mn:00009A95                 align 4
.text$mn:00009A95 _text$mn        ends
.text$mn:00009A95
.text$mn:00009A98 ; ===========================================================================
.text$mn:00009A98
.text$mn:00009A98 ; Segment type: Pure code
.text$mn:00009A98 ; Segment permissions: Read/Execute
.text$mn:00009A98 _text$mn        segment para public 'CODE' use32
.text$mn:00009A98                 assume cs:_text$mn
.text$mn:00009A98                 ;org 9A98h
.text$mn:00009A98 ; COMDAT (pick any)
.text$mn:00009A98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A98
.text$mn:00009A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A98
.text$mn:00009A98 ; Attributes: bp-based frame
.text$mn:00009A98
.text$mn:00009A98 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00009A98                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00009A98 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00009A98                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00009A98                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00009A98
.text$mn:00009A98 var_4           = dword ptr -4
.text$mn:00009A98
.text$mn:00009A98                 push    ebp
.text$mn:00009A99                 mov     ebp, esp
.text$mn:00009A9B                 push    ecx
.text$mn:00009A9C                 mov     [ebp+var_4], ecx
.text$mn:00009A9F                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00009AA4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00009AA9                 mov     esp, ebp
.text$mn:00009AAB                 pop     ebp
.text$mn:00009AAC                 retn
.text$mn:00009AAC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00009AAC
.text$mn:00009AAC ; ---------------------------------------------------------------------------
.text$mn:00009AAD                 align 10h
.text$mn:00009AAD _text$mn        ends
.text$mn:00009AAD
.text$mn:00009AB0 ; ===========================================================================
.text$mn:00009AB0
.text$mn:00009AB0 ; Segment type: Pure code
.text$mn:00009AB0 ; Segment permissions: Read/Execute
.text$mn:00009AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00009AB0                 assume cs:_text$mn
.text$mn:00009AB0                 ;org 9AB0h
.text$mn:00009AB0 ; COMDAT (pick any)
.text$mn:00009AB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009AB0
.text$mn:00009AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009AB0
.text$mn:00009AB0 ; Attributes: bp-based frame
.text$mn:00009AB0
.text$mn:00009AB0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00009AB0                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00009AB0 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00009AB0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00009AB0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p ...
.text$mn:00009AB0
.text$mn:00009AB0 var_4           = dword ptr -4
.text$mn:00009AB0
.text$mn:00009AB0                 push    ebp
.text$mn:00009AB1                 mov     ebp, esp
.text$mn:00009AB3                 push    ecx
.text$mn:00009AB4                 mov     [ebp+var_4], ecx
.text$mn:00009AB7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00009ABC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00009AC1                 mov     esp, ebp
.text$mn:00009AC3                 pop     ebp
.text$mn:00009AC4                 retn
.text$mn:00009AC4 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00009AC4
.text$mn:00009AC4 ; ---------------------------------------------------------------------------
.text$mn:00009AC5                 align 4
.text$mn:00009AC5 _text$mn        ends
.text$mn:00009AC5
.text$mn:00009AC8 ; ===========================================================================
.text$mn:00009AC8
.text$mn:00009AC8 ; Segment type: Pure code
.text$mn:00009AC8 ; Segment permissions: Read/Execute
.text$mn:00009AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00009AC8                 assume cs:_text$mn
.text$mn:00009AC8                 ;org 9AC8h
.text$mn:00009AC8 ; COMDAT (pick any)
.text$mn:00009AC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009AC8
.text$mn:00009AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00009AC8
.text$mn:00009AC8 ; Attributes: bp-based frame
.text$mn:00009AC8
.text$mn:00009AC8 ; public: void __thiscall PluginList::add(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool)
.text$mn:00009AC8                 public ?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z
.text$mn:00009AC8 ?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z proc near
.text$mn:00009AC8                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+4B4p
.text$mn:00009AC8
.text$mn:00009AC8 var_3C          = dword ptr -3Ch
.text$mn:00009AC8 var_38          = dword ptr -38h
.text$mn:00009AC8 var_34          = dword ptr -34h
.text$mn:00009AC8 var_30          = byte ptr -30h
.text$mn:00009AC8 var_10          = dword ptr -10h
.text$mn:00009AC8 var_C           = dword ptr -0Ch
.text$mn:00009AC8 var_4           = dword ptr -4
.text$mn:00009AC8 arg_0           = byte ptr  8
.text$mn:00009AC8 arg_1C          = byte ptr  24h
.text$mn:00009AC8
.text$mn:00009AC8                 push    ebp
.text$mn:00009AC9                 mov     ebp, esp
.text$mn:00009ACB                 push    0FFFFFFFFh
.text$mn:00009ACD                 push    offset __ehhandler$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z
.text$mn:00009AD2                 mov     eax, large fs:0
.text$mn:00009AD8                 push    eax
.text$mn:00009AD9                 sub     esp, 30h
.text$mn:00009ADC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009AE1                 xor     eax, ebp
.text$mn:00009AE3                 mov     [ebp+var_10], eax
.text$mn:00009AE6                 push    eax
.text$mn:00009AE7                 lea     eax, [ebp+var_C]
.text$mn:00009AEA                 mov     large fs:0, eax
.text$mn:00009AF0                 mov     [ebp+var_38], ecx
.text$mn:00009AF3                 mov     [ebp+var_4], 0
.text$mn:00009AFA                 lea     eax, [ebp+arg_1C]
.text$mn:00009AFD                 push    eax
.text$mn:00009AFE                 lea     ecx, [ebp+arg_0]
.text$mn:00009B01                 push    ecx
.text$mn:00009B02                 lea     ecx, [ebp+var_30]
.text$mn:00009B05                 call    ??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &,bool &)
.text$mn:00009B0A                 mov     [ebp+var_3C], eax
.text$mn:00009B0D                 mov     edx, [ebp+var_3C]
.text$mn:00009B10                 mov     [ebp+var_34], edx
.text$mn:00009B13                 mov     byte ptr [ebp+var_4], 1
.text$mn:00009B17                 mov     eax, [ebp+var_34]
.text$mn:00009B1A                 push    eax
.text$mn:00009B1B                 mov     ecx, [ebp+var_38]
.text$mn:00009B1E                 call    ?push_back@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAEX$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@@Z ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)
.text$mn:00009B23                 mov     byte ptr [ebp+var_4], 0
.text$mn:00009B27                 lea     ecx, [ebp+var_30]
.text$mn:00009B2A                 call    ??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::~pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(void)
.text$mn:00009B2F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009B36                 lea     ecx, [ebp+arg_0]
.text$mn:00009B39                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00009B3E                 mov     ecx, [ebp+var_C]
.text$mn:00009B41                 mov     large fs:0, ecx
.text$mn:00009B48                 pop     ecx
.text$mn:00009B49                 mov     ecx, [ebp+var_10]
.text$mn:00009B4C                 xor     ecx, ebp
.text$mn:00009B4E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00009B53                 mov     esp, ebp
.text$mn:00009B55                 pop     ebp
.text$mn:00009B56                 retn    20h
.text$mn:00009B56 ?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z endp
.text$mn:00009B56
.text$mn:00009B56 ; ---------------------------------------------------------------------------
.text$mn:00009B59                 align 4
.text$mn:00009B59 _text$mn        ends
.text$mn:00009B59
.text$x:00009B5C ; ===========================================================================
.text$x:00009B5C
.text$x:00009B5C ; Segment type: Pure code
.text$x:00009B5C ; Segment permissions: Read/Execute
.text$x:00009B5C _text$x         segment para public 'CODE' use32
.text$x:00009B5C                 assume cs:_text$x
.text$x:00009B5C                 ;org 9B5Ch
.text$x:00009B5C ; COMDAT (pick associative to section at 9AC8)
.text$x:00009B5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009B5C
.text$x:00009B5C ; =============== S U B R O U T I N E =======================================
.text$x:00009B5C
.text$x:00009B5C
.text$x:00009B5C __unwindfunclet$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z$0 proc near
.text$x:00009B5C                                         ; DATA XREF: .xdata$x:0000CD24o
.text$x:00009B5C                 lea     ecx, [ebp+8]
.text$x:00009B5F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00009B5F __unwindfunclet$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z$0 endp
.text$x:00009B5F
.text$x:00009B64
.text$x:00009B64 ; =============== S U B R O U T I N E =======================================
.text$x:00009B64
.text$x:00009B64
.text$x:00009B64 __unwindfunclet$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z$1 proc near
.text$x:00009B64                                         ; DATA XREF: .xdata$x:0000CD2Co
.text$x:00009B64                 lea     ecx, [ebp-30h]
.text$x:00009B67                 jmp     ??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>::~pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>(void)
.text$x:00009B67 __unwindfunclet$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z$1 endp
.text$x:00009B67
.text$x:00009B6C
.text$x:00009B6C ; =============== S U B R O U T I N E =======================================
.text$x:00009B6C
.text$x:00009B6C
.text$x:00009B6C __ehhandler$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z proc near
.text$x:00009B6C                                         ; DATA XREF: PluginList::add(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool)+5o
.text$x:00009B6C
.text$x:00009B6C arg_4           = dword ptr  8
.text$x:00009B6C
.text$x:00009B6C                 mov     edx, [esp+arg_4]
.text$x:00009B70                 lea     eax, [edx+0Ch]
.text$x:00009B73                 mov     ecx, [edx-34h]
.text$x:00009B76                 xor     ecx, eax
.text$x:00009B78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009B7D                 mov     ecx, [edx-4]
.text$x:00009B80                 xor     ecx, eax
.text$x:00009B82                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009B87                 mov     eax, offset __ehfuncinfo$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z
.text$x:00009B8C                 jmp     ___CxxFrameHandler3
.text$x:00009B8C __ehhandler$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z endp
.text$x:00009B8C
.text$x:00009B8C ; ---------------------------------------------------------------------------
.text$x:00009B91                 align 4
.text$x:00009B91 _text$x         ends
.text$x:00009B91
.text$mn:00009B94 ; ===========================================================================
.text$mn:00009B94
.text$mn:00009B94 ; Segment type: Pure code
.text$mn:00009B94 ; Segment permissions: Read/Execute
.text$mn:00009B94 _text$mn        segment para public 'CODE' use32
.text$mn:00009B94                 assume cs:_text$mn
.text$mn:00009B94                 ;org 9B94h
.text$mn:00009B94 ; COMDAT (pick any)
.text$mn:00009B94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009B94
.text$mn:00009B94 ; =============== S U B R O U T I N E =======================================
.text$mn:00009B94
.text$mn:00009B94 ; Attributes: bp-based frame
.text$mn:00009B94
.text$mn:00009B94 ; void __thiscall PluginsManager::addInLoadedDlls(PluginsManager *this, const wchar_t *)
.text$mn:00009B94                 public ?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z
.text$mn:00009B94 ?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z proc near
.text$mn:00009B94                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+9C0p
.text$mn:00009B94
.text$mn:00009B94 var_30          = dword ptr -30h
.text$mn:00009B94 var_2C          = byte ptr -2Ch
.text$mn:00009B94 var_10          = dword ptr -10h
.text$mn:00009B94 var_C           = dword ptr -0Ch
.text$mn:00009B94 var_4           = dword ptr -4
.text$mn:00009B94 Str             = dword ptr  8
.text$mn:00009B94
.text$mn:00009B94                 push    ebp
.text$mn:00009B95                 mov     ebp, esp
.text$mn:00009B97                 push    0FFFFFFFFh
.text$mn:00009B99                 push    offset __ehhandler$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z
.text$mn:00009B9E                 mov     eax, large fs:0
.text$mn:00009BA4                 push    eax
.text$mn:00009BA5                 sub     esp, 24h
.text$mn:00009BA8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009BAD                 xor     eax, ebp
.text$mn:00009BAF                 mov     [ebp+var_10], eax
.text$mn:00009BB2                 push    eax
.text$mn:00009BB3                 lea     eax, [ebp+var_C]
.text$mn:00009BB6                 mov     large fs:0, eax
.text$mn:00009BBC                 mov     [ebp+var_30], ecx
.text$mn:00009BBF                 mov     eax, [ebp+Str]
.text$mn:00009BC2                 push    eax             ; Str
.text$mn:00009BC3                 lea     ecx, [ebp+var_2C]
.text$mn:00009BC6                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00009BCB                 mov     [ebp+var_4], 0
.text$mn:00009BD2                 lea     ecx, [ebp+var_2C]
.text$mn:00009BD5                 push    ecx
.text$mn:00009BD6                 mov     ecx, [ebp+var_30]
.text$mn:00009BD9                 add     ecx, 30h ; '0'
.text$mn:00009BDC                 call    ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00009BE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009BE8                 lea     ecx, [ebp+var_2C]
.text$mn:00009BEB                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00009BF0                 mov     ecx, [ebp+var_C]
.text$mn:00009BF3                 mov     large fs:0, ecx
.text$mn:00009BFA                 pop     ecx
.text$mn:00009BFB                 mov     ecx, [ebp+var_10]
.text$mn:00009BFE                 xor     ecx, ebp
.text$mn:00009C00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00009C05                 mov     esp, ebp
.text$mn:00009C07                 pop     ebp
.text$mn:00009C08                 retn    4
.text$mn:00009C08 ?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z endp
.text$mn:00009C08
.text$mn:00009C08 ; ---------------------------------------------------------------------------
.text$mn:00009C0B                 align 4
.text$mn:00009C0B _text$mn        ends
.text$mn:00009C0B
.text$x:00009C0C ; ===========================================================================
.text$x:00009C0C
.text$x:00009C0C ; Segment type: Pure code
.text$x:00009C0C ; Segment permissions: Read/Execute
.text$x:00009C0C _text$x         segment para public 'CODE' use32
.text$x:00009C0C                 assume cs:_text$x
.text$x:00009C0C                 ;org 9C0Ch
.text$x:00009C0C ; COMDAT (pick associative to section at 9B94)
.text$x:00009C0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009C0C
.text$x:00009C0C ; =============== S U B R O U T I N E =======================================
.text$x:00009C0C
.text$x:00009C0C
.text$x:00009C0C __unwindfunclet$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z$0 proc near
.text$x:00009C0C                                         ; DATA XREF: .xdata$x:0000D5D4o
.text$x:00009C0C                 lea     ecx, [ebp-2Ch]
.text$x:00009C0F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00009C0F __unwindfunclet$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z$0 endp
.text$x:00009C0F
.text$x:00009C14
.text$x:00009C14 ; =============== S U B R O U T I N E =======================================
.text$x:00009C14
.text$x:00009C14
.text$x:00009C14 __ehhandler$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z proc near
.text$x:00009C14                                         ; DATA XREF: PluginsManager::addInLoadedDlls(wchar_t const *)+5o
.text$x:00009C14
.text$x:00009C14 arg_4           = dword ptr  8
.text$x:00009C14
.text$x:00009C14                 mov     edx, [esp+arg_4]
.text$x:00009C18                 lea     eax, [edx+0Ch]
.text$x:00009C1B                 mov     ecx, [edx-28h]
.text$x:00009C1E                 xor     ecx, eax
.text$x:00009C20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009C25                 mov     ecx, [edx-4]
.text$x:00009C28                 xor     ecx, eax
.text$x:00009C2A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009C2F                 mov     eax, offset __ehfuncinfo$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z
.text$x:00009C34                 jmp     ___CxxFrameHandler3
.text$x:00009C34 __ehhandler$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z endp
.text$x:00009C34
.text$x:00009C34 ; ---------------------------------------------------------------------------
.text$x:00009C39                 align 4
.text$x:00009C39 _text$x         ends
.text$x:00009C39
.text$mn:00009C3C ; ===========================================================================
.text$mn:00009C3C
.text$mn:00009C3C ; Segment type: Pure code
.text$mn:00009C3C ; Segment permissions: Read/Execute
.text$mn:00009C3C _text$mn        segment para public 'CODE' use32
.text$mn:00009C3C                 assume cs:_text$mn
.text$mn:00009C3C                 ;org 9C3Ch
.text$mn:00009C3C ; COMDAT (pick any)
.text$mn:00009C3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009C3C
.text$mn:00009C3C ; =============== S U B R O U T I N E =======================================
.text$mn:00009C3C
.text$mn:00009C3C ; Attributes: bp-based frame
.text$mn:00009C3C
.text$mn:00009C3C ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00009C3C                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00009C3C ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00009C3C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00009C3C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00009C3C
.text$mn:00009C3C var_4           = dword ptr -4
.text$mn:00009C3C arg_0           = dword ptr  8
.text$mn:00009C3C
.text$mn:00009C3C                 push    ebp
.text$mn:00009C3D                 mov     ebp, esp
.text$mn:00009C3F                 push    ecx
.text$mn:00009C40                 mov     [ebp+var_4], ecx
.text$mn:00009C43                 mov     eax, [ebp+arg_0]
.text$mn:00009C46                 push    eax
.text$mn:00009C47                 mov     ecx, [ebp+var_4]
.text$mn:00009C4A                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00009C4F                 mov     esp, ebp
.text$mn:00009C51                 pop     ebp
.text$mn:00009C52                 retn    4
.text$mn:00009C52 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00009C52
.text$mn:00009C52 ; ---------------------------------------------------------------------------
.text$mn:00009C55                 align 4
.text$mn:00009C55 _text$mn        ends
.text$mn:00009C55
.text$mn:00009C58 ; ===========================================================================
.text$mn:00009C58
.text$mn:00009C58 ; Segment type: Pure code
.text$mn:00009C58 ; Segment permissions: Read/Execute
.text$mn:00009C58 _text$mn        segment para public 'CODE' use32
.text$mn:00009C58                 assume cs:_text$mn
.text$mn:00009C58                 ;org 9C58h
.text$mn:00009C58 ; COMDAT (pick any)
.text$mn:00009C58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009C58
.text$mn:00009C58 ; =============== S U B R O U T I N E =======================================
.text$mn:00009C58
.text$mn:00009C58 ; Attributes: bp-based frame
.text$mn:00009C58
.text$mn:00009C58 ; public: struct PluginInfo * * __thiscall std::_Wrap_alloc<class std::allocator<struct PluginInfo *>>::allocate(unsigned int)
.text$mn:00009C58                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEPAPAUPluginInfo@@I@Z
.text$mn:00009C58 ?allocate@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEPAPAUPluginInfo@@I@Z proc near
.text$mn:00009C58                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reallocate(uint)+41p
.text$mn:00009C58
.text$mn:00009C58 var_4           = dword ptr -4
.text$mn:00009C58 arg_0           = dword ptr  8
.text$mn:00009C58
.text$mn:00009C58                 push    ebp
.text$mn:00009C59                 mov     ebp, esp
.text$mn:00009C5B                 push    ecx
.text$mn:00009C5C                 mov     [ebp+var_4], ecx
.text$mn:00009C5F                 mov     eax, [ebp+arg_0]
.text$mn:00009C62                 push    eax
.text$mn:00009C63                 mov     ecx, [ebp+var_4]
.text$mn:00009C66                 call    ?allocate@?$allocator@PAUPluginInfo@@@std@@QAEPAPAUPluginInfo@@I@Z ; std::allocator<PluginInfo *>::allocate(uint)
.text$mn:00009C6B                 mov     esp, ebp
.text$mn:00009C6D                 pop     ebp
.text$mn:00009C6E                 retn    4
.text$mn:00009C6E ?allocate@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEPAPAUPluginInfo@@I@Z endp
.text$mn:00009C6E
.text$mn:00009C6E ; ---------------------------------------------------------------------------
.text$mn:00009C71                 align 4
.text$mn:00009C71 _text$mn        ends
.text$mn:00009C71
.text$mn:00009C74 ; ===========================================================================
.text$mn:00009C74
.text$mn:00009C74 ; Segment type: Pure code
.text$mn:00009C74 ; Segment permissions: Read/Execute
.text$mn:00009C74 _text$mn        segment para public 'CODE' use32
.text$mn:00009C74                 assume cs:_text$mn
.text$mn:00009C74                 ;org 9C74h
.text$mn:00009C74 ; COMDAT (pick any)
.text$mn:00009C74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009C74
.text$mn:00009C74 ; =============== S U B R O U T I N E =======================================
.text$mn:00009C74
.text$mn:00009C74 ; Attributes: bp-based frame
.text$mn:00009C74
.text$mn:00009C74 ; public: class TiXmlDocument * * __thiscall std::_Wrap_alloc<class std::allocator<class TiXmlDocument *>>::allocate(unsigned int)
.text$mn:00009C74                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEPAPAVTiXmlDocument@@I@Z
.text$mn:00009C74 ?allocate@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEPAPAVTiXmlDocument@@I@Z proc near
.text$mn:00009C74                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reallocate(uint)+41p
.text$mn:00009C74
.text$mn:00009C74 var_4           = dword ptr -4
.text$mn:00009C74 arg_0           = dword ptr  8
.text$mn:00009C74
.text$mn:00009C74                 push    ebp
.text$mn:00009C75                 mov     ebp, esp
.text$mn:00009C77                 push    ecx
.text$mn:00009C78                 mov     [ebp+var_4], ecx
.text$mn:00009C7B                 mov     eax, [ebp+arg_0]
.text$mn:00009C7E                 push    eax
.text$mn:00009C7F                 mov     ecx, [ebp+var_4]
.text$mn:00009C82                 call    ?allocate@?$allocator@PAVTiXmlDocument@@@std@@QAEPAPAVTiXmlDocument@@I@Z ; std::allocator<TiXmlDocument *>::allocate(uint)
.text$mn:00009C87                 mov     esp, ebp
.text$mn:00009C89                 pop     ebp
.text$mn:00009C8A                 retn    4
.text$mn:00009C8A ?allocate@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEPAPAVTiXmlDocument@@I@Z endp
.text$mn:00009C8A
.text$mn:00009C8A ; ---------------------------------------------------------------------------
.text$mn:00009C8D                 align 10h
.text$mn:00009C8D _text$mn        ends
.text$mn:00009C8D
.text$mn:00009C90 ; ===========================================================================
.text$mn:00009C90
.text$mn:00009C90 ; Segment type: Pure code
.text$mn:00009C90 ; Segment permissions: Read/Execute
.text$mn:00009C90 _text$mn        segment para public 'CODE' use32
.text$mn:00009C90                 assume cs:_text$mn
.text$mn:00009C90                 ;org 9C90h
.text$mn:00009C90 ; COMDAT (pick any)
.text$mn:00009C90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009C90
.text$mn:00009C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00009C90
.text$mn:00009C90 ; Attributes: bp-based frame
.text$mn:00009C90
.text$mn:00009C90 ; public: struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * __thiscall std::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::allocate(unsigned int)
.text$mn:00009C90                 public ?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z
.text$mn:00009C90 ?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z proc near
.text$mn:00009C90                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reallocate(uint)+41p
.text$mn:00009C90
.text$mn:00009C90 var_4           = dword ptr -4
.text$mn:00009C90 arg_0           = dword ptr  8
.text$mn:00009C90
.text$mn:00009C90                 push    ebp
.text$mn:00009C91                 mov     ebp, esp
.text$mn:00009C93                 push    ecx
.text$mn:00009C94                 mov     [ebp+var_4], ecx
.text$mn:00009C97                 mov     eax, [ebp+arg_0]
.text$mn:00009C9A                 push    eax
.text$mn:00009C9B                 mov     ecx, [ebp+var_4]
.text$mn:00009C9E                 call    ?allocate@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::allocate(uint)
.text$mn:00009CA3                 mov     esp, ebp
.text$mn:00009CA5                 pop     ebp
.text$mn:00009CA6                 retn    4
.text$mn:00009CA6 ?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z endp
.text$mn:00009CA6
.text$mn:00009CA6 ; ---------------------------------------------------------------------------
.text$mn:00009CA9                 align 4
.text$mn:00009CA9 _text$mn        ends
.text$mn:00009CA9
.text$mn:00009CAC ; ===========================================================================
.text$mn:00009CAC
.text$mn:00009CAC ; Segment type: Pure code
.text$mn:00009CAC ; Segment permissions: Read/Execute
.text$mn:00009CAC _text$mn        segment para public 'CODE' use32
.text$mn:00009CAC                 assume cs:_text$mn
.text$mn:00009CAC                 ;org 9CACh
.text$mn:00009CAC ; COMDAT (pick any)
.text$mn:00009CAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009CAC
.text$mn:00009CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00009CAC
.text$mn:00009CAC ; Attributes: bp-based frame
.text$mn:00009CAC
.text$mn:00009CAC ; public: struct PluginCommand * __thiscall std::_Wrap_alloc<class std::allocator<struct PluginCommand>>::allocate(unsigned int)
.text$mn:00009CAC                 public ?allocate@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEPAUPluginCommand@@I@Z
.text$mn:00009CAC ?allocate@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEPAUPluginCommand@@I@Z proc near
.text$mn:00009CAC                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reallocate(uint)+41p
.text$mn:00009CAC
.text$mn:00009CAC var_4           = dword ptr -4
.text$mn:00009CAC arg_0           = dword ptr  8
.text$mn:00009CAC
.text$mn:00009CAC                 push    ebp
.text$mn:00009CAD                 mov     ebp, esp
.text$mn:00009CAF                 push    ecx
.text$mn:00009CB0                 mov     [ebp+var_4], ecx
.text$mn:00009CB3                 mov     eax, [ebp+arg_0]
.text$mn:00009CB6                 push    eax
.text$mn:00009CB7                 mov     ecx, [ebp+var_4]
.text$mn:00009CBA                 call    ?allocate@?$allocator@UPluginCommand@@@std@@QAEPAUPluginCommand@@I@Z ; std::allocator<PluginCommand>::allocate(uint)
.text$mn:00009CBF                 mov     esp, ebp
.text$mn:00009CC1                 pop     ebp
.text$mn:00009CC2                 retn    4
.text$mn:00009CC2 ?allocate@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEPAUPluginCommand@@I@Z endp
.text$mn:00009CC2
.text$mn:00009CC2 ; ---------------------------------------------------------------------------
.text$mn:00009CC5                 align 4
.text$mn:00009CC5 _text$mn        ends
.text$mn:00009CC5
.text$mn:00009CC8 ; ===========================================================================
.text$mn:00009CC8
.text$mn:00009CC8 ; Segment type: Pure code
.text$mn:00009CC8 ; Segment permissions: Read/Execute
.text$mn:00009CC8 _text$mn        segment para public 'CODE' use32
.text$mn:00009CC8                 assume cs:_text$mn
.text$mn:00009CC8                 ;org 9CC8h
.text$mn:00009CC8 ; COMDAT (pick any)
.text$mn:00009CC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009CC8
.text$mn:00009CC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00009CC8
.text$mn:00009CC8 ; Attributes: bp-based frame
.text$mn:00009CC8
.text$mn:00009CC8 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:00009CC8                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00009CC8 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00009CC8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Alloc_proxy(void)+16p
.text$mn:00009CC8
.text$mn:00009CC8 var_4           = dword ptr -4
.text$mn:00009CC8 arg_0           = dword ptr  8
.text$mn:00009CC8
.text$mn:00009CC8                 push    ebp
.text$mn:00009CC9                 mov     ebp, esp
.text$mn:00009CCB                 push    ecx
.text$mn:00009CCC                 mov     [ebp+var_4], ecx
.text$mn:00009CCF                 mov     eax, [ebp+arg_0]
.text$mn:00009CD2                 push    eax
.text$mn:00009CD3                 mov     ecx, [ebp+var_4]
.text$mn:00009CD6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00009CDB                 mov     esp, ebp
.text$mn:00009CDD                 pop     ebp
.text$mn:00009CDE                 retn    4
.text$mn:00009CDE ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00009CDE
.text$mn:00009CDE ; ---------------------------------------------------------------------------
.text$mn:00009CE1                 align 4
.text$mn:00009CE1 _text$mn        ends
.text$mn:00009CE1
.text$mn:00009CE4 ; ===========================================================================
.text$mn:00009CE4
.text$mn:00009CE4 ; Segment type: Pure code
.text$mn:00009CE4 ; Segment permissions: Read/Execute
.text$mn:00009CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00009CE4                 assume cs:_text$mn
.text$mn:00009CE4                 ;org 9CE4h
.text$mn:00009CE4 ; COMDAT (pick any)
.text$mn:00009CE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009CE4
.text$mn:00009CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009CE4
.text$mn:00009CE4 ; Attributes: bp-based frame
.text$mn:00009CE4
.text$mn:00009CE4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::allocate(unsigned int)
.text$mn:00009CE4                 public ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:00009CE4 ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:00009CE4                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+41p
.text$mn:00009CE4
.text$mn:00009CE4 var_4           = dword ptr -4
.text$mn:00009CE4 arg_0           = dword ptr  8
.text$mn:00009CE4
.text$mn:00009CE4                 push    ebp
.text$mn:00009CE5                 mov     ebp, esp
.text$mn:00009CE7                 push    ecx
.text$mn:00009CE8                 mov     [ebp+var_4], ecx
.text$mn:00009CEB                 mov     eax, [ebp+arg_0]
.text$mn:00009CEE                 push    eax
.text$mn:00009CEF                 mov     ecx, [ebp+var_4]
.text$mn:00009CF2                 call    ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::allocate(uint)
.text$mn:00009CF7                 mov     esp, ebp
.text$mn:00009CF9                 pop     ebp
.text$mn:00009CFA                 retn    4
.text$mn:00009CFA ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:00009CFA
.text$mn:00009CFA ; ---------------------------------------------------------------------------
.text$mn:00009CFD                 align 10h
.text$mn:00009CFD _text$mn        ends
.text$mn:00009CFD
.text$mn:00009D00 ; ===========================================================================
.text$mn:00009D00
.text$mn:00009D00 ; Segment type: Pure code
.text$mn:00009D00 ; Segment permissions: Read/Execute
.text$mn:00009D00 _text$mn        segment para public 'CODE' use32
.text$mn:00009D00                 assume cs:_text$mn
.text$mn:00009D00                 ;org 9D00h
.text$mn:00009D00 ; COMDAT (pick any)
.text$mn:00009D00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009D00
.text$mn:00009D00 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D00
.text$mn:00009D00 ; Attributes: bp-based frame
.text$mn:00009D00
.text$mn:00009D00 ; public: class PluginCmdShortcut * __thiscall std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>>::allocate(unsigned int)
.text$mn:00009D00                 public ?allocate@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEPAVPluginCmdShortcut@@I@Z
.text$mn:00009D00 ?allocate@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEPAVPluginCmdShortcut@@I@Z proc near
.text$mn:00009D00                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reallocate(uint)+41p
.text$mn:00009D00
.text$mn:00009D00 var_4           = dword ptr -4
.text$mn:00009D00 arg_0           = dword ptr  8
.text$mn:00009D00
.text$mn:00009D00                 push    ebp
.text$mn:00009D01                 mov     ebp, esp
.text$mn:00009D03                 push    ecx
.text$mn:00009D04                 mov     [ebp+var_4], ecx
.text$mn:00009D07                 mov     eax, [ebp+arg_0]
.text$mn:00009D0A                 push    eax
.text$mn:00009D0B                 mov     ecx, [ebp+var_4]
.text$mn:00009D0E                 call    ?allocate@?$allocator@VPluginCmdShortcut@@@std@@QAEPAVPluginCmdShortcut@@I@Z ; std::allocator<PluginCmdShortcut>::allocate(uint)
.text$mn:00009D13                 mov     esp, ebp
.text$mn:00009D15                 pop     ebp
.text$mn:00009D16                 retn    4
.text$mn:00009D16 ?allocate@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEPAVPluginCmdShortcut@@I@Z endp
.text$mn:00009D16
.text$mn:00009D16 ; ---------------------------------------------------------------------------
.text$mn:00009D19                 align 4
.text$mn:00009D19 _text$mn        ends
.text$mn:00009D19
.text$mn:00009D1C ; ===========================================================================
.text$mn:00009D1C
.text$mn:00009D1C ; Segment type: Pure code
.text$mn:00009D1C ; Segment permissions: Read/Execute
.text$mn:00009D1C _text$mn        segment para public 'CODE' use32
.text$mn:00009D1C                 assume cs:_text$mn
.text$mn:00009D1C                 ;org 9D1Ch
.text$mn:00009D1C ; COMDAT (pick any)
.text$mn:00009D1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009D1C
.text$mn:00009D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00009D1C
.text$mn:00009D1C ; Attributes: bp-based frame
.text$mn:00009D1C
.text$mn:00009D1C ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00009D1C                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00009D1C ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00009D1C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00009D1C                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00009D1C
.text$mn:00009D1C var_4           = dword ptr -4
.text$mn:00009D1C arg_0           = dword ptr  8
.text$mn:00009D1C
.text$mn:00009D1C                 push    ebp
.text$mn:00009D1D                 mov     ebp, esp
.text$mn:00009D1F                 push    ecx
.text$mn:00009D20                 mov     [ebp+var_4], ecx
.text$mn:00009D23                 mov     eax, [ebp+arg_0]
.text$mn:00009D26                 push    eax
.text$mn:00009D27                 mov     ecx, [ebp+var_4]
.text$mn:00009D2A                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:00009D2F                 mov     esp, ebp
.text$mn:00009D31                 pop     ebp
.text$mn:00009D32                 retn    4
.text$mn:00009D32 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:00009D32
.text$mn:00009D32 ; ---------------------------------------------------------------------------
.text$mn:00009D35                 align 4
.text$mn:00009D35 _text$mn        ends
.text$mn:00009D35
.text$mn:00009D38 ; ===========================================================================
.text$mn:00009D38
.text$mn:00009D38 ; Segment type: Pure code
.text$mn:00009D38 ; Segment permissions: Read/Execute
.text$mn:00009D38 _text$mn        segment para public 'CODE' use32
.text$mn:00009D38                 assume cs:_text$mn
.text$mn:00009D38                 ;org 9D38h
.text$mn:00009D38 ; COMDAT (pick any)
.text$mn:00009D38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009D38
.text$mn:00009D38 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D38
.text$mn:00009D38 ; Attributes: bp-based frame
.text$mn:00009D38
.text$mn:00009D38 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00009D38                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00009D38 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00009D38                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00009D38
.text$mn:00009D38 var_4           = dword ptr -4
.text$mn:00009D38 arg_0           = dword ptr  8
.text$mn:00009D38
.text$mn:00009D38                 push    ebp
.text$mn:00009D39                 mov     ebp, esp
.text$mn:00009D3B                 push    ecx
.text$mn:00009D3C                 mov     [ebp+var_4], ecx
.text$mn:00009D3F                 push    0
.text$mn:00009D41                 mov     eax, [ebp+arg_0]
.text$mn:00009D44                 push    eax
.text$mn:00009D45                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00009D4A                 add     esp, 8
.text$mn:00009D4D                 mov     esp, ebp
.text$mn:00009D4F                 pop     ebp
.text$mn:00009D50                 retn    4
.text$mn:00009D50 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00009D50
.text$mn:00009D50 ; ---------------------------------------------------------------------------
.text$mn:00009D53                 align 4
.text$mn:00009D53 _text$mn        ends
.text$mn:00009D53
.text$mn:00009D54 ; ===========================================================================
.text$mn:00009D54
.text$mn:00009D54 ; Segment type: Pure code
.text$mn:00009D54 ; Segment permissions: Read/Execute
.text$mn:00009D54 _text$mn        segment para public 'CODE' use32
.text$mn:00009D54                 assume cs:_text$mn
.text$mn:00009D54                 ;org 9D54h
.text$mn:00009D54 ; COMDAT (pick any)
.text$mn:00009D54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009D54
.text$mn:00009D54 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D54
.text$mn:00009D54 ; Attributes: bp-based frame
.text$mn:00009D54
.text$mn:00009D54 ; public: struct PluginInfo * * __thiscall std::allocator<struct PluginInfo *>::allocate(unsigned int)
.text$mn:00009D54                 public ?allocate@?$allocator@PAUPluginInfo@@@std@@QAEPAPAUPluginInfo@@I@Z
.text$mn:00009D54 ?allocate@?$allocator@PAUPluginInfo@@@std@@QAEPAPAUPluginInfo@@I@Z proc near
.text$mn:00009D54                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginInfo *>>::allocate(uint)+Ep
.text$mn:00009D54
.text$mn:00009D54 var_4           = dword ptr -4
.text$mn:00009D54 arg_0           = dword ptr  8
.text$mn:00009D54
.text$mn:00009D54                 push    ebp
.text$mn:00009D55                 mov     ebp, esp
.text$mn:00009D57                 push    ecx
.text$mn:00009D58                 mov     [ebp+var_4], ecx
.text$mn:00009D5B                 push    0
.text$mn:00009D5D                 mov     eax, [ebp+arg_0]
.text$mn:00009D60                 push    eax
.text$mn:00009D61                 call    ??$_Allocate@PAUPluginInfo@@@std@@YAPAPAUPluginInfo@@IPAPAU1@@Z ; std::_Allocate<PluginInfo *>(uint,PluginInfo * *)
.text$mn:00009D66                 add     esp, 8
.text$mn:00009D69                 mov     esp, ebp
.text$mn:00009D6B                 pop     ebp
.text$mn:00009D6C                 retn    4
.text$mn:00009D6C ?allocate@?$allocator@PAUPluginInfo@@@std@@QAEPAPAUPluginInfo@@I@Z endp
.text$mn:00009D6C
.text$mn:00009D6C ; ---------------------------------------------------------------------------
.text$mn:00009D6F                 align 10h
.text$mn:00009D6F _text$mn        ends
.text$mn:00009D6F
.text$mn:00009D70 ; ===========================================================================
.text$mn:00009D70
.text$mn:00009D70 ; Segment type: Pure code
.text$mn:00009D70 ; Segment permissions: Read/Execute
.text$mn:00009D70 _text$mn        segment para public 'CODE' use32
.text$mn:00009D70                 assume cs:_text$mn
.text$mn:00009D70                 ;org 9D70h
.text$mn:00009D70 ; COMDAT (pick any)
.text$mn:00009D70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009D70
.text$mn:00009D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D70
.text$mn:00009D70 ; Attributes: bp-based frame
.text$mn:00009D70
.text$mn:00009D70 ; public: class TiXmlDocument * * __thiscall std::allocator<class TiXmlDocument *>::allocate(unsigned int)
.text$mn:00009D70                 public ?allocate@?$allocator@PAVTiXmlDocument@@@std@@QAEPAPAVTiXmlDocument@@I@Z
.text$mn:00009D70 ?allocate@?$allocator@PAVTiXmlDocument@@@std@@QAEPAPAVTiXmlDocument@@I@Z proc near
.text$mn:00009D70                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::allocate(uint)+Ep
.text$mn:00009D70
.text$mn:00009D70 var_4           = dword ptr -4
.text$mn:00009D70 arg_0           = dword ptr  8
.text$mn:00009D70
.text$mn:00009D70                 push    ebp
.text$mn:00009D71                 mov     ebp, esp
.text$mn:00009D73                 push    ecx
.text$mn:00009D74                 mov     [ebp+var_4], ecx
.text$mn:00009D77                 push    0
.text$mn:00009D79                 mov     eax, [ebp+arg_0]
.text$mn:00009D7C                 push    eax
.text$mn:00009D7D                 call    ??$_Allocate@PAVTiXmlDocument@@@std@@YAPAPAVTiXmlDocument@@IPAPAV1@@Z ; std::_Allocate<TiXmlDocument *>(uint,TiXmlDocument * *)
.text$mn:00009D82                 add     esp, 8
.text$mn:00009D85                 mov     esp, ebp
.text$mn:00009D87                 pop     ebp
.text$mn:00009D88                 retn    4
.text$mn:00009D88 ?allocate@?$allocator@PAVTiXmlDocument@@@std@@QAEPAPAVTiXmlDocument@@I@Z endp
.text$mn:00009D88
.text$mn:00009D88 ; ---------------------------------------------------------------------------
.text$mn:00009D8B                 align 4
.text$mn:00009D8B _text$mn        ends
.text$mn:00009D8B
.text$mn:00009D8C ; ===========================================================================
.text$mn:00009D8C
.text$mn:00009D8C ; Segment type: Pure code
.text$mn:00009D8C ; Segment permissions: Read/Execute
.text$mn:00009D8C _text$mn        segment para public 'CODE' use32
.text$mn:00009D8C                 assume cs:_text$mn
.text$mn:00009D8C                 ;org 9D8Ch
.text$mn:00009D8C ; COMDAT (pick any)
.text$mn:00009D8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009D8C
.text$mn:00009D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00009D8C
.text$mn:00009D8C ; Attributes: bp-based frame
.text$mn:00009D8C
.text$mn:00009D8C ; public: struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> * __thiscall std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>::allocate(unsigned int)
.text$mn:00009D8C                 public ?allocate@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z
.text$mn:00009D8C ?allocate@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z proc near
.text$mn:00009D8C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::allocate(uint)+Ep
.text$mn:00009D8C
.text$mn:00009D8C var_4           = dword ptr -4
.text$mn:00009D8C arg_0           = dword ptr  8
.text$mn:00009D8C
.text$mn:00009D8C                 push    ebp
.text$mn:00009D8D                 mov     ebp, esp
.text$mn:00009D8F                 push    ecx
.text$mn:00009D90                 mov     [ebp+var_4], ecx
.text$mn:00009D93                 push    0
.text$mn:00009D95                 mov     eax, [ebp+arg_0]
.text$mn:00009D98                 push    eax
.text$mn:00009D99                 call    ??$_Allocate@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@IPAU10@@Z ; std::_Allocate<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(uint,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:00009D9E                 add     esp, 8
.text$mn:00009DA1                 mov     esp, ebp
.text$mn:00009DA3                 pop     ebp
.text$mn:00009DA4                 retn    4
.text$mn:00009DA4 ?allocate@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z endp
.text$mn:00009DA4
.text$mn:00009DA4 ; ---------------------------------------------------------------------------
.text$mn:00009DA7                 align 4
.text$mn:00009DA7 _text$mn        ends
.text$mn:00009DA7
.text$mn:00009DA8 ; ===========================================================================
.text$mn:00009DA8
.text$mn:00009DA8 ; Segment type: Pure code
.text$mn:00009DA8 ; Segment permissions: Read/Execute
.text$mn:00009DA8 _text$mn        segment para public 'CODE' use32
.text$mn:00009DA8                 assume cs:_text$mn
.text$mn:00009DA8                 ;org 9DA8h
.text$mn:00009DA8 ; COMDAT (pick any)
.text$mn:00009DA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009DA8
.text$mn:00009DA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DA8
.text$mn:00009DA8 ; Attributes: bp-based frame
.text$mn:00009DA8
.text$mn:00009DA8 ; public: struct PluginCommand * __thiscall std::allocator<struct PluginCommand>::allocate(unsigned int)
.text$mn:00009DA8                 public ?allocate@?$allocator@UPluginCommand@@@std@@QAEPAUPluginCommand@@I@Z
.text$mn:00009DA8 ?allocate@?$allocator@UPluginCommand@@@std@@QAEPAUPluginCommand@@I@Z proc near
.text$mn:00009DA8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCommand>>::allocate(uint)+Ep
.text$mn:00009DA8
.text$mn:00009DA8 var_4           = dword ptr -4
.text$mn:00009DA8 arg_0           = dword ptr  8
.text$mn:00009DA8
.text$mn:00009DA8                 push    ebp
.text$mn:00009DA9                 mov     ebp, esp
.text$mn:00009DAB                 push    ecx
.text$mn:00009DAC                 mov     [ebp+var_4], ecx
.text$mn:00009DAF                 push    0
.text$mn:00009DB1                 mov     eax, [ebp+arg_0]
.text$mn:00009DB4                 push    eax
.text$mn:00009DB5                 call    ??$_Allocate@UPluginCommand@@@std@@YAPAUPluginCommand@@IPAU1@@Z ; std::_Allocate<PluginCommand>(uint,PluginCommand *)
.text$mn:00009DBA                 add     esp, 8
.text$mn:00009DBD                 mov     esp, ebp
.text$mn:00009DBF                 pop     ebp
.text$mn:00009DC0                 retn    4
.text$mn:00009DC0 ?allocate@?$allocator@UPluginCommand@@@std@@QAEPAUPluginCommand@@I@Z endp
.text$mn:00009DC0
.text$mn:00009DC0 ; ---------------------------------------------------------------------------
.text$mn:00009DC3                 align 4
.text$mn:00009DC3 _text$mn        ends
.text$mn:00009DC3
.text$mn:00009DC4 ; ===========================================================================
.text$mn:00009DC4
.text$mn:00009DC4 ; Segment type: Pure code
.text$mn:00009DC4 ; Segment permissions: Read/Execute
.text$mn:00009DC4 _text$mn        segment para public 'CODE' use32
.text$mn:00009DC4                 assume cs:_text$mn
.text$mn:00009DC4                 ;org 9DC4h
.text$mn:00009DC4 ; COMDAT (pick any)
.text$mn:00009DC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009DC4
.text$mn:00009DC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DC4
.text$mn:00009DC4 ; Attributes: bp-based frame
.text$mn:00009DC4
.text$mn:00009DC4 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00009DC4                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00009DC4 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00009DC4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00009DC4                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p ...
.text$mn:00009DC4
.text$mn:00009DC4 var_4           = dword ptr -4
.text$mn:00009DC4 arg_0           = dword ptr  8
.text$mn:00009DC4
.text$mn:00009DC4                 push    ebp
.text$mn:00009DC5                 mov     ebp, esp
.text$mn:00009DC7                 push    ecx
.text$mn:00009DC8                 mov     [ebp+var_4], ecx
.text$mn:00009DCB                 push    0
.text$mn:00009DCD                 mov     eax, [ebp+arg_0]
.text$mn:00009DD0                 push    eax
.text$mn:00009DD1                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00009DD6                 add     esp, 8
.text$mn:00009DD9                 mov     esp, ebp
.text$mn:00009DDB                 pop     ebp
.text$mn:00009DDC                 retn    4
.text$mn:00009DDC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00009DDC
.text$mn:00009DDC ; ---------------------------------------------------------------------------
.text$mn:00009DDF                 align 10h
.text$mn:00009DDF _text$mn        ends
.text$mn:00009DDF
.text$mn:00009DE0 ; ===========================================================================
.text$mn:00009DE0
.text$mn:00009DE0 ; Segment type: Pure code
.text$mn:00009DE0 ; Segment permissions: Read/Execute
.text$mn:00009DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00009DE0                 assume cs:_text$mn
.text$mn:00009DE0                 ;org 9DE0h
.text$mn:00009DE0 ; COMDAT (pick any)
.text$mn:00009DE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009DE0
.text$mn:00009DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DE0
.text$mn:00009DE0 ; Attributes: bp-based frame
.text$mn:00009DE0
.text$mn:00009DE0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> * __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::allocate(unsigned int)
.text$mn:00009DE0                 public ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:00009DE0 ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:00009DE0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::allocate(uint)+Ep
.text$mn:00009DE0
.text$mn:00009DE0 var_4           = dword ptr -4
.text$mn:00009DE0 arg_0           = dword ptr  8
.text$mn:00009DE0
.text$mn:00009DE0                 push    ebp
.text$mn:00009DE1                 mov     ebp, esp
.text$mn:00009DE3                 push    ecx
.text$mn:00009DE4                 mov     [ebp+var_4], ecx
.text$mn:00009DE7                 push    0
.text$mn:00009DE9                 mov     eax, [ebp+arg_0]
.text$mn:00009DEC                 push    eax
.text$mn:00009DED                 call    ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:00009DF2                 add     esp, 8
.text$mn:00009DF5                 mov     esp, ebp
.text$mn:00009DF7                 pop     ebp
.text$mn:00009DF8                 retn    4
.text$mn:00009DF8 ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:00009DF8
.text$mn:00009DF8 ; ---------------------------------------------------------------------------
.text$mn:00009DFB                 align 4
.text$mn:00009DFB _text$mn        ends
.text$mn:00009DFB
.text$mn:00009DFC ; ===========================================================================
.text$mn:00009DFC
.text$mn:00009DFC ; Segment type: Pure code
.text$mn:00009DFC ; Segment permissions: Read/Execute
.text$mn:00009DFC _text$mn        segment para public 'CODE' use32
.text$mn:00009DFC                 assume cs:_text$mn
.text$mn:00009DFC                 ;org 9DFCh
.text$mn:00009DFC ; COMDAT (pick any)
.text$mn:00009DFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009DFC
.text$mn:00009DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00009DFC
.text$mn:00009DFC ; Attributes: bp-based frame
.text$mn:00009DFC
.text$mn:00009DFC ; public: class PluginCmdShortcut * __thiscall std::allocator<class PluginCmdShortcut>::allocate(unsigned int)
.text$mn:00009DFC                 public ?allocate@?$allocator@VPluginCmdShortcut@@@std@@QAEPAVPluginCmdShortcut@@I@Z
.text$mn:00009DFC ?allocate@?$allocator@VPluginCmdShortcut@@@std@@QAEPAVPluginCmdShortcut@@I@Z proc near
.text$mn:00009DFC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::allocate(uint)+Ep
.text$mn:00009DFC
.text$mn:00009DFC var_4           = dword ptr -4
.text$mn:00009DFC arg_0           = dword ptr  8
.text$mn:00009DFC
.text$mn:00009DFC                 push    ebp
.text$mn:00009DFD                 mov     ebp, esp
.text$mn:00009DFF                 push    ecx
.text$mn:00009E00                 mov     [ebp+var_4], ecx
.text$mn:00009E03                 push    0
.text$mn:00009E05                 mov     eax, [ebp+arg_0]
.text$mn:00009E08                 push    eax
.text$mn:00009E09                 call    ??$_Allocate@VPluginCmdShortcut@@@std@@YAPAVPluginCmdShortcut@@IPAV1@@Z ; std::_Allocate<PluginCmdShortcut>(uint,PluginCmdShortcut *)
.text$mn:00009E0E                 add     esp, 8
.text$mn:00009E11                 mov     esp, ebp
.text$mn:00009E13                 pop     ebp
.text$mn:00009E14                 retn    4
.text$mn:00009E14 ?allocate@?$allocator@VPluginCmdShortcut@@@std@@QAEPAVPluginCmdShortcut@@I@Z endp
.text$mn:00009E14
.text$mn:00009E14 ; ---------------------------------------------------------------------------
.text$mn:00009E17                 align 4
.text$mn:00009E17 _text$mn        ends
.text$mn:00009E17
.text$mn:00009E18 ; ===========================================================================
.text$mn:00009E18
.text$mn:00009E18 ; Segment type: Pure code
.text$mn:00009E18 ; Segment permissions: Read/Execute
.text$mn:00009E18 _text$mn        segment para public 'CODE' use32
.text$mn:00009E18                 assume cs:_text$mn
.text$mn:00009E18                 ;org 9E18h
.text$mn:00009E18 ; COMDAT (pick any)
.text$mn:00009E18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009E18
.text$mn:00009E18 ; =============== S U B R O U T I N E =======================================
.text$mn:00009E18
.text$mn:00009E18 ; Attributes: bp-based frame
.text$mn:00009E18
.text$mn:00009E18 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:00009E18                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:00009E18 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:00009E18                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:00009E18
.text$mn:00009E18 var_4           = dword ptr -4
.text$mn:00009E18 arg_0           = dword ptr  8
.text$mn:00009E18
.text$mn:00009E18                 push    ebp
.text$mn:00009E19                 mov     ebp, esp
.text$mn:00009E1B                 push    ecx
.text$mn:00009E1C                 mov     [ebp+var_4], ecx
.text$mn:00009E1F                 push    0
.text$mn:00009E21                 mov     eax, [ebp+arg_0]
.text$mn:00009E24                 push    eax
.text$mn:00009E25                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:00009E2A                 add     esp, 8
.text$mn:00009E2D                 mov     esp, ebp
.text$mn:00009E2F                 pop     ebp
.text$mn:00009E30                 retn    4
.text$mn:00009E30 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00009E30
.text$mn:00009E30 ; ---------------------------------------------------------------------------
.text$mn:00009E33                 align 4
.text$mn:00009E33 _text$mn        ends
.text$mn:00009E33
.text$mn:00009E34 ; ===========================================================================
.text$mn:00009E34
.text$mn:00009E34 ; Segment type: Pure code
.text$mn:00009E34 ; Segment permissions: Read/Execute
.text$mn:00009E34 _text$mn        segment para public 'CODE' use32
.text$mn:00009E34                 assume cs:_text$mn
.text$mn:00009E34                 ;org 9E34h
.text$mn:00009E34 ; COMDAT (pick any)
.text$mn:00009E34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009E34
.text$mn:00009E34 ; =============== S U B R O U T I N E =======================================
.text$mn:00009E34
.text$mn:00009E34 ; Attributes: bp-based frame
.text$mn:00009E34
.text$mn:00009E34 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00009E34                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:00009E34 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:00009E34                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Ep
.text$mn:00009E34
.text$mn:00009E34 var_4           = dword ptr -4
.text$mn:00009E34 arg_0           = dword ptr  8
.text$mn:00009E34
.text$mn:00009E34                 push    ebp
.text$mn:00009E35                 mov     ebp, esp
.text$mn:00009E37                 push    ecx
.text$mn:00009E38                 mov     [ebp+var_4], ecx
.text$mn:00009E3B                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00009E40                 push    eax
.text$mn:00009E41                 push    0
.text$mn:00009E43                 mov     ecx, [ebp+arg_0]
.text$mn:00009E46                 push    ecx
.text$mn:00009E47                 mov     ecx, [ebp+var_4]
.text$mn:00009E4A                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00009E4F                 mov     esp, ebp
.text$mn:00009E51                 pop     ebp
.text$mn:00009E52                 retn    4
.text$mn:00009E52 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:00009E52
.text$mn:00009E52 ; ---------------------------------------------------------------------------
.text$mn:00009E55                 align 4
.text$mn:00009E55 _text$mn        ends
.text$mn:00009E55
.text$mn:00009E58 ; ===========================================================================
.text$mn:00009E58
.text$mn:00009E58 ; Segment type: Pure code
.text$mn:00009E58 ; Segment permissions: Read/Execute
.text$mn:00009E58 _text$mn        segment para public 'CODE' use32
.text$mn:00009E58                 assume cs:_text$mn
.text$mn:00009E58                 ;org 9E58h
.text$mn:00009E58 ; COMDAT (pick any)
.text$mn:00009E58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009E58
.text$mn:00009E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00009E58
.text$mn:00009E58 ; Attributes: bp-based frame
.text$mn:00009E58
.text$mn:00009E58 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00009E58                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00009E58 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00009E58                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+16p
.text$mn:00009E58                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+53p
.text$mn:00009E58
.text$mn:00009E58 var_8           = dword ptr -8
.text$mn:00009E58 var_4           = dword ptr -4
.text$mn:00009E58 arg_0           = dword ptr  8
.text$mn:00009E58 arg_4           = dword ptr  0Ch
.text$mn:00009E58 arg_8           = dword ptr  10h
.text$mn:00009E58
.text$mn:00009E58                 push    ebp
.text$mn:00009E59                 mov     ebp, esp
.text$mn:00009E5B                 sub     esp, 8
.text$mn:00009E5E                 mov     [ebp+var_4], ecx
.text$mn:00009E61                 mov     ecx, [ebp+arg_0]
.text$mn:00009E64                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00009E69                 cmp     eax, [ebp+arg_4]
.text$mn:00009E6C                 jnb     short loc_9E76
.text$mn:00009E6E                 mov     ecx, [ebp+var_4]
.text$mn:00009E71                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00009E76
.text$mn:00009E76 loc_9E76:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00009E76                 mov     ecx, [ebp+arg_0]
.text$mn:00009E79                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00009E7E                 sub     eax, [ebp+arg_4]
.text$mn:00009E81                 mov     [ebp+var_8], eax
.text$mn:00009E84                 mov     eax, [ebp+var_8]
.text$mn:00009E87                 cmp     eax, [ebp+arg_8]
.text$mn:00009E8A                 jnb     short loc_9E92
.text$mn:00009E8C                 mov     ecx, [ebp+var_8]
.text$mn:00009E8F                 mov     [ebp+arg_8], ecx
.text$mn:00009E92
.text$mn:00009E92 loc_9E92:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00009E92                 mov     edx, [ebp+var_4]
.text$mn:00009E95                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00009E9A                 sub     eax, [edx+14h]
.text$mn:00009E9D                 cmp     eax, [ebp+arg_8]
.text$mn:00009EA0                 ja      short loc_9EAA
.text$mn:00009EA2                 mov     ecx, [ebp+var_4]
.text$mn:00009EA5                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00009EAA
.text$mn:00009EAA loc_9EAA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+48j
.text$mn:00009EAA                 cmp     [ebp+arg_8], 0
.text$mn:00009EAE                 jbe     short loc_9F0A
.text$mn:00009EB0                 mov     ecx, [ebp+var_4]
.text$mn:00009EB3                 mov     edx, [ecx+14h]
.text$mn:00009EB6                 add     edx, [ebp+arg_8]
.text$mn:00009EB9                 mov     [ebp+var_8], edx
.text$mn:00009EBC                 push    0
.text$mn:00009EBE                 mov     eax, [ebp+var_8]
.text$mn:00009EC1                 push    eax
.text$mn:00009EC2                 mov     ecx, [ebp+var_4]
.text$mn:00009EC5                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00009ECA                 movzx   ecx, al
.text$mn:00009ECD                 test    ecx, ecx
.text$mn:00009ECF                 jz      short loc_9F0A
.text$mn:00009ED1                 mov     edx, [ebp+arg_8]
.text$mn:00009ED4                 push    edx             ; int
.text$mn:00009ED5                 mov     ecx, [ebp+arg_0]
.text$mn:00009ED8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009EDD                 mov     ecx, [ebp+arg_4]
.text$mn:00009EE0                 lea     edx, [eax+ecx*2]
.text$mn:00009EE3                 push    edx             ; Src
.text$mn:00009EE4                 mov     ecx, [ebp+var_4]
.text$mn:00009EE7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009EEC                 mov     ecx, [ebp+var_4]
.text$mn:00009EEF                 mov     edx, [ecx+14h]
.text$mn:00009EF2                 lea     eax, [eax+edx*2]
.text$mn:00009EF5                 push    eax             ; Dst
.text$mn:00009EF6                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00009EFB                 add     esp, 0Ch
.text$mn:00009EFE                 mov     ecx, [ebp+var_8]
.text$mn:00009F01                 push    ecx
.text$mn:00009F02                 mov     ecx, [ebp+var_4]
.text$mn:00009F05                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00009F0A
.text$mn:00009F0A loc_9F0A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+56j
.text$mn:00009F0A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+77j
.text$mn:00009F0A                 mov     eax, [ebp+var_4]
.text$mn:00009F0D                 mov     esp, ebp
.text$mn:00009F0F                 pop     ebp
.text$mn:00009F10                 retn    0Ch
.text$mn:00009F10 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00009F10
.text$mn:00009F10 ; ---------------------------------------------------------------------------
.text$mn:00009F13                 align 4
.text$mn:00009F13 _text$mn        ends
.text$mn:00009F13
.text$mn:00009F14 ; ===========================================================================
.text$mn:00009F14
.text$mn:00009F14 ; Segment type: Pure code
.text$mn:00009F14 ; Segment permissions: Read/Execute
.text$mn:00009F14 _text$mn        segment para public 'CODE' use32
.text$mn:00009F14                 assume cs:_text$mn
.text$mn:00009F14                 ;org 9F14h
.text$mn:00009F14 ; COMDAT (pick any)
.text$mn:00009F14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009F14
.text$mn:00009F14 ; =============== S U B R O U T I N E =======================================
.text$mn:00009F14
.text$mn:00009F14 ; Attributes: bp-based frame
.text$mn:00009F14
.text$mn:00009F14 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t *Str)
.text$mn:00009F14                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00009F14 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00009F14                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&,wchar_t const *)+31p
.text$mn:00009F14                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)+Ep
.text$mn:00009F14
.text$mn:00009F14 var_4           = dword ptr -4
.text$mn:00009F14 Str             = dword ptr  8
.text$mn:00009F14
.text$mn:00009F14                 push    ebp
.text$mn:00009F15                 mov     ebp, esp
.text$mn:00009F17                 push    ecx
.text$mn:00009F18                 mov     [ebp+var_4], ecx
.text$mn:00009F1B                 push    43Eh            ; unsigned int
.text$mn:00009F20                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009F25                 mov     eax, [ebp+Str]
.text$mn:00009F28                 push    eax             ; int
.text$mn:00009F29                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00009F2E                 add     esp, 0Ch
.text$mn:00009F31                 mov     ecx, [ebp+Str]
.text$mn:00009F34                 push    ecx             ; Str
.text$mn:00009F35                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00009F3A                 add     esp, 4
.text$mn:00009F3D                 push    eax             ; int
.text$mn:00009F3E                 mov     edx, [ebp+Str]
.text$mn:00009F41                 push    edx             ; Src
.text$mn:00009F42                 mov     ecx, [ebp+var_4]
.text$mn:00009F45                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)
.text$mn:00009F4A                 mov     esp, ebp
.text$mn:00009F4C                 pop     ebp
.text$mn:00009F4D                 retn    4
.text$mn:00009F4D ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00009F4D
.text$mn:00009F4D _text$mn        ends
.text$mn:00009F4D
.text$mn:00009F50 ; ===========================================================================
.text$mn:00009F50
.text$mn:00009F50 ; Segment type: Pure code
.text$mn:00009F50 ; Segment permissions: Read/Execute
.text$mn:00009F50 _text$mn        segment para public 'CODE' use32
.text$mn:00009F50                 assume cs:_text$mn
.text$mn:00009F50                 ;org 9F50h
.text$mn:00009F50 ; COMDAT (pick any)
.text$mn:00009F50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009F50
.text$mn:00009F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00009F50
.text$mn:00009F50 ; Attributes: bp-based frame
.text$mn:00009F50
.text$mn:00009F50 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(void *Src, int)
.text$mn:00009F50                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00009F50 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00009F50                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+31p
.text$mn:00009F50
.text$mn:00009F50 var_8           = dword ptr -8
.text$mn:00009F50 var_4           = dword ptr -4
.text$mn:00009F50 Src             = dword ptr  8
.text$mn:00009F50 arg_4           = dword ptr  0Ch
.text$mn:00009F50
.text$mn:00009F50                 push    ebp
.text$mn:00009F51                 mov     ebp, esp
.text$mn:00009F53                 sub     esp, 8
.text$mn:00009F56                 mov     [ebp+var_4], ecx
.text$mn:00009F59                 cmp     [ebp+arg_4], 0
.text$mn:00009F5D                 jz      short loc_9F75
.text$mn:00009F5F                 push    42Ah            ; unsigned int
.text$mn:00009F64                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009F69                 mov     eax, [ebp+Src]
.text$mn:00009F6C                 push    eax             ; int
.text$mn:00009F6D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00009F72                 add     esp, 0Ch
.text$mn:00009F75
.text$mn:00009F75 loc_9F75:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+Dj
.text$mn:00009F75                 mov     ecx, [ebp+Src]
.text$mn:00009F78                 push    ecx
.text$mn:00009F79                 mov     ecx, [ebp+var_4]
.text$mn:00009F7C                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00009F81                 movzx   edx, al
.text$mn:00009F84                 test    edx, edx
.text$mn:00009F86                 jz      short loc_9FAA
.text$mn:00009F88                 mov     eax, [ebp+arg_4]
.text$mn:00009F8B                 push    eax
.text$mn:00009F8C                 mov     ecx, [ebp+var_4]
.text$mn:00009F8F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009F94                 mov     ecx, [ebp+Src]
.text$mn:00009F97                 sub     ecx, eax
.text$mn:00009F99                 sar     ecx, 1
.text$mn:00009F9B                 push    ecx
.text$mn:00009F9C                 mov     edx, [ebp+var_4]
.text$mn:00009F9F                 push    edx
.text$mn:00009FA0                 mov     ecx, [ebp+var_4]
.text$mn:00009FA3                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00009FA8                 jmp     short loc_A01B
.text$mn:00009FAA ; ---------------------------------------------------------------------------
.text$mn:00009FAA
.text$mn:00009FAA loc_9FAA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+36j
.text$mn:00009FAA                 mov     eax, [ebp+var_4]
.text$mn:00009FAD                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00009FB3                 sub     ecx, [eax+14h]
.text$mn:00009FB6                 cmp     ecx, [ebp+arg_4]
.text$mn:00009FB9                 ja      short loc_9FC3
.text$mn:00009FBB                 mov     ecx, [ebp+var_4]
.text$mn:00009FBE                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00009FC3
.text$mn:00009FC3 loc_9FC3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+69j
.text$mn:00009FC3                 cmp     [ebp+arg_4], 0
.text$mn:00009FC7                 jbe     short loc_A018
.text$mn:00009FC9                 mov     edx, [ebp+var_4]
.text$mn:00009FCC                 mov     eax, [edx+14h]
.text$mn:00009FCF                 add     eax, [ebp+arg_4]
.text$mn:00009FD2                 mov     [ebp+var_8], eax
.text$mn:00009FD5                 push    0
.text$mn:00009FD7                 mov     ecx, [ebp+var_8]
.text$mn:00009FDA                 push    ecx
.text$mn:00009FDB                 mov     ecx, [ebp+var_4]
.text$mn:00009FDE                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00009FE3                 movzx   edx, al
.text$mn:00009FE6                 test    edx, edx
.text$mn:00009FE8                 jz      short loc_A018
.text$mn:00009FEA                 mov     eax, [ebp+arg_4]
.text$mn:00009FED                 push    eax             ; int
.text$mn:00009FEE                 mov     ecx, [ebp+Src]
.text$mn:00009FF1                 push    ecx             ; Src
.text$mn:00009FF2                 mov     ecx, [ebp+var_4]
.text$mn:00009FF5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009FFA                 mov     edx, [ebp+var_4]
.text$mn:00009FFD                 mov     ecx, [edx+14h]
.text$mn:0000A000                 lea     edx, [eax+ecx*2]
.text$mn:0000A003                 push    edx             ; Dst
.text$mn:0000A004                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000A009                 add     esp, 0Ch
.text$mn:0000A00C                 mov     eax, [ebp+var_8]
.text$mn:0000A00F                 push    eax
.text$mn:0000A010                 mov     ecx, [ebp+var_4]
.text$mn:0000A013                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A018
.text$mn:0000A018 loc_A018:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+77j
.text$mn:0000A018                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+98j
.text$mn:0000A018                 mov     eax, [ebp+var_4]
.text$mn:0000A01B
.text$mn:0000A01B loc_A01B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+58j
.text$mn:0000A01B                 mov     esp, ebp
.text$mn:0000A01D                 pop     ebp
.text$mn:0000A01E                 retn    8
.text$mn:0000A01E ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000A01E
.text$mn:0000A01E ; ---------------------------------------------------------------------------
.text$mn:0000A021                 align 4
.text$mn:0000A021 _text$mn        ends
.text$mn:0000A021
.text$mn:0000A024 ; ===========================================================================
.text$mn:0000A024
.text$mn:0000A024 ; Segment type: Pure code
.text$mn:0000A024 ; Segment permissions: Read/Execute
.text$mn:0000A024 _text$mn        segment para public 'CODE' use32
.text$mn:0000A024                 assume cs:_text$mn
.text$mn:0000A024                 ;org 0A024h
.text$mn:0000A024 ; COMDAT (pick any)
.text$mn:0000A024                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A024
.text$mn:0000A024 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A024
.text$mn:0000A024 ; Attributes: bp-based frame
.text$mn:0000A024
.text$mn:0000A024 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:0000A024                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000A024 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000A024                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:0000A024
.text$mn:0000A024 Size            = dword ptr -8
.text$mn:0000A024 var_4           = dword ptr -4
.text$mn:0000A024 arg_0           = dword ptr  8
.text$mn:0000A024 arg_4           = dword ptr  0Ch
.text$mn:0000A024 arg_8           = dword ptr  10h
.text$mn:0000A024
.text$mn:0000A024                 push    ebp
.text$mn:0000A025                 mov     ebp, esp
.text$mn:0000A027                 sub     esp, 8
.text$mn:0000A02A                 mov     [ebp+var_4], ecx
.text$mn:0000A02D                 mov     ecx, [ebp+arg_0]
.text$mn:0000A030                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000A035                 cmp     eax, [ebp+arg_4]
.text$mn:0000A038                 jnb     short loc_A042
.text$mn:0000A03A                 mov     ecx, [ebp+var_4]
.text$mn:0000A03D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000A042
.text$mn:0000A042 loc_A042:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000A042                 mov     ecx, [ebp+arg_0]
.text$mn:0000A045                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000A04A                 sub     eax, [ebp+arg_4]
.text$mn:0000A04D                 mov     [ebp+Size], eax
.text$mn:0000A050                 mov     eax, [ebp+arg_8]
.text$mn:0000A053                 cmp     eax, [ebp+Size]
.text$mn:0000A056                 jnb     short loc_A05E
.text$mn:0000A058                 mov     ecx, [ebp+arg_8]
.text$mn:0000A05B                 mov     [ebp+Size], ecx
.text$mn:0000A05E
.text$mn:0000A05E loc_A05E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000A05E                 mov     edx, [ebp+var_4]
.text$mn:0000A061                 cmp     edx, [ebp+arg_0]
.text$mn:0000A064                 jnz     short loc_A085
.text$mn:0000A066                 mov     eax, [ebp+arg_4]
.text$mn:0000A069                 add     eax, [ebp+Size]
.text$mn:0000A06C                 push    eax
.text$mn:0000A06D                 mov     ecx, [ebp+var_4]
.text$mn:0000A070                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:0000A075                 mov     ecx, [ebp+arg_4]
.text$mn:0000A078                 push    ecx
.text$mn:0000A079                 push    0
.text$mn:0000A07B                 mov     ecx, [ebp+var_4]
.text$mn:0000A07E                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000A083                 jmp     short loc_A0C7
.text$mn:0000A085 ; ---------------------------------------------------------------------------
.text$mn:0000A085
.text$mn:0000A085 loc_A085:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:0000A085                 push    0
.text$mn:0000A087                 mov     edx, [ebp+Size]
.text$mn:0000A08A                 push    edx
.text$mn:0000A08B                 mov     ecx, [ebp+var_4]
.text$mn:0000A08E                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000A093                 movzx   eax, al
.text$mn:0000A096                 test    eax, eax
.text$mn:0000A098                 jz      short loc_A0C7
.text$mn:0000A09A                 mov     ecx, [ebp+Size]
.text$mn:0000A09D                 push    ecx             ; Size
.text$mn:0000A09E                 mov     ecx, [ebp+arg_0]
.text$mn:0000A0A1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000A0A6                 add     eax, [ebp+arg_4]
.text$mn:0000A0A9                 push    eax             ; Src
.text$mn:0000A0AA                 mov     ecx, [ebp+var_4]
.text$mn:0000A0AD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000A0B2                 push    eax             ; Dst
.text$mn:0000A0B3                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000A0B8                 add     esp, 0Ch
.text$mn:0000A0BB                 mov     edx, [ebp+Size]
.text$mn:0000A0BE                 push    edx
.text$mn:0000A0BF                 mov     ecx, [ebp+var_4]
.text$mn:0000A0C2                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000A0C7
.text$mn:0000A0C7 loc_A0C7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:0000A0C7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:0000A0C7                 mov     eax, [ebp+var_4]
.text$mn:0000A0CA                 mov     esp, ebp
.text$mn:0000A0CC                 pop     ebp
.text$mn:0000A0CD                 retn    0Ch
.text$mn:0000A0CD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000A0CD
.text$mn:0000A0CD _text$mn        ends
.text$mn:0000A0CD
.text$mn:0000A0D0 ; ===========================================================================
.text$mn:0000A0D0
.text$mn:0000A0D0 ; Segment type: Pure code
.text$mn:0000A0D0 ; Segment permissions: Read/Execute
.text$mn:0000A0D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A0D0                 assume cs:_text$mn
.text$mn:0000A0D0                 ;org 0A0D0h
.text$mn:0000A0D0 ; COMDAT (pick any)
.text$mn:0000A0D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A0D0
.text$mn:0000A0D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A0D0
.text$mn:0000A0D0 ; Attributes: bp-based frame
.text$mn:0000A0D0
.text$mn:0000A0D0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:0000A0D0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:0000A0D0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:0000A0D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:0000A0D0
.text$mn:0000A0D0 var_4           = dword ptr -4
.text$mn:0000A0D0 Str             = dword ptr  8
.text$mn:0000A0D0
.text$mn:0000A0D0                 push    ebp
.text$mn:0000A0D1                 mov     ebp, esp
.text$mn:0000A0D3                 push    ecx
.text$mn:0000A0D4                 mov     [ebp+var_4], ecx
.text$mn:0000A0D7                 push    490h            ; unsigned int
.text$mn:0000A0DC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A0E1                 mov     eax, [ebp+Str]
.text$mn:0000A0E4                 push    eax             ; int
.text$mn:0000A0E5                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000A0EA                 add     esp, 0Ch
.text$mn:0000A0ED                 mov     ecx, [ebp+Str]
.text$mn:0000A0F0                 push    ecx             ; Str
.text$mn:0000A0F1                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000A0F6                 add     esp, 4
.text$mn:0000A0F9                 push    eax             ; Size
.text$mn:0000A0FA                 mov     edx, [ebp+Str]
.text$mn:0000A0FD                 push    edx             ; Src
.text$mn:0000A0FE                 mov     ecx, [ebp+var_4]
.text$mn:0000A101                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000A106                 mov     esp, ebp
.text$mn:0000A108                 pop     ebp
.text$mn:0000A109                 retn    4
.text$mn:0000A109 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:0000A109
.text$mn:0000A109 _text$mn        ends
.text$mn:0000A109
.text$mn:0000A10C ; ===========================================================================
.text$mn:0000A10C
.text$mn:0000A10C ; Segment type: Pure code
.text$mn:0000A10C ; Segment permissions: Read/Execute
.text$mn:0000A10C _text$mn        segment para public 'CODE' use32
.text$mn:0000A10C                 assume cs:_text$mn
.text$mn:0000A10C                 ;org 0A10Ch
.text$mn:0000A10C ; COMDAT (pick any)
.text$mn:0000A10C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A10C
.text$mn:0000A10C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A10C
.text$mn:0000A10C ; Attributes: bp-based frame
.text$mn:0000A10C
.text$mn:0000A10C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000A10C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000A10C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000A10C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000A10C
.text$mn:0000A10C var_4           = dword ptr -4
.text$mn:0000A10C Src             = dword ptr  8
.text$mn:0000A10C Size            = dword ptr  0Ch
.text$mn:0000A10C
.text$mn:0000A10C                 push    ebp
.text$mn:0000A10D                 mov     ebp, esp
.text$mn:0000A10F                 push    ecx
.text$mn:0000A110                 mov     [ebp+var_4], ecx
.text$mn:0000A113                 cmp     [ebp+Size], 0
.text$mn:0000A117                 jz      short loc_A12F
.text$mn:0000A119                 push    47Fh            ; unsigned int
.text$mn:0000A11E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A123                 mov     eax, [ebp+Src]
.text$mn:0000A126                 push    eax             ; int
.text$mn:0000A127                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000A12C                 add     esp, 0Ch
.text$mn:0000A12F
.text$mn:0000A12F loc_A12F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000A12F                 mov     ecx, [ebp+Src]
.text$mn:0000A132                 push    ecx
.text$mn:0000A133                 mov     ecx, [ebp+var_4]
.text$mn:0000A136                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000A13B                 movzx   edx, al
.text$mn:0000A13E                 test    edx, edx
.text$mn:0000A140                 jz      short loc_A162
.text$mn:0000A142                 mov     eax, [ebp+Size]
.text$mn:0000A145                 push    eax
.text$mn:0000A146                 mov     ecx, [ebp+var_4]
.text$mn:0000A149                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000A14E                 mov     ecx, [ebp+Src]
.text$mn:0000A151                 sub     ecx, eax
.text$mn:0000A153                 push    ecx
.text$mn:0000A154                 mov     edx, [ebp+var_4]
.text$mn:0000A157                 push    edx
.text$mn:0000A158                 mov     ecx, [ebp+var_4]
.text$mn:0000A15B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:0000A160                 jmp     short loc_A19F
.text$mn:0000A162 ; ---------------------------------------------------------------------------
.text$mn:0000A162
.text$mn:0000A162 loc_A162:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000A162                 push    0
.text$mn:0000A164                 mov     eax, [ebp+Size]
.text$mn:0000A167                 push    eax
.text$mn:0000A168                 mov     ecx, [ebp+var_4]
.text$mn:0000A16B                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000A170                 movzx   ecx, al
.text$mn:0000A173                 test    ecx, ecx
.text$mn:0000A175                 jz      short loc_A19C
.text$mn:0000A177                 mov     edx, [ebp+Size]
.text$mn:0000A17A                 push    edx             ; Size
.text$mn:0000A17B                 mov     eax, [ebp+Src]
.text$mn:0000A17E                 push    eax             ; Src
.text$mn:0000A17F                 mov     ecx, [ebp+var_4]
.text$mn:0000A182                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000A187                 push    eax             ; Dst
.text$mn:0000A188                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000A18D                 add     esp, 0Ch
.text$mn:0000A190                 mov     ecx, [ebp+Size]
.text$mn:0000A193                 push    ecx
.text$mn:0000A194                 mov     ecx, [ebp+var_4]
.text$mn:0000A197                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000A19C
.text$mn:0000A19C loc_A19C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:0000A19C                 mov     eax, [ebp+var_4]
.text$mn:0000A19F
.text$mn:0000A19F loc_A19F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000A19F                 mov     esp, ebp
.text$mn:0000A1A1                 pop     ebp
.text$mn:0000A1A2                 retn    8
.text$mn:0000A1A2 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000A1A2
.text$mn:0000A1A2 ; ---------------------------------------------------------------------------
.text$mn:0000A1A5                 align 4
.text$mn:0000A1A5 _text$mn        ends
.text$mn:0000A1A5
.text$mn:0000A1A8 ; ===========================================================================
.text$mn:0000A1A8
.text$mn:0000A1A8 ; Segment type: Pure code
.text$mn:0000A1A8 ; Segment permissions: Read/Execute
.text$mn:0000A1A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A1A8                 assume cs:_text$mn
.text$mn:0000A1A8                 ;org 0A1A8h
.text$mn:0000A1A8 ; COMDAT (pick any)
.text$mn:0000A1A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A1A8
.text$mn:0000A1A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A1A8
.text$mn:0000A1A8 ; Attributes: bp-based frame
.text$mn:0000A1A8
.text$mn:0000A1A8 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000A1A8                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000A1A8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000A1A8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bp
.text$mn:0000A1A8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:0000A1A8
.text$mn:0000A1A8 var_8           = dword ptr -8
.text$mn:0000A1A8 var_4           = dword ptr -4
.text$mn:0000A1A8 arg_0           = dword ptr  8
.text$mn:0000A1A8 arg_4           = dword ptr  0Ch
.text$mn:0000A1A8 arg_8           = dword ptr  10h
.text$mn:0000A1A8
.text$mn:0000A1A8                 push    ebp
.text$mn:0000A1A9                 mov     ebp, esp
.text$mn:0000A1AB                 sub     esp, 8
.text$mn:0000A1AE                 mov     [ebp+var_4], ecx
.text$mn:0000A1B1                 mov     ecx, [ebp+arg_0]
.text$mn:0000A1B4                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000A1B9                 cmp     eax, [ebp+arg_4]
.text$mn:0000A1BC                 jnb     short loc_A1C6
.text$mn:0000A1BE                 mov     ecx, [ebp+var_4]
.text$mn:0000A1C1                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000A1C6
.text$mn:0000A1C6 loc_A1C6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000A1C6                 mov     ecx, [ebp+arg_0]
.text$mn:0000A1C9                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000A1CE                 sub     eax, [ebp+arg_4]
.text$mn:0000A1D1                 mov     [ebp+var_8], eax
.text$mn:0000A1D4                 mov     eax, [ebp+arg_8]
.text$mn:0000A1D7                 cmp     eax, [ebp+var_8]
.text$mn:0000A1DA                 jnb     short loc_A1E2
.text$mn:0000A1DC                 mov     ecx, [ebp+arg_8]
.text$mn:0000A1DF                 mov     [ebp+var_8], ecx
.text$mn:0000A1E2
.text$mn:0000A1E2 loc_A1E2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:0000A1E2                 mov     edx, [ebp+var_4]
.text$mn:0000A1E5                 cmp     edx, [ebp+arg_0]
.text$mn:0000A1E8                 jnz     short loc_A209
.text$mn:0000A1EA                 mov     eax, [ebp+arg_4]
.text$mn:0000A1ED                 add     eax, [ebp+var_8]
.text$mn:0000A1F0                 push    eax
.text$mn:0000A1F1                 mov     ecx, [ebp+var_4]
.text$mn:0000A1F4                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:0000A1F9                 mov     ecx, [ebp+arg_4]
.text$mn:0000A1FC                 push    ecx
.text$mn:0000A1FD                 push    0
.text$mn:0000A1FF                 mov     ecx, [ebp+var_4]
.text$mn:0000A202                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:0000A207                 jmp     short loc_A24E
.text$mn:0000A209 ; ---------------------------------------------------------------------------
.text$mn:0000A209
.text$mn:0000A209 loc_A209:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:0000A209                 push    0
.text$mn:0000A20B                 mov     edx, [ebp+var_8]
.text$mn:0000A20E                 push    edx
.text$mn:0000A20F                 mov     ecx, [ebp+var_4]
.text$mn:0000A212                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000A217                 movzx   eax, al
.text$mn:0000A21A                 test    eax, eax
.text$mn:0000A21C                 jz      short loc_A24E
.text$mn:0000A21E                 mov     ecx, [ebp+var_8]
.text$mn:0000A221                 push    ecx             ; int
.text$mn:0000A222                 mov     ecx, [ebp+arg_0]
.text$mn:0000A225                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A22A                 mov     edx, [ebp+arg_4]
.text$mn:0000A22D                 lea     eax, [eax+edx*2]
.text$mn:0000A230                 push    eax             ; Src
.text$mn:0000A231                 mov     ecx, [ebp+var_4]
.text$mn:0000A234                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A239                 push    eax             ; Dst
.text$mn:0000A23A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000A23F                 add     esp, 0Ch
.text$mn:0000A242                 mov     ecx, [ebp+var_8]
.text$mn:0000A245                 push    ecx
.text$mn:0000A246                 mov     ecx, [ebp+var_4]
.text$mn:0000A249                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A24E
.text$mn:0000A24E loc_A24E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:0000A24E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:0000A24E                 mov     eax, [ebp+var_4]
.text$mn:0000A251                 mov     esp, ebp
.text$mn:0000A253                 pop     ebp
.text$mn:0000A254                 retn    0Ch
.text$mn:0000A254 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000A254
.text$mn:0000A254 ; ---------------------------------------------------------------------------
.text$mn:0000A257                 align 4
.text$mn:0000A257 _text$mn        ends
.text$mn:0000A257
.text$mn:0000A258 ; ===========================================================================
.text$mn:0000A258
.text$mn:0000A258 ; Segment type: Pure code
.text$mn:0000A258 ; Segment permissions: Read/Execute
.text$mn:0000A258 _text$mn        segment para public 'CODE' use32
.text$mn:0000A258                 assume cs:_text$mn
.text$mn:0000A258                 ;org 0A258h
.text$mn:0000A258 ; COMDAT (pick any)
.text$mn:0000A258                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A258
.text$mn:0000A258 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A258
.text$mn:0000A258 ; Attributes: bp-based frame
.text$mn:0000A258
.text$mn:0000A258 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:0000A258                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:0000A258 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:0000A258                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:0000A258                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:0000A258
.text$mn:0000A258 var_4           = dword ptr -4
.text$mn:0000A258 Str             = dword ptr  8
.text$mn:0000A258
.text$mn:0000A258                 push    ebp
.text$mn:0000A259                 mov     ebp, esp
.text$mn:0000A25B                 push    ecx
.text$mn:0000A25C                 mov     [ebp+var_4], ecx
.text$mn:0000A25F                 push    490h            ; unsigned int
.text$mn:0000A264                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A269                 mov     eax, [ebp+Str]
.text$mn:0000A26C                 push    eax             ; int
.text$mn:0000A26D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000A272                 add     esp, 0Ch
.text$mn:0000A275                 mov     ecx, [ebp+Str]
.text$mn:0000A278                 push    ecx             ; Str
.text$mn:0000A279                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000A27E                 add     esp, 4
.text$mn:0000A281                 push    eax             ; int
.text$mn:0000A282                 mov     edx, [ebp+Str]
.text$mn:0000A285                 push    edx             ; Src
.text$mn:0000A286                 mov     ecx, [ebp+var_4]
.text$mn:0000A289                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:0000A28E                 mov     esp, ebp
.text$mn:0000A290                 pop     ebp
.text$mn:0000A291                 retn    4
.text$mn:0000A291 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:0000A291
.text$mn:0000A291 _text$mn        ends
.text$mn:0000A291
.text$mn:0000A294 ; ===========================================================================
.text$mn:0000A294
.text$mn:0000A294 ; Segment type: Pure code
.text$mn:0000A294 ; Segment permissions: Read/Execute
.text$mn:0000A294 _text$mn        segment para public 'CODE' use32
.text$mn:0000A294                 assume cs:_text$mn
.text$mn:0000A294                 ;org 0A294h
.text$mn:0000A294 ; COMDAT (pick any)
.text$mn:0000A294                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A294
.text$mn:0000A294 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A294
.text$mn:0000A294 ; Attributes: bp-based frame
.text$mn:0000A294
.text$mn:0000A294 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:0000A294                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:0000A294 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:0000A294                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:0000A294
.text$mn:0000A294 var_4           = dword ptr -4
.text$mn:0000A294 Src             = dword ptr  8
.text$mn:0000A294 arg_4           = dword ptr  0Ch
.text$mn:0000A294
.text$mn:0000A294                 push    ebp
.text$mn:0000A295                 mov     ebp, esp
.text$mn:0000A297                 push    ecx
.text$mn:0000A298                 mov     [ebp+var_4], ecx
.text$mn:0000A29B                 cmp     [ebp+arg_4], 0
.text$mn:0000A29F                 jz      short loc_A2B7
.text$mn:0000A2A1                 push    47Fh            ; unsigned int
.text$mn:0000A2A6                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A2AB                 mov     eax, [ebp+Src]
.text$mn:0000A2AE                 push    eax             ; int
.text$mn:0000A2AF                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000A2B4                 add     esp, 0Ch
.text$mn:0000A2B7
.text$mn:0000A2B7 loc_A2B7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:0000A2B7                 mov     ecx, [ebp+Src]
.text$mn:0000A2BA                 push    ecx
.text$mn:0000A2BB                 mov     ecx, [ebp+var_4]
.text$mn:0000A2BE                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000A2C3                 movzx   edx, al
.text$mn:0000A2C6                 test    edx, edx
.text$mn:0000A2C8                 jz      short loc_A2EC
.text$mn:0000A2CA                 mov     eax, [ebp+arg_4]
.text$mn:0000A2CD                 push    eax
.text$mn:0000A2CE                 mov     ecx, [ebp+var_4]
.text$mn:0000A2D1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A2D6                 mov     ecx, [ebp+Src]
.text$mn:0000A2D9                 sub     ecx, eax
.text$mn:0000A2DB                 sar     ecx, 1
.text$mn:0000A2DD                 push    ecx
.text$mn:0000A2DE                 mov     edx, [ebp+var_4]
.text$mn:0000A2E1                 push    edx
.text$mn:0000A2E2                 mov     ecx, [ebp+var_4]
.text$mn:0000A2E5                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000A2EA                 jmp     short loc_A329
.text$mn:0000A2EC ; ---------------------------------------------------------------------------
.text$mn:0000A2EC
.text$mn:0000A2EC loc_A2EC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:0000A2EC                 push    0
.text$mn:0000A2EE                 mov     eax, [ebp+arg_4]
.text$mn:0000A2F1                 push    eax
.text$mn:0000A2F2                 mov     ecx, [ebp+var_4]
.text$mn:0000A2F5                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000A2FA                 movzx   ecx, al
.text$mn:0000A2FD                 test    ecx, ecx
.text$mn:0000A2FF                 jz      short loc_A326
.text$mn:0000A301                 mov     edx, [ebp+arg_4]
.text$mn:0000A304                 push    edx             ; int
.text$mn:0000A305                 mov     eax, [ebp+Src]
.text$mn:0000A308                 push    eax             ; Src
.text$mn:0000A309                 mov     ecx, [ebp+var_4]
.text$mn:0000A30C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A311                 push    eax             ; Dst
.text$mn:0000A312                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000A317                 add     esp, 0Ch
.text$mn:0000A31A                 mov     ecx, [ebp+arg_4]
.text$mn:0000A31D                 push    ecx
.text$mn:0000A31E                 mov     ecx, [ebp+var_4]
.text$mn:0000A321                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A326
.text$mn:0000A326 loc_A326:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:0000A326                 mov     eax, [ebp+var_4]
.text$mn:0000A329
.text$mn:0000A329 loc_A329:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:0000A329                 mov     esp, ebp
.text$mn:0000A32B                 pop     ebp
.text$mn:0000A32C                 retn    8
.text$mn:0000A32C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000A32C
.text$mn:0000A32C ; ---------------------------------------------------------------------------
.text$mn:0000A32F                 align 10h
.text$mn:0000A32F _text$mn        ends
.text$mn:0000A32F
.text$mn:0000A330 ; ===========================================================================
.text$mn:0000A330
.text$mn:0000A330 ; Segment type: Pure code
.text$mn:0000A330 ; Segment permissions: Read/Execute
.text$mn:0000A330 _text$mn        segment para public 'CODE' use32
.text$mn:0000A330                 assume cs:_text$mn
.text$mn:0000A330                 ;org 0A330h
.text$mn:0000A330 ; COMDAT (pick any)
.text$mn:0000A330                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A330
.text$mn:0000A330 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A330
.text$mn:0000A330 ; Attributes: bp-based frame
.text$mn:0000A330
.text$mn:0000A330 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:0000A330                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:0000A330 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:0000A330                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:0000A330
.text$mn:0000A330 arg_0           = dword ptr  8
.text$mn:0000A330 arg_4           = dword ptr  0Ch
.text$mn:0000A330
.text$mn:0000A330                 push    ebp
.text$mn:0000A331                 mov     ebp, esp
.text$mn:0000A333                 mov     eax, [ebp+arg_0]
.text$mn:0000A336                 mov     ecx, [ebp+arg_4]
.text$mn:0000A339                 mov     dl, [ecx]
.text$mn:0000A33B                 mov     [eax], dl
.text$mn:0000A33D                 pop     ebp
.text$mn:0000A33E                 retn
.text$mn:0000A33E ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:0000A33E
.text$mn:0000A33E ; ---------------------------------------------------------------------------
.text$mn:0000A33F                 align 10h
.text$mn:0000A33F _text$mn        ends
.text$mn:0000A33F
.text$mn:0000A340 ; ===========================================================================
.text$mn:0000A340
.text$mn:0000A340 ; Segment type: Pure code
.text$mn:0000A340 ; Segment permissions: Read/Execute
.text$mn:0000A340 _text$mn        segment para public 'CODE' use32
.text$mn:0000A340                 assume cs:_text$mn
.text$mn:0000A340                 ;org 0A340h
.text$mn:0000A340 ; COMDAT (pick any)
.text$mn:0000A340                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A340
.text$mn:0000A340 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A340
.text$mn:0000A340 ; Attributes: bp-based frame
.text$mn:0000A340
.text$mn:0000A340 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:0000A340                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:0000A340 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:0000A340                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:0000A340
.text$mn:0000A340 arg_0           = dword ptr  8
.text$mn:0000A340 arg_4           = dword ptr  0Ch
.text$mn:0000A340
.text$mn:0000A340                 push    ebp
.text$mn:0000A341                 mov     ebp, esp
.text$mn:0000A343                 mov     eax, [ebp+arg_0]
.text$mn:0000A346                 mov     ecx, [ebp+arg_4]
.text$mn:0000A349                 mov     dx, [ecx]
.text$mn:0000A34C                 mov     [eax], dx
.text$mn:0000A34F                 pop     ebp
.text$mn:0000A350                 retn
.text$mn:0000A350 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:0000A350
.text$mn:0000A350 ; ---------------------------------------------------------------------------
.text$mn:0000A351                 align 4
.text$mn:0000A351 _text$mn        ends
.text$mn:0000A351
.text$mn:0000A354 ; ===========================================================================
.text$mn:0000A354
.text$mn:0000A354 ; Segment type: Pure code
.text$mn:0000A354 ; Segment permissions: Read/Execute
.text$mn:0000A354 _text$mn        segment para public 'CODE' use32
.text$mn:0000A354                 assume cs:_text$mn
.text$mn:0000A354                 ;org 0A354h
.text$mn:0000A354 ; COMDAT (pick any)
.text$mn:0000A354                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A354
.text$mn:0000A354 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A354
.text$mn:0000A354 ; Attributes: bp-based frame
.text$mn:0000A354
.text$mn:0000A354 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:0000A354                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:0000A354 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:0000A354                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+5EDp
.text$mn:0000A354                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+62Ap ...
.text$mn:0000A354
.text$mn:0000A354 var_4           = dword ptr -4
.text$mn:0000A354
.text$mn:0000A354                 push    ebp
.text$mn:0000A355                 mov     ebp, esp
.text$mn:0000A357                 push    ecx
.text$mn:0000A358                 mov     [ebp+var_4], ecx
.text$mn:0000A35B                 mov     ecx, [ebp+var_4]
.text$mn:0000A35E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A363                 mov     esp, ebp
.text$mn:0000A365                 pop     ebp
.text$mn:0000A366                 retn
.text$mn:0000A366 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:0000A366
.text$mn:0000A366 ; ---------------------------------------------------------------------------
.text$mn:0000A367                 align 4
.text$mn:0000A367 _text$mn        ends
.text$mn:0000A367
.text$mn:0000A368 ; ===========================================================================
.text$mn:0000A368
.text$mn:0000A368 ; Segment type: Pure code
.text$mn:0000A368 ; Segment permissions: Read/Execute
.text$mn:0000A368 _text$mn        segment para public 'CODE' use32
.text$mn:0000A368                 assume cs:_text$mn
.text$mn:0000A368                 ;org 0A368h
.text$mn:0000A368 ; COMDAT (pick any)
.text$mn:0000A368                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A368
.text$mn:0000A368 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A368
.text$mn:0000A368 ; Attributes: bp-based frame
.text$mn:0000A368
.text$mn:0000A368 ; public: unsigned int __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::capacity(void)const
.text$mn:0000A368                 public ?capacity@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ
.text$mn:0000A368 ?capacity@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:0000A368                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Grow_to(uint)+Cp
.text$mn:0000A368
.text$mn:0000A368 var_4           = dword ptr -4
.text$mn:0000A368
.text$mn:0000A368                 push    ebp
.text$mn:0000A369                 mov     ebp, esp
.text$mn:0000A36B                 push    ecx
.text$mn:0000A36C                 mov     [ebp+var_4], ecx
.text$mn:0000A36F                 mov     eax, [ebp+var_4]
.text$mn:0000A372                 mov     ecx, [ebp+var_4]
.text$mn:0000A375                 mov     eax, [eax+0Ch]
.text$mn:0000A378                 sub     eax, [ecx+4]
.text$mn:0000A37B                 sar     eax, 2
.text$mn:0000A37E                 mov     esp, ebp
.text$mn:0000A380                 pop     ebp
.text$mn:0000A381                 retn
.text$mn:0000A381 ?capacity@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ endp
.text$mn:0000A381
.text$mn:0000A381 ; ---------------------------------------------------------------------------
.text$mn:0000A382                 align 4
.text$mn:0000A382 _text$mn        ends
.text$mn:0000A382
.text$mn:0000A384 ; ===========================================================================
.text$mn:0000A384
.text$mn:0000A384 ; Segment type: Pure code
.text$mn:0000A384 ; Segment permissions: Read/Execute
.text$mn:0000A384 _text$mn        segment para public 'CODE' use32
.text$mn:0000A384                 assume cs:_text$mn
.text$mn:0000A384                 ;org 0A384h
.text$mn:0000A384 ; COMDAT (pick any)
.text$mn:0000A384                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A384
.text$mn:0000A384 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A384
.text$mn:0000A384 ; Attributes: bp-based frame
.text$mn:0000A384
.text$mn:0000A384 ; public: unsigned int __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::capacity(void)const
.text$mn:0000A384                 public ?capacity@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ
.text$mn:0000A384 ?capacity@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ proc near
.text$mn:0000A384                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Grow_to(uint)+Cp
.text$mn:0000A384
.text$mn:0000A384 var_4           = dword ptr -4
.text$mn:0000A384
.text$mn:0000A384                 push    ebp
.text$mn:0000A385                 mov     ebp, esp
.text$mn:0000A387                 push    ecx
.text$mn:0000A388                 mov     [ebp+var_4], ecx
.text$mn:0000A38B                 mov     eax, [ebp+var_4]
.text$mn:0000A38E                 mov     ecx, [ebp+var_4]
.text$mn:0000A391                 mov     eax, [eax+0Ch]
.text$mn:0000A394                 sub     eax, [ecx+4]
.text$mn:0000A397                 sar     eax, 2
.text$mn:0000A39A                 mov     esp, ebp
.text$mn:0000A39C                 pop     ebp
.text$mn:0000A39D                 retn
.text$mn:0000A39D ?capacity@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ endp
.text$mn:0000A39D
.text$mn:0000A39D ; ---------------------------------------------------------------------------
.text$mn:0000A39E                 align 10h
.text$mn:0000A39E _text$mn        ends
.text$mn:0000A39E
.text$mn:0000A3A0 ; ===========================================================================
.text$mn:0000A3A0
.text$mn:0000A3A0 ; Segment type: Pure code
.text$mn:0000A3A0 ; Segment permissions: Read/Execute
.text$mn:0000A3A0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A3A0                 assume cs:_text$mn
.text$mn:0000A3A0                 ;org 0A3A0h
.text$mn:0000A3A0 ; COMDAT (pick any)
.text$mn:0000A3A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A3A0
.text$mn:0000A3A0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A3A0
.text$mn:0000A3A0 ; Attributes: bp-based frame
.text$mn:0000A3A0
.text$mn:0000A3A0 ; public: unsigned int __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::capacity(void)const
.text$mn:0000A3A0                 public ?capacity@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ
.text$mn:0000A3A0 ?capacity@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000A3A0                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Grow_to(uint)+Cp
.text$mn:0000A3A0
.text$mn:0000A3A0 var_4           = dword ptr -4
.text$mn:0000A3A0
.text$mn:0000A3A0                 push    ebp
.text$mn:0000A3A1                 mov     ebp, esp
.text$mn:0000A3A3                 push    ecx
.text$mn:0000A3A4                 mov     [ebp+var_4], ecx
.text$mn:0000A3A7                 mov     eax, [ebp+var_4]
.text$mn:0000A3AA                 mov     ecx, [ebp+var_4]
.text$mn:0000A3AD                 mov     eax, [eax+0Ch]
.text$mn:0000A3B0                 sub     eax, [ecx+4]
.text$mn:0000A3B3                 sar     eax, 5
.text$mn:0000A3B6                 mov     esp, ebp
.text$mn:0000A3B8                 pop     ebp
.text$mn:0000A3B9                 retn
.text$mn:0000A3B9 ?capacity@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ endp
.text$mn:0000A3B9
.text$mn:0000A3B9 ; ---------------------------------------------------------------------------
.text$mn:0000A3BA                 align 4
.text$mn:0000A3BA _text$mn        ends
.text$mn:0000A3BA
.text$mn:0000A3BC ; ===========================================================================
.text$mn:0000A3BC
.text$mn:0000A3BC ; Segment type: Pure code
.text$mn:0000A3BC ; Segment permissions: Read/Execute
.text$mn:0000A3BC _text$mn        segment para public 'CODE' use32
.text$mn:0000A3BC                 assume cs:_text$mn
.text$mn:0000A3BC                 ;org 0A3BCh
.text$mn:0000A3BC ; COMDAT (pick any)
.text$mn:0000A3BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A3BC
.text$mn:0000A3BC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A3BC
.text$mn:0000A3BC ; Attributes: bp-based frame
.text$mn:0000A3BC
.text$mn:0000A3BC ; public: unsigned int __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::capacity(void)const
.text$mn:0000A3BC                 public ?capacity@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ
.text$mn:0000A3BC ?capacity@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:0000A3BC                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Grow_to(uint)+Cp
.text$mn:0000A3BC
.text$mn:0000A3BC var_4           = dword ptr -4
.text$mn:0000A3BC
.text$mn:0000A3BC                 push    ebp
.text$mn:0000A3BD                 mov     ebp, esp
.text$mn:0000A3BF                 push    ecx
.text$mn:0000A3C0                 mov     [ebp+var_4], ecx
.text$mn:0000A3C3                 mov     eax, [ebp+var_4]
.text$mn:0000A3C6                 mov     ecx, [ebp+var_4]
.text$mn:0000A3C9                 mov     eax, [eax+0Ch]
.text$mn:0000A3CC                 sub     eax, [ecx+4]
.text$mn:0000A3CF                 cdq
.text$mn:0000A3D0                 mov     ecx, 24h ; '$'
.text$mn:0000A3D5                 idiv    ecx
.text$mn:0000A3D7                 mov     esp, ebp
.text$mn:0000A3D9                 pop     ebp
.text$mn:0000A3DA                 retn
.text$mn:0000A3DA ?capacity@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ endp
.text$mn:0000A3DA
.text$mn:0000A3DA ; ---------------------------------------------------------------------------
.text$mn:0000A3DB                 align 4
.text$mn:0000A3DB _text$mn        ends
.text$mn:0000A3DB
.text$mn:0000A3DC ; ===========================================================================
.text$mn:0000A3DC
.text$mn:0000A3DC ; Segment type: Pure code
.text$mn:0000A3DC ; Segment permissions: Read/Execute
.text$mn:0000A3DC _text$mn        segment para public 'CODE' use32
.text$mn:0000A3DC                 assume cs:_text$mn
.text$mn:0000A3DC                 ;org 0A3DCh
.text$mn:0000A3DC ; COMDAT (pick any)
.text$mn:0000A3DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A3DC
.text$mn:0000A3DC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A3DC
.text$mn:0000A3DC ; Attributes: bp-based frame
.text$mn:0000A3DC
.text$mn:0000A3DC ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::capacity(void)const
.text$mn:0000A3DC                 public ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:0000A3DC ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000A3DC                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+Cp
.text$mn:0000A3DC
.text$mn:0000A3DC var_4           = dword ptr -4
.text$mn:0000A3DC
.text$mn:0000A3DC                 push    ebp
.text$mn:0000A3DD                 mov     ebp, esp
.text$mn:0000A3DF                 push    ecx
.text$mn:0000A3E0                 mov     [ebp+var_4], ecx
.text$mn:0000A3E3                 mov     eax, [ebp+var_4]
.text$mn:0000A3E6                 mov     ecx, [ebp+var_4]
.text$mn:0000A3E9                 mov     eax, [eax+0Ch]
.text$mn:0000A3EC                 sub     eax, [ecx+4]
.text$mn:0000A3EF                 cdq
.text$mn:0000A3F0                 mov     ecx, 1Ch
.text$mn:0000A3F5                 idiv    ecx
.text$mn:0000A3F7                 mov     esp, ebp
.text$mn:0000A3F9                 pop     ebp
.text$mn:0000A3FA                 retn
.text$mn:0000A3FA ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:0000A3FA
.text$mn:0000A3FA ; ---------------------------------------------------------------------------
.text$mn:0000A3FB                 align 4
.text$mn:0000A3FB _text$mn        ends
.text$mn:0000A3FB
.text$mn:0000A3FC ; ===========================================================================
.text$mn:0000A3FC
.text$mn:0000A3FC ; Segment type: Pure code
.text$mn:0000A3FC ; Segment permissions: Read/Execute
.text$mn:0000A3FC _text$mn        segment para public 'CODE' use32
.text$mn:0000A3FC                 assume cs:_text$mn
.text$mn:0000A3FC                 ;org 0A3FCh
.text$mn:0000A3FC ; COMDAT (pick any)
.text$mn:0000A3FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A3FC
.text$mn:0000A3FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A3FC
.text$mn:0000A3FC ; Attributes: bp-based frame
.text$mn:0000A3FC
.text$mn:0000A3FC ; public: unsigned int __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::capacity(void)const
.text$mn:0000A3FC                 public ?capacity@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ
.text$mn:0000A3FC ?capacity@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ proc near
.text$mn:0000A3FC                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Grow_to(uint)+Cp
.text$mn:0000A3FC
.text$mn:0000A3FC var_4           = dword ptr -4
.text$mn:0000A3FC
.text$mn:0000A3FC                 push    ebp
.text$mn:0000A3FD                 mov     ebp, esp
.text$mn:0000A3FF                 push    ecx
.text$mn:0000A400                 mov     [ebp+var_4], ecx
.text$mn:0000A403                 mov     eax, [ebp+var_4]
.text$mn:0000A406                 mov     ecx, [ebp+var_4]
.text$mn:0000A409                 mov     eax, [eax+0Ch]
.text$mn:0000A40C                 sub     eax, [ecx+4]
.text$mn:0000A40F                 cdq
.text$mn:0000A410                 mov     ecx, 150h
.text$mn:0000A415                 idiv    ecx
.text$mn:0000A417                 mov     esp, ebp
.text$mn:0000A419                 pop     ebp
.text$mn:0000A41A                 retn
.text$mn:0000A41A ?capacity@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ endp
.text$mn:0000A41A
.text$mn:0000A41A ; ---------------------------------------------------------------------------
.text$mn:0000A41B                 align 4
.text$mn:0000A41B _text$mn        ends
.text$mn:0000A41B
.text$mn:0000A41C ; ===========================================================================
.text$mn:0000A41C
.text$mn:0000A41C ; Segment type: Pure code
.text$mn:0000A41C ; Segment permissions: Read/Execute
.text$mn:0000A41C _text$mn        segment para public 'CODE' use32
.text$mn:0000A41C                 assume cs:_text$mn
.text$mn:0000A41C                 ;org 0A41Ch
.text$mn:0000A41C ; COMDAT (pick any)
.text$mn:0000A41C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A41C
.text$mn:0000A41C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A41C
.text$mn:0000A41C ; Attributes: bp-based frame
.text$mn:0000A41C
.text$mn:0000A41C ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:0000A41C                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:0000A41C ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000A41C                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:0000A41C
.text$mn:0000A41C var_4           = dword ptr -4
.text$mn:0000A41C
.text$mn:0000A41C                 push    ebp
.text$mn:0000A41D                 mov     ebp, esp
.text$mn:0000A41F                 push    ecx
.text$mn:0000A420                 mov     [ebp+var_4], ecx
.text$mn:0000A423                 mov     eax, [ebp+var_4]
.text$mn:0000A426                 mov     eax, [eax+4]
.text$mn:0000A429                 mov     esp, ebp
.text$mn:0000A42B                 pop     ebp
.text$mn:0000A42C                 retn
.text$mn:0000A42C ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000A42C
.text$mn:0000A42C ; ---------------------------------------------------------------------------
.text$mn:0000A42D                 align 10h
.text$mn:0000A42D _text$mn        ends
.text$mn:0000A42D
.text$mn:0000A430 ; ===========================================================================
.text$mn:0000A430
.text$mn:0000A430 ; Segment type: Pure code
.text$mn:0000A430 ; Segment permissions: Read/Execute
.text$mn:0000A430 _text$mn        segment para public 'CODE' use32
.text$mn:0000A430                 assume cs:_text$mn
.text$mn:0000A430                 ;org 0A430h
.text$mn:0000A430 ; COMDAT (pick any)
.text$mn:0000A430                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A430
.text$mn:0000A430 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A430
.text$mn:0000A430 ; Attributes: bp-based frame
.text$mn:0000A430
.text$mn:0000A430 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:0000A430                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:0000A430 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000A430                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:0000A430                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:0000A430
.text$mn:0000A430 var_4           = dword ptr -4
.text$mn:0000A430
.text$mn:0000A430                 push    ebp
.text$mn:0000A431                 mov     ebp, esp
.text$mn:0000A433                 push    ecx
.text$mn:0000A434                 mov     [ebp+var_4], ecx
.text$mn:0000A437                 mov     eax, [ebp+var_4]
.text$mn:0000A43A                 mov     eax, [eax+4]
.text$mn:0000A43D                 mov     esp, ebp
.text$mn:0000A43F                 pop     ebp
.text$mn:0000A440                 retn
.text$mn:0000A440 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000A440
.text$mn:0000A440 ; ---------------------------------------------------------------------------
.text$mn:0000A441                 align 4
.text$mn:0000A441 _text$mn        ends
.text$mn:0000A441
.text$mn:0000A444 ; ===========================================================================
.text$mn:0000A444
.text$mn:0000A444 ; Segment type: Pure code
.text$mn:0000A444 ; Segment permissions: Read/Execute
.text$mn:0000A444 _text$mn        segment para public 'CODE' use32
.text$mn:0000A444                 assume cs:_text$mn
.text$mn:0000A444                 ;org 0A444h
.text$mn:0000A444 ; COMDAT (pick any)
.text$mn:0000A444                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A444
.text$mn:0000A444 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A444
.text$mn:0000A444 ; Attributes: bp-based frame
.text$mn:0000A444
.text$mn:0000A444 ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(unsigned int, unsigned int, wchar_t const *, unsigned int)const
.text$mn:0000A444                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z
.text$mn:0000A444 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z proc near
.text$mn:0000A444                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+3Ap
.text$mn:0000A444
.text$mn:0000A444 var_18          = dword ptr -18h
.text$mn:0000A444 var_14          = dword ptr -14h
.text$mn:0000A444 var_10          = dword ptr -10h
.text$mn:0000A444 var_C           = dword ptr -0Ch
.text$mn:0000A444 var_8           = dword ptr -8
.text$mn:0000A444 var_4           = dword ptr -4
.text$mn:0000A444 arg_0           = dword ptr  8
.text$mn:0000A444 arg_4           = dword ptr  0Ch
.text$mn:0000A444 arg_8           = dword ptr  10h
.text$mn:0000A444 arg_C           = dword ptr  14h
.text$mn:0000A444
.text$mn:0000A444                 push    ebp
.text$mn:0000A445                 mov     ebp, esp
.text$mn:0000A447                 sub     esp, 18h
.text$mn:0000A44A                 mov     [ebp+var_4], ecx
.text$mn:0000A44D                 cmp     [ebp+arg_C], 0
.text$mn:0000A451                 jz      short loc_A469
.text$mn:0000A453                 push    87Dh            ; unsigned int
.text$mn:0000A458                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A45D                 mov     eax, [ebp+arg_8]
.text$mn:0000A460                 push    eax             ; int
.text$mn:0000A461                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000A466                 add     esp, 0Ch
.text$mn:0000A469
.text$mn:0000A469 loc_A469:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+Dj
.text$mn:0000A469                 mov     ecx, [ebp+var_4]
.text$mn:0000A46C                 mov     edx, [ecx+14h]
.text$mn:0000A46F                 cmp     edx, [ebp+arg_0]
.text$mn:0000A472                 jnb     short loc_A47C
.text$mn:0000A474                 mov     ecx, [ebp+var_4]
.text$mn:0000A477                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000A47C
.text$mn:0000A47C loc_A47C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+2Ej
.text$mn:0000A47C                 mov     eax, [ebp+var_4]
.text$mn:0000A47F                 mov     ecx, [eax+14h]
.text$mn:0000A482                 sub     ecx, [ebp+arg_0]
.text$mn:0000A485                 cmp     ecx, [ebp+arg_4]
.text$mn:0000A488                 jnb     short loc_A496
.text$mn:0000A48A                 mov     edx, [ebp+var_4]
.text$mn:0000A48D                 mov     eax, [edx+14h]
.text$mn:0000A490                 sub     eax, [ebp+arg_0]
.text$mn:0000A493                 mov     [ebp+arg_4], eax
.text$mn:0000A496
.text$mn:0000A496 loc_A496:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+44j
.text$mn:0000A496                 mov     ecx, [ebp+arg_4]
.text$mn:0000A499                 cmp     ecx, [ebp+arg_C]
.text$mn:0000A49C                 jnb     short loc_A4A6
.text$mn:0000A49E                 mov     edx, [ebp+arg_4]
.text$mn:0000A4A1                 mov     [ebp+var_8], edx
.text$mn:0000A4A4                 jmp     short loc_A4AC
.text$mn:0000A4A6 ; ---------------------------------------------------------------------------
.text$mn:0000A4A6
.text$mn:0000A4A6 loc_A4A6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+58j
.text$mn:0000A4A6                 mov     eax, [ebp+arg_C]
.text$mn:0000A4A9                 mov     [ebp+var_8], eax
.text$mn:0000A4AC
.text$mn:0000A4AC loc_A4AC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+60j
.text$mn:0000A4AC                 mov     ecx, [ebp+var_8]
.text$mn:0000A4AF                 push    ecx
.text$mn:0000A4B0                 mov     edx, [ebp+arg_8]
.text$mn:0000A4B3                 push    edx
.text$mn:0000A4B4                 mov     ecx, [ebp+var_4]
.text$mn:0000A4B7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A4BC                 mov     ecx, [ebp+arg_0]
.text$mn:0000A4BF                 lea     edx, [eax+ecx*2]
.text$mn:0000A4C2                 push    edx
.text$mn:0000A4C3                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:0000A4C8                 add     esp, 0Ch
.text$mn:0000A4CB                 mov     [ebp+var_C], eax
.text$mn:0000A4CE                 cmp     [ebp+var_C], 0
.text$mn:0000A4D2                 jz      short loc_A4DC
.text$mn:0000A4D4                 mov     eax, [ebp+var_C]
.text$mn:0000A4D7                 mov     [ebp+var_18], eax
.text$mn:0000A4DA                 jmp     short loc_A511
.text$mn:0000A4DC ; ---------------------------------------------------------------------------
.text$mn:0000A4DC
.text$mn:0000A4DC loc_A4DC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+8Ej
.text$mn:0000A4DC                 mov     ecx, [ebp+arg_4]
.text$mn:0000A4DF                 cmp     ecx, [ebp+arg_C]
.text$mn:0000A4E2                 jnb     short loc_A4ED
.text$mn:0000A4E4                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:0000A4EB                 jmp     short loc_A50B
.text$mn:0000A4ED ; ---------------------------------------------------------------------------
.text$mn:0000A4ED
.text$mn:0000A4ED loc_A4ED:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+9Ej
.text$mn:0000A4ED                 mov     edx, [ebp+arg_4]
.text$mn:0000A4F0                 cmp     edx, [ebp+arg_C]
.text$mn:0000A4F3                 jnz     short loc_A4FE
.text$mn:0000A4F5                 mov     [ebp+var_10], 0
.text$mn:0000A4FC                 jmp     short loc_A505
.text$mn:0000A4FE ; ---------------------------------------------------------------------------
.text$mn:0000A4FE
.text$mn:0000A4FE loc_A4FE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+AFj
.text$mn:0000A4FE                 mov     [ebp+var_10], 1
.text$mn:0000A505
.text$mn:0000A505 loc_A505:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+B8j
.text$mn:0000A505                 mov     eax, [ebp+var_10]
.text$mn:0000A508                 mov     [ebp+var_14], eax
.text$mn:0000A50B
.text$mn:0000A50B loc_A50B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+A7j
.text$mn:0000A50B                 mov     ecx, [ebp+var_14]
.text$mn:0000A50E                 mov     [ebp+var_18], ecx
.text$mn:0000A511
.text$mn:0000A511 loc_A511:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+96j
.text$mn:0000A511                 mov     eax, [ebp+var_18]
.text$mn:0000A514                 mov     esp, ebp
.text$mn:0000A516                 pop     ebp
.text$mn:0000A517                 retn    10h
.text$mn:0000A517 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z endp
.text$mn:0000A517
.text$mn:0000A517 ; ---------------------------------------------------------------------------
.text$mn:0000A51A                 align 4
.text$mn:0000A51A _text$mn        ends
.text$mn:0000A51A
.text$mn:0000A51C ; ===========================================================================
.text$mn:0000A51C
.text$mn:0000A51C ; Segment type: Pure code
.text$mn:0000A51C ; Segment permissions: Read/Execute
.text$mn:0000A51C _text$mn        segment para public 'CODE' use32
.text$mn:0000A51C                 assume cs:_text$mn
.text$mn:0000A51C                 ;org 0A51Ch
.text$mn:0000A51C ; COMDAT (pick any)
.text$mn:0000A51C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A51C
.text$mn:0000A51C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A51C
.text$mn:0000A51C ; Attributes: bp-based frame
.text$mn:0000A51C
.text$mn:0000A51C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t *Str)
.text$mn:0000A51C                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
.text$mn:0000A51C ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z proc near
.text$mn:0000A51C                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Bp
.text$mn:0000A51C
.text$mn:0000A51C var_4           = dword ptr -4
.text$mn:0000A51C Str             = dword ptr  8
.text$mn:0000A51C
.text$mn:0000A51C                 push    ebp
.text$mn:0000A51D                 mov     ebp, esp
.text$mn:0000A51F                 push    ecx
.text$mn:0000A520                 mov     [ebp+var_4], ecx
.text$mn:0000A523                 push    86Eh            ; unsigned int
.text$mn:0000A528                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000A52D                 mov     eax, [ebp+Str]
.text$mn:0000A530                 push    eax             ; int
.text$mn:0000A531                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000A536                 add     esp, 0Ch
.text$mn:0000A539                 mov     ecx, [ebp+Str]
.text$mn:0000A53C                 push    ecx             ; Str
.text$mn:0000A53D                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000A542                 add     esp, 4
.text$mn:0000A545                 push    eax
.text$mn:0000A546                 mov     edx, [ebp+Str]
.text$mn:0000A549                 push    edx
.text$mn:0000A54A                 mov     eax, [ebp+var_4]
.text$mn:0000A54D                 mov     ecx, [eax+14h]
.text$mn:0000A550                 push    ecx
.text$mn:0000A551                 push    0
.text$mn:0000A553                 mov     ecx, [ebp+var_4]
.text$mn:0000A556                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:0000A55B                 mov     esp, ebp
.text$mn:0000A55D                 pop     ebp
.text$mn:0000A55E                 retn    4
.text$mn:0000A55E ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z endp
.text$mn:0000A55E
.text$mn:0000A55E ; ---------------------------------------------------------------------------
.text$mn:0000A561                 align 4
.text$mn:0000A561 _text$mn        ends
.text$mn:0000A561
.text$mn:0000A564 ; ===========================================================================
.text$mn:0000A564
.text$mn:0000A564 ; Segment type: Pure code
.text$mn:0000A564 ; Segment permissions: Read/Execute
.text$mn:0000A564 _text$mn        segment para public 'CODE' use32
.text$mn:0000A564                 assume cs:_text$mn
.text$mn:0000A564                 ;org 0A564h
.text$mn:0000A564 ; COMDAT (pick any)
.text$mn:0000A564                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A564
.text$mn:0000A564 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A564
.text$mn:0000A564 ; Attributes: bp-based frame
.text$mn:0000A564
.text$mn:0000A564 ; public: static int __cdecl std::char_traits<wchar_t>::compare(wchar_t const *, wchar_t const *, unsigned int)
.text$mn:0000A564                 public ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
.text$mn:0000A564 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z proc near
.text$mn:0000A564                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+7Fp
.text$mn:0000A564
.text$mn:0000A564 var_4           = dword ptr -4
.text$mn:0000A564 arg_0           = dword ptr  8
.text$mn:0000A564 arg_4           = dword ptr  0Ch
.text$mn:0000A564 arg_8           = dword ptr  10h
.text$mn:0000A564
.text$mn:0000A564                 push    ebp
.text$mn:0000A565                 mov     ebp, esp
.text$mn:0000A567                 push    ecx
.text$mn:0000A568                 cmp     [ebp+arg_8], 0
.text$mn:0000A56C                 jnz     short loc_A577
.text$mn:0000A56E                 mov     [ebp+var_4], 0
.text$mn:0000A575                 jmp     short loc_A58E
.text$mn:0000A577 ; ---------------------------------------------------------------------------
.text$mn:0000A577
.text$mn:0000A577 loc_A577:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+8j
.text$mn:0000A577                 mov     eax, [ebp+arg_8]
.text$mn:0000A57A                 push    eax
.text$mn:0000A57B                 mov     ecx, [ebp+arg_4]
.text$mn:0000A57E                 push    ecx
.text$mn:0000A57F                 mov     edx, [ebp+arg_0]
.text$mn:0000A582                 push    edx
.text$mn:0000A583                 call    _wmemcmp
.text$mn:0000A588                 add     esp, 0Ch
.text$mn:0000A58B                 mov     [ebp+var_4], eax
.text$mn:0000A58E
.text$mn:0000A58E loc_A58E:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+11j
.text$mn:0000A58E                 mov     eax, [ebp+var_4]
.text$mn:0000A591                 mov     esp, ebp
.text$mn:0000A593                 pop     ebp
.text$mn:0000A594                 retn
.text$mn:0000A594 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z endp
.text$mn:0000A594
.text$mn:0000A594 ; ---------------------------------------------------------------------------
.text$mn:0000A595                 align 4
.text$mn:0000A595 _text$mn        ends
.text$mn:0000A595
.text$mn:0000A598 ; ===========================================================================
.text$mn:0000A598
.text$mn:0000A598 ; Segment type: Pure code
.text$mn:0000A598 ; Segment permissions: Read/Execute
.text$mn:0000A598 _text$mn        segment para public 'CODE' use32
.text$mn:0000A598                 assume cs:_text$mn
.text$mn:0000A598                 ;org 0A598h
.text$mn:0000A598 ; COMDAT (pick any)
.text$mn:0000A598                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A598
.text$mn:0000A598 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A598
.text$mn:0000A598 ; Attributes: bp-based frame
.text$mn:0000A598
.text$mn:0000A598 ; int __stdcall std::allocator<PluginInfo *>::construct(void *, int)
.text$mn:0000A598                 public ?construct@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@ABQAU3@@Z
.text$mn:0000A598 ?construct@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@ABQAU3@@Z proc near
.text$mn:0000A598                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * const &>(std::allocator<PluginInfo *> &,PluginInfo * *,PluginInfo * const &)+17p
.text$mn:0000A598
.text$mn:0000A598 var_C           = dword ptr -0Ch
.text$mn:0000A598 var_8           = dword ptr -8
.text$mn:0000A598 var_4           = dword ptr -4
.text$mn:0000A598 arg_0           = dword ptr  8
.text$mn:0000A598 arg_4           = dword ptr  0Ch
.text$mn:0000A598
.text$mn:0000A598                 push    ebp
.text$mn:0000A599                 mov     ebp, esp
.text$mn:0000A59B                 sub     esp, 0Ch
.text$mn:0000A59E                 mov     [ebp+var_C], ecx
.text$mn:0000A5A1                 mov     eax, [ebp+arg_0]
.text$mn:0000A5A4                 push    eax             ; void *
.text$mn:0000A5A5                 push    4               ; unsigned int
.text$mn:0000A5A7                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000A5AC                 add     esp, 8
.text$mn:0000A5AF                 mov     [ebp+var_4], eax
.text$mn:0000A5B2                 cmp     [ebp+var_4], 0
.text$mn:0000A5B6                 jz      short loc_A5CA
.text$mn:0000A5B8                 mov     ecx, [ebp+var_4]
.text$mn:0000A5BB                 mov     edx, [ebp+arg_4]
.text$mn:0000A5BE                 mov     eax, [edx]
.text$mn:0000A5C0                 mov     [ecx], eax
.text$mn:0000A5C2                 mov     ecx, [ebp+var_4]
.text$mn:0000A5C5                 mov     [ebp+var_8], ecx
.text$mn:0000A5C8                 jmp     short loc_A5D1
.text$mn:0000A5CA ; ---------------------------------------------------------------------------
.text$mn:0000A5CA
.text$mn:0000A5CA loc_A5CA:                               ; CODE XREF: std::allocator<PluginInfo *>::construct(PluginInfo * *,PluginInfo * const &)+1Ej
.text$mn:0000A5CA                 mov     [ebp+var_8], 0
.text$mn:0000A5D1
.text$mn:0000A5D1 loc_A5D1:                               ; CODE XREF: std::allocator<PluginInfo *>::construct(PluginInfo * *,PluginInfo * const &)+30j
.text$mn:0000A5D1                 mov     esp, ebp
.text$mn:0000A5D3                 pop     ebp
.text$mn:0000A5D4                 retn    8
.text$mn:0000A5D4 ?construct@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@ABQAU3@@Z endp
.text$mn:0000A5D4
.text$mn:0000A5D4 ; ---------------------------------------------------------------------------
.text$mn:0000A5D7                 align 4
.text$mn:0000A5D7 _text$mn        ends
.text$mn:0000A5D7
.text$mn:0000A5D8 ; ===========================================================================
.text$mn:0000A5D8
.text$mn:0000A5D8 ; Segment type: Pure code
.text$mn:0000A5D8 ; Segment permissions: Read/Execute
.text$mn:0000A5D8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A5D8                 assume cs:_text$mn
.text$mn:0000A5D8                 ;org 0A5D8h
.text$mn:0000A5D8 ; COMDAT (pick any)
.text$mn:0000A5D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A5D8
.text$mn:0000A5D8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A5D8
.text$mn:0000A5D8 ; Attributes: bp-based frame
.text$mn:0000A5D8
.text$mn:0000A5D8 ; int __stdcall std::allocator<TiXmlDocument *>::construct(void *, int)
.text$mn:0000A5D8                 public ?construct@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@ABQAV3@@Z
.text$mn:0000A5D8 ?construct@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@ABQAV3@@Z proc near
.text$mn:0000A5D8                                         ; CODE XREF: std::allocator_traits<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * const &>(std::allocator<TiXmlDocument *> &,TiXmlDocument * *,TiXmlDocument * const &)+17p
.text$mn:0000A5D8
.text$mn:0000A5D8 var_C           = dword ptr -0Ch
.text$mn:0000A5D8 var_8           = dword ptr -8
.text$mn:0000A5D8 var_4           = dword ptr -4
.text$mn:0000A5D8 arg_0           = dword ptr  8
.text$mn:0000A5D8 arg_4           = dword ptr  0Ch
.text$mn:0000A5D8
.text$mn:0000A5D8                 push    ebp
.text$mn:0000A5D9                 mov     ebp, esp
.text$mn:0000A5DB                 sub     esp, 0Ch
.text$mn:0000A5DE                 mov     [ebp+var_C], ecx
.text$mn:0000A5E1                 mov     eax, [ebp+arg_0]
.text$mn:0000A5E4                 push    eax             ; void *
.text$mn:0000A5E5                 push    4               ; unsigned int
.text$mn:0000A5E7                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000A5EC                 add     esp, 8
.text$mn:0000A5EF                 mov     [ebp+var_4], eax
.text$mn:0000A5F2                 cmp     [ebp+var_4], 0
.text$mn:0000A5F6                 jz      short loc_A60A
.text$mn:0000A5F8                 mov     ecx, [ebp+var_4]
.text$mn:0000A5FB                 mov     edx, [ebp+arg_4]
.text$mn:0000A5FE                 mov     eax, [edx]
.text$mn:0000A600                 mov     [ecx], eax
.text$mn:0000A602                 mov     ecx, [ebp+var_4]
.text$mn:0000A605                 mov     [ebp+var_8], ecx
.text$mn:0000A608                 jmp     short loc_A611
.text$mn:0000A60A ; ---------------------------------------------------------------------------
.text$mn:0000A60A
.text$mn:0000A60A loc_A60A:                               ; CODE XREF: std::allocator<TiXmlDocument *>::construct(TiXmlDocument * *,TiXmlDocument * const &)+1Ej
.text$mn:0000A60A                 mov     [ebp+var_8], 0
.text$mn:0000A611
.text$mn:0000A611 loc_A611:                               ; CODE XREF: std::allocator<TiXmlDocument *>::construct(TiXmlDocument * *,TiXmlDocument * const &)+30j
.text$mn:0000A611                 mov     esp, ebp
.text$mn:0000A613                 pop     ebp
.text$mn:0000A614                 retn    8
.text$mn:0000A614 ?construct@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@ABQAV3@@Z endp
.text$mn:0000A614
.text$mn:0000A614 ; ---------------------------------------------------------------------------
.text$mn:0000A617                 align 4
.text$mn:0000A617 _text$mn        ends
.text$mn:0000A617
.text$mn:0000A618 ; ===========================================================================
.text$mn:0000A618
.text$mn:0000A618 ; Segment type: Pure code
.text$mn:0000A618 ; Segment permissions: Read/Execute
.text$mn:0000A618 _text$mn        segment para public 'CODE' use32
.text$mn:0000A618                 assume cs:_text$mn
.text$mn:0000A618                 ;org 0A618h
.text$mn:0000A618 ; COMDAT (pick any)
.text$mn:0000A618                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A618
.text$mn:0000A618 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A618
.text$mn:0000A618 ; Attributes: bp-based frame
.text$mn:0000A618
.text$mn:0000A618 ; int __stdcall std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct(void *, int)
.text$mn:0000A618                 public ?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z
.text$mn:0000A618 ?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z proc near
.text$mn:0000A618                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &>(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> &,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+17p
.text$mn:0000A618
.text$mn:0000A618 var_1C          = dword ptr -1Ch
.text$mn:0000A618 var_18          = dword ptr -18h
.text$mn:0000A618 var_14          = dword ptr -14h
.text$mn:0000A618 var_10          = dword ptr -10h
.text$mn:0000A618 var_C           = dword ptr -0Ch
.text$mn:0000A618 var_4           = dword ptr -4
.text$mn:0000A618 arg_0           = dword ptr  8
.text$mn:0000A618 arg_4           = dword ptr  0Ch
.text$mn:0000A618
.text$mn:0000A618                 push    ebp
.text$mn:0000A619                 mov     ebp, esp
.text$mn:0000A61B                 push    0FFFFFFFFh
.text$mn:0000A61D                 push    offset __ehhandler$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z
.text$mn:0000A622                 mov     eax, large fs:0
.text$mn:0000A628                 push    eax
.text$mn:0000A629                 sub     esp, 10h
.text$mn:0000A62C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A631                 xor     eax, ebp
.text$mn:0000A633                 push    eax
.text$mn:0000A634                 lea     eax, [ebp+var_C]
.text$mn:0000A637                 mov     large fs:0, eax
.text$mn:0000A63D                 mov     [ebp+var_18], ecx
.text$mn:0000A640                 mov     eax, [ebp+arg_0]
.text$mn:0000A643                 push    eax             ; void *
.text$mn:0000A644                 push    1Ch             ; unsigned int
.text$mn:0000A646                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000A64B                 add     esp, 8
.text$mn:0000A64E                 mov     [ebp+var_10], eax
.text$mn:0000A651                 mov     [ebp+var_4], 0
.text$mn:0000A658                 cmp     [ebp+var_10], 0
.text$mn:0000A65C                 jz      short loc_A66F
.text$mn:0000A65E                 mov     ecx, [ebp+arg_4]
.text$mn:0000A661                 push    ecx
.text$mn:0000A662                 mov     ecx, [ebp+var_10]
.text$mn:0000A665                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000A66A                 mov     [ebp+var_14], eax
.text$mn:0000A66D                 jmp     short loc_A676
.text$mn:0000A66F ; ---------------------------------------------------------------------------
.text$mn:0000A66F
.text$mn:0000A66F loc_A66F:                               ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+44j
.text$mn:0000A66F                 mov     [ebp+var_14], 0
.text$mn:0000A676
.text$mn:0000A676 loc_A676:                               ; CODE XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+55j
.text$mn:0000A676                 mov     edx, [ebp+var_14]
.text$mn:0000A679                 mov     [ebp+var_1C], edx
.text$mn:0000A67C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A683                 mov     ecx, [ebp+var_C]
.text$mn:0000A686                 mov     large fs:0, ecx
.text$mn:0000A68D                 pop     ecx
.text$mn:0000A68E                 mov     esp, ebp
.text$mn:0000A690                 pop     ebp
.text$mn:0000A691                 retn    8
.text$mn:0000A691 ?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z endp
.text$mn:0000A691
.text$mn:0000A691 _text$mn        ends
.text$mn:0000A691
.text$x:0000A694 ; ===========================================================================
.text$x:0000A694
.text$x:0000A694 ; Segment type: Pure code
.text$x:0000A694 ; Segment permissions: Read/Execute
.text$x:0000A694 _text$x         segment para public 'CODE' use32
.text$x:0000A694                 assume cs:_text$x
.text$x:0000A694                 ;org 0A694h
.text$x:0000A694 ; COMDAT (pick associative to section at A618)
.text$x:0000A694                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000A694
.text$x:0000A694 ; =============== S U B R O U T I N E =======================================
.text$x:0000A694
.text$x:0000A694
.text$x:0000A694 __unwindfunclet$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z$0 proc near
.text$x:0000A694                                         ; DATA XREF: .xdata$x:0000CB6Co
.text$x:0000A694                 mov     eax, [ebp+8]
.text$x:0000A697                 push    eax
.text$x:0000A698                 mov     eax, [ebp-10h]
.text$x:0000A69B                 push    eax             ; void *
.text$x:0000A69C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000A6A1                 add     esp, 8
.text$x:0000A6A4                 retn
.text$x:0000A6A4 __unwindfunclet$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z$0 endp
.text$x:0000A6A4
.text$x:0000A6A5
.text$x:0000A6A5 ; =============== S U B R O U T I N E =======================================
.text$x:0000A6A5
.text$x:0000A6A5
.text$x:0000A6A5 __ehhandler$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z proc near
.text$x:0000A6A5                                         ; DATA XREF: std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::construct(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:0000A6A5
.text$x:0000A6A5 arg_4           = dword ptr  8
.text$x:0000A6A5
.text$x:0000A6A5                 mov     edx, [esp+arg_4]
.text$x:0000A6A9                 lea     eax, [edx+0Ch]
.text$x:0000A6AC                 mov     ecx, [edx-14h]
.text$x:0000A6AF                 xor     ecx, eax
.text$x:0000A6B1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A6B6                 mov     eax, offset __ehfuncinfo$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z
.text$x:0000A6BB                 jmp     ___CxxFrameHandler3
.text$x:0000A6BB __ehhandler$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z endp
.text$x:0000A6BB
.text$x:0000A6BB _text$x         ends
.text$x:0000A6BB
.text$mn:0000A6C0 ; ===========================================================================
.text$mn:0000A6C0
.text$mn:0000A6C0 ; Segment type: Pure code
.text$mn:0000A6C0 ; Segment permissions: Read/Execute
.text$mn:0000A6C0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A6C0                 assume cs:_text$mn
.text$mn:0000A6C0                 ;org 0A6C0h
.text$mn:0000A6C0 ; COMDAT (pick any)
.text$mn:0000A6C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A6C0
.text$mn:0000A6C0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A6C0
.text$mn:0000A6C0 ; Attributes: bp-based frame
.text$mn:0000A6C0
.text$mn:0000A6C0 ; int __stdcall std::allocator<PluginCmdShortcut>::construct(void *, struct CommandShortcut *)
.text$mn:0000A6C0                 public ?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z
.text$mn:0000A6C0 ?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z proc near
.text$mn:0000A6C0                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut const &>(std::allocator<PluginCmdShortcut> &,PluginCmdShortcut *,PluginCmdShortcut const &)+17p
.text$mn:0000A6C0
.text$mn:0000A6C0 var_1C          = dword ptr -1Ch
.text$mn:0000A6C0 var_18          = dword ptr -18h
.text$mn:0000A6C0 var_14          = dword ptr -14h
.text$mn:0000A6C0 var_10          = dword ptr -10h
.text$mn:0000A6C0 var_C           = dword ptr -0Ch
.text$mn:0000A6C0 var_4           = dword ptr -4
.text$mn:0000A6C0 arg_0           = dword ptr  8
.text$mn:0000A6C0 arg_4           = dword ptr  0Ch
.text$mn:0000A6C0
.text$mn:0000A6C0                 push    ebp
.text$mn:0000A6C1                 mov     ebp, esp
.text$mn:0000A6C3                 push    0FFFFFFFFh
.text$mn:0000A6C5                 push    offset __ehhandler$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z
.text$mn:0000A6CA                 mov     eax, large fs:0
.text$mn:0000A6D0                 push    eax
.text$mn:0000A6D1                 sub     esp, 10h
.text$mn:0000A6D4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A6D9                 xor     eax, ebp
.text$mn:0000A6DB                 push    eax
.text$mn:0000A6DC                 lea     eax, [ebp+var_C]
.text$mn:0000A6DF                 mov     large fs:0, eax
.text$mn:0000A6E5                 mov     [ebp+var_18], ecx
.text$mn:0000A6E8                 mov     eax, [ebp+arg_0]
.text$mn:0000A6EB                 push    eax             ; void *
.text$mn:0000A6EC                 push    150h            ; unsigned int
.text$mn:0000A6F1                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000A6F6                 add     esp, 8
.text$mn:0000A6F9                 mov     [ebp+var_10], eax
.text$mn:0000A6FC                 mov     [ebp+var_4], 0
.text$mn:0000A703                 cmp     [ebp+var_10], 0
.text$mn:0000A707                 jz      short loc_A71A
.text$mn:0000A709                 mov     ecx, [ebp+arg_4]
.text$mn:0000A70C                 push    ecx             ; struct CommandShortcut *
.text$mn:0000A70D                 mov     ecx, [ebp+var_10]
.text$mn:0000A710                 call    ??0PluginCmdShortcut@@QAE@ABV0@@Z ; PluginCmdShortcut::PluginCmdShortcut(PluginCmdShortcut const &)
.text$mn:0000A715                 mov     [ebp+var_14], eax
.text$mn:0000A718                 jmp     short loc_A721
.text$mn:0000A71A ; ---------------------------------------------------------------------------
.text$mn:0000A71A
.text$mn:0000A71A loc_A71A:                               ; CODE XREF: std::allocator<PluginCmdShortcut>::construct(PluginCmdShortcut *,PluginCmdShortcut const &)+47j
.text$mn:0000A71A                 mov     [ebp+var_14], 0
.text$mn:0000A721
.text$mn:0000A721 loc_A721:                               ; CODE XREF: std::allocator<PluginCmdShortcut>::construct(PluginCmdShortcut *,PluginCmdShortcut const &)+58j
.text$mn:0000A721                 mov     edx, [ebp+var_14]
.text$mn:0000A724                 mov     [ebp+var_1C], edx
.text$mn:0000A727                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000A72E                 mov     ecx, [ebp+var_C]
.text$mn:0000A731                 mov     large fs:0, ecx
.text$mn:0000A738                 pop     ecx
.text$mn:0000A739                 mov     esp, ebp
.text$mn:0000A73B                 pop     ebp
.text$mn:0000A73C                 retn    8
.text$mn:0000A73C ?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z endp
.text$mn:0000A73C
.text$mn:0000A73C ; ---------------------------------------------------------------------------
.text$mn:0000A73F                 align 10h
.text$mn:0000A73F _text$mn        ends
.text$mn:0000A73F
.text$x:0000A740 ; ===========================================================================
.text$x:0000A740
.text$x:0000A740 ; Segment type: Pure code
.text$x:0000A740 ; Segment permissions: Read/Execute
.text$x:0000A740 _text$x         segment para public 'CODE' use32
.text$x:0000A740                 assume cs:_text$x
.text$x:0000A740                 ;org 0A740h
.text$x:0000A740 ; COMDAT (pick associative to section at A6C0)
.text$x:0000A740                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000A740
.text$x:0000A740 ; =============== S U B R O U T I N E =======================================
.text$x:0000A740
.text$x:0000A740
.text$x:0000A740 __unwindfunclet$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z$0 proc near
.text$x:0000A740                                         ; DATA XREF: .xdata$x:0000CEE4o
.text$x:0000A740                 mov     eax, [ebp+8]
.text$x:0000A743                 push    eax
.text$x:0000A744                 mov     eax, [ebp-10h]
.text$x:0000A747                 push    eax             ; void *
.text$x:0000A748                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000A74D                 add     esp, 8
.text$x:0000A750                 retn
.text$x:0000A750 __unwindfunclet$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z$0 endp
.text$x:0000A750
.text$x:0000A751
.text$x:0000A751 ; =============== S U B R O U T I N E =======================================
.text$x:0000A751
.text$x:0000A751
.text$x:0000A751 __ehhandler$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z proc near
.text$x:0000A751                                         ; DATA XREF: std::allocator<PluginCmdShortcut>::construct(PluginCmdShortcut *,PluginCmdShortcut const &)+5o
.text$x:0000A751
.text$x:0000A751 arg_4           = dword ptr  8
.text$x:0000A751
.text$x:0000A751                 mov     edx, [esp+arg_4]
.text$x:0000A755                 lea     eax, [edx+0Ch]
.text$x:0000A758                 mov     ecx, [edx-14h]
.text$x:0000A75B                 xor     ecx, eax
.text$x:0000A75D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A762                 mov     eax, offset __ehfuncinfo$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z
.text$x:0000A767                 jmp     ___CxxFrameHandler3
.text$x:0000A767 __ehhandler$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z endp
.text$x:0000A767
.text$x:0000A767 _text$x         ends
.text$x:0000A767
.text$mn:0000A76C ; ===========================================================================
.text$mn:0000A76C
.text$mn:0000A76C ; Segment type: Pure code
.text$mn:0000A76C ; Segment permissions: Read/Execute
.text$mn:0000A76C _text$mn        segment para public 'CODE' use32
.text$mn:0000A76C                 assume cs:_text$mn
.text$mn:0000A76C                 ;org 0A76Ch
.text$mn:0000A76C ; COMDAT (pick any)
.text$mn:0000A76C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A76C
.text$mn:0000A76C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A76C
.text$mn:0000A76C ; Attributes: bp-based frame
.text$mn:0000A76C
.text$mn:0000A76C ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:0000A76C                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000A76C ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:0000A76C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000A76C
.text$mn:0000A76C var_4           = dword ptr -4
.text$mn:0000A76C Dst             = dword ptr  8
.text$mn:0000A76C Src             = dword ptr  0Ch
.text$mn:0000A76C Size            = dword ptr  10h
.text$mn:0000A76C
.text$mn:0000A76C                 push    ebp
.text$mn:0000A76D                 mov     ebp, esp
.text$mn:0000A76F                 push    ecx
.text$mn:0000A770                 cmp     [ebp+Size], 0
.text$mn:0000A774                 jnz     short loc_A77E
.text$mn:0000A776                 mov     eax, [ebp+Dst]
.text$mn:0000A779                 mov     [ebp+var_4], eax
.text$mn:0000A77C                 jmp     short loc_A795
.text$mn:0000A77E ; ---------------------------------------------------------------------------
.text$mn:0000A77E
.text$mn:0000A77E loc_A77E:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:0000A77E                 mov     ecx, [ebp+Size]
.text$mn:0000A781                 push    ecx             ; Size
.text$mn:0000A782                 mov     edx, [ebp+Src]
.text$mn:0000A785                 push    edx             ; Src
.text$mn:0000A786                 mov     eax, [ebp+Dst]
.text$mn:0000A789                 push    eax             ; Dst
.text$mn:0000A78A                 call    _memcpy
.text$mn:0000A78F                 add     esp, 0Ch
.text$mn:0000A792                 mov     [ebp+var_4], eax
.text$mn:0000A795
.text$mn:0000A795 loc_A795:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000A795                 mov     eax, [ebp+var_4]
.text$mn:0000A798                 mov     esp, ebp
.text$mn:0000A79A                 pop     ebp
.text$mn:0000A79B                 retn
.text$mn:0000A79B ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000A79B
.text$mn:0000A79B _text$mn        ends
.text$mn:0000A79B
.text$mn:0000A79C ; ===========================================================================
.text$mn:0000A79C
.text$mn:0000A79C ; Segment type: Pure code
.text$mn:0000A79C ; Segment permissions: Read/Execute
.text$mn:0000A79C _text$mn        segment para public 'CODE' use32
.text$mn:0000A79C                 assume cs:_text$mn
.text$mn:0000A79C                 ;org 0A79Ch
.text$mn:0000A79C ; COMDAT (pick any)
.text$mn:0000A79C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A79C
.text$mn:0000A79C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A79C
.text$mn:0000A79C ; Attributes: bp-based frame
.text$mn:0000A79C
.text$mn:0000A79C ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:0000A79C                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000A79C ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000A79C                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:0000A79C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000A79C
.text$mn:0000A79C var_4           = dword ptr -4
.text$mn:0000A79C Dst             = dword ptr  8
.text$mn:0000A79C Src             = dword ptr  0Ch
.text$mn:0000A79C arg_8           = dword ptr  10h
.text$mn:0000A79C
.text$mn:0000A79C                 push    ebp
.text$mn:0000A79D                 mov     ebp, esp
.text$mn:0000A79F                 push    ecx
.text$mn:0000A7A0                 cmp     [ebp+arg_8], 0
.text$mn:0000A7A4                 jnz     short loc_A7AE
.text$mn:0000A7A6                 mov     eax, [ebp+Dst]
.text$mn:0000A7A9                 mov     [ebp+var_4], eax
.text$mn:0000A7AC                 jmp     short loc_A7C5
.text$mn:0000A7AE ; ---------------------------------------------------------------------------
.text$mn:0000A7AE
.text$mn:0000A7AE loc_A7AE:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000A7AE                 mov     ecx, [ebp+arg_8]
.text$mn:0000A7B1                 push    ecx             ; int
.text$mn:0000A7B2                 mov     edx, [ebp+Src]
.text$mn:0000A7B5                 push    edx             ; Src
.text$mn:0000A7B6                 mov     eax, [ebp+Dst]
.text$mn:0000A7B9                 push    eax             ; Dst
.text$mn:0000A7BA                 call    _wmemcpy
.text$mn:0000A7BF                 add     esp, 0Ch
.text$mn:0000A7C2                 mov     [ebp+var_4], eax
.text$mn:0000A7C5
.text$mn:0000A7C5 loc_A7C5:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000A7C5                 mov     eax, [ebp+var_4]
.text$mn:0000A7C8                 mov     esp, ebp
.text$mn:0000A7CA                 pop     ebp
.text$mn:0000A7CB                 retn
.text$mn:0000A7CB ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000A7CB
.text$mn:0000A7CB _text$mn        ends
.text$mn:0000A7CB
.text$mn:0000A7CC ; ===========================================================================
.text$mn:0000A7CC
.text$mn:0000A7CC ; Segment type: Pure code
.text$mn:0000A7CC ; Segment permissions: Read/Execute
.text$mn:0000A7CC _text$mn        segment para public 'CODE' use32
.text$mn:0000A7CC                 assume cs:_text$mn
.text$mn:0000A7CC                 ;org 0A7CCh
.text$mn:0000A7CC ; COMDAT (pick any)
.text$mn:0000A7CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A7CC
.text$mn:0000A7CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A7CC
.text$mn:0000A7CC ; Attributes: bp-based frame
.text$mn:0000A7CC
.text$mn:0000A7CC ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:0000A7CC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:0000A7CC ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:0000A7CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:0000A7CC
.text$mn:0000A7CC var_4           = dword ptr -4
.text$mn:0000A7CC arg_0           = dword ptr  8
.text$mn:0000A7CC arg_4           = dword ptr  0Ch
.text$mn:0000A7CC
.text$mn:0000A7CC                 push    ebp
.text$mn:0000A7CD                 mov     ebp, esp
.text$mn:0000A7CF                 push    ecx
.text$mn:0000A7D0                 mov     [ebp+var_4], ecx
.text$mn:0000A7D3                 mov     eax, [ebp+arg_4]
.text$mn:0000A7D6                 push    eax             ; int
.text$mn:0000A7D7                 mov     ecx, [ebp+arg_0]
.text$mn:0000A7DA                 push    ecx             ; void *
.text$mn:0000A7DB                 mov     ecx, [ebp+var_4]
.text$mn:0000A7DE                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000A7E3                 mov     esp, ebp
.text$mn:0000A7E5                 pop     ebp
.text$mn:0000A7E6                 retn    8
.text$mn:0000A7E6 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000A7E6
.text$mn:0000A7E6 ; ---------------------------------------------------------------------------
.text$mn:0000A7E9                 align 4
.text$mn:0000A7E9 _text$mn        ends
.text$mn:0000A7E9
.text$mn:0000A7EC ; ===========================================================================
.text$mn:0000A7EC
.text$mn:0000A7EC ; Segment type: Pure code
.text$mn:0000A7EC ; Segment permissions: Read/Execute
.text$mn:0000A7EC _text$mn        segment para public 'CODE' use32
.text$mn:0000A7EC                 assume cs:_text$mn
.text$mn:0000A7EC                 ;org 0A7ECh
.text$mn:0000A7EC ; COMDAT (pick any)
.text$mn:0000A7EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A7EC
.text$mn:0000A7EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A7EC
.text$mn:0000A7EC ; Attributes: bp-based frame
.text$mn:0000A7EC
.text$mn:0000A7EC ; int __stdcall std::_Wrap_alloc<std::allocator<PluginInfo *>>::deallocate(void *, int)
.text$mn:0000A7EC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@I@Z
.text$mn:0000A7EC ?deallocate@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@I@Z proc near
.text$mn:0000A7EC                                         ; CODE XREF: __catch$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000A7EC                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reallocate(uint)+F5p
.text$mn:0000A7EC
.text$mn:0000A7EC var_4           = dword ptr -4
.text$mn:0000A7EC arg_0           = dword ptr  8
.text$mn:0000A7EC arg_4           = dword ptr  0Ch
.text$mn:0000A7EC
.text$mn:0000A7EC                 push    ebp
.text$mn:0000A7ED                 mov     ebp, esp
.text$mn:0000A7EF                 push    ecx
.text$mn:0000A7F0                 mov     [ebp+var_4], ecx
.text$mn:0000A7F3                 mov     eax, [ebp+arg_4]
.text$mn:0000A7F6                 push    eax             ; int
.text$mn:0000A7F7                 mov     ecx, [ebp+arg_0]
.text$mn:0000A7FA                 push    ecx             ; void *
.text$mn:0000A7FB                 mov     ecx, [ebp+var_4]
.text$mn:0000A7FE                 call    ?deallocate@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@I@Z ; std::allocator<PluginInfo *>::deallocate(PluginInfo * *,uint)
.text$mn:0000A803                 mov     esp, ebp
.text$mn:0000A805                 pop     ebp
.text$mn:0000A806                 retn    8
.text$mn:0000A806 ?deallocate@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@I@Z endp
.text$mn:0000A806
.text$mn:0000A806 ; ---------------------------------------------------------------------------
.text$mn:0000A809                 align 4
.text$mn:0000A809 _text$mn        ends
.text$mn:0000A809
.text$mn:0000A80C ; ===========================================================================
.text$mn:0000A80C
.text$mn:0000A80C ; Segment type: Pure code
.text$mn:0000A80C ; Segment permissions: Read/Execute
.text$mn:0000A80C _text$mn        segment para public 'CODE' use32
.text$mn:0000A80C                 assume cs:_text$mn
.text$mn:0000A80C                 ;org 0A80Ch
.text$mn:0000A80C ; COMDAT (pick any)
.text$mn:0000A80C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A80C
.text$mn:0000A80C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A80C
.text$mn:0000A80C ; Attributes: bp-based frame
.text$mn:0000A80C
.text$mn:0000A80C ; int __stdcall std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::deallocate(void *, int)
.text$mn:0000A80C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@I@Z
.text$mn:0000A80C ?deallocate@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@I@Z proc near
.text$mn:0000A80C                                         ; CODE XREF: __catch$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000A80C                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reallocate(uint)+F5p
.text$mn:0000A80C
.text$mn:0000A80C var_4           = dword ptr -4
.text$mn:0000A80C arg_0           = dword ptr  8
.text$mn:0000A80C arg_4           = dword ptr  0Ch
.text$mn:0000A80C
.text$mn:0000A80C                 push    ebp
.text$mn:0000A80D                 mov     ebp, esp
.text$mn:0000A80F                 push    ecx
.text$mn:0000A810                 mov     [ebp+var_4], ecx
.text$mn:0000A813                 mov     eax, [ebp+arg_4]
.text$mn:0000A816                 push    eax             ; int
.text$mn:0000A817                 mov     ecx, [ebp+arg_0]
.text$mn:0000A81A                 push    ecx             ; void *
.text$mn:0000A81B                 mov     ecx, [ebp+var_4]
.text$mn:0000A81E                 call    ?deallocate@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@I@Z ; std::allocator<TiXmlDocument *>::deallocate(TiXmlDocument * *,uint)
.text$mn:0000A823                 mov     esp, ebp
.text$mn:0000A825                 pop     ebp
.text$mn:0000A826                 retn    8
.text$mn:0000A826 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@I@Z endp
.text$mn:0000A826
.text$mn:0000A826 ; ---------------------------------------------------------------------------
.text$mn:0000A829                 align 4
.text$mn:0000A829 _text$mn        ends
.text$mn:0000A829
.text$mn:0000A82C ; ===========================================================================
.text$mn:0000A82C
.text$mn:0000A82C ; Segment type: Pure code
.text$mn:0000A82C ; Segment permissions: Read/Execute
.text$mn:0000A82C _text$mn        segment para public 'CODE' use32
.text$mn:0000A82C                 assume cs:_text$mn
.text$mn:0000A82C                 ;org 0A82Ch
.text$mn:0000A82C ; COMDAT (pick any)
.text$mn:0000A82C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A82C
.text$mn:0000A82C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A82C
.text$mn:0000A82C ; Attributes: bp-based frame
.text$mn:0000A82C
.text$mn:0000A82C ; int __stdcall std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::deallocate(void *, int)
.text$mn:0000A82C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z
.text$mn:0000A82C ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z proc near
.text$mn:0000A82C                                         ; CODE XREF: __catch$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z$0+16p
.text$mn:0000A82C                                         ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reallocate(uint)+F5p
.text$mn:0000A82C
.text$mn:0000A82C var_4           = dword ptr -4
.text$mn:0000A82C arg_0           = dword ptr  8
.text$mn:0000A82C arg_4           = dword ptr  0Ch
.text$mn:0000A82C
.text$mn:0000A82C                 push    ebp
.text$mn:0000A82D                 mov     ebp, esp
.text$mn:0000A82F                 push    ecx
.text$mn:0000A830                 mov     [ebp+var_4], ecx
.text$mn:0000A833                 mov     eax, [ebp+arg_4]
.text$mn:0000A836                 push    eax             ; int
.text$mn:0000A837                 mov     ecx, [ebp+arg_0]
.text$mn:0000A83A                 push    ecx             ; void *
.text$mn:0000A83B                 mov     ecx, [ebp+var_4]
.text$mn:0000A83E                 call    ?deallocate@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::deallocate(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,uint)
.text$mn:0000A843                 mov     esp, ebp
.text$mn:0000A845                 pop     ebp
.text$mn:0000A846                 retn    8
.text$mn:0000A846 ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z endp
.text$mn:0000A846
.text$mn:0000A846 ; ---------------------------------------------------------------------------
.text$mn:0000A849                 align 4
.text$mn:0000A849 _text$mn        ends
.text$mn:0000A849
.text$mn:0000A84C ; ===========================================================================
.text$mn:0000A84C
.text$mn:0000A84C ; Segment type: Pure code
.text$mn:0000A84C ; Segment permissions: Read/Execute
.text$mn:0000A84C _text$mn        segment para public 'CODE' use32
.text$mn:0000A84C                 assume cs:_text$mn
.text$mn:0000A84C                 ;org 0A84Ch
.text$mn:0000A84C ; COMDAT (pick any)
.text$mn:0000A84C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A84C
.text$mn:0000A84C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A84C
.text$mn:0000A84C ; Attributes: bp-based frame
.text$mn:0000A84C
.text$mn:0000A84C ; int __stdcall std::_Wrap_alloc<std::allocator<PluginCommand>>::deallocate(void *, int)
.text$mn:0000A84C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@I@Z
.text$mn:0000A84C ?deallocate@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@I@Z proc near
.text$mn:0000A84C                                         ; CODE XREF: __catch$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000A84C                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reallocate(uint)+FAp
.text$mn:0000A84C
.text$mn:0000A84C var_4           = dword ptr -4
.text$mn:0000A84C arg_0           = dword ptr  8
.text$mn:0000A84C arg_4           = dword ptr  0Ch
.text$mn:0000A84C
.text$mn:0000A84C                 push    ebp
.text$mn:0000A84D                 mov     ebp, esp
.text$mn:0000A84F                 push    ecx
.text$mn:0000A850                 mov     [ebp+var_4], ecx
.text$mn:0000A853                 mov     eax, [ebp+arg_4]
.text$mn:0000A856                 push    eax             ; int
.text$mn:0000A857                 mov     ecx, [ebp+arg_0]
.text$mn:0000A85A                 push    ecx             ; void *
.text$mn:0000A85B                 mov     ecx, [ebp+var_4]
.text$mn:0000A85E                 call    ?deallocate@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@I@Z ; std::allocator<PluginCommand>::deallocate(PluginCommand *,uint)
.text$mn:0000A863                 mov     esp, ebp
.text$mn:0000A865                 pop     ebp
.text$mn:0000A866                 retn    8
.text$mn:0000A866 ?deallocate@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@I@Z endp
.text$mn:0000A866
.text$mn:0000A866 ; ---------------------------------------------------------------------------
.text$mn:0000A869                 align 4
.text$mn:0000A869 _text$mn        ends
.text$mn:0000A869
.text$mn:0000A86C ; ===========================================================================
.text$mn:0000A86C
.text$mn:0000A86C ; Segment type: Pure code
.text$mn:0000A86C ; Segment permissions: Read/Execute
.text$mn:0000A86C _text$mn        segment para public 'CODE' use32
.text$mn:0000A86C                 assume cs:_text$mn
.text$mn:0000A86C                 ;org 0A86Ch
.text$mn:0000A86C ; COMDAT (pick any)
.text$mn:0000A86C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A86C
.text$mn:0000A86C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A86C
.text$mn:0000A86C ; Attributes: bp-based frame
.text$mn:0000A86C
.text$mn:0000A86C ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:0000A86C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000A86C ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000A86C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Free_proxy(void)+32p
.text$mn:0000A86C
.text$mn:0000A86C var_4           = dword ptr -4
.text$mn:0000A86C arg_0           = dword ptr  8
.text$mn:0000A86C arg_4           = dword ptr  0Ch
.text$mn:0000A86C
.text$mn:0000A86C                 push    ebp
.text$mn:0000A86D                 mov     ebp, esp
.text$mn:0000A86F                 push    ecx
.text$mn:0000A870                 mov     [ebp+var_4], ecx
.text$mn:0000A873                 mov     eax, [ebp+arg_4]
.text$mn:0000A876                 push    eax             ; int
.text$mn:0000A877                 mov     ecx, [ebp+arg_0]
.text$mn:0000A87A                 push    ecx             ; void *
.text$mn:0000A87B                 mov     ecx, [ebp+var_4]
.text$mn:0000A87E                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000A883                 mov     esp, ebp
.text$mn:0000A885                 pop     ebp
.text$mn:0000A886                 retn    8
.text$mn:0000A886 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000A886
.text$mn:0000A886 ; ---------------------------------------------------------------------------
.text$mn:0000A889                 align 4
.text$mn:0000A889 _text$mn        ends
.text$mn:0000A889
.text$mn:0000A88C ; ===========================================================================
.text$mn:0000A88C
.text$mn:0000A88C ; Segment type: Pure code
.text$mn:0000A88C ; Segment permissions: Read/Execute
.text$mn:0000A88C _text$mn        segment para public 'CODE' use32
.text$mn:0000A88C                 assume cs:_text$mn
.text$mn:0000A88C                 ;org 0A88Ch
.text$mn:0000A88C ; COMDAT (pick any)
.text$mn:0000A88C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A88C
.text$mn:0000A88C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A88C
.text$mn:0000A88C ; Attributes: bp-based frame
.text$mn:0000A88C
.text$mn:0000A88C ; int __stdcall std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(void *, int)
.text$mn:0000A88C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000A88C ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000A88C                                         ; CODE XREF: __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0+16p
.text$mn:0000A88C                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reallocate(uint)+FAp ...
.text$mn:0000A88C
.text$mn:0000A88C var_4           = dword ptr -4
.text$mn:0000A88C arg_0           = dword ptr  8
.text$mn:0000A88C arg_4           = dword ptr  0Ch
.text$mn:0000A88C
.text$mn:0000A88C                 push    ebp
.text$mn:0000A88D                 mov     ebp, esp
.text$mn:0000A88F                 push    ecx
.text$mn:0000A890                 mov     [ebp+var_4], ecx
.text$mn:0000A893                 mov     eax, [ebp+arg_4]
.text$mn:0000A896                 push    eax             ; int
.text$mn:0000A897                 mov     ecx, [ebp+arg_0]
.text$mn:0000A89A                 push    ecx             ; void *
.text$mn:0000A89B                 mov     ecx, [ebp+var_4]
.text$mn:0000A89E                 call    ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)
.text$mn:0000A8A3                 mov     esp, ebp
.text$mn:0000A8A5                 pop     ebp
.text$mn:0000A8A6                 retn    8
.text$mn:0000A8A6 ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0000A8A6
.text$mn:0000A8A6 ; ---------------------------------------------------------------------------
.text$mn:0000A8A9                 align 4
.text$mn:0000A8A9 _text$mn        ends
.text$mn:0000A8A9
.text$mn:0000A8AC ; ===========================================================================
.text$mn:0000A8AC
.text$mn:0000A8AC ; Segment type: Pure code
.text$mn:0000A8AC ; Segment permissions: Read/Execute
.text$mn:0000A8AC _text$mn        segment para public 'CODE' use32
.text$mn:0000A8AC                 assume cs:_text$mn
.text$mn:0000A8AC                 ;org 0A8ACh
.text$mn:0000A8AC ; COMDAT (pick any)
.text$mn:0000A8AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A8AC
.text$mn:0000A8AC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A8AC
.text$mn:0000A8AC ; Attributes: bp-based frame
.text$mn:0000A8AC
.text$mn:0000A8AC ; int __stdcall std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::deallocate(void *, int)
.text$mn:0000A8AC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@I@Z
.text$mn:0000A8AC ?deallocate@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@I@Z proc near
.text$mn:0000A8AC                                         ; CODE XREF: __catch$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:0000A8AC                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reallocate(uint)+FAp
.text$mn:0000A8AC
.text$mn:0000A8AC var_4           = dword ptr -4
.text$mn:0000A8AC arg_0           = dword ptr  8
.text$mn:0000A8AC arg_4           = dword ptr  0Ch
.text$mn:0000A8AC
.text$mn:0000A8AC                 push    ebp
.text$mn:0000A8AD                 mov     ebp, esp
.text$mn:0000A8AF                 push    ecx
.text$mn:0000A8B0                 mov     [ebp+var_4], ecx
.text$mn:0000A8B3                 mov     eax, [ebp+arg_4]
.text$mn:0000A8B6                 push    eax             ; int
.text$mn:0000A8B7                 mov     ecx, [ebp+arg_0]
.text$mn:0000A8BA                 push    ecx             ; void *
.text$mn:0000A8BB                 mov     ecx, [ebp+var_4]
.text$mn:0000A8BE                 call    ?deallocate@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@I@Z ; std::allocator<PluginCmdShortcut>::deallocate(PluginCmdShortcut *,uint)
.text$mn:0000A8C3                 mov     esp, ebp
.text$mn:0000A8C5                 pop     ebp
.text$mn:0000A8C6                 retn    8
.text$mn:0000A8C6 ?deallocate@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@I@Z endp
.text$mn:0000A8C6
.text$mn:0000A8C6 ; ---------------------------------------------------------------------------
.text$mn:0000A8C9                 align 4
.text$mn:0000A8C9 _text$mn        ends
.text$mn:0000A8C9
.text$mn:0000A8CC ; ===========================================================================
.text$mn:0000A8CC
.text$mn:0000A8CC ; Segment type: Pure code
.text$mn:0000A8CC ; Segment permissions: Read/Execute
.text$mn:0000A8CC _text$mn        segment para public 'CODE' use32
.text$mn:0000A8CC                 assume cs:_text$mn
.text$mn:0000A8CC                 ;org 0A8CCh
.text$mn:0000A8CC ; COMDAT (pick any)
.text$mn:0000A8CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A8CC
.text$mn:0000A8CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A8CC
.text$mn:0000A8CC ; Attributes: bp-based frame
.text$mn:0000A8CC
.text$mn:0000A8CC ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:0000A8CC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:0000A8CC ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:0000A8CC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:0000A8CC
.text$mn:0000A8CC var_4           = dword ptr -4
.text$mn:0000A8CC arg_0           = dword ptr  8
.text$mn:0000A8CC arg_4           = dword ptr  0Ch
.text$mn:0000A8CC
.text$mn:0000A8CC                 push    ebp
.text$mn:0000A8CD                 mov     ebp, esp
.text$mn:0000A8CF                 push    ecx
.text$mn:0000A8D0                 mov     [ebp+var_4], ecx
.text$mn:0000A8D3                 mov     eax, [ebp+arg_4]
.text$mn:0000A8D6                 push    eax             ; int
.text$mn:0000A8D7                 mov     ecx, [ebp+arg_0]
.text$mn:0000A8DA                 push    ecx             ; void *
.text$mn:0000A8DB                 mov     ecx, [ebp+var_4]
.text$mn:0000A8DE                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:0000A8E3                 mov     esp, ebp
.text$mn:0000A8E5                 pop     ebp
.text$mn:0000A8E6                 retn    8
.text$mn:0000A8E6 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:0000A8E6
.text$mn:0000A8E6 ; ---------------------------------------------------------------------------
.text$mn:0000A8E9                 align 4
.text$mn:0000A8E9 _text$mn        ends
.text$mn:0000A8E9
.text$mn:0000A8EC ; ===========================================================================
.text$mn:0000A8EC
.text$mn:0000A8EC ; Segment type: Pure code
.text$mn:0000A8EC ; Segment permissions: Read/Execute
.text$mn:0000A8EC _text$mn        segment para public 'CODE' use32
.text$mn:0000A8EC                 assume cs:_text$mn
.text$mn:0000A8EC                 ;org 0A8ECh
.text$mn:0000A8EC ; COMDAT (pick any)
.text$mn:0000A8EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A8EC
.text$mn:0000A8EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A8EC
.text$mn:0000A8EC ; Attributes: bp-based frame
.text$mn:0000A8EC
.text$mn:0000A8EC ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:0000A8EC                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:0000A8EC ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:0000A8EC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:0000A8EC
.text$mn:0000A8EC var_4           = dword ptr -4
.text$mn:0000A8EC arg_0           = dword ptr  8
.text$mn:0000A8EC
.text$mn:0000A8EC                 push    ebp
.text$mn:0000A8ED                 mov     ebp, esp
.text$mn:0000A8EF                 push    ecx
.text$mn:0000A8F0                 mov     [ebp+var_4], ecx
.text$mn:0000A8F3                 mov     eax, [ebp+arg_0]
.text$mn:0000A8F6                 push    eax             ; void *
.text$mn:0000A8F7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A8FC                 add     esp, 4
.text$mn:0000A8FF                 mov     esp, ebp
.text$mn:0000A901                 pop     ebp
.text$mn:0000A902                 retn    8
.text$mn:0000A902 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000A902
.text$mn:0000A902 ; ---------------------------------------------------------------------------
.text$mn:0000A905                 align 4
.text$mn:0000A905 _text$mn        ends
.text$mn:0000A905
.text$mn:0000A908 ; ===========================================================================
.text$mn:0000A908
.text$mn:0000A908 ; Segment type: Pure code
.text$mn:0000A908 ; Segment permissions: Read/Execute
.text$mn:0000A908 _text$mn        segment para public 'CODE' use32
.text$mn:0000A908                 assume cs:_text$mn
.text$mn:0000A908                 ;org 0A908h
.text$mn:0000A908 ; COMDAT (pick any)
.text$mn:0000A908                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A908
.text$mn:0000A908 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A908
.text$mn:0000A908 ; Attributes: bp-based frame
.text$mn:0000A908
.text$mn:0000A908 ; int __stdcall std::allocator<PluginInfo *>::deallocate(void *, int)
.text$mn:0000A908                 public ?deallocate@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@I@Z
.text$mn:0000A908 ?deallocate@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@I@Z proc near
.text$mn:0000A908                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginInfo *>>::deallocate(PluginInfo * *,uint)+12p
.text$mn:0000A908
.text$mn:0000A908 var_4           = dword ptr -4
.text$mn:0000A908 arg_0           = dword ptr  8
.text$mn:0000A908
.text$mn:0000A908                 push    ebp
.text$mn:0000A909                 mov     ebp, esp
.text$mn:0000A90B                 push    ecx
.text$mn:0000A90C                 mov     [ebp+var_4], ecx
.text$mn:0000A90F                 mov     eax, [ebp+arg_0]
.text$mn:0000A912                 push    eax             ; void *
.text$mn:0000A913                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A918                 add     esp, 4
.text$mn:0000A91B                 mov     esp, ebp
.text$mn:0000A91D                 pop     ebp
.text$mn:0000A91E                 retn    8
.text$mn:0000A91E ?deallocate@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@I@Z endp
.text$mn:0000A91E
.text$mn:0000A91E ; ---------------------------------------------------------------------------
.text$mn:0000A921                 align 4
.text$mn:0000A921 _text$mn        ends
.text$mn:0000A921
.text$mn:0000A924 ; ===========================================================================
.text$mn:0000A924
.text$mn:0000A924 ; Segment type: Pure code
.text$mn:0000A924 ; Segment permissions: Read/Execute
.text$mn:0000A924 _text$mn        segment para public 'CODE' use32
.text$mn:0000A924                 assume cs:_text$mn
.text$mn:0000A924                 ;org 0A924h
.text$mn:0000A924 ; COMDAT (pick any)
.text$mn:0000A924                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A924
.text$mn:0000A924 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A924
.text$mn:0000A924 ; Attributes: bp-based frame
.text$mn:0000A924
.text$mn:0000A924 ; int __stdcall std::allocator<TiXmlDocument *>::deallocate(void *, int)
.text$mn:0000A924                 public ?deallocate@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@I@Z
.text$mn:0000A924 ?deallocate@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@I@Z proc near
.text$mn:0000A924                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::deallocate(TiXmlDocument * *,uint)+12p
.text$mn:0000A924
.text$mn:0000A924 var_4           = dword ptr -4
.text$mn:0000A924 arg_0           = dword ptr  8
.text$mn:0000A924
.text$mn:0000A924                 push    ebp
.text$mn:0000A925                 mov     ebp, esp
.text$mn:0000A927                 push    ecx
.text$mn:0000A928                 mov     [ebp+var_4], ecx
.text$mn:0000A92B                 mov     eax, [ebp+arg_0]
.text$mn:0000A92E                 push    eax             ; void *
.text$mn:0000A92F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A934                 add     esp, 4
.text$mn:0000A937                 mov     esp, ebp
.text$mn:0000A939                 pop     ebp
.text$mn:0000A93A                 retn    8
.text$mn:0000A93A ?deallocate@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@I@Z endp
.text$mn:0000A93A
.text$mn:0000A93A ; ---------------------------------------------------------------------------
.text$mn:0000A93D                 align 10h
.text$mn:0000A93D _text$mn        ends
.text$mn:0000A93D
.text$mn:0000A940 ; ===========================================================================
.text$mn:0000A940
.text$mn:0000A940 ; Segment type: Pure code
.text$mn:0000A940 ; Segment permissions: Read/Execute
.text$mn:0000A940 _text$mn        segment para public 'CODE' use32
.text$mn:0000A940                 assume cs:_text$mn
.text$mn:0000A940                 ;org 0A940h
.text$mn:0000A940 ; COMDAT (pick any)
.text$mn:0000A940                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A940
.text$mn:0000A940 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A940
.text$mn:0000A940 ; Attributes: bp-based frame
.text$mn:0000A940
.text$mn:0000A940 ; int __stdcall std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::deallocate(void *, int)
.text$mn:0000A940                 public ?deallocate@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z
.text$mn:0000A940 ?deallocate@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z proc near
.text$mn:0000A940                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::deallocate(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,uint)+12p
.text$mn:0000A940
.text$mn:0000A940 var_4           = dword ptr -4
.text$mn:0000A940 arg_0           = dword ptr  8
.text$mn:0000A940
.text$mn:0000A940                 push    ebp
.text$mn:0000A941                 mov     ebp, esp
.text$mn:0000A943                 push    ecx
.text$mn:0000A944                 mov     [ebp+var_4], ecx
.text$mn:0000A947                 mov     eax, [ebp+arg_0]
.text$mn:0000A94A                 push    eax             ; void *
.text$mn:0000A94B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A950                 add     esp, 4
.text$mn:0000A953                 mov     esp, ebp
.text$mn:0000A955                 pop     ebp
.text$mn:0000A956                 retn    8
.text$mn:0000A956 ?deallocate@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@I@Z endp
.text$mn:0000A956
.text$mn:0000A956 ; ---------------------------------------------------------------------------
.text$mn:0000A959                 align 4
.text$mn:0000A959 _text$mn        ends
.text$mn:0000A959
.text$mn:0000A95C ; ===========================================================================
.text$mn:0000A95C
.text$mn:0000A95C ; Segment type: Pure code
.text$mn:0000A95C ; Segment permissions: Read/Execute
.text$mn:0000A95C _text$mn        segment para public 'CODE' use32
.text$mn:0000A95C                 assume cs:_text$mn
.text$mn:0000A95C                 ;org 0A95Ch
.text$mn:0000A95C ; COMDAT (pick any)
.text$mn:0000A95C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A95C
.text$mn:0000A95C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A95C
.text$mn:0000A95C ; Attributes: bp-based frame
.text$mn:0000A95C
.text$mn:0000A95C ; int __stdcall std::allocator<PluginCommand>::deallocate(void *, int)
.text$mn:0000A95C                 public ?deallocate@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@I@Z
.text$mn:0000A95C ?deallocate@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@I@Z proc near
.text$mn:0000A95C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCommand>>::deallocate(PluginCommand *,uint)+12p
.text$mn:0000A95C
.text$mn:0000A95C var_4           = dword ptr -4
.text$mn:0000A95C arg_0           = dword ptr  8
.text$mn:0000A95C
.text$mn:0000A95C                 push    ebp
.text$mn:0000A95D                 mov     ebp, esp
.text$mn:0000A95F                 push    ecx
.text$mn:0000A960                 mov     [ebp+var_4], ecx
.text$mn:0000A963                 mov     eax, [ebp+arg_0]
.text$mn:0000A966                 push    eax             ; void *
.text$mn:0000A967                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A96C                 add     esp, 4
.text$mn:0000A96F                 mov     esp, ebp
.text$mn:0000A971                 pop     ebp
.text$mn:0000A972                 retn    8
.text$mn:0000A972 ?deallocate@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@I@Z endp
.text$mn:0000A972
.text$mn:0000A972 ; ---------------------------------------------------------------------------
.text$mn:0000A975                 align 4
.text$mn:0000A975 _text$mn        ends
.text$mn:0000A975
.text$mn:0000A978 ; ===========================================================================
.text$mn:0000A978
.text$mn:0000A978 ; Segment type: Pure code
.text$mn:0000A978 ; Segment permissions: Read/Execute
.text$mn:0000A978 _text$mn        segment para public 'CODE' use32
.text$mn:0000A978                 assume cs:_text$mn
.text$mn:0000A978                 ;org 0A978h
.text$mn:0000A978 ; COMDAT (pick any)
.text$mn:0000A978                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A978
.text$mn:0000A978 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A978
.text$mn:0000A978 ; Attributes: bp-based frame
.text$mn:0000A978
.text$mn:0000A978 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:0000A978                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000A978 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000A978                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000A978                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:0000A978
.text$mn:0000A978 var_4           = dword ptr -4
.text$mn:0000A978 arg_0           = dword ptr  8
.text$mn:0000A978
.text$mn:0000A978                 push    ebp
.text$mn:0000A979                 mov     ebp, esp
.text$mn:0000A97B                 push    ecx
.text$mn:0000A97C                 mov     [ebp+var_4], ecx
.text$mn:0000A97F                 mov     eax, [ebp+arg_0]
.text$mn:0000A982                 push    eax             ; void *
.text$mn:0000A983                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A988                 add     esp, 4
.text$mn:0000A98B                 mov     esp, ebp
.text$mn:0000A98D                 pop     ebp
.text$mn:0000A98E                 retn    8
.text$mn:0000A98E ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000A98E
.text$mn:0000A98E ; ---------------------------------------------------------------------------
.text$mn:0000A991                 align 4
.text$mn:0000A991 _text$mn        ends
.text$mn:0000A991
.text$mn:0000A994 ; ===========================================================================
.text$mn:0000A994
.text$mn:0000A994 ; Segment type: Pure code
.text$mn:0000A994 ; Segment permissions: Read/Execute
.text$mn:0000A994 _text$mn        segment para public 'CODE' use32
.text$mn:0000A994                 assume cs:_text$mn
.text$mn:0000A994                 ;org 0A994h
.text$mn:0000A994 ; COMDAT (pick any)
.text$mn:0000A994                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A994
.text$mn:0000A994 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A994
.text$mn:0000A994 ; Attributes: bp-based frame
.text$mn:0000A994
.text$mn:0000A994 ; int __stdcall std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::deallocate(void *, int)
.text$mn:0000A994                 public ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
.text$mn:0000A994 ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z proc near
.text$mn:0000A994                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::deallocate(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,uint)+12p
.text$mn:0000A994
.text$mn:0000A994 var_4           = dword ptr -4
.text$mn:0000A994 arg_0           = dword ptr  8
.text$mn:0000A994
.text$mn:0000A994                 push    ebp
.text$mn:0000A995                 mov     ebp, esp
.text$mn:0000A997                 push    ecx
.text$mn:0000A998                 mov     [ebp+var_4], ecx
.text$mn:0000A99B                 mov     eax, [ebp+arg_0]
.text$mn:0000A99E                 push    eax             ; void *
.text$mn:0000A99F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A9A4                 add     esp, 4
.text$mn:0000A9A7                 mov     esp, ebp
.text$mn:0000A9A9                 pop     ebp
.text$mn:0000A9AA                 retn    8
.text$mn:0000A9AA ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z endp
.text$mn:0000A9AA
.text$mn:0000A9AA ; ---------------------------------------------------------------------------
.text$mn:0000A9AD                 align 10h
.text$mn:0000A9AD _text$mn        ends
.text$mn:0000A9AD
.text$mn:0000A9B0 ; ===========================================================================
.text$mn:0000A9B0
.text$mn:0000A9B0 ; Segment type: Pure code
.text$mn:0000A9B0 ; Segment permissions: Read/Execute
.text$mn:0000A9B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9B0                 assume cs:_text$mn
.text$mn:0000A9B0                 ;org 0A9B0h
.text$mn:0000A9B0 ; COMDAT (pick any)
.text$mn:0000A9B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A9B0
.text$mn:0000A9B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9B0
.text$mn:0000A9B0 ; Attributes: bp-based frame
.text$mn:0000A9B0
.text$mn:0000A9B0 ; int __stdcall std::allocator<PluginCmdShortcut>::deallocate(void *, int)
.text$mn:0000A9B0                 public ?deallocate@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@I@Z
.text$mn:0000A9B0 ?deallocate@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@I@Z proc near
.text$mn:0000A9B0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::deallocate(PluginCmdShortcut *,uint)+12p
.text$mn:0000A9B0
.text$mn:0000A9B0 var_4           = dword ptr -4
.text$mn:0000A9B0 arg_0           = dword ptr  8
.text$mn:0000A9B0
.text$mn:0000A9B0                 push    ebp
.text$mn:0000A9B1                 mov     ebp, esp
.text$mn:0000A9B3                 push    ecx
.text$mn:0000A9B4                 mov     [ebp+var_4], ecx
.text$mn:0000A9B7                 mov     eax, [ebp+arg_0]
.text$mn:0000A9BA                 push    eax             ; void *
.text$mn:0000A9BB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A9C0                 add     esp, 4
.text$mn:0000A9C3                 mov     esp, ebp
.text$mn:0000A9C5                 pop     ebp
.text$mn:0000A9C6                 retn    8
.text$mn:0000A9C6 ?deallocate@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@I@Z endp
.text$mn:0000A9C6
.text$mn:0000A9C6 ; ---------------------------------------------------------------------------
.text$mn:0000A9C9                 align 4
.text$mn:0000A9C9 _text$mn        ends
.text$mn:0000A9C9
.text$mn:0000A9CC ; ===========================================================================
.text$mn:0000A9CC
.text$mn:0000A9CC ; Segment type: Pure code
.text$mn:0000A9CC ; Segment permissions: Read/Execute
.text$mn:0000A9CC _text$mn        segment para public 'CODE' use32
.text$mn:0000A9CC                 assume cs:_text$mn
.text$mn:0000A9CC                 ;org 0A9CCh
.text$mn:0000A9CC ; COMDAT (pick any)
.text$mn:0000A9CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A9CC
.text$mn:0000A9CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9CC
.text$mn:0000A9CC ; Attributes: bp-based frame
.text$mn:0000A9CC
.text$mn:0000A9CC ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:0000A9CC                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:0000A9CC ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:0000A9CC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:0000A9CC
.text$mn:0000A9CC var_4           = dword ptr -4
.text$mn:0000A9CC arg_0           = dword ptr  8
.text$mn:0000A9CC
.text$mn:0000A9CC                 push    ebp
.text$mn:0000A9CD                 mov     ebp, esp
.text$mn:0000A9CF                 push    ecx
.text$mn:0000A9D0                 mov     [ebp+var_4], ecx
.text$mn:0000A9D3                 mov     eax, [ebp+arg_0]
.text$mn:0000A9D6                 push    eax             ; void *
.text$mn:0000A9D7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A9DC                 add     esp, 4
.text$mn:0000A9DF                 mov     esp, ebp
.text$mn:0000A9E1                 pop     ebp
.text$mn:0000A9E2                 retn    8
.text$mn:0000A9E2 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:0000A9E2
.text$mn:0000A9E2 ; ---------------------------------------------------------------------------
.text$mn:0000A9E5                 align 4
.text$mn:0000A9E5 _text$mn        ends
.text$mn:0000A9E5
.text$mn:0000A9E8 ; ===========================================================================
.text$mn:0000A9E8
.text$mn:0000A9E8 ; Segment type: Pure code
.text$mn:0000A9E8 ; Segment permissions: Read/Execute
.text$mn:0000A9E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9E8                 assume cs:_text$mn
.text$mn:0000A9E8                 ;org 0A9E8h
.text$mn:0000A9E8 ; COMDAT (pick any)
.text$mn:0000A9E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A9E8
.text$mn:0000A9E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9E8
.text$mn:0000A9E8 ; Attributes: bp-based frame
.text$mn:0000A9E8
.text$mn:0000A9E8 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:0000A9E8                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000A9E8 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000A9E8                                         ; DATA XREF: .rdata:0000DA58o
.text$mn:0000A9E8
.text$mn:0000A9E8 var_4           = dword ptr -4
.text$mn:0000A9E8 arg_0           = dword ptr  8
.text$mn:0000A9E8 arg_4           = dword ptr  0Ch
.text$mn:0000A9E8
.text$mn:0000A9E8                 push    ebp
.text$mn:0000A9E9                 mov     ebp, esp
.text$mn:0000A9EB                 push    ecx
.text$mn:0000A9EC                 mov     [ebp+var_4], ecx
.text$mn:0000A9EF                 mov     eax, [ebp+arg_4]
.text$mn:0000A9F2                 push    eax             ; int
.text$mn:0000A9F3                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000A9F8                 add     esp, 4
.text$mn:0000A9FB                 test    eax, eax
.text$mn:0000A9FD                 jz      short loc_AA18
.text$mn:0000A9FF                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:0000AA04                 push    eax             ; struct std::error_category *
.text$mn:0000AA05                 mov     ecx, [ebp+arg_4]
.text$mn:0000AA08                 push    ecx             ; int
.text$mn:0000AA09                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000AA0C                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000AA11                 mov     eax, [ebp+arg_0]
.text$mn:0000AA14                 jmp     short loc_AA2D
.text$mn:0000AA16 ; ---------------------------------------------------------------------------
.text$mn:0000AA16                 jmp     short loc_AA2D
.text$mn:0000AA18 ; ---------------------------------------------------------------------------
.text$mn:0000AA18
.text$mn:0000AA18 loc_AA18:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:0000AA18                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:0000AA1D                 push    eax             ; struct std::error_category *
.text$mn:0000AA1E                 mov     edx, [ebp+arg_4]
.text$mn:0000AA21                 push    edx             ; int
.text$mn:0000AA22                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000AA25                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000AA2A                 mov     eax, [ebp+arg_0]
.text$mn:0000AA2D
.text$mn:0000AA2D loc_AA2D:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0000AA2D                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0000AA2D                 mov     esp, ebp
.text$mn:0000AA2F                 pop     ebp
.text$mn:0000AA30                 retn    8
.text$mn:0000AA30 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000AA30
.text$mn:0000AA30 ; ---------------------------------------------------------------------------
.text$mn:0000AA33                 align 4
.text$mn:0000AA33 _text$mn        ends
.text$mn:0000AA33
.text$mn:0000AA34 ; ===========================================================================
.text$mn:0000AA34
.text$mn:0000AA34 ; Segment type: Pure code
.text$mn:0000AA34 ; Segment permissions: Read/Execute
.text$mn:0000AA34 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA34                 assume cs:_text$mn
.text$mn:0000AA34                 ;org 0AA34h
.text$mn:0000AA34 ; COMDAT (pick any)
.text$mn:0000AA34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AA34
.text$mn:0000AA34 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA34
.text$mn:0000AA34 ; Attributes: bp-based frame
.text$mn:0000AA34
.text$mn:0000AA34 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:0000AA34                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000AA34 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000AA34                                         ; DATA XREF: .rdata:0000D9C8o
.text$mn:0000AA34                                         ; .rdata:0000D9E4o ...
.text$mn:0000AA34
.text$mn:0000AA34 var_4           = dword ptr -4
.text$mn:0000AA34 arg_0           = dword ptr  8
.text$mn:0000AA34 arg_4           = dword ptr  0Ch
.text$mn:0000AA34
.text$mn:0000AA34                 push    ebp
.text$mn:0000AA35                 mov     ebp, esp
.text$mn:0000AA37                 push    ecx
.text$mn:0000AA38                 mov     [ebp+var_4], ecx
.text$mn:0000AA3B                 mov     eax, [ebp+var_4]
.text$mn:0000AA3E                 push    eax             ; struct std::error_category *
.text$mn:0000AA3F                 mov     ecx, [ebp+arg_4]
.text$mn:0000AA42                 push    ecx             ; int
.text$mn:0000AA43                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000AA46                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000AA4B                 mov     eax, [ebp+arg_0]
.text$mn:0000AA4E                 mov     esp, ebp
.text$mn:0000AA50                 pop     ebp
.text$mn:0000AA51                 retn    8
.text$mn:0000AA51 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000AA51
.text$mn:0000AA51 _text$mn        ends
.text$mn:0000AA51
.text$mn:0000AA54 ; ===========================================================================
.text$mn:0000AA54
.text$mn:0000AA54 ; Segment type: Pure code
.text$mn:0000AA54 ; Segment permissions: Read/Execute
.text$mn:0000AA54 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA54                 assume cs:_text$mn
.text$mn:0000AA54                 ;org 0AA54h
.text$mn:0000AA54 ; COMDAT (pick any)
.text$mn:0000AA54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AA54
.text$mn:0000AA54 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA54
.text$mn:0000AA54 ; Attributes: bp-based frame
.text$mn:0000AA54
.text$mn:0000AA54 ; void __thiscall StaticDialog::destroy(StaticDialog *__hidden this)
.text$mn:0000AA54                 public ?destroy@StaticDialog@@UAEXXZ
.text$mn:0000AA54 ?destroy@StaticDialog@@UAEXXZ proc near ; CODE XREF: StaticDialog::~StaticDialog(void)+59p
.text$mn:0000AA54                                         ; DATA XREF: .rdata:0000DAC8o ...
.text$mn:0000AA54
.text$mn:0000AA54 var_4           = dword ptr -4
.text$mn:0000AA54
.text$mn:0000AA54                 push    ebp
.text$mn:0000AA55                 mov     ebp, esp
.text$mn:0000AA57                 push    ecx
.text$mn:0000AA58                 mov     [ebp+var_4], ecx
.text$mn:0000AA5B                 mov     eax, [ebp+var_4]
.text$mn:0000AA5E                 mov     ecx, [eax+0Ch]
.text$mn:0000AA61                 push    ecx             ; lParam
.text$mn:0000AA62                 push    1               ; wParam
.text$mn:0000AA64                 push    7F4h            ; Msg
.text$mn:0000AA69                 mov     edx, [ebp+var_4]
.text$mn:0000AA6C                 mov     eax, [edx+8]
.text$mn:0000AA6F                 push    eax             ; hWnd
.text$mn:0000AA70                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000AA76                 mov     ecx, [ebp+var_4]
.text$mn:0000AA79                 mov     edx, [ecx+0Ch]
.text$mn:0000AA7C                 push    edx             ; hWnd
.text$mn:0000AA7D                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:0000AA83                 mov     esp, ebp
.text$mn:0000AA85                 pop     ebp
.text$mn:0000AA86                 retn
.text$mn:0000AA86 ?destroy@StaticDialog@@UAEXXZ endp
.text$mn:0000AA86
.text$mn:0000AA86 ; ---------------------------------------------------------------------------
.text$mn:0000AA87                 align 4
.text$mn:0000AA87 _text$mn        ends
.text$mn:0000AA87
.text$mn:0000AA88 ; ===========================================================================
.text$mn:0000AA88
.text$mn:0000AA88 ; Segment type: Pure code
.text$mn:0000AA88 ; Segment permissions: Read/Execute
.text$mn:0000AA88 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA88                 assume cs:_text$mn
.text$mn:0000AA88                 ;org 0AA88h
.text$mn:0000AA88 ; COMDAT (pick any)
.text$mn:0000AA88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AA88
.text$mn:0000AA88 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA88
.text$mn:0000AA88 ; Attributes: bp-based frame
.text$mn:0000AA88
.text$mn:0000AA88 ; void __thiscall Window::display(Window *this, bool)
.text$mn:0000AA88                 public ?display@Window@@UBEX_N@Z
.text$mn:0000AA88 ?display@Window@@UBEX_N@Z proc near     ; DATA XREF: .rdata:0000DA98o
.text$mn:0000AA88
.text$mn:0000AA88 var_8           = dword ptr -8
.text$mn:0000AA88 nCmdShow        = dword ptr -4
.text$mn:0000AA88 arg_0           = byte ptr  8
.text$mn:0000AA88
.text$mn:0000AA88                 push    ebp
.text$mn:0000AA89                 mov     ebp, esp
.text$mn:0000AA8B                 sub     esp, 8
.text$mn:0000AA8E                 mov     [ebp+var_8], ecx
.text$mn:0000AA91                 movzx   eax, [ebp+arg_0]
.text$mn:0000AA95                 test    eax, eax
.text$mn:0000AA97                 jz      short loc_AAA2
.text$mn:0000AA99                 mov     [ebp+nCmdShow], 5
.text$mn:0000AAA0                 jmp     short loc_AAA9
.text$mn:0000AAA2 ; ---------------------------------------------------------------------------
.text$mn:0000AAA2
.text$mn:0000AAA2 loc_AAA2:                               ; CODE XREF: Window::display(bool)+Fj
.text$mn:0000AAA2                 mov     [ebp+nCmdShow], 0
.text$mn:0000AAA9
.text$mn:0000AAA9 loc_AAA9:                               ; CODE XREF: Window::display(bool)+18j
.text$mn:0000AAA9                 mov     ecx, [ebp+nCmdShow]
.text$mn:0000AAAC                 push    ecx             ; nCmdShow
.text$mn:0000AAAD                 mov     edx, [ebp+var_8]
.text$mn:0000AAB0                 mov     eax, [edx+0Ch]
.text$mn:0000AAB3                 push    eax             ; hWnd
.text$mn:0000AAB4                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:0000AABA                 mov     esp, ebp
.text$mn:0000AABC                 pop     ebp
.text$mn:0000AABD                 retn    4
.text$mn:0000AABD ?display@Window@@UBEX_N@Z endp
.text$mn:0000AABD
.text$mn:0000AABD _text$mn        ends
.text$mn:0000AABD
.text$mn:0000AAC0 ; ===========================================================================
.text$mn:0000AAC0
.text$mn:0000AAC0 ; Segment type: Pure code
.text$mn:0000AAC0 ; Segment permissions: Read/Execute
.text$mn:0000AAC0 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAC0                 assume cs:_text$mn
.text$mn:0000AAC0                 ;org 0AAC0h
.text$mn:0000AAC0 ; COMDAT (pick any)
.text$mn:0000AAC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AAC0
.text$mn:0000AAC0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAC0
.text$mn:0000AAC0 ; Attributes: bp-based frame
.text$mn:0000AAC0
.text$mn:0000AAC0 ; int __thiscall Shortcut::doDialog(Shortcut *__hidden this)
.text$mn:0000AAC0                 public ?doDialog@Shortcut@@UAEHXZ
.text$mn:0000AAC0 ?doDialog@Shortcut@@UAEHXZ proc near    ; DATA XREF: .rdata:0000DB3Co
.text$mn:0000AAC0                                         ; .rdata:0000DB8Co ...
.text$mn:0000AAC0
.text$mn:0000AAC0 dwInitParam     = dword ptr -4
.text$mn:0000AAC0
.text$mn:0000AAC0                 push    ebp
.text$mn:0000AAC1                 mov     ebp, esp
.text$mn:0000AAC3                 push    ecx
.text$mn:0000AAC4                 mov     [ebp+dwInitParam], ecx
.text$mn:0000AAC7                 mov     eax, [ebp+dwInitParam]
.text$mn:0000AACA                 push    eax             ; dwInitParam
.text$mn:0000AACB                 push    offset ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z ; lpDialogFunc
.text$mn:0000AAD0                 mov     ecx, [ebp+dwInitParam]
.text$mn:0000AAD3                 mov     edx, [ecx+8]
.text$mn:0000AAD6                 push    edx             ; hWndParent
.text$mn:0000AAD7                 push    (offset loc_137F+9) ; lpTemplateName
.text$mn:0000AADC                 mov     eax, [ebp+dwInitParam]
.text$mn:0000AADF                 mov     ecx, [eax+4]
.text$mn:0000AAE2                 push    ecx             ; hInstance
.text$mn:0000AAE3                 call    dword ptr ds:__imp__DialogBoxParamW@20 ; DialogBoxParamW(x,x,x,x,x)
.text$mn:0000AAE9                 mov     esp, ebp
.text$mn:0000AAEB                 pop     ebp
.text$mn:0000AAEC                 retn
.text$mn:0000AAEC ?doDialog@Shortcut@@UAEHXZ endp
.text$mn:0000AAEC
.text$mn:0000AAEC ; ---------------------------------------------------------------------------
.text$mn:0000AAED                 align 10h
.text$mn:0000AAED _text$mn        ends
.text$mn:0000AAED
.text$mn:0000AAF0 ; ===========================================================================
.text$mn:0000AAF0
.text$mn:0000AAF0 ; Segment type: Pure code
.text$mn:0000AAF0 ; Segment permissions: Read/Execute
.text$mn:0000AAF0 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAF0                 assume cs:_text$mn
.text$mn:0000AAF0                 ;org 0AAF0h
.text$mn:0000AAF0 ; COMDAT (pick any)
.text$mn:0000AAF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AAF0
.text$mn:0000AAF0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAF0
.text$mn:0000AAF0 ; Attributes: bp-based frame
.text$mn:0000AAF0
.text$mn:0000AAF0 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:0000AAF0                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:0000AAF0 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:0000AAF0                                         ; DATA XREF: .rdata:0000D9CCo
.text$mn:0000AAF0                                         ; .rdata:0000D9E8o ...
.text$mn:0000AAF0
.text$mn:0000AAF0 var_8           = dword ptr -8
.text$mn:0000AAF0 var_4           = dword ptr -4
.text$mn:0000AAF0 arg_0           = dword ptr  8
.text$mn:0000AAF0 arg_4           = dword ptr  0Ch
.text$mn:0000AAF0
.text$mn:0000AAF0                 push    ebp
.text$mn:0000AAF1                 mov     ebp, esp
.text$mn:0000AAF3                 sub     esp, 8
.text$mn:0000AAF6                 mov     [ebp+var_8], ecx
.text$mn:0000AAF9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000AAFC                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:0000AB01                 push    eax
.text$mn:0000AB02                 mov     ecx, [ebp+var_8]
.text$mn:0000AB05                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000AB0A                 movzx   eax, al
.text$mn:0000AB0D                 test    eax, eax
.text$mn:0000AB0F                 jz      short loc_AB27
.text$mn:0000AB11                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000AB14                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000AB19                 cmp     eax, [ebp+arg_4]
.text$mn:0000AB1C                 jnz     short loc_AB27
.text$mn:0000AB1E                 mov     [ebp+var_4], 1
.text$mn:0000AB25                 jmp     short loc_AB2E
.text$mn:0000AB27 ; ---------------------------------------------------------------------------
.text$mn:0000AB27
.text$mn:0000AB27 loc_AB27:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000AB27                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000AB27                 mov     [ebp+var_4], 0
.text$mn:0000AB2E
.text$mn:0000AB2E loc_AB2E:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:0000AB2E                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000AB31                 mov     esp, ebp
.text$mn:0000AB33                 pop     ebp
.text$mn:0000AB34                 retn    8
.text$mn:0000AB34 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000AB34
.text$mn:0000AB34 ; ---------------------------------------------------------------------------
.text$mn:0000AB37                 align 4
.text$mn:0000AB37 _text$mn        ends
.text$mn:0000AB37
.text$mn:0000AB38 ; ===========================================================================
.text$mn:0000AB38
.text$mn:0000AB38 ; Segment type: Pure code
.text$mn:0000AB38 ; Segment permissions: Read/Execute
.text$mn:0000AB38 _text$mn        segment para public 'CODE' use32
.text$mn:0000AB38                 assume cs:_text$mn
.text$mn:0000AB38                 ;org 0AB38h
.text$mn:0000AB38 ; COMDAT (pick any)
.text$mn:0000AB38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AB38
.text$mn:0000AB38 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB38
.text$mn:0000AB38 ; Attributes: bp-based frame
.text$mn:0000AB38
.text$mn:0000AB38 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000AB38                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000AB38 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000AB38                                         ; DATA XREF: .rdata:0000D9D0o
.text$mn:0000AB38                                         ; .rdata:0000D9ECo ...
.text$mn:0000AB38
.text$mn:0000AB38 var_C           = byte ptr -0Ch
.text$mn:0000AB38 var_4           = dword ptr -4
.text$mn:0000AB38 arg_0           = dword ptr  8
.text$mn:0000AB38 arg_4           = dword ptr  0Ch
.text$mn:0000AB38
.text$mn:0000AB38                 push    ebp
.text$mn:0000AB39                 mov     ebp, esp
.text$mn:0000AB3B                 sub     esp, 0Ch
.text$mn:0000AB3E                 mov     [ebp+var_4], ecx
.text$mn:0000AB41                 mov     eax, [ebp+arg_4]
.text$mn:0000AB44                 push    eax             ; std::error_condition *
.text$mn:0000AB45                 mov     ecx, [ebp+arg_0]
.text$mn:0000AB48                 push    ecx
.text$mn:0000AB49                 lea     edx, [ebp+var_C]
.text$mn:0000AB4C                 push    edx
.text$mn:0000AB4D                 mov     eax, [ebp+var_4]
.text$mn:0000AB50                 mov     edx, [eax]
.text$mn:0000AB52                 mov     ecx, [ebp+var_4]
.text$mn:0000AB55                 mov     eax, [edx+0Ch]
.text$mn:0000AB58                 call    eax
.text$mn:0000AB5A                 mov     ecx, eax
.text$mn:0000AB5C                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:0000AB61                 mov     esp, ebp
.text$mn:0000AB63                 pop     ebp
.text$mn:0000AB64                 retn    8
.text$mn:0000AB64 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000AB64
.text$mn:0000AB64 ; ---------------------------------------------------------------------------
.text$mn:0000AB67                 align 4
.text$mn:0000AB67 _text$mn        ends
.text$mn:0000AB67
.text$mn:0000AB68 ; ===========================================================================
.text$mn:0000AB68
.text$mn:0000AB68 ; Segment type: Pure code
.text$mn:0000AB68 ; Segment permissions: Read/Execute
.text$mn:0000AB68 _text$mn        segment para public 'CODE' use32
.text$mn:0000AB68                 assume cs:_text$mn
.text$mn:0000AB68                 ;org 0AB68h
.text$mn:0000AB68 ; COMDAT (pick any)
.text$mn:0000AB68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AB68
.text$mn:0000AB68 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB68
.text$mn:0000AB68 ; Attributes: bp-based frame
.text$mn:0000AB68
.text$mn:0000AB68 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000AB68                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000AB68 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000AB68                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000AB68
.text$mn:0000AB68 var_4           = dword ptr -4
.text$mn:0000AB68 arg_0           = dword ptr  8
.text$mn:0000AB68
.text$mn:0000AB68                 push    ebp
.text$mn:0000AB69                 mov     ebp, esp
.text$mn:0000AB6B                 push    ecx
.text$mn:0000AB6C                 mov     [ebp+var_4], ecx
.text$mn:0000AB6F                 mov     eax, [ebp+var_4]
.text$mn:0000AB72                 mov     ecx, [eax+14h]
.text$mn:0000AB75                 cmp     ecx, [ebp+arg_0]
.text$mn:0000AB78                 jnb     short loc_AB82
.text$mn:0000AB7A                 mov     ecx, [ebp+var_4]
.text$mn:0000AB7D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000AB82
.text$mn:0000AB82 loc_AB82:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000AB82                 mov     edx, [ebp+arg_0]
.text$mn:0000AB85                 push    edx
.text$mn:0000AB86                 mov     ecx, [ebp+var_4]
.text$mn:0000AB89                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000AB8E                 mov     eax, [ebp+var_4]
.text$mn:0000AB91                 mov     esp, ebp
.text$mn:0000AB93                 pop     ebp
.text$mn:0000AB94                 retn    4
.text$mn:0000AB94 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000AB94
.text$mn:0000AB94 ; ---------------------------------------------------------------------------
.text$mn:0000AB97                 align 4
.text$mn:0000AB97 _text$mn        ends
.text$mn:0000AB97
.text$mn:0000AB98 ; ===========================================================================
.text$mn:0000AB98
.text$mn:0000AB98 ; Segment type: Pure code
.text$mn:0000AB98 ; Segment permissions: Read/Execute
.text$mn:0000AB98 _text$mn        segment para public 'CODE' use32
.text$mn:0000AB98                 assume cs:_text$mn
.text$mn:0000AB98                 ;org 0AB98h
.text$mn:0000AB98 ; COMDAT (pick any)
.text$mn:0000AB98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AB98
.text$mn:0000AB98 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB98
.text$mn:0000AB98 ; Attributes: bp-based frame
.text$mn:0000AB98
.text$mn:0000AB98 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000AB98                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000AB98 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000AB98                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000AB98
.text$mn:0000AB98 var_C           = dword ptr -0Ch
.text$mn:0000AB98 Dst             = dword ptr -8
.text$mn:0000AB98 var_4           = dword ptr -4
.text$mn:0000AB98 arg_0           = dword ptr  8
.text$mn:0000AB98 arg_4           = dword ptr  0Ch
.text$mn:0000AB98
.text$mn:0000AB98                 push    ebp
.text$mn:0000AB99                 mov     ebp, esp
.text$mn:0000AB9B                 sub     esp, 0Ch
.text$mn:0000AB9E                 mov     [ebp+var_4], ecx
.text$mn:0000ABA1                 mov     eax, [ebp+var_4]
.text$mn:0000ABA4                 mov     ecx, [eax+14h]
.text$mn:0000ABA7                 cmp     ecx, [ebp+arg_0]
.text$mn:0000ABAA                 jnb     short loc_ABB4
.text$mn:0000ABAC                 mov     ecx, [ebp+var_4]
.text$mn:0000ABAF                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000ABB4
.text$mn:0000ABB4 loc_ABB4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:0000ABB4                 mov     edx, [ebp+var_4]
.text$mn:0000ABB7                 mov     eax, [edx+14h]
.text$mn:0000ABBA                 sub     eax, [ebp+arg_0]
.text$mn:0000ABBD                 cmp     eax, [ebp+arg_4]
.text$mn:0000ABC0                 ja      short loc_ABD0
.text$mn:0000ABC2                 mov     ecx, [ebp+arg_0]
.text$mn:0000ABC5                 push    ecx
.text$mn:0000ABC6                 mov     ecx, [ebp+var_4]
.text$mn:0000ABC9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000ABCE                 jmp     short loc_AC16
.text$mn:0000ABD0 ; ---------------------------------------------------------------------------
.text$mn:0000ABD0
.text$mn:0000ABD0 loc_ABD0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:0000ABD0                 cmp     [ebp+arg_4], 0
.text$mn:0000ABD4                 jbe     short loc_AC16
.text$mn:0000ABD6                 mov     ecx, [ebp+var_4]
.text$mn:0000ABD9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000ABDE                 add     eax, [ebp+arg_0]
.text$mn:0000ABE1                 mov     [ebp+Dst], eax
.text$mn:0000ABE4                 mov     edx, [ebp+var_4]
.text$mn:0000ABE7                 mov     eax, [edx+14h]
.text$mn:0000ABEA                 sub     eax, [ebp+arg_4]
.text$mn:0000ABED                 mov     [ebp+var_C], eax
.text$mn:0000ABF0                 mov     ecx, [ebp+var_C]
.text$mn:0000ABF3                 sub     ecx, [ebp+arg_0]
.text$mn:0000ABF6                 push    ecx             ; Size
.text$mn:0000ABF7                 mov     edx, [ebp+Dst]
.text$mn:0000ABFA                 add     edx, [ebp+arg_4]
.text$mn:0000ABFD                 push    edx             ; Src
.text$mn:0000ABFE                 mov     eax, [ebp+Dst]
.text$mn:0000AC01                 push    eax             ; Dst
.text$mn:0000AC02                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000AC07                 add     esp, 0Ch
.text$mn:0000AC0A                 mov     ecx, [ebp+var_C]
.text$mn:0000AC0D                 push    ecx
.text$mn:0000AC0E                 mov     ecx, [ebp+var_4]
.text$mn:0000AC11                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000AC16
.text$mn:0000AC16 loc_AC16:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000AC16                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000AC16                 mov     eax, [ebp+var_4]
.text$mn:0000AC19                 mov     esp, ebp
.text$mn:0000AC1B                 pop     ebp
.text$mn:0000AC1C                 retn    8
.text$mn:0000AC1C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000AC1C
.text$mn:0000AC1C ; ---------------------------------------------------------------------------
.text$mn:0000AC1F                 align 10h
.text$mn:0000AC1F _text$mn        ends
.text$mn:0000AC1F
.text$mn:0000AC20 ; ===========================================================================
.text$mn:0000AC20
.text$mn:0000AC20 ; Segment type: Pure code
.text$mn:0000AC20 ; Segment permissions: Read/Execute
.text$mn:0000AC20 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC20                 assume cs:_text$mn
.text$mn:0000AC20                 ;org 0AC20h
.text$mn:0000AC20 ; COMDAT (pick any)
.text$mn:0000AC20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AC20
.text$mn:0000AC20 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC20
.text$mn:0000AC20 ; Attributes: bp-based frame
.text$mn:0000AC20
.text$mn:0000AC20 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:0000AC20                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:0000AC20 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000AC20                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:0000AC20
.text$mn:0000AC20 var_4           = dword ptr -4
.text$mn:0000AC20 arg_0           = dword ptr  8
.text$mn:0000AC20
.text$mn:0000AC20                 push    ebp
.text$mn:0000AC21                 mov     ebp, esp
.text$mn:0000AC23                 push    ecx
.text$mn:0000AC24                 mov     [ebp+var_4], ecx
.text$mn:0000AC27                 mov     eax, [ebp+var_4]
.text$mn:0000AC2A                 mov     ecx, [eax+14h]
.text$mn:0000AC2D                 cmp     ecx, [ebp+arg_0]
.text$mn:0000AC30                 jnb     short loc_AC3A
.text$mn:0000AC32                 mov     ecx, [ebp+var_4]
.text$mn:0000AC35                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000AC3A
.text$mn:0000AC3A loc_AC3A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:0000AC3A                 mov     edx, [ebp+arg_0]
.text$mn:0000AC3D                 push    edx
.text$mn:0000AC3E                 mov     ecx, [ebp+var_4]
.text$mn:0000AC41                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000AC46                 mov     eax, [ebp+var_4]
.text$mn:0000AC49                 mov     esp, ebp
.text$mn:0000AC4B                 pop     ebp
.text$mn:0000AC4C                 retn    4
.text$mn:0000AC4C ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000AC4C
.text$mn:0000AC4C ; ---------------------------------------------------------------------------
.text$mn:0000AC4F                 align 10h
.text$mn:0000AC4F _text$mn        ends
.text$mn:0000AC4F
.text$mn:0000AC50 ; ===========================================================================
.text$mn:0000AC50
.text$mn:0000AC50 ; Segment type: Pure code
.text$mn:0000AC50 ; Segment permissions: Read/Execute
.text$mn:0000AC50 _text$mn        segment para public 'CODE' use32
.text$mn:0000AC50                 assume cs:_text$mn
.text$mn:0000AC50                 ;org 0AC50h
.text$mn:0000AC50 ; COMDAT (pick any)
.text$mn:0000AC50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AC50
.text$mn:0000AC50 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC50
.text$mn:0000AC50 ; Attributes: bp-based frame
.text$mn:0000AC50
.text$mn:0000AC50 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:0000AC50                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:0000AC50 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000AC50                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:0000AC50
.text$mn:0000AC50 var_C           = dword ptr -0Ch
.text$mn:0000AC50 Dst             = dword ptr -8
.text$mn:0000AC50 var_4           = dword ptr -4
.text$mn:0000AC50 arg_0           = dword ptr  8
.text$mn:0000AC50 arg_4           = dword ptr  0Ch
.text$mn:0000AC50
.text$mn:0000AC50                 push    ebp
.text$mn:0000AC51                 mov     ebp, esp
.text$mn:0000AC53                 sub     esp, 0Ch
.text$mn:0000AC56                 mov     [ebp+var_4], ecx
.text$mn:0000AC59                 mov     eax, [ebp+var_4]
.text$mn:0000AC5C                 mov     ecx, [eax+14h]
.text$mn:0000AC5F                 cmp     ecx, [ebp+arg_0]
.text$mn:0000AC62                 jnb     short loc_AC6C
.text$mn:0000AC64                 mov     ecx, [ebp+var_4]
.text$mn:0000AC67                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000AC6C
.text$mn:0000AC6C loc_AC6C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:0000AC6C                 mov     edx, [ebp+var_4]
.text$mn:0000AC6F                 mov     eax, [edx+14h]
.text$mn:0000AC72                 sub     eax, [ebp+arg_0]
.text$mn:0000AC75                 cmp     eax, [ebp+arg_4]
.text$mn:0000AC78                 ja      short loc_AC88
.text$mn:0000AC7A                 mov     ecx, [ebp+arg_0]
.text$mn:0000AC7D                 push    ecx
.text$mn:0000AC7E                 mov     ecx, [ebp+var_4]
.text$mn:0000AC81                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000AC86                 jmp     short loc_ACD4
.text$mn:0000AC88 ; ---------------------------------------------------------------------------
.text$mn:0000AC88
.text$mn:0000AC88 loc_AC88:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:0000AC88                 cmp     [ebp+arg_4], 0
.text$mn:0000AC8C                 jbe     short loc_ACD4
.text$mn:0000AC8E                 mov     ecx, [ebp+var_4]
.text$mn:0000AC91                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000AC96                 mov     edx, [ebp+arg_0]
.text$mn:0000AC99                 lea     eax, [eax+edx*2]
.text$mn:0000AC9C                 mov     [ebp+Dst], eax
.text$mn:0000AC9F                 mov     ecx, [ebp+var_4]
.text$mn:0000ACA2                 mov     edx, [ecx+14h]
.text$mn:0000ACA5                 sub     edx, [ebp+arg_4]
.text$mn:0000ACA8                 mov     [ebp+var_C], edx
.text$mn:0000ACAB                 mov     eax, [ebp+var_C]
.text$mn:0000ACAE                 sub     eax, [ebp+arg_0]
.text$mn:0000ACB1                 push    eax             ; int
.text$mn:0000ACB2                 mov     ecx, [ebp+arg_4]
.text$mn:0000ACB5                 mov     edx, [ebp+Dst]
.text$mn:0000ACB8                 lea     eax, [edx+ecx*2]
.text$mn:0000ACBB                 push    eax             ; Src
.text$mn:0000ACBC                 mov     ecx, [ebp+Dst]
.text$mn:0000ACBF                 push    ecx             ; Dst
.text$mn:0000ACC0                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000ACC5                 add     esp, 0Ch
.text$mn:0000ACC8                 mov     edx, [ebp+var_C]
.text$mn:0000ACCB                 push    edx
.text$mn:0000ACCC                 mov     ecx, [ebp+var_4]
.text$mn:0000ACCF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000ACD4
.text$mn:0000ACD4 loc_ACD4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:0000ACD4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:0000ACD4                 mov     eax, [ebp+var_4]
.text$mn:0000ACD7                 mov     esp, ebp
.text$mn:0000ACD9                 pop     ebp
.text$mn:0000ACDA                 retn    8
.text$mn:0000ACDA ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000ACDA
.text$mn:0000ACDA ; ---------------------------------------------------------------------------
.text$mn:0000ACDD                 align 10h
.text$mn:0000ACDD _text$mn        ends
.text$mn:0000ACDD
.text$mn:0000ACE0 ; ===========================================================================
.text$mn:0000ACE0
.text$mn:0000ACE0 ; Segment type: Pure code
.text$mn:0000ACE0 ; Segment permissions: Read/Execute
.text$mn:0000ACE0 _text$mn        segment para public 'CODE' use32
.text$mn:0000ACE0                 assume cs:_text$mn
.text$mn:0000ACE0                 ;org 0ACE0h
.text$mn:0000ACE0 ; COMDAT (pick any)
.text$mn:0000ACE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ACE0
.text$mn:0000ACE0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ACE0
.text$mn:0000ACE0 ; Attributes: bp-based frame
.text$mn:0000ACE0
.text$mn:0000ACE0 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:0000ACE0                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:0000ACE0 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000ACE0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:0000ACE0                 push    ebp
.text$mn:0000ACE1                 mov     ebp, esp
.text$mn:0000ACE3                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:0000ACE8                 pop     ebp
.text$mn:0000ACE9                 retn
.text$mn:0000ACE9 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000ACE9
.text$mn:0000ACE9 ; ---------------------------------------------------------------------------
.text$mn:0000ACEA                 align 4
.text$mn:0000ACEA _text$mn        ends
.text$mn:0000ACEA
.text$mn:0000ACEC ; ===========================================================================
.text$mn:0000ACEC
.text$mn:0000ACEC ; Segment type: Pure code
.text$mn:0000ACEC ; Segment permissions: Read/Execute
.text$mn:0000ACEC _text$mn        segment para public 'CODE' use32
.text$mn:0000ACEC                 assume cs:_text$mn
.text$mn:0000ACEC                 ;org 0ACECh
.text$mn:0000ACEC ; COMDAT (pick any)
.text$mn:0000ACEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ACEC
.text$mn:0000ACEC ; =============== S U B R O U T I N E =======================================
.text$mn:0000ACEC
.text$mn:0000ACEC ; Attributes: bp-based frame
.text$mn:0000ACEC
.text$mn:0000ACEC ; const wchar_t *__thiscall NppParameters::getAppDataNppDir(NppParameters *__hidden this)
.text$mn:0000ACEC                 public ?getAppDataNppDir@NppParameters@@QBEPB_WXZ
.text$mn:0000ACEC ?getAppDataNppDir@NppParameters@@QBEPB_WXZ proc near
.text$mn:0000ACEC                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+68Ep
.text$mn:0000ACEC
.text$mn:0000ACEC var_4           = dword ptr -4
.text$mn:0000ACEC
.text$mn:0000ACEC                 push    ebp
.text$mn:0000ACED                 mov     ebp, esp
.text$mn:0000ACEF                 push    ecx
.text$mn:0000ACF0                 mov     [ebp+var_4], ecx
.text$mn:0000ACF3                 mov     ecx, [ebp+var_4]
.text$mn:0000ACF6                 add     ecx, 1CB14h
.text$mn:0000ACFC                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000AD01                 mov     esp, ebp
.text$mn:0000AD03                 pop     ebp
.text$mn:0000AD04                 retn
.text$mn:0000AD04 ?getAppDataNppDir@NppParameters@@QBEPB_WXZ endp
.text$mn:0000AD04
.text$mn:0000AD04 ; ---------------------------------------------------------------------------
.text$mn:0000AD05                 align 4
.text$mn:0000AD05 _text$mn        ends
.text$mn:0000AD05
.text$mn:0000AD08 ; ===========================================================================
.text$mn:0000AD08
.text$mn:0000AD08 ; Segment type: Pure code
.text$mn:0000AD08 ; Segment permissions: Read/Execute
.text$mn:0000AD08 _text$mn        segment para public 'CODE' use32
.text$mn:0000AD08                 assume cs:_text$mn
.text$mn:0000AD08                 ;org 0AD08h
.text$mn:0000AD08 ; COMDAT (pick any)
.text$mn:0000AD08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AD08
.text$mn:0000AD08 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AD08
.text$mn:0000AD08 ; Attributes: bp-based frame
.text$mn:0000AD08
.text$mn:0000AD08 ; void __thiscall Window::getClientRect(Window *this, struct tagRECT *)
.text$mn:0000AD08                 public ?getClientRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:0000AD08 ?getClientRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:0000AD08                                         ; DATA XREF: .rdata:0000DAA8o
.text$mn:0000AD08                                         ; .rdata:0000DADCo ...
.text$mn:0000AD08
.text$mn:0000AD08 var_4           = dword ptr -4
.text$mn:0000AD08 lpRect          = dword ptr  8
.text$mn:0000AD08
.text$mn:0000AD08                 push    ebp
.text$mn:0000AD09                 mov     ebp, esp
.text$mn:0000AD0B                 push    ecx
.text$mn:0000AD0C                 mov     [ebp+var_4], ecx
.text$mn:0000AD0F                 mov     eax, [ebp+lpRect]
.text$mn:0000AD12                 push    eax             ; lpRect
.text$mn:0000AD13                 mov     ecx, [ebp+var_4]
.text$mn:0000AD16                 mov     edx, [ecx+0Ch]
.text$mn:0000AD19                 push    edx             ; hWnd
.text$mn:0000AD1A                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000AD20                 mov     esp, ebp
.text$mn:0000AD22                 pop     ebp
.text$mn:0000AD23                 retn    4
.text$mn:0000AD23 ?getClientRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:0000AD23
.text$mn:0000AD23 ; ---------------------------------------------------------------------------
.text$mn:0000AD26                 align 4
.text$mn:0000AD26 _text$mn        ends
.text$mn:0000AD26
.text$mn:0000AD28 ; ===========================================================================
.text$mn:0000AD28
.text$mn:0000AD28 ; Segment type: Pure code
.text$mn:0000AD28 ; Segment permissions: Read/Execute
.text$mn:0000AD28 _text$mn        segment para public 'CODE' use32
.text$mn:0000AD28                 assume cs:_text$mn
.text$mn:0000AD28                 ;org 0AD28h
.text$mn:0000AD28 ; COMDAT (pick any)
.text$mn:0000AD28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AD28
.text$mn:0000AD28 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AD28
.text$mn:0000AD28 ; Attributes: bp-based frame
.text$mn:0000AD28
.text$mn:0000AD28 ; public: class std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>> * __thiscall NppParameters::getExternalLexerDoc(void)
.text$mn:0000AD28                 public ?getExternalLexerDoc@NppParameters@@QAEPAV?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@XZ
.text$mn:0000AD28 ?getExternalLexerDoc@NppParameters@@QAEPAV?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@XZ proc near
.text$mn:0000AD28                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+96Ep
.text$mn:0000AD28
.text$mn:0000AD28 var_4           = dword ptr -4
.text$mn:0000AD28
.text$mn:0000AD28                 push    ebp
.text$mn:0000AD29                 mov     ebp, esp
.text$mn:0000AD2B                 push    ecx
.text$mn:0000AD2C                 mov     [ebp+var_4], ecx
.text$mn:0000AD2F                 mov     eax, [ebp+var_4]
.text$mn:0000AD32                 add     eax, 108h
.text$mn:0000AD37                 mov     esp, ebp
.text$mn:0000AD39                 pop     ebp
.text$mn:0000AD3A                 retn
.text$mn:0000AD3A ?getExternalLexerDoc@NppParameters@@QAEPAV?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@XZ endp
.text$mn:0000AD3A
.text$mn:0000AD3A ; ---------------------------------------------------------------------------
.text$mn:0000AD3B                 align 4
.text$mn:0000AD3B _text$mn        ends
.text$mn:0000AD3B
.text$mn:0000AD3C ; ===========================================================================
.text$mn:0000AD3C
.text$mn:0000AD3C ; Segment type: Pure code
.text$mn:0000AD3C ; Segment permissions: Read/Execute
.text$mn:0000AD3C _text$mn        segment para public 'CODE' use32
.text$mn:0000AD3C                 assume cs:_text$mn
.text$mn:0000AD3C                 ;org 0AD3Ch
.text$mn:0000AD3C ; COMDAT (pick any)
.text$mn:0000AD3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AD3C
.text$mn:0000AD3C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AD3C
.text$mn:0000AD3C ; Attributes: bp-based frame
.text$mn:0000AD3C
.text$mn:0000AD3C ; int __thiscall Window::getHeight(Window *__hidden this)
.text$mn:0000AD3C                 public ?getHeight@Window@@UBEHXZ
.text$mn:0000AD3C ?getHeight@Window@@UBEHXZ proc near     ; DATA XREF: .rdata:0000DAB4o
.text$mn:0000AD3C                                         ; .rdata:0000DAE8o ...
.text$mn:0000AD3C
.text$mn:0000AD3C var_18          = dword ptr -18h
.text$mn:0000AD3C Rect            = tagRECT ptr -14h
.text$mn:0000AD3C var_4           = dword ptr -4
.text$mn:0000AD3C
.text$mn:0000AD3C                 push    ebp
.text$mn:0000AD3D                 mov     ebp, esp
.text$mn:0000AD3F                 sub     esp, 18h
.text$mn:0000AD42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AD47                 xor     eax, ebp
.text$mn:0000AD49                 mov     [ebp+var_4], eax
.text$mn:0000AD4C                 mov     [ebp+var_18], ecx
.text$mn:0000AD4F                 lea     eax, [ebp+Rect]
.text$mn:0000AD52                 push    eax             ; lpRect
.text$mn:0000AD53                 mov     ecx, [ebp+var_18]
.text$mn:0000AD56                 mov     edx, [ecx+0Ch]
.text$mn:0000AD59                 push    edx             ; hWnd
.text$mn:0000AD5A                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000AD60                 mov     eax, [ebp+var_18]
.text$mn:0000AD63                 mov     ecx, [eax+0Ch]
.text$mn:0000AD66                 push    ecx             ; hWnd
.text$mn:0000AD67                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:0000AD6D                 cmp     eax, 1
.text$mn:0000AD70                 jnz     short loc_AD7A
.text$mn:0000AD72                 mov     eax, [ebp+Rect.bottom]
.text$mn:0000AD75                 sub     eax, [ebp+Rect.top]
.text$mn:0000AD78                 jmp     short loc_AD7C
.text$mn:0000AD7A ; ---------------------------------------------------------------------------
.text$mn:0000AD7A
.text$mn:0000AD7A loc_AD7A:                               ; CODE XREF: Window::getHeight(void)+34j
.text$mn:0000AD7A                 xor     eax, eax
.text$mn:0000AD7C
.text$mn:0000AD7C loc_AD7C:                               ; CODE XREF: Window::getHeight(void)+3Cj
.text$mn:0000AD7C                 mov     ecx, [ebp+var_4]
.text$mn:0000AD7F                 xor     ecx, ebp
.text$mn:0000AD81                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000AD86                 mov     esp, ebp
.text$mn:0000AD88                 pop     ebp
.text$mn:0000AD89                 retn
.text$mn:0000AD89 ?getHeight@Window@@UBEHXZ endp
.text$mn:0000AD89
.text$mn:0000AD89 ; ---------------------------------------------------------------------------
.text$mn:0000AD8A                 align 4
.text$mn:0000AD8A _text$mn        ends
.text$mn:0000AD8A
.text$mn:0000AD8C ; ===========================================================================
.text$mn:0000AD8C
.text$mn:0000AD8C ; Segment type: Pure code
.text$mn:0000AD8C ; Segment permissions: Read/Execute
.text$mn:0000AD8C _text$mn        segment para public 'CODE' use32
.text$mn:0000AD8C                 assume cs:_text$mn
.text$mn:0000AD8C                 ;org 0AD8Ch
.text$mn:0000AD8C ; COMDAT (pick any)
.text$mn:0000AD8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AD8C
.text$mn:0000AD8C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AD8C
.text$mn:0000AD8C ; Attributes: bp-based frame
.text$mn:0000AD8C
.text$mn:0000AD8C ; unsigned __int32 __thiscall PluginCmdShortcut::getID(PluginCmdShortcut *__hidden this)
.text$mn:0000AD8C                 public ?getID@PluginCmdShortcut@@QBEKXZ
.text$mn:0000AD8C ?getID@PluginCmdShortcut@@QBEKXZ proc near
.text$mn:0000AD8C                                         ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+5Ep
.text$mn:0000AD8C
.text$mn:0000AD8C var_4           = dword ptr -4
.text$mn:0000AD8C
.text$mn:0000AD8C                 push    ebp
.text$mn:0000AD8D                 mov     ebp, esp
.text$mn:0000AD8F                 push    ecx
.text$mn:0000AD90                 mov     [ebp+var_4], ecx
.text$mn:0000AD93                 mov     eax, [ebp+var_4]
.text$mn:0000AD96                 mov     eax, [eax+12Ch]
.text$mn:0000AD9C                 mov     esp, ebp
.text$mn:0000AD9E                 pop     ebp
.text$mn:0000AD9F                 retn
.text$mn:0000AD9F ?getID@PluginCmdShortcut@@QBEKXZ endp
.text$mn:0000AD9F
.text$mn:0000AD9F _text$mn        ends
.text$mn:0000AD9F
.text$mn:0000ADA0 ; ===========================================================================
.text$mn:0000ADA0
.text$mn:0000ADA0 ; Segment type: Pure code
.text$mn:0000ADA0 ; Segment permissions: Read/Execute
.text$mn:0000ADA0 _text$mn        segment para public 'CODE' use32
.text$mn:0000ADA0                 assume cs:_text$mn
.text$mn:0000ADA0                 ;org 0ADA0h
.text$mn:0000ADA0 ; COMDAT (pick any)
.text$mn:0000ADA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADA0
.text$mn:0000ADA0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADA0
.text$mn:0000ADA0 ; Attributes: bp-based frame
.text$mn:0000ADA0
.text$mn:0000ADA0 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:0000ADA0                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:0000ADA0 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:0000ADA0                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+48Ep
.text$mn:0000ADA0                                         ; PluginsManager::loadPlugins(wchar_t const *)+71p ...
.text$mn:0000ADA0                 push    ebp
.text$mn:0000ADA1                 mov     ebp, esp
.text$mn:0000ADA3                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:0000ADA8                 pop     ebp
.text$mn:0000ADA9                 retn
.text$mn:0000ADA9 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:0000ADA9
.text$mn:0000ADA9 ; ---------------------------------------------------------------------------
.text$mn:0000ADAA                 align 4
.text$mn:0000ADAA _text$mn        ends
.text$mn:0000ADAA
.text$mn:0000ADAC ; ===========================================================================
.text$mn:0000ADAC
.text$mn:0000ADAC ; Segment type: Pure code
.text$mn:0000ADAC ; Segment permissions: Read/Execute
.text$mn:0000ADAC _text$mn        segment para public 'CODE' use32
.text$mn:0000ADAC                 assume cs:_text$mn
.text$mn:0000ADAC                 ;org 0ADACh
.text$mn:0000ADAC ; COMDAT (pick any)
.text$mn:0000ADAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADAC
.text$mn:0000ADAC ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADAC
.text$mn:0000ADAC ; Attributes: bp-based frame
.text$mn:0000ADAC
.text$mn:0000ADAC ; struct WcharMbcsConvertor *__cdecl WcharMbcsConvertor::getInstance()
.text$mn:0000ADAC                 public ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ
.text$mn:0000ADAC ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ proc near
.text$mn:0000ADAC                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+499p
.text$mn:0000ADAC                 push    ebp
.text$mn:0000ADAD                 mov     ebp, esp
.text$mn:0000ADAF                 mov     eax, dword ptr ds:?_pSelf@WcharMbcsConvertor@@1PAV1@A ; WcharMbcsConvertor * WcharMbcsConvertor::_pSelf
.text$mn:0000ADB4                 pop     ebp
.text$mn:0000ADB5                 retn
.text$mn:0000ADB5 ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ endp
.text$mn:0000ADB5
.text$mn:0000ADB5 ; ---------------------------------------------------------------------------
.text$mn:0000ADB6                 align 4
.text$mn:0000ADB6 _text$mn        ends
.text$mn:0000ADB6
.text$mn:0000ADB8 ; ===========================================================================
.text$mn:0000ADB8
.text$mn:0000ADB8 ; Segment type: Pure code
.text$mn:0000ADB8 ; Segment permissions: Read/Execute
.text$mn:0000ADB8 _text$mn        segment para public 'CODE' use32
.text$mn:0000ADB8                 assume cs:_text$mn
.text$mn:0000ADB8                 ;org 0ADB8h
.text$mn:0000ADB8 ; COMDAT (pick any)
.text$mn:0000ADB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADB8
.text$mn:0000ADB8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADB8
.text$mn:0000ADB8 ; Attributes: bp-based frame
.text$mn:0000ADB8
.text$mn:0000ADB8 ; const struct KeyCombo *__thiscall Shortcut::getKeyCombo(Shortcut *__hidden this)
.text$mn:0000ADB8                 public ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ
.text$mn:0000ADB8 ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ proc near
.text$mn:0000ADB8                                         ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+76p
.text$mn:0000ADB8
.text$mn:0000ADB8 var_4           = dword ptr -4
.text$mn:0000ADB8
.text$mn:0000ADB8                 push    ebp
.text$mn:0000ADB9                 mov     ebp, esp
.text$mn:0000ADBB                 push    ecx
.text$mn:0000ADBC                 mov     [ebp+var_4], ecx
.text$mn:0000ADBF                 mov     eax, [ebp+var_4]
.text$mn:0000ADC2                 add     eax, 20h ; ' '
.text$mn:0000ADC5                 mov     esp, ebp
.text$mn:0000ADC7                 pop     ebp
.text$mn:0000ADC8                 retn
.text$mn:0000ADC8 ?getKeyCombo@Shortcut@@QBEABUKeyCombo@@XZ endp
.text$mn:0000ADC8
.text$mn:0000ADC8 ; ---------------------------------------------------------------------------
.text$mn:0000ADC9                 align 4
.text$mn:0000ADC9 _text$mn        ends
.text$mn:0000ADC9
.text$mn:0000ADCC ; ===========================================================================
.text$mn:0000ADCC
.text$mn:0000ADCC ; Segment type: Pure code
.text$mn:0000ADCC ; Segment permissions: Read/Execute
.text$mn:0000ADCC _text$mn        segment para public 'CODE' use32
.text$mn:0000ADCC                 assume cs:_text$mn
.text$mn:0000ADCC                 ;org 0ADCCh
.text$mn:0000ADCC ; COMDAT (pick any)
.text$mn:0000ADCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADCC
.text$mn:0000ADCC ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADCC
.text$mn:0000ADCC ; Attributes: bp-based frame
.text$mn:0000ADCC
.text$mn:0000ADCC ; const wchar_t *__thiscall Shortcut::getMenuName(Shortcut *__hidden this)
.text$mn:0000ADCC                 public ?getMenuName@Shortcut@@QBEPB_WXZ
.text$mn:0000ADCC ?getMenuName@Shortcut@@QBEPB_WXZ proc near
.text$mn:0000ADCC                                         ; CODE XREF: Shortcut::Shortcut(Shortcut const &)+41p
.text$mn:0000ADCC
.text$mn:0000ADCC var_4           = dword ptr -4
.text$mn:0000ADCC
.text$mn:0000ADCC                 push    ebp
.text$mn:0000ADCD                 mov     ebp, esp
.text$mn:0000ADCF                 push    ecx
.text$mn:0000ADD0                 mov     [ebp+var_4], ecx
.text$mn:0000ADD3                 mov     eax, [ebp+var_4]
.text$mn:0000ADD6                 add     eax, 0A6h ; ''
.text$mn:0000ADDB                 mov     esp, ebp
.text$mn:0000ADDD                 pop     ebp
.text$mn:0000ADDE                 retn
.text$mn:0000ADDE ?getMenuName@Shortcut@@QBEPB_WXZ endp
.text$mn:0000ADDE
.text$mn:0000ADDE ; ---------------------------------------------------------------------------
.text$mn:0000ADDF                 align 10h
.text$mn:0000ADDF _text$mn        ends
.text$mn:0000ADDF
.text$mn:0000ADE0 ; ===========================================================================
.text$mn:0000ADE0
.text$mn:0000ADE0 ; Segment type: Pure code
.text$mn:0000ADE0 ; Segment permissions: Read/Execute
.text$mn:0000ADE0 _text$mn        segment para public 'CODE' use32
.text$mn:0000ADE0                 assume cs:_text$mn
.text$mn:0000ADE0                 ;org 0ADE0h
.text$mn:0000ADE0 ; COMDAT (pick any)
.text$mn:0000ADE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADE0
.text$mn:0000ADE0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADE0
.text$mn:0000ADE0 ; Attributes: bp-based frame
.text$mn:0000ADE0
.text$mn:0000ADE0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall NppParameters::getNppPath(void)const
.text$mn:0000ADE0                 public ?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.text$mn:0000ADE0 ?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ proc near
.text$mn:0000ADE0                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+5CCp
.text$mn:0000ADE0                                         ; PluginsManager::loadPlugins(wchar_t const *)+86p
.text$mn:0000ADE0
.text$mn:0000ADE0 var_14          = dword ptr -14h
.text$mn:0000ADE0 var_10          = dword ptr -10h
.text$mn:0000ADE0 var_C           = dword ptr -0Ch
.text$mn:0000ADE0 var_4           = dword ptr -4
.text$mn:0000ADE0 arg_0           = dword ptr  8
.text$mn:0000ADE0
.text$mn:0000ADE0                 push    ebp
.text$mn:0000ADE1                 mov     ebp, esp
.text$mn:0000ADE3                 push    0FFFFFFFFh
.text$mn:0000ADE5                 push    offset __ehhandler$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.text$mn:0000ADEA                 mov     eax, large fs:0
.text$mn:0000ADF0                 push    eax
.text$mn:0000ADF1                 sub     esp, 8
.text$mn:0000ADF4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000ADF9                 xor     eax, ebp
.text$mn:0000ADFB                 push    eax
.text$mn:0000ADFC                 lea     eax, [ebp+var_C]
.text$mn:0000ADFF                 mov     large fs:0, eax
.text$mn:0000AE05                 mov     [ebp+var_14], ecx
.text$mn:0000AE08                 mov     [ebp+var_10], 0
.text$mn:0000AE0F                 mov     eax, [ebp+var_14]
.text$mn:0000AE12                 add     eax, 1CAC0h
.text$mn:0000AE17                 push    eax
.text$mn:0000AE18                 mov     ecx, [ebp+arg_0]
.text$mn:0000AE1B                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000AE20                 mov     [ebp+var_4], 0
.text$mn:0000AE27                 mov     ecx, [ebp+var_10]
.text$mn:0000AE2A                 or      ecx, 1
.text$mn:0000AE2D                 mov     [ebp+var_10], ecx
.text$mn:0000AE30                 mov     eax, [ebp+arg_0]
.text$mn:0000AE33                 mov     ecx, [ebp+var_C]
.text$mn:0000AE36                 mov     large fs:0, ecx
.text$mn:0000AE3D                 pop     ecx
.text$mn:0000AE3E                 mov     esp, ebp
.text$mn:0000AE40                 pop     ebp
.text$mn:0000AE41                 retn    4
.text$mn:0000AE41 ?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ endp
.text$mn:0000AE41
.text$mn:0000AE41 _text$mn        ends
.text$mn:0000AE41
.text$x:0000AE44 ; ===========================================================================
.text$x:0000AE44
.text$x:0000AE44 ; Segment type: Pure code
.text$x:0000AE44 ; Segment permissions: Read/Execute
.text$x:0000AE44 _text$x         segment para public 'CODE' use32
.text$x:0000AE44                 assume cs:_text$x
.text$x:0000AE44                 ;org 0AE44h
.text$x:0000AE44 ; COMDAT (pick associative to section at ADE0)
.text$x:0000AE44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000AE44
.text$x:0000AE44 ; =============== S U B R O U T I N E =======================================
.text$x:0000AE44
.text$x:0000AE44
.text$x:0000AE44 __unwindfunclet$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0 proc near
.text$x:0000AE44                                         ; DATA XREF: .xdata$x:0000CE34o
.text$x:0000AE44                 mov     eax, [ebp-10h]
.text$x:0000AE47                 and     eax, 1
.text$x:0000AE4A                 jz      $LN4
.text$x:0000AE50                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000AE54                 mov     ecx, [ebp+8]
.text$x:0000AE57                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000AE5C ; ---------------------------------------------------------------------------
.text$x:0000AE5C
.text$x:0000AE5C $LN4:                                   ; CODE XREF: __unwindfunclet$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0+6j
.text$x:0000AE5C                 retn
.text$x:0000AE5C __unwindfunclet$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0 endp
.text$x:0000AE5C
.text$x:0000AE5D
.text$x:0000AE5D ; =============== S U B R O U T I N E =======================================
.text$x:0000AE5D
.text$x:0000AE5D
.text$x:0000AE5D __ehhandler$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ proc near
.text$x:0000AE5D                                         ; DATA XREF: NppParameters::getNppPath(void)+5o
.text$x:0000AE5D
.text$x:0000AE5D arg_4           = dword ptr  8
.text$x:0000AE5D
.text$x:0000AE5D                 mov     edx, [esp+arg_4]
.text$x:0000AE61                 lea     eax, [edx+0Ch]
.text$x:0000AE64                 mov     ecx, [edx-0Ch]
.text$x:0000AE67                 xor     ecx, eax
.text$x:0000AE69                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AE6E                 mov     eax, offset __ehfuncinfo$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.text$x:0000AE73                 jmp     ___CxxFrameHandler3
.text$x:0000AE73 __ehhandler$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ endp
.text$x:0000AE73
.text$x:0000AE73 _text$x         ends
.text$x:0000AE73
.text$mn:0000AE78 ; ===========================================================================
.text$mn:0000AE78
.text$mn:0000AE78 ; Segment type: Pure code
.text$mn:0000AE78 ; Segment permissions: Read/Execute
.text$mn:0000AE78 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE78                 assume cs:_text$mn
.text$mn:0000AE78                 ;org 0AE78h
.text$mn:0000AE78 ; COMDAT (pick any)
.text$mn:0000AE78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AE78
.text$mn:0000AE78 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE78
.text$mn:0000AE78 ; Attributes: bp-based frame
.text$mn:0000AE78
.text$mn:0000AE78 ; public: class std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>> & __thiscall NppParameters::getPluginCommandList(void)
.text$mn:0000AE78                 public ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ
.text$mn:0000AE78 ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ proc near
.text$mn:0000AE78                                         ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+39p
.text$mn:0000AE78                                         ; PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+23p
.text$mn:0000AE78
.text$mn:0000AE78 var_4           = dword ptr -4
.text$mn:0000AE78
.text$mn:0000AE78                 push    ebp
.text$mn:0000AE79                 mov     ebp, esp
.text$mn:0000AE7B                 push    ecx
.text$mn:0000AE7C                 mov     [ebp+var_4], ecx
.text$mn:0000AE7F                 mov     eax, [ebp+var_4]
.text$mn:0000AE82                 add     eax, 1C944h
.text$mn:0000AE87                 mov     esp, ebp
.text$mn:0000AE89                 pop     ebp
.text$mn:0000AE8A                 retn
.text$mn:0000AE8A ?getPluginCommandList@NppParameters@@QAEAAV?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@XZ endp
.text$mn:0000AE8A
.text$mn:0000AE8A ; ---------------------------------------------------------------------------
.text$mn:0000AE8B                 align 4
.text$mn:0000AE8B _text$mn        ends
.text$mn:0000AE8B
.text$mn:0000AE8C ; ===========================================================================
.text$mn:0000AE8C
.text$mn:0000AE8C ; Segment type: Pure code
.text$mn:0000AE8C ; Segment permissions: Read/Execute
.text$mn:0000AE8C _text$mn        segment para public 'CODE' use32
.text$mn:0000AE8C                 assume cs:_text$mn
.text$mn:0000AE8C                 ;org 0AE8Ch
.text$mn:0000AE8C ; COMDAT (pick any)
.text$mn:0000AE8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AE8C
.text$mn:0000AE8C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE8C
.text$mn:0000AE8C ; Attributes: bp-based frame
.text$mn:0000AE8C
.text$mn:0000AE8C ; struct PluginList *__thiscall NppParameters::getPluginList(NppParameters *__hidden this)
.text$mn:0000AE8C                 public ?getPluginList@NppParameters@@QAEAAVPluginList@@XZ
.text$mn:0000AE8C ?getPluginList@NppParameters@@QAEAAVPluginList@@XZ proc near
.text$mn:0000AE8C                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+46Ap
.text$mn:0000AE8C
.text$mn:0000AE8C var_4           = dword ptr -4
.text$mn:0000AE8C
.text$mn:0000AE8C                 push    ebp
.text$mn:0000AE8D                 mov     ebp, esp
.text$mn:0000AE8F                 push    ecx
.text$mn:0000AE90                 mov     [ebp+var_4], ecx
.text$mn:0000AE93                 mov     eax, [ebp+var_4]
.text$mn:0000AE96                 add     eax, 1C8E4h
.text$mn:0000AE9B                 mov     esp, ebp
.text$mn:0000AE9D                 pop     ebp
.text$mn:0000AE9E                 retn
.text$mn:0000AE9E ?getPluginList@NppParameters@@QAEAAVPluginList@@XZ endp
.text$mn:0000AE9E
.text$mn:0000AE9E ; ---------------------------------------------------------------------------
.text$mn:0000AE9F                 align 10h
.text$mn:0000AE9F _text$mn        ends
.text$mn:0000AE9F
.text$mn:0000AEA0 ; ===========================================================================
.text$mn:0000AEA0
.text$mn:0000AEA0 ; Segment type: Pure code
.text$mn:0000AEA0 ; Segment permissions: Read/Execute
.text$mn:0000AEA0 _text$mn        segment para public 'CODE' use32
.text$mn:0000AEA0                 assume cs:_text$mn
.text$mn:0000AEA0                 ;org 0AEA0h
.text$mn:0000AEA0 ; COMDAT (pick any)
.text$mn:0000AEA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AEA0
.text$mn:0000AEA0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AEA0
.text$mn:0000AEA0 ; Attributes: bp-based frame
.text$mn:0000AEA0
.text$mn:0000AEA0 ; int __thiscall Window::getWidth(Window *__hidden this)
.text$mn:0000AEA0                 public ?getWidth@Window@@UBEHXZ
.text$mn:0000AEA0 ?getWidth@Window@@UBEHXZ proc near      ; DATA XREF: .rdata:0000DAB0o
.text$mn:0000AEA0                                         ; .rdata:0000DAE4o ...
.text$mn:0000AEA0
.text$mn:0000AEA0 var_18          = dword ptr -18h
.text$mn:0000AEA0 Rect            = tagRECT ptr -14h
.text$mn:0000AEA0 var_4           = dword ptr -4
.text$mn:0000AEA0
.text$mn:0000AEA0                 push    ebp
.text$mn:0000AEA1                 mov     ebp, esp
.text$mn:0000AEA3                 sub     esp, 18h
.text$mn:0000AEA6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AEAB                 xor     eax, ebp
.text$mn:0000AEAD                 mov     [ebp+var_4], eax
.text$mn:0000AEB0                 mov     [ebp+var_18], ecx
.text$mn:0000AEB3                 lea     eax, [ebp+Rect]
.text$mn:0000AEB6                 push    eax             ; lpRect
.text$mn:0000AEB7                 mov     ecx, [ebp+var_18]
.text$mn:0000AEBA                 mov     edx, [ecx+0Ch]
.text$mn:0000AEBD                 push    edx             ; hWnd
.text$mn:0000AEBE                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:0000AEC4                 mov     eax, [ebp+Rect.right]
.text$mn:0000AEC7                 sub     eax, [ebp+Rect.left]
.text$mn:0000AECA                 mov     ecx, [ebp+var_4]
.text$mn:0000AECD                 xor     ecx, ebp
.text$mn:0000AECF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000AED4                 mov     esp, ebp
.text$mn:0000AED6                 pop     ebp
.text$mn:0000AED7                 retn
.text$mn:0000AED7 ?getWidth@Window@@UBEHXZ endp
.text$mn:0000AED7
.text$mn:0000AED7 _text$mn        ends
.text$mn:0000AED7
.text$mn:0000AED8 ; ===========================================================================
.text$mn:0000AED8
.text$mn:0000AED8 ; Segment type: Pure code
.text$mn:0000AED8 ; Segment permissions: Read/Execute
.text$mn:0000AED8 _text$mn        segment para public 'CODE' use32
.text$mn:0000AED8                 assume cs:_text$mn
.text$mn:0000AED8                 ;org 0AED8h
.text$mn:0000AED8 ; COMDAT (pick any)
.text$mn:0000AED8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AED8
.text$mn:0000AED8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AED8
.text$mn:0000AED8 ; Attributes: bp-based frame
.text$mn:0000AED8
.text$mn:0000AED8 ; void __thiscall Window::getWindowRect(Window *this, struct tagRECT *)
.text$mn:0000AED8                 public ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:0000AED8 ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:0000AED8                                         ; DATA XREF: .rdata:0000DAACo
.text$mn:0000AED8                                         ; .rdata:0000DAE0o ...
.text$mn:0000AED8
.text$mn:0000AED8 var_4           = dword ptr -4
.text$mn:0000AED8 lpRect          = dword ptr  8
.text$mn:0000AED8
.text$mn:0000AED8                 push    ebp
.text$mn:0000AED9                 mov     ebp, esp
.text$mn:0000AEDB                 push    ecx
.text$mn:0000AEDC                 mov     [ebp+var_4], ecx
.text$mn:0000AEDF                 mov     eax, [ebp+lpRect]
.text$mn:0000AEE2                 push    eax             ; lpRect
.text$mn:0000AEE3                 mov     ecx, [ebp+var_4]
.text$mn:0000AEE6                 mov     edx, [ecx+0Ch]
.text$mn:0000AEE9                 push    edx             ; hWnd
.text$mn:0000AEEA                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:0000AEF0                 mov     esp, ebp
.text$mn:0000AEF2                 pop     ebp
.text$mn:0000AEF3                 retn    4
.text$mn:0000AEF3 ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:0000AEF3
.text$mn:0000AEF3 ; ---------------------------------------------------------------------------
.text$mn:0000AEF6                 align 4
.text$mn:0000AEF6 _text$mn        ends
.text$mn:0000AEF6
.text$mn:0000AEF8 ; ===========================================================================
.text$mn:0000AEF8
.text$mn:0000AEF8 ; Segment type: Pure code
.text$mn:0000AEF8 ; Segment permissions: Read/Execute
.text$mn:0000AEF8 _text$mn        segment para public 'CODE' use32
.text$mn:0000AEF8                 assume cs:_text$mn
.text$mn:0000AEF8                 ;org 0AEF8h
.text$mn:0000AEF8 ; COMDAT (pick any)
.text$mn:0000AEF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AEF8
.text$mn:0000AEF8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AEF8
.text$mn:0000AEF8 ; Attributes: bp-based frame
.text$mn:0000AEF8
.text$mn:0000AEF8 ; bool __thiscall PluginsManager::hasPlugins(PluginsManager *__hidden this)
.text$mn:0000AEF8                 public ?hasPlugins@PluginsManager@@QAE_NXZ
.text$mn:0000AEF8 ?hasPlugins@PluginsManager@@QAE_NXZ proc near
.text$mn:0000AEF8                                         ; CODE XREF: PluginsManager::setMenu(HMENU__ *,wchar_t const *)+Cp
.text$mn:0000AEF8
.text$mn:0000AEF8 var_8           = dword ptr -8
.text$mn:0000AEF8 var_4           = dword ptr -4
.text$mn:0000AEF8
.text$mn:0000AEF8                 push    ebp
.text$mn:0000AEF9                 mov     ebp, esp
.text$mn:0000AEFB                 sub     esp, 8
.text$mn:0000AEFE                 mov     [ebp+var_8], ecx
.text$mn:0000AF01                 mov     ecx, [ebp+var_8]
.text$mn:0000AF04                 add     ecx, 10h
.text$mn:0000AF07                 call    ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::size(void)
.text$mn:0000AF0C                 test    eax, eax
.text$mn:0000AF0E                 jz      short loc_AF19
.text$mn:0000AF10                 mov     [ebp+var_4], 1
.text$mn:0000AF17                 jmp     short loc_AF20
.text$mn:0000AF19 ; ---------------------------------------------------------------------------
.text$mn:0000AF19
.text$mn:0000AF19 loc_AF19:                               ; CODE XREF: PluginsManager::hasPlugins(void)+16j
.text$mn:0000AF19                 mov     [ebp+var_4], 0
.text$mn:0000AF20
.text$mn:0000AF20 loc_AF20:                               ; CODE XREF: PluginsManager::hasPlugins(void)+1Fj
.text$mn:0000AF20                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000AF23                 mov     esp, ebp
.text$mn:0000AF25                 pop     ebp
.text$mn:0000AF26                 retn
.text$mn:0000AF26 ?hasPlugins@PluginsManager@@QAE_NXZ endp
.text$mn:0000AF26
.text$mn:0000AF26 ; ---------------------------------------------------------------------------
.text$mn:0000AF27                 align 4
.text$mn:0000AF27 _text$mn        ends
.text$mn:0000AF27
.text$mn:0000AF28 ; ===========================================================================
.text$mn:0000AF28
.text$mn:0000AF28 ; Segment type: Pure code
.text$mn:0000AF28 ; Segment permissions: Read/Execute
.text$mn:0000AF28 _text$mn        segment para public 'CODE' use32
.text$mn:0000AF28                 assume cs:_text$mn
.text$mn:0000AF28                 ;org 0AF28h
.text$mn:0000AF28 ; COMDAT (pick any)
.text$mn:0000AF28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AF28
.text$mn:0000AF28 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AF28
.text$mn:0000AF28 ; Attributes: bp-based frame
.text$mn:0000AF28
.text$mn:0000AF28 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:0000AF28                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:0000AF28 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:0000AF28                                         ; DATA XREF: .rdata:0000DA90o
.text$mn:0000AF28                                         ; .rdata:0000DAC4o ...
.text$mn:0000AF28
.text$mn:0000AF28 var_4           = dword ptr -4
.text$mn:0000AF28 arg_0           = dword ptr  8
.text$mn:0000AF28 arg_4           = dword ptr  0Ch
.text$mn:0000AF28
.text$mn:0000AF28                 push    ebp
.text$mn:0000AF29                 mov     ebp, esp
.text$mn:0000AF2B                 push    ecx
.text$mn:0000AF2C                 mov     [ebp+var_4], ecx
.text$mn:0000AF2F                 mov     eax, [ebp+var_4]
.text$mn:0000AF32                 mov     ecx, [ebp+arg_0]
.text$mn:0000AF35                 mov     [eax+4], ecx
.text$mn:0000AF38                 mov     edx, [ebp+var_4]
.text$mn:0000AF3B                 mov     eax, [ebp+arg_4]
.text$mn:0000AF3E                 mov     [edx+8], eax
.text$mn:0000AF41                 mov     esp, ebp
.text$mn:0000AF43                 pop     ebp
.text$mn:0000AF44                 retn    8
.text$mn:0000AF44 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:0000AF44
.text$mn:0000AF44 ; ---------------------------------------------------------------------------
.text$mn:0000AF47                 align 4
.text$mn:0000AF47 _text$mn        ends
.text$mn:0000AF47
.text$mn:0000AF48 ; ===========================================================================
.text$mn:0000AF48
.text$mn:0000AF48 ; Segment type: Pure code
.text$mn:0000AF48 ; Segment permissions: Read/Execute
.text$mn:0000AF48 _text$mn        segment para public 'CODE' use32
.text$mn:0000AF48                 assume cs:_text$mn
.text$mn:0000AF48                 ;org 0AF48h
.text$mn:0000AF48 ; COMDAT (pick any)
.text$mn:0000AF48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AF48
.text$mn:0000AF48 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AF48
.text$mn:0000AF48 ; Attributes: bp-based frame
.text$mn:0000AF48
.text$mn:0000AF48 ; bool __thiscall StaticDialog::isCreated(StaticDialog *__hidden this)
.text$mn:0000AF48                 public ?isCreated@StaticDialog@@UBE_NXZ
.text$mn:0000AF48 ?isCreated@StaticDialog@@UBE_NXZ proc near
.text$mn:0000AF48                                         ; CODE XREF: StaticDialog::~StaticDialog(void)+39p
.text$mn:0000AF48                                         ; DATA XREF: .rdata:0000DAF4o ...
.text$mn:0000AF48
.text$mn:0000AF48 var_8           = dword ptr -8
.text$mn:0000AF48 var_4           = dword ptr -4
.text$mn:0000AF48
.text$mn:0000AF48                 push    ebp
.text$mn:0000AF49                 mov     ebp, esp
.text$mn:0000AF4B                 sub     esp, 8
.text$mn:0000AF4E                 mov     [ebp+var_8], ecx
.text$mn:0000AF51                 mov     eax, [ebp+var_8]
.text$mn:0000AF54                 cmp     dword ptr [eax+0Ch], 0
.text$mn:0000AF58                 jz      short loc_AF63
.text$mn:0000AF5A                 mov     [ebp+var_4], 1
.text$mn:0000AF61                 jmp     short loc_AF6A
.text$mn:0000AF63 ; ---------------------------------------------------------------------------
.text$mn:0000AF63
.text$mn:0000AF63 loc_AF63:                               ; CODE XREF: StaticDialog::isCreated(void)+10j
.text$mn:0000AF63                 mov     [ebp+var_4], 0
.text$mn:0000AF6A
.text$mn:0000AF6A loc_AF6A:                               ; CODE XREF: StaticDialog::isCreated(void)+19j
.text$mn:0000AF6A                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000AF6D                 mov     esp, ebp
.text$mn:0000AF6F                 pop     ebp
.text$mn:0000AF70                 retn
.text$mn:0000AF70 ?isCreated@StaticDialog@@UBE_NXZ endp
.text$mn:0000AF70
.text$mn:0000AF70 ; ---------------------------------------------------------------------------
.text$mn:0000AF71                 align 4
.text$mn:0000AF71 _text$mn        ends
.text$mn:0000AF71
.text$mn:0000AF74 ; ===========================================================================
.text$mn:0000AF74
.text$mn:0000AF74 ; Segment type: Pure code
.text$mn:0000AF74 ; Segment permissions: Read/Execute
.text$mn:0000AF74 _text$mn        segment para public 'CODE' use32
.text$mn:0000AF74                 assume cs:_text$mn
.text$mn:0000AF74                 ;org 0AF74h
.text$mn:0000AF74 ; COMDAT (pick any)
.text$mn:0000AF74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AF74
.text$mn:0000AF74 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AF74
.text$mn:0000AF74 ; Attributes: bp-based frame
.text$mn:0000AF74
.text$mn:0000AF74 ; bool __thiscall Shortcut::isEnabled(Shortcut *__hidden this)
.text$mn:0000AF74                 public ?isEnabled@Shortcut@@UBE_NXZ
.text$mn:0000AF74 ?isEnabled@Shortcut@@UBE_NXZ proc near  ; DATA XREF: .rdata:0000DB44o
.text$mn:0000AF74                                         ; .rdata:0000DB94o ...
.text$mn:0000AF74
.text$mn:0000AF74 var_8           = dword ptr -8
.text$mn:0000AF74 var_4           = dword ptr -4
.text$mn:0000AF74
.text$mn:0000AF74                 push    ebp
.text$mn:0000AF75                 mov     ebp, esp
.text$mn:0000AF77                 sub     esp, 8
.text$mn:0000AF7A                 mov     [ebp+var_8], ecx
.text$mn:0000AF7D                 mov     eax, [ebp+var_8]
.text$mn:0000AF80                 movzx   ecx, byte ptr [eax+23h]
.text$mn:0000AF84                 test    ecx, ecx
.text$mn:0000AF86                 jz      short loc_AF91
.text$mn:0000AF88                 mov     [ebp+var_4], 1
.text$mn:0000AF8F                 jmp     short loc_AF98
.text$mn:0000AF91 ; ---------------------------------------------------------------------------
.text$mn:0000AF91
.text$mn:0000AF91 loc_AF91:                               ; CODE XREF: Shortcut::isEnabled(void)+12j
.text$mn:0000AF91                 mov     [ebp+var_4], 0
.text$mn:0000AF98
.text$mn:0000AF98 loc_AF98:                               ; CODE XREF: Shortcut::isEnabled(void)+1Bj
.text$mn:0000AF98                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000AF9B                 mov     esp, ebp
.text$mn:0000AF9D                 pop     ebp
.text$mn:0000AF9E                 retn
.text$mn:0000AF9E ?isEnabled@Shortcut@@UBE_NXZ endp
.text$mn:0000AF9E
.text$mn:0000AF9E ; ---------------------------------------------------------------------------
.text$mn:0000AF9F                 align 10h
.text$mn:0000AF9F _text$mn        ends
.text$mn:0000AF9F
.text$mn:0000AFA0 ; ===========================================================================
.text$mn:0000AFA0
.text$mn:0000AFA0 ; Segment type: Pure code
.text$mn:0000AFA0 ; Segment permissions: Read/Execute
.text$mn:0000AFA0 _text$mn        segment para public 'CODE' use32
.text$mn:0000AFA0                 assume cs:_text$mn
.text$mn:0000AFA0                 ;org 0AFA0h
.text$mn:0000AFA0 ; COMDAT (pick any)
.text$mn:0000AFA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AFA0
.text$mn:0000AFA0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AFA0
.text$mn:0000AFA0 ; Attributes: bp-based frame
.text$mn:0000AFA0
.text$mn:0000AFA0 ; bool __thiscall NppParameters::isExistingExternalLangName(NppParameters *this, const wchar_t *)
.text$mn:0000AFA0                 public ?isExistingExternalLangName@NppParameters@@QBE_NPB_W@Z
.text$mn:0000AFA0 ?isExistingExternalLangName@NppParameters@@QBE_NPB_W@Z proc near
.text$mn:0000AFA0                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+521p
.text$mn:0000AFA0
.text$mn:0000AFA0 var_8           = dword ptr -8
.text$mn:0000AFA0 var_4           = dword ptr -4
.text$mn:0000AFA0 lpString2       = dword ptr  8
.text$mn:0000AFA0
.text$mn:0000AFA0                 push    ebp
.text$mn:0000AFA1                 mov     ebp, esp
.text$mn:0000AFA3                 sub     esp, 8
.text$mn:0000AFA6                 mov     [ebp+var_8], ecx
.text$mn:0000AFA9                 cmp     [ebp+lpString2], 0
.text$mn:0000AFAD                 jz      short loc_AFC2
.text$mn:0000AFAF                 mov     eax, 2
.text$mn:0000AFB4                 imul    ecx, eax, 0
.text$mn:0000AFB7                 mov     edx, [ebp+lpString2]
.text$mn:0000AFBA                 movzx   eax, word ptr [edx+ecx]
.text$mn:0000AFBE                 test    eax, eax
.text$mn:0000AFC0                 jnz     short loc_AFC6
.text$mn:0000AFC2
.text$mn:0000AFC2 loc_AFC2:                               ; CODE XREF: NppParameters::isExistingExternalLangName(wchar_t const *)+Dj
.text$mn:0000AFC2                 mov     al, 1
.text$mn:0000AFC4                 jmp     short loc_B00A
.text$mn:0000AFC6 ; ---------------------------------------------------------------------------
.text$mn:0000AFC6
.text$mn:0000AFC6 loc_AFC6:                               ; CODE XREF: NppParameters::isExistingExternalLangName(wchar_t const *)+20j
.text$mn:0000AFC6                 mov     [ebp+var_4], 0
.text$mn:0000AFCD                 jmp     short loc_AFD8
.text$mn:0000AFCF ; ---------------------------------------------------------------------------
.text$mn:0000AFCF
.text$mn:0000AFCF loc_AFCF:                               ; CODE XREF: NppParameters::isExistingExternalLangName(wchar_t const *):loc_B006j
.text$mn:0000AFCF                 mov     ecx, [ebp+var_4]
.text$mn:0000AFD2                 add     ecx, 1
.text$mn:0000AFD5                 mov     [ebp+var_4], ecx
.text$mn:0000AFD8
.text$mn:0000AFD8 loc_AFD8:                               ; CODE XREF: NppParameters::isExistingExternalLangName(wchar_t const *)+2Dj
.text$mn:0000AFD8                 mov     edx, [ebp+var_8]
.text$mn:0000AFDB                 mov     eax, [ebp+var_4]
.text$mn:0000AFDE                 cmp     eax, [edx+0B30h]
.text$mn:0000AFE4                 jge     short loc_B008
.text$mn:0000AFE6                 mov     ecx, [ebp+lpString2]
.text$mn:0000AFE9                 push    ecx             ; lpString2
.text$mn:0000AFEA                 mov     edx, [ebp+var_4]
.text$mn:0000AFED                 mov     eax, [ebp+var_8]
.text$mn:0000AFF0                 mov     ecx, [eax+edx*4+0AB8h]
.text$mn:0000AFF7                 push    ecx             ; lpString1
.text$mn:0000AFF8                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:0000AFFE                 test    eax, eax
.text$mn:0000B000                 jnz     short loc_B006
.text$mn:0000B002                 mov     al, 1
.text$mn:0000B004                 jmp     short loc_B00A
.text$mn:0000B006 ; ---------------------------------------------------------------------------
.text$mn:0000B006
.text$mn:0000B006 loc_B006:                               ; CODE XREF: NppParameters::isExistingExternalLangName(wchar_t const *)+60j
.text$mn:0000B006                 jmp     short loc_AFCF
.text$mn:0000B008 ; ---------------------------------------------------------------------------
.text$mn:0000B008
.text$mn:0000B008 loc_B008:                               ; CODE XREF: NppParameters::isExistingExternalLangName(wchar_t const *)+44j
.text$mn:0000B008                 xor     al, al
.text$mn:0000B00A
.text$mn:0000B00A loc_B00A:                               ; CODE XREF: NppParameters::isExistingExternalLangName(wchar_t const *)+24j
.text$mn:0000B00A                                         ; NppParameters::isExistingExternalLangName(wchar_t const *)+64j
.text$mn:0000B00A                 mov     esp, ebp
.text$mn:0000B00C                 pop     ebp
.text$mn:0000B00D                 retn    4
.text$mn:0000B00D ?isExistingExternalLangName@NppParameters@@QBE_NPB_W@Z endp
.text$mn:0000B00D
.text$mn:0000B00D _text$mn        ends
.text$mn:0000B00D
.text$mn:0000B010 ; ===========================================================================
.text$mn:0000B010
.text$mn:0000B010 ; Segment type: Pure code
.text$mn:0000B010 ; Segment permissions: Read/Execute
.text$mn:0000B010 _text$mn        segment para public 'CODE' use32
.text$mn:0000B010                 assume cs:_text$mn
.text$mn:0000B010                 ;org 0B010h
.text$mn:0000B010 ; COMDAT (pick any)
.text$mn:0000B010                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B010
.text$mn:0000B010 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B010
.text$mn:0000B010 ; Attributes: bp-based frame
.text$mn:0000B010
.text$mn:0000B010 ; bool __thiscall NppParameters::isInBlackList(NppParameters *this, wchar_t *)
.text$mn:0000B010                 public ?isInBlackList@NppParameters@@QAE_NPA_W@Z
.text$mn:0000B010 ?isInBlackList@NppParameters@@QAE_NPA_W@Z proc near
.text$mn:0000B010                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+315p
.text$mn:0000B010
.text$mn:0000B010 var_C           = dword ptr -0Ch
.text$mn:0000B010 var_8           = dword ptr -8
.text$mn:0000B010 var_4           = dword ptr -4
.text$mn:0000B010 Str             = dword ptr  8
.text$mn:0000B010
.text$mn:0000B010                 push    ebp
.text$mn:0000B011                 mov     ebp, esp
.text$mn:0000B013                 sub     esp, 0Ch
.text$mn:0000B016                 mov     [ebp+var_8], ecx
.text$mn:0000B019                 mov     [ebp+var_4], 0
.text$mn:0000B020                 mov     ecx, [ebp+var_8]
.text$mn:0000B023                 add     ecx, 1C8D4h
.text$mn:0000B029                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000B02E                 mov     [ebp+var_C], eax
.text$mn:0000B031                 jmp     short loc_B03C
.text$mn:0000B033 ; ---------------------------------------------------------------------------
.text$mn:0000B033
.text$mn:0000B033 loc_B033:                               ; CODE XREF: NppParameters::isInBlackList(wchar_t *):loc_B06Ej
.text$mn:0000B033                 mov     eax, [ebp+var_4]
.text$mn:0000B036                 add     eax, 1
.text$mn:0000B039                 mov     [ebp+var_4], eax
.text$mn:0000B03C
.text$mn:0000B03C loc_B03C:                               ; CODE XREF: NppParameters::isInBlackList(wchar_t *)+21j
.text$mn:0000B03C                 mov     ecx, [ebp+var_4]
.text$mn:0000B03F                 cmp     ecx, [ebp+var_C]
.text$mn:0000B042                 jnb     short loc_B070
.text$mn:0000B044                 mov     edx, [ebp+Str]
.text$mn:0000B047                 push    edx             ; Str
.text$mn:0000B048                 mov     eax, [ebp+var_4]
.text$mn:0000B04B                 push    eax
.text$mn:0000B04C                 mov     ecx, [ebp+var_8]
.text$mn:0000B04F                 add     ecx, 1C8D4h
.text$mn:0000B055                 call    ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)
.text$mn:0000B05A                 push    eax             ; int
.text$mn:0000B05B                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:0000B060                 add     esp, 8
.text$mn:0000B063                 movzx   ecx, al
.text$mn:0000B066                 test    ecx, ecx
.text$mn:0000B068                 jz      short loc_B06E
.text$mn:0000B06A                 mov     al, 1
.text$mn:0000B06C                 jmp     short loc_B072
.text$mn:0000B06E ; ---------------------------------------------------------------------------
.text$mn:0000B06E
.text$mn:0000B06E loc_B06E:                               ; CODE XREF: NppParameters::isInBlackList(wchar_t *)+58j
.text$mn:0000B06E                 jmp     short loc_B033
.text$mn:0000B070 ; ---------------------------------------------------------------------------
.text$mn:0000B070
.text$mn:0000B070 loc_B070:                               ; CODE XREF: NppParameters::isInBlackList(wchar_t *)+32j
.text$mn:0000B070                 xor     al, al
.text$mn:0000B072
.text$mn:0000B072 loc_B072:                               ; CODE XREF: NppParameters::isInBlackList(wchar_t *)+5Cj
.text$mn:0000B072                 mov     esp, ebp
.text$mn:0000B074                 pop     ebp
.text$mn:0000B075                 retn    4
.text$mn:0000B075 ?isInBlackList@NppParameters@@QAE_NPA_W@Z endp
.text$mn:0000B075
.text$mn:0000B075 _text$mn        ends
.text$mn:0000B075
.text$mn:0000B078 ; ===========================================================================
.text$mn:0000B078
.text$mn:0000B078 ; Segment type: Pure code
.text$mn:0000B078 ; Segment permissions: Read/Execute
.text$mn:0000B078 _text$mn        segment para public 'CODE' use32
.text$mn:0000B078                 assume cs:_text$mn
.text$mn:0000B078                 ;org 0B078h
.text$mn:0000B078 ; COMDAT (pick any)
.text$mn:0000B078                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B078
.text$mn:0000B078 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B078
.text$mn:0000B078 ; Attributes: bp-based frame
.text$mn:0000B078
.text$mn:0000B078 ; bool __thiscall PluginsManager::isInLoadedDlls(PluginsManager *this, const wchar_t *)
.text$mn:0000B078                 public ?isInLoadedDlls@PluginsManager@@ABE_NPB_W@Z
.text$mn:0000B078 ?isInLoadedDlls@PluginsManager@@ABE_NPB_W@Z proc near
.text$mn:0000B078                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+55p
.text$mn:0000B078
.text$mn:0000B078 var_8           = dword ptr -8
.text$mn:0000B078 var_4           = dword ptr -4
.text$mn:0000B078 Str1            = dword ptr  8
.text$mn:0000B078
.text$mn:0000B078                 push    ebp
.text$mn:0000B079                 mov     ebp, esp
.text$mn:0000B07B                 sub     esp, 8
.text$mn:0000B07E                 mov     [ebp+var_8], ecx
.text$mn:0000B081                 mov     [ebp+var_4], 0
.text$mn:0000B088                 jmp     short loc_B093
.text$mn:0000B08A ; ---------------------------------------------------------------------------
.text$mn:0000B08A
.text$mn:0000B08A loc_B08A:                               ; CODE XREF: PluginsManager::isInLoadedDlls(wchar_t const *):loc_B0CEj
.text$mn:0000B08A                 mov     eax, [ebp+var_4]
.text$mn:0000B08D                 add     eax, 1
.text$mn:0000B090                 mov     [ebp+var_4], eax
.text$mn:0000B093
.text$mn:0000B093 loc_B093:                               ; CODE XREF: PluginsManager::isInLoadedDlls(wchar_t const *)+10j
.text$mn:0000B093                 mov     ecx, [ebp+var_8]
.text$mn:0000B096                 add     ecx, 30h ; '0'
.text$mn:0000B099                 call    ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::size(void)
.text$mn:0000B09E                 cmp     [ebp+var_4], eax
.text$mn:0000B0A1                 jnb     short loc_B0D0
.text$mn:0000B0A3                 mov     ecx, [ebp+var_4]
.text$mn:0000B0A6                 push    ecx
.text$mn:0000B0A7                 mov     ecx, [ebp+var_8]
.text$mn:0000B0AA                 add     ecx, 30h ; '0'
.text$mn:0000B0AD                 call    ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@I@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)
.text$mn:0000B0B2                 mov     ecx, eax
.text$mn:0000B0B4                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000B0B9                 push    eax             ; Str2
.text$mn:0000B0BA                 mov     edx, [ebp+Str1]
.text$mn:0000B0BD                 push    edx             ; Str1
.text$mn:0000B0BE                 call    _wcsicmp
.text$mn:0000B0C3                 add     esp, 8
.text$mn:0000B0C6                 test    eax, eax
.text$mn:0000B0C8                 jnz     short loc_B0CE
.text$mn:0000B0CA                 mov     al, 1
.text$mn:0000B0CC                 jmp     short loc_B0D2
.text$mn:0000B0CE ; ---------------------------------------------------------------------------
.text$mn:0000B0CE
.text$mn:0000B0CE loc_B0CE:                               ; CODE XREF: PluginsManager::isInLoadedDlls(wchar_t const *)+50j
.text$mn:0000B0CE                 jmp     short loc_B08A
.text$mn:0000B0D0 ; ---------------------------------------------------------------------------
.text$mn:0000B0D0
.text$mn:0000B0D0 loc_B0D0:                               ; CODE XREF: PluginsManager::isInLoadedDlls(wchar_t const *)+29j
.text$mn:0000B0D0                 xor     al, al
.text$mn:0000B0D2
.text$mn:0000B0D2 loc_B0D2:                               ; CODE XREF: PluginsManager::isInLoadedDlls(wchar_t const *)+54j
.text$mn:0000B0D2                 mov     esp, ebp
.text$mn:0000B0D4                 pop     ebp
.text$mn:0000B0D5                 retn    4
.text$mn:0000B0D5 ?isInLoadedDlls@PluginsManager@@ABE_NPB_W@Z endp
.text$mn:0000B0D5
.text$mn:0000B0D5 _text$mn        ends
.text$mn:0000B0D5
.text$mn:0000B0D8 ; ===========================================================================
.text$mn:0000B0D8
.text$mn:0000B0D8 ; Segment type: Pure code
.text$mn:0000B0D8 ; Segment permissions: Read/Execute
.text$mn:0000B0D8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B0D8                 assume cs:_text$mn
.text$mn:0000B0D8                 ;org 0B0D8h
.text$mn:0000B0D8 ; COMDAT (pick any)
.text$mn:0000B0D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B0D8
.text$mn:0000B0D8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B0D8
.text$mn:0000B0D8 ; Attributes: bp-based frame
.text$mn:0000B0D8
.text$mn:0000B0D8 ; bool __thiscall PluginCmdShortcut::isValid(PluginCmdShortcut *__hidden this)
.text$mn:0000B0D8                 public ?isValid@PluginCmdShortcut@@UBE_NXZ
.text$mn:0000B0D8 ?isValid@PluginCmdShortcut@@UBE_NXZ proc near
.text$mn:0000B0D8                                         ; DATA XREF: .rdata:0000DBE0o
.text$mn:0000B0D8
.text$mn:0000B0D8 var_4           = dword ptr -4
.text$mn:0000B0D8
.text$mn:0000B0D8                 push    ebp
.text$mn:0000B0D9                 mov     ebp, esp
.text$mn:0000B0DB                 push    ecx
.text$mn:0000B0DC                 mov     [ebp+var_4], ecx
.text$mn:0000B0DF                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000B0E2                 call    ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.text$mn:0000B0E7                 movzx   eax, al
.text$mn:0000B0EA                 test    eax, eax
.text$mn:0000B0EC                 jnz     short loc_B0F2
.text$mn:0000B0EE                 xor     al, al
.text$mn:0000B0F0                 jmp     short loc_B11B
.text$mn:0000B0F2 ; ---------------------------------------------------------------------------
.text$mn:0000B0F2
.text$mn:0000B0F2 loc_B0F2:                               ; CODE XREF: PluginCmdShortcut::isValid(void)+14j
.text$mn:0000B0F2                 push    0
.text$mn:0000B0F4                 mov     ecx, [ebp+var_4]
.text$mn:0000B0F7                 add     ecx, 130h
.text$mn:0000B0FD                 call    ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)
.text$mn:0000B102                 movzx   ecx, word ptr [eax]
.text$mn:0000B105                 test    ecx, ecx
.text$mn:0000B107                 jz      short loc_B115
.text$mn:0000B109                 mov     edx, [ebp+var_4]
.text$mn:0000B10C                 cmp     dword ptr [edx+14Ch], 0FFFFFFFFh
.text$mn:0000B113                 jnz     short loc_B119
.text$mn:0000B115
.text$mn:0000B115 loc_B115:                               ; CODE XREF: PluginCmdShortcut::isValid(void)+2Fj
.text$mn:0000B115                 xor     al, al
.text$mn:0000B117                 jmp     short loc_B11B
.text$mn:0000B119 ; ---------------------------------------------------------------------------
.text$mn:0000B119
.text$mn:0000B119 loc_B119:                               ; CODE XREF: PluginCmdShortcut::isValid(void)+3Bj
.text$mn:0000B119                 mov     al, 1
.text$mn:0000B11B
.text$mn:0000B11B loc_B11B:                               ; CODE XREF: PluginCmdShortcut::isValid(void)+18j
.text$mn:0000B11B                                         ; PluginCmdShortcut::isValid(void)+3Fj
.text$mn:0000B11B                 mov     esp, ebp
.text$mn:0000B11D                 pop     ebp
.text$mn:0000B11E                 retn
.text$mn:0000B11E ?isValid@PluginCmdShortcut@@UBE_NXZ endp
.text$mn:0000B11E
.text$mn:0000B11E ; ---------------------------------------------------------------------------
.text$mn:0000B11F                 align 10h
.text$mn:0000B11F _text$mn        ends
.text$mn:0000B11F
.text$mn:0000B120 ; ===========================================================================
.text$mn:0000B120
.text$mn:0000B120 ; Segment type: Pure code
.text$mn:0000B120 ; Segment permissions: Read/Execute
.text$mn:0000B120 _text$mn        segment para public 'CODE' use32
.text$mn:0000B120                 assume cs:_text$mn
.text$mn:0000B120                 ;org 0B120h
.text$mn:0000B120 ; COMDAT (pick any)
.text$mn:0000B120                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B120
.text$mn:0000B120 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B120
.text$mn:0000B120 ; Attributes: bp-based frame
.text$mn:0000B120
.text$mn:0000B120 ; bool __thiscall Shortcut::isValid(Shortcut *__hidden this)
.text$mn:0000B120                 public ?isValid@Shortcut@@UBE_NXZ
.text$mn:0000B120 ?isValid@Shortcut@@UBE_NXZ proc near    ; CODE XREF: PluginCmdShortcut::isValid(void)+Ap
.text$mn:0000B120                                         ; DATA XREF: .rdata:0000DB40o ...
.text$mn:0000B120
.text$mn:0000B120 var_8           = dword ptr -8
.text$mn:0000B120 var_4           = dword ptr -4
.text$mn:0000B120
.text$mn:0000B120                 push    ebp
.text$mn:0000B121                 mov     ebp, esp
.text$mn:0000B123                 sub     esp, 8
.text$mn:0000B126                 mov     [ebp+var_4], ecx
.text$mn:0000B129                 mov     eax, [ebp+var_4]
.text$mn:0000B12C                 movzx   ecx, byte ptr [eax+23h]
.text$mn:0000B130                 test    ecx, ecx
.text$mn:0000B132                 jnz     short loc_B13B
.text$mn:0000B134                 mov     al, 1
.text$mn:0000B136                 jmp     loc_B1C8
.text$mn:0000B13B ; ---------------------------------------------------------------------------
.text$mn:0000B13B
.text$mn:0000B13B loc_B13B:                               ; CODE XREF: Shortcut::isValid(void)+12j
.text$mn:0000B13B                 mov     edx, [ebp+var_4]
.text$mn:0000B13E                 movzx   eax, byte ptr [edx+23h]
.text$mn:0000B142                 cmp     eax, 41h ; 'A'
.text$mn:0000B145                 jl      short loc_B153
.text$mn:0000B147                 mov     ecx, [ebp+var_4]
.text$mn:0000B14A                 movzx   edx, byte ptr [ecx+23h]
.text$mn:0000B14E                 cmp     edx, 5Ah ; 'Z'
.text$mn:0000B151                 jle     short loc_B19B
.text$mn:0000B153
.text$mn:0000B153 loc_B153:                               ; CODE XREF: Shortcut::isValid(void)+25j
.text$mn:0000B153                 mov     eax, [ebp+var_4]
.text$mn:0000B156                 movzx   ecx, byte ptr [eax+23h]
.text$mn:0000B15A                 cmp     ecx, 30h ; '0'
.text$mn:0000B15D                 jl      short loc_B16B
.text$mn:0000B15F                 mov     edx, [ebp+var_4]
.text$mn:0000B162                 movzx   eax, byte ptr [edx+23h]
.text$mn:0000B166                 cmp     eax, 39h ; '9'
.text$mn:0000B169                 jle     short loc_B19B
.text$mn:0000B16B
.text$mn:0000B16B loc_B16B:                               ; CODE XREF: Shortcut::isValid(void)+3Dj
.text$mn:0000B16B                 mov     ecx, [ebp+var_4]
.text$mn:0000B16E                 movzx   edx, byte ptr [ecx+23h]
.text$mn:0000B172                 cmp     edx, 20h ; ' '
.text$mn:0000B175                 jz      short loc_B19B
.text$mn:0000B177                 mov     eax, [ebp+var_4]
.text$mn:0000B17A                 movzx   ecx, byte ptr [eax+23h]
.text$mn:0000B17E                 cmp     ecx, 14h
.text$mn:0000B181                 jz      short loc_B19B
.text$mn:0000B183                 mov     edx, [ebp+var_4]
.text$mn:0000B186                 movzx   eax, byte ptr [edx+23h]
.text$mn:0000B18A                 cmp     eax, 8
.text$mn:0000B18D                 jz      short loc_B19B
.text$mn:0000B18F                 mov     ecx, [ebp+var_4]
.text$mn:0000B192                 movzx   edx, byte ptr [ecx+23h]
.text$mn:0000B196                 cmp     edx, 0Dh
.text$mn:0000B199                 jnz     short loc_B1C6
.text$mn:0000B19B
.text$mn:0000B19B loc_B19B:                               ; CODE XREF: Shortcut::isValid(void)+31j
.text$mn:0000B19B                                         ; Shortcut::isValid(void)+49j ...
.text$mn:0000B19B                 mov     eax, [ebp+var_4]
.text$mn:0000B19E                 movzx   ecx, byte ptr [eax+20h]
.text$mn:0000B1A2                 test    ecx, ecx
.text$mn:0000B1A4                 jnz     short loc_B1BA
.text$mn:0000B1A6                 mov     edx, [ebp+var_4]
.text$mn:0000B1A9                 movzx   eax, byte ptr [edx+21h]
.text$mn:0000B1AD                 test    eax, eax
.text$mn:0000B1AF                 jnz     short loc_B1BA
.text$mn:0000B1B1                 mov     [ebp+var_8], 0
.text$mn:0000B1B8                 jmp     short loc_B1C1
.text$mn:0000B1BA ; ---------------------------------------------------------------------------
.text$mn:0000B1BA
.text$mn:0000B1BA loc_B1BA:                               ; CODE XREF: Shortcut::isValid(void)+84j
.text$mn:0000B1BA                                         ; Shortcut::isValid(void)+8Fj
.text$mn:0000B1BA                 mov     [ebp+var_8], 1
.text$mn:0000B1C1
.text$mn:0000B1C1 loc_B1C1:                               ; CODE XREF: Shortcut::isValid(void)+98j
.text$mn:0000B1C1                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000B1C4                 jmp     short loc_B1C8
.text$mn:0000B1C6 ; ---------------------------------------------------------------------------
.text$mn:0000B1C6
.text$mn:0000B1C6 loc_B1C6:                               ; CODE XREF: Shortcut::isValid(void)+79j
.text$mn:0000B1C6                 mov     al, 1
.text$mn:0000B1C8
.text$mn:0000B1C8 loc_B1C8:                               ; CODE XREF: Shortcut::isValid(void)+16j
.text$mn:0000B1C8                                         ; Shortcut::isValid(void)+A4j
.text$mn:0000B1C8                 mov     esp, ebp
.text$mn:0000B1CA                 pop     ebp
.text$mn:0000B1CB                 retn
.text$mn:0000B1CB ?isValid@Shortcut@@UBE_NXZ endp
.text$mn:0000B1CB
.text$mn:0000B1CB _text$mn        ends
.text$mn:0000B1CB
.text$mn:0000B1CC ; ===========================================================================
.text$mn:0000B1CC
.text$mn:0000B1CC ; Segment type: Pure code
.text$mn:0000B1CC ; Segment permissions: Read/Execute
.text$mn:0000B1CC _text$mn        segment para public 'CODE' use32
.text$mn:0000B1CC                 assume cs:_text$mn
.text$mn:0000B1CC                 ;org 0B1CCh
.text$mn:0000B1CC ; COMDAT (pick any)
.text$mn:0000B1CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B1CC
.text$mn:0000B1CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B1CC
.text$mn:0000B1CC ; Attributes: bp-based frame
.text$mn:0000B1CC
.text$mn:0000B1CC ; bool __thiscall Window::isVisible(Window *__hidden this)
.text$mn:0000B1CC                 public ?isVisible@Window@@UBE_NXZ
.text$mn:0000B1CC ?isVisible@Window@@UBE_NXZ proc near    ; DATA XREF: .rdata:0000DAB8o
.text$mn:0000B1CC                                         ; .rdata:0000DAECo ...
.text$mn:0000B1CC
.text$mn:0000B1CC var_8           = dword ptr -8
.text$mn:0000B1CC var_1           = byte ptr -1
.text$mn:0000B1CC
.text$mn:0000B1CC                 push    ebp
.text$mn:0000B1CD                 mov     ebp, esp
.text$mn:0000B1CF                 sub     esp, 8
.text$mn:0000B1D2                 mov     [ebp+var_8], ecx
.text$mn:0000B1D5                 mov     eax, [ebp+var_8]
.text$mn:0000B1D8                 mov     ecx, [eax+0Ch]
.text$mn:0000B1DB                 push    ecx             ; hWnd
.text$mn:0000B1DC                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:0000B1E2                 test    eax, eax
.text$mn:0000B1E4                 jz      short loc_B1EC
.text$mn:0000B1E6                 mov     [ebp+var_1], 1
.text$mn:0000B1EA                 jmp     short loc_B1F0
.text$mn:0000B1EC ; ---------------------------------------------------------------------------
.text$mn:0000B1EC
.text$mn:0000B1EC loc_B1EC:                               ; CODE XREF: Window::isVisible(void)+18j
.text$mn:0000B1EC                 mov     [ebp+var_1], 0
.text$mn:0000B1F0
.text$mn:0000B1F0 loc_B1F0:                               ; CODE XREF: Window::isVisible(void)+1Ej
.text$mn:0000B1F0                 mov     al, [ebp+var_1]
.text$mn:0000B1F3                 mov     esp, ebp
.text$mn:0000B1F5                 pop     ebp
.text$mn:0000B1F6                 retn
.text$mn:0000B1F6 ?isVisible@Window@@UBE_NXZ endp
.text$mn:0000B1F6
.text$mn:0000B1F6 ; ---------------------------------------------------------------------------
.text$mn:0000B1F7                 align 4
.text$mn:0000B1F7 _text$mn        ends
.text$mn:0000B1F7
.text$mn:0000B1F8 ; ===========================================================================
.text$mn:0000B1F8
.text$mn:0000B1F8 ; Segment type: Pure code
.text$mn:0000B1F8 ; Segment permissions: Read/Execute
.text$mn:0000B1F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B1F8                 assume cs:_text$mn
.text$mn:0000B1F8                 ;org 0B1F8h
.text$mn:0000B1F8 ; COMDAT (pick any)
.text$mn:0000B1F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B1F8
.text$mn:0000B1F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B1F8
.text$mn:0000B1F8 ; Attributes: bp-based frame
.text$mn:0000B1F8
.text$mn:0000B1F8 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000B1F8                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000B1F8 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000B1F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000B1F8
.text$mn:0000B1F8 var_4           = dword ptr -4
.text$mn:0000B1F8 Str             = dword ptr  8
.text$mn:0000B1F8
.text$mn:0000B1F8                 push    ebp
.text$mn:0000B1F9                 mov     ebp, esp
.text$mn:0000B1FB                 push    ecx
.text$mn:0000B1FC                 mov     eax, [ebp+Str]
.text$mn:0000B1FF                 movsx   ecx, byte ptr [eax]
.text$mn:0000B202                 test    ecx, ecx
.text$mn:0000B204                 jnz     short loc_B20F
.text$mn:0000B206                 mov     [ebp+var_4], 0
.text$mn:0000B20D                 jmp     short loc_B21E
.text$mn:0000B20F ; ---------------------------------------------------------------------------
.text$mn:0000B20F
.text$mn:0000B20F loc_B20F:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000B20F                 mov     edx, [ebp+Str]
.text$mn:0000B212                 push    edx             ; Str
.text$mn:0000B213                 call    _strlen
.text$mn:0000B218                 add     esp, 4
.text$mn:0000B21B                 mov     [ebp+var_4], eax
.text$mn:0000B21E
.text$mn:0000B21E loc_B21E:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000B21E                 mov     eax, [ebp+var_4]
.text$mn:0000B221                 mov     esp, ebp
.text$mn:0000B223                 pop     ebp
.text$mn:0000B224                 retn
.text$mn:0000B224 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:0000B224
.text$mn:0000B224 ; ---------------------------------------------------------------------------
.text$mn:0000B225                 align 4
.text$mn:0000B225 _text$mn        ends
.text$mn:0000B225
.text$mn:0000B228 ; ===========================================================================
.text$mn:0000B228
.text$mn:0000B228 ; Segment type: Pure code
.text$mn:0000B228 ; Segment permissions: Read/Execute
.text$mn:0000B228 _text$mn        segment para public 'CODE' use32
.text$mn:0000B228                 assume cs:_text$mn
.text$mn:0000B228                 ;org 0B228h
.text$mn:0000B228 ; COMDAT (pick any)
.text$mn:0000B228                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B228
.text$mn:0000B228 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B228
.text$mn:0000B228 ; Attributes: bp-based frame
.text$mn:0000B228
.text$mn:0000B228 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:0000B228                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:0000B228 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:0000B228                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+21p
.text$mn:0000B228                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p ...
.text$mn:0000B228
.text$mn:0000B228 var_4           = dword ptr -4
.text$mn:0000B228 Str             = dword ptr  8
.text$mn:0000B228
.text$mn:0000B228                 push    ebp
.text$mn:0000B229                 mov     ebp, esp
.text$mn:0000B22B                 push    ecx
.text$mn:0000B22C                 mov     eax, [ebp+Str]
.text$mn:0000B22F                 movzx   ecx, word ptr [eax]
.text$mn:0000B232                 test    ecx, ecx
.text$mn:0000B234                 jnz     short loc_B23F
.text$mn:0000B236                 mov     [ebp+var_4], 0
.text$mn:0000B23D                 jmp     short loc_B24E
.text$mn:0000B23F ; ---------------------------------------------------------------------------
.text$mn:0000B23F
.text$mn:0000B23F loc_B23F:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:0000B23F                 mov     edx, [ebp+Str]
.text$mn:0000B242                 push    edx             ; Str
.text$mn:0000B243                 call    _wcslen
.text$mn:0000B248                 add     esp, 4
.text$mn:0000B24B                 mov     [ebp+var_4], eax
.text$mn:0000B24E
.text$mn:0000B24E loc_B24E:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:0000B24E                 mov     eax, [ebp+var_4]
.text$mn:0000B251                 mov     esp, ebp
.text$mn:0000B253                 pop     ebp
.text$mn:0000B254                 retn
.text$mn:0000B254 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:0000B254
.text$mn:0000B254 ; ---------------------------------------------------------------------------
.text$mn:0000B255                 align 4
.text$mn:0000B255 _text$mn        ends
.text$mn:0000B255
.text$mn:0000B258 ; ===========================================================================
.text$mn:0000B258
.text$mn:0000B258 ; Segment type: Pure code
.text$mn:0000B258 ; Segment permissions: Read/Execute
.text$mn:0000B258 _text$mn        segment para public 'CODE' use32
.text$mn:0000B258                 assume cs:_text$mn
.text$mn:0000B258                 ;org 0B258h
.text$mn:0000B258 ; COMDAT (pick any)
.text$mn:0000B258                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B258
.text$mn:0000B258 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B258
.text$mn:0000B258 ; Attributes: bp-based frame
.text$mn:0000B258
.text$mn:0000B258 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:0000B258                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000B258 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000B258                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:0000B258
.text$mn:0000B258 var_4           = dword ptr -4
.text$mn:0000B258
.text$mn:0000B258                 push    ebp
.text$mn:0000B259                 mov     ebp, esp
.text$mn:0000B25B                 push    ecx
.text$mn:0000B25C                 mov     [ebp+var_4], ecx
.text$mn:0000B25F                 mov     eax, [ebp+var_4]
.text$mn:0000B262                 push    eax
.text$mn:0000B263                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:0000B268                 add     esp, 4
.text$mn:0000B26B                 mov     esp, ebp
.text$mn:0000B26D                 pop     ebp
.text$mn:0000B26E                 retn
.text$mn:0000B26E ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000B26E
.text$mn:0000B26E ; ---------------------------------------------------------------------------
.text$mn:0000B26F                 align 10h
.text$mn:0000B26F _text$mn        ends
.text$mn:0000B26F
.text$mn:0000B270 ; ===========================================================================
.text$mn:0000B270
.text$mn:0000B270 ; Segment type: Pure code
.text$mn:0000B270 ; Segment permissions: Read/Execute
.text$mn:0000B270 _text$mn        segment para public 'CODE' use32
.text$mn:0000B270                 assume cs:_text$mn
.text$mn:0000B270                 ;org 0B270h
.text$mn:0000B270 ; COMDAT (pick any)
.text$mn:0000B270                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B270
.text$mn:0000B270 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B270
.text$mn:0000B270 ; Attributes: bp-based frame
.text$mn:0000B270
.text$mn:0000B270 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct PluginInfo *>>::max_size(void)const
.text$mn:0000B270                 public ?max_size@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ
.text$mn:0000B270 ?max_size@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B270                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::max_size(void)+17p
.text$mn:0000B270
.text$mn:0000B270 var_4           = dword ptr -4
.text$mn:0000B270
.text$mn:0000B270                 push    ebp
.text$mn:0000B271                 mov     ebp, esp
.text$mn:0000B273                 push    ecx
.text$mn:0000B274                 mov     [ebp+var_4], ecx
.text$mn:0000B277                 mov     eax, [ebp+var_4]
.text$mn:0000B27A                 push    eax
.text$mn:0000B27B                 call    ?max_size@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAIABV?$allocator@PAUPluginInfo@@@2@@Z ; std::allocator_traits<std::allocator<PluginInfo *>>::max_size(std::allocator<PluginInfo *> const &)
.text$mn:0000B280                 add     esp, 4
.text$mn:0000B283                 mov     esp, ebp
.text$mn:0000B285                 pop     ebp
.text$mn:0000B286                 retn
.text$mn:0000B286 ?max_size@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ endp
.text$mn:0000B286
.text$mn:0000B286 ; ---------------------------------------------------------------------------
.text$mn:0000B287                 align 4
.text$mn:0000B287 _text$mn        ends
.text$mn:0000B287
.text$mn:0000B288 ; ===========================================================================
.text$mn:0000B288
.text$mn:0000B288 ; Segment type: Pure code
.text$mn:0000B288 ; Segment permissions: Read/Execute
.text$mn:0000B288 _text$mn        segment para public 'CODE' use32
.text$mn:0000B288                 assume cs:_text$mn
.text$mn:0000B288                 ;org 0B288h
.text$mn:0000B288 ; COMDAT (pick any)
.text$mn:0000B288                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B288
.text$mn:0000B288 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B288
.text$mn:0000B288 ; Attributes: bp-based frame
.text$mn:0000B288
.text$mn:0000B288 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class TiXmlDocument *>>::max_size(void)const
.text$mn:0000B288                 public ?max_size@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ
.text$mn:0000B288 ?max_size@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B288                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::max_size(void)+17p
.text$mn:0000B288
.text$mn:0000B288 var_4           = dword ptr -4
.text$mn:0000B288
.text$mn:0000B288                 push    ebp
.text$mn:0000B289                 mov     ebp, esp
.text$mn:0000B28B                 push    ecx
.text$mn:0000B28C                 mov     [ebp+var_4], ecx
.text$mn:0000B28F                 mov     eax, [ebp+var_4]
.text$mn:0000B292                 push    eax
.text$mn:0000B293                 call    ?max_size@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAIABV?$allocator@PAVTiXmlDocument@@@2@@Z ; std::allocator_traits<std::allocator<TiXmlDocument *>>::max_size(std::allocator<TiXmlDocument *> const &)
.text$mn:0000B298                 add     esp, 4
.text$mn:0000B29B                 mov     esp, ebp
.text$mn:0000B29D                 pop     ebp
.text$mn:0000B29E                 retn
.text$mn:0000B29E ?max_size@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ endp
.text$mn:0000B29E
.text$mn:0000B29E ; ---------------------------------------------------------------------------
.text$mn:0000B29F                 align 10h
.text$mn:0000B29F _text$mn        ends
.text$mn:0000B29F
.text$mn:0000B2A0 ; ===========================================================================
.text$mn:0000B2A0
.text$mn:0000B2A0 ; Segment type: Pure code
.text$mn:0000B2A0 ; Segment permissions: Read/Execute
.text$mn:0000B2A0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B2A0                 assume cs:_text$mn
.text$mn:0000B2A0                 ;org 0B2A0h
.text$mn:0000B2A0 ; COMDAT (pick any)
.text$mn:0000B2A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B2A0
.text$mn:0000B2A0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2A0
.text$mn:0000B2A0 ; Attributes: bp-based frame
.text$mn:0000B2A0
.text$mn:0000B2A0 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::max_size(void)const
.text$mn:0000B2A0                 public ?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QBEIXZ
.text$mn:0000B2A0 ?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B2A0                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::max_size(void)+17p
.text$mn:0000B2A0
.text$mn:0000B2A0 var_4           = dword ptr -4
.text$mn:0000B2A0
.text$mn:0000B2A0                 push    ebp
.text$mn:0000B2A1                 mov     ebp, esp
.text$mn:0000B2A3                 push    ecx
.text$mn:0000B2A4                 mov     [ebp+var_4], ecx
.text$mn:0000B2A7                 mov     eax, [ebp+var_4]
.text$mn:0000B2AA                 push    eax
.text$mn:0000B2AB                 call    ?max_size@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAIABV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@Z ; std::allocator_traits<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::max_size(std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>> const &)
.text$mn:0000B2B0                 add     esp, 4
.text$mn:0000B2B3                 mov     esp, ebp
.text$mn:0000B2B5                 pop     ebp
.text$mn:0000B2B6                 retn
.text$mn:0000B2B6 ?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QBEIXZ endp
.text$mn:0000B2B6
.text$mn:0000B2B6 ; ---------------------------------------------------------------------------
.text$mn:0000B2B7                 align 4
.text$mn:0000B2B7 _text$mn        ends
.text$mn:0000B2B7
.text$mn:0000B2B8 ; ===========================================================================
.text$mn:0000B2B8
.text$mn:0000B2B8 ; Segment type: Pure code
.text$mn:0000B2B8 ; Segment permissions: Read/Execute
.text$mn:0000B2B8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B2B8                 assume cs:_text$mn
.text$mn:0000B2B8                 ;org 0B2B8h
.text$mn:0000B2B8 ; COMDAT (pick any)
.text$mn:0000B2B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B2B8
.text$mn:0000B2B8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2B8
.text$mn:0000B2B8 ; Attributes: bp-based frame
.text$mn:0000B2B8
.text$mn:0000B2B8 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct PluginCommand>>::max_size(void)const
.text$mn:0000B2B8                 public ?max_size@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ
.text$mn:0000B2B8 ?max_size@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B2B8                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::max_size(void)+17p
.text$mn:0000B2B8
.text$mn:0000B2B8 var_4           = dword ptr -4
.text$mn:0000B2B8
.text$mn:0000B2B8                 push    ebp
.text$mn:0000B2B9                 mov     ebp, esp
.text$mn:0000B2BB                 push    ecx
.text$mn:0000B2BC                 mov     [ebp+var_4], ecx
.text$mn:0000B2BF                 mov     eax, [ebp+var_4]
.text$mn:0000B2C2                 push    eax
.text$mn:0000B2C3                 call    ?max_size@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAIABV?$allocator@UPluginCommand@@@2@@Z ; std::allocator_traits<std::allocator<PluginCommand>>::max_size(std::allocator<PluginCommand> const &)
.text$mn:0000B2C8                 add     esp, 4
.text$mn:0000B2CB                 mov     esp, ebp
.text$mn:0000B2CD                 pop     ebp
.text$mn:0000B2CE                 retn
.text$mn:0000B2CE ?max_size@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ endp
.text$mn:0000B2CE
.text$mn:0000B2CE ; ---------------------------------------------------------------------------
.text$mn:0000B2CF                 align 10h
.text$mn:0000B2CF _text$mn        ends
.text$mn:0000B2CF
.text$mn:0000B2D0 ; ===========================================================================
.text$mn:0000B2D0
.text$mn:0000B2D0 ; Segment type: Pure code
.text$mn:0000B2D0 ; Segment permissions: Read/Execute
.text$mn:0000B2D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B2D0                 assume cs:_text$mn
.text$mn:0000B2D0                 ;org 0B2D0h
.text$mn:0000B2D0 ; COMDAT (pick any)
.text$mn:0000B2D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B2D0
.text$mn:0000B2D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2D0
.text$mn:0000B2D0 ; Attributes: bp-based frame
.text$mn:0000B2D0
.text$mn:0000B2D0 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::max_size(void)const
.text$mn:0000B2D0                 public ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ
.text$mn:0000B2D0 ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B2D0                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)+17p
.text$mn:0000B2D0
.text$mn:0000B2D0 var_4           = dword ptr -4
.text$mn:0000B2D0
.text$mn:0000B2D0                 push    ebp
.text$mn:0000B2D1                 mov     ebp, esp
.text$mn:0000B2D3                 push    ecx
.text$mn:0000B2D4                 mov     [ebp+var_4], ecx
.text$mn:0000B2D7                 mov     eax, [ebp+var_4]
.text$mn:0000B2DA                 push    eax
.text$mn:0000B2DB                 call    ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)
.text$mn:0000B2E0                 add     esp, 4
.text$mn:0000B2E3                 mov     esp, ebp
.text$mn:0000B2E5                 pop     ebp
.text$mn:0000B2E6                 retn
.text$mn:0000B2E6 ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ endp
.text$mn:0000B2E6
.text$mn:0000B2E6 ; ---------------------------------------------------------------------------
.text$mn:0000B2E7                 align 4
.text$mn:0000B2E7 _text$mn        ends
.text$mn:0000B2E7
.text$mn:0000B2E8 ; ===========================================================================
.text$mn:0000B2E8
.text$mn:0000B2E8 ; Segment type: Pure code
.text$mn:0000B2E8 ; Segment permissions: Read/Execute
.text$mn:0000B2E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B2E8                 assume cs:_text$mn
.text$mn:0000B2E8                 ;org 0B2E8h
.text$mn:0000B2E8 ; COMDAT (pick any)
.text$mn:0000B2E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B2E8
.text$mn:0000B2E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2E8
.text$mn:0000B2E8 ; Attributes: bp-based frame
.text$mn:0000B2E8
.text$mn:0000B2E8 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class PluginCmdShortcut>>::max_size(void)const
.text$mn:0000B2E8                 public ?max_size@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ
.text$mn:0000B2E8 ?max_size@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B2E8                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::max_size(void)+17p
.text$mn:0000B2E8
.text$mn:0000B2E8 var_4           = dword ptr -4
.text$mn:0000B2E8
.text$mn:0000B2E8                 push    ebp
.text$mn:0000B2E9                 mov     ebp, esp
.text$mn:0000B2EB                 push    ecx
.text$mn:0000B2EC                 mov     [ebp+var_4], ecx
.text$mn:0000B2EF                 mov     eax, [ebp+var_4]
.text$mn:0000B2F2                 push    eax
.text$mn:0000B2F3                 call    ?max_size@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAIABV?$allocator@VPluginCmdShortcut@@@2@@Z ; std::allocator_traits<std::allocator<PluginCmdShortcut>>::max_size(std::allocator<PluginCmdShortcut> const &)
.text$mn:0000B2F8                 add     esp, 4
.text$mn:0000B2FB                 mov     esp, ebp
.text$mn:0000B2FD                 pop     ebp
.text$mn:0000B2FE                 retn
.text$mn:0000B2FE ?max_size@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ endp
.text$mn:0000B2FE
.text$mn:0000B2FE ; ---------------------------------------------------------------------------
.text$mn:0000B2FF                 align 10h
.text$mn:0000B2FF _text$mn        ends
.text$mn:0000B2FF
.text$mn:0000B300 ; ===========================================================================
.text$mn:0000B300
.text$mn:0000B300 ; Segment type: Pure code
.text$mn:0000B300 ; Segment permissions: Read/Execute
.text$mn:0000B300 _text$mn        segment para public 'CODE' use32
.text$mn:0000B300                 assume cs:_text$mn
.text$mn:0000B300                 ;org 0B300h
.text$mn:0000B300 ; COMDAT (pick any)
.text$mn:0000B300                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B300
.text$mn:0000B300 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B300
.text$mn:0000B300 ; Attributes: bp-based frame
.text$mn:0000B300
.text$mn:0000B300 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000B300                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000B300 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000B300                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:0000B300
.text$mn:0000B300 var_4           = dword ptr -4
.text$mn:0000B300
.text$mn:0000B300                 push    ebp
.text$mn:0000B301                 mov     ebp, esp
.text$mn:0000B303                 push    ecx
.text$mn:0000B304                 mov     [ebp+var_4], ecx
.text$mn:0000B307                 mov     eax, [ebp+var_4]
.text$mn:0000B30A                 push    eax
.text$mn:0000B30B                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:0000B310                 add     esp, 4
.text$mn:0000B313                 mov     esp, ebp
.text$mn:0000B315                 pop     ebp
.text$mn:0000B316                 retn
.text$mn:0000B316 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000B316
.text$mn:0000B316 ; ---------------------------------------------------------------------------
.text$mn:0000B317                 align 4
.text$mn:0000B317 _text$mn        ends
.text$mn:0000B317
.text$mn:0000B318 ; ===========================================================================
.text$mn:0000B318
.text$mn:0000B318 ; Segment type: Pure code
.text$mn:0000B318 ; Segment permissions: Read/Execute
.text$mn:0000B318 _text$mn        segment para public 'CODE' use32
.text$mn:0000B318                 assume cs:_text$mn
.text$mn:0000B318                 ;org 0B318h
.text$mn:0000B318 ; COMDAT (pick any)
.text$mn:0000B318                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B318
.text$mn:0000B318 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B318
.text$mn:0000B318 ; Attributes: bp-based frame
.text$mn:0000B318
.text$mn:0000B318 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000B318                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000B318 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000B318                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000B318
.text$mn:0000B318 var_4           = dword ptr -4
.text$mn:0000B318
.text$mn:0000B318                 push    ebp
.text$mn:0000B319                 mov     ebp, esp
.text$mn:0000B31B                 push    ecx
.text$mn:0000B31C                 mov     [ebp+var_4], ecx
.text$mn:0000B31F                 or      eax, 0FFFFFFFFh
.text$mn:0000B322                 mov     esp, ebp
.text$mn:0000B324                 pop     ebp
.text$mn:0000B325                 retn
.text$mn:0000B325 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:0000B325
.text$mn:0000B325 ; ---------------------------------------------------------------------------
.text$mn:0000B326                 align 4
.text$mn:0000B326 _text$mn        ends
.text$mn:0000B326
.text$mn:0000B328 ; ===========================================================================
.text$mn:0000B328
.text$mn:0000B328 ; Segment type: Pure code
.text$mn:0000B328 ; Segment permissions: Read/Execute
.text$mn:0000B328 _text$mn        segment para public 'CODE' use32
.text$mn:0000B328                 assume cs:_text$mn
.text$mn:0000B328                 ;org 0B328h
.text$mn:0000B328 ; COMDAT (pick any)
.text$mn:0000B328                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B328
.text$mn:0000B328 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B328
.text$mn:0000B328 ; Attributes: bp-based frame
.text$mn:0000B328
.text$mn:0000B328 ; public: unsigned int __thiscall std::allocator<struct PluginInfo *>::max_size(void)const
.text$mn:0000B328                 public ?max_size@?$allocator@PAUPluginInfo@@@std@@QBEIXZ
.text$mn:0000B328 ?max_size@?$allocator@PAUPluginInfo@@@std@@QBEIXZ proc near
.text$mn:0000B328                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginInfo *>>::max_size(std::allocator<PluginInfo *> const &)+6p
.text$mn:0000B328
.text$mn:0000B328 var_4           = dword ptr -4
.text$mn:0000B328
.text$mn:0000B328                 push    ebp
.text$mn:0000B329                 mov     ebp, esp
.text$mn:0000B32B                 push    ecx
.text$mn:0000B32C                 mov     [ebp+var_4], ecx
.text$mn:0000B32F                 mov     eax, 3FFFFFFFh
.text$mn:0000B334                 mov     esp, ebp
.text$mn:0000B336                 pop     ebp
.text$mn:0000B337                 retn
.text$mn:0000B337 ?max_size@?$allocator@PAUPluginInfo@@@std@@QBEIXZ endp
.text$mn:0000B337
.text$mn:0000B337 _text$mn        ends
.text$mn:0000B337
.text$mn:0000B338 ; ===========================================================================
.text$mn:0000B338
.text$mn:0000B338 ; Segment type: Pure code
.text$mn:0000B338 ; Segment permissions: Read/Execute
.text$mn:0000B338 _text$mn        segment para public 'CODE' use32
.text$mn:0000B338                 assume cs:_text$mn
.text$mn:0000B338                 ;org 0B338h
.text$mn:0000B338 ; COMDAT (pick any)
.text$mn:0000B338                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B338
.text$mn:0000B338 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B338
.text$mn:0000B338 ; Attributes: bp-based frame
.text$mn:0000B338
.text$mn:0000B338 ; public: unsigned int __thiscall std::allocator<class TiXmlDocument *>::max_size(void)const
.text$mn:0000B338                 public ?max_size@?$allocator@PAVTiXmlDocument@@@std@@QBEIXZ
.text$mn:0000B338 ?max_size@?$allocator@PAVTiXmlDocument@@@std@@QBEIXZ proc near
.text$mn:0000B338                                         ; CODE XREF: std::allocator_traits<std::allocator<TiXmlDocument *>>::max_size(std::allocator<TiXmlDocument *> const &)+6p
.text$mn:0000B338
.text$mn:0000B338 var_4           = dword ptr -4
.text$mn:0000B338
.text$mn:0000B338                 push    ebp
.text$mn:0000B339                 mov     ebp, esp
.text$mn:0000B33B                 push    ecx
.text$mn:0000B33C                 mov     [ebp+var_4], ecx
.text$mn:0000B33F                 mov     eax, 3FFFFFFFh
.text$mn:0000B344                 mov     esp, ebp
.text$mn:0000B346                 pop     ebp
.text$mn:0000B347                 retn
.text$mn:0000B347 ?max_size@?$allocator@PAVTiXmlDocument@@@std@@QBEIXZ endp
.text$mn:0000B347
.text$mn:0000B347 _text$mn        ends
.text$mn:0000B347
.text$mn:0000B348 ; ===========================================================================
.text$mn:0000B348
.text$mn:0000B348 ; Segment type: Pure code
.text$mn:0000B348 ; Segment permissions: Read/Execute
.text$mn:0000B348 _text$mn        segment para public 'CODE' use32
.text$mn:0000B348                 assume cs:_text$mn
.text$mn:0000B348                 ;org 0B348h
.text$mn:0000B348 ; COMDAT (pick any)
.text$mn:0000B348                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B348
.text$mn:0000B348 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B348
.text$mn:0000B348 ; Attributes: bp-based frame
.text$mn:0000B348
.text$mn:0000B348 ; public: unsigned int __thiscall std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>::max_size(void)const
.text$mn:0000B348                 public ?max_size@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QBEIXZ
.text$mn:0000B348 ?max_size@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QBEIXZ proc near
.text$mn:0000B348                                         ; CODE XREF: std::allocator_traits<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::max_size(std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>> const &)+6p
.text$mn:0000B348
.text$mn:0000B348 var_4           = dword ptr -4
.text$mn:0000B348
.text$mn:0000B348                 push    ebp
.text$mn:0000B349                 mov     ebp, esp
.text$mn:0000B34B                 push    ecx
.text$mn:0000B34C                 mov     [ebp+var_4], ecx
.text$mn:0000B34F                 mov     eax, 7FFFFFFh
.text$mn:0000B354                 mov     esp, ebp
.text$mn:0000B356                 pop     ebp
.text$mn:0000B357                 retn
.text$mn:0000B357 ?max_size@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QBEIXZ endp
.text$mn:0000B357
.text$mn:0000B357 _text$mn        ends
.text$mn:0000B357
.text$mn:0000B358 ; ===========================================================================
.text$mn:0000B358
.text$mn:0000B358 ; Segment type: Pure code
.text$mn:0000B358 ; Segment permissions: Read/Execute
.text$mn:0000B358 _text$mn        segment para public 'CODE' use32
.text$mn:0000B358                 assume cs:_text$mn
.text$mn:0000B358                 ;org 0B358h
.text$mn:0000B358 ; COMDAT (pick any)
.text$mn:0000B358                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B358
.text$mn:0000B358 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B358
.text$mn:0000B358 ; Attributes: bp-based frame
.text$mn:0000B358
.text$mn:0000B358 ; public: unsigned int __thiscall std::allocator<struct PluginCommand>::max_size(void)const
.text$mn:0000B358                 public ?max_size@?$allocator@UPluginCommand@@@std@@QBEIXZ
.text$mn:0000B358 ?max_size@?$allocator@UPluginCommand@@@std@@QBEIXZ proc near
.text$mn:0000B358                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginCommand>>::max_size(std::allocator<PluginCommand> const &)+6p
.text$mn:0000B358
.text$mn:0000B358 var_4           = dword ptr -4
.text$mn:0000B358
.text$mn:0000B358                 push    ebp
.text$mn:0000B359                 mov     ebp, esp
.text$mn:0000B35B                 push    ecx
.text$mn:0000B35C                 mov     [ebp+var_4], ecx
.text$mn:0000B35F                 mov     eax, 71C71C7h
.text$mn:0000B364                 mov     esp, ebp
.text$mn:0000B366                 pop     ebp
.text$mn:0000B367                 retn
.text$mn:0000B367 ?max_size@?$allocator@UPluginCommand@@@std@@QBEIXZ endp
.text$mn:0000B367
.text$mn:0000B367 _text$mn        ends
.text$mn:0000B367
.text$mn:0000B368 ; ===========================================================================
.text$mn:0000B368
.text$mn:0000B368 ; Segment type: Pure code
.text$mn:0000B368 ; Segment permissions: Read/Execute
.text$mn:0000B368 _text$mn        segment para public 'CODE' use32
.text$mn:0000B368                 assume cs:_text$mn
.text$mn:0000B368                 ;org 0B368h
.text$mn:0000B368 ; COMDAT (pick any)
.text$mn:0000B368                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B368
.text$mn:0000B368 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B368
.text$mn:0000B368 ; Attributes: bp-based frame
.text$mn:0000B368
.text$mn:0000B368 ; public: unsigned int __thiscall std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>::max_size(void)const
.text$mn:0000B368                 public ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ
.text$mn:0000B368 ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ proc near
.text$mn:0000B368                                         ; CODE XREF: std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>> const &)+6p
.text$mn:0000B368
.text$mn:0000B368 var_4           = dword ptr -4
.text$mn:0000B368
.text$mn:0000B368                 push    ebp
.text$mn:0000B369                 mov     ebp, esp
.text$mn:0000B36B                 push    ecx
.text$mn:0000B36C                 mov     [ebp+var_4], ecx
.text$mn:0000B36F                 mov     eax, 9249249h
.text$mn:0000B374                 mov     esp, ebp
.text$mn:0000B376                 pop     ebp
.text$mn:0000B377                 retn
.text$mn:0000B377 ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ endp
.text$mn:0000B377
.text$mn:0000B377 _text$mn        ends
.text$mn:0000B377
.text$mn:0000B378 ; ===========================================================================
.text$mn:0000B378
.text$mn:0000B378 ; Segment type: Pure code
.text$mn:0000B378 ; Segment permissions: Read/Execute
.text$mn:0000B378 _text$mn        segment para public 'CODE' use32
.text$mn:0000B378                 assume cs:_text$mn
.text$mn:0000B378                 ;org 0B378h
.text$mn:0000B378 ; COMDAT (pick any)
.text$mn:0000B378                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B378
.text$mn:0000B378 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B378
.text$mn:0000B378 ; Attributes: bp-based frame
.text$mn:0000B378
.text$mn:0000B378 ; public: unsigned int __thiscall std::allocator<class PluginCmdShortcut>::max_size(void)const
.text$mn:0000B378                 public ?max_size@?$allocator@VPluginCmdShortcut@@@std@@QBEIXZ
.text$mn:0000B378 ?max_size@?$allocator@VPluginCmdShortcut@@@std@@QBEIXZ proc near
.text$mn:0000B378                                         ; CODE XREF: std::allocator_traits<std::allocator<PluginCmdShortcut>>::max_size(std::allocator<PluginCmdShortcut> const &)+6p
.text$mn:0000B378
.text$mn:0000B378 var_4           = dword ptr -4
.text$mn:0000B378
.text$mn:0000B378                 push    ebp
.text$mn:0000B379                 mov     ebp, esp
.text$mn:0000B37B                 push    ecx
.text$mn:0000B37C                 mov     [ebp+var_4], ecx
.text$mn:0000B37F                 mov     eax, 0C30C30h
.text$mn:0000B384                 mov     esp, ebp
.text$mn:0000B386                 pop     ebp
.text$mn:0000B387                 retn
.text$mn:0000B387 ?max_size@?$allocator@VPluginCmdShortcut@@@std@@QBEIXZ endp
.text$mn:0000B387
.text$mn:0000B387 _text$mn        ends
.text$mn:0000B387
.text$mn:0000B388 ; ===========================================================================
.text$mn:0000B388
.text$mn:0000B388 ; Segment type: Pure code
.text$mn:0000B388 ; Segment permissions: Read/Execute
.text$mn:0000B388 _text$mn        segment para public 'CODE' use32
.text$mn:0000B388                 assume cs:_text$mn
.text$mn:0000B388                 ;org 0B388h
.text$mn:0000B388 ; COMDAT (pick any)
.text$mn:0000B388                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B388
.text$mn:0000B388 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B388
.text$mn:0000B388 ; Attributes: bp-based frame
.text$mn:0000B388
.text$mn:0000B388 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:0000B388                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:0000B388 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:0000B388                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:0000B388
.text$mn:0000B388 var_4           = dword ptr -4
.text$mn:0000B388
.text$mn:0000B388                 push    ebp
.text$mn:0000B389                 mov     ebp, esp
.text$mn:0000B38B                 push    ecx
.text$mn:0000B38C                 mov     [ebp+var_4], ecx
.text$mn:0000B38F                 mov     eax, 7FFFFFFFh
.text$mn:0000B394                 mov     esp, ebp
.text$mn:0000B396                 pop     ebp
.text$mn:0000B397                 retn
.text$mn:0000B397 ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:0000B397
.text$mn:0000B397 _text$mn        ends
.text$mn:0000B397
.text$mn:0000B398 ; ===========================================================================
.text$mn:0000B398
.text$mn:0000B398 ; Segment type: Pure code
.text$mn:0000B398 ; Segment permissions: Read/Execute
.text$mn:0000B398 _text$mn        segment para public 'CODE' use32
.text$mn:0000B398                 assume cs:_text$mn
.text$mn:0000B398                 ;org 0B398h
.text$mn:0000B398 ; COMDAT (pick any)
.text$mn:0000B398                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B398
.text$mn:0000B398 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B398
.text$mn:0000B398 ; Attributes: bp-based frame
.text$mn:0000B398
.text$mn:0000B398 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000B398                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000B398 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000B398                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000B398
.text$mn:0000B398 arg_0           = dword ptr  8
.text$mn:0000B398
.text$mn:0000B398                 push    ebp
.text$mn:0000B399                 mov     ebp, esp
.text$mn:0000B39B                 mov     ecx, [ebp+arg_0]
.text$mn:0000B39E                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000B3A3                 pop     ebp
.text$mn:0000B3A4                 retn
.text$mn:0000B3A4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:0000B3A4
.text$mn:0000B3A4 ; ---------------------------------------------------------------------------
.text$mn:0000B3A5                 align 4
.text$mn:0000B3A5 _text$mn        ends
.text$mn:0000B3A5
.text$mn:0000B3A8 ; ===========================================================================
.text$mn:0000B3A8
.text$mn:0000B3A8 ; Segment type: Pure code
.text$mn:0000B3A8 ; Segment permissions: Read/Execute
.text$mn:0000B3A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B3A8                 assume cs:_text$mn
.text$mn:0000B3A8                 ;org 0B3A8h
.text$mn:0000B3A8 ; COMDAT (pick any)
.text$mn:0000B3A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B3A8
.text$mn:0000B3A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3A8
.text$mn:0000B3A8 ; Attributes: bp-based frame
.text$mn:0000B3A8
.text$mn:0000B3A8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct PluginInfo *>>::max_size(class std::allocator<struct PluginInfo *> const &)
.text$mn:0000B3A8                 public ?max_size@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAIABV?$allocator@PAUPluginInfo@@@2@@Z
.text$mn:0000B3A8 ?max_size@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAIABV?$allocator@PAUPluginInfo@@@2@@Z proc near
.text$mn:0000B3A8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginInfo *>>::max_size(void)+Bp
.text$mn:0000B3A8
.text$mn:0000B3A8 arg_0           = dword ptr  8
.text$mn:0000B3A8
.text$mn:0000B3A8                 push    ebp
.text$mn:0000B3A9                 mov     ebp, esp
.text$mn:0000B3AB                 mov     ecx, [ebp+arg_0]
.text$mn:0000B3AE                 call    ?max_size@?$allocator@PAUPluginInfo@@@std@@QBEIXZ ; std::allocator<PluginInfo *>::max_size(void)
.text$mn:0000B3B3                 pop     ebp
.text$mn:0000B3B4                 retn
.text$mn:0000B3B4 ?max_size@?$allocator_traits@V?$allocator@PAUPluginInfo@@@std@@@std@@SAIABV?$allocator@PAUPluginInfo@@@2@@Z endp
.text$mn:0000B3B4
.text$mn:0000B3B4 ; ---------------------------------------------------------------------------
.text$mn:0000B3B5                 align 4
.text$mn:0000B3B5 _text$mn        ends
.text$mn:0000B3B5
.text$mn:0000B3B8 ; ===========================================================================
.text$mn:0000B3B8
.text$mn:0000B3B8 ; Segment type: Pure code
.text$mn:0000B3B8 ; Segment permissions: Read/Execute
.text$mn:0000B3B8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B3B8                 assume cs:_text$mn
.text$mn:0000B3B8                 ;org 0B3B8h
.text$mn:0000B3B8 ; COMDAT (pick any)
.text$mn:0000B3B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B3B8
.text$mn:0000B3B8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3B8
.text$mn:0000B3B8 ; Attributes: bp-based frame
.text$mn:0000B3B8
.text$mn:0000B3B8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class TiXmlDocument *>>::max_size(class std::allocator<class TiXmlDocument *> const &)
.text$mn:0000B3B8                 public ?max_size@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAIABV?$allocator@PAVTiXmlDocument@@@2@@Z
.text$mn:0000B3B8 ?max_size@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAIABV?$allocator@PAVTiXmlDocument@@@2@@Z proc near
.text$mn:0000B3B8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::max_size(void)+Bp
.text$mn:0000B3B8
.text$mn:0000B3B8 arg_0           = dword ptr  8
.text$mn:0000B3B8
.text$mn:0000B3B8                 push    ebp
.text$mn:0000B3B9                 mov     ebp, esp
.text$mn:0000B3BB                 mov     ecx, [ebp+arg_0]
.text$mn:0000B3BE                 call    ?max_size@?$allocator@PAVTiXmlDocument@@@std@@QBEIXZ ; std::allocator<TiXmlDocument *>::max_size(void)
.text$mn:0000B3C3                 pop     ebp
.text$mn:0000B3C4                 retn
.text$mn:0000B3C4 ?max_size@?$allocator_traits@V?$allocator@PAVTiXmlDocument@@@std@@@std@@SAIABV?$allocator@PAVTiXmlDocument@@@2@@Z endp
.text$mn:0000B3C4
.text$mn:0000B3C4 ; ---------------------------------------------------------------------------
.text$mn:0000B3C5                 align 4
.text$mn:0000B3C5 _text$mn        ends
.text$mn:0000B3C5
.text$mn:0000B3C8 ; ===========================================================================
.text$mn:0000B3C8
.text$mn:0000B3C8 ; Segment type: Pure code
.text$mn:0000B3C8 ; Segment permissions: Read/Execute
.text$mn:0000B3C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B3C8                 assume cs:_text$mn
.text$mn:0000B3C8                 ;org 0B3C8h
.text$mn:0000B3C8 ; COMDAT (pick any)
.text$mn:0000B3C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B3C8
.text$mn:0000B3C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3C8
.text$mn:0000B3C8 ; Attributes: bp-based frame
.text$mn:0000B3C8
.text$mn:0000B3C8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::max_size(class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>> const &)
.text$mn:0000B3C8                 public ?max_size@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAIABV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@Z
.text$mn:0000B3C8 ?max_size@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAIABV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@Z proc near
.text$mn:0000B3C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::max_size(void)+Bp
.text$mn:0000B3C8
.text$mn:0000B3C8 arg_0           = dword ptr  8
.text$mn:0000B3C8
.text$mn:0000B3C8                 push    ebp
.text$mn:0000B3C9                 mov     ebp, esp
.text$mn:0000B3CB                 mov     ecx, [ebp+arg_0]
.text$mn:0000B3CE                 call    ?max_size@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QBEIXZ ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>::max_size(void)
.text$mn:0000B3D3                 pop     ebp
.text$mn:0000B3D4                 retn
.text$mn:0000B3D4 ?max_size@?$allocator_traits@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAIABV?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@Z endp
.text$mn:0000B3D4
.text$mn:0000B3D4 ; ---------------------------------------------------------------------------
.text$mn:0000B3D5                 align 4
.text$mn:0000B3D5 _text$mn        ends
.text$mn:0000B3D5
.text$mn:0000B3D8 ; ===========================================================================
.text$mn:0000B3D8
.text$mn:0000B3D8 ; Segment type: Pure code
.text$mn:0000B3D8 ; Segment permissions: Read/Execute
.text$mn:0000B3D8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B3D8                 assume cs:_text$mn
.text$mn:0000B3D8                 ;org 0B3D8h
.text$mn:0000B3D8 ; COMDAT (pick any)
.text$mn:0000B3D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B3D8
.text$mn:0000B3D8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3D8
.text$mn:0000B3D8 ; Attributes: bp-based frame
.text$mn:0000B3D8
.text$mn:0000B3D8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct PluginCommand>>::max_size(class std::allocator<struct PluginCommand> const &)
.text$mn:0000B3D8                 public ?max_size@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAIABV?$allocator@UPluginCommand@@@2@@Z
.text$mn:0000B3D8 ?max_size@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAIABV?$allocator@UPluginCommand@@@2@@Z proc near
.text$mn:0000B3D8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCommand>>::max_size(void)+Bp
.text$mn:0000B3D8
.text$mn:0000B3D8 arg_0           = dword ptr  8
.text$mn:0000B3D8
.text$mn:0000B3D8                 push    ebp
.text$mn:0000B3D9                 mov     ebp, esp
.text$mn:0000B3DB                 mov     ecx, [ebp+arg_0]
.text$mn:0000B3DE                 call    ?max_size@?$allocator@UPluginCommand@@@std@@QBEIXZ ; std::allocator<PluginCommand>::max_size(void)
.text$mn:0000B3E3                 pop     ebp
.text$mn:0000B3E4                 retn
.text$mn:0000B3E4 ?max_size@?$allocator_traits@V?$allocator@UPluginCommand@@@std@@@std@@SAIABV?$allocator@UPluginCommand@@@2@@Z endp
.text$mn:0000B3E4
.text$mn:0000B3E4 ; ---------------------------------------------------------------------------
.text$mn:0000B3E5                 align 4
.text$mn:0000B3E5 _text$mn        ends
.text$mn:0000B3E5
.text$mn:0000B3E8 ; ===========================================================================
.text$mn:0000B3E8
.text$mn:0000B3E8 ; Segment type: Pure code
.text$mn:0000B3E8 ; Segment permissions: Read/Execute
.text$mn:0000B3E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B3E8                 assume cs:_text$mn
.text$mn:0000B3E8                 ;org 0B3E8h
.text$mn:0000B3E8 ; COMDAT (pick any)
.text$mn:0000B3E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B3E8
.text$mn:0000B3E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3E8
.text$mn:0000B3E8 ; Attributes: bp-based frame
.text$mn:0000B3E8
.text$mn:0000B3E8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::max_size(class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>> const &)
.text$mn:0000B3E8                 public ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z
.text$mn:0000B3E8 ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z proc near
.text$mn:0000B3E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)+Bp
.text$mn:0000B3E8
.text$mn:0000B3E8 arg_0           = dword ptr  8
.text$mn:0000B3E8
.text$mn:0000B3E8                 push    ebp
.text$mn:0000B3E9                 mov     ebp, esp
.text$mn:0000B3EB                 mov     ecx, [ebp+arg_0]
.text$mn:0000B3EE                 call    ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>::max_size(void)
.text$mn:0000B3F3                 pop     ebp
.text$mn:0000B3F4                 retn
.text$mn:0000B3F4 ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z endp
.text$mn:0000B3F4
.text$mn:0000B3F4 ; ---------------------------------------------------------------------------
.text$mn:0000B3F5                 align 4
.text$mn:0000B3F5 _text$mn        ends
.text$mn:0000B3F5
.text$mn:0000B3F8 ; ===========================================================================
.text$mn:0000B3F8
.text$mn:0000B3F8 ; Segment type: Pure code
.text$mn:0000B3F8 ; Segment permissions: Read/Execute
.text$mn:0000B3F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B3F8                 assume cs:_text$mn
.text$mn:0000B3F8                 ;org 0B3F8h
.text$mn:0000B3F8 ; COMDAT (pick any)
.text$mn:0000B3F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B3F8
.text$mn:0000B3F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3F8
.text$mn:0000B3F8 ; Attributes: bp-based frame
.text$mn:0000B3F8
.text$mn:0000B3F8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class PluginCmdShortcut>>::max_size(class std::allocator<class PluginCmdShortcut> const &)
.text$mn:0000B3F8                 public ?max_size@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAIABV?$allocator@VPluginCmdShortcut@@@2@@Z
.text$mn:0000B3F8 ?max_size@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAIABV?$allocator@VPluginCmdShortcut@@@2@@Z proc near
.text$mn:0000B3F8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::max_size(void)+Bp
.text$mn:0000B3F8
.text$mn:0000B3F8 arg_0           = dword ptr  8
.text$mn:0000B3F8
.text$mn:0000B3F8                 push    ebp
.text$mn:0000B3F9                 mov     ebp, esp
.text$mn:0000B3FB                 mov     ecx, [ebp+arg_0]
.text$mn:0000B3FE                 call    ?max_size@?$allocator@VPluginCmdShortcut@@@std@@QBEIXZ ; std::allocator<PluginCmdShortcut>::max_size(void)
.text$mn:0000B403                 pop     ebp
.text$mn:0000B404                 retn
.text$mn:0000B404 ?max_size@?$allocator_traits@V?$allocator@VPluginCmdShortcut@@@std@@@std@@SAIABV?$allocator@VPluginCmdShortcut@@@2@@Z endp
.text$mn:0000B404
.text$mn:0000B404 ; ---------------------------------------------------------------------------
.text$mn:0000B405                 align 4
.text$mn:0000B405 _text$mn        ends
.text$mn:0000B405
.text$mn:0000B408 ; ===========================================================================
.text$mn:0000B408
.text$mn:0000B408 ; Segment type: Pure code
.text$mn:0000B408 ; Segment permissions: Read/Execute
.text$mn:0000B408 _text$mn        segment para public 'CODE' use32
.text$mn:0000B408                 assume cs:_text$mn
.text$mn:0000B408                 ;org 0B408h
.text$mn:0000B408 ; COMDAT (pick any)
.text$mn:0000B408                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B408
.text$mn:0000B408 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B408
.text$mn:0000B408 ; Attributes: bp-based frame
.text$mn:0000B408
.text$mn:0000B408 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:0000B408                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:0000B408 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:0000B408                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:0000B408
.text$mn:0000B408 arg_0           = dword ptr  8
.text$mn:0000B408
.text$mn:0000B408                 push    ebp
.text$mn:0000B409                 mov     ebp, esp
.text$mn:0000B40B                 mov     ecx, [ebp+arg_0]
.text$mn:0000B40E                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:0000B413                 pop     ebp
.text$mn:0000B414                 retn
.text$mn:0000B414 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:0000B414
.text$mn:0000B414 ; ---------------------------------------------------------------------------
.text$mn:0000B415                 align 4
.text$mn:0000B415 _text$mn        ends
.text$mn:0000B415
.text$mn:0000B418 ; ===========================================================================
.text$mn:0000B418
.text$mn:0000B418 ; Segment type: Pure code
.text$mn:0000B418 ; Segment permissions: Read/Execute
.text$mn:0000B418 _text$mn        segment para public 'CODE' use32
.text$mn:0000B418                 assume cs:_text$mn
.text$mn:0000B418                 ;org 0B418h
.text$mn:0000B418 ; COMDAT (pick any)
.text$mn:0000B418                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B418
.text$mn:0000B418 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B418
.text$mn:0000B418 ; Attributes: bp-based frame
.text$mn:0000B418
.text$mn:0000B418 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:0000B418                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000B418 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000B418                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:0000B418                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000B418
.text$mn:0000B418 var_10          = dword ptr -10h
.text$mn:0000B418 var_C           = dword ptr -0Ch
.text$mn:0000B418 var_8           = dword ptr -8
.text$mn:0000B418 var_1           = byte ptr -1
.text$mn:0000B418
.text$mn:0000B418                 push    ebp
.text$mn:0000B419                 mov     ebp, esp
.text$mn:0000B41B                 sub     esp, 10h
.text$mn:0000B41E                 mov     [ebp+var_10], ecx
.text$mn:0000B421                 lea     eax, [ebp+var_1]
.text$mn:0000B424                 push    eax
.text$mn:0000B425                 mov     ecx, [ebp+var_10]
.text$mn:0000B428                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000B42D                 mov     ecx, eax
.text$mn:0000B42F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:0000B434                 mov     [ebp+var_8], eax
.text$mn:0000B437                 cmp     [ebp+var_8], 1
.text$mn:0000B43B                 ja      short loc_B446
.text$mn:0000B43D                 mov     [ebp+var_C], 1
.text$mn:0000B444                 jmp     short loc_B44F
.text$mn:0000B446 ; ---------------------------------------------------------------------------
.text$mn:0000B446
.text$mn:0000B446 loc_B446:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000B446                 mov     ecx, [ebp+var_8]
.text$mn:0000B449                 sub     ecx, 1
.text$mn:0000B44C                 mov     [ebp+var_C], ecx
.text$mn:0000B44F
.text$mn:0000B44F loc_B44F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000B44F                 mov     eax, [ebp+var_C]
.text$mn:0000B452                 mov     esp, ebp
.text$mn:0000B454                 pop     ebp
.text$mn:0000B455                 retn
.text$mn:0000B455 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000B455
.text$mn:0000B455 ; ---------------------------------------------------------------------------
.text$mn:0000B456                 align 4
.text$mn:0000B456 _text$mn        ends
.text$mn:0000B456
.text$mn:0000B458 ; ===========================================================================
.text$mn:0000B458
.text$mn:0000B458 ; Segment type: Pure code
.text$mn:0000B458 ; Segment permissions: Read/Execute
.text$mn:0000B458 _text$mn        segment para public 'CODE' use32
.text$mn:0000B458                 assume cs:_text$mn
.text$mn:0000B458                 ;org 0B458h
.text$mn:0000B458 ; COMDAT (pick any)
.text$mn:0000B458                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B458
.text$mn:0000B458 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B458
.text$mn:0000B458 ; Attributes: bp-based frame
.text$mn:0000B458
.text$mn:0000B458 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000B458                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000B458 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000B458                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:0000B458                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000B458
.text$mn:0000B458 var_10          = dword ptr -10h
.text$mn:0000B458 var_C           = dword ptr -0Ch
.text$mn:0000B458 var_8           = dword ptr -8
.text$mn:0000B458 var_1           = byte ptr -1
.text$mn:0000B458
.text$mn:0000B458                 push    ebp
.text$mn:0000B459                 mov     ebp, esp
.text$mn:0000B45B                 sub     esp, 10h
.text$mn:0000B45E                 mov     [ebp+var_10], ecx
.text$mn:0000B461                 lea     eax, [ebp+var_1]
.text$mn:0000B464                 push    eax
.text$mn:0000B465                 mov     ecx, [ebp+var_10]
.text$mn:0000B468                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000B46D                 mov     ecx, eax
.text$mn:0000B46F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:0000B474                 mov     [ebp+var_8], eax
.text$mn:0000B477                 cmp     [ebp+var_8], 1
.text$mn:0000B47B                 ja      short loc_B486
.text$mn:0000B47D                 mov     [ebp+var_C], 1
.text$mn:0000B484                 jmp     short loc_B48F
.text$mn:0000B486 ; ---------------------------------------------------------------------------
.text$mn:0000B486
.text$mn:0000B486 loc_B486:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:0000B486                 mov     ecx, [ebp+var_8]
.text$mn:0000B489                 sub     ecx, 1
.text$mn:0000B48C                 mov     [ebp+var_C], ecx
.text$mn:0000B48F
.text$mn:0000B48F loc_B48F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:0000B48F                 mov     eax, [ebp+var_C]
.text$mn:0000B492                 mov     esp, ebp
.text$mn:0000B494                 pop     ebp
.text$mn:0000B495                 retn
.text$mn:0000B495 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000B495
.text$mn:0000B495 ; ---------------------------------------------------------------------------
.text$mn:0000B496                 align 4
.text$mn:0000B496 _text$mn        ends
.text$mn:0000B496
.text$mn:0000B498 ; ===========================================================================
.text$mn:0000B498
.text$mn:0000B498 ; Segment type: Pure code
.text$mn:0000B498 ; Segment permissions: Read/Execute
.text$mn:0000B498 _text$mn        segment para public 'CODE' use32
.text$mn:0000B498                 assume cs:_text$mn
.text$mn:0000B498                 ;org 0B498h
.text$mn:0000B498 ; COMDAT (pick any)
.text$mn:0000B498                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B498
.text$mn:0000B498 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B498
.text$mn:0000B498 ; Attributes: bp-based frame
.text$mn:0000B498
.text$mn:0000B498 ; public: unsigned int __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::max_size(void)const
.text$mn:0000B498                 public ?max_size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ
.text$mn:0000B498 ?max_size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B498                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Grow_to(uint)+17p
.text$mn:0000B498                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reserve(uint)+18p
.text$mn:0000B498
.text$mn:0000B498 var_8           = dword ptr -8
.text$mn:0000B498 var_1           = byte ptr -1
.text$mn:0000B498
.text$mn:0000B498                 push    ebp
.text$mn:0000B499                 mov     ebp, esp
.text$mn:0000B49B                 sub     esp, 8
.text$mn:0000B49E                 mov     [ebp+var_8], ecx
.text$mn:0000B4A1                 lea     eax, [ebp+var_1]
.text$mn:0000B4A4                 push    eax
.text$mn:0000B4A5                 mov     ecx, [ebp+var_8]
.text$mn:0000B4A8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginInfo *,std::allocator<PluginInfo *>>>::_Getal(void)
.text$mn:0000B4AD                 mov     ecx, eax
.text$mn:0000B4AF                 call    ?max_size@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<PluginInfo *>>::max_size(void)
.text$mn:0000B4B4                 mov     esp, ebp
.text$mn:0000B4B6                 pop     ebp
.text$mn:0000B4B7                 retn
.text$mn:0000B4B7 ?max_size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ endp
.text$mn:0000B4B7
.text$mn:0000B4B7 _text$mn        ends
.text$mn:0000B4B7
.text$mn:0000B4B8 ; ===========================================================================
.text$mn:0000B4B8
.text$mn:0000B4B8 ; Segment type: Pure code
.text$mn:0000B4B8 ; Segment permissions: Read/Execute
.text$mn:0000B4B8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B4B8                 assume cs:_text$mn
.text$mn:0000B4B8                 ;org 0B4B8h
.text$mn:0000B4B8 ; COMDAT (pick any)
.text$mn:0000B4B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B4B8
.text$mn:0000B4B8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B4B8
.text$mn:0000B4B8 ; Attributes: bp-based frame
.text$mn:0000B4B8
.text$mn:0000B4B8 ; public: unsigned int __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::max_size(void)const
.text$mn:0000B4B8                 public ?max_size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ
.text$mn:0000B4B8 ?max_size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B4B8                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Grow_to(uint)+17p
.text$mn:0000B4B8                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reserve(uint)+18p
.text$mn:0000B4B8
.text$mn:0000B4B8 var_8           = dword ptr -8
.text$mn:0000B4B8 var_1           = byte ptr -1
.text$mn:0000B4B8
.text$mn:0000B4B8                 push    ebp
.text$mn:0000B4B9                 mov     ebp, esp
.text$mn:0000B4BB                 sub     esp, 8
.text$mn:0000B4BE                 mov     [ebp+var_8], ecx
.text$mn:0000B4C1                 lea     eax, [ebp+var_1]
.text$mn:0000B4C4                 push    eax
.text$mn:0000B4C5                 mov     ecx, [ebp+var_8]
.text$mn:0000B4C8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TiXmlDocument *,std::allocator<TiXmlDocument *>>>::_Getal(void)
.text$mn:0000B4CD                 mov     ecx, eax
.text$mn:0000B4CF                 call    ?max_size@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::max_size(void)
.text$mn:0000B4D4                 mov     esp, ebp
.text$mn:0000B4D6                 pop     ebp
.text$mn:0000B4D7                 retn
.text$mn:0000B4D7 ?max_size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ endp
.text$mn:0000B4D7
.text$mn:0000B4D7 _text$mn        ends
.text$mn:0000B4D7
.text$mn:0000B4D8 ; ===========================================================================
.text$mn:0000B4D8
.text$mn:0000B4D8 ; Segment type: Pure code
.text$mn:0000B4D8 ; Segment permissions: Read/Execute
.text$mn:0000B4D8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B4D8                 assume cs:_text$mn
.text$mn:0000B4D8                 ;org 0B4D8h
.text$mn:0000B4D8 ; COMDAT (pick any)
.text$mn:0000B4D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B4D8
.text$mn:0000B4D8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B4D8
.text$mn:0000B4D8 ; Attributes: bp-based frame
.text$mn:0000B4D8
.text$mn:0000B4D8 ; public: unsigned int __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::max_size(void)const
.text$mn:0000B4D8                 public ?max_size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ
.text$mn:0000B4D8 ?max_size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000B4D8                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Grow_to(uint)+17p
.text$mn:0000B4D8                                         ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reserve(uint)+18p
.text$mn:0000B4D8
.text$mn:0000B4D8 var_8           = dword ptr -8
.text$mn:0000B4D8 var_1           = byte ptr -1
.text$mn:0000B4D8
.text$mn:0000B4D8                 push    ebp
.text$mn:0000B4D9                 mov     ebp, esp
.text$mn:0000B4DB                 sub     esp, 8
.text$mn:0000B4DE                 mov     [ebp+var_8], ecx
.text$mn:0000B4E1                 lea     eax, [ebp+var_1]
.text$mn:0000B4E4                 push    eax
.text$mn:0000B4E5                 mov     ecx, [ebp+var_8]
.text$mn:0000B4E8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>::_Getal(void)
.text$mn:0000B4ED                 mov     ecx, eax
.text$mn:0000B4EF                 call    ?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::max_size(void)
.text$mn:0000B4F4                 mov     esp, ebp
.text$mn:0000B4F6                 pop     ebp
.text$mn:0000B4F7                 retn
.text$mn:0000B4F7 ?max_size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ endp
.text$mn:0000B4F7
.text$mn:0000B4F7 _text$mn        ends
.text$mn:0000B4F7
.text$mn:0000B4F8 ; ===========================================================================
.text$mn:0000B4F8
.text$mn:0000B4F8 ; Segment type: Pure code
.text$mn:0000B4F8 ; Segment permissions: Read/Execute
.text$mn:0000B4F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B4F8                 assume cs:_text$mn
.text$mn:0000B4F8                 ;org 0B4F8h
.text$mn:0000B4F8 ; COMDAT (pick any)
.text$mn:0000B4F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B4F8
.text$mn:0000B4F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B4F8
.text$mn:0000B4F8 ; Attributes: bp-based frame
.text$mn:0000B4F8
.text$mn:0000B4F8 ; public: unsigned int __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::max_size(void)const
.text$mn:0000B4F8                 public ?max_size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ
.text$mn:0000B4F8 ?max_size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B4F8                                         ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::_Grow_to(uint)+17p
.text$mn:0000B4F8                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reserve(uint)+18p
.text$mn:0000B4F8
.text$mn:0000B4F8 var_8           = dword ptr -8
.text$mn:0000B4F8 var_1           = byte ptr -1
.text$mn:0000B4F8
.text$mn:0000B4F8                 push    ebp
.text$mn:0000B4F9                 mov     ebp, esp
.text$mn:0000B4FB                 sub     esp, 8
.text$mn:0000B4FE                 mov     [ebp+var_8], ecx
.text$mn:0000B501                 lea     eax, [ebp+var_1]
.text$mn:0000B504                 push    eax
.text$mn:0000B505                 mov     ecx, [ebp+var_8]
.text$mn:0000B508                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCommand,std::allocator<PluginCommand>>>::_Getal(void)
.text$mn:0000B50D                 mov     ecx, eax
.text$mn:0000B50F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<PluginCommand>>::max_size(void)
.text$mn:0000B514                 mov     esp, ebp
.text$mn:0000B516                 pop     ebp
.text$mn:0000B517                 retn
.text$mn:0000B517 ?max_size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ endp
.text$mn:0000B517
.text$mn:0000B517 _text$mn        ends
.text$mn:0000B517
.text$mn:0000B518 ; ===========================================================================
.text$mn:0000B518
.text$mn:0000B518 ; Segment type: Pure code
.text$mn:0000B518 ; Segment permissions: Read/Execute
.text$mn:0000B518 _text$mn        segment para public 'CODE' use32
.text$mn:0000B518                 assume cs:_text$mn
.text$mn:0000B518                 ;org 0B518h
.text$mn:0000B518 ; COMDAT (pick any)
.text$mn:0000B518                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B518
.text$mn:0000B518 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B518
.text$mn:0000B518 ; Attributes: bp-based frame
.text$mn:0000B518
.text$mn:0000B518 ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::max_size(void)const
.text$mn:0000B518                 public ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:0000B518 ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000B518                                         ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Grow_to(uint)+17p
.text$mn:0000B518                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)+18p
.text$mn:0000B518
.text$mn:0000B518 var_8           = dword ptr -8
.text$mn:0000B518 var_1           = byte ptr -1
.text$mn:0000B518
.text$mn:0000B518                 push    ebp
.text$mn:0000B519                 mov     ebp, esp
.text$mn:0000B51B                 sub     esp, 8
.text$mn:0000B51E                 mov     [ebp+var_8], ecx
.text$mn:0000B521                 lea     eax, [ebp+var_1]
.text$mn:0000B524                 push    eax
.text$mn:0000B525                 mov     ecx, [ebp+var_8]
.text$mn:0000B528                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000B52D                 mov     ecx, eax
.text$mn:0000B52F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::max_size(void)
.text$mn:0000B534                 mov     esp, ebp
.text$mn:0000B536                 pop     ebp
.text$mn:0000B537                 retn
.text$mn:0000B537 ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:0000B537
.text$mn:0000B537 _text$mn        ends
.text$mn:0000B537
.text$mn:0000B538 ; ===========================================================================
.text$mn:0000B538
.text$mn:0000B538 ; Segment type: Pure code
.text$mn:0000B538 ; Segment permissions: Read/Execute
.text$mn:0000B538 _text$mn        segment para public 'CODE' use32
.text$mn:0000B538                 assume cs:_text$mn
.text$mn:0000B538                 ;org 0B538h
.text$mn:0000B538 ; COMDAT (pick any)
.text$mn:0000B538                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B538
.text$mn:0000B538 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B538
.text$mn:0000B538 ; Attributes: bp-based frame
.text$mn:0000B538
.text$mn:0000B538 ; public: unsigned int __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::max_size(void)const
.text$mn:0000B538                 public ?max_size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ
.text$mn:0000B538 ?max_size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B538                                         ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Grow_to(uint)+17p
.text$mn:0000B538                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reserve(uint)+18p
.text$mn:0000B538
.text$mn:0000B538 var_8           = dword ptr -8
.text$mn:0000B538 var_1           = byte ptr -1
.text$mn:0000B538
.text$mn:0000B538                 push    ebp
.text$mn:0000B539                 mov     ebp, esp
.text$mn:0000B53B                 sub     esp, 8
.text$mn:0000B53E                 mov     [ebp+var_8], ecx
.text$mn:0000B541                 lea     eax, [ebp+var_1]
.text$mn:0000B544                 push    eax
.text$mn:0000B545                 mov     ecx, [ebp+var_8]
.text$mn:0000B548                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>>::_Getal(void)
.text$mn:0000B54D                 mov     ecx, eax
.text$mn:0000B54F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::max_size(void)
.text$mn:0000B554                 mov     esp, ebp
.text$mn:0000B556                 pop     ebp
.text$mn:0000B557                 retn
.text$mn:0000B557 ?max_size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ endp
.text$mn:0000B557
.text$mn:0000B557 _text$mn        ends
.text$mn:0000B557
.text$mn:0000B558 ; ===========================================================================
.text$mn:0000B558
.text$mn:0000B558 ; Segment type: Pure code
.text$mn:0000B558 ; Segment permissions: Read/Execute
.text$mn:0000B558 _text$mn        segment para public 'CODE' use32
.text$mn:0000B558                 assume cs:_text$mn
.text$mn:0000B558                 ;org 0B558h
.text$mn:0000B558 ; COMDAT (pick any)
.text$mn:0000B558                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B558
.text$mn:0000B558 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B558
.text$mn:0000B558 ; Attributes: bp-based frame
.text$mn:0000B558
.text$mn:0000B558 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000B558                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000B558 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000B558                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000B558                                         ; DATA XREF: .rdata:0000D9E0o
.text$mn:0000B558
.text$mn:0000B558 var_1C          = dword ptr -1Ch
.text$mn:0000B558 var_18          = dword ptr -18h
.text$mn:0000B558 Str             = dword ptr -14h
.text$mn:0000B558 var_10          = dword ptr -10h
.text$mn:0000B558 var_C           = dword ptr -0Ch
.text$mn:0000B558 var_4           = dword ptr -4
.text$mn:0000B558 arg_0           = dword ptr  8
.text$mn:0000B558 arg_4           = dword ptr  0Ch
.text$mn:0000B558
.text$mn:0000B558                 push    ebp
.text$mn:0000B559                 mov     ebp, esp
.text$mn:0000B55B                 push    0FFFFFFFFh
.text$mn:0000B55D                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000B562                 mov     eax, large fs:0
.text$mn:0000B568                 push    eax
.text$mn:0000B569                 sub     esp, 10h
.text$mn:0000B56C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B571                 xor     eax, ebp
.text$mn:0000B573                 push    eax
.text$mn:0000B574                 lea     eax, [ebp+var_C]
.text$mn:0000B577                 mov     large fs:0, eax
.text$mn:0000B57D                 mov     [ebp+var_1C], ecx
.text$mn:0000B580                 mov     [ebp+var_18], 0
.text$mn:0000B587                 mov     eax, [ebp+arg_4]
.text$mn:0000B58A                 push    eax             ; int
.text$mn:0000B58B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000B590                 add     esp, 4
.text$mn:0000B593                 mov     [ebp+var_10], eax
.text$mn:0000B596                 cmp     [ebp+var_10], 0
.text$mn:0000B59A                 jz      short loc_B5A4
.text$mn:0000B59C                 mov     ecx, [ebp+var_10]
.text$mn:0000B59F                 mov     [ebp+Str], ecx
.text$mn:0000B5A2                 jmp     short loc_B5AB
.text$mn:0000B5A4 ; ---------------------------------------------------------------------------
.text$mn:0000B5A4
.text$mn:0000B5A4 loc_B5A4:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:0000B5A4                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000B5AB
.text$mn:0000B5AB loc_B5AB:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000B5AB                 mov     edx, [ebp+Str]
.text$mn:0000B5AE                 push    edx             ; Str
.text$mn:0000B5AF                 mov     ecx, [ebp+arg_0]
.text$mn:0000B5B2                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000B5B7                 mov     [ebp+var_4], 0
.text$mn:0000B5BE                 mov     eax, [ebp+var_18]
.text$mn:0000B5C1                 or      eax, 1
.text$mn:0000B5C4                 mov     [ebp+var_18], eax
.text$mn:0000B5C7                 mov     eax, [ebp+arg_0]
.text$mn:0000B5CA                 mov     ecx, [ebp+var_C]
.text$mn:0000B5CD                 mov     large fs:0, ecx
.text$mn:0000B5D4                 pop     ecx
.text$mn:0000B5D5                 mov     esp, ebp
.text$mn:0000B5D7                 pop     ebp
.text$mn:0000B5D8                 retn    8
.text$mn:0000B5D8 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000B5D8
.text$mn:0000B5D8 ; ---------------------------------------------------------------------------
.text$mn:0000B5DB                 align 4
.text$mn:0000B5DB _text$mn        ends
.text$mn:0000B5DB
.text$x:0000B5DC ; ===========================================================================
.text$x:0000B5DC
.text$x:0000B5DC ; Segment type: Pure code
.text$x:0000B5DC ; Segment permissions: Read/Execute
.text$x:0000B5DC _text$x         segment para public 'CODE' use32
.text$x:0000B5DC                 assume cs:_text$x
.text$x:0000B5DC                 ;org 0B5DCh
.text$x:0000B5DC ; COMDAT (pick associative to section at B558)
.text$x:0000B5DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000B5DC
.text$x:0000B5DC ; =============== S U B R O U T I N E =======================================
.text$x:0000B5DC
.text$x:0000B5DC
.text$x:0000B5DC __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000B5DC                                         ; DATA XREF: .xdata$x:0000C588o
.text$x:0000B5DC                 mov     eax, [ebp-18h]
.text$x:0000B5DF                 and     eax, 1
.text$x:0000B5E2                 jz      $LN6
.text$x:0000B5E8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000B5EC                 mov     ecx, [ebp+8]
.text$x:0000B5EF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000B5F4 ; ---------------------------------------------------------------------------
.text$x:0000B5F4
.text$x:0000B5F4 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000B5F4                 retn
.text$x:0000B5F4 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000B5F4
.text$x:0000B5F5
.text$x:0000B5F5 ; =============== S U B R O U T I N E =======================================
.text$x:0000B5F5
.text$x:0000B5F5
.text$x:0000B5F5 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000B5F5                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:0000B5F5
.text$x:0000B5F5 arg_4           = dword ptr  8
.text$x:0000B5F5
.text$x:0000B5F5                 mov     edx, [esp+arg_4]
.text$x:0000B5F9                 lea     eax, [edx+0Ch]
.text$x:0000B5FC                 mov     ecx, [edx-14h]
.text$x:0000B5FF                 xor     ecx, eax
.text$x:0000B601                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B606                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000B60B                 jmp     ___CxxFrameHandler3
.text$x:0000B60B __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000B60B
.text$x:0000B60B _text$x         ends
.text$x:0000B60B
.text$mn:0000B610 ; ===========================================================================
.text$mn:0000B610
.text$mn:0000B610 ; Segment type: Pure code
.text$mn:0000B610 ; Segment permissions: Read/Execute
.text$mn:0000B610 _text$mn        segment para public 'CODE' use32
.text$mn:0000B610                 assume cs:_text$mn
.text$mn:0000B610                 ;org 0B610h
.text$mn:0000B610 ; COMDAT (pick any)
.text$mn:0000B610                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B610
.text$mn:0000B610 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B610
.text$mn:0000B610 ; Attributes: bp-based frame
.text$mn:0000B610
.text$mn:0000B610 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:0000B610                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000B610 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000B610                                         ; DATA XREF: .rdata:0000DA14o
.text$mn:0000B610
.text$mn:0000B610 var_14          = dword ptr -14h
.text$mn:0000B610 var_10          = dword ptr -10h
.text$mn:0000B610 var_C           = dword ptr -0Ch
.text$mn:0000B610 var_4           = dword ptr -4
.text$mn:0000B610 arg_0           = dword ptr  8
.text$mn:0000B610 arg_4           = dword ptr  0Ch
.text$mn:0000B610
.text$mn:0000B610                 push    ebp
.text$mn:0000B611                 mov     ebp, esp
.text$mn:0000B613                 push    0FFFFFFFFh
.text$mn:0000B615                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000B61A                 mov     eax, large fs:0
.text$mn:0000B620                 push    eax
.text$mn:0000B621                 sub     esp, 8
.text$mn:0000B624                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B629                 xor     eax, ebp
.text$mn:0000B62B                 push    eax
.text$mn:0000B62C                 lea     eax, [ebp+var_C]
.text$mn:0000B62F                 mov     large fs:0, eax
.text$mn:0000B635                 mov     [ebp+var_14], ecx
.text$mn:0000B638                 mov     [ebp+var_10], 0
.text$mn:0000B63F                 cmp     [ebp+arg_4], 1
.text$mn:0000B643                 jnz     short loc_B669
.text$mn:0000B645                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000B64A                 mov     ecx, [ebp+arg_0]
.text$mn:0000B64D                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000B652                 mov     [ebp+var_4], 0
.text$mn:0000B659                 mov     eax, [ebp+var_10]
.text$mn:0000B65C                 or      eax, 1
.text$mn:0000B65F                 mov     [ebp+var_10], eax
.text$mn:0000B662                 mov     eax, [ebp+arg_0]
.text$mn:0000B665                 jmp     short loc_B68C
.text$mn:0000B667 ; ---------------------------------------------------------------------------
.text$mn:0000B667                 jmp     short loc_B68C
.text$mn:0000B669 ; ---------------------------------------------------------------------------
.text$mn:0000B669
.text$mn:0000B669 loc_B669:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000B669                 mov     ecx, [ebp+arg_4]
.text$mn:0000B66C                 push    ecx
.text$mn:0000B66D                 mov     edx, [ebp+arg_0]
.text$mn:0000B670                 push    edx
.text$mn:0000B671                 mov     ecx, [ebp+var_14]
.text$mn:0000B674                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000B679                 mov     [ebp+var_4], 0
.text$mn:0000B680                 mov     eax, [ebp+var_10]
.text$mn:0000B683                 or      eax, 1
.text$mn:0000B686                 mov     [ebp+var_10], eax
.text$mn:0000B689                 mov     eax, [ebp+arg_0]
.text$mn:0000B68C
.text$mn:0000B68C loc_B68C:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:0000B68C                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:0000B68C                 mov     ecx, [ebp+var_C]
.text$mn:0000B68F                 mov     large fs:0, ecx
.text$mn:0000B696                 pop     ecx
.text$mn:0000B697                 mov     esp, ebp
.text$mn:0000B699                 pop     ebp
.text$mn:0000B69A                 retn    8
.text$mn:0000B69A ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000B69A
.text$mn:0000B69A ; ---------------------------------------------------------------------------
.text$mn:0000B69D                 align 10h
.text$mn:0000B69D _text$mn        ends
.text$mn:0000B69D
.text$x:0000B6A0 ; ===========================================================================
.text$x:0000B6A0
.text$x:0000B6A0 ; Segment type: Pure code
.text$x:0000B6A0 ; Segment permissions: Read/Execute
.text$x:0000B6A0 _text$x         segment para public 'CODE' use32
.text$x:0000B6A0                 assume cs:_text$x
.text$x:0000B6A0                 ;org 0B6A0h
.text$x:0000B6A0 ; COMDAT (pick associative to section at B610)
.text$x:0000B6A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000B6A0
.text$x:0000B6A0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B6A0
.text$x:0000B6A0
.text$x:0000B6A0 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000B6A0                                         ; DATA XREF: .xdata$x:0000C60Co
.text$x:0000B6A0                 mov     eax, [ebp-10h]
.text$x:0000B6A3                 and     eax, 1
.text$x:0000B6A6                 jz      $LN6_0
.text$x:0000B6AC                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000B6B0                 mov     ecx, [ebp+8]
.text$x:0000B6B3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000B6B8 ; ---------------------------------------------------------------------------
.text$x:0000B6B8
.text$x:0000B6B8 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000B6B8                 retn
.text$x:0000B6B8 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000B6B8
.text$x:0000B6B9
.text$x:0000B6B9 ; =============== S U B R O U T I N E =======================================
.text$x:0000B6B9
.text$x:0000B6B9
.text$x:0000B6B9 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000B6B9                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:0000B6B9
.text$x:0000B6B9 arg_4           = dword ptr  8
.text$x:0000B6B9
.text$x:0000B6B9                 mov     edx, [esp+arg_4]
.text$x:0000B6BD                 lea     eax, [edx+0Ch]
.text$x:0000B6C0                 mov     ecx, [edx-0Ch]
.text$x:0000B6C3                 xor     ecx, eax
.text$x:0000B6C5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B6CA                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000B6CF                 jmp     ___CxxFrameHandler3
.text$x:0000B6CF __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000B6CF
.text$x:0000B6CF _text$x         ends
.text$x:0000B6CF
.text$mn:0000B6D4 ; ===========================================================================
.text$mn:0000B6D4
.text$mn:0000B6D4 ; Segment type: Pure code
.text$mn:0000B6D4 ; Segment permissions: Read/Execute
.text$mn:0000B6D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B6D4                 assume cs:_text$mn
.text$mn:0000B6D4                 ;org 0B6D4h
.text$mn:0000B6D4 ; COMDAT (pick any)
.text$mn:0000B6D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B6D4
.text$mn:0000B6D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B6D4
.text$mn:0000B6D4 ; Attributes: bp-based frame
.text$mn:0000B6D4
.text$mn:0000B6D4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:0000B6D4                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000B6D4 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000B6D4                                         ; DATA XREF: .rdata:0000DA54o
.text$mn:0000B6D4
.text$mn:0000B6D4 var_1C          = dword ptr -1Ch
.text$mn:0000B6D4 var_18          = dword ptr -18h
.text$mn:0000B6D4 Str             = dword ptr -14h
.text$mn:0000B6D4 var_10          = dword ptr -10h
.text$mn:0000B6D4 var_C           = dword ptr -0Ch
.text$mn:0000B6D4 var_4           = dword ptr -4
.text$mn:0000B6D4 arg_0           = dword ptr  8
.text$mn:0000B6D4 arg_4           = dword ptr  0Ch
.text$mn:0000B6D4
.text$mn:0000B6D4                 push    ebp
.text$mn:0000B6D5                 mov     ebp, esp
.text$mn:0000B6D7                 push    0FFFFFFFFh
.text$mn:0000B6D9                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000B6DE                 mov     eax, large fs:0
.text$mn:0000B6E4                 push    eax
.text$mn:0000B6E5                 sub     esp, 10h
.text$mn:0000B6E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B6ED                 xor     eax, ebp
.text$mn:0000B6EF                 push    eax
.text$mn:0000B6F0                 lea     eax, [ebp+var_C]
.text$mn:0000B6F3                 mov     large fs:0, eax
.text$mn:0000B6F9                 mov     [ebp+var_1C], ecx
.text$mn:0000B6FC                 mov     [ebp+var_18], 0
.text$mn:0000B703                 mov     eax, [ebp+arg_4]
.text$mn:0000B706                 push    eax             ; int
.text$mn:0000B707                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:0000B70C                 add     esp, 4
.text$mn:0000B70F                 mov     [ebp+var_10], eax
.text$mn:0000B712                 cmp     [ebp+var_10], 0
.text$mn:0000B716                 jz      short loc_B720
.text$mn:0000B718                 mov     ecx, [ebp+var_10]
.text$mn:0000B71B                 mov     [ebp+Str], ecx
.text$mn:0000B71E                 jmp     short loc_B727
.text$mn:0000B720 ; ---------------------------------------------------------------------------
.text$mn:0000B720
.text$mn:0000B720 loc_B720:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:0000B720                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000B727
.text$mn:0000B727 loc_B727:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000B727                 mov     edx, [ebp+Str]
.text$mn:0000B72A                 push    edx             ; Str
.text$mn:0000B72B                 mov     ecx, [ebp+arg_0]
.text$mn:0000B72E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000B733                 mov     [ebp+var_4], 0
.text$mn:0000B73A                 mov     eax, [ebp+var_18]
.text$mn:0000B73D                 or      eax, 1
.text$mn:0000B740                 mov     [ebp+var_18], eax
.text$mn:0000B743                 mov     eax, [ebp+arg_0]
.text$mn:0000B746                 mov     ecx, [ebp+var_C]
.text$mn:0000B749                 mov     large fs:0, ecx
.text$mn:0000B750                 pop     ecx
.text$mn:0000B751                 mov     esp, ebp
.text$mn:0000B753                 pop     ebp
.text$mn:0000B754                 retn    8
.text$mn:0000B754 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000B754
.text$mn:0000B754 ; ---------------------------------------------------------------------------
.text$mn:0000B757                 align 4
.text$mn:0000B757 _text$mn        ends
.text$mn:0000B757
.text$x:0000B758 ; ===========================================================================
.text$x:0000B758
.text$x:0000B758 ; Segment type: Pure code
.text$x:0000B758 ; Segment permissions: Read/Execute
.text$x:0000B758 _text$x         segment para public 'CODE' use32
.text$x:0000B758                 assume cs:_text$x
.text$x:0000B758                 ;org 0B758h
.text$x:0000B758 ; COMDAT (pick associative to section at B6D4)
.text$x:0000B758                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000B758
.text$x:0000B758 ; =============== S U B R O U T I N E =======================================
.text$x:0000B758
.text$x:0000B758
.text$x:0000B758 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000B758                                         ; DATA XREF: .xdata$x:0000C690o
.text$x:0000B758                 mov     eax, [ebp-18h]
.text$x:0000B75B                 and     eax, 1
.text$x:0000B75E                 jz      $LN6_1
.text$x:0000B764                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000B768                 mov     ecx, [ebp+8]
.text$x:0000B76B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000B770 ; ---------------------------------------------------------------------------
.text$x:0000B770
.text$x:0000B770 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000B770                 retn
.text$x:0000B770 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000B770
.text$x:0000B771
.text$x:0000B771 ; =============== S U B R O U T I N E =======================================
.text$x:0000B771
.text$x:0000B771
.text$x:0000B771 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000B771                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:0000B771
.text$x:0000B771 arg_4           = dword ptr  8
.text$x:0000B771
.text$x:0000B771                 mov     edx, [esp+arg_4]
.text$x:0000B775                 lea     eax, [edx+0Ch]
.text$x:0000B778                 mov     ecx, [edx-14h]
.text$x:0000B77B                 xor     ecx, eax
.text$x:0000B77D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B782                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000B787                 jmp     ___CxxFrameHandler3
.text$x:0000B787 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000B787
.text$x:0000B787 _text$x         ends
.text$x:0000B787
.text$mn:0000B78C ; ===========================================================================
.text$mn:0000B78C
.text$mn:0000B78C ; Segment type: Pure code
.text$mn:0000B78C ; Segment permissions: Read/Execute
.text$mn:0000B78C _text$mn        segment para public 'CODE' use32
.text$mn:0000B78C                 assume cs:_text$mn
.text$mn:0000B78C                 ;org 0B78Ch
.text$mn:0000B78C ; COMDAT (pick any)
.text$mn:0000B78C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B78C
.text$mn:0000B78C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B78C
.text$mn:0000B78C ; Attributes: bp-based frame
.text$mn:0000B78C
.text$mn:0000B78C ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:0000B78C                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000B78C ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:0000B78C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:0000B78C
.text$mn:0000B78C var_4           = dword ptr -4
.text$mn:0000B78C Dst             = dword ptr  8
.text$mn:0000B78C Src             = dword ptr  0Ch
.text$mn:0000B78C Size            = dword ptr  10h
.text$mn:0000B78C
.text$mn:0000B78C                 push    ebp
.text$mn:0000B78D                 mov     ebp, esp
.text$mn:0000B78F                 push    ecx
.text$mn:0000B790                 cmp     [ebp+Size], 0
.text$mn:0000B794                 jnz     short loc_B79E
.text$mn:0000B796                 mov     eax, [ebp+Dst]
.text$mn:0000B799                 mov     [ebp+var_4], eax
.text$mn:0000B79C                 jmp     short loc_B7B5
.text$mn:0000B79E ; ---------------------------------------------------------------------------
.text$mn:0000B79E
.text$mn:0000B79E loc_B79E:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000B79E                 mov     ecx, [ebp+Size]
.text$mn:0000B7A1                 push    ecx             ; Size
.text$mn:0000B7A2                 mov     edx, [ebp+Src]
.text$mn:0000B7A5                 push    edx             ; Src
.text$mn:0000B7A6                 mov     eax, [ebp+Dst]
.text$mn:0000B7A9                 push    eax             ; Dst
.text$mn:0000B7AA                 call    _memmove
.text$mn:0000B7AF                 add     esp, 0Ch
.text$mn:0000B7B2                 mov     [ebp+var_4], eax
.text$mn:0000B7B5
.text$mn:0000B7B5 loc_B7B5:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:0000B7B5                 mov     eax, [ebp+var_4]
.text$mn:0000B7B8                 mov     esp, ebp
.text$mn:0000B7BA                 pop     ebp
.text$mn:0000B7BB                 retn
.text$mn:0000B7BB ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000B7BB
.text$mn:0000B7BB _text$mn        ends
.text$mn:0000B7BB
.text$mn:0000B7BC ; ===========================================================================
.text$mn:0000B7BC
.text$mn:0000B7BC ; Segment type: Pure code
.text$mn:0000B7BC ; Segment permissions: Read/Execute
.text$mn:0000B7BC _text$mn        segment para public 'CODE' use32
.text$mn:0000B7BC                 assume cs:_text$mn
.text$mn:0000B7BC                 ;org 0B7BCh
.text$mn:0000B7BC ; COMDAT (pick any)
.text$mn:0000B7BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B7BC
.text$mn:0000B7BC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B7BC
.text$mn:0000B7BC ; Attributes: bp-based frame
.text$mn:0000B7BC
.text$mn:0000B7BC ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:0000B7BC                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000B7BC ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000B7BC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Ap
.text$mn:0000B7BC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:0000B7BC
.text$mn:0000B7BC var_4           = dword ptr -4
.text$mn:0000B7BC Dst             = dword ptr  8
.text$mn:0000B7BC Src             = dword ptr  0Ch
.text$mn:0000B7BC arg_8           = dword ptr  10h
.text$mn:0000B7BC
.text$mn:0000B7BC                 push    ebp
.text$mn:0000B7BD                 mov     ebp, esp
.text$mn:0000B7BF                 push    ecx
.text$mn:0000B7C0                 cmp     [ebp+arg_8], 0
.text$mn:0000B7C4                 jnz     short loc_B7CE
.text$mn:0000B7C6                 mov     eax, [ebp+Dst]
.text$mn:0000B7C9                 mov     [ebp+var_4], eax
.text$mn:0000B7CC                 jmp     short loc_B7E5
.text$mn:0000B7CE ; ---------------------------------------------------------------------------
.text$mn:0000B7CE
.text$mn:0000B7CE loc_B7CE:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000B7CE                 mov     ecx, [ebp+arg_8]
.text$mn:0000B7D1                 push    ecx             ; int
.text$mn:0000B7D2                 mov     edx, [ebp+Src]
.text$mn:0000B7D5                 push    edx             ; Src
.text$mn:0000B7D6                 mov     eax, [ebp+Dst]
.text$mn:0000B7D9                 push    eax             ; Dst
.text$mn:0000B7DA                 call    _wmemmove
.text$mn:0000B7DF                 add     esp, 0Ch
.text$mn:0000B7E2                 mov     [ebp+var_4], eax
.text$mn:0000B7E5
.text$mn:0000B7E5 loc_B7E5:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000B7E5                 mov     eax, [ebp+var_4]
.text$mn:0000B7E8                 mov     esp, ebp
.text$mn:0000B7EA                 pop     ebp
.text$mn:0000B7EB                 retn
.text$mn:0000B7EB ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000B7EB
.text$mn:0000B7EB _text$mn        ends
.text$mn:0000B7EB
.text$mn:0000B7EC ; ===========================================================================
.text$mn:0000B7EC
.text$mn:0000B7EC ; Segment type: Pure code
.text$mn:0000B7EC ; Segment permissions: Read/Execute
.text$mn:0000B7EC _text$mn        segment para public 'CODE' use32
.text$mn:0000B7EC                 assume cs:_text$mn
.text$mn:0000B7EC                 ;org 0B7ECh
.text$mn:0000B7EC ; COMDAT (pick any)
.text$mn:0000B7EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B7EC
.text$mn:0000B7EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B7EC
.text$mn:0000B7EC ; Attributes: bp-based frame
.text$mn:0000B7EC
.text$mn:0000B7EC ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:0000B7EC                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:0000B7EC ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:0000B7EC                                         ; DATA XREF: .rdata:0000D9DCo
.text$mn:0000B7EC
.text$mn:0000B7EC var_4           = dword ptr -4
.text$mn:0000B7EC
.text$mn:0000B7EC                 push    ebp
.text$mn:0000B7ED                 mov     ebp, esp
.text$mn:0000B7EF                 push    ecx
.text$mn:0000B7F0                 mov     [ebp+var_4], ecx
.text$mn:0000B7F3                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000B7F8                 mov     esp, ebp
.text$mn:0000B7FA                 pop     ebp
.text$mn:0000B7FB                 retn
.text$mn:0000B7FB ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000B7FB
.text$mn:0000B7FB _text$mn        ends
.text$mn:0000B7FB
.text$mn:0000B7FC ; ===========================================================================
.text$mn:0000B7FC
.text$mn:0000B7FC ; Segment type: Pure code
.text$mn:0000B7FC ; Segment permissions: Read/Execute
.text$mn:0000B7FC _text$mn        segment para public 'CODE' use32
.text$mn:0000B7FC                 assume cs:_text$mn
.text$mn:0000B7FC                 ;org 0B7FCh
.text$mn:0000B7FC ; COMDAT (pick any)
.text$mn:0000B7FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B7FC
.text$mn:0000B7FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B7FC
.text$mn:0000B7FC ; Attributes: bp-based frame
.text$mn:0000B7FC
.text$mn:0000B7FC ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:0000B7FC                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:0000B7FC ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:0000B7FC                                         ; DATA XREF: .rdata:0000DA10o
.text$mn:0000B7FC
.text$mn:0000B7FC var_4           = dword ptr -4
.text$mn:0000B7FC
.text$mn:0000B7FC                 push    ebp
.text$mn:0000B7FD                 mov     ebp, esp
.text$mn:0000B7FF                 push    ecx
.text$mn:0000B800                 mov     [ebp+var_4], ecx
.text$mn:0000B803                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000B808                 mov     esp, ebp
.text$mn:0000B80A                 pop     ebp
.text$mn:0000B80B                 retn
.text$mn:0000B80B ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000B80B
.text$mn:0000B80B _text$mn        ends
.text$mn:0000B80B
.text$mn:0000B80C ; ===========================================================================
.text$mn:0000B80C
.text$mn:0000B80C ; Segment type: Pure code
.text$mn:0000B80C ; Segment permissions: Read/Execute
.text$mn:0000B80C _text$mn        segment para public 'CODE' use32
.text$mn:0000B80C                 assume cs:_text$mn
.text$mn:0000B80C                 ;org 0B80Ch
.text$mn:0000B80C ; COMDAT (pick any)
.text$mn:0000B80C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B80C
.text$mn:0000B80C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B80C
.text$mn:0000B80C ; Attributes: bp-based frame
.text$mn:0000B80C
.text$mn:0000B80C ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:0000B80C                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:0000B80C ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:0000B80C                                         ; DATA XREF: .rdata:0000DA50o
.text$mn:0000B80C
.text$mn:0000B80C var_4           = dword ptr -4
.text$mn:0000B80C
.text$mn:0000B80C                 push    ebp
.text$mn:0000B80D                 mov     ebp, esp
.text$mn:0000B80F                 push    ecx
.text$mn:0000B810                 mov     [ebp+var_4], ecx
.text$mn:0000B813                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000B818                 mov     esp, ebp
.text$mn:0000B81A                 pop     ebp
.text$mn:0000B81B                 retn
.text$mn:0000B81B ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000B81B
.text$mn:0000B81B _text$mn        ends
.text$mn:0000B81B
.text$mn:0000B81C ; ===========================================================================
.text$mn:0000B81C
.text$mn:0000B81C ; Segment type: Pure code
.text$mn:0000B81C ; Segment permissions: Read/Execute
.text$mn:0000B81C _text$mn        segment para public 'CODE' use32
.text$mn:0000B81C                 assume cs:_text$mn
.text$mn:0000B81C                 ;org 0B81Ch
.text$mn:0000B81C ; COMDAT (pick any)
.text$mn:0000B81C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B81C
.text$mn:0000B81C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B81C
.text$mn:0000B81C ; Attributes: bp-based frame
.text$mn:0000B81C
.text$mn:0000B81C ; void __thiscall PluginsManager::pluginCrashAlert(PluginsManager *this, const wchar_t *Str, const wchar_t *)
.text$mn:0000B81C                 public ?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z
.text$mn:0000B81C ?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z proc near
.text$mn:0000B81C                                         ; CODE XREF: __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$1+3Fp
.text$mn:0000B81C                                         ; __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$1+46p ...
.text$mn:0000B81C
.text$mn:0000B81C var_30          = dword ptr -30h
.text$mn:0000B81C var_2C          = byte ptr -2Ch
.text$mn:0000B81C var_10          = dword ptr -10h
.text$mn:0000B81C var_C           = dword ptr -0Ch
.text$mn:0000B81C var_4           = dword ptr -4
.text$mn:0000B81C Str             = dword ptr  8
.text$mn:0000B81C arg_4           = dword ptr  0Ch
.text$mn:0000B81C
.text$mn:0000B81C                 push    ebp
.text$mn:0000B81D                 mov     ebp, esp
.text$mn:0000B81F                 push    0FFFFFFFFh
.text$mn:0000B821                 push    offset __ehhandler$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z
.text$mn:0000B826                 mov     eax, large fs:0
.text$mn:0000B82C                 push    eax
.text$mn:0000B82D                 sub     esp, 24h
.text$mn:0000B830                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000B835                 xor     eax, ebp
.text$mn:0000B837                 mov     [ebp+var_10], eax
.text$mn:0000B83A                 push    eax
.text$mn:0000B83B                 lea     eax, [ebp+var_C]
.text$mn:0000B83E                 mov     large fs:0, eax
.text$mn:0000B844                 mov     [ebp+var_30], ecx
.text$mn:0000B847                 mov     eax, [ebp+Str]
.text$mn:0000B84A                 push    eax             ; Str
.text$mn:0000B84B                 lea     ecx, [ebp+var_2C]
.text$mn:0000B84E                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000B853                 mov     [ebp+var_4], 0
.text$mn:0000B85A                 push    offset ??_C@_1CA@FEODNHCM@?$AA?5?$AAj?$AAu?$AAs?$AAt?$AA?5?$AAc?$AAr?$AAa?$AAs?$AAh?$AA?5?$AAi?$AAn?$AA?$AN?$AA?$AA@ ; " just crash in\r"
.text$mn:0000B85F                 lea     ecx, [ebp+var_2C]
.text$mn:0000B862                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000B867                 mov     ecx, [ebp+arg_4]
.text$mn:0000B86A                 push    ecx             ; Str
.text$mn:0000B86B                 lea     ecx, [ebp+var_2C]
.text$mn:0000B86E                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000B873                 push    10h             ; uType
.text$mn:0000B875                 push    offset ??_C@_1CA@FEODNHCM@?$AA?5?$AAj?$AAu?$AAs?$AAt?$AA?5?$AAc?$AAr?$AAa?$AAs?$AAh?$AA?5?$AAi?$AAn?$AA?$AN?$AA?$AA@ ; " just crash in\r"
.text$mn:0000B87A                 lea     ecx, [ebp+var_2C]
.text$mn:0000B87D                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000B882                 push    eax             ; lpText
.text$mn:0000B883                 push    0               ; hWnd
.text$mn:0000B885                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:0000B88B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000B892                 lea     ecx, [ebp+var_2C]
.text$mn:0000B895                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000B89A                 mov     ecx, [ebp+var_C]
.text$mn:0000B89D                 mov     large fs:0, ecx
.text$mn:0000B8A4                 pop     ecx
.text$mn:0000B8A5                 mov     ecx, [ebp+var_10]
.text$mn:0000B8A8                 xor     ecx, ebp
.text$mn:0000B8AA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000B8AF                 mov     esp, ebp
.text$mn:0000B8B1                 pop     ebp
.text$mn:0000B8B2                 retn    8
.text$mn:0000B8B2 ?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z endp
.text$mn:0000B8B2
.text$mn:0000B8B2 ; ---------------------------------------------------------------------------
.text$mn:0000B8B5                 align 4
.text$mn:0000B8B5 _text$mn        ends
.text$mn:0000B8B5
.text$x:0000B8B8 ; ===========================================================================
.text$x:0000B8B8
.text$x:0000B8B8 ; Segment type: Pure code
.text$x:0000B8B8 ; Segment permissions: Read/Execute
.text$x:0000B8B8 _text$x         segment para public 'CODE' use32
.text$x:0000B8B8                 assume cs:_text$x
.text$x:0000B8B8                 ;org 0B8B8h
.text$x:0000B8B8 ; COMDAT (pick associative to section at B81C)
.text$x:0000B8B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000B8B8
.text$x:0000B8B8 ; =============== S U B R O U T I N E =======================================
.text$x:0000B8B8
.text$x:0000B8B8
.text$x:0000B8B8 __unwindfunclet$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z$0 proc near
.text$x:0000B8B8                                         ; DATA XREF: .xdata$x:0000D5A8o
.text$x:0000B8B8                 lea     ecx, [ebp-2Ch]
.text$x:0000B8BB                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000B8BB __unwindfunclet$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z$0 endp
.text$x:0000B8BB
.text$x:0000B8C0
.text$x:0000B8C0 ; =============== S U B R O U T I N E =======================================
.text$x:0000B8C0
.text$x:0000B8C0
.text$x:0000B8C0 __ehhandler$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z proc near
.text$x:0000B8C0                                         ; DATA XREF: PluginsManager::pluginCrashAlert(wchar_t const *,wchar_t const *)+5o
.text$x:0000B8C0
.text$x:0000B8C0 arg_4           = dword ptr  8
.text$x:0000B8C0
.text$x:0000B8C0                 mov     edx, [esp+arg_4]
.text$x:0000B8C4                 lea     eax, [edx+0Ch]
.text$x:0000B8C7                 mov     ecx, [edx-28h]
.text$x:0000B8CA                 xor     ecx, eax
.text$x:0000B8CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B8D1                 mov     ecx, [edx-4]
.text$x:0000B8D4                 xor     ecx, eax
.text$x:0000B8D6                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000B8DB                 mov     eax, offset __ehfuncinfo$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z
.text$x:0000B8E0                 jmp     ___CxxFrameHandler3
.text$x:0000B8E0 __ehhandler$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z endp
.text$x:0000B8E0
.text$x:0000B8E0 ; ---------------------------------------------------------------------------
.text$x:0000B8E5                 align 4
.text$x:0000B8E5 _text$x         ends
.text$x:0000B8E5
.text$mn:0000B8E8 ; ===========================================================================
.text$mn:0000B8E8
.text$mn:0000B8E8 ; Segment type: Pure code
.text$mn:0000B8E8 ; Segment permissions: Read/Execute
.text$mn:0000B8E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000B8E8                 assume cs:_text$mn
.text$mn:0000B8E8                 ;org 0B8E8h
.text$mn:0000B8E8 ; COMDAT (pick any)
.text$mn:0000B8E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B8E8
.text$mn:0000B8E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B8E8
.text$mn:0000B8E8 ; Attributes: bp-based frame
.text$mn:0000B8E8
.text$mn:0000B8E8 ; public: void __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::push_back(struct PluginInfo * const &)
.text$mn:0000B8E8                 public ?push_back@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXABQAUPluginInfo@@@Z
.text$mn:0000B8E8 ?push_back@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXABQAUPluginInfo@@@Z proc near
.text$mn:0000B8E8                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+9D5p
.text$mn:0000B8E8
.text$mn:0000B8E8 var_C           = dword ptr -0Ch
.text$mn:0000B8E8 var_8           = dword ptr -8
.text$mn:0000B8E8 var_2           = byte ptr -2
.text$mn:0000B8E8 var_1           = byte ptr -1
.text$mn:0000B8E8 arg_0           = dword ptr  8
.text$mn:0000B8E8
.text$mn:0000B8E8                 push    ebp
.text$mn:0000B8E9                 mov     ebp, esp
.text$mn:0000B8EB                 sub     esp, 0Ch
.text$mn:0000B8EE                 mov     [ebp+var_8], ecx
.text$mn:0000B8F1                 mov     eax, [ebp+arg_0]
.text$mn:0000B8F4                 push    eax
.text$mn:0000B8F5                 call    ??$addressof@QAUPluginInfo@@@std@@YAPBQAUPluginInfo@@ABQAU1@@Z ; std::addressof<PluginInfo * const>(PluginInfo * const &)
.text$mn:0000B8FA                 add     esp, 4
.text$mn:0000B8FD                 push    eax
.text$mn:0000B8FE                 mov     ecx, [ebp+var_8]
.text$mn:0000B901                 call    ?_Inside@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBE_NPBQAUPluginInfo@@@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Inside(PluginInfo * const *)
.text$mn:0000B906                 movzx   ecx, al
.text$mn:0000B909                 test    ecx, ecx
.text$mn:0000B90B                 jz      short loc_B98B
.text$mn:0000B90D                 mov     edx, [ebp+arg_0]
.text$mn:0000B910                 push    edx
.text$mn:0000B911                 call    ??$addressof@QAUPluginInfo@@@std@@YAPBQAUPluginInfo@@ABQAU1@@Z ; std::addressof<PluginInfo * const>(PluginInfo * const &)
.text$mn:0000B916                 add     esp, 4
.text$mn:0000B919                 mov     ecx, [ebp+var_8]
.text$mn:0000B91C                 sub     eax, [ecx+4]
.text$mn:0000B91F                 sar     eax, 2
.text$mn:0000B922                 mov     [ebp+var_C], eax
.text$mn:0000B925                 mov     edx, [ebp+var_8]
.text$mn:0000B928                 mov     eax, [ebp+var_8]
.text$mn:0000B92B                 mov     ecx, [edx+8]
.text$mn:0000B92E                 cmp     ecx, [eax+0Ch]
.text$mn:0000B931                 jnz     short loc_B93D
.text$mn:0000B933                 push    1
.text$mn:0000B935                 mov     ecx, [ebp+var_8]
.text$mn:0000B938                 call    ?_Reserve@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reserve(uint)
.text$mn:0000B93D
.text$mn:0000B93D loc_B93D:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+49j
.text$mn:0000B93D                 mov     edx, [ebp+var_8]
.text$mn:0000B940                 mov     eax, [edx+8]
.text$mn:0000B943                 push    eax
.text$mn:0000B944                 mov     ecx, [ebp+var_8]
.text$mn:0000B947                 mov     edx, [ecx+8]
.text$mn:0000B94A                 push    edx
.text$mn:0000B94B                 mov     ecx, [ebp+var_8]
.text$mn:0000B94E                 call    ?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)
.text$mn:0000B953                 mov     eax, [ebp+var_8]
.text$mn:0000B956                 mov     ecx, [eax+4]
.text$mn:0000B959                 mov     edx, [ebp+var_C]
.text$mn:0000B95C                 lea     eax, [ecx+edx*4]
.text$mn:0000B95F                 push    eax             ; int
.text$mn:0000B960                 mov     ecx, [ebp+var_8]
.text$mn:0000B963                 mov     edx, [ecx+8]
.text$mn:0000B966                 push    edx             ; void *
.text$mn:0000B967                 lea     eax, [ebp+var_1]
.text$mn:0000B96A                 push    eax
.text$mn:0000B96B                 mov     ecx, [ebp+var_8]
.text$mn:0000B96E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginInfo *,std::allocator<PluginInfo *>>>::_Getal(void)
.text$mn:0000B973                 mov     ecx, eax
.text$mn:0000B975                 call    ??$construct@PAUPluginInfo@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z ; std::_Wrap_alloc<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * &>(PluginInfo * *,PluginInfo * &)
.text$mn:0000B97A                 mov     ecx, [ebp+var_8]
.text$mn:0000B97D                 mov     edx, [ecx+8]
.text$mn:0000B980                 add     edx, 4
.text$mn:0000B983                 mov     eax, [ebp+var_8]
.text$mn:0000B986                 mov     [eax+8], edx
.text$mn:0000B989                 jmp     short loc_B9E6
.text$mn:0000B98B ; ---------------------------------------------------------------------------
.text$mn:0000B98B
.text$mn:0000B98B loc_B98B:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+23j
.text$mn:0000B98B                 mov     ecx, [ebp+var_8]
.text$mn:0000B98E                 mov     edx, [ebp+var_8]
.text$mn:0000B991                 mov     eax, [ecx+8]
.text$mn:0000B994                 cmp     eax, [edx+0Ch]
.text$mn:0000B997                 jnz     short loc_B9A3
.text$mn:0000B999                 push    1
.text$mn:0000B99B                 mov     ecx, [ebp+var_8]
.text$mn:0000B99E                 call    ?_Reserve@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Reserve(uint)
.text$mn:0000B9A3
.text$mn:0000B9A3 loc_B9A3:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+AFj
.text$mn:0000B9A3                 mov     ecx, [ebp+var_8]
.text$mn:0000B9A6                 mov     edx, [ecx+8]
.text$mn:0000B9A9                 push    edx
.text$mn:0000B9AA                 mov     eax, [ebp+var_8]
.text$mn:0000B9AD                 mov     ecx, [eax+8]
.text$mn:0000B9B0                 push    ecx
.text$mn:0000B9B1                 mov     ecx, [ebp+var_8]
.text$mn:0000B9B4                 call    ?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)
.text$mn:0000B9B9                 mov     edx, [ebp+arg_0]
.text$mn:0000B9BC                 push    edx             ; int
.text$mn:0000B9BD                 mov     eax, [ebp+var_8]
.text$mn:0000B9C0                 mov     ecx, [eax+8]
.text$mn:0000B9C3                 push    ecx             ; void *
.text$mn:0000B9C4                 lea     edx, [ebp+var_2]
.text$mn:0000B9C7                 push    edx
.text$mn:0000B9C8                 mov     ecx, [ebp+var_8]
.text$mn:0000B9CB                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginInfo *,std::allocator<PluginInfo *>>>::_Getal(void)
.text$mn:0000B9D0                 mov     ecx, eax
.text$mn:0000B9D2                 call    ??$construct@PAUPluginInfo@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXPAPAUPluginInfo@@ABQAU2@@Z ; std::_Wrap_alloc<std::allocator<PluginInfo *>>::construct<PluginInfo *,PluginInfo * const &>(PluginInfo * *,PluginInfo * const &)
.text$mn:0000B9D7                 mov     eax, [ebp+var_8]
.text$mn:0000B9DA                 mov     ecx, [eax+8]
.text$mn:0000B9DD                 add     ecx, 4
.text$mn:0000B9E0                 mov     edx, [ebp+var_8]
.text$mn:0000B9E3                 mov     [edx+8], ecx
.text$mn:0000B9E6
.text$mn:0000B9E6 loc_B9E6:                               ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::push_back(PluginInfo * const &)+A1j
.text$mn:0000B9E6                 mov     esp, ebp
.text$mn:0000B9E8                 pop     ebp
.text$mn:0000B9E9                 retn    4
.text$mn:0000B9E9 ?push_back@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QAEXABQAUPluginInfo@@@Z endp
.text$mn:0000B9E9
.text$mn:0000B9E9 _text$mn        ends
.text$mn:0000B9E9
.text$mn:0000B9EC ; ===========================================================================
.text$mn:0000B9EC
.text$mn:0000B9EC ; Segment type: Pure code
.text$mn:0000B9EC ; Segment permissions: Read/Execute
.text$mn:0000B9EC _text$mn        segment para public 'CODE' use32
.text$mn:0000B9EC                 assume cs:_text$mn
.text$mn:0000B9EC                 ;org 0B9ECh
.text$mn:0000B9EC ; COMDAT (pick any)
.text$mn:0000B9EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B9EC
.text$mn:0000B9EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B9EC
.text$mn:0000B9EC ; Attributes: bp-based frame
.text$mn:0000B9EC
.text$mn:0000B9EC ; public: void __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::push_back(class TiXmlDocument * const &)
.text$mn:0000B9EC                 public ?push_back@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXABQAVTiXmlDocument@@@Z
.text$mn:0000B9EC ?push_back@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXABQAVTiXmlDocument@@@Z proc near
.text$mn:0000B9EC                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+975p
.text$mn:0000B9EC
.text$mn:0000B9EC var_C           = dword ptr -0Ch
.text$mn:0000B9EC var_8           = dword ptr -8
.text$mn:0000B9EC var_2           = byte ptr -2
.text$mn:0000B9EC var_1           = byte ptr -1
.text$mn:0000B9EC arg_0           = dword ptr  8
.text$mn:0000B9EC
.text$mn:0000B9EC                 push    ebp
.text$mn:0000B9ED                 mov     ebp, esp
.text$mn:0000B9EF                 sub     esp, 0Ch
.text$mn:0000B9F2                 mov     [ebp+var_8], ecx
.text$mn:0000B9F5                 mov     eax, [ebp+arg_0]
.text$mn:0000B9F8                 push    eax
.text$mn:0000B9F9                 call    ??$addressof@QAVTiXmlDocument@@@std@@YAPBQAVTiXmlDocument@@ABQAV1@@Z ; std::addressof<TiXmlDocument * const>(TiXmlDocument * const &)
.text$mn:0000B9FE                 add     esp, 4
.text$mn:0000BA01                 push    eax
.text$mn:0000BA02                 mov     ecx, [ebp+var_8]
.text$mn:0000BA05                 call    ?_Inside@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBE_NPBQAVTiXmlDocument@@@Z ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Inside(TiXmlDocument * const *)
.text$mn:0000BA0A                 movzx   ecx, al
.text$mn:0000BA0D                 test    ecx, ecx
.text$mn:0000BA0F                 jz      short loc_BA8F
.text$mn:0000BA11                 mov     edx, [ebp+arg_0]
.text$mn:0000BA14                 push    edx
.text$mn:0000BA15                 call    ??$addressof@QAVTiXmlDocument@@@std@@YAPBQAVTiXmlDocument@@ABQAV1@@Z ; std::addressof<TiXmlDocument * const>(TiXmlDocument * const &)
.text$mn:0000BA1A                 add     esp, 4
.text$mn:0000BA1D                 mov     ecx, [ebp+var_8]
.text$mn:0000BA20                 sub     eax, [ecx+4]
.text$mn:0000BA23                 sar     eax, 2
.text$mn:0000BA26                 mov     [ebp+var_C], eax
.text$mn:0000BA29                 mov     edx, [ebp+var_8]
.text$mn:0000BA2C                 mov     eax, [ebp+var_8]
.text$mn:0000BA2F                 mov     ecx, [edx+8]
.text$mn:0000BA32                 cmp     ecx, [eax+0Ch]
.text$mn:0000BA35                 jnz     short loc_BA41
.text$mn:0000BA37                 push    1
.text$mn:0000BA39                 mov     ecx, [ebp+var_8]
.text$mn:0000BA3C                 call    ?_Reserve@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reserve(uint)
.text$mn:0000BA41
.text$mn:0000BA41 loc_BA41:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+49j
.text$mn:0000BA41                 mov     edx, [ebp+var_8]
.text$mn:0000BA44                 mov     eax, [edx+8]
.text$mn:0000BA47                 push    eax
.text$mn:0000BA48                 mov     ecx, [ebp+var_8]
.text$mn:0000BA4B                 mov     edx, [ecx+8]
.text$mn:0000BA4E                 push    edx
.text$mn:0000BA4F                 mov     ecx, [ebp+var_8]
.text$mn:0000BA52                 call    ?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *)
.text$mn:0000BA57                 mov     eax, [ebp+var_8]
.text$mn:0000BA5A                 mov     ecx, [eax+4]
.text$mn:0000BA5D                 mov     edx, [ebp+var_C]
.text$mn:0000BA60                 lea     eax, [ecx+edx*4]
.text$mn:0000BA63                 push    eax             ; int
.text$mn:0000BA64                 mov     ecx, [ebp+var_8]
.text$mn:0000BA67                 mov     edx, [ecx+8]
.text$mn:0000BA6A                 push    edx             ; void *
.text$mn:0000BA6B                 lea     eax, [ebp+var_1]
.text$mn:0000BA6E                 push    eax
.text$mn:0000BA6F                 mov     ecx, [ebp+var_8]
.text$mn:0000BA72                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TiXmlDocument *,std::allocator<TiXmlDocument *>>>::_Getal(void)
.text$mn:0000BA77                 mov     ecx, eax
.text$mn:0000BA79                 call    ??$construct@PAVTiXmlDocument@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * &>(TiXmlDocument * *,TiXmlDocument * &)
.text$mn:0000BA7E                 mov     ecx, [ebp+var_8]
.text$mn:0000BA81                 mov     edx, [ecx+8]
.text$mn:0000BA84                 add     edx, 4
.text$mn:0000BA87                 mov     eax, [ebp+var_8]
.text$mn:0000BA8A                 mov     [eax+8], edx
.text$mn:0000BA8D                 jmp     short loc_BAEA
.text$mn:0000BA8F ; ---------------------------------------------------------------------------
.text$mn:0000BA8F
.text$mn:0000BA8F loc_BA8F:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+23j
.text$mn:0000BA8F                 mov     ecx, [ebp+var_8]
.text$mn:0000BA92                 mov     edx, [ebp+var_8]
.text$mn:0000BA95                 mov     eax, [ecx+8]
.text$mn:0000BA98                 cmp     eax, [edx+0Ch]
.text$mn:0000BA9B                 jnz     short loc_BAA7
.text$mn:0000BA9D                 push    1
.text$mn:0000BA9F                 mov     ecx, [ebp+var_8]
.text$mn:0000BAA2                 call    ?_Reserve@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reserve(uint)
.text$mn:0000BAA7
.text$mn:0000BAA7 loc_BAA7:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+AFj
.text$mn:0000BAA7                 mov     ecx, [ebp+var_8]
.text$mn:0000BAAA                 mov     edx, [ecx+8]
.text$mn:0000BAAD                 push    edx
.text$mn:0000BAAE                 mov     eax, [ebp+var_8]
.text$mn:0000BAB1                 mov     ecx, [eax+8]
.text$mn:0000BAB4                 push    ecx
.text$mn:0000BAB5                 mov     ecx, [ebp+var_8]
.text$mn:0000BAB8                 call    ?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Orphan_range(TiXmlDocument * *,TiXmlDocument * *)
.text$mn:0000BABD                 mov     edx, [ebp+arg_0]
.text$mn:0000BAC0                 push    edx             ; int
.text$mn:0000BAC1                 mov     eax, [ebp+var_8]
.text$mn:0000BAC4                 mov     ecx, [eax+8]
.text$mn:0000BAC7                 push    ecx             ; void *
.text$mn:0000BAC8                 lea     edx, [ebp+var_2]
.text$mn:0000BACB                 push    edx
.text$mn:0000BACC                 mov     ecx, [ebp+var_8]
.text$mn:0000BACF                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<TiXmlDocument *,std::allocator<TiXmlDocument *>>>::_Getal(void)
.text$mn:0000BAD4                 mov     ecx, eax
.text$mn:0000BAD6                 call    ??$construct@PAVTiXmlDocument@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXPAPAVTiXmlDocument@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<TiXmlDocument *>>::construct<TiXmlDocument *,TiXmlDocument * const &>(TiXmlDocument * *,TiXmlDocument * const &)
.text$mn:0000BADB                 mov     eax, [ebp+var_8]
.text$mn:0000BADE                 mov     ecx, [eax+8]
.text$mn:0000BAE1                 add     ecx, 4
.text$mn:0000BAE4                 mov     edx, [ebp+var_8]
.text$mn:0000BAE7                 mov     [edx+8], ecx
.text$mn:0000BAEA
.text$mn:0000BAEA loc_BAEA:                               ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::push_back(TiXmlDocument * const &)+A1j
.text$mn:0000BAEA                 mov     esp, ebp
.text$mn:0000BAEC                 pop     ebp
.text$mn:0000BAED                 retn    4
.text$mn:0000BAED ?push_back@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QAEXABQAVTiXmlDocument@@@Z endp
.text$mn:0000BAED
.text$mn:0000BAED _text$mn        ends
.text$mn:0000BAED
.text$mn:0000BAF0 ; ===========================================================================
.text$mn:0000BAF0
.text$mn:0000BAF0 ; Segment type: Pure code
.text$mn:0000BAF0 ; Segment permissions: Read/Execute
.text$mn:0000BAF0 _text$mn        segment para public 'CODE' use32
.text$mn:0000BAF0                 assume cs:_text$mn
.text$mn:0000BAF0                 ;org 0BAF0h
.text$mn:0000BAF0 ; COMDAT (pick any)
.text$mn:0000BAF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BAF0
.text$mn:0000BAF0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BAF0
.text$mn:0000BAF0 ; Attributes: bp-based frame
.text$mn:0000BAF0
.text$mn:0000BAF0 ; public: void __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::push_back(struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool> &&)
.text$mn:0000BAF0                 public ?push_back@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAEX$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@@Z
.text$mn:0000BAF0 ?push_back@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAEX$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@@Z proc near
.text$mn:0000BAF0                                         ; CODE XREF: PluginList::add(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool)+56p
.text$mn:0000BAF0
.text$mn:0000BAF0 var_C           = dword ptr -0Ch
.text$mn:0000BAF0 var_8           = dword ptr -8
.text$mn:0000BAF0 var_2           = byte ptr -2
.text$mn:0000BAF0 var_1           = byte ptr -1
.text$mn:0000BAF0 arg_0           = dword ptr  8
.text$mn:0000BAF0
.text$mn:0000BAF0                 push    ebp
.text$mn:0000BAF1                 mov     ebp, esp
.text$mn:0000BAF3                 sub     esp, 0Ch
.text$mn:0000BAF6                 mov     [ebp+var_8], ecx
.text$mn:0000BAF9                 mov     eax, [ebp+arg_0]
.text$mn:0000BAFC                 push    eax
.text$mn:0000BAFD                 call    ??$addressof@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ; std::addressof<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &)
.text$mn:0000BB02                 add     esp, 4
.text$mn:0000BB05                 push    eax
.text$mn:0000BB06                 mov     ecx, [ebp+var_8]
.text$mn:0000BB09                 call    ?_Inside@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBE_NPBU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@@Z ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Inside(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> const *)
.text$mn:0000BB0E                 movzx   ecx, al
.text$mn:0000BB11                 test    ecx, ecx
.text$mn:0000BB13                 jz      loc_BBA0
.text$mn:0000BB19                 mov     edx, [ebp+arg_0]
.text$mn:0000BB1C                 push    edx
.text$mn:0000BB1D                 call    ??$addressof@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ; std::addressof<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &)
.text$mn:0000BB22                 add     esp, 4
.text$mn:0000BB25                 mov     ecx, [ebp+var_8]
.text$mn:0000BB28                 sub     eax, [ecx+4]
.text$mn:0000BB2B                 sar     eax, 5
.text$mn:0000BB2E                 mov     [ebp+var_C], eax
.text$mn:0000BB31                 mov     edx, [ebp+var_8]
.text$mn:0000BB34                 mov     eax, [ebp+var_8]
.text$mn:0000BB37                 mov     ecx, [edx+8]
.text$mn:0000BB3A                 cmp     ecx, [eax+0Ch]
.text$mn:0000BB3D                 jnz     short loc_BB49
.text$mn:0000BB3F                 push    1
.text$mn:0000BB41                 mov     ecx, [ebp+var_8]
.text$mn:0000BB44                 call    ?_Reserve@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reserve(uint)
.text$mn:0000BB49
.text$mn:0000BB49 loc_BB49:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+4Dj
.text$mn:0000BB49                 mov     edx, [ebp+var_8]
.text$mn:0000BB4C                 mov     eax, [edx+8]
.text$mn:0000BB4F                 push    eax
.text$mn:0000BB50                 mov     ecx, [ebp+var_8]
.text$mn:0000BB53                 mov     edx, [ecx+8]
.text$mn:0000BB56                 push    edx
.text$mn:0000BB57                 mov     ecx, [ebp+var_8]
.text$mn:0000BB5A                 call    ?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Orphan_range(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:0000BB5F                 mov     eax, [ebp+var_C]
.text$mn:0000BB62                 shl     eax, 5
.text$mn:0000BB65                 mov     ecx, [ebp+var_8]
.text$mn:0000BB68                 add     eax, [ecx+4]
.text$mn:0000BB6B                 push    eax
.text$mn:0000BB6C                 call    ??$forward@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ; std::forward<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &)
.text$mn:0000BB71                 add     esp, 4
.text$mn:0000BB74                 push    eax             ; int
.text$mn:0000BB75                 mov     edx, [ebp+var_8]
.text$mn:0000BB78                 mov     eax, [edx+8]
.text$mn:0000BB7B                 push    eax             ; void *
.text$mn:0000BB7C                 lea     ecx, [ebp+var_1]
.text$mn:0000BB7F                 push    ecx
.text$mn:0000BB80                 mov     ecx, [ebp+var_8]
.text$mn:0000BB83                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>::_Getal(void)
.text$mn:0000BB88                 mov     ecx, eax
.text$mn:0000BB8A                 call    ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)
.text$mn:0000BB8F                 mov     edx, [ebp+var_8]
.text$mn:0000BB92                 mov     eax, [edx+8]
.text$mn:0000BB95                 add     eax, 20h ; ' '
.text$mn:0000BB98                 mov     ecx, [ebp+var_8]
.text$mn:0000BB9B                 mov     [ecx+8], eax
.text$mn:0000BB9E                 jmp     short loc_BC04
.text$mn:0000BBA0 ; ---------------------------------------------------------------------------
.text$mn:0000BBA0
.text$mn:0000BBA0 loc_BBA0:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+23j
.text$mn:0000BBA0                 mov     edx, [ebp+var_8]
.text$mn:0000BBA3                 mov     eax, [ebp+var_8]
.text$mn:0000BBA6                 mov     ecx, [edx+8]
.text$mn:0000BBA9                 cmp     ecx, [eax+0Ch]
.text$mn:0000BBAC                 jnz     short loc_BBB8
.text$mn:0000BBAE                 push    1
.text$mn:0000BBB0                 mov     ecx, [ebp+var_8]
.text$mn:0000BBB3                 call    ?_Reserve@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reserve(uint)
.text$mn:0000BBB8
.text$mn:0000BBB8 loc_BBB8:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+BCj
.text$mn:0000BBB8                 mov     edx, [ebp+var_8]
.text$mn:0000BBBB                 mov     eax, [edx+8]
.text$mn:0000BBBE                 push    eax
.text$mn:0000BBBF                 mov     ecx, [ebp+var_8]
.text$mn:0000BBC2                 mov     edx, [ecx+8]
.text$mn:0000BBC5                 push    edx
.text$mn:0000BBC6                 mov     ecx, [ebp+var_8]
.text$mn:0000BBC9                 call    ?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Orphan_range(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *)
.text$mn:0000BBCE                 mov     eax, [ebp+arg_0]
.text$mn:0000BBD1                 push    eax
.text$mn:0000BBD2                 call    ??$forward@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YA$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ; std::forward<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &)
.text$mn:0000BBD7                 add     esp, 4
.text$mn:0000BBDA                 push    eax             ; int
.text$mn:0000BBDB                 mov     ecx, [ebp+var_8]
.text$mn:0000BBDE                 mov     edx, [ecx+8]
.text$mn:0000BBE1                 push    edx             ; void *
.text$mn:0000BBE2                 lea     eax, [ebp+var_2]
.text$mn:0000BBE5                 push    eax
.text$mn:0000BBE6                 mov     ecx, [ebp+var_8]
.text$mn:0000BBE9                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>>::_Getal(void)
.text$mn:0000BBEE                 mov     ecx, eax
.text$mn:0000BBF0                 call    ??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::construct<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)
.text$mn:0000BBF5                 mov     ecx, [ebp+var_8]
.text$mn:0000BBF8                 mov     edx, [ecx+8]
.text$mn:0000BBFB                 add     edx, 20h ; ' '
.text$mn:0000BBFE                 mov     eax, [ebp+var_8]
.text$mn:0000BC01                 mov     [eax+8], edx
.text$mn:0000BC04
.text$mn:0000BC04 loc_BC04:                               ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::push_back(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> &&)+AEj
.text$mn:0000BC04                 mov     esp, ebp
.text$mn:0000BC06                 pop     ebp
.text$mn:0000BC07                 retn    4
.text$mn:0000BC07 ?push_back@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAEX$$QAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@@Z endp
.text$mn:0000BC07
.text$mn:0000BC07 ; ---------------------------------------------------------------------------
.text$mn:0000BC0A                 align 4
.text$mn:0000BC0A _text$mn        ends
.text$mn:0000BC0A
.text$mn:0000BC0C ; ===========================================================================
.text$mn:0000BC0C
.text$mn:0000BC0C ; Segment type: Pure code
.text$mn:0000BC0C ; Segment permissions: Read/Execute
.text$mn:0000BC0C _text$mn        segment para public 'CODE' use32
.text$mn:0000BC0C                 assume cs:_text$mn
.text$mn:0000BC0C                 ;org 0BC0Ch
.text$mn:0000BC0C ; COMDAT (pick any)
.text$mn:0000BC0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BC0C
.text$mn:0000BC0C ; =============== S U B R O U T I N E =======================================
.text$mn:0000BC0C
.text$mn:0000BC0C ; Attributes: bp-based frame
.text$mn:0000BC0C
.text$mn:0000BC0C ; public: void __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::push_back(struct PluginCommand &&)
.text$mn:0000BC0C                 public ?push_back@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEX$$QAUPluginCommand@@@Z
.text$mn:0000BC0C ?push_back@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEX$$QAUPluginCommand@@@Z proc near
.text$mn:0000BC0C                                         ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+1B7p
.text$mn:0000BC0C
.text$mn:0000BC0C var_C           = dword ptr -0Ch
.text$mn:0000BC0C var_8           = dword ptr -8
.text$mn:0000BC0C var_2           = byte ptr -2
.text$mn:0000BC0C var_1           = byte ptr -1
.text$mn:0000BC0C arg_0           = dword ptr  8
.text$mn:0000BC0C
.text$mn:0000BC0C                 push    ebp
.text$mn:0000BC0D                 mov     ebp, esp
.text$mn:0000BC0F                 sub     esp, 0Ch
.text$mn:0000BC12                 mov     [ebp+var_8], ecx
.text$mn:0000BC15                 mov     eax, [ebp+arg_0]
.text$mn:0000BC18                 push    eax
.text$mn:0000BC19                 call    ??$addressof@UPluginCommand@@@std@@YAPAUPluginCommand@@AAU1@@Z ; std::addressof<PluginCommand>(PluginCommand &)
.text$mn:0000BC1E                 add     esp, 4
.text$mn:0000BC21                 push    eax
.text$mn:0000BC22                 mov     ecx, [ebp+var_8]
.text$mn:0000BC25                 call    ?_Inside@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBE_NPBUPluginCommand@@@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Inside(PluginCommand const *)
.text$mn:0000BC2A                 movzx   ecx, al
.text$mn:0000BC2D                 test    ecx, ecx
.text$mn:0000BC2F                 jz      loc_BCBF
.text$mn:0000BC35                 mov     edx, [ebp+arg_0]
.text$mn:0000BC38                 push    edx
.text$mn:0000BC39                 call    ??$addressof@UPluginCommand@@@std@@YAPAUPluginCommand@@AAU1@@Z ; std::addressof<PluginCommand>(PluginCommand &)
.text$mn:0000BC3E                 add     esp, 4
.text$mn:0000BC41                 mov     ecx, [ebp+var_8]
.text$mn:0000BC44                 sub     eax, [ecx+4]
.text$mn:0000BC47                 cdq
.text$mn:0000BC48                 mov     ecx, 24h ; '$'
.text$mn:0000BC4D                 idiv    ecx
.text$mn:0000BC4F                 mov     [ebp+var_C], eax
.text$mn:0000BC52                 mov     edx, [ebp+var_8]
.text$mn:0000BC55                 mov     eax, [ebp+var_8]
.text$mn:0000BC58                 mov     ecx, [edx+8]
.text$mn:0000BC5B                 cmp     ecx, [eax+0Ch]
.text$mn:0000BC5E                 jnz     short loc_BC6A
.text$mn:0000BC60                 push    1
.text$mn:0000BC62                 mov     ecx, [ebp+var_8]
.text$mn:0000BC65                 call    ?_Reserve@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reserve(uint)
.text$mn:0000BC6A
.text$mn:0000BC6A loc_BC6A:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+52j
.text$mn:0000BC6A                 mov     edx, [ebp+var_8]
.text$mn:0000BC6D                 mov     eax, [edx+8]
.text$mn:0000BC70                 push    eax
.text$mn:0000BC71                 mov     ecx, [ebp+var_8]
.text$mn:0000BC74                 mov     edx, [ecx+8]
.text$mn:0000BC77                 push    edx
.text$mn:0000BC78                 mov     ecx, [ebp+var_8]
.text$mn:0000BC7B                 call    ?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Orphan_range(PluginCommand *,PluginCommand *)
.text$mn:0000BC80                 imul    eax, [ebp+var_C], 24h
.text$mn:0000BC84                 mov     ecx, [ebp+var_8]
.text$mn:0000BC87                 add     eax, [ecx+4]
.text$mn:0000BC8A                 push    eax
.text$mn:0000BC8B                 call    ??$forward@UPluginCommand@@@std@@YA$$QAUPluginCommand@@AAU1@@Z ; std::forward<PluginCommand>(PluginCommand &)
.text$mn:0000BC90                 add     esp, 4
.text$mn:0000BC93                 push    eax             ; int
.text$mn:0000BC94                 mov     edx, [ebp+var_8]
.text$mn:0000BC97                 mov     eax, [edx+8]
.text$mn:0000BC9A                 push    eax             ; void *
.text$mn:0000BC9B                 lea     ecx, [ebp+var_1]
.text$mn:0000BC9E                 push    ecx
.text$mn:0000BC9F                 mov     ecx, [ebp+var_8]
.text$mn:0000BCA2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCommand,std::allocator<PluginCommand>>>::_Getal(void)
.text$mn:0000BCA7                 mov     ecx, eax
.text$mn:0000BCA9                 call    ??$construct@UPluginCommand@@U1@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<PluginCommand>>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)
.text$mn:0000BCAE                 mov     edx, [ebp+var_8]
.text$mn:0000BCB1                 mov     eax, [edx+8]
.text$mn:0000BCB4                 add     eax, 24h ; '$'
.text$mn:0000BCB7                 mov     ecx, [ebp+var_8]
.text$mn:0000BCBA                 mov     [ecx+8], eax
.text$mn:0000BCBD                 jmp     short loc_BD23
.text$mn:0000BCBF ; ---------------------------------------------------------------------------
.text$mn:0000BCBF
.text$mn:0000BCBF loc_BCBF:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+23j
.text$mn:0000BCBF                 mov     edx, [ebp+var_8]
.text$mn:0000BCC2                 mov     eax, [ebp+var_8]
.text$mn:0000BCC5                 mov     ecx, [edx+8]
.text$mn:0000BCC8                 cmp     ecx, [eax+0Ch]
.text$mn:0000BCCB                 jnz     short loc_BCD7
.text$mn:0000BCCD                 push    1
.text$mn:0000BCCF                 mov     ecx, [ebp+var_8]
.text$mn:0000BCD2                 call    ?_Reserve@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Reserve(uint)
.text$mn:0000BCD7
.text$mn:0000BCD7 loc_BCD7:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+BFj
.text$mn:0000BCD7                 mov     edx, [ebp+var_8]
.text$mn:0000BCDA                 mov     eax, [edx+8]
.text$mn:0000BCDD                 push    eax
.text$mn:0000BCDE                 mov     ecx, [ebp+var_8]
.text$mn:0000BCE1                 mov     edx, [ecx+8]
.text$mn:0000BCE4                 push    edx
.text$mn:0000BCE5                 mov     ecx, [ebp+var_8]
.text$mn:0000BCE8                 call    ?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z ; std::vector<PluginCommand,std::allocator<PluginCommand>>::_Orphan_range(PluginCommand *,PluginCommand *)
.text$mn:0000BCED                 mov     eax, [ebp+arg_0]
.text$mn:0000BCF0                 push    eax
.text$mn:0000BCF1                 call    ??$forward@UPluginCommand@@@std@@YA$$QAUPluginCommand@@AAU1@@Z ; std::forward<PluginCommand>(PluginCommand &)
.text$mn:0000BCF6                 add     esp, 4
.text$mn:0000BCF9                 push    eax             ; int
.text$mn:0000BCFA                 mov     ecx, [ebp+var_8]
.text$mn:0000BCFD                 mov     edx, [ecx+8]
.text$mn:0000BD00                 push    edx             ; void *
.text$mn:0000BD01                 lea     eax, [ebp+var_2]
.text$mn:0000BD04                 push    eax
.text$mn:0000BD05                 mov     ecx, [ebp+var_8]
.text$mn:0000BD08                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCommand,std::allocator<PluginCommand>>>::_Getal(void)
.text$mn:0000BD0D                 mov     ecx, eax
.text$mn:0000BD0F                 call    ??$construct@UPluginCommand@@U1@@?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<PluginCommand>>::construct<PluginCommand,PluginCommand>(PluginCommand *,PluginCommand &&)
.text$mn:0000BD14                 mov     ecx, [ebp+var_8]
.text$mn:0000BD17                 mov     edx, [ecx+8]
.text$mn:0000BD1A                 add     edx, 24h ; '$'
.text$mn:0000BD1D                 mov     eax, [ebp+var_8]
.text$mn:0000BD20                 mov     [eax+8], edx
.text$mn:0000BD23
.text$mn:0000BD23 loc_BD23:                               ; CODE XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::push_back(PluginCommand &&)+B1j
.text$mn:0000BD23                 mov     esp, ebp
.text$mn:0000BD25                 pop     ebp
.text$mn:0000BD26                 retn    4
.text$mn:0000BD26 ?push_back@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QAEX$$QAUPluginCommand@@@Z endp
.text$mn:0000BD26
.text$mn:0000BD26 ; ---------------------------------------------------------------------------
.text$mn:0000BD29                 align 4
.text$mn:0000BD29 _text$mn        ends
.text$mn:0000BD29
.text$mn:0000BD2C ; ===========================================================================
.text$mn:0000BD2C
.text$mn:0000BD2C ; Segment type: Pure code
.text$mn:0000BD2C ; Segment permissions: Read/Execute
.text$mn:0000BD2C _text$mn        segment para public 'CODE' use32
.text$mn:0000BD2C                 assume cs:_text$mn
.text$mn:0000BD2C                 ;org 0BD2Ch
.text$mn:0000BD2C ; COMDAT (pick any)
.text$mn:0000BD2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BD2C
.text$mn:0000BD2C ; =============== S U B R O U T I N E =======================================
.text$mn:0000BD2C
.text$mn:0000BD2C ; Attributes: bp-based frame
.text$mn:0000BD2C
.text$mn:0000BD2C ; public: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::push_back(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:0000BD2C                 public ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
.text$mn:0000BD2C ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z proc near
.text$mn:0000BD2C                                         ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+62p
.text$mn:0000BD2C                                         ; __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2+72p ...
.text$mn:0000BD2C
.text$mn:0000BD2C var_C           = dword ptr -0Ch
.text$mn:0000BD2C var_8           = dword ptr -8
.text$mn:0000BD2C var_2           = byte ptr -2
.text$mn:0000BD2C var_1           = byte ptr -1
.text$mn:0000BD2C arg_0           = dword ptr  8
.text$mn:0000BD2C
.text$mn:0000BD2C                 push    ebp
.text$mn:0000BD2D                 mov     ebp, esp
.text$mn:0000BD2F                 sub     esp, 0Ch
.text$mn:0000BD32                 mov     [ebp+var_8], ecx
.text$mn:0000BD35                 mov     eax, [ebp+arg_0]
.text$mn:0000BD38                 push    eax
.text$mn:0000BD39                 call    ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000BD3E                 add     esp, 4
.text$mn:0000BD41                 push    eax
.text$mn:0000BD42                 mov     ecx, [ebp+var_8]
.text$mn:0000BD45                 call    ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)
.text$mn:0000BD4A                 movzx   ecx, al
.text$mn:0000BD4D                 test    ecx, ecx
.text$mn:0000BD4F                 jz      loc_BDDF
.text$mn:0000BD55                 mov     edx, [ebp+arg_0]
.text$mn:0000BD58                 push    edx
.text$mn:0000BD59                 call    ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000BD5E                 add     esp, 4
.text$mn:0000BD61                 mov     ecx, [ebp+var_8]
.text$mn:0000BD64                 sub     eax, [ecx+4]
.text$mn:0000BD67                 cdq
.text$mn:0000BD68                 mov     ecx, 1Ch
.text$mn:0000BD6D                 idiv    ecx
.text$mn:0000BD6F                 mov     [ebp+var_C], eax
.text$mn:0000BD72                 mov     edx, [ebp+var_8]
.text$mn:0000BD75                 mov     eax, [ebp+var_8]
.text$mn:0000BD78                 mov     ecx, [edx+8]
.text$mn:0000BD7B                 cmp     ecx, [eax+0Ch]
.text$mn:0000BD7E                 jnz     short loc_BD8A
.text$mn:0000BD80                 push    1
.text$mn:0000BD82                 mov     ecx, [ebp+var_8]
.text$mn:0000BD85                 call    ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)
.text$mn:0000BD8A
.text$mn:0000BD8A loc_BD8A:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+52j
.text$mn:0000BD8A                 mov     edx, [ebp+var_8]
.text$mn:0000BD8D                 mov     eax, [edx+8]
.text$mn:0000BD90                 push    eax
.text$mn:0000BD91                 mov     ecx, [ebp+var_8]
.text$mn:0000BD94                 mov     edx, [ecx+8]
.text$mn:0000BD97                 push    edx
.text$mn:0000BD98                 mov     ecx, [ebp+var_8]
.text$mn:0000BD9B                 call    ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000BDA0                 imul    eax, [ebp+var_C], 1Ch
.text$mn:0000BDA4                 mov     ecx, [ebp+var_8]
.text$mn:0000BDA7                 add     eax, [ecx+4]
.text$mn:0000BDAA                 push    eax
.text$mn:0000BDAB                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000BDB0                 add     esp, 4
.text$mn:0000BDB3                 push    eax             ; int
.text$mn:0000BDB4                 mov     edx, [ebp+var_8]
.text$mn:0000BDB7                 mov     eax, [edx+8]
.text$mn:0000BDBA                 push    eax             ; void *
.text$mn:0000BDBB                 lea     ecx, [ebp+var_1]
.text$mn:0000BDBE                 push    ecx
.text$mn:0000BDBF                 mov     ecx, [ebp+var_8]
.text$mn:0000BDC2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000BDC7                 mov     ecx, eax
.text$mn:0000BDC9                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000BDCE                 mov     edx, [ebp+var_8]
.text$mn:0000BDD1                 mov     eax, [edx+8]
.text$mn:0000BDD4                 add     eax, 1Ch
.text$mn:0000BDD7                 mov     ecx, [ebp+var_8]
.text$mn:0000BDDA                 mov     [ecx+8], eax
.text$mn:0000BDDD                 jmp     short loc_BE43
.text$mn:0000BDDF ; ---------------------------------------------------------------------------
.text$mn:0000BDDF
.text$mn:0000BDDF loc_BDDF:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+23j
.text$mn:0000BDDF                 mov     edx, [ebp+var_8]
.text$mn:0000BDE2                 mov     eax, [ebp+var_8]
.text$mn:0000BDE5                 mov     ecx, [edx+8]
.text$mn:0000BDE8                 cmp     ecx, [eax+0Ch]
.text$mn:0000BDEB                 jnz     short loc_BDF7
.text$mn:0000BDED                 push    1
.text$mn:0000BDEF                 mov     ecx, [ebp+var_8]
.text$mn:0000BDF2                 call    ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)
.text$mn:0000BDF7
.text$mn:0000BDF7 loc_BDF7:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+BFj
.text$mn:0000BDF7                 mov     edx, [ebp+var_8]
.text$mn:0000BDFA                 mov     eax, [edx+8]
.text$mn:0000BDFD                 push    eax
.text$mn:0000BDFE                 mov     ecx, [ebp+var_8]
.text$mn:0000BE01                 mov     edx, [ecx+8]
.text$mn:0000BE04                 push    edx
.text$mn:0000BE05                 mov     ecx, [ebp+var_8]
.text$mn:0000BE08                 call    ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000BE0D                 mov     eax, [ebp+arg_0]
.text$mn:0000BE10                 push    eax
.text$mn:0000BE11                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000BE16                 add     esp, 4
.text$mn:0000BE19                 push    eax             ; int
.text$mn:0000BE1A                 mov     ecx, [ebp+var_8]
.text$mn:0000BE1D                 mov     edx, [ecx+8]
.text$mn:0000BE20                 push    edx             ; void *
.text$mn:0000BE21                 lea     eax, [ebp+var_2]
.text$mn:0000BE24                 push    eax
.text$mn:0000BE25                 mov     ecx, [ebp+var_8]
.text$mn:0000BE28                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000BE2D                 mov     ecx, eax
.text$mn:0000BE2F                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:0000BE34                 mov     ecx, [ebp+var_8]
.text$mn:0000BE37                 mov     edx, [ecx+8]
.text$mn:0000BE3A                 add     edx, 1Ch
.text$mn:0000BE3D                 mov     eax, [ebp+var_8]
.text$mn:0000BE40                 mov     [eax+8], edx
.text$mn:0000BE43
.text$mn:0000BE43 loc_BE43:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+B1j
.text$mn:0000BE43                 mov     esp, ebp
.text$mn:0000BE45                 pop     ebp
.text$mn:0000BE46                 retn    4
.text$mn:0000BE46 ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z endp
.text$mn:0000BE46
.text$mn:0000BE46 ; ---------------------------------------------------------------------------
.text$mn:0000BE49                 align 4
.text$mn:0000BE49 _text$mn        ends
.text$mn:0000BE49
.text$mn:0000BE4C ; ===========================================================================
.text$mn:0000BE4C
.text$mn:0000BE4C ; Segment type: Pure code
.text$mn:0000BE4C ; Segment permissions: Read/Execute
.text$mn:0000BE4C _text$mn        segment para public 'CODE' use32
.text$mn:0000BE4C                 assume cs:_text$mn
.text$mn:0000BE4C                 ;org 0BE4Ch
.text$mn:0000BE4C ; COMDAT (pick any)
.text$mn:0000BE4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BE4C
.text$mn:0000BE4C ; =============== S U B R O U T I N E =======================================
.text$mn:0000BE4C
.text$mn:0000BE4C ; Attributes: bp-based frame
.text$mn:0000BE4C
.text$mn:0000BE4C ; public: void __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::push_back(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000BE4C                 public ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
.text$mn:0000BE4C ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z proc near
.text$mn:0000BE4C                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+2E7p
.text$mn:0000BE4C                                         ; PluginsManager::loadPlugins(wchar_t const *)+453p
.text$mn:0000BE4C
.text$mn:0000BE4C var_C           = dword ptr -0Ch
.text$mn:0000BE4C var_8           = dword ptr -8
.text$mn:0000BE4C var_2           = byte ptr -2
.text$mn:0000BE4C var_1           = byte ptr -1
.text$mn:0000BE4C arg_0           = dword ptr  8
.text$mn:0000BE4C
.text$mn:0000BE4C                 push    ebp
.text$mn:0000BE4D                 mov     ebp, esp
.text$mn:0000BE4F                 sub     esp, 0Ch
.text$mn:0000BE52                 mov     [ebp+var_8], ecx
.text$mn:0000BE55                 mov     eax, [ebp+arg_0]
.text$mn:0000BE58                 push    eax
.text$mn:0000BE59                 call    ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000BE5E                 add     esp, 4
.text$mn:0000BE61                 push    eax
.text$mn:0000BE62                 mov     ecx, [ebp+var_8]
.text$mn:0000BE65                 call    ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBE_NPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Inside(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const *)
.text$mn:0000BE6A                 movzx   ecx, al
.text$mn:0000BE6D                 test    ecx, ecx
.text$mn:0000BE6F                 jz      loc_BEF6
.text$mn:0000BE75                 mov     edx, [ebp+arg_0]
.text$mn:0000BE78                 push    edx
.text$mn:0000BE79                 call    ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000BE7E                 add     esp, 4
.text$mn:0000BE81                 mov     ecx, [ebp+var_8]
.text$mn:0000BE84                 sub     eax, [ecx+4]
.text$mn:0000BE87                 cdq
.text$mn:0000BE88                 mov     ecx, 1Ch
.text$mn:0000BE8D                 idiv    ecx
.text$mn:0000BE8F                 mov     [ebp+var_C], eax
.text$mn:0000BE92                 mov     edx, [ebp+var_8]
.text$mn:0000BE95                 mov     eax, [ebp+var_8]
.text$mn:0000BE98                 mov     ecx, [edx+8]
.text$mn:0000BE9B                 cmp     ecx, [eax+0Ch]
.text$mn:0000BE9E                 jnz     short loc_BEAA
.text$mn:0000BEA0                 push    1
.text$mn:0000BEA2                 mov     ecx, [ebp+var_8]
.text$mn:0000BEA5                 call    ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)
.text$mn:0000BEAA
.text$mn:0000BEAA loc_BEAA:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+52j
.text$mn:0000BEAA                 mov     edx, [ebp+var_8]
.text$mn:0000BEAD                 mov     eax, [edx+8]
.text$mn:0000BEB0                 push    eax
.text$mn:0000BEB1                 mov     ecx, [ebp+var_8]
.text$mn:0000BEB4                 mov     edx, [ecx+8]
.text$mn:0000BEB7                 push    edx
.text$mn:0000BEB8                 mov     ecx, [ebp+var_8]
.text$mn:0000BEBB                 call    ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000BEC0                 imul    eax, [ebp+var_C], 1Ch
.text$mn:0000BEC4                 mov     ecx, [ebp+var_8]
.text$mn:0000BEC7                 add     eax, [ecx+4]
.text$mn:0000BECA                 push    eax             ; int
.text$mn:0000BECB                 mov     edx, [ebp+var_8]
.text$mn:0000BECE                 mov     eax, [edx+8]
.text$mn:0000BED1                 push    eax             ; void *
.text$mn:0000BED2                 lea     ecx, [ebp+var_1]
.text$mn:0000BED5                 push    ecx
.text$mn:0000BED6                 mov     ecx, [ebp+var_8]
.text$mn:0000BED9                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000BEDE                 mov     ecx, eax
.text$mn:0000BEE0                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:0000BEE5                 mov     edx, [ebp+var_8]
.text$mn:0000BEE8                 mov     eax, [edx+8]
.text$mn:0000BEEB                 add     eax, 1Ch
.text$mn:0000BEEE                 mov     ecx, [ebp+var_8]
.text$mn:0000BEF1                 mov     [ecx+8], eax
.text$mn:0000BEF4                 jmp     short loc_BF51
.text$mn:0000BEF6 ; ---------------------------------------------------------------------------
.text$mn:0000BEF6
.text$mn:0000BEF6 loc_BEF6:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+23j
.text$mn:0000BEF6                 mov     edx, [ebp+var_8]
.text$mn:0000BEF9                 mov     eax, [ebp+var_8]
.text$mn:0000BEFC                 mov     ecx, [edx+8]
.text$mn:0000BEFF                 cmp     ecx, [eax+0Ch]
.text$mn:0000BF02                 jnz     short loc_BF0E
.text$mn:0000BF04                 push    1
.text$mn:0000BF06                 mov     ecx, [ebp+var_8]
.text$mn:0000BF09                 call    ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Reserve(uint)
.text$mn:0000BF0E
.text$mn:0000BF0E loc_BF0E:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+B6j
.text$mn:0000BF0E                 mov     edx, [ebp+var_8]
.text$mn:0000BF11                 mov     eax, [edx+8]
.text$mn:0000BF14                 push    eax
.text$mn:0000BF15                 mov     ecx, [ebp+var_8]
.text$mn:0000BF18                 mov     edx, [ecx+8]
.text$mn:0000BF1B                 push    edx
.text$mn:0000BF1C                 mov     ecx, [ebp+var_8]
.text$mn:0000BF1F                 call    ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::_Orphan_range(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *)
.text$mn:0000BF24                 mov     eax, [ebp+arg_0]
.text$mn:0000BF27                 push    eax             ; int
.text$mn:0000BF28                 mov     ecx, [ebp+var_8]
.text$mn:0000BF2B                 mov     edx, [ecx+8]
.text$mn:0000BF2E                 push    edx             ; void *
.text$mn:0000BF2F                 lea     eax, [ebp+var_2]
.text$mn:0000BF32                 push    eax
.text$mn:0000BF33                 mov     ecx, [ebp+var_8]
.text$mn:0000BF36                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>>::_Getal(void)
.text$mn:0000BF3B                 mov     ecx, eax
.text$mn:0000BF3D                 call    ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000BF42                 mov     ecx, [ebp+var_8]
.text$mn:0000BF45                 mov     edx, [ecx+8]
.text$mn:0000BF48                 add     edx, 1Ch
.text$mn:0000BF4B                 mov     eax, [ebp+var_8]
.text$mn:0000BF4E                 mov     [eax+8], edx
.text$mn:0000BF51
.text$mn:0000BF51 loc_BF51:                               ; CODE XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::push_back(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+A8j
.text$mn:0000BF51                 mov     esp, ebp
.text$mn:0000BF53                 pop     ebp
.text$mn:0000BF54                 retn    4
.text$mn:0000BF54 ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z endp
.text$mn:0000BF54
.text$mn:0000BF54 ; ---------------------------------------------------------------------------
.text$mn:0000BF57                 align 4
.text$mn:0000BF57 _text$mn        ends
.text$mn:0000BF57
.text$mn:0000BF58 ; ===========================================================================
.text$mn:0000BF58
.text$mn:0000BF58 ; Segment type: Pure code
.text$mn:0000BF58 ; Segment permissions: Read/Execute
.text$mn:0000BF58 _text$mn        segment para public 'CODE' use32
.text$mn:0000BF58                 assume cs:_text$mn
.text$mn:0000BF58                 ;org 0BF58h
.text$mn:0000BF58 ; COMDAT (pick any)
.text$mn:0000BF58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000BF58
.text$mn:0000BF58 ; =============== S U B R O U T I N E =======================================
.text$mn:0000BF58
.text$mn:0000BF58 ; Attributes: bp-based frame
.text$mn:0000BF58
.text$mn:0000BF58 ; public: void __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::push_back(class PluginCmdShortcut const &)
.text$mn:0000BF58                 public ?push_back@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXABVPluginCmdShortcut@@@Z
.text$mn:0000BF58 ?push_back@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXABVPluginCmdShortcut@@@Z proc near
.text$mn:0000BF58                                         ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+35Fp
.text$mn:0000BF58                                         ; PluginsManager::addInMenuFromPMIndex(int)+467p
.text$mn:0000BF58
.text$mn:0000BF58 var_C           = dword ptr -0Ch
.text$mn:0000BF58 var_8           = dword ptr -8
.text$mn:0000BF58 var_2           = byte ptr -2
.text$mn:0000BF58 var_1           = byte ptr -1
.text$mn:0000BF58 arg_0           = dword ptr  8
.text$mn:0000BF58
.text$mn:0000BF58                 push    ebp
.text$mn:0000BF59                 mov     ebp, esp
.text$mn:0000BF5B                 sub     esp, 0Ch
.text$mn:0000BF5E                 mov     [ebp+var_8], ecx
.text$mn:0000BF61                 mov     eax, [ebp+arg_0]
.text$mn:0000BF64                 push    eax
.text$mn:0000BF65                 call    ??$addressof@$$CBVPluginCmdShortcut@@@std@@YAPBVPluginCmdShortcut@@ABV1@@Z ; std::addressof<PluginCmdShortcut const>(PluginCmdShortcut const &)
.text$mn:0000BF6A                 add     esp, 4
.text$mn:0000BF6D                 push    eax
.text$mn:0000BF6E                 mov     ecx, [ebp+var_8]
.text$mn:0000BF71                 call    ?_Inside@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBE_NPBVPluginCmdShortcut@@@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Inside(PluginCmdShortcut const *)
.text$mn:0000BF76                 movzx   ecx, al
.text$mn:0000BF79                 test    ecx, ecx
.text$mn:0000BF7B                 jz      loc_C007
.text$mn:0000BF81                 mov     edx, [ebp+arg_0]
.text$mn:0000BF84                 push    edx
.text$mn:0000BF85                 call    ??$addressof@$$CBVPluginCmdShortcut@@@std@@YAPBVPluginCmdShortcut@@ABV1@@Z ; std::addressof<PluginCmdShortcut const>(PluginCmdShortcut const &)
.text$mn:0000BF8A                 add     esp, 4
.text$mn:0000BF8D                 mov     ecx, [ebp+var_8]
.text$mn:0000BF90                 sub     eax, [ecx+4]
.text$mn:0000BF93                 cdq
.text$mn:0000BF94                 mov     ecx, 150h
.text$mn:0000BF99                 idiv    ecx
.text$mn:0000BF9B                 mov     [ebp+var_C], eax
.text$mn:0000BF9E                 mov     edx, [ebp+var_8]
.text$mn:0000BFA1                 mov     eax, [ebp+var_8]
.text$mn:0000BFA4                 mov     ecx, [edx+8]
.text$mn:0000BFA7                 cmp     ecx, [eax+0Ch]
.text$mn:0000BFAA                 jnz     short loc_BFB6
.text$mn:0000BFAC                 push    1
.text$mn:0000BFAE                 mov     ecx, [ebp+var_8]
.text$mn:0000BFB1                 call    ?_Reserve@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reserve(uint)
.text$mn:0000BFB6
.text$mn:0000BFB6 loc_BFB6:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+52j
.text$mn:0000BFB6                 mov     edx, [ebp+var_8]
.text$mn:0000BFB9                 mov     eax, [edx+8]
.text$mn:0000BFBC                 push    eax
.text$mn:0000BFBD                 mov     ecx, [ebp+var_8]
.text$mn:0000BFC0                 mov     edx, [ecx+8]
.text$mn:0000BFC3                 push    edx
.text$mn:0000BFC4                 mov     ecx, [ebp+var_8]
.text$mn:0000BFC7                 call    ?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Orphan_range(PluginCmdShortcut *,PluginCmdShortcut *)
.text$mn:0000BFCC                 imul    eax, [ebp+var_C], 150h
.text$mn:0000BFD3                 mov     ecx, [ebp+var_8]
.text$mn:0000BFD6                 add     eax, [ecx+4]
.text$mn:0000BFD9                 push    eax             ; int
.text$mn:0000BFDA                 mov     edx, [ebp+var_8]
.text$mn:0000BFDD                 mov     eax, [edx+8]
.text$mn:0000BFE0                 push    eax             ; void *
.text$mn:0000BFE1                 lea     ecx, [ebp+var_1]
.text$mn:0000BFE4                 push    ecx
.text$mn:0000BFE5                 mov     ecx, [ebp+var_8]
.text$mn:0000BFE8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>>::_Getal(void)
.text$mn:0000BFED                 mov     ecx, eax
.text$mn:0000BFEF                 call    ??$construct@VPluginCmdShortcut@@AAV1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z ; std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut &>(PluginCmdShortcut *,PluginCmdShortcut &)
.text$mn:0000BFF4                 mov     edx, [ebp+var_8]
.text$mn:0000BFF7                 mov     eax, [edx+8]
.text$mn:0000BFFA                 add     eax, 150h
.text$mn:0000BFFF                 mov     ecx, [ebp+var_8]
.text$mn:0000C002                 mov     [ecx+8], eax
.text$mn:0000C005                 jmp     short loc_C065
.text$mn:0000C007 ; ---------------------------------------------------------------------------
.text$mn:0000C007
.text$mn:0000C007 loc_C007:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+23j
.text$mn:0000C007                 mov     edx, [ebp+var_8]
.text$mn:0000C00A                 mov     eax, [ebp+var_8]
.text$mn:0000C00D                 mov     ecx, [edx+8]
.text$mn:0000C010                 cmp     ecx, [eax+0Ch]
.text$mn:0000C013                 jnz     short loc_C01F
.text$mn:0000C015                 push    1
.text$mn:0000C017                 mov     ecx, [ebp+var_8]
.text$mn:0000C01A                 call    ?_Reserve@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Reserve(uint)
.text$mn:0000C01F
.text$mn:0000C01F loc_C01F:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+BBj
.text$mn:0000C01F                 mov     edx, [ebp+var_8]
.text$mn:0000C022                 mov     eax, [edx+8]
.text$mn:0000C025                 push    eax
.text$mn:0000C026                 mov     ecx, [ebp+var_8]
.text$mn:0000C029                 mov     edx, [ecx+8]
.text$mn:0000C02C                 push    edx
.text$mn:0000C02D                 mov     ecx, [ebp+var_8]
.text$mn:0000C030                 call    ?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::_Orphan_range(PluginCmdShortcut *,PluginCmdShortcut *)
.text$mn:0000C035                 mov     eax, [ebp+arg_0]
.text$mn:0000C038                 push    eax             ; int
.text$mn:0000C039                 mov     ecx, [ebp+var_8]
.text$mn:0000C03C                 mov     edx, [ecx+8]
.text$mn:0000C03F                 push    edx             ; void *
.text$mn:0000C040                 lea     eax, [ebp+var_2]
.text$mn:0000C043                 push    eax
.text$mn:0000C044                 mov     ecx, [ebp+var_8]
.text$mn:0000C047                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>>::_Getal(void)
.text$mn:0000C04C                 mov     ecx, eax
.text$mn:0000C04E                 call    ??$construct@VPluginCmdShortcut@@ABV1@@?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXPAVPluginCmdShortcut@@ABV2@@Z ; std::_Wrap_alloc<std::allocator<PluginCmdShortcut>>::construct<PluginCmdShortcut,PluginCmdShortcut const &>(PluginCmdShortcut *,PluginCmdShortcut const &)
.text$mn:0000C053                 mov     ecx, [ebp+var_8]
.text$mn:0000C056                 mov     edx, [ecx+8]
.text$mn:0000C059                 add     edx, 150h
.text$mn:0000C05F                 mov     eax, [ebp+var_8]
.text$mn:0000C062                 mov     [eax+8], edx
.text$mn:0000C065
.text$mn:0000C065 loc_C065:                               ; CODE XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::push_back(PluginCmdShortcut const &)+ADj
.text$mn:0000C065                 mov     esp, ebp
.text$mn:0000C067                 pop     ebp
.text$mn:0000C068                 retn    4
.text$mn:0000C068 ?push_back@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QAEXABVPluginCmdShortcut@@@Z endp
.text$mn:0000C068
.text$mn:0000C068 ; ---------------------------------------------------------------------------
.text$mn:0000C06B                 align 4
.text$mn:0000C06B _text$mn        ends
.text$mn:0000C06B
.text$mn:0000C06C ; ===========================================================================
.text$mn:0000C06C
.text$mn:0000C06C ; Segment type: Pure code
.text$mn:0000C06C ; Segment permissions: Read/Execute
.text$mn:0000C06C _text$mn        segment para public 'CODE' use32
.text$mn:0000C06C                 assume cs:_text$mn
.text$mn:0000C06C                 ;org 0C06Ch
.text$mn:0000C06C ; COMDAT (pick any)
.text$mn:0000C06C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C06C
.text$mn:0000C06C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C06C
.text$mn:0000C06C ; Attributes: bp-based frame
.text$mn:0000C06C
.text$mn:0000C06C ; void __thiscall Window::reSizeTo(Window *this, struct tagRECT *)
.text$mn:0000C06C                 public ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z
.text$mn:0000C06C ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:0000C06C                                         ; DATA XREF: .rdata:0000DA9Co
.text$mn:0000C06C                                         ; .rdata:0000DAD0o ...
.text$mn:0000C06C
.text$mn:0000C06C var_4           = dword ptr -4
.text$mn:0000C06C arg_0           = dword ptr  8
.text$mn:0000C06C
.text$mn:0000C06C                 push    ebp
.text$mn:0000C06D                 mov     ebp, esp
.text$mn:0000C06F                 push    ecx
.text$mn:0000C070                 mov     [ebp+var_4], ecx
.text$mn:0000C073                 push    1               ; bRepaint
.text$mn:0000C075                 mov     eax, [ebp+arg_0]
.text$mn:0000C078                 mov     ecx, [eax+0Ch]
.text$mn:0000C07B                 push    ecx             ; nHeight
.text$mn:0000C07C                 mov     edx, [ebp+arg_0]
.text$mn:0000C07F                 mov     eax, [edx+8]
.text$mn:0000C082                 push    eax             ; nWidth
.text$mn:0000C083                 mov     ecx, [ebp+arg_0]
.text$mn:0000C086                 mov     edx, [ecx+4]
.text$mn:0000C089                 push    edx             ; Y
.text$mn:0000C08A                 mov     eax, [ebp+arg_0]
.text$mn:0000C08D                 mov     ecx, [eax]
.text$mn:0000C08F                 push    ecx             ; X
.text$mn:0000C090                 mov     edx, [ebp+var_4]
.text$mn:0000C093                 mov     eax, [edx+0Ch]
.text$mn:0000C096                 push    eax             ; hWnd
.text$mn:0000C097                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:0000C09D                 push    0
.text$mn:0000C09F                 mov     ecx, [ebp+var_4]
.text$mn:0000C0A2                 mov     edx, [ecx]
.text$mn:0000C0A4                 mov     ecx, [ebp+var_4]
.text$mn:0000C0A7                 mov     eax, [edx+18h]
.text$mn:0000C0AA                 call    eax
.text$mn:0000C0AC                 mov     esp, ebp
.text$mn:0000C0AE                 pop     ebp
.text$mn:0000C0AF                 retn    4
.text$mn:0000C0AF ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:0000C0AF
.text$mn:0000C0AF ; ---------------------------------------------------------------------------
.text$mn:0000C0B2                 align 4
.text$mn:0000C0B2 _text$mn        ends
.text$mn:0000C0B2
.text$mn:0000C0B4 ; ===========================================================================
.text$mn:0000C0B4
.text$mn:0000C0B4 ; Segment type: Pure code
.text$mn:0000C0B4 ; Segment permissions: Read/Execute
.text$mn:0000C0B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C0B4                 assume cs:_text$mn
.text$mn:0000C0B4                 ;org 0C0B4h
.text$mn:0000C0B4 ; COMDAT (pick any)
.text$mn:0000C0B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C0B4
.text$mn:0000C0B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C0B4
.text$mn:0000C0B4 ; Attributes: bp-based frame
.text$mn:0000C0B4
.text$mn:0000C0B4 ; void __thiscall Window::reSizeToWH(Window *this, struct tagRECT *)
.text$mn:0000C0B4                 public ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z
.text$mn:0000C0B4 ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:0000C0B4                                         ; DATA XREF: .rdata:0000DAA0o
.text$mn:0000C0B4                                         ; .rdata:0000DAD4o ...
.text$mn:0000C0B4
.text$mn:0000C0B4 var_4           = dword ptr -4
.text$mn:0000C0B4 arg_0           = dword ptr  8
.text$mn:0000C0B4
.text$mn:0000C0B4                 push    ebp
.text$mn:0000C0B5                 mov     ebp, esp
.text$mn:0000C0B7                 push    ecx
.text$mn:0000C0B8                 mov     [ebp+var_4], ecx
.text$mn:0000C0BB                 push    1               ; bRepaint
.text$mn:0000C0BD                 mov     eax, [ebp+arg_0]
.text$mn:0000C0C0                 mov     ecx, [ebp+arg_0]
.text$mn:0000C0C3                 mov     edx, [eax+0Ch]
.text$mn:0000C0C6                 sub     edx, [ecx+4]
.text$mn:0000C0C9                 push    edx             ; nHeight
.text$mn:0000C0CA                 mov     eax, [ebp+arg_0]
.text$mn:0000C0CD                 mov     ecx, [ebp+arg_0]
.text$mn:0000C0D0                 mov     edx, [eax+8]
.text$mn:0000C0D3                 sub     edx, [ecx]
.text$mn:0000C0D5                 push    edx             ; nWidth
.text$mn:0000C0D6                 mov     eax, [ebp+arg_0]
.text$mn:0000C0D9                 mov     ecx, [eax+4]
.text$mn:0000C0DC                 push    ecx             ; Y
.text$mn:0000C0DD                 mov     edx, [ebp+arg_0]
.text$mn:0000C0E0                 mov     eax, [edx]
.text$mn:0000C0E2                 push    eax             ; X
.text$mn:0000C0E3                 mov     ecx, [ebp+var_4]
.text$mn:0000C0E6                 mov     edx, [ecx+0Ch]
.text$mn:0000C0E9                 push    edx             ; hWnd
.text$mn:0000C0EA                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:0000C0F0                 push    0
.text$mn:0000C0F2                 mov     eax, [ebp+var_4]
.text$mn:0000C0F5                 mov     edx, [eax]
.text$mn:0000C0F7                 mov     ecx, [ebp+var_4]
.text$mn:0000C0FA                 mov     eax, [edx+18h]
.text$mn:0000C0FD                 call    eax
.text$mn:0000C0FF                 mov     esp, ebp
.text$mn:0000C101                 pop     ebp
.text$mn:0000C102                 retn    4
.text$mn:0000C102 ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:0000C102
.text$mn:0000C102 ; ---------------------------------------------------------------------------
.text$mn:0000C105                 align 4
.text$mn:0000C105 _text$mn        ends
.text$mn:0000C105
.text$mn:0000C108 ; ===========================================================================
.text$mn:0000C108
.text$mn:0000C108 ; Segment type: Pure code
.text$mn:0000C108 ; Segment permissions: Read/Execute
.text$mn:0000C108 _text$mn        segment para public 'CODE' use32
.text$mn:0000C108                 assume cs:_text$mn
.text$mn:0000C108                 ;org 0C108h
.text$mn:0000C108 ; COMDAT (pick any)
.text$mn:0000C108                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C108
.text$mn:0000C108 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C108
.text$mn:0000C108 ; Attributes: bp-based frame
.text$mn:0000C108
.text$mn:0000C108 ; void __thiscall Window::redraw(Window *this, bool)
.text$mn:0000C108                 public ?redraw@Window@@UBEX_N@Z
.text$mn:0000C108 ?redraw@Window@@UBEX_N@Z proc near      ; DATA XREF: .rdata:0000DAA4o
.text$mn:0000C108                                         ; .rdata:0000DAD8o ...
.text$mn:0000C108
.text$mn:0000C108 var_4           = dword ptr -4
.text$mn:0000C108 arg_0           = byte ptr  8
.text$mn:0000C108
.text$mn:0000C108                 push    ebp
.text$mn:0000C109                 mov     ebp, esp
.text$mn:0000C10B                 push    ecx
.text$mn:0000C10C                 mov     [ebp+var_4], ecx
.text$mn:0000C10F                 push    1               ; bErase
.text$mn:0000C111                 push    0               ; lpRect
.text$mn:0000C113                 mov     eax, [ebp+var_4]
.text$mn:0000C116                 mov     ecx, [eax+0Ch]
.text$mn:0000C119                 push    ecx             ; hWnd
.text$mn:0000C11A                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:0000C120                 movzx   edx, [ebp+arg_0]
.text$mn:0000C124                 test    edx, edx
.text$mn:0000C126                 jz      short loc_C135
.text$mn:0000C128                 mov     eax, [ebp+var_4]
.text$mn:0000C12B                 mov     ecx, [eax+0Ch]
.text$mn:0000C12E                 push    ecx             ; hWnd
.text$mn:0000C12F                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:0000C135
.text$mn:0000C135 loc_C135:                               ; CODE XREF: Window::redraw(bool)+1Ej
.text$mn:0000C135                 mov     esp, ebp
.text$mn:0000C137                 pop     ebp
.text$mn:0000C138                 retn    4
.text$mn:0000C138 ?redraw@Window@@UBEX_N@Z endp
.text$mn:0000C138
.text$mn:0000C138 ; ---------------------------------------------------------------------------
.text$mn:0000C13B                 align 4
.text$mn:0000C13B _text$mn        ends
.text$mn:0000C13B
.text$mn:0000C13C ; ===========================================================================
.text$mn:0000C13C
.text$mn:0000C13C ; Segment type: Pure code
.text$mn:0000C13C ; Segment permissions: Read/Execute
.text$mn:0000C13C _text$mn        segment para public 'CODE' use32
.text$mn:0000C13C                 assume cs:_text$mn
.text$mn:0000C13C                 ;org 0C13Ch
.text$mn:0000C13C ; COMDAT (pick any)
.text$mn:0000C13C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C13C
.text$mn:0000C13C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C13C
.text$mn:0000C13C ; Attributes: bp-based frame
.text$mn:0000C13C
.text$mn:0000C13C ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::select_on_container_copy_construction(void)const
.text$mn:0000C13C                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
.text$mn:0000C13C ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:0000C13C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Ap
.text$mn:0000C13C
.text$mn:0000C13C var_8           = dword ptr -8
.text$mn:0000C13C var_1           = byte ptr -1
.text$mn:0000C13C arg_0           = dword ptr  8
.text$mn:0000C13C
.text$mn:0000C13C                 push    ebp
.text$mn:0000C13D                 mov     ebp, esp
.text$mn:0000C13F                 sub     esp, 8
.text$mn:0000C142                 mov     [ebp+var_8], ecx
.text$mn:0000C145                 mov     eax, [ebp+var_8]
.text$mn:0000C148                 push    eax
.text$mn:0000C149                 lea     ecx, [ebp+var_1]
.text$mn:0000C14C                 push    ecx
.text$mn:0000C14D                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)
.text$mn:0000C152                 add     esp, 8
.text$mn:0000C155                 push    eax
.text$mn:0000C156                 mov     ecx, [ebp+arg_0]
.text$mn:0000C159                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)
.text$mn:0000C15E                 mov     eax, [ebp+arg_0]
.text$mn:0000C161                 mov     esp, ebp
.text$mn:0000C163                 pop     ebp
.text$mn:0000C164                 retn    4
.text$mn:0000C164 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:0000C164
.text$mn:0000C164 ; ---------------------------------------------------------------------------
.text$mn:0000C167                 align 4
.text$mn:0000C167 _text$mn        ends
.text$mn:0000C167
.text$mn:0000C168 ; ===========================================================================
.text$mn:0000C168
.text$mn:0000C168 ; Segment type: Pure code
.text$mn:0000C168 ; Segment permissions: Read/Execute
.text$mn:0000C168 _text$mn        segment para public 'CODE' use32
.text$mn:0000C168                 assume cs:_text$mn
.text$mn:0000C168                 ;org 0C168h
.text$mn:0000C168 ; COMDAT (pick any)
.text$mn:0000C168                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C168
.text$mn:0000C168 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C168
.text$mn:0000C168 ; Attributes: bp-based frame
.text$mn:0000C168
.text$mn:0000C168 ; public: class std::allocator<wchar_t> __thiscall std::allocator<wchar_t>::select_on_container_copy_construction(void)const
.text$mn:0000C168                 public ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
.text$mn:0000C168 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ proc near
.text$mn:0000C168                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)+Ap
.text$mn:0000C168
.text$mn:0000C168 var_4           = dword ptr -4
.text$mn:0000C168 arg_0           = dword ptr  8
.text$mn:0000C168
.text$mn:0000C168                 push    ebp
.text$mn:0000C169                 mov     ebp, esp
.text$mn:0000C16B                 push    ecx
.text$mn:0000C16C                 mov     [ebp+var_4], ecx
.text$mn:0000C16F                 mov     eax, [ebp+var_4]
.text$mn:0000C172                 push    eax
.text$mn:0000C173                 mov     ecx, [ebp+arg_0]
.text$mn:0000C176                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:0000C17B                 mov     eax, [ebp+arg_0]
.text$mn:0000C17E                 mov     esp, ebp
.text$mn:0000C180                 pop     ebp
.text$mn:0000C181                 retn    4
.text$mn:0000C181 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ endp
.text$mn:0000C181
.text$mn:0000C181 _text$mn        ends
.text$mn:0000C181
.text$mn:0000C184 ; ===========================================================================
.text$mn:0000C184
.text$mn:0000C184 ; Segment type: Pure code
.text$mn:0000C184 ; Segment permissions: Read/Execute
.text$mn:0000C184 _text$mn        segment para public 'CODE' use32
.text$mn:0000C184                 assume cs:_text$mn
.text$mn:0000C184                 ;org 0C184h
.text$mn:0000C184 ; COMDAT (pick any)
.text$mn:0000C184                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C184
.text$mn:0000C184 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C184
.text$mn:0000C184 ; Attributes: bp-based frame
.text$mn:0000C184
.text$mn:0000C184 ; public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class std::allocator<wchar_t>>::select_on_container_copy_construction(class std::allocator<wchar_t> const &)
.text$mn:0000C184                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
.text$mn:0000C184 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z proc near
.text$mn:0000C184                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+11p
.text$mn:0000C184
.text$mn:0000C184 arg_0           = dword ptr  8
.text$mn:0000C184 arg_4           = dword ptr  0Ch
.text$mn:0000C184
.text$mn:0000C184                 push    ebp
.text$mn:0000C185                 mov     ebp, esp
.text$mn:0000C187                 mov     eax, [ebp+arg_0]
.text$mn:0000C18A                 push    eax
.text$mn:0000C18B                 mov     ecx, [ebp+arg_4]
.text$mn:0000C18E                 call    ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction(void)
.text$mn:0000C193                 mov     eax, [ebp+arg_0]
.text$mn:0000C196                 pop     ebp
.text$mn:0000C197                 retn
.text$mn:0000C197 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z endp
.text$mn:0000C197
.text$mn:0000C197 _text$mn        ends
.text$mn:0000C197
.text$mn:0000C198 ; ===========================================================================
.text$mn:0000C198
.text$mn:0000C198 ; Segment type: Pure code
.text$mn:0000C198 ; Segment permissions: Read/Execute
.text$mn:0000C198 _text$mn        segment para public 'CODE' use32
.text$mn:0000C198                 assume cs:_text$mn
.text$mn:0000C198                 ;org 0C198h
.text$mn:0000C198 ; COMDAT (pick any)
.text$mn:0000C198                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C198
.text$mn:0000C198 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C198
.text$mn:0000C198 ; Attributes: bp-based frame
.text$mn:0000C198
.text$mn:0000C198 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:0000C198                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000C198 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000C198                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:0000C198                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:0000C198
.text$mn:0000C198 var_4           = dword ptr -4
.text$mn:0000C198
.text$mn:0000C198                 push    ebp
.text$mn:0000C199                 mov     ebp, esp
.text$mn:0000C19B                 push    ecx
.text$mn:0000C19C                 mov     [ebp+var_4], ecx
.text$mn:0000C19F                 mov     eax, [ebp+var_4]
.text$mn:0000C1A2                 mov     eax, [eax+14h]
.text$mn:0000C1A5                 mov     esp, ebp
.text$mn:0000C1A7                 pop     ebp
.text$mn:0000C1A8                 retn
.text$mn:0000C1A8 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000C1A8
.text$mn:0000C1A8 ; ---------------------------------------------------------------------------
.text$mn:0000C1A9                 align 4
.text$mn:0000C1A9 _text$mn        ends
.text$mn:0000C1A9
.text$mn:0000C1AC ; ===========================================================================
.text$mn:0000C1AC
.text$mn:0000C1AC ; Segment type: Pure code
.text$mn:0000C1AC ; Segment permissions: Read/Execute
.text$mn:0000C1AC _text$mn        segment para public 'CODE' use32
.text$mn:0000C1AC                 assume cs:_text$mn
.text$mn:0000C1AC                 ;org 0C1ACh
.text$mn:0000C1AC ; COMDAT (pick any)
.text$mn:0000C1AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C1AC
.text$mn:0000C1AC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C1AC
.text$mn:0000C1AC ; Attributes: bp-based frame
.text$mn:0000C1AC
.text$mn:0000C1AC ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:0000C1AC                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000C1AC ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000C1AC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:0000C1AC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p ...
.text$mn:0000C1AC
.text$mn:0000C1AC var_4           = dword ptr -4
.text$mn:0000C1AC
.text$mn:0000C1AC                 push    ebp
.text$mn:0000C1AD                 mov     ebp, esp
.text$mn:0000C1AF                 push    ecx
.text$mn:0000C1B0                 mov     [ebp+var_4], ecx
.text$mn:0000C1B3                 mov     eax, [ebp+var_4]
.text$mn:0000C1B6                 mov     eax, [eax+14h]
.text$mn:0000C1B9                 mov     esp, ebp
.text$mn:0000C1BB                 pop     ebp
.text$mn:0000C1BC                 retn
.text$mn:0000C1BC ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000C1BC
.text$mn:0000C1BC ; ---------------------------------------------------------------------------
.text$mn:0000C1BD                 align 10h
.text$mn:0000C1BD _text$mn        ends
.text$mn:0000C1BD
.text$mn:0000C1C0 ; ===========================================================================
.text$mn:0000C1C0
.text$mn:0000C1C0 ; Segment type: Pure code
.text$mn:0000C1C0 ; Segment permissions: Read/Execute
.text$mn:0000C1C0 _text$mn        segment para public 'CODE' use32
.text$mn:0000C1C0                 assume cs:_text$mn
.text$mn:0000C1C0                 ;org 0C1C0h
.text$mn:0000C1C0 ; COMDAT (pick any)
.text$mn:0000C1C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C1C0
.text$mn:0000C1C0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C1C0
.text$mn:0000C1C0 ; Attributes: bp-based frame
.text$mn:0000C1C0
.text$mn:0000C1C0 ; public: unsigned int __thiscall std::vector<struct PluginInfo *, class std::allocator<struct PluginInfo *>>::size(void)const
.text$mn:0000C1C0                 public ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ
.text$mn:0000C1C0 ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C1C0                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+9E3p
.text$mn:0000C1C0                                         ; PluginsManager::setMenu(HMENU__ *,wchar_t const *)+88p ...
.text$mn:0000C1C0
.text$mn:0000C1C0 var_4           = dword ptr -4
.text$mn:0000C1C0
.text$mn:0000C1C0                 push    ebp
.text$mn:0000C1C1                 mov     ebp, esp
.text$mn:0000C1C3                 push    ecx
.text$mn:0000C1C4                 mov     [ebp+var_4], ecx
.text$mn:0000C1C7                 mov     eax, [ebp+var_4]
.text$mn:0000C1CA                 mov     ecx, [ebp+var_4]
.text$mn:0000C1CD                 mov     eax, [eax+8]
.text$mn:0000C1D0                 sub     eax, [ecx+4]
.text$mn:0000C1D3                 sar     eax, 2
.text$mn:0000C1D6                 mov     esp, ebp
.text$mn:0000C1D8                 pop     ebp
.text$mn:0000C1D9                 retn
.text$mn:0000C1D9 ?size@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@QBEIXZ endp
.text$mn:0000C1D9
.text$mn:0000C1D9 ; ---------------------------------------------------------------------------
.text$mn:0000C1DA                 align 4
.text$mn:0000C1DA _text$mn        ends
.text$mn:0000C1DA
.text$mn:0000C1DC ; ===========================================================================
.text$mn:0000C1DC
.text$mn:0000C1DC ; Segment type: Pure code
.text$mn:0000C1DC ; Segment permissions: Read/Execute
.text$mn:0000C1DC _text$mn        segment para public 'CODE' use32
.text$mn:0000C1DC                 assume cs:_text$mn
.text$mn:0000C1DC                 ;org 0C1DCh
.text$mn:0000C1DC ; COMDAT (pick any)
.text$mn:0000C1DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C1DC
.text$mn:0000C1DC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C1DC
.text$mn:0000C1DC ; Attributes: bp-based frame
.text$mn:0000C1DC
.text$mn:0000C1DC ; public: unsigned int __thiscall std::vector<class TiXmlDocument *, class std::allocator<class TiXmlDocument *>>::size(void)const
.text$mn:0000C1DC                 public ?size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ
.text$mn:0000C1DC ?size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C1DC                                         ; CODE XREF: std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reallocate(uint)+A9p
.text$mn:0000C1DC                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Reserve(uint)+22p ...
.text$mn:0000C1DC
.text$mn:0000C1DC var_4           = dword ptr -4
.text$mn:0000C1DC
.text$mn:0000C1DC                 push    ebp
.text$mn:0000C1DD                 mov     ebp, esp
.text$mn:0000C1DF                 push    ecx
.text$mn:0000C1E0                 mov     [ebp+var_4], ecx
.text$mn:0000C1E3                 mov     eax, [ebp+var_4]
.text$mn:0000C1E6                 mov     ecx, [ebp+var_4]
.text$mn:0000C1E9                 mov     eax, [eax+8]
.text$mn:0000C1EC                 sub     eax, [ecx+4]
.text$mn:0000C1EF                 sar     eax, 2
.text$mn:0000C1F2                 mov     esp, ebp
.text$mn:0000C1F4                 pop     ebp
.text$mn:0000C1F5                 retn
.text$mn:0000C1F5 ?size@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@QBEIXZ endp
.text$mn:0000C1F5
.text$mn:0000C1F5 ; ---------------------------------------------------------------------------
.text$mn:0000C1F6                 align 4
.text$mn:0000C1F6 _text$mn        ends
.text$mn:0000C1F6
.text$mn:0000C1F8 ; ===========================================================================
.text$mn:0000C1F8
.text$mn:0000C1F8 ; Segment type: Pure code
.text$mn:0000C1F8 ; Segment permissions: Read/Execute
.text$mn:0000C1F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000C1F8                 assume cs:_text$mn
.text$mn:0000C1F8                 ;org 0C1F8h
.text$mn:0000C1F8 ; COMDAT (pick any)
.text$mn:0000C1F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C1F8
.text$mn:0000C1F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C1F8
.text$mn:0000C1F8 ; Attributes: bp-based frame
.text$mn:0000C1F8
.text$mn:0000C1F8 ; public: unsigned int __thiscall std::vector<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>, class std::allocator<struct std::pair<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, bool>>>::size(void)const
.text$mn:0000C1F8                 public ?size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ
.text$mn:0000C1F8 ?size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000C1F8                                         ; CODE XREF: std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reallocate(uint)+A9p
.text$mn:0000C1F8                                         ; std::vector<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>>::_Reserve(uint)+22p ...
.text$mn:0000C1F8
.text$mn:0000C1F8 var_4           = dword ptr -4
.text$mn:0000C1F8
.text$mn:0000C1F8                 push    ebp
.text$mn:0000C1F9                 mov     ebp, esp
.text$mn:0000C1FB                 push    ecx
.text$mn:0000C1FC                 mov     [ebp+var_4], ecx
.text$mn:0000C1FF                 mov     eax, [ebp+var_4]
.text$mn:0000C202                 mov     ecx, [ebp+var_4]
.text$mn:0000C205                 mov     eax, [eax+8]
.text$mn:0000C208                 sub     eax, [ecx+4]
.text$mn:0000C20B                 sar     eax, 5
.text$mn:0000C20E                 mov     esp, ebp
.text$mn:0000C210                 pop     ebp
.text$mn:0000C211                 retn
.text$mn:0000C211 ?size@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QBEIXZ endp
.text$mn:0000C211
.text$mn:0000C211 ; ---------------------------------------------------------------------------
.text$mn:0000C212                 align 4
.text$mn:0000C212 _text$mn        ends
.text$mn:0000C212
.text$mn:0000C214 ; ===========================================================================
.text$mn:0000C214
.text$mn:0000C214 ; Segment type: Pure code
.text$mn:0000C214 ; Segment permissions: Read/Execute
.text$mn:0000C214 _text$mn        segment para public 'CODE' use32
.text$mn:0000C214                 assume cs:_text$mn
.text$mn:0000C214                 ;org 0C214h
.text$mn:0000C214 ; COMDAT (pick any)
.text$mn:0000C214                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C214
.text$mn:0000C214 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C214
.text$mn:0000C214 ; Attributes: bp-based frame
.text$mn:0000C214
.text$mn:0000C214 ; public: unsigned int __thiscall std::vector<struct PluginCommand, class std::allocator<struct PluginCommand>>::size(void)const
.text$mn:0000C214                 public ?size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ
.text$mn:0000C214 ?size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C214                                         ; CODE XREF: PluginsManager::runPluginCommand(uint)+41p
.text$mn:0000C214                                         ; PluginsManager::runPluginCommand(wchar_t const *,int)+4Bp ...
.text$mn:0000C214
.text$mn:0000C214 var_4           = dword ptr -4
.text$mn:0000C214
.text$mn:0000C214                 push    ebp
.text$mn:0000C215                 mov     ebp, esp
.text$mn:0000C217                 push    ecx
.text$mn:0000C218                 mov     [ebp+var_4], ecx
.text$mn:0000C21B                 mov     eax, [ebp+var_4]
.text$mn:0000C21E                 mov     ecx, [ebp+var_4]
.text$mn:0000C221                 mov     eax, [eax+8]
.text$mn:0000C224                 sub     eax, [ecx+4]
.text$mn:0000C227                 cdq
.text$mn:0000C228                 mov     ecx, 24h ; '$'
.text$mn:0000C22D                 idiv    ecx
.text$mn:0000C22F                 mov     esp, ebp
.text$mn:0000C231                 pop     ebp
.text$mn:0000C232                 retn
.text$mn:0000C232 ?size@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@QBEIXZ endp
.text$mn:0000C232
.text$mn:0000C232 ; ---------------------------------------------------------------------------
.text$mn:0000C233                 align 4
.text$mn:0000C233 _text$mn        ends
.text$mn:0000C233
.text$mn:0000C234 ; ===========================================================================
.text$mn:0000C234
.text$mn:0000C234 ; Segment type: Pure code
.text$mn:0000C234 ; Segment permissions: Read/Execute
.text$mn:0000C234 _text$mn        segment para public 'CODE' use32
.text$mn:0000C234                 assume cs:_text$mn
.text$mn:0000C234                 ;org 0C234h
.text$mn:0000C234 ; COMDAT (pick any)
.text$mn:0000C234                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C234
.text$mn:0000C234 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C234
.text$mn:0000C234 ; Attributes: bp-based frame
.text$mn:0000C234
.text$mn:0000C234 ; public: unsigned int __thiscall std::vector<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>, class std::allocator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::size(void)const
.text$mn:0000C234                 public ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
.text$mn:0000C234 ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000C234                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+4DBp
.text$mn:0000C234                                         ; PluginsManager::loadPlugins(wchar_t const *)+54Fp ...
.text$mn:0000C234
.text$mn:0000C234 var_4           = dword ptr -4
.text$mn:0000C234
.text$mn:0000C234                 push    ebp
.text$mn:0000C235                 mov     ebp, esp
.text$mn:0000C237                 push    ecx
.text$mn:0000C238                 mov     [ebp+var_4], ecx
.text$mn:0000C23B                 mov     eax, [ebp+var_4]
.text$mn:0000C23E                 mov     ecx, [ebp+var_4]
.text$mn:0000C241                 mov     eax, [eax+8]
.text$mn:0000C244                 sub     eax, [ecx+4]
.text$mn:0000C247                 cdq
.text$mn:0000C248                 mov     ecx, 1Ch
.text$mn:0000C24D                 idiv    ecx
.text$mn:0000C24F                 mov     esp, ebp
.text$mn:0000C251                 pop     ebp
.text$mn:0000C252                 retn
.text$mn:0000C252 ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ endp
.text$mn:0000C252
.text$mn:0000C252 ; ---------------------------------------------------------------------------
.text$mn:0000C253                 align 4
.text$mn:0000C253 _text$mn        ends
.text$mn:0000C253
.text$mn:0000C254 ; ===========================================================================
.text$mn:0000C254
.text$mn:0000C254 ; Segment type: Pure code
.text$mn:0000C254 ; Segment permissions: Read/Execute
.text$mn:0000C254 _text$mn        segment para public 'CODE' use32
.text$mn:0000C254                 assume cs:_text$mn
.text$mn:0000C254                 ;org 0C254h
.text$mn:0000C254 ; COMDAT (pick any)
.text$mn:0000C254                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C254
.text$mn:0000C254 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C254
.text$mn:0000C254 ; Attributes: bp-based frame
.text$mn:0000C254
.text$mn:0000C254 ; public: unsigned int __thiscall std::vector<class PluginCmdShortcut, class std::allocator<class PluginCmdShortcut>>::size(void)const
.text$mn:0000C254                 public ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ
.text$mn:0000C254 ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ proc near
.text$mn:0000C254                                         ; CODE XREF: PluginsManager::getShortcutByCmdID(int,ShortcutKey *)+35p
.text$mn:0000C254                                         ; std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+Ap ...
.text$mn:0000C254
.text$mn:0000C254 var_4           = dword ptr -4
.text$mn:0000C254
.text$mn:0000C254                 push    ebp
.text$mn:0000C255                 mov     ebp, esp
.text$mn:0000C257                 push    ecx
.text$mn:0000C258                 mov     [ebp+var_4], ecx
.text$mn:0000C25B                 mov     eax, [ebp+var_4]
.text$mn:0000C25E                 mov     ecx, [ebp+var_4]
.text$mn:0000C261                 mov     eax, [eax+8]
.text$mn:0000C264                 sub     eax, [ecx+4]
.text$mn:0000C267                 cdq
.text$mn:0000C268                 mov     ecx, 150h
.text$mn:0000C26D                 idiv    ecx
.text$mn:0000C26F                 mov     esp, ebp
.text$mn:0000C271                 pop     ebp
.text$mn:0000C272                 retn
.text$mn:0000C272 ?size@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@QBEIXZ endp
.text$mn:0000C272
.text$mn:0000C272 ; ---------------------------------------------------------------------------
.text$mn:0000C273                 align 4
.text$mn:0000C273 _text$mn        ends
.text$mn:0000C273
.text$mn:0000C274 ; ===========================================================================
.text$mn:0000C274
.text$mn:0000C274 ; Segment type: Pure code
.text$mn:0000C274 ; Segment permissions: Read/Execute
.text$mn:0000C274 _text$mn        segment para public 'CODE' use32
.text$mn:0000C274                 assume cs:_text$mn
.text$mn:0000C274                 ;org 0C274h
.text$mn:0000C274 ; COMDAT (pick any)
.text$mn:0000C274                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C274
.text$mn:0000C274 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C274
.text$mn:0000C274 ; Attributes: bp-based frame
.text$mn:0000C274
.text$mn:0000C274 ; int swprintf(wchar_t *Dest, const wchar_t *Format, ...)
.text$mn:0000C274                 public ?swprintf@@YAHPA_WPB_WZZ
.text$mn:0000C274 ?swprintf@@YAHPA_WPB_WZZ proc near      ; CODE XREF: __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$1+10p
.text$mn:0000C274                                         ; __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$1+14p ...
.text$mn:0000C274
.text$mn:0000C274 var_8           = dword ptr -8
.text$mn:0000C274 Args            = dword ptr -4
.text$mn:0000C274 Dest            = dword ptr  8
.text$mn:0000C274 Format          = dword ptr  0Ch
.text$mn:0000C274 arg_8           = byte ptr  10h
.text$mn:0000C274
.text$mn:0000C274                 push    ebp
.text$mn:0000C275                 mov     ebp, esp
.text$mn:0000C277                 sub     esp, 8
.text$mn:0000C27A                 lea     eax, [ebp+arg_8]
.text$mn:0000C27D                 mov     [ebp+Args], eax
.text$mn:0000C280                 mov     ecx, [ebp+Args]
.text$mn:0000C283                 push    ecx             ; Args
.text$mn:0000C284                 mov     edx, [ebp+Format]
.text$mn:0000C287                 push    edx             ; Format
.text$mn:0000C288                 mov     eax, [ebp+Dest]
.text$mn:0000C28B                 push    eax             ; Dest
.text$mn:0000C28C                 call    __vswprintf
.text$mn:0000C291                 add     esp, 0Ch
.text$mn:0000C294                 mov     [ebp+var_8], eax
.text$mn:0000C297                 mov     [ebp+Args], 0
.text$mn:0000C29E                 mov     eax, [ebp+var_8]
.text$mn:0000C2A1                 mov     esp, ebp
.text$mn:0000C2A3                 pop     ebp
.text$mn:0000C2A4                 retn
.text$mn:0000C2A4 ?swprintf@@YAHPA_WPB_WZZ endp
.text$mn:0000C2A4
.text$mn:0000C2A4 ; ---------------------------------------------------------------------------
.text$mn:0000C2A5                 align 4
.text$mn:0000C2A5 _text$mn        ends
.text$mn:0000C2A5
.text$mn:0000C2A8 ; ===========================================================================
.text$mn:0000C2A8
.text$mn:0000C2A8 ; Segment type: Pure code
.text$mn:0000C2A8 ; Segment permissions: Read/Execute
.text$mn:0000C2A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2A8                 assume cs:_text$mn
.text$mn:0000C2A8                 ;org 0C2A8h
.text$mn:0000C2A8 ; COMDAT (pick any)
.text$mn:0000C2A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C2A8
.text$mn:0000C2A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2A8
.text$mn:0000C2A8 ; Attributes: bp-based frame
.text$mn:0000C2A8
.text$mn:0000C2A8 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:0000C2A8                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:0000C2A8 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000C2A8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_AA18p
.text$mn:0000C2A8                 push    ebp
.text$mn:0000C2A9                 mov     ebp, esp
.text$mn:0000C2AB                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:0000C2B0                 pop     ebp
.text$mn:0000C2B1                 retn
.text$mn:0000C2B1 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000C2B1
.text$mn:0000C2B1 ; ---------------------------------------------------------------------------
.text$mn:0000C2B2                 align 4
.text$mn:0000C2B2 _text$mn        ends
.text$mn:0000C2B2
.text$mn:0000C2B4 ; ===========================================================================
.text$mn:0000C2B4
.text$mn:0000C2B4 ; Segment type: Pure code
.text$mn:0000C2B4 ; Segment permissions: Read/Execute
.text$mn:0000C2B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2B4                 assume cs:_text$mn
.text$mn:0000C2B4                 ;org 0C2B4h
.text$mn:0000C2B4 ; COMDAT (pick any)
.text$mn:0000C2B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C2B4
.text$mn:0000C2B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2B4
.text$mn:0000C2B4 ; Attributes: bp-based frame
.text$mn:0000C2B4
.text$mn:0000C2B4 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:0000C2B4                 public ?value@error_code@std@@QBEHXZ
.text$mn:0000C2B4 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:0000C2B4
.text$mn:0000C2B4 var_4           = dword ptr -4
.text$mn:0000C2B4
.text$mn:0000C2B4                 push    ebp
.text$mn:0000C2B5                 mov     ebp, esp
.text$mn:0000C2B7                 push    ecx
.text$mn:0000C2B8                 mov     [ebp+var_4], ecx
.text$mn:0000C2BB                 mov     eax, [ebp+var_4]
.text$mn:0000C2BE                 mov     eax, [eax]
.text$mn:0000C2C0                 mov     esp, ebp
.text$mn:0000C2C2                 pop     ebp
.text$mn:0000C2C3                 retn
.text$mn:0000C2C3 ?value@error_code@std@@QBEHXZ endp
.text$mn:0000C2C3
.text$mn:0000C2C3 _text$mn        ends
.text$mn:0000C2C3
.text$mn:0000C2C4 ; ===========================================================================
.text$mn:0000C2C4
.text$mn:0000C2C4 ; Segment type: Pure code
.text$mn:0000C2C4 ; Segment permissions: Read/Execute
.text$mn:0000C2C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2C4                 assume cs:_text$mn
.text$mn:0000C2C4                 ;org 0C2C4h
.text$mn:0000C2C4 ; COMDAT (pick any)
.text$mn:0000C2C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C2C4
.text$mn:0000C2C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2C4
.text$mn:0000C2C4 ; Attributes: bp-based frame
.text$mn:0000C2C4
.text$mn:0000C2C4 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:0000C2C4                 public ?value@error_condition@std@@QBEHXZ
.text$mn:0000C2C4 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:0000C2C4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:0000C2C4                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:0000C2C4
.text$mn:0000C2C4 var_4           = dword ptr -4
.text$mn:0000C2C4
.text$mn:0000C2C4                 push    ebp
.text$mn:0000C2C5                 mov     ebp, esp
.text$mn:0000C2C7                 push    ecx
.text$mn:0000C2C8                 mov     [ebp+var_4], ecx
.text$mn:0000C2CB                 mov     eax, [ebp+var_4]
.text$mn:0000C2CE                 mov     eax, [eax]
.text$mn:0000C2D0                 mov     esp, ebp
.text$mn:0000C2D2                 pop     ebp
.text$mn:0000C2D3                 retn
.text$mn:0000C2D3 ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000C2D3
.text$mn:0000C2D3 _text$mn        ends
.text$mn:0000C2D3
.text$mn:0000C2D4 ; ===========================================================================
.text$mn:0000C2D4
.text$mn:0000C2D4 ; Segment type: Pure code
.text$mn:0000C2D4 ; Segment permissions: Read/Execute
.text$mn:0000C2D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000C2D4                 assume cs:_text$mn
.text$mn:0000C2D4                 ;org 0C2D4h
.text$mn:0000C2D4 ; COMDAT (pick any)
.text$mn:0000C2D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C2D4
.text$mn:0000C2D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2D4
.text$mn:0000C2D4 ; Attributes: bp-based frame
.text$mn:0000C2D4
.text$mn:0000C2D4                 public _hypot
.text$mn:0000C2D4 _hypot          proc near
.text$mn:0000C2D4
.text$mn:0000C2D4 var_10          = qword ptr -10h
.text$mn:0000C2D4 var_8           = qword ptr -8
.text$mn:0000C2D4 arg_0           = qword ptr  8
.text$mn:0000C2D4 arg_8           = qword ptr  10h
.text$mn:0000C2D4
.text$mn:0000C2D4                 push    ebp
.text$mn:0000C2D5                 mov     ebp, esp
.text$mn:0000C2D7                 sub     esp, 8
.text$mn:0000C2DA                 movsd   xmm0, [ebp+arg_8]
.text$mn:0000C2DF                 movsd   [esp+8+var_8], xmm0
.text$mn:0000C2E4                 sub     esp, 8
.text$mn:0000C2E7                 movsd   xmm0, [ebp+arg_0]
.text$mn:0000C2EC                 movsd   [esp+10h+var_10], xmm0
.text$mn:0000C2F1                 call    __hypot
.text$mn:0000C2F6                 add     esp, 10h
.text$mn:0000C2F9                 pop     ebp
.text$mn:0000C2FA                 retn
.text$mn:0000C2FA _hypot          endp
.text$mn:0000C2FA
.text$mn:0000C2FA ; ---------------------------------------------------------------------------
.text$mn:0000C2FB                 align 4
.text$mn:0000C2FB _text$mn        ends
.text$mn:0000C2FB
.text$mn:0000C2FC ; ===========================================================================
.text$mn:0000C2FC
.text$mn:0000C2FC ; Segment type: Pure code
.text$mn:0000C2FC ; Segment permissions: Read/Execute
.text$mn:0000C2FC _text$mn        segment para public 'CODE' use32
.text$mn:0000C2FC                 assume cs:_text$mn
.text$mn:0000C2FC                 ;org 0C2FCh
.text$mn:0000C2FC ; COMDAT (pick any)
.text$mn:0000C2FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C2FC
.text$mn:0000C2FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000C2FC
.text$mn:0000C2FC ; Attributes: bp-based frame
.text$mn:0000C2FC
.text$mn:0000C2FC                 public _wmemcmp
.text$mn:0000C2FC _wmemcmp        proc near               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+1Fp
.text$mn:0000C2FC
.text$mn:0000C2FC var_4           = dword ptr -4
.text$mn:0000C2FC arg_0           = dword ptr  8
.text$mn:0000C2FC arg_4           = dword ptr  0Ch
.text$mn:0000C2FC arg_8           = dword ptr  10h
.text$mn:0000C2FC
.text$mn:0000C2FC                 push    ebp
.text$mn:0000C2FD                 mov     ebp, esp
.text$mn:0000C2FF                 push    ecx
.text$mn:0000C300                 jmp     short loc_C31D
.text$mn:0000C302 ; ---------------------------------------------------------------------------
.text$mn:0000C302
.text$mn:0000C302 loc_C302:                               ; CODE XREF: _wmemcmp:loc_C358j
.text$mn:0000C302                 mov     eax, [ebp+arg_0]
.text$mn:0000C305                 add     eax, 2
.text$mn:0000C308                 mov     [ebp+arg_0], eax
.text$mn:0000C30B                 mov     ecx, [ebp+arg_4]
.text$mn:0000C30E                 add     ecx, 2
.text$mn:0000C311                 mov     [ebp+arg_4], ecx
.text$mn:0000C314                 mov     edx, [ebp+arg_8]
.text$mn:0000C317                 sub     edx, 1
.text$mn:0000C31A                 mov     [ebp+arg_8], edx
.text$mn:0000C31D
.text$mn:0000C31D loc_C31D:                               ; CODE XREF: _wmemcmp+4j
.text$mn:0000C31D                 cmp     [ebp+arg_8], 0
.text$mn:0000C321                 jbe     short loc_C35A
.text$mn:0000C323                 mov     eax, [ebp+arg_0]
.text$mn:0000C326                 movzx   ecx, word ptr [eax]
.text$mn:0000C329                 mov     edx, [ebp+arg_4]
.text$mn:0000C32C                 movzx   eax, word ptr [edx]
.text$mn:0000C32F                 cmp     ecx, eax
.text$mn:0000C331                 jz      short loc_C358
.text$mn:0000C333                 mov     ecx, [ebp+arg_0]
.text$mn:0000C336                 movzx   edx, word ptr [ecx]
.text$mn:0000C339                 mov     eax, [ebp+arg_4]
.text$mn:0000C33C                 movzx   ecx, word ptr [eax]
.text$mn:0000C33F                 cmp     edx, ecx
.text$mn:0000C341                 jge     short loc_C34C
.text$mn:0000C343                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000C34A                 jmp     short loc_C353
.text$mn:0000C34C ; ---------------------------------------------------------------------------
.text$mn:0000C34C
.text$mn:0000C34C loc_C34C:                               ; CODE XREF: _wmemcmp+45j
.text$mn:0000C34C                 mov     [ebp+var_4], 1
.text$mn:0000C353
.text$mn:0000C353 loc_C353:                               ; CODE XREF: _wmemcmp+4Ej
.text$mn:0000C353                 mov     eax, [ebp+var_4]
.text$mn:0000C356                 jmp     short loc_C35C
.text$mn:0000C358 ; ---------------------------------------------------------------------------
.text$mn:0000C358
.text$mn:0000C358 loc_C358:                               ; CODE XREF: _wmemcmp+35j
.text$mn:0000C358                 jmp     short loc_C302
.text$mn:0000C35A ; ---------------------------------------------------------------------------
.text$mn:0000C35A
.text$mn:0000C35A loc_C35A:                               ; CODE XREF: _wmemcmp+25j
.text$mn:0000C35A                 xor     eax, eax
.text$mn:0000C35C
.text$mn:0000C35C loc_C35C:                               ; CODE XREF: _wmemcmp+5Aj
.text$mn:0000C35C                 mov     esp, ebp
.text$mn:0000C35E                 pop     ebp
.text$mn:0000C35F                 retn
.text$mn:0000C35F _wmemcmp        endp
.text$mn:0000C35F
.text$mn:0000C35F _text$mn        ends
.text$mn:0000C35F
.text$mn:0000C360 ; ===========================================================================
.text$mn:0000C360
.text$mn:0000C360 ; Segment type: Pure code
.text$mn:0000C360 ; Segment permissions: Read/Execute
.text$mn:0000C360 _text$mn        segment para public 'CODE' use32
.text$mn:0000C360                 assume cs:_text$mn
.text$mn:0000C360                 ;org 0C360h
.text$mn:0000C360 ; COMDAT (pick any)
.text$mn:0000C360                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C360
.text$mn:0000C360 ; =============== S U B R O U T I N E =======================================
.text$mn:0000C360
.text$mn:0000C360 ; Attributes: bp-based frame
.text$mn:0000C360
.text$mn:0000C360 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:0000C360                 public _wmemcpy
.text$mn:0000C360 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000C360
.text$mn:0000C360 Dst             = dword ptr  8
.text$mn:0000C360 Src             = dword ptr  0Ch
.text$mn:0000C360 arg_8           = dword ptr  10h
.text$mn:0000C360
.text$mn:0000C360                 push    ebp
.text$mn:0000C361                 mov     ebp, esp
.text$mn:0000C363                 mov     eax, [ebp+arg_8]
.text$mn:0000C366                 shl     eax, 1
.text$mn:0000C368                 push    eax             ; Size
.text$mn:0000C369                 mov     ecx, [ebp+Src]
.text$mn:0000C36C                 push    ecx             ; Src
.text$mn:0000C36D                 mov     edx, [ebp+Dst]
.text$mn:0000C370                 push    edx             ; Dst
.text$mn:0000C371                 call    _memcpy
.text$mn:0000C376                 add     esp, 0Ch
.text$mn:0000C379                 pop     ebp
.text$mn:0000C37A                 retn
.text$mn:0000C37A _wmemcpy        endp
.text$mn:0000C37A
.text$mn:0000C37A ; ---------------------------------------------------------------------------
.text$mn:0000C37B                 align 4
.text$mn:0000C37B _text$mn        ends
.text$mn:0000C37B
.text$mn:0000C37C ; ===========================================================================
.text$mn:0000C37C
.text$mn:0000C37C ; Segment type: Pure code
.text$mn:0000C37C ; Segment permissions: Read/Execute
.text$mn:0000C37C _text$mn        segment para public 'CODE' use32
.text$mn:0000C37C                 assume cs:_text$mn
.text$mn:0000C37C                 ;org 0C37Ch
.text$mn:0000C37C ; COMDAT (pick any)
.text$mn:0000C37C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000C37C
.text$mn:0000C37C ; =============== S U B R O U T I N E =======================================
.text$mn:0000C37C
.text$mn:0000C37C ; Attributes: bp-based frame
.text$mn:0000C37C
.text$mn:0000C37C ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:0000C37C                 public _wmemmove
.text$mn:0000C37C _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000C37C
.text$mn:0000C37C Dst             = dword ptr  8
.text$mn:0000C37C Src             = dword ptr  0Ch
.text$mn:0000C37C arg_8           = dword ptr  10h
.text$mn:0000C37C
.text$mn:0000C37C                 push    ebp
.text$mn:0000C37D                 mov     ebp, esp
.text$mn:0000C37F                 mov     eax, [ebp+arg_8]
.text$mn:0000C382                 shl     eax, 1
.text$mn:0000C384                 push    eax             ; Size
.text$mn:0000C385                 mov     ecx, [ebp+Src]
.text$mn:0000C388                 push    ecx             ; Src
.text$mn:0000C389                 mov     edx, [ebp+Dst]
.text$mn:0000C38C                 push    edx             ; Dst
.text$mn:0000C38D                 call    _memmove
.text$mn:0000C392                 add     esp, 0Ch
.text$mn:0000C395                 pop     ebp
.text$mn:0000C396                 retn
.text$mn:0000C396 _wmemmove       endp
.text$mn:0000C396
.text$mn:0000C396 ; ---------------------------------------------------------------------------
.text$mn:0000C397                 align 4
.text$mn:0000C397 _text$mn        ends
.text$mn:0000C397
.xdata$x:0000C398 ; ===========================================================================
.xdata$x:0000C398
.xdata$x:0000C398 ; Segment type: Pure data
.xdata$x:0000C398 ; Segment permissions: Read
.xdata$x:0000C398 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C398                 assume cs:_xdata$x
.xdata$x:0000C398                 ;org 0C398h
.xdata$x:0000C398 ; COMDAT (pick associative to section at 871C)
.xdata$x:0000C398 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:0000C398                                         ; DATA XREF: .xdata$x:0000C3A8o
.xdata$x:0000C399                 db 0FFh
.xdata$x:0000C39A                 db 0FFh
.xdata$x:0000C39B                 db 0FFh
.xdata$x:0000C39C                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000C3A0 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000C3A0                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000C3A1                 db    5
.xdata$x:0000C3A2                 db  93h ; 
.xdata$x:0000C3A3                 db  19h
.xdata$x:0000C3A4                 db    1
.xdata$x:0000C3A5                 db    0
.xdata$x:0000C3A6                 db    0
.xdata$x:0000C3A7                 db    0
.xdata$x:0000C3A8                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:0000C3AC                 db    0
.xdata$x:0000C3AD                 db    0
.xdata$x:0000C3AE                 db    0
.xdata$x:0000C3AF                 db    0
.xdata$x:0000C3B0                 db    0
.xdata$x:0000C3B1                 db    0
.xdata$x:0000C3B2                 db    0
.xdata$x:0000C3B3                 db    0
.xdata$x:0000C3B4                 db    0
.xdata$x:0000C3B5                 db    0
.xdata$x:0000C3B6                 db    0
.xdata$x:0000C3B7                 db    0
.xdata$x:0000C3B8                 db    0
.xdata$x:0000C3B9                 db    0
.xdata$x:0000C3BA                 db    0
.xdata$x:0000C3BB                 db    0
.xdata$x:0000C3BC                 db    0
.xdata$x:0000C3BD                 db    0
.xdata$x:0000C3BE                 db    0
.xdata$x:0000C3BF                 db    0
.xdata$x:0000C3C0                 db    0
.xdata$x:0000C3C1                 db    0
.xdata$x:0000C3C2                 db    0
.xdata$x:0000C3C3                 db    0
.xdata$x:0000C3C3 _xdata$x        ends
.xdata$x:0000C3C3
.xdata$x:0000C3C4 ; ===========================================================================
.xdata$x:0000C3C4
.xdata$x:0000C3C4 ; Segment type: Pure data
.xdata$x:0000C3C4 ; Segment permissions: Read
.xdata$x:0000C3C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C3C4                 assume cs:_xdata$x
.xdata$x:0000C3C4                 ;org 0C3C4h
.xdata$x:0000C3C4 ; COMDAT (pick associative to section at 5690)
.xdata$x:0000C3C4 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C3C4                                         ; DATA XREF: .xdata$x:0000C3D4o
.xdata$x:0000C3C5                 db 0FFh
.xdata$x:0000C3C6                 db 0FFh
.xdata$x:0000C3C7                 db 0FFh
.xdata$x:0000C3C8                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000C3CC __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C3CC                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000C3CD                 db    5
.xdata$x:0000C3CE                 db  93h ; 
.xdata$x:0000C3CF                 db  19h
.xdata$x:0000C3D0                 db    1
.xdata$x:0000C3D1                 db    0
.xdata$x:0000C3D2                 db    0
.xdata$x:0000C3D3                 db    0
.xdata$x:0000C3D4                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000C3D8                 db    0
.xdata$x:0000C3D9                 db    0
.xdata$x:0000C3DA                 db    0
.xdata$x:0000C3DB                 db    0
.xdata$x:0000C3DC                 db    0
.xdata$x:0000C3DD                 db    0
.xdata$x:0000C3DE                 db    0
.xdata$x:0000C3DF                 db    0
.xdata$x:0000C3E0                 db    0
.xdata$x:0000C3E1                 db    0
.xdata$x:0000C3E2                 db    0
.xdata$x:0000C3E3                 db    0
.xdata$x:0000C3E4                 db    0
.xdata$x:0000C3E5                 db    0
.xdata$x:0000C3E6                 db    0
.xdata$x:0000C3E7                 db    0
.xdata$x:0000C3E8                 db    0
.xdata$x:0000C3E9                 db    0
.xdata$x:0000C3EA                 db    0
.xdata$x:0000C3EB                 db    0
.xdata$x:0000C3EC                 db    0
.xdata$x:0000C3ED                 db    0
.xdata$x:0000C3EE                 db    0
.xdata$x:0000C3EF                 db    0
.xdata$x:0000C3EF _xdata$x        ends
.xdata$x:0000C3EF
.xdata$x:0000C3F0 ; ===========================================================================
.xdata$x:0000C3F0
.xdata$x:0000C3F0 ; Segment type: Pure data
.xdata$x:0000C3F0 ; Segment permissions: Read
.xdata$x:0000C3F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C3F0                 assume cs:_xdata$x
.xdata$x:0000C3F0                 ;org 0C3F0h
.xdata$x:0000C3F0 ; COMDAT (pick associative to section at 6900)
.xdata$x:0000C3F0 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C3F0                                         ; DATA XREF: .xdata$x:0000C400o
.xdata$x:0000C3F1                 db 0FFh
.xdata$x:0000C3F2                 db 0FFh
.xdata$x:0000C3F3                 db 0FFh
.xdata$x:0000C3F4                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000C3F8 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C3F8                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000C3F9                 db    5
.xdata$x:0000C3FA                 db  93h ; 
.xdata$x:0000C3FB                 db  19h
.xdata$x:0000C3FC                 db    1
.xdata$x:0000C3FD                 db    0
.xdata$x:0000C3FE                 db    0
.xdata$x:0000C3FF                 db    0
.xdata$x:0000C400                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000C404                 db    0
.xdata$x:0000C405                 db    0
.xdata$x:0000C406                 db    0
.xdata$x:0000C407                 db    0
.xdata$x:0000C408                 db    0
.xdata$x:0000C409                 db    0
.xdata$x:0000C40A                 db    0
.xdata$x:0000C40B                 db    0
.xdata$x:0000C40C                 db    0
.xdata$x:0000C40D                 db    0
.xdata$x:0000C40E                 db    0
.xdata$x:0000C40F                 db    0
.xdata$x:0000C410                 db    0
.xdata$x:0000C411                 db    0
.xdata$x:0000C412                 db    0
.xdata$x:0000C413                 db    0
.xdata$x:0000C414                 db    0
.xdata$x:0000C415                 db    0
.xdata$x:0000C416                 db    0
.xdata$x:0000C417                 db    0
.xdata$x:0000C418                 db    0
.xdata$x:0000C419                 db    0
.xdata$x:0000C41A                 db    0
.xdata$x:0000C41B                 db    0
.xdata$x:0000C41B _xdata$x        ends
.xdata$x:0000C41B
.xdata$x:0000C41C ; ===========================================================================
.xdata$x:0000C41C
.xdata$x:0000C41C ; Segment type: Pure data
.xdata$x:0000C41C ; Segment permissions: Read
.xdata$x:0000C41C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C41C                 assume cs:_xdata$x
.xdata$x:0000C41C                 ;org 0C41Ch
.xdata$x:0000C41C ; COMDAT (pick associative to section at 5520)
.xdata$x:0000C41C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000C41C                                         ; DATA XREF: .xdata$x:0000C42Co
.xdata$x:0000C41D                 db 0FFh
.xdata$x:0000C41E                 db 0FFh
.xdata$x:0000C41F                 db 0FFh
.xdata$x:0000C420                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:0000C424 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:0000C424                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:0000C425                 db    5
.xdata$x:0000C426                 db  93h ; 
.xdata$x:0000C427                 db  19h
.xdata$x:0000C428                 db    1
.xdata$x:0000C429                 db    0
.xdata$x:0000C42A                 db    0
.xdata$x:0000C42B                 db    0
.xdata$x:0000C42C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:0000C430                 db    0
.xdata$x:0000C431                 db    0
.xdata$x:0000C432                 db    0
.xdata$x:0000C433                 db    0
.xdata$x:0000C434                 db    0
.xdata$x:0000C435                 db    0
.xdata$x:0000C436                 db    0
.xdata$x:0000C437                 db    0
.xdata$x:0000C438                 db    0
.xdata$x:0000C439                 db    0
.xdata$x:0000C43A                 db    0
.xdata$x:0000C43B                 db    0
.xdata$x:0000C43C                 db    0
.xdata$x:0000C43D                 db    0
.xdata$x:0000C43E                 db    0
.xdata$x:0000C43F                 db    0
.xdata$x:0000C440                 db    0
.xdata$x:0000C441                 db    0
.xdata$x:0000C442                 db    0
.xdata$x:0000C443                 db    0
.xdata$x:0000C444                 db    0
.xdata$x:0000C445                 db    0
.xdata$x:0000C446                 db    0
.xdata$x:0000C447                 db    0
.xdata$x:0000C447 _xdata$x        ends
.xdata$x:0000C447
.xdata$x:0000C448 ; ===========================================================================
.xdata$x:0000C448
.xdata$x:0000C448 ; Segment type: Pure data
.xdata$x:0000C448 ; Segment permissions: Read
.xdata$x:0000C448 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C448                 assume cs:_xdata$x
.xdata$x:0000C448                 ;org 0C448h
.xdata$x:0000C448 ; COMDAT (pick associative to section at 6810)
.xdata$x:0000C448 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C448                                         ; DATA XREF: .xdata$x:0000C458o
.xdata$x:0000C449                 db 0FFh
.xdata$x:0000C44A                 db 0FFh
.xdata$x:0000C44B                 db 0FFh
.xdata$x:0000C44C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000C450 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C450                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000C451                 db    5
.xdata$x:0000C452                 db  93h ; 
.xdata$x:0000C453                 db  19h
.xdata$x:0000C454                 db    1
.xdata$x:0000C455                 db    0
.xdata$x:0000C456                 db    0
.xdata$x:0000C457                 db    0
.xdata$x:0000C458                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000C45C                 db    0
.xdata$x:0000C45D                 db    0
.xdata$x:0000C45E                 db    0
.xdata$x:0000C45F                 db    0
.xdata$x:0000C460                 db    0
.xdata$x:0000C461                 db    0
.xdata$x:0000C462                 db    0
.xdata$x:0000C463                 db    0
.xdata$x:0000C464                 db    0
.xdata$x:0000C465                 db    0
.xdata$x:0000C466                 db    0
.xdata$x:0000C467                 db    0
.xdata$x:0000C468                 db    0
.xdata$x:0000C469                 db    0
.xdata$x:0000C46A                 db    0
.xdata$x:0000C46B                 db    0
.xdata$x:0000C46C                 db    0
.xdata$x:0000C46D                 db    0
.xdata$x:0000C46E                 db    0
.xdata$x:0000C46F                 db    0
.xdata$x:0000C470                 db    0
.xdata$x:0000C471                 db    0
.xdata$x:0000C472                 db    0
.xdata$x:0000C473                 db    0
.xdata$x:0000C473 _xdata$x        ends
.xdata$x:0000C473
.xdata$x:0000C474 ; ===========================================================================
.xdata$x:0000C474
.xdata$x:0000C474 ; Segment type: Pure data
.xdata$x:0000C474 ; Segment permissions: Read
.xdata$x:0000C474 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C474                 assume cs:_xdata$x
.xdata$x:0000C474                 ;org 0C474h
.xdata$x:0000C474 ; COMDAT (pick associative to section at 5AF4)
.xdata$x:0000C474 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000C474                                         ; DATA XREF: .xdata$x:0000C484o
.xdata$x:0000C475                 db 0FFh
.xdata$x:0000C476                 db 0FFh
.xdata$x:0000C477                 db 0FFh
.xdata$x:0000C478                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:0000C47C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000C47C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:0000C47D                 db    5
.xdata$x:0000C47E                 db  93h ; 
.xdata$x:0000C47F                 db  19h
.xdata$x:0000C480                 db    1
.xdata$x:0000C481                 db    0
.xdata$x:0000C482                 db    0
.xdata$x:0000C483                 db    0
.xdata$x:0000C484                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:0000C488                 align 20h
.xdata$x:0000C488 _xdata$x        ends
.xdata$x:0000C488
.xdata$x:0000C4A0 ; ===========================================================================
.xdata$x:0000C4A0
.xdata$x:0000C4A0 ; Segment type: Pure data
.xdata$x:0000C4A0 ; Segment permissions: Read
.xdata$x:0000C4A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C4A0                 assume cs:_xdata$x
.xdata$x:0000C4A0                 ;org 0C4A0h
.xdata$x:0000C4A0 ; COMDAT (pick associative to section at 6AC8)
.xdata$x:0000C4A0 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000C4A0                                         ; DATA XREF: .xdata$x:0000C4B0o
.xdata$x:0000C4A1                 db 0FFh
.xdata$x:0000C4A2                 db 0FFh
.xdata$x:0000C4A3                 db 0FFh
.xdata$x:0000C4A4                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:0000C4A8 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C4A8                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:0000C4A9                 db    5
.xdata$x:0000C4AA                 db  93h ; 
.xdata$x:0000C4AB                 db  19h
.xdata$x:0000C4AC                 db    1
.xdata$x:0000C4AD                 db    0
.xdata$x:0000C4AE                 db    0
.xdata$x:0000C4AF                 db    0
.xdata$x:0000C4B0                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:0000C4B4                 db    0
.xdata$x:0000C4B5                 db    0
.xdata$x:0000C4B6                 db    0
.xdata$x:0000C4B7                 db    0
.xdata$x:0000C4B8                 db    0
.xdata$x:0000C4B9                 db    0
.xdata$x:0000C4BA                 db    0
.xdata$x:0000C4BB                 db    0
.xdata$x:0000C4BC                 db    0
.xdata$x:0000C4BD                 db    0
.xdata$x:0000C4BE                 db    0
.xdata$x:0000C4BF                 db    0
.xdata$x:0000C4C0                 db    0
.xdata$x:0000C4C1                 db    0
.xdata$x:0000C4C2                 db    0
.xdata$x:0000C4C3                 db    0
.xdata$x:0000C4C4                 db    0
.xdata$x:0000C4C5                 db    0
.xdata$x:0000C4C6                 db    0
.xdata$x:0000C4C7                 db    0
.xdata$x:0000C4C8                 db    0
.xdata$x:0000C4C9                 db    0
.xdata$x:0000C4CA                 db    0
.xdata$x:0000C4CB                 db    0
.xdata$x:0000C4CB _xdata$x        ends
.xdata$x:0000C4CB
.xdata$x:0000C4CC ; ===========================================================================
.xdata$x:0000C4CC
.xdata$x:0000C4CC ; Segment type: Pure data
.xdata$x:0000C4CC ; Segment permissions: Read
.xdata$x:0000C4CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C4CC                 assume cs:_xdata$x
.xdata$x:0000C4CC                 ;org 0C4CCh
.xdata$x:0000C4CC ; COMDAT (pick associative to section at 7A1C)
.xdata$x:0000C4CC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000C4CC                                         ; DATA XREF: .xdata$x:0000C554o
.xdata$x:0000C4CD                 db    0
.xdata$x:0000C4CE                 db    0
.xdata$x:0000C4CF                 db    0
.xdata$x:0000C4D0                 db    0
.xdata$x:0000C4D1                 db    0
.xdata$x:0000C4D2                 db    0
.xdata$x:0000C4D3                 db    0
.xdata$x:0000C4D4                 db    0
.xdata$x:0000C4D5                 db    0
.xdata$x:0000C4D6                 db    0
.xdata$x:0000C4D7                 db    0
.xdata$x:0000C4D8                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0000C4DC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000C4DC                                         ; DATA XREF: .xdata$x:0000C540o
.xdata$x:0000C4DD                 db    0
.xdata$x:0000C4DE                 db    0
.xdata$x:0000C4DF                 db    0
.xdata$x:0000C4E0                 db    0
.xdata$x:0000C4E1                 db    0
.xdata$x:0000C4E2                 db    0
.xdata$x:0000C4E3                 db    0
.xdata$x:0000C4E4                 db    0
.xdata$x:0000C4E5                 db    0
.xdata$x:0000C4E6                 db    0
.xdata$x:0000C4E7                 db    0
.xdata$x:0000C4E8                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000C4EC __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000C4EC                                         ; DATA XREF: .xdata$x:0000C514o
.xdata$x:0000C4ED                 db 0FFh
.xdata$x:0000C4EE                 db 0FFh
.xdata$x:0000C4EF                 db 0FFh
.xdata$x:0000C4F0                 db    0
.xdata$x:0000C4F1                 db    0
.xdata$x:0000C4F2                 db    0
.xdata$x:0000C4F3                 db    0
.xdata$x:0000C4F4                 db 0FFh
.xdata$x:0000C4F5                 db 0FFh
.xdata$x:0000C4F6                 db 0FFh
.xdata$x:0000C4F7                 db 0FFh
.xdata$x:0000C4F8                 db    0
.xdata$x:0000C4F9                 db    0
.xdata$x:0000C4FA                 db    0
.xdata$x:0000C4FB                 db    0
.xdata$x:0000C4FC                 db    1
.xdata$x:0000C4FD                 db    0
.xdata$x:0000C4FE                 db    0
.xdata$x:0000C4FF                 db    0
.xdata$x:0000C500                 db    0
.xdata$x:0000C501                 db    0
.xdata$x:0000C502                 db    0
.xdata$x:0000C503                 db    0
.xdata$x:0000C504                 db    1
.xdata$x:0000C505                 db    0
.xdata$x:0000C506                 db    0
.xdata$x:0000C507                 db    0
.xdata$x:0000C508                 db    0
.xdata$x:0000C509                 db    0
.xdata$x:0000C50A                 db    0
.xdata$x:0000C50B                 db    0
.xdata$x:0000C50C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000C50C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0000C50D                 db    5
.xdata$x:0000C50E                 db  93h ; 
.xdata$x:0000C50F                 db  19h
.xdata$x:0000C510                 db    4
.xdata$x:0000C511                 db    0
.xdata$x:0000C512                 db    0
.xdata$x:0000C513                 db    0
.xdata$x:0000C514                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000C518                 db    2
.xdata$x:0000C519                 db    0
.xdata$x:0000C51A                 db    0
.xdata$x:0000C51B                 db    0
.xdata$x:0000C51C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000C520                 db    0
.xdata$x:0000C521                 db    0
.xdata$x:0000C522                 db    0
.xdata$x:0000C523                 db    0
.xdata$x:0000C524                 db    0
.xdata$x:0000C525                 db    0
.xdata$x:0000C526                 db    0
.xdata$x:0000C527                 db    0
.xdata$x:0000C528                 db    0
.xdata$x:0000C529                 db    0
.xdata$x:0000C52A                 db    0
.xdata$x:0000C52B                 db    0
.xdata$x:0000C52C                 db    0
.xdata$x:0000C52D                 db    0
.xdata$x:0000C52E                 db    0
.xdata$x:0000C52F                 db    0
.xdata$x:0000C530 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:0000C530                                         ; DATA XREF: .xdata$x:0000C51Co
.xdata$x:0000C531                 db    0
.xdata$x:0000C532                 db    0
.xdata$x:0000C533                 db    0
.xdata$x:0000C534                 db    2
.xdata$x:0000C535                 db    0
.xdata$x:0000C536                 db    0
.xdata$x:0000C537                 db    0
.xdata$x:0000C538                 db    3
.xdata$x:0000C539                 db    0
.xdata$x:0000C53A                 db    0
.xdata$x:0000C53B                 db    0
.xdata$x:0000C53C                 db    1
.xdata$x:0000C53D                 db    0
.xdata$x:0000C53E                 db    0
.xdata$x:0000C53F                 db    0
.xdata$x:0000C540                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:0000C544                 db    0
.xdata$x:0000C545                 db    0
.xdata$x:0000C546                 db    0
.xdata$x:0000C547                 db    0
.xdata$x:0000C548                 db    0
.xdata$x:0000C549                 db    0
.xdata$x:0000C54A                 db    0
.xdata$x:0000C54B                 db    0
.xdata$x:0000C54C                 db    3
.xdata$x:0000C54D                 db    0
.xdata$x:0000C54E                 db    0
.xdata$x:0000C54F                 db    0
.xdata$x:0000C550                 db    1
.xdata$x:0000C551                 db    0
.xdata$x:0000C552                 db    0
.xdata$x:0000C553                 db    0
.xdata$x:0000C554                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:0000C554 _xdata$x        ends
.xdata$x:0000C554
.xdata$x:0000C558 ; ===========================================================================
.xdata$x:0000C558
.xdata$x:0000C558 ; Segment type: Pure data
.xdata$x:0000C558 ; Segment permissions: Read
.xdata$x:0000C558 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C558                 assume cs:_xdata$x
.xdata$x:0000C558                 ;org 0C558h
.xdata$x:0000C558 ; COMDAT (pick associative to section at 6648)
.xdata$x:0000C558 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000C558                                         ; DATA XREF: .xdata$x:0000C568o
.xdata$x:0000C559                 db 0FFh
.xdata$x:0000C55A                 db 0FFh
.xdata$x:0000C55B                 db 0FFh
.xdata$x:0000C55C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:0000C560 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000C560                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:0000C561                 db    5
.xdata$x:0000C562                 db  93h ; 
.xdata$x:0000C563                 db  19h
.xdata$x:0000C564                 db    1
.xdata$x:0000C565                 db    0
.xdata$x:0000C566                 db    0
.xdata$x:0000C567                 db    0
.xdata$x:0000C568                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000C56C                 db    0
.xdata$x:0000C56D                 db    0
.xdata$x:0000C56E                 db    0
.xdata$x:0000C56F                 db    0
.xdata$x:0000C570                 db    0
.xdata$x:0000C571                 db    0
.xdata$x:0000C572                 db    0
.xdata$x:0000C573                 db    0
.xdata$x:0000C574                 db    0
.xdata$x:0000C575                 db    0
.xdata$x:0000C576                 db    0
.xdata$x:0000C577                 db    0
.xdata$x:0000C578                 db    0
.xdata$x:0000C579                 db    0
.xdata$x:0000C57A                 db    0
.xdata$x:0000C57B                 db    0
.xdata$x:0000C57C                 db    0
.xdata$x:0000C57D                 db    0
.xdata$x:0000C57E                 db    0
.xdata$x:0000C57F                 db    0
.xdata$x:0000C580                 db    0
.xdata$x:0000C581                 db    0
.xdata$x:0000C582                 db    0
.xdata$x:0000C583                 db    0
.xdata$x:0000C583 _xdata$x        ends
.xdata$x:0000C583
.xdata$x:0000C584 ; ===========================================================================
.xdata$x:0000C584
.xdata$x:0000C584 ; Segment type: Pure data
.xdata$x:0000C584 ; Segment permissions: Read
.xdata$x:0000C584 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C584                 assume cs:_xdata$x
.xdata$x:0000C584                 ;org 0C584h
.xdata$x:0000C584 ; COMDAT (pick associative to section at B558)
.xdata$x:0000C584 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000C584                                         ; DATA XREF: .xdata$x:0000C594o
.xdata$x:0000C585                 db 0FFh
.xdata$x:0000C586                 db 0FFh
.xdata$x:0000C587                 db 0FFh
.xdata$x:0000C588                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000C58C __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000C58C                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000C58D                 db    5
.xdata$x:0000C58E                 db  93h ; 
.xdata$x:0000C58F                 db  19h
.xdata$x:0000C590                 db    1
.xdata$x:0000C591                 db    0
.xdata$x:0000C592                 db    0
.xdata$x:0000C593                 db    0
.xdata$x:0000C594                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000C598                 db    0
.xdata$x:0000C599                 db    0
.xdata$x:0000C59A                 db    0
.xdata$x:0000C59B                 db    0
.xdata$x:0000C59C                 db    0
.xdata$x:0000C59D                 db    0
.xdata$x:0000C59E                 db    0
.xdata$x:0000C59F                 db    0
.xdata$x:0000C5A0                 db    0
.xdata$x:0000C5A1                 db    0
.xdata$x:0000C5A2                 db    0
.xdata$x:0000C5A3                 db    0
.xdata$x:0000C5A4                 db    0
.xdata$x:0000C5A5                 db    0
.xdata$x:0000C5A6                 db    0
.xdata$x:0000C5A7                 db    0
.xdata$x:0000C5A8                 db    0
.xdata$x:0000C5A9                 db    0
.xdata$x:0000C5AA                 db    0
.xdata$x:0000C5AB                 db    0
.xdata$x:0000C5AC                 db    0
.xdata$x:0000C5AD                 db    0
.xdata$x:0000C5AE                 db    0
.xdata$x:0000C5AF                 db    0
.xdata$x:0000C5AF _xdata$x        ends
.xdata$x:0000C5AF
.xdata$x:0000C5B0 ; ===========================================================================
.xdata$x:0000C5B0
.xdata$x:0000C5B0 ; Segment type: Pure data
.xdata$x:0000C5B0 ; Segment permissions: Read
.xdata$x:0000C5B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C5B0                 assume cs:_xdata$x
.xdata$x:0000C5B0                 ;org 0C5B0h
.xdata$x:0000C5B0 ; COMDAT (pick associative to section at 6FF4)
.xdata$x:0000C5B0 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000C5B0                                         ; DATA XREF: .xdata$x:0000C5C0o
.xdata$x:0000C5B1                 db 0FFh
.xdata$x:0000C5B2                 db 0FFh
.xdata$x:0000C5B3                 db 0FFh
.xdata$x:0000C5B4                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:0000C5B8 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000C5B8                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:0000C5B9                 db    5
.xdata$x:0000C5BA                 db  93h ; 
.xdata$x:0000C5BB                 db  19h
.xdata$x:0000C5BC                 db    1
.xdata$x:0000C5BD                 db    0
.xdata$x:0000C5BE                 db    0
.xdata$x:0000C5BF                 db    0
.xdata$x:0000C5C0                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:0000C5C4                 db    0
.xdata$x:0000C5C5                 db    0
.xdata$x:0000C5C6                 db    0
.xdata$x:0000C5C7                 db    0
.xdata$x:0000C5C8                 db    0
.xdata$x:0000C5C9                 db    0
.xdata$x:0000C5CA                 db    0
.xdata$x:0000C5CB                 db    0
.xdata$x:0000C5CC                 db    0
.xdata$x:0000C5CD                 db    0
.xdata$x:0000C5CE                 db    0
.xdata$x:0000C5CF                 db    0
.xdata$x:0000C5D0                 db    0
.xdata$x:0000C5D1                 db    0
.xdata$x:0000C5D2                 db    0
.xdata$x:0000C5D3                 db    0
.xdata$x:0000C5D4                 db    0
.xdata$x:0000C5D5                 db    0
.xdata$x:0000C5D6                 db    0
.xdata$x:0000C5D7                 db    0
.xdata$x:0000C5D8                 db    0
.xdata$x:0000C5D9                 db    0
.xdata$x:0000C5DA                 db    0
.xdata$x:0000C5DB                 db    0
.xdata$x:0000C5DB _xdata$x        ends
.xdata$x:0000C5DB
.xdata$x:0000C5DC ; ===========================================================================
.xdata$x:0000C5DC
.xdata$x:0000C5DC ; Segment type: Pure data
.xdata$x:0000C5DC ; Segment permissions: Read
.xdata$x:0000C5DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C5DC                 assume cs:_xdata$x
.xdata$x:0000C5DC                 ;org 0C5DCh
.xdata$x:0000C5DC ; COMDAT (pick associative to section at 66C4)
.xdata$x:0000C5DC __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000C5DC                                         ; DATA XREF: .xdata$x:0000C5ECo
.xdata$x:0000C5DD                 db 0FFh
.xdata$x:0000C5DE                 db 0FFh
.xdata$x:0000C5DF                 db 0FFh
.xdata$x:0000C5E0                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:0000C5E4 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000C5E4                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:0000C5E5                 db    5
.xdata$x:0000C5E6                 db  93h ; 
.xdata$x:0000C5E7                 db  19h
.xdata$x:0000C5E8                 db    1
.xdata$x:0000C5E9                 db    0
.xdata$x:0000C5EA                 db    0
.xdata$x:0000C5EB                 db    0
.xdata$x:0000C5EC                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:0000C5F0                 db    0
.xdata$x:0000C5F1                 db    0
.xdata$x:0000C5F2                 db    0
.xdata$x:0000C5F3                 db    0
.xdata$x:0000C5F4                 db    0
.xdata$x:0000C5F5                 db    0
.xdata$x:0000C5F6                 db    0
.xdata$x:0000C5F7                 db    0
.xdata$x:0000C5F8                 db    0
.xdata$x:0000C5F9                 db    0
.xdata$x:0000C5FA                 db    0
.xdata$x:0000C5FB                 db    0
.xdata$x:0000C5FC                 db    0
.xdata$x:0000C5FD                 db    0
.xdata$x:0000C5FE                 db    0
.xdata$x:0000C5FF                 db    0
.xdata$x:0000C600                 db    0
.xdata$x:0000C601                 db    0
.xdata$x:0000C602                 db    0
.xdata$x:0000C603                 db    0
.xdata$x:0000C604                 db    0
.xdata$x:0000C605                 db    0
.xdata$x:0000C606                 db    0
.xdata$x:0000C607                 db    0
.xdata$x:0000C607 _xdata$x        ends
.xdata$x:0000C607
.xdata$x:0000C608 ; ===========================================================================
.xdata$x:0000C608
.xdata$x:0000C608 ; Segment type: Pure data
.xdata$x:0000C608 ; Segment permissions: Read
.xdata$x:0000C608 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C608                 assume cs:_xdata$x
.xdata$x:0000C608                 ;org 0C608h
.xdata$x:0000C608 ; COMDAT (pick associative to section at B610)
.xdata$x:0000C608 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000C608                                         ; DATA XREF: .xdata$x:0000C618o
.xdata$x:0000C609                 db 0FFh
.xdata$x:0000C60A                 db 0FFh
.xdata$x:0000C60B                 db 0FFh
.xdata$x:0000C60C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000C610 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000C610                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000C611                 db    5
.xdata$x:0000C612                 db  93h ; 
.xdata$x:0000C613                 db  19h
.xdata$x:0000C614                 db    1
.xdata$x:0000C615                 db    0
.xdata$x:0000C616                 db    0
.xdata$x:0000C617                 db    0
.xdata$x:0000C618                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000C61C                 db    0
.xdata$x:0000C61D                 db    0
.xdata$x:0000C61E                 db    0
.xdata$x:0000C61F                 db    0
.xdata$x:0000C620                 db    0
.xdata$x:0000C621                 db    0
.xdata$x:0000C622                 db    0
.xdata$x:0000C623                 db    0
.xdata$x:0000C624                 db    0
.xdata$x:0000C625                 db    0
.xdata$x:0000C626                 db    0
.xdata$x:0000C627                 db    0
.xdata$x:0000C628                 db    0
.xdata$x:0000C629                 db    0
.xdata$x:0000C62A                 db    0
.xdata$x:0000C62B                 db    0
.xdata$x:0000C62C                 db    0
.xdata$x:0000C62D                 db    0
.xdata$x:0000C62E                 db    0
.xdata$x:0000C62F                 db    0
.xdata$x:0000C630                 db    0
.xdata$x:0000C631                 db    0
.xdata$x:0000C632                 db    0
.xdata$x:0000C633                 db    0
.xdata$x:0000C633 _xdata$x        ends
.xdata$x:0000C633
.xdata$x:0000C634 ; ===========================================================================
.xdata$x:0000C634
.xdata$x:0000C634 ; Segment type: Pure data
.xdata$x:0000C634 ; Segment permissions: Read
.xdata$x:0000C634 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C634                 assume cs:_xdata$x
.xdata$x:0000C634                 ;org 0C634h
.xdata$x:0000C634 ; COMDAT (pick associative to section at 7064)
.xdata$x:0000C634 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000C634                                         ; DATA XREF: .xdata$x:0000C644o
.xdata$x:0000C635                 db 0FFh
.xdata$x:0000C636                 db 0FFh
.xdata$x:0000C637                 db 0FFh
.xdata$x:0000C638                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0000C63C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000C63C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0000C63D                 db    5
.xdata$x:0000C63E                 db  93h ; 
.xdata$x:0000C63F                 db  19h
.xdata$x:0000C640                 db    1
.xdata$x:0000C641                 db    0
.xdata$x:0000C642                 db    0
.xdata$x:0000C643                 db    0
.xdata$x:0000C644                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:0000C648                 align 20h
.xdata$x:0000C648 _xdata$x        ends
.xdata$x:0000C648
.xdata$x:0000C660 ; ===========================================================================
.xdata$x:0000C660
.xdata$x:0000C660 ; Segment type: Pure data
.xdata$x:0000C660 ; Segment permissions: Read
.xdata$x:0000C660 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C660                 assume cs:_xdata$x
.xdata$x:0000C660                 ;org 0C660h
.xdata$x:0000C660 ; COMDAT (pick associative to section at 6740)
.xdata$x:0000C660 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000C660                                         ; DATA XREF: .xdata$x:0000C670o
.xdata$x:0000C661                 db 0FFh
.xdata$x:0000C662                 db 0FFh
.xdata$x:0000C663                 db 0FFh
.xdata$x:0000C664                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:0000C668 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000C668                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:0000C669                 db    5
.xdata$x:0000C66A                 db  93h ; 
.xdata$x:0000C66B                 db  19h
.xdata$x:0000C66C                 db    1
.xdata$x:0000C66D                 db    0
.xdata$x:0000C66E                 db    0
.xdata$x:0000C66F                 db    0
.xdata$x:0000C670                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:0000C674                 db    0
.xdata$x:0000C675                 db    0
.xdata$x:0000C676                 db    0
.xdata$x:0000C677                 db    0
.xdata$x:0000C678                 db    0
.xdata$x:0000C679                 db    0
.xdata$x:0000C67A                 db    0
.xdata$x:0000C67B                 db    0
.xdata$x:0000C67C                 db    0
.xdata$x:0000C67D                 db    0
.xdata$x:0000C67E                 db    0
.xdata$x:0000C67F                 db    0
.xdata$x:0000C680                 db    0
.xdata$x:0000C681                 db    0
.xdata$x:0000C682                 db    0
.xdata$x:0000C683                 db    0
.xdata$x:0000C684                 db    0
.xdata$x:0000C685                 db    0
.xdata$x:0000C686                 db    0
.xdata$x:0000C687                 db    0
.xdata$x:0000C688                 db    0
.xdata$x:0000C689                 db    0
.xdata$x:0000C68A                 db    0
.xdata$x:0000C68B                 db    0
.xdata$x:0000C68B _xdata$x        ends
.xdata$x:0000C68B
.xdata$x:0000C68C ; ===========================================================================
.xdata$x:0000C68C
.xdata$x:0000C68C ; Segment type: Pure data
.xdata$x:0000C68C ; Segment permissions: Read
.xdata$x:0000C68C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C68C                 assume cs:_xdata$x
.xdata$x:0000C68C                 ;org 0C68Ch
.xdata$x:0000C68C ; COMDAT (pick associative to section at B6D4)
.xdata$x:0000C68C __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000C68C                                         ; DATA XREF: .xdata$x:0000C69Co
.xdata$x:0000C68D                 db 0FFh
.xdata$x:0000C68E                 db 0FFh
.xdata$x:0000C68F                 db 0FFh
.xdata$x:0000C690                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000C694 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000C694                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000C695                 db    5
.xdata$x:0000C696                 db  93h ; 
.xdata$x:0000C697                 db  19h
.xdata$x:0000C698                 db    1
.xdata$x:0000C699                 db    0
.xdata$x:0000C69A                 db    0
.xdata$x:0000C69B                 db    0
.xdata$x:0000C69C                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000C6A0                 db    0
.xdata$x:0000C6A1                 db    0
.xdata$x:0000C6A2                 db    0
.xdata$x:0000C6A3                 db    0
.xdata$x:0000C6A4                 db    0
.xdata$x:0000C6A5                 db    0
.xdata$x:0000C6A6                 db    0
.xdata$x:0000C6A7                 db    0
.xdata$x:0000C6A8                 db    0
.xdata$x:0000C6A9                 db    0
.xdata$x:0000C6AA                 db    0
.xdata$x:0000C6AB                 db    0
.xdata$x:0000C6AC                 db    0
.xdata$x:0000C6AD                 db    0
.xdata$x:0000C6AE                 db    0
.xdata$x:0000C6AF                 db    0
.xdata$x:0000C6B0                 db    0
.xdata$x:0000C6B1                 db    0
.xdata$x:0000C6B2                 db    0
.xdata$x:0000C6B3                 db    0
.xdata$x:0000C6B4                 db    0
.xdata$x:0000C6B5                 db    0
.xdata$x:0000C6B6                 db    0
.xdata$x:0000C6B7                 db    0
.xdata$x:0000C6B7 _xdata$x        ends
.xdata$x:0000C6B7
.xdata$x:0000C6B8 ; ===========================================================================
.xdata$x:0000C6B8
.xdata$x:0000C6B8 ; Segment type: Pure data
.xdata$x:0000C6B8 ; Segment permissions: Read
.xdata$x:0000C6B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C6B8                 assume cs:_xdata$x
.xdata$x:0000C6B8                 ;org 0C6B8h
.xdata$x:0000C6B8 ; COMDAT (pick associative to section at 70D4)
.xdata$x:0000C6B8 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000C6B8                                         ; DATA XREF: .xdata$x:0000C6C8o
.xdata$x:0000C6B9                 db 0FFh
.xdata$x:0000C6BA                 db 0FFh
.xdata$x:0000C6BB                 db 0FFh
.xdata$x:0000C6BC                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:0000C6C0 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000C6C0                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:0000C6C1                 db    5
.xdata$x:0000C6C2                 db  93h ; 
.xdata$x:0000C6C3                 db  19h
.xdata$x:0000C6C4                 db    1
.xdata$x:0000C6C5                 db    0
.xdata$x:0000C6C6                 db    0
.xdata$x:0000C6C7                 db    0
.xdata$x:0000C6C8                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000C6CC                 db    0
.xdata$x:0000C6CD                 db    0
.xdata$x:0000C6CE                 db    0
.xdata$x:0000C6CF                 db    0
.xdata$x:0000C6D0                 db    0
.xdata$x:0000C6D1                 db    0
.xdata$x:0000C6D2                 db    0
.xdata$x:0000C6D3                 db    0
.xdata$x:0000C6D4                 db    0
.xdata$x:0000C6D5                 db    0
.xdata$x:0000C6D6                 db    0
.xdata$x:0000C6D7                 db    0
.xdata$x:0000C6D8                 db    0
.xdata$x:0000C6D9                 db    0
.xdata$x:0000C6DA                 db    0
.xdata$x:0000C6DB                 db    0
.xdata$x:0000C6DC                 db    0
.xdata$x:0000C6DD                 db    0
.xdata$x:0000C6DE                 db    0
.xdata$x:0000C6DF                 db    0
.xdata$x:0000C6E0                 db    0
.xdata$x:0000C6E1                 db    0
.xdata$x:0000C6E2                 db    0
.xdata$x:0000C6E3                 db    0
.xdata$x:0000C6E3 _xdata$x        ends
.xdata$x:0000C6E3
.xdata$x:0000C6E4 ; ===========================================================================
.xdata$x:0000C6E4
.xdata$x:0000C6E4 ; Segment type: Pure data
.xdata$x:0000C6E4 ; Segment permissions: Read
.xdata$x:0000C6E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C6E4                 assume cs:_xdata$x
.xdata$x:0000C6E4                 ;org 0C6E4h
.xdata$x:0000C6E4 ; COMDAT (pick associative to section at 57CC)
.xdata$x:0000C6E4 __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C6E4                                         ; DATA XREF: .xdata$x:0000C6F4o
.xdata$x:0000C6E5                 db 0FFh
.xdata$x:0000C6E6                 db 0FFh
.xdata$x:0000C6E7                 db 0FFh
.xdata$x:0000C6E8                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000C6EC __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C6EC                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000C6ED                 db    5
.xdata$x:0000C6EE                 db  93h ; 
.xdata$x:0000C6EF                 db  19h
.xdata$x:0000C6F0                 db    1
.xdata$x:0000C6F1                 db    0
.xdata$x:0000C6F2                 db    0
.xdata$x:0000C6F3                 db    0
.xdata$x:0000C6F4                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000C6F8                 db    0
.xdata$x:0000C6F9                 db    0
.xdata$x:0000C6FA                 db    0
.xdata$x:0000C6FB                 db    0
.xdata$x:0000C6FC                 db    0
.xdata$x:0000C6FD                 db    0
.xdata$x:0000C6FE                 db    0
.xdata$x:0000C6FF                 db    0
.xdata$x:0000C700                 db    0
.xdata$x:0000C701                 db    0
.xdata$x:0000C702                 db    0
.xdata$x:0000C703                 db    0
.xdata$x:0000C704                 db    0
.xdata$x:0000C705                 db    0
.xdata$x:0000C706                 db    0
.xdata$x:0000C707                 db    0
.xdata$x:0000C708                 db    0
.xdata$x:0000C709                 db    0
.xdata$x:0000C70A                 db    0
.xdata$x:0000C70B                 db    0
.xdata$x:0000C70C                 db    0
.xdata$x:0000C70D                 db    0
.xdata$x:0000C70E                 db    0
.xdata$x:0000C70F                 db    0
.xdata$x:0000C70F _xdata$x        ends
.xdata$x:0000C70F
.xdata$x:0000C710 ; ===========================================================================
.xdata$x:0000C710
.xdata$x:0000C710 ; Segment type: Pure data
.xdata$x:0000C710 ; Segment permissions: Read
.xdata$x:0000C710 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C710                 assume cs:_xdata$x
.xdata$x:0000C710                 ;org 0C710h
.xdata$x:0000C710 ; COMDAT (pick associative to section at 6970)
.xdata$x:0000C710 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C710                                         ; DATA XREF: .xdata$x:0000C720o
.xdata$x:0000C711                 db 0FFh
.xdata$x:0000C712                 db 0FFh
.xdata$x:0000C713                 db 0FFh
.xdata$x:0000C714                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000C718 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C718                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000C719                 db    5
.xdata$x:0000C71A                 db  93h ; 
.xdata$x:0000C71B                 db  19h
.xdata$x:0000C71C                 db    1
.xdata$x:0000C71D                 db    0
.xdata$x:0000C71E                 db    0
.xdata$x:0000C71F                 db    0
.xdata$x:0000C720                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000C724                 db    0
.xdata$x:0000C725                 db    0
.xdata$x:0000C726                 db    0
.xdata$x:0000C727                 db    0
.xdata$x:0000C728                 db    0
.xdata$x:0000C729                 db    0
.xdata$x:0000C72A                 db    0
.xdata$x:0000C72B                 db    0
.xdata$x:0000C72C                 db    0
.xdata$x:0000C72D                 db    0
.xdata$x:0000C72E                 db    0
.xdata$x:0000C72F                 db    0
.xdata$x:0000C730                 db    0
.xdata$x:0000C731                 db    0
.xdata$x:0000C732                 db    0
.xdata$x:0000C733                 db    0
.xdata$x:0000C734                 db    0
.xdata$x:0000C735                 db    0
.xdata$x:0000C736                 db    0
.xdata$x:0000C737                 db    0
.xdata$x:0000C738                 db    0
.xdata$x:0000C739                 db    0
.xdata$x:0000C73A                 db    0
.xdata$x:0000C73B                 db    0
.xdata$x:0000C73B _xdata$x        ends
.xdata$x:0000C73B
.xdata$x:0000C73C ; ===========================================================================
.xdata$x:0000C73C
.xdata$x:0000C73C ; Segment type: Pure data
.xdata$x:0000C73C ; Segment permissions: Read
.xdata$x:0000C73C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C73C                 assume cs:_xdata$x
.xdata$x:0000C73C                 ;org 0C73Ch
.xdata$x:0000C73C ; COMDAT (pick associative to section at 5718)
.xdata$x:0000C73C __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000C73C                                         ; DATA XREF: .xdata$x:0000C74Co
.xdata$x:0000C73D                 db 0FFh
.xdata$x:0000C73E                 db 0FFh
.xdata$x:0000C73F                 db 0FFh
.xdata$x:0000C740                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000C744 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000C744                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000C745                 db    5
.xdata$x:0000C746                 db  93h ; 
.xdata$x:0000C747                 db  19h
.xdata$x:0000C748                 db    1
.xdata$x:0000C749                 db    0
.xdata$x:0000C74A                 db    0
.xdata$x:0000C74B                 db    0
.xdata$x:0000C74C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000C750                 db    0
.xdata$x:0000C751                 db    0
.xdata$x:0000C752                 db    0
.xdata$x:0000C753                 db    0
.xdata$x:0000C754                 db    0
.xdata$x:0000C755                 db    0
.xdata$x:0000C756                 db    0
.xdata$x:0000C757                 db    0
.xdata$x:0000C758                 db    0
.xdata$x:0000C759                 db    0
.xdata$x:0000C75A                 db    0
.xdata$x:0000C75B                 db    0
.xdata$x:0000C75C                 db    0
.xdata$x:0000C75D                 db    0
.xdata$x:0000C75E                 db    0
.xdata$x:0000C75F                 db    0
.xdata$x:0000C760                 db    0
.xdata$x:0000C761                 db    0
.xdata$x:0000C762                 db    0
.xdata$x:0000C763                 db    0
.xdata$x:0000C764                 db    0
.xdata$x:0000C765                 db    0
.xdata$x:0000C766                 db    0
.xdata$x:0000C767                 db    0
.xdata$x:0000C767 _xdata$x        ends
.xdata$x:0000C767
.xdata$x:0000C768 ; ===========================================================================
.xdata$x:0000C768
.xdata$x:0000C768 ; Segment type: Pure data
.xdata$x:0000C768 ; Segment permissions: Read
.xdata$x:0000C768 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C768                 assume cs:_xdata$x
.xdata$x:0000C768                 ;org 0C768h
.xdata$x:0000C768 ; COMDAT (pick associative to section at 5614)
.xdata$x:0000C768 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0000C768                                         ; DATA XREF: .xdata$x:0000C778o
.xdata$x:0000C769                 db 0FFh
.xdata$x:0000C76A                 db 0FFh
.xdata$x:0000C76B                 db 0FFh
.xdata$x:0000C76C                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:0000C770 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:0000C770                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:0000C771                 db    5
.xdata$x:0000C772                 db  93h ; 
.xdata$x:0000C773                 db  19h
.xdata$x:0000C774                 db    1
.xdata$x:0000C775                 db    0
.xdata$x:0000C776                 db    0
.xdata$x:0000C777                 db    0
.xdata$x:0000C778                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:0000C77C                 db    0
.xdata$x:0000C77D                 db    0
.xdata$x:0000C77E                 db    0
.xdata$x:0000C77F                 db    0
.xdata$x:0000C780                 db    0
.xdata$x:0000C781                 db    0
.xdata$x:0000C782                 db    0
.xdata$x:0000C783                 db    0
.xdata$x:0000C784                 db    0
.xdata$x:0000C785                 db    0
.xdata$x:0000C786                 db    0
.xdata$x:0000C787                 db    0
.xdata$x:0000C788                 db    0
.xdata$x:0000C789                 db    0
.xdata$x:0000C78A                 db    0
.xdata$x:0000C78B                 db    0
.xdata$x:0000C78C                 db    0
.xdata$x:0000C78D                 db    0
.xdata$x:0000C78E                 db    0
.xdata$x:0000C78F                 db    0
.xdata$x:0000C790                 db    0
.xdata$x:0000C791                 db    0
.xdata$x:0000C792                 db    0
.xdata$x:0000C793                 db    0
.xdata$x:0000C793 _xdata$x        ends
.xdata$x:0000C793
.xdata$x:0000C794 ; ===========================================================================
.xdata$x:0000C794
.xdata$x:0000C794 ; Segment type: Pure data
.xdata$x:0000C794 ; Segment permissions: Read
.xdata$x:0000C794 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C794                 assume cs:_xdata$x
.xdata$x:0000C794                 ;org 0C794h
.xdata$x:0000C794 ; COMDAT (pick associative to section at 6888)
.xdata$x:0000C794 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C794                                         ; DATA XREF: .xdata$x:0000C7A4o
.xdata$x:0000C795                 db 0FFh
.xdata$x:0000C796                 db 0FFh
.xdata$x:0000C797                 db 0FFh
.xdata$x:0000C798                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000C79C __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C79C                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000C79D                 db    5
.xdata$x:0000C79E                 db  93h ; 
.xdata$x:0000C79F                 db  19h
.xdata$x:0000C7A0                 db    1
.xdata$x:0000C7A1                 db    0
.xdata$x:0000C7A2                 db    0
.xdata$x:0000C7A3                 db    0
.xdata$x:0000C7A4                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000C7A8                 align 20h
.xdata$x:0000C7A8 _xdata$x        ends
.xdata$x:0000C7A8
.xdata$x:0000C7C0 ; ===========================================================================
.xdata$x:0000C7C0
.xdata$x:0000C7C0 ; Segment type: Pure data
.xdata$x:0000C7C0 ; Segment permissions: Read
.xdata$x:0000C7C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C7C0                 assume cs:_xdata$x
.xdata$x:0000C7C0                 ;org 0C7C0h
.xdata$x:0000C7C0 ; COMDAT (pick associative to section at 559C)
.xdata$x:0000C7C0 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000C7C0                                         ; DATA XREF: .xdata$x:0000C7D0o
.xdata$x:0000C7C1                 db 0FFh
.xdata$x:0000C7C2                 db 0FFh
.xdata$x:0000C7C3                 db 0FFh
.xdata$x:0000C7C4                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000C7C8 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000C7C8                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000C7C9                 db    5
.xdata$x:0000C7CA                 db  93h ; 
.xdata$x:0000C7CB                 db  19h
.xdata$x:0000C7CC                 db    1
.xdata$x:0000C7CD                 db    0
.xdata$x:0000C7CE                 db    0
.xdata$x:0000C7CF                 db    0
.xdata$x:0000C7D0                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000C7D4                 db    0
.xdata$x:0000C7D5                 db    0
.xdata$x:0000C7D6                 db    0
.xdata$x:0000C7D7                 db    0
.xdata$x:0000C7D8                 db    0
.xdata$x:0000C7D9                 db    0
.xdata$x:0000C7DA                 db    0
.xdata$x:0000C7DB                 db    0
.xdata$x:0000C7DC                 db    0
.xdata$x:0000C7DD                 db    0
.xdata$x:0000C7DE                 db    0
.xdata$x:0000C7DF                 db    0
.xdata$x:0000C7E0                 db    0
.xdata$x:0000C7E1                 db    0
.xdata$x:0000C7E2                 db    0
.xdata$x:0000C7E3                 db    0
.xdata$x:0000C7E4                 db    0
.xdata$x:0000C7E5                 db    0
.xdata$x:0000C7E6                 db    0
.xdata$x:0000C7E7                 db    0
.xdata$x:0000C7E8                 db    0
.xdata$x:0000C7E9                 db    0
.xdata$x:0000C7EA                 db    0
.xdata$x:0000C7EB                 db    0
.xdata$x:0000C7EB _xdata$x        ends
.xdata$x:0000C7EB
.xdata$x:0000C7EC ; ===========================================================================
.xdata$x:0000C7EC
.xdata$x:0000C7EC ; Segment type: Pure data
.xdata$x:0000C7EC ; Segment permissions: Read
.xdata$x:0000C7EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C7EC                 assume cs:_xdata$x
.xdata$x:0000C7EC                 ;org 0C7ECh
.xdata$x:0000C7EC ; COMDAT (pick associative to section at 5C30)
.xdata$x:0000C7EC __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000C7EC                                         ; DATA XREF: .xdata$x:0000C7FCo
.xdata$x:0000C7ED                 db 0FFh
.xdata$x:0000C7EE                 db 0FFh
.xdata$x:0000C7EF                 db 0FFh
.xdata$x:0000C7F0                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:0000C7F4 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000C7F4                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000C7F5                 db    5
.xdata$x:0000C7F6                 db  93h ; 
.xdata$x:0000C7F7                 db  19h
.xdata$x:0000C7F8                 db    1
.xdata$x:0000C7F9                 db    0
.xdata$x:0000C7FA                 db    0
.xdata$x:0000C7FB                 db    0
.xdata$x:0000C7FC                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.xdata$x:0000C800                 db    0
.xdata$x:0000C801                 db    0
.xdata$x:0000C802                 db    0
.xdata$x:0000C803                 db    0
.xdata$x:0000C804                 db    0
.xdata$x:0000C805                 db    0
.xdata$x:0000C806                 db    0
.xdata$x:0000C807                 db    0
.xdata$x:0000C808                 db    0
.xdata$x:0000C809                 db    0
.xdata$x:0000C80A                 db    0
.xdata$x:0000C80B                 db    0
.xdata$x:0000C80C                 db    0
.xdata$x:0000C80D                 db    0
.xdata$x:0000C80E                 db    0
.xdata$x:0000C80F                 db    0
.xdata$x:0000C810                 db    0
.xdata$x:0000C811                 db    0
.xdata$x:0000C812                 db    0
.xdata$x:0000C813                 db    0
.xdata$x:0000C814                 db    0
.xdata$x:0000C815                 db    0
.xdata$x:0000C816                 db    0
.xdata$x:0000C817                 db    0
.xdata$x:0000C817 _xdata$x        ends
.xdata$x:0000C817
.xdata$x:0000C818 ; ===========================================================================
.xdata$x:0000C818
.xdata$x:0000C818 ; Segment type: Pure data
.xdata$x:0000C818 ; Segment permissions: Read
.xdata$x:0000C818 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C818                 assume cs:_xdata$x
.xdata$x:0000C818                 ;org 0C818h
.xdata$x:0000C818 ; COMDAT (pick associative to section at 5D78)
.xdata$x:0000C818 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000C818                                         ; DATA XREF: .xdata$x:0000C828o
.xdata$x:0000C819                 db 0FFh
.xdata$x:0000C81A                 db 0FFh
.xdata$x:0000C81B                 db 0FFh
.xdata$x:0000C81C                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000C820 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C820                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000C821                 db    5
.xdata$x:0000C822                 db  93h ; 
.xdata$x:0000C823                 db  19h
.xdata$x:0000C824                 db    1
.xdata$x:0000C825                 db    0
.xdata$x:0000C826                 db    0
.xdata$x:0000C827                 db    0
.xdata$x:0000C828                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:0000C82C                 db    0
.xdata$x:0000C82D                 db    0
.xdata$x:0000C82E                 db    0
.xdata$x:0000C82F                 db    0
.xdata$x:0000C830                 db    0
.xdata$x:0000C831                 db    0
.xdata$x:0000C832                 db    0
.xdata$x:0000C833                 db    0
.xdata$x:0000C834                 db    0
.xdata$x:0000C835                 db    0
.xdata$x:0000C836                 db    0
.xdata$x:0000C837                 db    0
.xdata$x:0000C838                 db    0
.xdata$x:0000C839                 db    0
.xdata$x:0000C83A                 db    0
.xdata$x:0000C83B                 db    0
.xdata$x:0000C83C                 db    0
.xdata$x:0000C83D                 db    0
.xdata$x:0000C83E                 db    0
.xdata$x:0000C83F                 db    0
.xdata$x:0000C840                 db    0
.xdata$x:0000C841                 db    0
.xdata$x:0000C842                 db    0
.xdata$x:0000C843                 db    0
.xdata$x:0000C843 _xdata$x        ends
.xdata$x:0000C843
.xdata$x:0000C844 ; ===========================================================================
.xdata$x:0000C844
.xdata$x:0000C844 ; Segment type: Pure data
.xdata$x:0000C844 ; Segment permissions: Read
.xdata$x:0000C844 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C844                 assume cs:_xdata$x
.xdata$x:0000C844                 ;org 0C844h
.xdata$x:0000C844 ; COMDAT (pick associative to section at 5CE0)
.xdata$x:0000C844 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:0000C844                                         ; DATA XREF: .xdata$x:0000C854o
.xdata$x:0000C845                 db 0FFh
.xdata$x:0000C846                 db 0FFh
.xdata$x:0000C847                 db 0FFh
.xdata$x:0000C848                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:0000C84C __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:0000C84C                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:0000C84D                 db    5
.xdata$x:0000C84E                 db  93h ; 
.xdata$x:0000C84F                 db  19h
.xdata$x:0000C850                 db    1
.xdata$x:0000C851                 db    0
.xdata$x:0000C852                 db    0
.xdata$x:0000C853                 db    0
.xdata$x:0000C854                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:0000C858                 db    0
.xdata$x:0000C859                 db    0
.xdata$x:0000C85A                 db    0
.xdata$x:0000C85B                 db    0
.xdata$x:0000C85C                 db    0
.xdata$x:0000C85D                 db    0
.xdata$x:0000C85E                 db    0
.xdata$x:0000C85F                 db    0
.xdata$x:0000C860                 db    0
.xdata$x:0000C861                 db    0
.xdata$x:0000C862                 db    0
.xdata$x:0000C863                 db    0
.xdata$x:0000C864                 db    0
.xdata$x:0000C865                 db    0
.xdata$x:0000C866                 db    0
.xdata$x:0000C867                 db    0
.xdata$x:0000C868                 db    0
.xdata$x:0000C869                 db    0
.xdata$x:0000C86A                 db    0
.xdata$x:0000C86B                 db    0
.xdata$x:0000C86C                 db    0
.xdata$x:0000C86D                 db    0
.xdata$x:0000C86E                 db    0
.xdata$x:0000C86F                 db    0
.xdata$x:0000C86F _xdata$x        ends
.xdata$x:0000C86F
.xdata$x:0000C870 ; ===========================================================================
.xdata$x:0000C870
.xdata$x:0000C870 ; Segment type: Pure data
.xdata$x:0000C870 ; Segment permissions: Read
.xdata$x:0000C870 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C870                 assume cs:_xdata$x
.xdata$x:0000C870                 ;org 0C870h
.xdata$x:0000C870 ; COMDAT (pick associative to section at 5B8C)
.xdata$x:0000C870 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:0000C870                                         ; DATA XREF: .xdata$x:0000C880o
.xdata$x:0000C871                 db 0FFh
.xdata$x:0000C872                 db 0FFh
.xdata$x:0000C873                 db 0FFh
.xdata$x:0000C874                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0
.xdata$x:0000C878 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:0000C878                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:0000C879                 db    5
.xdata$x:0000C87A                 db  93h ; 
.xdata$x:0000C87B                 db  19h
.xdata$x:0000C87C                 db    1
.xdata$x:0000C87D                 db    0
.xdata$x:0000C87E                 db    0
.xdata$x:0000C87F                 db    0
.xdata$x:0000C880                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.xdata$x:0000C884                 db    0
.xdata$x:0000C885                 db    0
.xdata$x:0000C886                 db    0
.xdata$x:0000C887                 db    0
.xdata$x:0000C888                 db    0
.xdata$x:0000C889                 db    0
.xdata$x:0000C88A                 db    0
.xdata$x:0000C88B                 db    0
.xdata$x:0000C88C                 db    0
.xdata$x:0000C88D                 db    0
.xdata$x:0000C88E                 db    0
.xdata$x:0000C88F                 db    0
.xdata$x:0000C890                 db    0
.xdata$x:0000C891                 db    0
.xdata$x:0000C892                 db    0
.xdata$x:0000C893                 db    0
.xdata$x:0000C894                 db    0
.xdata$x:0000C895                 db    0
.xdata$x:0000C896                 db    0
.xdata$x:0000C897                 db    0
.xdata$x:0000C898                 db    0
.xdata$x:0000C899                 db    0
.xdata$x:0000C89A                 db    0
.xdata$x:0000C89B                 db    0
.xdata$x:0000C89B _xdata$x        ends
.xdata$x:0000C89B
.xdata$x:0000C89C ; ===========================================================================
.xdata$x:0000C89C
.xdata$x:0000C89C ; Segment type: Pure data
.xdata$x:0000C89C ; Segment permissions: Read
.xdata$x:0000C89C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C89C                 assume cs:_xdata$x
.xdata$x:0000C89C                 ;org 0C89Ch
.xdata$x:0000C89C ; COMDAT (pick associative to section at 6B44)
.xdata$x:0000C89C __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000C89C                                         ; DATA XREF: .xdata$x:0000C8ACo
.xdata$x:0000C89D                 db 0FFh
.xdata$x:0000C89E                 db 0FFh
.xdata$x:0000C89F                 db 0FFh
.xdata$x:0000C8A0                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000C8A4 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C8A4                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000C8A5                 db    5
.xdata$x:0000C8A6                 db  93h ; 
.xdata$x:0000C8A7                 db  19h
.xdata$x:0000C8A8                 db    1
.xdata$x:0000C8A9                 db    0
.xdata$x:0000C8AA                 db    0
.xdata$x:0000C8AB                 db    0
.xdata$x:0000C8AC                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:0000C8B0                 db    0
.xdata$x:0000C8B1                 db    0
.xdata$x:0000C8B2                 db    0
.xdata$x:0000C8B3                 db    0
.xdata$x:0000C8B4                 db    0
.xdata$x:0000C8B5                 db    0
.xdata$x:0000C8B6                 db    0
.xdata$x:0000C8B7                 db    0
.xdata$x:0000C8B8                 db    0
.xdata$x:0000C8B9                 db    0
.xdata$x:0000C8BA                 db    0
.xdata$x:0000C8BB                 db    0
.xdata$x:0000C8BC                 db    0
.xdata$x:0000C8BD                 db    0
.xdata$x:0000C8BE                 db    0
.xdata$x:0000C8BF                 db    0
.xdata$x:0000C8C0                 db    0
.xdata$x:0000C8C1                 db    0
.xdata$x:0000C8C2                 db    0
.xdata$x:0000C8C3                 db    0
.xdata$x:0000C8C4                 db    0
.xdata$x:0000C8C5                 db    0
.xdata$x:0000C8C6                 db    0
.xdata$x:0000C8C7                 db    0
.xdata$x:0000C8C7 _xdata$x        ends
.xdata$x:0000C8C7
.xdata$x:0000C8C8 ; ===========================================================================
.xdata$x:0000C8C8
.xdata$x:0000C8C8 ; Segment type: Pure data
.xdata$x:0000C8C8 ; Segment permissions: Read
.xdata$x:0000C8C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C8C8                 assume cs:_xdata$x
.xdata$x:0000C8C8                 ;org 0C8C8h
.xdata$x:0000C8C8 ; COMDAT (pick associative to section at 7BDC)
.xdata$x:0000C8C8 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000C8C8                                         ; DATA XREF: .xdata$x:0000C950o
.xdata$x:0000C8C9                 db    0
.xdata$x:0000C8CA                 db    0
.xdata$x:0000C8CB                 db    0
.xdata$x:0000C8CC                 db    0
.xdata$x:0000C8CD                 db    0
.xdata$x:0000C8CE                 db    0
.xdata$x:0000C8CF                 db    0
.xdata$x:0000C8D0                 db    0
.xdata$x:0000C8D1                 db    0
.xdata$x:0000C8D2                 db    0
.xdata$x:0000C8D3                 db    0
.xdata$x:0000C8D4                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:0000C8D8 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000C8D8                                         ; DATA XREF: .xdata$x:0000C93Co
.xdata$x:0000C8D9                 db    0
.xdata$x:0000C8DA                 db    0
.xdata$x:0000C8DB                 db    0
.xdata$x:0000C8DC                 db    0
.xdata$x:0000C8DD                 db    0
.xdata$x:0000C8DE                 db    0
.xdata$x:0000C8DF                 db    0
.xdata$x:0000C8E0                 db    0
.xdata$x:0000C8E1                 db    0
.xdata$x:0000C8E2                 db    0
.xdata$x:0000C8E3                 db    0
.xdata$x:0000C8E4                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:0000C8E8 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000C8E8                                         ; DATA XREF: .xdata$x:0000C910o
.xdata$x:0000C8E9                 db 0FFh
.xdata$x:0000C8EA                 db 0FFh
.xdata$x:0000C8EB                 db 0FFh
.xdata$x:0000C8EC                 db    0
.xdata$x:0000C8ED                 db    0
.xdata$x:0000C8EE                 db    0
.xdata$x:0000C8EF                 db    0
.xdata$x:0000C8F0                 db 0FFh
.xdata$x:0000C8F1                 db 0FFh
.xdata$x:0000C8F2                 db 0FFh
.xdata$x:0000C8F3                 db 0FFh
.xdata$x:0000C8F4                 db    0
.xdata$x:0000C8F5                 db    0
.xdata$x:0000C8F6                 db    0
.xdata$x:0000C8F7                 db    0
.xdata$x:0000C8F8                 db    1
.xdata$x:0000C8F9                 db    0
.xdata$x:0000C8FA                 db    0
.xdata$x:0000C8FB                 db    0
.xdata$x:0000C8FC                 db    0
.xdata$x:0000C8FD                 db    0
.xdata$x:0000C8FE                 db    0
.xdata$x:0000C8FF                 db    0
.xdata$x:0000C900                 db    1
.xdata$x:0000C901                 db    0
.xdata$x:0000C902                 db    0
.xdata$x:0000C903                 db    0
.xdata$x:0000C904                 db    0
.xdata$x:0000C905                 db    0
.xdata$x:0000C906                 db    0
.xdata$x:0000C907                 db    0
.xdata$x:0000C908 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000C908                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:0000C909                 db    5
.xdata$x:0000C90A                 db  93h ; 
.xdata$x:0000C90B                 db  19h
.xdata$x:0000C90C                 db    4
.xdata$x:0000C90D                 db    0
.xdata$x:0000C90E                 db    0
.xdata$x:0000C90F                 db    0
.xdata$x:0000C910                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000C914                 db    2
.xdata$x:0000C915                 db    0
.xdata$x:0000C916                 db    0
.xdata$x:0000C917                 db    0
.xdata$x:0000C918                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000C91C                 db    0
.xdata$x:0000C91D                 db    0
.xdata$x:0000C91E                 db    0
.xdata$x:0000C91F                 db    0
.xdata$x:0000C920                 db    0
.xdata$x:0000C921                 db    0
.xdata$x:0000C922                 db    0
.xdata$x:0000C923                 db    0
.xdata$x:0000C924                 db    0
.xdata$x:0000C925                 db    0
.xdata$x:0000C926                 db    0
.xdata$x:0000C927                 db    0
.xdata$x:0000C928                 db    0
.xdata$x:0000C929                 db    0
.xdata$x:0000C92A                 db    0
.xdata$x:0000C92B                 db    0
.xdata$x:0000C92C __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:0000C92C                                         ; DATA XREF: .xdata$x:0000C918o
.xdata$x:0000C92D                 db    0
.xdata$x:0000C92E                 db    0
.xdata$x:0000C92F                 db    0
.xdata$x:0000C930                 db    2
.xdata$x:0000C931                 db    0
.xdata$x:0000C932                 db    0
.xdata$x:0000C933                 db    0
.xdata$x:0000C934                 db    3
.xdata$x:0000C935                 db    0
.xdata$x:0000C936                 db    0
.xdata$x:0000C937                 db    0
.xdata$x:0000C938                 db    1
.xdata$x:0000C939                 db    0
.xdata$x:0000C93A                 db    0
.xdata$x:0000C93B                 db    0
.xdata$x:0000C93C                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:0000C940                 db    0
.xdata$x:0000C941                 db    0
.xdata$x:0000C942                 db    0
.xdata$x:0000C943                 db    0
.xdata$x:0000C944                 db    0
.xdata$x:0000C945                 db    0
.xdata$x:0000C946                 db    0
.xdata$x:0000C947                 db    0
.xdata$x:0000C948                 db    3
.xdata$x:0000C949                 db    0
.xdata$x:0000C94A                 db    0
.xdata$x:0000C94B                 db    0
.xdata$x:0000C94C                 db    1
.xdata$x:0000C94D                 db    0
.xdata$x:0000C94E                 db    0
.xdata$x:0000C94F                 db    0
.xdata$x:0000C950                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:0000C950 _xdata$x        ends
.xdata$x:0000C950
.xdata$x:0000C954 ; ===========================================================================
.xdata$x:0000C954
.xdata$x:0000C954 ; Segment type: Pure data
.xdata$x:0000C954 ; Segment permissions: Read
.xdata$x:0000C954 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C954                 assume cs:_xdata$x
.xdata$x:0000C954                 ;org 0C954h
.xdata$x:0000C954 ; COMDAT (pick associative to section at 653C)
.xdata$x:0000C954 __unwindtable$??0StaticDialog@@QAE@XZ db 0FFh
.xdata$x:0000C954                                         ; DATA XREF: .xdata$x:0000C964o
.xdata$x:0000C955                 db 0FFh
.xdata$x:0000C956                 db 0FFh
.xdata$x:0000C957                 db 0FFh
.xdata$x:0000C958                 dd offset __unwindfunclet$??0StaticDialog@@QAE@XZ$0
.xdata$x:0000C95C __ehfuncinfo$??0StaticDialog@@QAE@XZ db  22h ; "
.xdata$x:0000C95C                                         ; DATA XREF: __ehhandler$??0StaticDialog@@QAE@XZ+11o
.xdata$x:0000C95D                 db    5
.xdata$x:0000C95E                 db  93h ; 
.xdata$x:0000C95F                 db  19h
.xdata$x:0000C960                 db    1
.xdata$x:0000C961                 db    0
.xdata$x:0000C962                 db    0
.xdata$x:0000C963                 db    0
.xdata$x:0000C964                 dd offset __unwindtable$??0StaticDialog@@QAE@XZ
.xdata$x:0000C968                 align 20h
.xdata$x:0000C968 _xdata$x        ends
.xdata$x:0000C968
.xdata$x:0000C980 ; ===========================================================================
.xdata$x:0000C980
.xdata$x:0000C980 ; Segment type: Pure data
.xdata$x:0000C980 ; Segment permissions: Read
.xdata$x:0000C980 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C980                 assume cs:_xdata$x
.xdata$x:0000C980                 ;org 0C980h
.xdata$x:0000C980 ; COMDAT (pick associative to section at 6F2C)
.xdata$x:0000C980 __unwindtable$??1StaticDialog@@UAE@XZ db 0FFh
.xdata$x:0000C980                                         ; DATA XREF: .xdata$x:0000C990o
.xdata$x:0000C981                 db 0FFh
.xdata$x:0000C982                 db 0FFh
.xdata$x:0000C983                 db 0FFh
.xdata$x:0000C984                 dd offset __unwindfunclet$??1StaticDialog@@UAE@XZ$0
.xdata$x:0000C988 __ehfuncinfo$??1StaticDialog@@UAE@XZ db  22h ; "
.xdata$x:0000C988                                         ; DATA XREF: __ehhandler$??1StaticDialog@@UAE@XZ+11o
.xdata$x:0000C989                 db    5
.xdata$x:0000C98A                 db  93h ; 
.xdata$x:0000C98B                 db  19h
.xdata$x:0000C98C                 db    1
.xdata$x:0000C98D                 db    0
.xdata$x:0000C98E                 db    0
.xdata$x:0000C98F                 db    0
.xdata$x:0000C990                 dd offset __unwindtable$??1StaticDialog@@UAE@XZ
.xdata$x:0000C994                 db    0
.xdata$x:0000C995                 db    0
.xdata$x:0000C996                 db    0
.xdata$x:0000C997                 db    0
.xdata$x:0000C998                 db    0
.xdata$x:0000C999                 db    0
.xdata$x:0000C99A                 db    0
.xdata$x:0000C99B                 db    0
.xdata$x:0000C99C                 db    0
.xdata$x:0000C99D                 db    0
.xdata$x:0000C99E                 db    0
.xdata$x:0000C99F                 db    0
.xdata$x:0000C9A0                 db    0
.xdata$x:0000C9A1                 db    0
.xdata$x:0000C9A2                 db    0
.xdata$x:0000C9A3                 db    0
.xdata$x:0000C9A4                 db    0
.xdata$x:0000C9A5                 db    0
.xdata$x:0000C9A6                 db    0
.xdata$x:0000C9A7                 db    0
.xdata$x:0000C9A8                 db    0
.xdata$x:0000C9A9                 db    0
.xdata$x:0000C9AA                 db    0
.xdata$x:0000C9AB                 db    0
.xdata$x:0000C9AB _xdata$x        ends
.xdata$x:0000C9AB
.xdata$x:0000C9AC ; ===========================================================================
.xdata$x:0000C9AC
.xdata$x:0000C9AC ; Segment type: Pure data
.xdata$x:0000C9AC ; Segment permissions: Read
.xdata$x:0000C9AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C9AC                 assume cs:_xdata$x
.xdata$x:0000C9AC                 ;org 0C9ACh
.xdata$x:0000C9AC ; COMDAT (pick associative to section at 6460)
.xdata$x:0000C9AC __unwindtable$??0Shortcut@@QAE@PB_W_N11E@Z db 0FFh
.xdata$x:0000C9AC                                         ; DATA XREF: .xdata$x:0000C9BCo
.xdata$x:0000C9AD                 db 0FFh
.xdata$x:0000C9AE                 db 0FFh
.xdata$x:0000C9AF                 db 0FFh
.xdata$x:0000C9B0                 dd offset __unwindfunclet$??0Shortcut@@QAE@PB_W_N11E@Z$0
.xdata$x:0000C9B4 __ehfuncinfo$??0Shortcut@@QAE@PB_W_N11E@Z db  22h ; "
.xdata$x:0000C9B4                                         ; DATA XREF: __ehhandler$??0Shortcut@@QAE@PB_W_N11E@Z+11o
.xdata$x:0000C9B5                 db    5
.xdata$x:0000C9B6                 db  93h ; 
.xdata$x:0000C9B7                 db  19h
.xdata$x:0000C9B8                 db    1
.xdata$x:0000C9B9                 db    0
.xdata$x:0000C9BA                 db    0
.xdata$x:0000C9BB                 db    0
.xdata$x:0000C9BC                 dd offset __unwindtable$??0Shortcut@@QAE@PB_W_N11E@Z
.xdata$x:0000C9C0                 db    0
.xdata$x:0000C9C1                 db    0
.xdata$x:0000C9C2                 db    0
.xdata$x:0000C9C3                 db    0
.xdata$x:0000C9C4                 db    0
.xdata$x:0000C9C5                 db    0
.xdata$x:0000C9C6                 db    0
.xdata$x:0000C9C7                 db    0
.xdata$x:0000C9C8                 db    0
.xdata$x:0000C9C9                 db    0
.xdata$x:0000C9CA                 db    0
.xdata$x:0000C9CB                 db    0
.xdata$x:0000C9CC                 db    0
.xdata$x:0000C9CD                 db    0
.xdata$x:0000C9CE                 db    0
.xdata$x:0000C9CF                 db    0
.xdata$x:0000C9D0                 db    0
.xdata$x:0000C9D1                 db    0
.xdata$x:0000C9D2                 db    0
.xdata$x:0000C9D3                 db    0
.xdata$x:0000C9D4                 db    0
.xdata$x:0000C9D5                 db    0
.xdata$x:0000C9D6                 db    0
.xdata$x:0000C9D7                 db    0
.xdata$x:0000C9D7 _xdata$x        ends
.xdata$x:0000C9D7
.xdata$x:0000C9D8 ; ===========================================================================
.xdata$x:0000C9D8
.xdata$x:0000C9D8 ; Segment type: Pure data
.xdata$x:0000C9D8 ; Segment permissions: Read
.xdata$x:0000C9D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C9D8                 assume cs:_xdata$x
.xdata$x:0000C9D8                 ;org 0C9D8h
.xdata$x:0000C9D8 ; COMDAT (pick associative to section at 63B8)
.xdata$x:0000C9D8 __unwindtable$??0Shortcut@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000C9D8                                         ; DATA XREF: .xdata$x:0000C9E8o
.xdata$x:0000C9D9                 db 0FFh
.xdata$x:0000C9DA                 db 0FFh
.xdata$x:0000C9DB                 db 0FFh
.xdata$x:0000C9DC                 dd offset __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0
.xdata$x:0000C9E0 __ehfuncinfo$??0Shortcut@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000C9E0                                         ; DATA XREF: __ehhandler$??0Shortcut@@QAE@ABV0@@Z+11o
.xdata$x:0000C9E1                 db    5
.xdata$x:0000C9E2                 db  93h ; 
.xdata$x:0000C9E3                 db  19h
.xdata$x:0000C9E4                 db    1
.xdata$x:0000C9E5                 db    0
.xdata$x:0000C9E6                 db    0
.xdata$x:0000C9E7                 db    0
.xdata$x:0000C9E8                 dd offset __unwindtable$??0Shortcut@@QAE@ABV0@@Z
.xdata$x:0000C9EC                 db    0
.xdata$x:0000C9ED                 db    0
.xdata$x:0000C9EE                 db    0
.xdata$x:0000C9EF                 db    0
.xdata$x:0000C9F0                 db    0
.xdata$x:0000C9F1                 db    0
.xdata$x:0000C9F2                 db    0
.xdata$x:0000C9F3                 db    0
.xdata$x:0000C9F4                 db    0
.xdata$x:0000C9F5                 db    0
.xdata$x:0000C9F6                 db    0
.xdata$x:0000C9F7                 db    0
.xdata$x:0000C9F8                 db    0
.xdata$x:0000C9F9                 db    0
.xdata$x:0000C9FA                 db    0
.xdata$x:0000C9FB                 db    0
.xdata$x:0000C9FC                 db    0
.xdata$x:0000C9FD                 db    0
.xdata$x:0000C9FE                 db    0
.xdata$x:0000C9FF                 db    0
.xdata$x:0000CA00                 db    0
.xdata$x:0000CA01                 db    0
.xdata$x:0000CA02                 db    0
.xdata$x:0000CA03                 db    0
.xdata$x:0000CA03 _xdata$x        ends
.xdata$x:0000CA03
.xdata$x:0000CA04 ; ===========================================================================
.xdata$x:0000CA04
.xdata$x:0000CA04 ; Segment type: Pure data
.xdata$x:0000CA04 ; Segment permissions: Read
.xdata$x:0000CA04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CA04                 assume cs:_xdata$x
.xdata$x:0000CA04                 ;org 0CA04h
.xdata$x:0000CA04 ; COMDAT (pick associative to section at 6EBC)
.xdata$x:0000CA04 __unwindtable$??1Shortcut@@UAE@XZ db 0FFh ; DATA XREF: .xdata$x:0000CA14o
.xdata$x:0000CA05                 db 0FFh
.xdata$x:0000CA06                 db 0FFh
.xdata$x:0000CA07                 db 0FFh
.xdata$x:0000CA08                 dd offset __unwindfunclet$??1Shortcut@@UAE@XZ$0
.xdata$x:0000CA0C __ehfuncinfo$??1Shortcut@@UAE@XZ db  22h ; "
.xdata$x:0000CA0C                                         ; DATA XREF: __ehhandler$??1Shortcut@@UAE@XZ+11o
.xdata$x:0000CA0D                 db    5
.xdata$x:0000CA0E                 db  93h ; 
.xdata$x:0000CA0F                 db  19h
.xdata$x:0000CA10                 db    1
.xdata$x:0000CA11                 db    0
.xdata$x:0000CA12                 db    0
.xdata$x:0000CA13                 db    0
.xdata$x:0000CA14                 dd offset __unwindtable$??1Shortcut@@UAE@XZ
.xdata$x:0000CA18                 db    0
.xdata$x:0000CA19                 db    0
.xdata$x:0000CA1A                 db    0
.xdata$x:0000CA1B                 db    0
.xdata$x:0000CA1C                 db    0
.xdata$x:0000CA1D                 db    0
.xdata$x:0000CA1E                 db    0
.xdata$x:0000CA1F                 db    0
.xdata$x:0000CA20                 db    0
.xdata$x:0000CA21                 db    0
.xdata$x:0000CA22                 db    0
.xdata$x:0000CA23                 db    0
.xdata$x:0000CA24                 db    0
.xdata$x:0000CA25                 db    0
.xdata$x:0000CA26                 db    0
.xdata$x:0000CA27                 db    0
.xdata$x:0000CA28                 db    0
.xdata$x:0000CA29                 db    0
.xdata$x:0000CA2A                 db    0
.xdata$x:0000CA2B                 db    0
.xdata$x:0000CA2C                 db    0
.xdata$x:0000CA2D                 db    0
.xdata$x:0000CA2E                 db    0
.xdata$x:0000CA2F                 db    0
.xdata$x:0000CA2F _xdata$x        ends
.xdata$x:0000CA2F
.xdata$x:0000CA30 ; ===========================================================================
.xdata$x:0000CA30
.xdata$x:0000CA30 ; Segment type: Pure data
.xdata$x:0000CA30 ; Segment permissions: Read
.xdata$x:0000CA30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CA30                 assume cs:_xdata$x
.xdata$x:0000CA30                 ;org 0CA30h
.xdata$x:0000CA30 ; COMDAT (pick associative to section at 5F18)
.xdata$x:0000CA30 __unwindtable$??0CommandShortcut@@QAE@VShortcut@@J@Z db 0FFh
.xdata$x:0000CA30                                         ; DATA XREF: .xdata$x:0000CA48o
.xdata$x:0000CA31                 db 0FFh
.xdata$x:0000CA32                 db 0FFh
.xdata$x:0000CA33                 db 0FFh
.xdata$x:0000CA34                 dd offset __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$0
.xdata$x:0000CA38                 db    0
.xdata$x:0000CA39                 db    0
.xdata$x:0000CA3A                 db    0
.xdata$x:0000CA3B                 db    0
.xdata$x:0000CA3C                 dd offset __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$1
.xdata$x:0000CA40 __ehfuncinfo$??0CommandShortcut@@QAE@VShortcut@@J@Z db  22h ; "
.xdata$x:0000CA40                                         ; DATA XREF: __ehhandler$??0CommandShortcut@@QAE@VShortcut@@J@Z+11o
.xdata$x:0000CA41                 db    5
.xdata$x:0000CA42                 db  93h ; 
.xdata$x:0000CA43                 db  19h
.xdata$x:0000CA44                 db    2
.xdata$x:0000CA45                 db    0
.xdata$x:0000CA46                 db    0
.xdata$x:0000CA47                 db    0
.xdata$x:0000CA48                 dd offset __unwindtable$??0CommandShortcut@@QAE@VShortcut@@J@Z
.xdata$x:0000CA4C                 db    0
.xdata$x:0000CA4D                 db    0
.xdata$x:0000CA4E                 db    0
.xdata$x:0000CA4F                 db    0
.xdata$x:0000CA50                 db    0
.xdata$x:0000CA51                 db    0
.xdata$x:0000CA52                 db    0
.xdata$x:0000CA53                 db    0
.xdata$x:0000CA54                 db    0
.xdata$x:0000CA55                 db    0
.xdata$x:0000CA56                 db    0
.xdata$x:0000CA57                 db    0
.xdata$x:0000CA58                 db    0
.xdata$x:0000CA59                 db    0
.xdata$x:0000CA5A                 db    0
.xdata$x:0000CA5B                 db    0
.xdata$x:0000CA5C                 db    0
.xdata$x:0000CA5D                 db    0
.xdata$x:0000CA5E                 db    0
.xdata$x:0000CA5F                 db    0
.xdata$x:0000CA60                 db    0
.xdata$x:0000CA61                 db    0
.xdata$x:0000CA62                 db    0
.xdata$x:0000CA63                 db    0
.xdata$x:0000CA63 _xdata$x        ends
.xdata$x:0000CA63
.xdata$x:0000CA64 ; ===========================================================================
.xdata$x:0000CA64
.xdata$x:0000CA64 ; Segment type: Pure data
.xdata$x:0000CA64 ; Segment permissions: Read
.xdata$x:0000CA64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CA64                 assume cs:_xdata$x
.xdata$x:0000CA64                 ;org 0CA64h
.xdata$x:0000CA64 ; COMDAT (pick associative to section at 6CA8)
.xdata$x:0000CA64 __unwindtable$??1CommandShortcut@@UAE@XZ db 0FFh
.xdata$x:0000CA64                                         ; DATA XREF: .xdata$x:0000CA74o
.xdata$x:0000CA65                 db 0FFh
.xdata$x:0000CA66                 db 0FFh
.xdata$x:0000CA67                 db 0FFh
.xdata$x:0000CA68                 dd offset __unwindfunclet$??1CommandShortcut@@UAE@XZ$0
.xdata$x:0000CA6C __ehfuncinfo$??1CommandShortcut@@UAE@XZ db  22h ; "
.xdata$x:0000CA6C                                         ; DATA XREF: __ehhandler$??1CommandShortcut@@UAE@XZ+11o
.xdata$x:0000CA6D                 db    5
.xdata$x:0000CA6E                 db  93h ; 
.xdata$x:0000CA6F                 db  19h
.xdata$x:0000CA70                 db    1
.xdata$x:0000CA71                 db    0
.xdata$x:0000CA72                 db    0
.xdata$x:0000CA73                 db    0
.xdata$x:0000CA74                 dd offset __unwindtable$??1CommandShortcut@@UAE@XZ
.xdata$x:0000CA78                 db    0
.xdata$x:0000CA79                 db    0
.xdata$x:0000CA7A                 db    0
.xdata$x:0000CA7B                 db    0
.xdata$x:0000CA7C                 db    0
.xdata$x:0000CA7D                 db    0
.xdata$x:0000CA7E                 db    0
.xdata$x:0000CA7F                 db    0
.xdata$x:0000CA80                 db    0
.xdata$x:0000CA81                 db    0
.xdata$x:0000CA82                 db    0
.xdata$x:0000CA83                 db    0
.xdata$x:0000CA84                 db    0
.xdata$x:0000CA85                 db    0
.xdata$x:0000CA86                 db    0
.xdata$x:0000CA87                 db    0
.xdata$x:0000CA88                 db    0
.xdata$x:0000CA89                 db    0
.xdata$x:0000CA8A                 db    0
.xdata$x:0000CA8B                 db    0
.xdata$x:0000CA8C                 db    0
.xdata$x:0000CA8D                 db    0
.xdata$x:0000CA8E                 db    0
.xdata$x:0000CA8F                 db    0
.xdata$x:0000CA8F _xdata$x        ends
.xdata$x:0000CA8F
.xdata$x:0000CA90 ; ===========================================================================
.xdata$x:0000CA90
.xdata$x:0000CA90 ; Segment type: Pure data
.xdata$x:0000CA90 ; Segment permissions: Read
.xdata$x:0000CA90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CA90                 assume cs:_xdata$x
.xdata$x:0000CA90                 ;org 0CA90h
.xdata$x:0000CA90 ; COMDAT (pick associative to section at 5E84)
.xdata$x:0000CA90 __unwindtable$??0CommandShortcut@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000CA90                                         ; DATA XREF: .xdata$x:0000CAA0o
.xdata$x:0000CA91                 db 0FFh
.xdata$x:0000CA92                 db 0FFh
.xdata$x:0000CA93                 db 0FFh
.xdata$x:0000CA94                 dd offset __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0
.xdata$x:0000CA98 __ehfuncinfo$??0CommandShortcut@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000CA98                                         ; DATA XREF: __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z+11o
.xdata$x:0000CA99                 db    5
.xdata$x:0000CA9A                 db  93h ; 
.xdata$x:0000CA9B                 db  19h
.xdata$x:0000CA9C                 db    1
.xdata$x:0000CA9D                 db    0
.xdata$x:0000CA9E                 db    0
.xdata$x:0000CA9F                 db    0
.xdata$x:0000CAA0                 dd offset __unwindtable$??0CommandShortcut@@QAE@ABV0@@Z
.xdata$x:0000CAA4                 db    0
.xdata$x:0000CAA5                 db    0
.xdata$x:0000CAA6                 db    0
.xdata$x:0000CAA7                 db    0
.xdata$x:0000CAA8                 db    0
.xdata$x:0000CAA9                 db    0
.xdata$x:0000CAAA                 db    0
.xdata$x:0000CAAB                 db    0
.xdata$x:0000CAAC                 db    0
.xdata$x:0000CAAD                 db    0
.xdata$x:0000CAAE                 db    0
.xdata$x:0000CAAF                 db    0
.xdata$x:0000CAB0                 db    0
.xdata$x:0000CAB1                 db    0
.xdata$x:0000CAB2                 db    0
.xdata$x:0000CAB3                 db    0
.xdata$x:0000CAB4                 db    0
.xdata$x:0000CAB5                 db    0
.xdata$x:0000CAB6                 db    0
.xdata$x:0000CAB7                 db    0
.xdata$x:0000CAB8                 db    0
.xdata$x:0000CAB9                 db    0
.xdata$x:0000CABA                 db    0
.xdata$x:0000CABB                 db    0
.xdata$x:0000CABB _xdata$x        ends
.xdata$x:0000CABB
.xdata$x:0000CABC ; ===========================================================================
.xdata$x:0000CABC
.xdata$x:0000CABC ; Segment type: Pure data
.xdata$x:0000CABC ; Segment permissions: Read
.xdata$x:0000CABC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CABC                 assume cs:_xdata$x
.xdata$x:0000CABC                 ;org 0CABCh
.xdata$x:0000CABC ; COMDAT (pick associative to section at 60C8)
.xdata$x:0000CABC __unwindtable$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z db 0FFh
.xdata$x:0000CABC                                         ; DATA XREF: .xdata$x:0000CAE4o
.xdata$x:0000CABD                 db 0FFh
.xdata$x:0000CABE                 db 0FFh
.xdata$x:0000CABF                 db 0FFh
.xdata$x:0000CAC0                 dd offset __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$0
.xdata$x:0000CAC4                 align 8
.xdata$x:0000CAC8                 dd offset __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$1
.xdata$x:0000CACC                 align 10h
.xdata$x:0000CAD0                 dd offset __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$2
.xdata$x:0000CAD4                 db    2
.xdata$x:0000CAD5                 db    0
.xdata$x:0000CAD6                 db    0
.xdata$x:0000CAD7                 db    0
.xdata$x:0000CAD8                 dd offset __unwindfunclet$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z$3
.xdata$x:0000CADC __ehfuncinfo$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z db  22h ; "
.xdata$x:0000CADC                                         ; DATA XREF: __ehhandler$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z+11o
.xdata$x:0000CADD                 db    5
.xdata$x:0000CADE                 db  93h ; 
.xdata$x:0000CADF                 db  19h
.xdata$x:0000CAE0                 db    4
.xdata$x:0000CAE1                 db    0
.xdata$x:0000CAE2                 db    0
.xdata$x:0000CAE3                 db    0
.xdata$x:0000CAE4                 dd offset __unwindtable$??0PluginCmdShortcut@@QAE@VShortcut@@HPB_WG@Z
.xdata$x:0000CAE8                 align 20h
.xdata$x:0000CAE8 _xdata$x        ends
.xdata$x:0000CAE8
.xdata$x:0000CB00 ; ===========================================================================
.xdata$x:0000CB00
.xdata$x:0000CB00 ; Segment type: Pure data
.xdata$x:0000CB00 ; Segment permissions: Read
.xdata$x:0000CB00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CB00                 assume cs:_xdata$x
.xdata$x:0000CB00                 ;org 0CB00h
.xdata$x:0000CB00 ; COMDAT (pick associative to section at 6D18)
.xdata$x:0000CB00 __unwindtable$??1PluginCmdShortcut@@UAE@XZ db 0FFh
.xdata$x:0000CB00                                         ; DATA XREF: .xdata$x:0000CB18o
.xdata$x:0000CB01                 db 0FFh
.xdata$x:0000CB02                 db 0FFh
.xdata$x:0000CB03                 db 0FFh
.xdata$x:0000CB04                 dd offset __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$0
.xdata$x:0000CB08                 db    0
.xdata$x:0000CB09                 db    0
.xdata$x:0000CB0A                 db    0
.xdata$x:0000CB0B                 db    0
.xdata$x:0000CB0C                 dd offset __unwindfunclet$??1PluginCmdShortcut@@UAE@XZ$1
.xdata$x:0000CB10 __ehfuncinfo$??1PluginCmdShortcut@@UAE@XZ db  22h ; "
.xdata$x:0000CB10                                         ; DATA XREF: __ehhandler$??1PluginCmdShortcut@@UAE@XZ+11o
.xdata$x:0000CB11                 db    5
.xdata$x:0000CB12                 db  93h ; 
.xdata$x:0000CB13                 db  19h
.xdata$x:0000CB14                 db    2
.xdata$x:0000CB15                 db    0
.xdata$x:0000CB16                 db    0
.xdata$x:0000CB17                 db    0
.xdata$x:0000CB18                 dd offset __unwindtable$??1PluginCmdShortcut@@UAE@XZ
.xdata$x:0000CB1C                 db    0
.xdata$x:0000CB1D                 db    0
.xdata$x:0000CB1E                 db    0
.xdata$x:0000CB1F                 db    0
.xdata$x:0000CB20                 db    0
.xdata$x:0000CB21                 db    0
.xdata$x:0000CB22                 db    0
.xdata$x:0000CB23                 db    0
.xdata$x:0000CB24                 db    0
.xdata$x:0000CB25                 db    0
.xdata$x:0000CB26                 db    0
.xdata$x:0000CB27                 db    0
.xdata$x:0000CB28                 db    0
.xdata$x:0000CB29                 db    0
.xdata$x:0000CB2A                 db    0
.xdata$x:0000CB2B                 db    0
.xdata$x:0000CB2C                 db    0
.xdata$x:0000CB2D                 db    0
.xdata$x:0000CB2E                 db    0
.xdata$x:0000CB2F                 db    0
.xdata$x:0000CB30                 db    0
.xdata$x:0000CB31                 db    0
.xdata$x:0000CB32                 db    0
.xdata$x:0000CB33                 db    0
.xdata$x:0000CB33 _xdata$x        ends
.xdata$x:0000CB33
.xdata$x:0000CB34 ; ===========================================================================
.xdata$x:0000CB34
.xdata$x:0000CB34 ; Segment type: Pure data
.xdata$x:0000CB34 ; Segment permissions: Read
.xdata$x:0000CB34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CB34                 assume cs:_xdata$x
.xdata$x:0000CB34                 ;org 0CB34h
.xdata$x:0000CB34 ; COMDAT (pick associative to section at 5FF4)
.xdata$x:0000CB34 __unwindtable$??0PluginCmdShortcut@@QAE@ABV0@@Z db 0FFh
.xdata$x:0000CB34                                         ; DATA XREF: .xdata$x:0000CB4Co
.xdata$x:0000CB35                 db 0FFh
.xdata$x:0000CB36                 db 0FFh
.xdata$x:0000CB37                 db 0FFh
.xdata$x:0000CB38                 dd offset __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$0
.xdata$x:0000CB3C                 align 10h
.xdata$x:0000CB40                 dd offset __unwindfunclet$??0PluginCmdShortcut@@QAE@ABV0@@Z$1
.xdata$x:0000CB44 __ehfuncinfo$??0PluginCmdShortcut@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000CB44                                         ; DATA XREF: __ehhandler$??0PluginCmdShortcut@@QAE@ABV0@@Z+11o
.xdata$x:0000CB45                 db    5
.xdata$x:0000CB46                 db  93h ; 
.xdata$x:0000CB47                 db  19h
.xdata$x:0000CB48                 db    2
.xdata$x:0000CB49                 db    0
.xdata$x:0000CB4A                 db    0
.xdata$x:0000CB4B                 db    0
.xdata$x:0000CB4C                 dd offset __unwindtable$??0PluginCmdShortcut@@QAE@ABV0@@Z
.xdata$x:0000CB50                 db    0
.xdata$x:0000CB51                 db    0
.xdata$x:0000CB52                 db    0
.xdata$x:0000CB53                 db    0
.xdata$x:0000CB54                 db    0
.xdata$x:0000CB55                 db    0
.xdata$x:0000CB56                 db    0
.xdata$x:0000CB57                 db    0
.xdata$x:0000CB58                 db    0
.xdata$x:0000CB59                 db    0
.xdata$x:0000CB5A                 db    0
.xdata$x:0000CB5B                 db    0
.xdata$x:0000CB5C                 db    0
.xdata$x:0000CB5D                 db    0
.xdata$x:0000CB5E                 db    0
.xdata$x:0000CB5F                 db    0
.xdata$x:0000CB60                 db    0
.xdata$x:0000CB61                 db    0
.xdata$x:0000CB62                 db    0
.xdata$x:0000CB63                 db    0
.xdata$x:0000CB64                 db    0
.xdata$x:0000CB65                 db    0
.xdata$x:0000CB66                 db    0
.xdata$x:0000CB67                 db    0
.xdata$x:0000CB67 _xdata$x        ends
.xdata$x:0000CB67
.xdata$x:0000CB68 ; ===========================================================================
.xdata$x:0000CB68
.xdata$x:0000CB68 ; Segment type: Pure data
.xdata$x:0000CB68 ; Segment permissions: Read
.xdata$x:0000CB68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CB68                 assume cs:_xdata$x
.xdata$x:0000CB68                 ;org 0CB68h
.xdata$x:0000CB68 ; COMDAT (pick associative to section at A618)
.xdata$x:0000CB68 __unwindtable$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z db 0FFh
.xdata$x:0000CB68                                         ; DATA XREF: .xdata$x:0000CB78o
.xdata$x:0000CB69                 db 0FFh
.xdata$x:0000CB6A                 db 0FFh
.xdata$x:0000CB6B                 db 0FFh
.xdata$x:0000CB6C                 dd offset __unwindfunclet$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z$0
.xdata$x:0000CB70 __ehfuncinfo$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z db  22h ; "
.xdata$x:0000CB70                                         ; DATA XREF: __ehhandler$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z+11o
.xdata$x:0000CB71                 db    5
.xdata$x:0000CB72                 db  93h ; 
.xdata$x:0000CB73                 db  19h
.xdata$x:0000CB74                 db    1
.xdata$x:0000CB75                 db    0
.xdata$x:0000CB76                 db    0
.xdata$x:0000CB77                 db    0
.xdata$x:0000CB78                 dd offset __unwindtable$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z
.xdata$x:0000CB7C                 db    0
.xdata$x:0000CB7D                 db    0
.xdata$x:0000CB7E                 db    0
.xdata$x:0000CB7F                 db    0
.xdata$x:0000CB80                 db    0
.xdata$x:0000CB81                 db    0
.xdata$x:0000CB82                 db    0
.xdata$x:0000CB83                 db    0
.xdata$x:0000CB84                 db    0
.xdata$x:0000CB85                 db    0
.xdata$x:0000CB86                 db    0
.xdata$x:0000CB87                 db    0
.xdata$x:0000CB88                 db    0
.xdata$x:0000CB89                 db    0
.xdata$x:0000CB8A                 db    0
.xdata$x:0000CB8B                 db    0
.xdata$x:0000CB8C                 db    0
.xdata$x:0000CB8D                 db    0
.xdata$x:0000CB8E                 db    0
.xdata$x:0000CB8F                 db    0
.xdata$x:0000CB90                 db    0
.xdata$x:0000CB91                 db    0
.xdata$x:0000CB92                 db    0
.xdata$x:0000CB93                 db    0
.xdata$x:0000CB93 _xdata$x        ends
.xdata$x:0000CB93
.xdata$x:0000CB94 ; ===========================================================================
.xdata$x:0000CB94
.xdata$x:0000CB94 ; Segment type: Pure data
.xdata$x:0000CB94 ; Segment permissions: Read
.xdata$x:0000CB94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CB94                 assume cs:_xdata$x
.xdata$x:0000CB94                 ;org 0CB94h
.xdata$x:0000CB94 ; COMDAT (pick associative to section at 58D0)
.xdata$x:0000CB94 __unwindtable$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CB94                                         ; DATA XREF: .xdata$x:0000CBA4o
.xdata$x:0000CB95                 db 0FFh
.xdata$x:0000CB96                 db 0FFh
.xdata$x:0000CB97                 db 0FFh
.xdata$x:0000CB98                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000CB9C __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CB9C                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000CB9D                 db    5
.xdata$x:0000CB9E                 db  93h ; 
.xdata$x:0000CB9F                 db  19h
.xdata$x:0000CBA0                 db    1
.xdata$x:0000CBA1                 db    0
.xdata$x:0000CBA2                 db    0
.xdata$x:0000CBA3                 db    0
.xdata$x:0000CBA4                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000CBA8                 align 20h
.xdata$x:0000CBA8 _xdata$x        ends
.xdata$x:0000CBA8
.xdata$x:0000CBC0 ; ===========================================================================
.xdata$x:0000CBC0
.xdata$x:0000CBC0 ; Segment type: Pure data
.xdata$x:0000CBC0 ; Segment permissions: Read
.xdata$x:0000CBC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CBC0                 assume cs:_xdata$x
.xdata$x:0000CBC0                 ;org 0CBC0h
.xdata$x:0000CBC0 ; COMDAT (pick associative to section at 6A58)
.xdata$x:0000CBC0 __unwindtable$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CBC0                                         ; DATA XREF: .xdata$x:0000CBD0o
.xdata$x:0000CBC1                 db 0FFh
.xdata$x:0000CBC2                 db 0FFh
.xdata$x:0000CBC3                 db 0FFh
.xdata$x:0000CBC4                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000CBC8 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CBC8                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000CBC9                 db    5
.xdata$x:0000CBCA                 db  93h ; 
.xdata$x:0000CBCB                 db  19h
.xdata$x:0000CBCC                 db    1
.xdata$x:0000CBCD                 db    0
.xdata$x:0000CBCE                 db    0
.xdata$x:0000CBCF                 db    0
.xdata$x:0000CBD0                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000CBD4                 db    0
.xdata$x:0000CBD5                 db    0
.xdata$x:0000CBD6                 db    0
.xdata$x:0000CBD7                 db    0
.xdata$x:0000CBD8                 db    0
.xdata$x:0000CBD9                 db    0
.xdata$x:0000CBDA                 db    0
.xdata$x:0000CBDB                 db    0
.xdata$x:0000CBDC                 db    0
.xdata$x:0000CBDD                 db    0
.xdata$x:0000CBDE                 db    0
.xdata$x:0000CBDF                 db    0
.xdata$x:0000CBE0                 db    0
.xdata$x:0000CBE1                 db    0
.xdata$x:0000CBE2                 db    0
.xdata$x:0000CBE3                 db    0
.xdata$x:0000CBE4                 db    0
.xdata$x:0000CBE5                 db    0
.xdata$x:0000CBE6                 db    0
.xdata$x:0000CBE7                 db    0
.xdata$x:0000CBE8                 db    0
.xdata$x:0000CBE9                 db    0
.xdata$x:0000CBEA                 db    0
.xdata$x:0000CBEB                 db    0
.xdata$x:0000CBEB _xdata$x        ends
.xdata$x:0000CBEB
.xdata$x:0000CBEC ; ===========================================================================
.xdata$x:0000CBEC
.xdata$x:0000CBEC ; Segment type: Pure data
.xdata$x:0000CBEC ; Segment permissions: Read
.xdata$x:0000CBEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CBEC                 assume cs:_xdata$x
.xdata$x:0000CBEC                 ;org 0CBECh
.xdata$x:0000CBEC ; COMDAT (pick associative to section at 5854)
.xdata$x:0000CBEC __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z db 0FFh
.xdata$x:0000CBEC                                         ; DATA XREF: .xdata$x:0000CBFCo
.xdata$x:0000CBED                 db 0FFh
.xdata$x:0000CBEE                 db 0FFh
.xdata$x:0000CBEF                 db 0FFh
.xdata$x:0000CBF0                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z$0
.xdata$x:0000CBF4 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z db  22h ; "
.xdata$x:0000CBF4                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z+11o
.xdata$x:0000CBF5                 db    5
.xdata$x:0000CBF6                 db  93h ; 
.xdata$x:0000CBF7                 db  19h
.xdata$x:0000CBF8                 db    1
.xdata$x:0000CBF9                 db    0
.xdata$x:0000CBFA                 db    0
.xdata$x:0000CBFB                 db    0
.xdata$x:0000CBFC                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
.xdata$x:0000CC00                 db    0
.xdata$x:0000CC01                 db    0
.xdata$x:0000CC02                 db    0
.xdata$x:0000CC03                 db    0
.xdata$x:0000CC04                 db    0
.xdata$x:0000CC05                 db    0
.xdata$x:0000CC06                 db    0
.xdata$x:0000CC07                 db    0
.xdata$x:0000CC08                 db    0
.xdata$x:0000CC09                 db    0
.xdata$x:0000CC0A                 db    0
.xdata$x:0000CC0B                 db    0
.xdata$x:0000CC0C                 db    0
.xdata$x:0000CC0D                 db    0
.xdata$x:0000CC0E                 db    0
.xdata$x:0000CC0F                 db    0
.xdata$x:0000CC10                 db    0
.xdata$x:0000CC11                 db    0
.xdata$x:0000CC12                 db    0
.xdata$x:0000CC13                 db    0
.xdata$x:0000CC14                 db    0
.xdata$x:0000CC15                 db    0
.xdata$x:0000CC16                 db    0
.xdata$x:0000CC17                 db    0
.xdata$x:0000CC17 _xdata$x        ends
.xdata$x:0000CC17
.xdata$x:0000CC18 ; ===========================================================================
.xdata$x:0000CC18
.xdata$x:0000CC18 ; Segment type: Pure data
.xdata$x:0000CC18 ; Segment permissions: Read
.xdata$x:0000CC18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CC18                 assume cs:_xdata$x
.xdata$x:0000CC18                 ;org 0CC18h
.xdata$x:0000CC18 ; COMDAT (pick associative to section at 69E0)
.xdata$x:0000CC18 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000CC18                                         ; DATA XREF: .xdata$x:0000CC28o
.xdata$x:0000CC19                 db 0FFh
.xdata$x:0000CC1A                 db 0FFh
.xdata$x:0000CC1B                 db 0FFh
.xdata$x:0000CC1C                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ$0
.xdata$x:0000CC20 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CC20                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ+11o
.xdata$x:0000CC21                 db    5
.xdata$x:0000CC22                 db  93h ; 
.xdata$x:0000CC23                 db  19h
.xdata$x:0000CC24                 db    1
.xdata$x:0000CC25                 db    0
.xdata$x:0000CC26                 db    0
.xdata$x:0000CC27                 db    0
.xdata$x:0000CC28                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QAE@XZ
.xdata$x:0000CC2C                 db    0
.xdata$x:0000CC2D                 db    0
.xdata$x:0000CC2E                 db    0
.xdata$x:0000CC2F                 db    0
.xdata$x:0000CC30                 db    0
.xdata$x:0000CC31                 db    0
.xdata$x:0000CC32                 db    0
.xdata$x:0000CC33                 db    0
.xdata$x:0000CC34                 db    0
.xdata$x:0000CC35                 db    0
.xdata$x:0000CC36                 db    0
.xdata$x:0000CC37                 db    0
.xdata$x:0000CC38                 db    0
.xdata$x:0000CC39                 db    0
.xdata$x:0000CC3A                 db    0
.xdata$x:0000CC3B                 db    0
.xdata$x:0000CC3C                 db    0
.xdata$x:0000CC3D                 db    0
.xdata$x:0000CC3E                 db    0
.xdata$x:0000CC3F                 db    0
.xdata$x:0000CC40                 db    0
.xdata$x:0000CC41                 db    0
.xdata$x:0000CC42                 db    0
.xdata$x:0000CC43                 db    0
.xdata$x:0000CC43 _xdata$x        ends
.xdata$x:0000CC43
.xdata$x:0000CC44 ; ===========================================================================
.xdata$x:0000CC44
.xdata$x:0000CC44 ; Segment type: Pure data
.xdata$x:0000CC44 ; Segment permissions: Read
.xdata$x:0000CC44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CC44                 assume cs:_xdata$x
.xdata$x:0000CC44                 ;org 0CC44h
.xdata$x:0000CC44 ; COMDAT (pick associative to section at 5E04)
.xdata$x:0000CC44 __unwindtable$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000CC44                                         ; DATA XREF: .xdata$x:0000CC54o
.xdata$x:0000CC45                 db 0FFh
.xdata$x:0000CC46                 db 0FFh
.xdata$x:0000CC47                 db 0FFh
.xdata$x:0000CC48                 dd offset __unwindfunclet$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0
.xdata$x:0000CC4C __ehfuncinfo$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CC4C                                         ; DATA XREF: __ehhandler$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:0000CC4D                 db    5
.xdata$x:0000CC4E                 db  93h ; 
.xdata$x:0000CC4F                 db  19h
.xdata$x:0000CC50                 db    1
.xdata$x:0000CC51                 db    0
.xdata$x:0000CC52                 db    0
.xdata$x:0000CC53                 db    0
.xdata$x:0000CC54                 dd offset __unwindtable$??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.xdata$x:0000CC58                 db    0
.xdata$x:0000CC59                 db    0
.xdata$x:0000CC5A                 db    0
.xdata$x:0000CC5B                 db    0
.xdata$x:0000CC5C                 db    0
.xdata$x:0000CC5D                 db    0
.xdata$x:0000CC5E                 db    0
.xdata$x:0000CC5F                 db    0
.xdata$x:0000CC60                 db    0
.xdata$x:0000CC61                 db    0
.xdata$x:0000CC62                 db    0
.xdata$x:0000CC63                 db    0
.xdata$x:0000CC64                 db    0
.xdata$x:0000CC65                 db    0
.xdata$x:0000CC66                 db    0
.xdata$x:0000CC67                 db    0
.xdata$x:0000CC68                 db    0
.xdata$x:0000CC69                 db    0
.xdata$x:0000CC6A                 db    0
.xdata$x:0000CC6B                 db    0
.xdata$x:0000CC6C                 db    0
.xdata$x:0000CC6D                 db    0
.xdata$x:0000CC6E                 db    0
.xdata$x:0000CC6F                 db    0
.xdata$x:0000CC6F _xdata$x        ends
.xdata$x:0000CC6F
.xdata$x:0000CC70 ; ===========================================================================
.xdata$x:0000CC70
.xdata$x:0000CC70 ; Segment type: Pure data
.xdata$x:0000CC70 ; Segment permissions: Read
.xdata$x:0000CC70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CC70                 assume cs:_xdata$x
.xdata$x:0000CC70                 ;org 0CC70h
.xdata$x:0000CC70 ; COMDAT (pick associative to section at 6C30)
.xdata$x:0000CC70 __unwindtable$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000CC70                                         ; DATA XREF: .xdata$x:0000CC80o
.xdata$x:0000CC71                 db 0FFh
.xdata$x:0000CC72                 db 0FFh
.xdata$x:0000CC73                 db 0FFh
.xdata$x:0000CC74                 dd offset __unwindfunclet$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0
.xdata$x:0000CC78 __ehfuncinfo$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000CC78                                         ; DATA XREF: __ehhandler$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ+11o
.xdata$x:0000CC79                 db    5
.xdata$x:0000CC7A                 db  93h ; 
.xdata$x:0000CC7B                 db  19h
.xdata$x:0000CC7C                 db    1
.xdata$x:0000CC7D                 db    0
.xdata$x:0000CC7E                 db    0
.xdata$x:0000CC7F                 db    0
.xdata$x:0000CC80                 dd offset __unwindtable$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
.xdata$x:0000CC84                 db    0
.xdata$x:0000CC85                 db    0
.xdata$x:0000CC86                 db    0
.xdata$x:0000CC87                 db    0
.xdata$x:0000CC88                 db    0
.xdata$x:0000CC89                 db    0
.xdata$x:0000CC8A                 db    0
.xdata$x:0000CC8B                 db    0
.xdata$x:0000CC8C                 db    0
.xdata$x:0000CC8D                 db    0
.xdata$x:0000CC8E                 db    0
.xdata$x:0000CC8F                 db    0
.xdata$x:0000CC90                 db    0
.xdata$x:0000CC91                 db    0
.xdata$x:0000CC92                 db    0
.xdata$x:0000CC93                 db    0
.xdata$x:0000CC94                 db    0
.xdata$x:0000CC95                 db    0
.xdata$x:0000CC96                 db    0
.xdata$x:0000CC97                 db    0
.xdata$x:0000CC98                 db    0
.xdata$x:0000CC99                 db    0
.xdata$x:0000CC9A                 db    0
.xdata$x:0000CC9B                 db    0
.xdata$x:0000CC9B _xdata$x        ends
.xdata$x:0000CC9B
.xdata$x:0000CC9C ; ===========================================================================
.xdata$x:0000CC9C
.xdata$x:0000CC9C ; Segment type: Pure data
.xdata$x:0000CC9C ; Segment permissions: Read
.xdata$x:0000CC9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CC9C                 assume cs:_xdata$x
.xdata$x:0000CC9C                 ;org 0CC9Ch
.xdata$x:0000CC9C ; COMDAT (pick associative to section at 9274)
.xdata$x:0000CC9C __catchsym$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$2 db    0
.xdata$x:0000CC9C                                         ; DATA XREF: .xdata$x:0000CCCCo
.xdata$x:0000CC9D                 db    0
.xdata$x:0000CC9E                 db    0
.xdata$x:0000CC9F                 db    0
.xdata$x:0000CCA0                 db    0
.xdata$x:0000CCA1                 db    0
.xdata$x:0000CCA2                 db    0
.xdata$x:0000CCA3                 db    0
.xdata$x:0000CCA4                 db    0
.xdata$x:0000CCA5                 db    0
.xdata$x:0000CCA6                 db    0
.xdata$x:0000CCA7                 db    0
.xdata$x:0000CCA8                 dd offset __catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$0
.xdata$x:0000CCAC __unwindtable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z db 0FFh
.xdata$x:0000CCAC                                         ; DATA XREF: .xdata$x:0000CCD8o
.xdata$x:0000CCAD                 db 0FFh
.xdata$x:0000CCAE                 db 0FFh
.xdata$x:0000CCAF                 db 0FFh
.xdata$x:0000CCB0                 db    0
.xdata$x:0000CCB1                 db    0
.xdata$x:0000CCB2                 db    0
.xdata$x:0000CCB3                 db    0
.xdata$x:0000CCB4                 db 0FFh
.xdata$x:0000CCB5                 db 0FFh
.xdata$x:0000CCB6                 db 0FFh
.xdata$x:0000CCB7                 db 0FFh
.xdata$x:0000CCB8                 db    0
.xdata$x:0000CCB9                 db    0
.xdata$x:0000CCBA                 db    0
.xdata$x:0000CCBB                 db    0
.xdata$x:0000CCBC __tryblocktable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z db    0
.xdata$x:0000CCBC                                         ; DATA XREF: .xdata$x:0000CCE0o
.xdata$x:0000CCBD                 db    0
.xdata$x:0000CCBE                 db    0
.xdata$x:0000CCBF                 db    0
.xdata$x:0000CCC0                 db    0
.xdata$x:0000CCC1                 db    0
.xdata$x:0000CCC2                 db    0
.xdata$x:0000CCC3                 db    0
.xdata$x:0000CCC4                 db    1
.xdata$x:0000CCC5                 db    0
.xdata$x:0000CCC6                 db    0
.xdata$x:0000CCC7                 db    0
.xdata$x:0000CCC8                 db    1
.xdata$x:0000CCC9                 db    0
.xdata$x:0000CCCA                 db    0
.xdata$x:0000CCCB                 db    0
.xdata$x:0000CCCC                 dd offset __catchsym$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z$2
.xdata$x:0000CCD0 __ehfuncinfo$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000CCD0                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z+11o
.xdata$x:0000CCD1                 db    5
.xdata$x:0000CCD2                 db  93h ; 
.xdata$x:0000CCD3                 db  19h
.xdata$x:0000CCD4                 db    2
.xdata$x:0000CCD5                 db    0
.xdata$x:0000CCD6                 db    0
.xdata$x:0000CCD7                 db    0
.xdata$x:0000CCD8                 dd offset __unwindtable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.xdata$x:0000CCDC                 db    1
.xdata$x:0000CCDD                 db    0
.xdata$x:0000CCDE                 db    0
.xdata$x:0000CCDF                 db    0
.xdata$x:0000CCE0                 dd offset __tryblocktable$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
.xdata$x:0000CCE4                 db    0
.xdata$x:0000CCE5                 db    0
.xdata$x:0000CCE6                 db    0
.xdata$x:0000CCE7                 db    0
.xdata$x:0000CCE8                 db    0
.xdata$x:0000CCE9                 db    0
.xdata$x:0000CCEA                 db    0
.xdata$x:0000CCEB                 db    0
.xdata$x:0000CCEC                 db    0
.xdata$x:0000CCED                 db    0
.xdata$x:0000CCEE                 db    0
.xdata$x:0000CCEF                 db    0
.xdata$x:0000CCF0                 db    0
.xdata$x:0000CCF1                 db    0
.xdata$x:0000CCF2                 db    0
.xdata$x:0000CCF3                 db    0
.xdata$x:0000CCF3 _xdata$x        ends
.xdata$x:0000CCF3
.xdata$x:0000CCF4 ; ===========================================================================
.xdata$x:0000CCF4
.xdata$x:0000CCF4 ; Segment type: Pure data
.xdata$x:0000CCF4 ; Segment permissions: Read
.xdata$x:0000CCF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CCF4                 assume cs:_xdata$x
.xdata$x:0000CCF4                 ;org 0CCF4h
.xdata$x:0000CCF4 ; COMDAT (pick associative to section at 8B4C)
.xdata$x:0000CCF4 __unwindtable$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z db 0FFh
.xdata$x:0000CCF4                                         ; DATA XREF: .xdata$x:0000CD04o
.xdata$x:0000CCF5                 db 0FFh
.xdata$x:0000CCF6                 db 0FFh
.xdata$x:0000CCF7                 db 0FFh
.xdata$x:0000CCF8                 dd offset __unwindfunclet$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z$0
.xdata$x:0000CCFC __ehfuncinfo$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z db  22h ; "
.xdata$x:0000CCFC                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z+11o
.xdata$x:0000CCFD                 db    5
.xdata$x:0000CCFE                 db  93h ; 
.xdata$x:0000CCFF                 db  19h
.xdata$x:0000CD00                 db    1
.xdata$x:0000CD01                 db    0
.xdata$x:0000CD02                 db    0
.xdata$x:0000CD03                 db    0
.xdata$x:0000CD04                 dd offset __unwindtable$?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IBEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
.xdata$x:0000CD08                 align 20h
.xdata$x:0000CD08 _xdata$x        ends
.xdata$x:0000CD08
.xdata$x:0000CD20 ; ===========================================================================
.xdata$x:0000CD20
.xdata$x:0000CD20 ; Segment type: Pure data
.xdata$x:0000CD20 ; Segment permissions: Read
.xdata$x:0000CD20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CD20                 assume cs:_xdata$x
.xdata$x:0000CD20                 ;org 0CD20h
.xdata$x:0000CD20 ; COMDAT (pick associative to section at 9AC8)
.xdata$x:0000CD20 __unwindtable$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z db 0FFh
.xdata$x:0000CD20                                         ; DATA XREF: .xdata$x:0000CD38o
.xdata$x:0000CD21                 db 0FFh
.xdata$x:0000CD22                 db 0FFh
.xdata$x:0000CD23                 db 0FFh
.xdata$x:0000CD24                 dd offset __unwindfunclet$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z$0
.xdata$x:0000CD28                 db    0
.xdata$x:0000CD29                 db    0
.xdata$x:0000CD2A                 db    0
.xdata$x:0000CD2B                 db    0
.xdata$x:0000CD2C                 dd offset __unwindfunclet$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z$1
.xdata$x:0000CD30 __ehfuncinfo$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z db  22h ; "
.xdata$x:0000CD30                                         ; DATA XREF: __ehhandler$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z+1Bo
.xdata$x:0000CD31                 db    5
.xdata$x:0000CD32                 db  93h ; 
.xdata$x:0000CD33                 db  19h
.xdata$x:0000CD34                 db    2
.xdata$x:0000CD35                 db    0
.xdata$x:0000CD36                 db    0
.xdata$x:0000CD37                 db    0
.xdata$x:0000CD38                 dd offset __unwindtable$?add@PluginList@@QAEXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@Z
.xdata$x:0000CD3C                 db    0
.xdata$x:0000CD3D                 db    0
.xdata$x:0000CD3E                 db    0
.xdata$x:0000CD3F                 db    0
.xdata$x:0000CD40                 db    0
.xdata$x:0000CD41                 db    0
.xdata$x:0000CD42                 db    0
.xdata$x:0000CD43                 db    0
.xdata$x:0000CD44                 db    0
.xdata$x:0000CD45                 db    0
.xdata$x:0000CD46                 db    0
.xdata$x:0000CD47                 db    0
.xdata$x:0000CD48                 db    0
.xdata$x:0000CD49                 db    0
.xdata$x:0000CD4A                 db    0
.xdata$x:0000CD4B                 db    0
.xdata$x:0000CD4C                 db    0
.xdata$x:0000CD4D                 db    0
.xdata$x:0000CD4E                 db    0
.xdata$x:0000CD4F                 db    0
.xdata$x:0000CD50                 db    0
.xdata$x:0000CD51                 db    0
.xdata$x:0000CD52                 db    0
.xdata$x:0000CD53                 db    0
.xdata$x:0000CD53 _xdata$x        ends
.xdata$x:0000CD53
.xdata$x:0000CD54 ; ===========================================================================
.xdata$x:0000CD54
.xdata$x:0000CD54 ; Segment type: Pure data
.xdata$x:0000CD54 ; Segment permissions: Read
.xdata$x:0000CD54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CD54                 assume cs:_xdata$x
.xdata$x:0000CD54                 ;org 0CD54h
.xdata$x:0000CD54 ; COMDAT (pick associative to section at 8FBC)
.xdata$x:0000CD54 __catchsym$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z$2 db    0
.xdata$x:0000CD54                                         ; DATA XREF: .xdata$x:0000CD84o
.xdata$x:0000CD55                 db    0
.xdata$x:0000CD56                 db    0
.xdata$x:0000CD57                 db    0
.xdata$x:0000CD58                 db    0
.xdata$x:0000CD59                 db    0
.xdata$x:0000CD5A                 db    0
.xdata$x:0000CD5B                 db    0
.xdata$x:0000CD5C                 db    0
.xdata$x:0000CD5D                 db    0
.xdata$x:0000CD5E                 db    0
.xdata$x:0000CD5F                 db    0
.xdata$x:0000CD60                 dd offset __catch$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z$0
.xdata$x:0000CD64 __unwindtable$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z db 0FFh
.xdata$x:0000CD64                                         ; DATA XREF: .xdata$x:0000CD90o
.xdata$x:0000CD65                 db 0FFh
.xdata$x:0000CD66                 db 0FFh
.xdata$x:0000CD67                 db 0FFh
.xdata$x:0000CD68                 db    0
.xdata$x:0000CD69                 db    0
.xdata$x:0000CD6A                 db    0
.xdata$x:0000CD6B                 db    0
.xdata$x:0000CD6C                 db 0FFh
.xdata$x:0000CD6D                 db 0FFh
.xdata$x:0000CD6E                 db 0FFh
.xdata$x:0000CD6F                 db 0FFh
.xdata$x:0000CD70                 db    0
.xdata$x:0000CD71                 db    0
.xdata$x:0000CD72                 db    0
.xdata$x:0000CD73                 db    0
.xdata$x:0000CD74 __tryblocktable$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z db    0
.xdata$x:0000CD74                                         ; DATA XREF: .xdata$x:0000CD98o
.xdata$x:0000CD75                 db    0
.xdata$x:0000CD76                 db    0
.xdata$x:0000CD77                 db    0
.xdata$x:0000CD78                 db    0
.xdata$x:0000CD79                 db    0
.xdata$x:0000CD7A                 db    0
.xdata$x:0000CD7B                 db    0
.xdata$x:0000CD7C                 db    1
.xdata$x:0000CD7D                 db    0
.xdata$x:0000CD7E                 db    0
.xdata$x:0000CD7F                 db    0
.xdata$x:0000CD80                 db    1
.xdata$x:0000CD81                 db    0
.xdata$x:0000CD82                 db    0
.xdata$x:0000CD83                 db    0
.xdata$x:0000CD84                 dd offset __catchsym$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z$2
.xdata$x:0000CD88 __ehfuncinfo$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000CD88                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z+11o
.xdata$x:0000CD89                 db    5
.xdata$x:0000CD8A                 db  93h ; 
.xdata$x:0000CD8B                 db  19h
.xdata$x:0000CD8C                 db    2
.xdata$x:0000CD8D                 db    0
.xdata$x:0000CD8E                 db    0
.xdata$x:0000CD8F                 db    0
.xdata$x:0000CD90                 dd offset __unwindtable$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z
.xdata$x:0000CD94                 db    1
.xdata$x:0000CD95                 db    0
.xdata$x:0000CD96                 db    0
.xdata$x:0000CD97                 db    0
.xdata$x:0000CD98                 dd offset __tryblocktable$?_Reallocate@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IAEXI@Z
.xdata$x:0000CD9C                 db    0
.xdata$x:0000CD9D                 db    0
.xdata$x:0000CD9E                 db    0
.xdata$x:0000CD9F                 db    0
.xdata$x:0000CDA0                 db    0
.xdata$x:0000CDA1                 db    0
.xdata$x:0000CDA2                 db    0
.xdata$x:0000CDA3                 db    0
.xdata$x:0000CDA4                 db    0
.xdata$x:0000CDA5                 db    0
.xdata$x:0000CDA6                 db    0
.xdata$x:0000CDA7                 db    0
.xdata$x:0000CDA8                 db    0
.xdata$x:0000CDA9                 db    0
.xdata$x:0000CDAA                 db    0
.xdata$x:0000CDAB                 db    0
.xdata$x:0000CDAB _xdata$x        ends
.xdata$x:0000CDAB
.xdata$x:0000CDAC ; ===========================================================================
.xdata$x:0000CDAC
.xdata$x:0000CDAC ; Segment type: Pure data
.xdata$x:0000CDAC ; Segment permissions: Read
.xdata$x:0000CDAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CDAC                 assume cs:_xdata$x
.xdata$x:0000CDAC                 ;org 0CDACh
.xdata$x:0000CDAC ; COMDAT (pick associative to section at 8994)
.xdata$x:0000CDAC __unwindtable$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z db 0FFh
.xdata$x:0000CDAC                                         ; DATA XREF: .xdata$x:0000CDBCo
.xdata$x:0000CDAD                 db 0FFh
.xdata$x:0000CDAE                 db 0FFh
.xdata$x:0000CDAF                 db 0FFh
.xdata$x:0000CDB0                 dd offset __unwindfunclet$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z$0
.xdata$x:0000CDB4 __ehfuncinfo$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z db  22h ; "
.xdata$x:0000CDB4                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z+11o
.xdata$x:0000CDB5                 db    5
.xdata$x:0000CDB6                 db  93h ; 
.xdata$x:0000CDB7                 db  19h
.xdata$x:0000CDB8                 db    1
.xdata$x:0000CDB9                 db    0
.xdata$x:0000CDBA                 db    0
.xdata$x:0000CDBB                 db    0
.xdata$x:0000CDBC                 dd offset __unwindtable$?_Orphan_range@?$vector@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@IBEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@0@Z
.xdata$x:0000CDC0                 db    0
.xdata$x:0000CDC1                 db    0
.xdata$x:0000CDC2                 db    0
.xdata$x:0000CDC3                 db    0
.xdata$x:0000CDC4                 db    0
.xdata$x:0000CDC5                 db    0
.xdata$x:0000CDC6                 db    0
.xdata$x:0000CDC7                 db    0
.xdata$x:0000CDC8                 db    0
.xdata$x:0000CDC9                 db    0
.xdata$x:0000CDCA                 db    0
.xdata$x:0000CDCB                 db    0
.xdata$x:0000CDCC                 db    0
.xdata$x:0000CDCD                 db    0
.xdata$x:0000CDCE                 db    0
.xdata$x:0000CDCF                 db    0
.xdata$x:0000CDD0                 db    0
.xdata$x:0000CDD1                 db    0
.xdata$x:0000CDD2                 db    0
.xdata$x:0000CDD3                 db    0
.xdata$x:0000CDD4                 db    0
.xdata$x:0000CDD5                 db    0
.xdata$x:0000CDD6                 db    0
.xdata$x:0000CDD7                 db    0
.xdata$x:0000CDD7 _xdata$x        ends
.xdata$x:0000CDD7
.xdata$x:0000CDD8 ; ===========================================================================
.xdata$x:0000CDD8
.xdata$x:0000CDD8 ; Segment type: Pure data
.xdata$x:0000CDD8 ; Segment permissions: Read
.xdata$x:0000CDD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CDD8                 assume cs:_xdata$x
.xdata$x:0000CDD8                 ;org 0CDD8h
.xdata$x:0000CDD8 ; COMDAT (pick associative to section at 6BC0)
.xdata$x:0000CDD8 __unwindtable$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ db 0FFh
.xdata$x:0000CDD8                                         ; DATA XREF: .xdata$x:0000CDE8o
.xdata$x:0000CDD9                 db 0FFh
.xdata$x:0000CDDA                 db 0FFh
.xdata$x:0000CDDB                 db 0FFh
.xdata$x:0000CDDC                 dd offset __unwindfunclet$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ$0
.xdata$x:0000CDE0 __ehfuncinfo$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ db  22h ; "
.xdata$x:0000CDE0                                         ; DATA XREF: __ehhandler$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ+11o
.xdata$x:0000CDE1                 db    5
.xdata$x:0000CDE2                 db  93h ; 
.xdata$x:0000CDE3                 db  19h
.xdata$x:0000CDE4                 db    1
.xdata$x:0000CDE5                 db    0
.xdata$x:0000CDE6                 db    0
.xdata$x:0000CDE7                 db    0
.xdata$x:0000CDE8                 dd offset __unwindtable$??1?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ
.xdata$x:0000CDEC                 db    0
.xdata$x:0000CDED                 db    0
.xdata$x:0000CDEE                 db    0
.xdata$x:0000CDEF                 db    0
.xdata$x:0000CDF0                 db    0
.xdata$x:0000CDF1                 db    0
.xdata$x:0000CDF2                 db    0
.xdata$x:0000CDF3                 db    0
.xdata$x:0000CDF4                 db    0
.xdata$x:0000CDF5                 db    0
.xdata$x:0000CDF6                 db    0
.xdata$x:0000CDF7                 db    0
.xdata$x:0000CDF8                 db    0
.xdata$x:0000CDF9                 db    0
.xdata$x:0000CDFA                 db    0
.xdata$x:0000CDFB                 db    0
.xdata$x:0000CDFC                 db    0
.xdata$x:0000CDFD                 db    0
.xdata$x:0000CDFE                 db    0
.xdata$x:0000CDFF                 db    0
.xdata$x:0000CE00                 db    0
.xdata$x:0000CE01                 db    0
.xdata$x:0000CE02                 db    0
.xdata$x:0000CE03                 db    0
.xdata$x:0000CE03 _xdata$x        ends
.xdata$x:0000CE03
.xdata$x:0000CE04 ; ===========================================================================
.xdata$x:0000CE04
.xdata$x:0000CE04 ; Segment type: Pure data
.xdata$x:0000CE04 ; Segment permissions: Read
.xdata$x:0000CE04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CE04                 assume cs:_xdata$x
.xdata$x:0000CE04                 ;org 0CE04h
.xdata$x:0000CE04 ; COMDAT (pick associative to section at 30A0)
.xdata$x:0000CE04 __unwindtable$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z db 0FFh
.xdata$x:0000CE04                                         ; DATA XREF: .xdata$x:0000CE14o
.xdata$x:0000CE05                 db 0FFh
.xdata$x:0000CE06                 db 0FFh
.xdata$x:0000CE07                 db 0FFh
.xdata$x:0000CE08                 dd offset __unwindfunclet$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z$0
.xdata$x:0000CE0C __ehfuncinfo$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z db  22h ; "
.xdata$x:0000CE0C                                         ; DATA XREF: __ehhandler$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z+11o
.xdata$x:0000CE0D                 db    5
.xdata$x:0000CE0E                 db  93h ; 
.xdata$x:0000CE0F                 db  19h
.xdata$x:0000CE10                 db    1
.xdata$x:0000CE11                 db    0
.xdata$x:0000CE12                 db    0
.xdata$x:0000CE13                 db    0
.xdata$x:0000CE14                 dd offset __unwindtable$??$?0AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AA_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AA_N@Z
.xdata$x:0000CE18                 db    0
.xdata$x:0000CE19                 db    0
.xdata$x:0000CE1A                 db    0
.xdata$x:0000CE1B                 db    0
.xdata$x:0000CE1C                 db    0
.xdata$x:0000CE1D                 db    0
.xdata$x:0000CE1E                 db    0
.xdata$x:0000CE1F                 db    0
.xdata$x:0000CE20                 db    0
.xdata$x:0000CE21                 db    0
.xdata$x:0000CE22                 db    0
.xdata$x:0000CE23                 db    0
.xdata$x:0000CE24                 db    0
.xdata$x:0000CE25                 db    0
.xdata$x:0000CE26                 db    0
.xdata$x:0000CE27                 db    0
.xdata$x:0000CE28                 db    0
.xdata$x:0000CE29                 db    0
.xdata$x:0000CE2A                 db    0
.xdata$x:0000CE2B                 db    0
.xdata$x:0000CE2C                 db    0
.xdata$x:0000CE2D                 db    0
.xdata$x:0000CE2E                 db    0
.xdata$x:0000CE2F                 db    0
.xdata$x:0000CE2F _xdata$x        ends
.xdata$x:0000CE2F
.xdata$x:0000CE30 ; ===========================================================================
.xdata$x:0000CE30
.xdata$x:0000CE30 ; Segment type: Pure data
.xdata$x:0000CE30 ; Segment permissions: Read
.xdata$x:0000CE30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CE30                 assume cs:_xdata$x
.xdata$x:0000CE30                 ;org 0CE30h
.xdata$x:0000CE30 ; COMDAT (pick associative to section at ADE0)
.xdata$x:0000CE30 __unwindtable$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ db 0FFh
.xdata$x:0000CE30                                         ; DATA XREF: .xdata$x:0000CE40o
.xdata$x:0000CE31                 db 0FFh
.xdata$x:0000CE32                 db 0FFh
.xdata$x:0000CE33                 db 0FFh
.xdata$x:0000CE34                 dd offset __unwindfunclet$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0
.xdata$x:0000CE38 __ehfuncinfo$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ db  22h ; "
.xdata$x:0000CE38                                         ; DATA XREF: __ehhandler$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ+11o
.xdata$x:0000CE39                 db    5
.xdata$x:0000CE3A                 db  93h ; 
.xdata$x:0000CE3B                 db  19h
.xdata$x:0000CE3C                 db    1
.xdata$x:0000CE3D                 db    0
.xdata$x:0000CE3E                 db    0
.xdata$x:0000CE3F                 db    0
.xdata$x:0000CE40                 dd offset __unwindtable$?getNppPath@NppParameters@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.xdata$x:0000CE44                 db    0
.xdata$x:0000CE45                 db    0
.xdata$x:0000CE46                 db    0
.xdata$x:0000CE47                 db    0
.xdata$x:0000CE48                 db    0
.xdata$x:0000CE49                 db    0
.xdata$x:0000CE4A                 db    0
.xdata$x:0000CE4B                 db    0
.xdata$x:0000CE4C                 db    0
.xdata$x:0000CE4D                 db    0
.xdata$x:0000CE4E                 db    0
.xdata$x:0000CE4F                 db    0
.xdata$x:0000CE50                 db    0
.xdata$x:0000CE51                 db    0
.xdata$x:0000CE52                 db    0
.xdata$x:0000CE53                 db    0
.xdata$x:0000CE54                 db    0
.xdata$x:0000CE55                 db    0
.xdata$x:0000CE56                 db    0
.xdata$x:0000CE57                 db    0
.xdata$x:0000CE58                 db    0
.xdata$x:0000CE59                 db    0
.xdata$x:0000CE5A                 db    0
.xdata$x:0000CE5B                 db    0
.xdata$x:0000CE5B _xdata$x        ends
.xdata$x:0000CE5B
.xdata$x:0000CE5C ; ===========================================================================
.xdata$x:0000CE5C
.xdata$x:0000CE5C ; Segment type: Pure data
.xdata$x:0000CE5C ; Segment permissions: Read
.xdata$x:0000CE5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CE5C                 assume cs:_xdata$x
.xdata$x:0000CE5C                 ;org 0CE5Ch
.xdata$x:0000CE5C ; COMDAT (pick associative to section at 8E60)
.xdata$x:0000CE5C __catchsym$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000CE5C                                         ; DATA XREF: .xdata$x:0000CE8Co
.xdata$x:0000CE5D                 db    0
.xdata$x:0000CE5E                 db    0
.xdata$x:0000CE5F                 db    0
.xdata$x:0000CE60                 db    0
.xdata$x:0000CE61                 db    0
.xdata$x:0000CE62                 db    0
.xdata$x:0000CE63                 db    0
.xdata$x:0000CE64                 db    0
.xdata$x:0000CE65                 db    0
.xdata$x:0000CE66                 db    0
.xdata$x:0000CE67                 db    0
.xdata$x:0000CE68                 dd offset __catch$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z$0
.xdata$x:0000CE6C __unwindtable$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000CE6C                                         ; DATA XREF: .xdata$x:0000CE98o
.xdata$x:0000CE6D                 db 0FFh
.xdata$x:0000CE6E                 db 0FFh
.xdata$x:0000CE6F                 db 0FFh
.xdata$x:0000CE70                 db    0
.xdata$x:0000CE71                 db    0
.xdata$x:0000CE72                 db    0
.xdata$x:0000CE73                 db    0
.xdata$x:0000CE74                 db 0FFh
.xdata$x:0000CE75                 db 0FFh
.xdata$x:0000CE76                 db 0FFh
.xdata$x:0000CE77                 db 0FFh
.xdata$x:0000CE78                 db    0
.xdata$x:0000CE79                 db    0
.xdata$x:0000CE7A                 db    0
.xdata$x:0000CE7B                 db    0
.xdata$x:0000CE7C __tryblocktable$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z db    0
.xdata$x:0000CE7C                                         ; DATA XREF: .xdata$x:0000CEA0o
.xdata$x:0000CE7D                 db    0
.xdata$x:0000CE7E                 db    0
.xdata$x:0000CE7F                 db    0
.xdata$x:0000CE80                 db    0
.xdata$x:0000CE81                 db    0
.xdata$x:0000CE82                 db    0
.xdata$x:0000CE83                 db    0
.xdata$x:0000CE84                 db    1
.xdata$x:0000CE85                 db    0
.xdata$x:0000CE86                 db    0
.xdata$x:0000CE87                 db    0
.xdata$x:0000CE88                 db    1
.xdata$x:0000CE89                 db    0
.xdata$x:0000CE8A                 db    0
.xdata$x:0000CE8B                 db    0
.xdata$x:0000CE8C                 dd offset __catchsym$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z$2
.xdata$x:0000CE90 __ehfuncinfo$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000CE90                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z+11o
.xdata$x:0000CE91                 db    5
.xdata$x:0000CE92                 db  93h ; 
.xdata$x:0000CE93                 db  19h
.xdata$x:0000CE94                 db    2
.xdata$x:0000CE95                 db    0
.xdata$x:0000CE96                 db    0
.xdata$x:0000CE97                 db    0
.xdata$x:0000CE98                 dd offset __unwindtable$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z
.xdata$x:0000CE9C                 db    1
.xdata$x:0000CE9D                 db    0
.xdata$x:0000CE9E                 db    0
.xdata$x:0000CE9F                 db    0
.xdata$x:0000CEA0                 dd offset __tryblocktable$?_Reallocate@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IAEXI@Z
.xdata$x:0000CEA4                 db    0
.xdata$x:0000CEA5                 db    0
.xdata$x:0000CEA6                 db    0
.xdata$x:0000CEA7                 db    0
.xdata$x:0000CEA8                 db    0
.xdata$x:0000CEA9                 db    0
.xdata$x:0000CEAA                 db    0
.xdata$x:0000CEAB                 db    0
.xdata$x:0000CEAC                 db    0
.xdata$x:0000CEAD                 db    0
.xdata$x:0000CEAE                 db    0
.xdata$x:0000CEAF                 db    0
.xdata$x:0000CEB0                 db    0
.xdata$x:0000CEB1                 db    0
.xdata$x:0000CEB2                 db    0
.xdata$x:0000CEB3                 db    0
.xdata$x:0000CEB3 _xdata$x        ends
.xdata$x:0000CEB3
.xdata$x:0000CEB4 ; ===========================================================================
.xdata$x:0000CEB4
.xdata$x:0000CEB4 ; Segment type: Pure data
.xdata$x:0000CEB4 ; Segment permissions: Read
.xdata$x:0000CEB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CEB4                 assume cs:_xdata$x
.xdata$x:0000CEB4                 ;org 0CEB4h
.xdata$x:0000CEB4 ; COMDAT (pick associative to section at 88B8)
.xdata$x:0000CEB4 __unwindtable$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z db 0FFh
.xdata$x:0000CEB4                                         ; DATA XREF: .xdata$x:0000CEC4o
.xdata$x:0000CEB5                 db 0FFh
.xdata$x:0000CEB6                 db 0FFh
.xdata$x:0000CEB7                 db 0FFh
.xdata$x:0000CEB8                 dd offset __unwindfunclet$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z$0
.xdata$x:0000CEBC __ehfuncinfo$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z db  22h ; "
.xdata$x:0000CEBC                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z+11o
.xdata$x:0000CEBD                 db    5
.xdata$x:0000CEBE                 db  93h ; 
.xdata$x:0000CEBF                 db  19h
.xdata$x:0000CEC0                 db    1
.xdata$x:0000CEC1                 db    0
.xdata$x:0000CEC2                 db    0
.xdata$x:0000CEC3                 db    0
.xdata$x:0000CEC4                 dd offset __unwindtable$?_Orphan_range@?$vector@PAVTiXmlDocument@@V?$allocator@PAVTiXmlDocument@@@std@@@std@@IBEXPAPAVTiXmlDocument@@0@Z
.xdata$x:0000CEC8                 align 20h
.xdata$x:0000CEC8 _xdata$x        ends
.xdata$x:0000CEC8
.xdata$x:0000CEE0 ; ===========================================================================
.xdata$x:0000CEE0
.xdata$x:0000CEE0 ; Segment type: Pure data
.xdata$x:0000CEE0 ; Segment permissions: Read
.xdata$x:0000CEE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CEE0                 assume cs:_xdata$x
.xdata$x:0000CEE0                 ;org 0CEE0h
.xdata$x:0000CEE0 ; COMDAT (pick associative to section at A6C0)
.xdata$x:0000CEE0 __unwindtable$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z db 0FFh
.xdata$x:0000CEE0                                         ; DATA XREF: .xdata$x:0000CEF0o
.xdata$x:0000CEE1                 db 0FFh
.xdata$x:0000CEE2                 db 0FFh
.xdata$x:0000CEE3                 db 0FFh
.xdata$x:0000CEE4                 dd offset __unwindfunclet$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z$0
.xdata$x:0000CEE8 __ehfuncinfo$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z db  22h ; "
.xdata$x:0000CEE8                                         ; DATA XREF: __ehhandler$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z+11o
.xdata$x:0000CEE9                 db    5
.xdata$x:0000CEEA                 db  93h ; 
.xdata$x:0000CEEB                 db  19h
.xdata$x:0000CEEC                 db    1
.xdata$x:0000CEED                 db    0
.xdata$x:0000CEEE                 db    0
.xdata$x:0000CEEF                 db    0
.xdata$x:0000CEF0                 dd offset __unwindtable$?construct@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@ABV3@@Z
.xdata$x:0000CEF4                 db    0
.xdata$x:0000CEF5                 db    0
.xdata$x:0000CEF6                 db    0
.xdata$x:0000CEF7                 db    0
.xdata$x:0000CEF8                 db    0
.xdata$x:0000CEF9                 db    0
.xdata$x:0000CEFA                 db    0
.xdata$x:0000CEFB                 db    0
.xdata$x:0000CEFC                 db    0
.xdata$x:0000CEFD                 db    0
.xdata$x:0000CEFE                 db    0
.xdata$x:0000CEFF                 db    0
.xdata$x:0000CF00                 db    0
.xdata$x:0000CF01                 db    0
.xdata$x:0000CF02                 db    0
.xdata$x:0000CF03                 db    0
.xdata$x:0000CF04                 db    0
.xdata$x:0000CF05                 db    0
.xdata$x:0000CF06                 db    0
.xdata$x:0000CF07                 db    0
.xdata$x:0000CF08                 db    0
.xdata$x:0000CF09                 db    0
.xdata$x:0000CF0A                 db    0
.xdata$x:0000CF0B                 db    0
.xdata$x:0000CF0B _xdata$x        ends
.xdata$x:0000CF0B
.xdata$x:0000CF0C ; ===========================================================================
.xdata$x:0000CF0C
.xdata$x:0000CF0C ; Segment type: Pure data
.xdata$x:0000CF0C ; Segment permissions: Read
.xdata$x:0000CF0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CF0C                 assume cs:_xdata$x
.xdata$x:0000CF0C                 ;org 0CF0Ch
.xdata$x:0000CF0C ; COMDAT (pick associative to section at 93D0)
.xdata$x:0000CF0C __catchsym$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000CF0C                                         ; DATA XREF: .xdata$x:0000CF3Co
.xdata$x:0000CF0D                 db    0
.xdata$x:0000CF0E                 db    0
.xdata$x:0000CF0F                 db    0
.xdata$x:0000CF10                 db    0
.xdata$x:0000CF11                 db    0
.xdata$x:0000CF12                 db    0
.xdata$x:0000CF13                 db    0
.xdata$x:0000CF14                 db    0
.xdata$x:0000CF15                 db    0
.xdata$x:0000CF16                 db    0
.xdata$x:0000CF17                 db    0
.xdata$x:0000CF18                 dd offset __catch$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z$0
.xdata$x:0000CF1C __unwindtable$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000CF1C                                         ; DATA XREF: .xdata$x:0000CF48o
.xdata$x:0000CF1D                 db 0FFh
.xdata$x:0000CF1E                 db 0FFh
.xdata$x:0000CF1F                 db 0FFh
.xdata$x:0000CF20                 db    0
.xdata$x:0000CF21                 db    0
.xdata$x:0000CF22                 db    0
.xdata$x:0000CF23                 db    0
.xdata$x:0000CF24                 db 0FFh
.xdata$x:0000CF25                 db 0FFh
.xdata$x:0000CF26                 db 0FFh
.xdata$x:0000CF27                 db 0FFh
.xdata$x:0000CF28                 db    0
.xdata$x:0000CF29                 db    0
.xdata$x:0000CF2A                 db    0
.xdata$x:0000CF2B                 db    0
.xdata$x:0000CF2C __tryblocktable$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z db    0
.xdata$x:0000CF2C                                         ; DATA XREF: .xdata$x:0000CF50o
.xdata$x:0000CF2D                 db    0
.xdata$x:0000CF2E                 db    0
.xdata$x:0000CF2F                 db    0
.xdata$x:0000CF30                 db    0
.xdata$x:0000CF31                 db    0
.xdata$x:0000CF32                 db    0
.xdata$x:0000CF33                 db    0
.xdata$x:0000CF34                 db    1
.xdata$x:0000CF35                 db    0
.xdata$x:0000CF36                 db    0
.xdata$x:0000CF37                 db    0
.xdata$x:0000CF38                 db    1
.xdata$x:0000CF39                 db    0
.xdata$x:0000CF3A                 db    0
.xdata$x:0000CF3B                 db    0
.xdata$x:0000CF3C                 dd offset __catchsym$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z$2
.xdata$x:0000CF40 __ehfuncinfo$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000CF40                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z+11o
.xdata$x:0000CF41                 db    5
.xdata$x:0000CF42                 db  93h ; 
.xdata$x:0000CF43                 db  19h
.xdata$x:0000CF44                 db    2
.xdata$x:0000CF45                 db    0
.xdata$x:0000CF46                 db    0
.xdata$x:0000CF47                 db    0
.xdata$x:0000CF48                 dd offset __unwindtable$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z
.xdata$x:0000CF4C                 db    1
.xdata$x:0000CF4D                 db    0
.xdata$x:0000CF4E                 db    0
.xdata$x:0000CF4F                 db    0
.xdata$x:0000CF50                 dd offset __tryblocktable$?_Reallocate@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IAEXI@Z
.xdata$x:0000CF54                 db    0
.xdata$x:0000CF55                 db    0
.xdata$x:0000CF56                 db    0
.xdata$x:0000CF57                 db    0
.xdata$x:0000CF58                 db    0
.xdata$x:0000CF59                 db    0
.xdata$x:0000CF5A                 db    0
.xdata$x:0000CF5B                 db    0
.xdata$x:0000CF5C                 db    0
.xdata$x:0000CF5D                 db    0
.xdata$x:0000CF5E                 db    0
.xdata$x:0000CF5F                 db    0
.xdata$x:0000CF60                 db    0
.xdata$x:0000CF61                 db    0
.xdata$x:0000CF62                 db    0
.xdata$x:0000CF63                 db    0
.xdata$x:0000CF63 _xdata$x        ends
.xdata$x:0000CF63
.xdata$x:0000CF64 ; ===========================================================================
.xdata$x:0000CF64
.xdata$x:0000CF64 ; Segment type: Pure data
.xdata$x:0000CF64 ; Segment permissions: Read
.xdata$x:0000CF64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CF64                 assume cs:_xdata$x
.xdata$x:0000CF64                 ;org 0CF64h
.xdata$x:0000CF64 ; COMDAT (pick associative to section at 8C28)
.xdata$x:0000CF64 __unwindtable$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z db 0FFh
.xdata$x:0000CF64                                         ; DATA XREF: .xdata$x:0000CF74o
.xdata$x:0000CF65                 db 0FFh
.xdata$x:0000CF66                 db 0FFh
.xdata$x:0000CF67                 db 0FFh
.xdata$x:0000CF68                 dd offset __unwindfunclet$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z$0
.xdata$x:0000CF6C __ehfuncinfo$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z db  22h ; "
.xdata$x:0000CF6C                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z+11o
.xdata$x:0000CF6D                 db    5
.xdata$x:0000CF6E                 db  93h ; 
.xdata$x:0000CF6F                 db  19h
.xdata$x:0000CF70                 db    1
.xdata$x:0000CF71                 db    0
.xdata$x:0000CF72                 db    0
.xdata$x:0000CF73                 db    0
.xdata$x:0000CF74                 dd offset __unwindtable$?_Orphan_range@?$vector@VPluginCmdShortcut@@V?$allocator@VPluginCmdShortcut@@@std@@@std@@IBEXPAVPluginCmdShortcut@@0@Z
.xdata$x:0000CF78                 db    0
.xdata$x:0000CF79                 db    0
.xdata$x:0000CF7A                 db    0
.xdata$x:0000CF7B                 db    0
.xdata$x:0000CF7C                 db    0
.xdata$x:0000CF7D                 db    0
.xdata$x:0000CF7E                 db    0
.xdata$x:0000CF7F                 db    0
.xdata$x:0000CF80                 db    0
.xdata$x:0000CF81                 db    0
.xdata$x:0000CF82                 db    0
.xdata$x:0000CF83                 db    0
.xdata$x:0000CF84                 db    0
.xdata$x:0000CF85                 db    0
.xdata$x:0000CF86                 db    0
.xdata$x:0000CF87                 db    0
.xdata$x:0000CF88                 db    0
.xdata$x:0000CF89                 db    0
.xdata$x:0000CF8A                 db    0
.xdata$x:0000CF8B                 db    0
.xdata$x:0000CF8C                 db    0
.xdata$x:0000CF8D                 db    0
.xdata$x:0000CF8E                 db    0
.xdata$x:0000CF8F                 db    0
.xdata$x:0000CF8F _xdata$x        ends
.xdata$x:0000CF8F
.xdata$x:0000CF90 ; ===========================================================================
.xdata$x:0000CF90
.xdata$x:0000CF90 ; Segment type: Pure data
.xdata$x:0000CF90 ; Segment permissions: Read
.xdata$x:0000CF90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CF90                 assume cs:_xdata$x
.xdata$x:0000CF90                 ;org 0CF90h
.xdata$x:0000CF90 ; COMDAT (pick associative to section at 626C)
.xdata$x:0000CF90 __unwindtable$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z db 0FFh
.xdata$x:0000CF90                                         ; DATA XREF: .xdata$x:0000CFA0o
.xdata$x:0000CF91                 db 0FFh
.xdata$x:0000CF92                 db 0FFh
.xdata$x:0000CF93                 db 0FFh
.xdata$x:0000CF94                 dd offset __unwindfunclet$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z$0
.xdata$x:0000CF98 __ehfuncinfo$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z db  22h ; "
.xdata$x:0000CF98                                         ; DATA XREF: __ehhandler$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z+11o
.xdata$x:0000CF99                 db    5
.xdata$x:0000CF9A                 db  93h ; 
.xdata$x:0000CF9B                 db  19h
.xdata$x:0000CF9C                 db    1
.xdata$x:0000CF9D                 db    0
.xdata$x:0000CF9E                 db    0
.xdata$x:0000CF9F                 db    0
.xdata$x:0000CFA0                 dd offset __unwindtable$??0PluginCommand@@QAE@PB_WHP6AXXZ@Z
.xdata$x:0000CFA4                 db    0
.xdata$x:0000CFA5                 db    0
.xdata$x:0000CFA6                 db    0
.xdata$x:0000CFA7                 db    0
.xdata$x:0000CFA8                 db    0
.xdata$x:0000CFA9                 db    0
.xdata$x:0000CFAA                 db    0
.xdata$x:0000CFAB                 db    0
.xdata$x:0000CFAC                 db    0
.xdata$x:0000CFAD                 db    0
.xdata$x:0000CFAE                 db    0
.xdata$x:0000CFAF                 db    0
.xdata$x:0000CFB0                 db    0
.xdata$x:0000CFB1                 db    0
.xdata$x:0000CFB2                 db    0
.xdata$x:0000CFB3                 db    0
.xdata$x:0000CFB4                 db    0
.xdata$x:0000CFB5                 db    0
.xdata$x:0000CFB6                 db    0
.xdata$x:0000CFB7                 db    0
.xdata$x:0000CFB8                 db    0
.xdata$x:0000CFB9                 db    0
.xdata$x:0000CFBA                 db    0
.xdata$x:0000CFBB                 db    0
.xdata$x:0000CFBB _xdata$x        ends
.xdata$x:0000CFBB
.xdata$x:0000CFBC ; ===========================================================================
.xdata$x:0000CFBC
.xdata$x:0000CFBC ; Segment type: Pure data
.xdata$x:0000CFBC ; Segment permissions: Read
.xdata$x:0000CFBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CFBC                 assume cs:_xdata$x
.xdata$x:0000CFBC                 ;org 0CFBCh
.xdata$x:0000CFBC ; COMDAT (pick associative to section at 6DAC)
.xdata$x:0000CFBC __unwindtable$??1PluginCommand@@QAE@XZ db 0FFh
.xdata$x:0000CFBC                                         ; DATA XREF: .xdata$x:0000CFCCo
.xdata$x:0000CFBD                 db 0FFh
.xdata$x:0000CFBE                 db 0FFh
.xdata$x:0000CFBF                 db 0FFh
.xdata$x:0000CFC0                 dd offset __unwindfunclet$??1PluginCommand@@QAE@XZ$0
.xdata$x:0000CFC4 __ehfuncinfo$??1PluginCommand@@QAE@XZ db  22h ; "
.xdata$x:0000CFC4                                         ; DATA XREF: __ehhandler$??1PluginCommand@@QAE@XZ+11o
.xdata$x:0000CFC5                 db    5
.xdata$x:0000CFC6                 db  93h ; 
.xdata$x:0000CFC7                 db  19h
.xdata$x:0000CFC8                 db    1
.xdata$x:0000CFC9                 db    0
.xdata$x:0000CFCA                 db    0
.xdata$x:0000CFCB                 db    0
.xdata$x:0000CFCC                 dd offset __unwindtable$??1PluginCommand@@QAE@XZ
.xdata$x:0000CFD0                 db    0
.xdata$x:0000CFD1                 db    0
.xdata$x:0000CFD2                 db    0
.xdata$x:0000CFD3                 db    0
.xdata$x:0000CFD4                 db    0
.xdata$x:0000CFD5                 db    0
.xdata$x:0000CFD6                 db    0
.xdata$x:0000CFD7                 db    0
.xdata$x:0000CFD8                 db    0
.xdata$x:0000CFD9                 db    0
.xdata$x:0000CFDA                 db    0
.xdata$x:0000CFDB                 db    0
.xdata$x:0000CFDC                 db    0
.xdata$x:0000CFDD                 db    0
.xdata$x:0000CFDE                 db    0
.xdata$x:0000CFDF                 db    0
.xdata$x:0000CFE0                 db    0
.xdata$x:0000CFE1                 db    0
.xdata$x:0000CFE2                 db    0
.xdata$x:0000CFE3                 db    0
.xdata$x:0000CFE4                 db    0
.xdata$x:0000CFE5                 db    0
.xdata$x:0000CFE6                 db    0
.xdata$x:0000CFE7                 db    0
.xdata$x:0000CFE7 _xdata$x        ends
.xdata$x:0000CFE7
.xdata$x:0000CFE8 ; ===========================================================================
.xdata$x:0000CFE8
.xdata$x:0000CFE8 ; Segment type: Pure data
.xdata$x:0000CFE8 ; Segment permissions: Read
.xdata$x:0000CFE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000CFE8                 assume cs:_xdata$x
.xdata$x:0000CFE8                 ;org 0CFE8h
.xdata$x:0000CFE8 ; COMDAT (pick associative to section at 61DC)
.xdata$x:0000CFE8 __unwindtable$??0PluginCommand@@QAE@ABU0@@Z db 0FFh
.xdata$x:0000CFE8                                         ; DATA XREF: .xdata$x:0000CFF8o
.xdata$x:0000CFE9                 db 0FFh
.xdata$x:0000CFEA                 db 0FFh
.xdata$x:0000CFEB                 db 0FFh
.xdata$x:0000CFEC                 dd offset __unwindfunclet$??0PluginCommand@@QAE@ABU0@@Z$0
.xdata$x:0000CFF0 __ehfuncinfo$??0PluginCommand@@QAE@ABU0@@Z db  22h ; "
.xdata$x:0000CFF0                                         ; DATA XREF: __ehhandler$??0PluginCommand@@QAE@ABU0@@Z+11o
.xdata$x:0000CFF1                 db    5
.xdata$x:0000CFF2                 db  93h ; 
.xdata$x:0000CFF3                 db  19h
.xdata$x:0000CFF4                 db    1
.xdata$x:0000CFF5                 db    0
.xdata$x:0000CFF6                 db    0
.xdata$x:0000CFF7                 db    0
.xdata$x:0000CFF8                 dd offset __unwindtable$??0PluginCommand@@QAE@ABU0@@Z
.xdata$x:0000CFFC                 db    0
.xdata$x:0000CFFD                 db    0
.xdata$x:0000CFFE                 db    0
.xdata$x:0000CFFF                 db    0
.xdata$x:0000D000                 db    0
.xdata$x:0000D001                 db    0
.xdata$x:0000D002                 db    0
.xdata$x:0000D003                 db    0
.xdata$x:0000D004                 db    0
.xdata$x:0000D005                 db    0
.xdata$x:0000D006                 db    0
.xdata$x:0000D007                 db    0
.xdata$x:0000D008                 db    0
.xdata$x:0000D009                 db    0
.xdata$x:0000D00A                 db    0
.xdata$x:0000D00B                 db    0
.xdata$x:0000D00C                 db    0
.xdata$x:0000D00D                 db    0
.xdata$x:0000D00E                 db    0
.xdata$x:0000D00F                 db    0
.xdata$x:0000D010                 db    0
.xdata$x:0000D011                 db    0
.xdata$x:0000D012                 db    0
.xdata$x:0000D013                 db    0
.xdata$x:0000D013 _xdata$x        ends
.xdata$x:0000D013
.xdata$x:0000D014 ; ===========================================================================
.xdata$x:0000D014
.xdata$x:0000D014 ; Segment type: Pure data
.xdata$x:0000D014 ; Segment permissions: Read
.xdata$x:0000D014 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D014                 assume cs:_xdata$x
.xdata$x:0000D014                 ;org 0D014h
.xdata$x:0000D014 ; COMDAT (pick associative to section at 62F8)
.xdata$x:0000D014 __unwindtable$??0PluginInfo@@QAE@XZ db 0FFh
.xdata$x:0000D014                                         ; DATA XREF: .xdata$x:0000D024o
.xdata$x:0000D015                 db 0FFh
.xdata$x:0000D016                 db 0FFh
.xdata$x:0000D017                 db 0FFh
.xdata$x:0000D018                 dd offset __unwindfunclet$??0PluginInfo@@QAE@XZ$0
.xdata$x:0000D01C __ehfuncinfo$??0PluginInfo@@QAE@XZ db  22h ; "
.xdata$x:0000D01C                                         ; DATA XREF: __ehhandler$??0PluginInfo@@QAE@XZ+11o
.xdata$x:0000D01D                 db    5
.xdata$x:0000D01E                 db  93h ; 
.xdata$x:0000D01F                 db  19h
.xdata$x:0000D020                 db    1
.xdata$x:0000D021                 db    0
.xdata$x:0000D022                 db    0
.xdata$x:0000D023                 db    0
.xdata$x:0000D024                 dd offset __unwindtable$??0PluginInfo@@QAE@XZ
.xdata$x:0000D028                 align 20h
.xdata$x:0000D028 _xdata$x        ends
.xdata$x:0000D028
.xdata$x:0000D040 ; ===========================================================================
.xdata$x:0000D040
.xdata$x:0000D040 ; Segment type: Pure data
.xdata$x:0000D040 ; Segment permissions: Read
.xdata$x:0000D040 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D040                 assume cs:_xdata$x
.xdata$x:0000D040                 ;org 0D040h
.xdata$x:0000D040 ; COMDAT (pick associative to section at 6E1C)
.xdata$x:0000D040 __unwindtable$??1PluginInfo@@QAE@XZ db 0FFh
.xdata$x:0000D040                                         ; DATA XREF: .xdata$x:0000D050o
.xdata$x:0000D041                 db 0FFh
.xdata$x:0000D042                 db 0FFh
.xdata$x:0000D043                 db 0FFh
.xdata$x:0000D044                 dd offset __unwindfunclet$??1PluginInfo@@QAE@XZ$0
.xdata$x:0000D048 __ehfuncinfo$??1PluginInfo@@QAE@XZ db  22h ; "
.xdata$x:0000D048                                         ; DATA XREF: __ehhandler$??1PluginInfo@@QAE@XZ+11o
.xdata$x:0000D049                 db    5
.xdata$x:0000D04A                 db  93h ; 
.xdata$x:0000D04B                 db  19h
.xdata$x:0000D04C                 db    1
.xdata$x:0000D04D                 db    0
.xdata$x:0000D04E                 db    0
.xdata$x:0000D04F                 db    0
.xdata$x:0000D050                 dd offset __unwindtable$??1PluginInfo@@QAE@XZ
.xdata$x:0000D054                 db    0
.xdata$x:0000D055                 db    0
.xdata$x:0000D056                 db    0
.xdata$x:0000D057                 db    0
.xdata$x:0000D058                 db    0
.xdata$x:0000D059                 db    0
.xdata$x:0000D05A                 db    0
.xdata$x:0000D05B                 db    0
.xdata$x:0000D05C                 db    0
.xdata$x:0000D05D                 db    0
.xdata$x:0000D05E                 db    0
.xdata$x:0000D05F                 db    0
.xdata$x:0000D060                 db    0
.xdata$x:0000D061                 db    0
.xdata$x:0000D062                 db    0
.xdata$x:0000D063                 db    0
.xdata$x:0000D064                 db    0
.xdata$x:0000D065                 db    0
.xdata$x:0000D066                 db    0
.xdata$x:0000D067                 db    0
.xdata$x:0000D068                 db    0
.xdata$x:0000D069                 db    0
.xdata$x:0000D06A                 db    0
.xdata$x:0000D06B                 db    0
.xdata$x:0000D06B _xdata$x        ends
.xdata$x:0000D06B
.xdata$x:0000D06C ; ===========================================================================
.xdata$x:0000D06C
.xdata$x:0000D06C ; Segment type: Pure data
.xdata$x:0000D06C ; Segment permissions: Read
.xdata$x:0000D06C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D06C                 assume cs:_xdata$x
.xdata$x:0000D06C                 ;org 0D06Ch
.xdata$x:0000D06C __tryblocktable$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z db    0
.xdata$x:0000D06C                                         ; DATA XREF: .xdata$x:0000D20Co
.xdata$x:0000D06D                 db    0
.xdata$x:0000D06E                 db    0
.xdata$x:0000D06F                 db    0
.xdata$x:0000D070                 db    0
.xdata$x:0000D071                 db    0
.xdata$x:0000D072                 db    0
.xdata$x:0000D073                 db    0
.xdata$x:0000D074                 db    2
.xdata$x:0000D075                 db    0
.xdata$x:0000D076                 db    0
.xdata$x:0000D077                 db    0
.xdata$x:0000D078                 db    2
.xdata$x:0000D079                 db    0
.xdata$x:0000D07A                 db    0
.xdata$x:0000D07B                 db    0
.xdata$x:0000D07C                 dd offset __catchsym$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$4
.xdata$x:0000D080 __tryblocktable$?relayNppMessages@PluginsManager@@QAEXIIJ@Z db    0
.xdata$x:0000D080                                         ; DATA XREF: .xdata$x:0000D230o
.xdata$x:0000D081                 db    0
.xdata$x:0000D082                 db    0
.xdata$x:0000D083                 db    0
.xdata$x:0000D084                 db    0
.xdata$x:0000D085                 db    0
.xdata$x:0000D086                 db    0
.xdata$x:0000D087                 db    0
.xdata$x:0000D088                 db    2
.xdata$x:0000D089                 db    0
.xdata$x:0000D08A                 db    0
.xdata$x:0000D08B                 db    0
.xdata$x:0000D08C                 db    2
.xdata$x:0000D08D                 db    0
.xdata$x:0000D08E                 db    0
.xdata$x:0000D08F                 db    0
.xdata$x:0000D090                 dd offset __catchsym$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$4
.xdata$x:0000D094 __tryblocktable$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z db    0
.xdata$x:0000D094                                         ; DATA XREF: .xdata$x:0000D254o
.xdata$x:0000D095                 db    0
.xdata$x:0000D096                 db    0
.xdata$x:0000D097                 db    0
.xdata$x:0000D098                 db    0
.xdata$x:0000D099                 db    0
.xdata$x:0000D09A                 db    0
.xdata$x:0000D09B                 db    0
.xdata$x:0000D09C                 db    2
.xdata$x:0000D09D                 db    0
.xdata$x:0000D09E                 db    0
.xdata$x:0000D09F                 db    0
.xdata$x:0000D0A0                 db    2
.xdata$x:0000D0A1                 db    0
.xdata$x:0000D0A2                 db    0
.xdata$x:0000D0A3                 db    0
.xdata$x:0000D0A4                 dd offset __catchsym$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$4
.xdata$x:0000D0A8 __tryblocktable$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z db    0
.xdata$x:0000D0A8                                         ; DATA XREF: .xdata$x:0000D29Co
.xdata$x:0000D0A9                 db    0
.xdata$x:0000D0AA                 db    0
.xdata$x:0000D0AB                 db    0
.xdata$x:0000D0AC                 db    0
.xdata$x:0000D0AD                 db    0
.xdata$x:0000D0AE                 db    0
.xdata$x:0000D0AF                 db    0
.xdata$x:0000D0B0                 db    2
.xdata$x:0000D0B1                 db    0
.xdata$x:0000D0B2                 db    0
.xdata$x:0000D0B3                 db    0
.xdata$x:0000D0B4                 db    2
.xdata$x:0000D0B5                 db    0
.xdata$x:0000D0B6                 db    0
.xdata$x:0000D0B7                 db    0
.xdata$x:0000D0B8                 dd offset __catchsym$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$4
.xdata$x:0000D0BC __tryblocktable$?runPluginCommand@PluginsManager@@QAEXI@Z db    0
.xdata$x:0000D0BC                                         ; DATA XREF: .xdata$x:0000D2C0o
.xdata$x:0000D0BD                 db    0
.xdata$x:0000D0BE                 db    0
.xdata$x:0000D0BF                 db    0
.xdata$x:0000D0C0                 db    0
.xdata$x:0000D0C1                 db    0
.xdata$x:0000D0C2                 db    0
.xdata$x:0000D0C3                 db    0
.xdata$x:0000D0C4                 db    2
.xdata$x:0000D0C5                 db    0
.xdata$x:0000D0C6                 db    0
.xdata$x:0000D0C7                 db    0
.xdata$x:0000D0C8                 db    2
.xdata$x:0000D0C9                 db    0
.xdata$x:0000D0CA                 db    0
.xdata$x:0000D0CB                 db    0
.xdata$x:0000D0CC                 dd offset __catchsym$?runPluginCommand@PluginsManager@@QAEXI@Z$4
.xdata$x:0000D0D0 __tryblocktable$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z db    1
.xdata$x:0000D0D0                                         ; DATA XREF: .xdata$x:0000D308o
.xdata$x:0000D0D1                 db    0
.xdata$x:0000D0D2                 db    0
.xdata$x:0000D0D3                 db    0
.xdata$x:0000D0D4                 db    8
.xdata$x:0000D0D5                 db    0
.xdata$x:0000D0D6                 db    0
.xdata$x:0000D0D7                 db    0
.xdata$x:0000D0D8                 db  0Eh
.xdata$x:0000D0D9                 db    0
.xdata$x:0000D0DA                 db    0
.xdata$x:0000D0DB                 db    0
.xdata$x:0000D0DC                 db    3
.xdata$x:0000D0DD                 db    0
.xdata$x:0000D0DE                 db    0
.xdata$x:0000D0DF                 db    0
.xdata$x:0000D0E0                 dd offset __catchsym$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$17
.xdata$x:0000D0E4 __unwindtable$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z db 0FFh
.xdata$x:0000D0E4                                         ; DATA XREF: .xdata$x:0000D204o
.xdata$x:0000D0E5                 db 0FFh
.xdata$x:0000D0E6                 db 0FFh
.xdata$x:0000D0E7                 db 0FFh
.xdata$x:0000D0E8                 db    0
.xdata$x:0000D0E9                 db    0
.xdata$x:0000D0EA                 db    0
.xdata$x:0000D0EB                 db    0
.xdata$x:0000D0EC                 db 0FFh
.xdata$x:0000D0ED                 db 0FFh
.xdata$x:0000D0EE                 db 0FFh
.xdata$x:0000D0EF                 db 0FFh
.xdata$x:0000D0F0                 db    0
.xdata$x:0000D0F1                 db    0
.xdata$x:0000D0F2                 db    0
.xdata$x:0000D0F3                 db    0
.xdata$x:0000D0F4                 db    1
.xdata$x:0000D0F5                 db    0
.xdata$x:0000D0F6                 db    0
.xdata$x:0000D0F7                 db    0
.xdata$x:0000D0F8                 dd offset __unwindfunclet$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$3
.xdata$x:0000D0FC __unwindtable$?relayNppMessages@PluginsManager@@QAEXIIJ@Z db 0FFh
.xdata$x:0000D0FC                                         ; DATA XREF: .xdata$x:0000D228o
.xdata$x:0000D0FD                 db 0FFh
.xdata$x:0000D0FE                 db 0FFh
.xdata$x:0000D0FF                 db 0FFh
.xdata$x:0000D100                 db    0
.xdata$x:0000D101                 db    0
.xdata$x:0000D102                 db    0
.xdata$x:0000D103                 db    0
.xdata$x:0000D104                 db 0FFh
.xdata$x:0000D105                 db 0FFh
.xdata$x:0000D106                 db 0FFh
.xdata$x:0000D107                 db 0FFh
.xdata$x:0000D108                 db    0
.xdata$x:0000D109                 db    0
.xdata$x:0000D10A                 db    0
.xdata$x:0000D10B                 db    0
.xdata$x:0000D10C                 db    1
.xdata$x:0000D10D                 db    0
.xdata$x:0000D10E                 db    0
.xdata$x:0000D10F                 db    0
.xdata$x:0000D110                 dd offset __unwindfunclet$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$3
.xdata$x:0000D114 __unwindtable$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z db 0FFh
.xdata$x:0000D114                                         ; DATA XREF: .xdata$x:0000D24Co
.xdata$x:0000D115                 db 0FFh
.xdata$x:0000D116                 db 0FFh
.xdata$x:0000D117                 db 0FFh
.xdata$x:0000D118                 db    0
.xdata$x:0000D119                 db    0
.xdata$x:0000D11A                 db    0
.xdata$x:0000D11B                 db    0
.xdata$x:0000D11C                 db 0FFh
.xdata$x:0000D11D                 db 0FFh
.xdata$x:0000D11E                 db 0FFh
.xdata$x:0000D11F                 db 0FFh
.xdata$x:0000D120                 db    0
.xdata$x:0000D121                 db    0
.xdata$x:0000D122                 db    0
.xdata$x:0000D123                 db    0
.xdata$x:0000D124                 db    1
.xdata$x:0000D125                 db    0
.xdata$x:0000D126                 db    0
.xdata$x:0000D127                 db    0
.xdata$x:0000D128                 dd offset __unwindfunclet$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$3
.xdata$x:0000D12C __unwindtable$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z db 0FFh
.xdata$x:0000D12C                                         ; DATA XREF: .xdata$x:0000D294o
.xdata$x:0000D12D                 db 0FFh
.xdata$x:0000D12E                 db 0FFh
.xdata$x:0000D12F                 db 0FFh
.xdata$x:0000D130                 db    0
.xdata$x:0000D131                 db    0
.xdata$x:0000D132                 db    0
.xdata$x:0000D133                 db    0
.xdata$x:0000D134                 db 0FFh
.xdata$x:0000D135                 db 0FFh
.xdata$x:0000D136                 db 0FFh
.xdata$x:0000D137                 db 0FFh
.xdata$x:0000D138                 db    0
.xdata$x:0000D139                 db    0
.xdata$x:0000D13A                 db    0
.xdata$x:0000D13B                 db    0
.xdata$x:0000D13C                 db    1
.xdata$x:0000D13D                 db    0
.xdata$x:0000D13E                 db    0
.xdata$x:0000D13F                 db    0
.xdata$x:0000D140                 dd offset __unwindfunclet$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$3
.xdata$x:0000D144 __unwindtable$?runPluginCommand@PluginsManager@@QAEXI@Z db 0FFh
.xdata$x:0000D144                                         ; DATA XREF: .xdata$x:0000D2B8o
.xdata$x:0000D145                 db 0FFh
.xdata$x:0000D146                 db 0FFh
.xdata$x:0000D147                 db 0FFh
.xdata$x:0000D148                 db    0
.xdata$x:0000D149                 db    0
.xdata$x:0000D14A                 db    0
.xdata$x:0000D14B                 db    0
.xdata$x:0000D14C                 db 0FFh
.xdata$x:0000D14D                 db 0FFh
.xdata$x:0000D14E                 db 0FFh
.xdata$x:0000D14F                 db 0FFh
.xdata$x:0000D150                 db    0
.xdata$x:0000D151                 db    0
.xdata$x:0000D152                 db    0
.xdata$x:0000D153                 db    0
.xdata$x:0000D154                 db    1
.xdata$x:0000D155                 db    0
.xdata$x:0000D156                 db    0
.xdata$x:0000D157                 db    0
.xdata$x:0000D158                 dd offset __unwindfunclet$?runPluginCommand@PluginsManager@@QAEXI@Z$3
.xdata$x:0000D15C __catchsym$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$4 db    0
.xdata$x:0000D15C                                         ; DATA XREF: .xdata$x:0000D07Co
.xdata$x:0000D15D                 db    0
.xdata$x:0000D15E                 db    0
.xdata$x:0000D15F                 db    0
.xdata$x:0000D160                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:0000D164                 db 0D0h ; -
.xdata$x:0000D165                 db 0FEh ; 
.xdata$x:0000D166                 db 0FFh
.xdata$x:0000D167                 db 0FFh
.xdata$x:0000D168                 dd offset __catch$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$0
.xdata$x:0000D16C                 db    0
.xdata$x:0000D16D                 db    0
.xdata$x:0000D16E                 db    0
.xdata$x:0000D16F                 db    0
.xdata$x:0000D170                 db    0
.xdata$x:0000D171                 db    0
.xdata$x:0000D172                 db    0
.xdata$x:0000D173                 db    0
.xdata$x:0000D174                 db    0
.xdata$x:0000D175                 db    0
.xdata$x:0000D176                 db    0
.xdata$x:0000D177                 db    0
.xdata$x:0000D178                 dd offset __catch$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z$1
.xdata$x:0000D17C __catchsym$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$4 db    0
.xdata$x:0000D17C                                         ; DATA XREF: .xdata$x:0000D090o
.xdata$x:0000D17D                 db    0
.xdata$x:0000D17E                 db    0
.xdata$x:0000D17F                 db    0
.xdata$x:0000D180                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:0000D184                 db 0D4h ; +
.xdata$x:0000D185                 db 0FEh ; 
.xdata$x:0000D186                 db 0FFh
.xdata$x:0000D187                 db 0FFh
.xdata$x:0000D188                 dd offset __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$0
.xdata$x:0000D18C                 db    0
.xdata$x:0000D18D                 db    0
.xdata$x:0000D18E                 db    0
.xdata$x:0000D18F                 db    0
.xdata$x:0000D190                 db    0
.xdata$x:0000D191                 db    0
.xdata$x:0000D192                 db    0
.xdata$x:0000D193                 db    0
.xdata$x:0000D194                 db    0
.xdata$x:0000D195                 db    0
.xdata$x:0000D196                 db    0
.xdata$x:0000D197                 db    0
.xdata$x:0000D198                 dd offset __catch$?relayNppMessages@PluginsManager@@QAEXIIJ@Z$1
.xdata$x:0000D19C __catchsym$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$4 db    0
.xdata$x:0000D19C                                         ; DATA XREF: .xdata$x:0000D0A4o
.xdata$x:0000D19D                 db    0
.xdata$x:0000D19E                 db    0
.xdata$x:0000D19F                 db    0
.xdata$x:0000D1A0                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:0000D1A4                 db 0D4h ; +
.xdata$x:0000D1A5                 db 0FEh ; 
.xdata$x:0000D1A6                 db 0FFh
.xdata$x:0000D1A7                 db 0FFh
.xdata$x:0000D1A8                 dd offset __catch$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$0
.xdata$x:0000D1AC                 db    0
.xdata$x:0000D1AD                 db    0
.xdata$x:0000D1AE                 db    0
.xdata$x:0000D1AF                 db    0
.xdata$x:0000D1B0                 db    0
.xdata$x:0000D1B1                 db    0
.xdata$x:0000D1B2                 db    0
.xdata$x:0000D1B3                 db    0
.xdata$x:0000D1B4                 db    0
.xdata$x:0000D1B5                 db    0
.xdata$x:0000D1B6                 db    0
.xdata$x:0000D1B7                 db    0
.xdata$x:0000D1B8                 dd offset __catch$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z$1
.xdata$x:0000D1BC __catchsym$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$4 db    0
.xdata$x:0000D1BC                                         ; DATA XREF: .xdata$x:0000D0B8o
.xdata$x:0000D1BD                 db    0
.xdata$x:0000D1BE                 db    0
.xdata$x:0000D1BF                 db    0
.xdata$x:0000D1C0                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:0000D1C4                 db 0D4h ; +
.xdata$x:0000D1C5                 db 0FEh ; 
.xdata$x:0000D1C6                 db 0FFh
.xdata$x:0000D1C7                 db 0FFh
.xdata$x:0000D1C8                 dd offset __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$0
.xdata$x:0000D1CC                 db    0
.xdata$x:0000D1CD                 db    0
.xdata$x:0000D1CE                 db    0
.xdata$x:0000D1CF                 db    0
.xdata$x:0000D1D0                 db    0
.xdata$x:0000D1D1                 db    0
.xdata$x:0000D1D2                 db    0
.xdata$x:0000D1D3                 db    0
.xdata$x:0000D1D4                 db    0
.xdata$x:0000D1D5                 db    0
.xdata$x:0000D1D6                 db    0
.xdata$x:0000D1D7                 db    0
.xdata$x:0000D1D8                 dd offset __catch$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z$1
.xdata$x:0000D1DC __catchsym$?runPluginCommand@PluginsManager@@QAEXI@Z$4 db    0
.xdata$x:0000D1DC                                         ; DATA XREF: .xdata$x:0000D0CCo
.xdata$x:0000D1DD                 db    0
.xdata$x:0000D1DE                 db    0
.xdata$x:0000D1DF                 db    0
.xdata$x:0000D1E0                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:0000D1E4                 db 0DCh ; _
.xdata$x:0000D1E5                 db 0FEh ; 
.xdata$x:0000D1E6                 db 0FFh
.xdata$x:0000D1E7                 db 0FFh
.xdata$x:0000D1E8                 dd offset __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$0
.xdata$x:0000D1EC                 db    0
.xdata$x:0000D1ED                 db    0
.xdata$x:0000D1EE                 db    0
.xdata$x:0000D1EF                 db    0
.xdata$x:0000D1F0                 db    0
.xdata$x:0000D1F1                 db    0
.xdata$x:0000D1F2                 db    0
.xdata$x:0000D1F3                 db    0
.xdata$x:0000D1F4                 db    0
.xdata$x:0000D1F5                 db    0
.xdata$x:0000D1F6                 db    0
.xdata$x:0000D1F7                 db    0
.xdata$x:0000D1F8                 dd offset __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$1
.xdata$x:0000D1FC __ehfuncinfo$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z db  22h ; "
.xdata$x:0000D1FC                                         ; DATA XREF: __ehhandler$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z+1Eo
.xdata$x:0000D1FD                 db    5
.xdata$x:0000D1FE                 db  93h ; 
.xdata$x:0000D1FF                 db  19h
.xdata$x:0000D200                 db    3
.xdata$x:0000D201                 db    0
.xdata$x:0000D202                 db    0
.xdata$x:0000D203                 db    0
.xdata$x:0000D204                 dd offset __unwindtable$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z
.xdata$x:0000D208                 db    1
.xdata$x:0000D209                 db    0
.xdata$x:0000D20A                 db    0
.xdata$x:0000D20B                 db    0
.xdata$x:0000D20C                 dd offset __tryblocktable$?relayPluginMessages@PluginsManager@@QAE_NIIJ@Z
.xdata$x:0000D210                 align 20h
.xdata$x:0000D220 __ehfuncinfo$?relayNppMessages@PluginsManager@@QAEXIIJ@Z db  22h ; "
.xdata$x:0000D220                                         ; DATA XREF: __ehhandler$?relayNppMessages@PluginsManager@@QAEXIIJ@Z+1Eo
.xdata$x:0000D221                 db    5
.xdata$x:0000D222                 db  93h ; 
.xdata$x:0000D223                 db  19h
.xdata$x:0000D224                 db    3
.xdata$x:0000D225                 db    0
.xdata$x:0000D226                 db    0
.xdata$x:0000D227                 db    0
.xdata$x:0000D228                 dd offset __unwindtable$?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.xdata$x:0000D22C                 db    1
.xdata$x:0000D22D                 db    0
.xdata$x:0000D22E                 db    0
.xdata$x:0000D22F                 db    0
.xdata$x:0000D230                 dd offset __tryblocktable$?relayNppMessages@PluginsManager@@QAEXIIJ@Z
.xdata$x:0000D234                 db    0
.xdata$x:0000D235                 db    0
.xdata$x:0000D236                 db    0
.xdata$x:0000D237                 db    0
.xdata$x:0000D238                 db    0
.xdata$x:0000D239                 db    0
.xdata$x:0000D23A                 db    0
.xdata$x:0000D23B                 db    0
.xdata$x:0000D23C                 db    0
.xdata$x:0000D23D                 db    0
.xdata$x:0000D23E                 db    0
.xdata$x:0000D23F                 db    0
.xdata$x:0000D240                 db    0
.xdata$x:0000D241                 db    0
.xdata$x:0000D242                 db    0
.xdata$x:0000D243                 db    0
.xdata$x:0000D244 __ehfuncinfo$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z db  22h ; "
.xdata$x:0000D244                                         ; DATA XREF: __ehhandler$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z+1Eo
.xdata$x:0000D245                 db    5
.xdata$x:0000D246                 db  93h ; 
.xdata$x:0000D247                 db  19h
.xdata$x:0000D248                 db    3
.xdata$x:0000D249                 db    0
.xdata$x:0000D24A                 db    0
.xdata$x:0000D24B                 db    0
.xdata$x:0000D24C                 dd offset __unwindtable$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.xdata$x:0000D250                 db    1
.xdata$x:0000D251                 db    0
.xdata$x:0000D252                 db    0
.xdata$x:0000D253                 db    0
.xdata$x:0000D254                 dd offset __tryblocktable$?notify@PluginsManager@@QAEXPBUSCNotification@@@Z
.xdata$x:0000D258                 db    0
.xdata$x:0000D259                 db    0
.xdata$x:0000D25A                 db    0
.xdata$x:0000D25B                 db    0
.xdata$x:0000D25C                 db    0
.xdata$x:0000D25D                 db    0
.xdata$x:0000D25E                 db    0
.xdata$x:0000D25F                 db    0
.xdata$x:0000D260                 db    0
.xdata$x:0000D261                 db    0
.xdata$x:0000D262                 db    0
.xdata$x:0000D263                 db    0
.xdata$x:0000D264                 db    0
.xdata$x:0000D265                 db    0
.xdata$x:0000D266                 db    0
.xdata$x:0000D267                 db    0
.xdata$x:0000D268 __ehfuncinfo$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z db  22h ; "
.xdata$x:0000D268                                         ; DATA XREF: __ehhandler$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z+1Eo
.xdata$x:0000D269                 db    5
.xdata$x:0000D26A                 db  93h ; 
.xdata$x:0000D26B                 db  19h
.xdata$x:0000D26C                 db    8
.xdata$x:0000D26D                 db    0
.xdata$x:0000D26E                 db    0
.xdata$x:0000D26F                 db    0
.xdata$x:0000D270                 dd offset __unwindtable$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z
.xdata$x:0000D274                 db    0
.xdata$x:0000D275                 db    0
.xdata$x:0000D276                 db    0
.xdata$x:0000D277                 db    0
.xdata$x:0000D278                 db    0
.xdata$x:0000D279                 db    0
.xdata$x:0000D27A                 db    0
.xdata$x:0000D27B                 db    0
.xdata$x:0000D27C                 db    0
.xdata$x:0000D27D                 db    0
.xdata$x:0000D27E                 db    0
.xdata$x:0000D27F                 db    0
.xdata$x:0000D280                 db    0
.xdata$x:0000D281                 db    0
.xdata$x:0000D282                 db    0
.xdata$x:0000D283                 db    0
.xdata$x:0000D284                 db    0
.xdata$x:0000D285                 db    0
.xdata$x:0000D286                 db    0
.xdata$x:0000D287                 db    0
.xdata$x:0000D288                 db    0
.xdata$x:0000D289                 db    0
.xdata$x:0000D28A                 db    0
.xdata$x:0000D28B                 db    0
.xdata$x:0000D28C __ehfuncinfo$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z db  22h ; "
.xdata$x:0000D28C                                         ; DATA XREF: __ehhandler$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z+1Eo
.xdata$x:0000D28D                 db    5
.xdata$x:0000D28E                 db  93h ; 
.xdata$x:0000D28F                 db  19h
.xdata$x:0000D290                 db    3
.xdata$x:0000D291                 db    0
.xdata$x:0000D292                 db    0
.xdata$x:0000D293                 db    0
.xdata$x:0000D294                 dd offset __unwindtable$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.xdata$x:0000D298                 db    1
.xdata$x:0000D299                 db    0
.xdata$x:0000D29A                 db    0
.xdata$x:0000D29B                 db    0
.xdata$x:0000D29C                 dd offset __tryblocktable$?runPluginCommand@PluginsManager@@QAEXPB_WH@Z
.xdata$x:0000D2A0                 db    0
.xdata$x:0000D2A1                 db    0
.xdata$x:0000D2A2                 db    0
.xdata$x:0000D2A3                 db    0
.xdata$x:0000D2A4                 db    0
.xdata$x:0000D2A5                 db    0
.xdata$x:0000D2A6                 db    0
.xdata$x:0000D2A7                 db    0
.xdata$x:0000D2A8                 db    0
.xdata$x:0000D2A9                 db    0
.xdata$x:0000D2AA                 db    0
.xdata$x:0000D2AB                 db    0
.xdata$x:0000D2AC                 db    0
.xdata$x:0000D2AD                 db    0
.xdata$x:0000D2AE                 db    0
.xdata$x:0000D2AF                 db    0
.xdata$x:0000D2B0 __ehfuncinfo$?runPluginCommand@PluginsManager@@QAEXI@Z db  22h ; "
.xdata$x:0000D2B0                                         ; DATA XREF: __ehhandler$?runPluginCommand@PluginsManager@@QAEXI@Z+1Eo
.xdata$x:0000D2B1                 db    5
.xdata$x:0000D2B2                 db  93h ; 
.xdata$x:0000D2B3                 db  19h
.xdata$x:0000D2B4                 db    3
.xdata$x:0000D2B5                 db    0
.xdata$x:0000D2B6                 db    0
.xdata$x:0000D2B7                 db    0
.xdata$x:0000D2B8                 dd offset __unwindtable$?runPluginCommand@PluginsManager@@QAEXI@Z
.xdata$x:0000D2BC                 db    1
.xdata$x:0000D2BD                 db    0
.xdata$x:0000D2BE                 db    0
.xdata$x:0000D2BF                 db    0
.xdata$x:0000D2C0                 dd offset __tryblocktable$?runPluginCommand@PluginsManager@@QAEXI@Z
.xdata$x:0000D2C4                 db    0
.xdata$x:0000D2C5                 db    0
.xdata$x:0000D2C6                 db    0
.xdata$x:0000D2C7                 db    0
.xdata$x:0000D2C8                 db    0
.xdata$x:0000D2C9                 db    0
.xdata$x:0000D2CA                 db    0
.xdata$x:0000D2CB                 db    0
.xdata$x:0000D2CC                 db    0
.xdata$x:0000D2CD                 db    0
.xdata$x:0000D2CE                 db    0
.xdata$x:0000D2CF                 db    0
.xdata$x:0000D2D0                 db    0
.xdata$x:0000D2D1                 db    0
.xdata$x:0000D2D2                 db    0
.xdata$x:0000D2D3                 db    0
.xdata$x:0000D2D4 __ehfuncinfo$?loadPlugins@PluginsManager@@QAE_NPB_W@Z db  22h ; "
.xdata$x:0000D2D4                                         ; DATA XREF: __ehhandler$?loadPlugins@PluginsManager@@QAE_NPB_W@Z+1Eo
.xdata$x:0000D2D5                 db    5
.xdata$x:0000D2D6                 db  93h ; 
.xdata$x:0000D2D7                 db  19h
.xdata$x:0000D2D8                 db  13h
.xdata$x:0000D2D9                 db    0
.xdata$x:0000D2DA                 db    0
.xdata$x:0000D2DB                 db    0
.xdata$x:0000D2DC                 dd offset __unwindtable$?loadPlugins@PluginsManager@@QAE_NPB_W@Z
.xdata$x:0000D2E0                 db    0
.xdata$x:0000D2E1                 db    0
.xdata$x:0000D2E2                 db    0
.xdata$x:0000D2E3                 db    0
.xdata$x:0000D2E4                 db    0
.xdata$x:0000D2E5                 db    0
.xdata$x:0000D2E6                 db    0
.xdata$x:0000D2E7                 db    0
.xdata$x:0000D2E8                 db    0
.xdata$x:0000D2E9                 db    0
.xdata$x:0000D2EA                 db    0
.xdata$x:0000D2EB                 db    0
.xdata$x:0000D2EC                 db    0
.xdata$x:0000D2ED                 db    0
.xdata$x:0000D2EE                 db    0
.xdata$x:0000D2EF                 db    0
.xdata$x:0000D2F0                 db    0
.xdata$x:0000D2F1                 db    0
.xdata$x:0000D2F2                 db    0
.xdata$x:0000D2F3                 db    0
.xdata$x:0000D2F4                 db    0
.xdata$x:0000D2F5                 db    0
.xdata$x:0000D2F6                 db    0
.xdata$x:0000D2F7                 db    0
.xdata$x:0000D2F8 __ehfuncinfo$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z db  22h ; "
.xdata$x:0000D2F8                                         ; DATA XREF: __ehhandler$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z+1Eo
.xdata$x:0000D2F9                 db    5
.xdata$x:0000D2FA                 db  93h ; 
.xdata$x:0000D2FB                 db  19h
.xdata$x:0000D2FC                 db  0Fh
.xdata$x:0000D2FD                 db    0
.xdata$x:0000D2FE                 db    0
.xdata$x:0000D2FF                 db    0
.xdata$x:0000D300                 dd offset __unwindtable$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z
.xdata$x:0000D304                 db    1
.xdata$x:0000D305                 db    0
.xdata$x:0000D306                 db    0
.xdata$x:0000D307                 db    0
.xdata$x:0000D308                 dd offset __tryblocktable$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z
.xdata$x:0000D30C                 db    0
.xdata$x:0000D30D                 db    0
.xdata$x:0000D30E                 db    0
.xdata$x:0000D30F                 db    0
.xdata$x:0000D310                 db    0
.xdata$x:0000D311                 db    0
.xdata$x:0000D312                 db    0
.xdata$x:0000D313                 db    0
.xdata$x:0000D314                 db    0
.xdata$x:0000D315                 db    0
.xdata$x:0000D316                 db    0
.xdata$x:0000D317                 db    0
.xdata$x:0000D318                 db    0
.xdata$x:0000D319                 db    0
.xdata$x:0000D31A                 db    0
.xdata$x:0000D31B                 db    0
.xdata$x:0000D31C __catchsym$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$17 db    0
.xdata$x:0000D31C                                         ; DATA XREF: .xdata$x:0000D0E0o
.xdata$x:0000D31D                 db    0
.xdata$x:0000D31E                 db    0
.xdata$x:0000D31F                 db    0
.xdata$x:0000D320                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:0000D324                 db    8
.xdata$x:0000D325                 db 0FAh ; 
.xdata$x:0000D326                 db 0FFh
.xdata$x:0000D327                 db 0FFh
.xdata$x:0000D328                 dd offset __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$0
.xdata$x:0000D32C                 align 10h
.xdata$x:0000D330                 dd offset ??_R0?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> `RTTI Type Descriptor'
.xdata$x:0000D334                 db 0E4h ; S
.xdata$x:0000D335                 db 0FCh ; n
.xdata$x:0000D336                 db 0FFh
.xdata$x:0000D337                 db 0FFh
.xdata$x:0000D338                 dd offset __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1
.xdata$x:0000D33C                 db    0
.xdata$x:0000D33D                 db    0
.xdata$x:0000D33E                 db    0
.xdata$x:0000D33F                 db    0
.xdata$x:0000D340                 db    0
.xdata$x:0000D341                 db    0
.xdata$x:0000D342                 db    0
.xdata$x:0000D343                 db    0
.xdata$x:0000D344                 db    0
.xdata$x:0000D345                 db    0
.xdata$x:0000D346                 db    0
.xdata$x:0000D347                 db    0
.xdata$x:0000D348                 dd offset __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2
.xdata$x:0000D34C __unwindtable$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z db 0FFh
.xdata$x:0000D34C                                         ; DATA XREF: .xdata$x:0000D270o
.xdata$x:0000D34D                 db 0FFh
.xdata$x:0000D34E                 db 0FFh
.xdata$x:0000D34F                 db 0FFh
.xdata$x:0000D350                 dd offset __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$0
.xdata$x:0000D354                 db 0FFh
.xdata$x:0000D355                 db 0FFh
.xdata$x:0000D356                 db 0FFh
.xdata$x:0000D357                 db 0FFh
.xdata$x:0000D358                 dd offset __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$1
.xdata$x:0000D35C                 db    1
.xdata$x:0000D35D                 db    0
.xdata$x:0000D35E                 db    0
.xdata$x:0000D35F                 db    0
.xdata$x:0000D360                 dd offset __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$2
.xdata$x:0000D364                 db    1
.xdata$x:0000D365                 db    0
.xdata$x:0000D366                 db    0
.xdata$x:0000D367                 db    0
.xdata$x:0000D368                 dd offset __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$3
.xdata$x:0000D36C                 db    3
.xdata$x:0000D36D                 db    0
.xdata$x:0000D36E                 db    0
.xdata$x:0000D36F                 db    0
.xdata$x:0000D370                 dd offset __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$4
.xdata$x:0000D374                 db    1
.xdata$x:0000D375                 db    0
.xdata$x:0000D376                 db    0
.xdata$x:0000D377                 db    0
.xdata$x:0000D378                 dd offset __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$5
.xdata$x:0000D37C                 db    5
.xdata$x:0000D37D                 db    0
.xdata$x:0000D37E                 db    0
.xdata$x:0000D37F                 db    0
.xdata$x:0000D380                 dd offset __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$6
.xdata$x:0000D384                 db    5
.xdata$x:0000D385                 db    0
.xdata$x:0000D386                 db    0
.xdata$x:0000D387                 db    0
.xdata$x:0000D388                 dd offset __unwindfunclet$?addInMenuFromPMIndex@PluginsManager@@QAEXH@Z$7
.xdata$x:0000D38C __unwindtable$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z db 0FFh
.xdata$x:0000D38C                                         ; DATA XREF: .xdata$x:0000D300o
.xdata$x:0000D38D                 db 0FFh
.xdata$x:0000D38E                 db 0FFh
.xdata$x:0000D38F                 db 0FFh
.xdata$x:0000D390                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$4
.xdata$x:0000D394                 db 0FFh
.xdata$x:0000D395                 db 0FFh
.xdata$x:0000D396                 db 0FFh
.xdata$x:0000D397                 db 0FFh
.xdata$x:0000D398                 db    0
.xdata$x:0000D399                 db    0
.xdata$x:0000D39A                 db    0
.xdata$x:0000D39B                 db    0
.xdata$x:0000D39C                 db    1
.xdata$x:0000D39D                 db    0
.xdata$x:0000D39E                 db    0
.xdata$x:0000D39F                 db    0
.xdata$x:0000D3A0                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$5
.xdata$x:0000D3A4                 db    1
.xdata$x:0000D3A5                 db    0
.xdata$x:0000D3A6                 db    0
.xdata$x:0000D3A7                 db    0
.xdata$x:0000D3A8                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$6
.xdata$x:0000D3AC                 db    1
.xdata$x:0000D3AD                 db    0
.xdata$x:0000D3AE                 db    0
.xdata$x:0000D3AF                 db    0
.xdata$x:0000D3B0                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$7
.xdata$x:0000D3B4                 db    4
.xdata$x:0000D3B5                 db    0
.xdata$x:0000D3B6                 db    0
.xdata$x:0000D3B7                 db    0
.xdata$x:0000D3B8                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$8
.xdata$x:0000D3BC                 db    1
.xdata$x:0000D3BD                 db    0
.xdata$x:0000D3BE                 db    0
.xdata$x:0000D3BF                 db    0
.xdata$x:0000D3C0                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$9
.xdata$x:0000D3C4                 db    1
.xdata$x:0000D3C5                 db    0
.xdata$x:0000D3C6                 db    0
.xdata$x:0000D3C7                 db    0
.xdata$x:0000D3C8                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$10
.xdata$x:0000D3CC                 db    7
.xdata$x:0000D3CD                 db    0
.xdata$x:0000D3CE                 db    0
.xdata$x:0000D3CF                 db    0
.xdata$x:0000D3D0                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$11
.xdata$x:0000D3D4                 db 0FFh
.xdata$x:0000D3D5                 db 0FFh
.xdata$x:0000D3D6                 db 0FFh
.xdata$x:0000D3D7                 db 0FFh
.xdata$x:0000D3D8                 db    0
.xdata$x:0000D3D9                 db    0
.xdata$x:0000D3DA                 db    0
.xdata$x:0000D3DB                 db    0
.xdata$x:0000D3DC                 db    9
.xdata$x:0000D3DD                 db    0
.xdata$x:0000D3DE                 db    0
.xdata$x:0000D3DF                 db    0
.xdata$x:0000D3E0                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$12
.xdata$x:0000D3E4                 db    9
.xdata$x:0000D3E5                 db    0
.xdata$x:0000D3E6                 db    0
.xdata$x:0000D3E7                 db    0
.xdata$x:0000D3E8                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$13
.xdata$x:0000D3EC                 db  0Bh
.xdata$x:0000D3ED                 db    0
.xdata$x:0000D3EE                 db    0
.xdata$x:0000D3EF                 db    0
.xdata$x:0000D3F0                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$14
.xdata$x:0000D3F4                 db    9
.xdata$x:0000D3F5                 db    0
.xdata$x:0000D3F6                 db    0
.xdata$x:0000D3F7                 db    0
.xdata$x:0000D3F8                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$15
.xdata$x:0000D3FC                 db  0Dh
.xdata$x:0000D3FD                 db    0
.xdata$x:0000D3FE                 db    0
.xdata$x:0000D3FF                 db    0
.xdata$x:0000D400                 dd offset __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$16
.xdata$x:0000D404 __unwindtable$?loadPlugins@PluginsManager@@QAE_NPB_W@Z db 0FFh
.xdata$x:0000D404                                         ; DATA XREF: .xdata$x:0000D2DCo
.xdata$x:0000D405                 db 0FFh
.xdata$x:0000D406                 db 0FFh
.xdata$x:0000D407                 db 0FFh
.xdata$x:0000D408                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$0
.xdata$x:0000D40C                 align 10h
.xdata$x:0000D410                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$1
.xdata$x:0000D414                 db    1
.xdata$x:0000D415                 db    0
.xdata$x:0000D416                 db    0
.xdata$x:0000D417                 db    0
.xdata$x:0000D418                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$2
.xdata$x:0000D41C                 db    2
.xdata$x:0000D41D                 db    0
.xdata$x:0000D41E                 db    0
.xdata$x:0000D41F                 db    0
.xdata$x:0000D420                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$3
.xdata$x:0000D424                 db    3
.xdata$x:0000D425                 db    0
.xdata$x:0000D426                 db    0
.xdata$x:0000D427                 db    0
.xdata$x:0000D428                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$4
.xdata$x:0000D42C                 db    4
.xdata$x:0000D42D                 db    0
.xdata$x:0000D42E                 db    0
.xdata$x:0000D42F                 db    0
.xdata$x:0000D430                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$5
.xdata$x:0000D434                 db    3
.xdata$x:0000D435                 db    0
.xdata$x:0000D436                 db    0
.xdata$x:0000D437                 db    0
.xdata$x:0000D438                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$5
.xdata$x:0000D43C                 db    2
.xdata$x:0000D43D                 db    0
.xdata$x:0000D43E                 db    0
.xdata$x:0000D43F                 db    0
.xdata$x:0000D440                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$5
.xdata$x:0000D444                 db    7
.xdata$x:0000D445                 db    0
.xdata$x:0000D446                 db    0
.xdata$x:0000D447                 db    0
.xdata$x:0000D448                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$6
.xdata$x:0000D44C                 db    8
.xdata$x:0000D44D                 db    0
.xdata$x:0000D44E                 db    0
.xdata$x:0000D44F                 db    0
.xdata$x:0000D450                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$7
.xdata$x:0000D454                 db    9
.xdata$x:0000D455                 db    0
.xdata$x:0000D456                 db    0
.xdata$x:0000D457                 db    0
.xdata$x:0000D458                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$8
.xdata$x:0000D45C                 db    8
.xdata$x:0000D45D                 db    0
.xdata$x:0000D45E                 db    0
.xdata$x:0000D45F                 db    0
.xdata$x:0000D460                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$8
.xdata$x:0000D464                 db    7
.xdata$x:0000D465                 db    0
.xdata$x:0000D466                 db    0
.xdata$x:0000D467                 db    0
.xdata$x:0000D468                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$8
.xdata$x:0000D46C                 db  0Ch
.xdata$x:0000D46D                 db    0
.xdata$x:0000D46E                 db    0
.xdata$x:0000D46F                 db    0
.xdata$x:0000D470                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$9
.xdata$x:0000D474                 db  0Dh
.xdata$x:0000D475                 db    0
.xdata$x:0000D476                 db    0
.xdata$x:0000D477                 db    0
.xdata$x:0000D478                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$10
.xdata$x:0000D47C                 db  0Eh
.xdata$x:0000D47D                 db    0
.xdata$x:0000D47E                 db    0
.xdata$x:0000D47F                 db    0
.xdata$x:0000D480                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$11
.xdata$x:0000D484                 db  0Dh
.xdata$x:0000D485                 db    0
.xdata$x:0000D486                 db    0
.xdata$x:0000D487                 db    0
.xdata$x:0000D488                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$11
.xdata$x:0000D48C                 db  0Ch
.xdata$x:0000D48D                 db    0
.xdata$x:0000D48E                 db    0
.xdata$x:0000D48F                 db    0
.xdata$x:0000D490                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$11
.xdata$x:0000D494                 db  0Ch
.xdata$x:0000D495                 db    0
.xdata$x:0000D496                 db    0
.xdata$x:0000D497                 db    0
.xdata$x:0000D498                 dd offset __unwindfunclet$?loadPlugins@PluginsManager@@QAE_NPB_W@Z$12
.xdata$x:0000D498 _xdata$x        ends
.xdata$x:0000D498
.xdata$x:0000D49C ; ===========================================================================
.xdata$x:0000D49C
.xdata$x:0000D49C ; Segment type: Pure data
.xdata$x:0000D49C ; Segment permissions: Read
.xdata$x:0000D49C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D49C                 assume cs:_xdata$x
.xdata$x:0000D49C                 ;org 0D49Ch
.xdata$x:0000D49C ; COMDAT (pick associative to section at 8D04)
.xdata$x:0000D49C __catchsym$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000D49C                                         ; DATA XREF: .xdata$x:0000D4CCo
.xdata$x:0000D49D                 db    0
.xdata$x:0000D49E                 db    0
.xdata$x:0000D49F                 db    0
.xdata$x:0000D4A0                 db    0
.xdata$x:0000D4A1                 db    0
.xdata$x:0000D4A2                 db    0
.xdata$x:0000D4A3                 db    0
.xdata$x:0000D4A4                 db    0
.xdata$x:0000D4A5                 db    0
.xdata$x:0000D4A6                 db    0
.xdata$x:0000D4A7                 db    0
.xdata$x:0000D4A8                 dd offset __catch$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z$0
.xdata$x:0000D4AC __unwindtable$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000D4AC                                         ; DATA XREF: .xdata$x:0000D4D8o
.xdata$x:0000D4AD                 db 0FFh
.xdata$x:0000D4AE                 db 0FFh
.xdata$x:0000D4AF                 db 0FFh
.xdata$x:0000D4B0                 db    0
.xdata$x:0000D4B1                 db    0
.xdata$x:0000D4B2                 db    0
.xdata$x:0000D4B3                 db    0
.xdata$x:0000D4B4                 db 0FFh
.xdata$x:0000D4B5                 db 0FFh
.xdata$x:0000D4B6                 db 0FFh
.xdata$x:0000D4B7                 db 0FFh
.xdata$x:0000D4B8                 db    0
.xdata$x:0000D4B9                 db    0
.xdata$x:0000D4BA                 db    0
.xdata$x:0000D4BB                 db    0
.xdata$x:0000D4BC __tryblocktable$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z db    0
.xdata$x:0000D4BC                                         ; DATA XREF: .xdata$x:0000D4E0o
.xdata$x:0000D4BD                 db    0
.xdata$x:0000D4BE                 db    0
.xdata$x:0000D4BF                 db    0
.xdata$x:0000D4C0                 db    0
.xdata$x:0000D4C1                 db    0
.xdata$x:0000D4C2                 db    0
.xdata$x:0000D4C3                 db    0
.xdata$x:0000D4C4                 db    1
.xdata$x:0000D4C5                 db    0
.xdata$x:0000D4C6                 db    0
.xdata$x:0000D4C7                 db    0
.xdata$x:0000D4C8                 db    1
.xdata$x:0000D4C9                 db    0
.xdata$x:0000D4CA                 db    0
.xdata$x:0000D4CB                 db    0
.xdata$x:0000D4CC                 dd offset __catchsym$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z$2
.xdata$x:0000D4D0 __ehfuncinfo$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000D4D0                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z+11o
.xdata$x:0000D4D1                 db    5
.xdata$x:0000D4D2                 db  93h ; 
.xdata$x:0000D4D3                 db  19h
.xdata$x:0000D4D4                 db    2
.xdata$x:0000D4D5                 db    0
.xdata$x:0000D4D6                 db    0
.xdata$x:0000D4D7                 db    0
.xdata$x:0000D4D8                 dd offset __unwindtable$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z
.xdata$x:0000D4DC                 db    1
.xdata$x:0000D4DD                 db    0
.xdata$x:0000D4DE                 db    0
.xdata$x:0000D4DF                 db    0
.xdata$x:0000D4E0                 dd offset __tryblocktable$?_Reallocate@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IAEXI@Z
.xdata$x:0000D4E4                 db    0
.xdata$x:0000D4E5                 db    0
.xdata$x:0000D4E6                 db    0
.xdata$x:0000D4E7                 db    0
.xdata$x:0000D4E8                 db    0
.xdata$x:0000D4E9                 db    0
.xdata$x:0000D4EA                 db    0
.xdata$x:0000D4EB                 db    0
.xdata$x:0000D4EC                 db    0
.xdata$x:0000D4ED                 db    0
.xdata$x:0000D4EE                 db    0
.xdata$x:0000D4EF                 db    0
.xdata$x:0000D4F0                 db    0
.xdata$x:0000D4F1                 db    0
.xdata$x:0000D4F2                 db    0
.xdata$x:0000D4F3                 db    0
.xdata$x:0000D4F3 _xdata$x        ends
.xdata$x:0000D4F3
.xdata$x:0000D4F4 ; ===========================================================================
.xdata$x:0000D4F4
.xdata$x:0000D4F4 ; Segment type: Pure data
.xdata$x:0000D4F4 ; Segment permissions: Read
.xdata$x:0000D4F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D4F4                 assume cs:_xdata$x
.xdata$x:0000D4F4                 ;org 0D4F4h
.xdata$x:0000D4F4 ; COMDAT (pick associative to section at 87DC)
.xdata$x:0000D4F4 __unwindtable$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z db 0FFh
.xdata$x:0000D4F4                                         ; DATA XREF: .xdata$x:0000D504o
.xdata$x:0000D4F5                 db 0FFh
.xdata$x:0000D4F6                 db 0FFh
.xdata$x:0000D4F7                 db 0FFh
.xdata$x:0000D4F8                 dd offset __unwindfunclet$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z$0
.xdata$x:0000D4FC __ehfuncinfo$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z db  22h ; "
.xdata$x:0000D4FC                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z+11o
.xdata$x:0000D4FD                 db    5
.xdata$x:0000D4FE                 db  93h ; 
.xdata$x:0000D4FF                 db  19h
.xdata$x:0000D500                 db    1
.xdata$x:0000D501                 db    0
.xdata$x:0000D502                 db    0
.xdata$x:0000D503                 db    0
.xdata$x:0000D504                 dd offset __unwindtable$?_Orphan_range@?$vector@PAUPluginInfo@@V?$allocator@PAUPluginInfo@@@std@@@std@@IBEXPAPAUPluginInfo@@0@Z
.xdata$x:0000D508                 align 20h
.xdata$x:0000D508 _xdata$x        ends
.xdata$x:0000D508
.xdata$x:0000D520 ; ===========================================================================
.xdata$x:0000D520
.xdata$x:0000D520 ; Segment type: Pure data
.xdata$x:0000D520 ; Segment permissions: Read
.xdata$x:0000D520 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D520                 assume cs:_xdata$x
.xdata$x:0000D520                 ;org 0D520h
.xdata$x:0000D520 ; COMDAT (pick associative to section at 9118)
.xdata$x:0000D520 __catchsym$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000D520                                         ; DATA XREF: .xdata$x:0000D550o
.xdata$x:0000D521                 db    0
.xdata$x:0000D522                 db    0
.xdata$x:0000D523                 db    0
.xdata$x:0000D524                 db    0
.xdata$x:0000D525                 db    0
.xdata$x:0000D526                 db    0
.xdata$x:0000D527                 db    0
.xdata$x:0000D528                 db    0
.xdata$x:0000D529                 db    0
.xdata$x:0000D52A                 db    0
.xdata$x:0000D52B                 db    0
.xdata$x:0000D52C                 dd offset __catch$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z$0
.xdata$x:0000D530 __unwindtable$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000D530                                         ; DATA XREF: .xdata$x:0000D55Co
.xdata$x:0000D531                 db 0FFh
.xdata$x:0000D532                 db 0FFh
.xdata$x:0000D533                 db 0FFh
.xdata$x:0000D534                 db    0
.xdata$x:0000D535                 db    0
.xdata$x:0000D536                 db    0
.xdata$x:0000D537                 db    0
.xdata$x:0000D538                 db 0FFh
.xdata$x:0000D539                 db 0FFh
.xdata$x:0000D53A                 db 0FFh
.xdata$x:0000D53B                 db 0FFh
.xdata$x:0000D53C                 db    0
.xdata$x:0000D53D                 db    0
.xdata$x:0000D53E                 db    0
.xdata$x:0000D53F                 db    0
.xdata$x:0000D540 __tryblocktable$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z db    0
.xdata$x:0000D540                                         ; DATA XREF: .xdata$x:0000D564o
.xdata$x:0000D541                 db    0
.xdata$x:0000D542                 db    0
.xdata$x:0000D543                 db    0
.xdata$x:0000D544                 db    0
.xdata$x:0000D545                 db    0
.xdata$x:0000D546                 db    0
.xdata$x:0000D547                 db    0
.xdata$x:0000D548                 db    1
.xdata$x:0000D549                 db    0
.xdata$x:0000D54A                 db    0
.xdata$x:0000D54B                 db    0
.xdata$x:0000D54C                 db    1
.xdata$x:0000D54D                 db    0
.xdata$x:0000D54E                 db    0
.xdata$x:0000D54F                 db    0
.xdata$x:0000D550                 dd offset __catchsym$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z$2
.xdata$x:0000D554 __ehfuncinfo$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000D554                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z+11o
.xdata$x:0000D555                 db    5
.xdata$x:0000D556                 db  93h ; 
.xdata$x:0000D557                 db  19h
.xdata$x:0000D558                 db    2
.xdata$x:0000D559                 db    0
.xdata$x:0000D55A                 db    0
.xdata$x:0000D55B                 db    0
.xdata$x:0000D55C                 dd offset __unwindtable$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z
.xdata$x:0000D560                 db    1
.xdata$x:0000D561                 db    0
.xdata$x:0000D562                 db    0
.xdata$x:0000D563                 db    0
.xdata$x:0000D564                 dd offset __tryblocktable$?_Reallocate@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IAEXI@Z
.xdata$x:0000D568                 db    0
.xdata$x:0000D569                 db    0
.xdata$x:0000D56A                 db    0
.xdata$x:0000D56B                 db    0
.xdata$x:0000D56C                 db    0
.xdata$x:0000D56D                 db    0
.xdata$x:0000D56E                 db    0
.xdata$x:0000D56F                 db    0
.xdata$x:0000D570                 db    0
.xdata$x:0000D571                 db    0
.xdata$x:0000D572                 db    0
.xdata$x:0000D573                 db    0
.xdata$x:0000D574                 db    0
.xdata$x:0000D575                 db    0
.xdata$x:0000D576                 db    0
.xdata$x:0000D577                 db    0
.xdata$x:0000D577 _xdata$x        ends
.xdata$x:0000D577
.xdata$x:0000D578 ; ===========================================================================
.xdata$x:0000D578
.xdata$x:0000D578 ; Segment type: Pure data
.xdata$x:0000D578 ; Segment permissions: Read
.xdata$x:0000D578 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D578                 assume cs:_xdata$x
.xdata$x:0000D578                 ;org 0D578h
.xdata$x:0000D578 ; COMDAT (pick associative to section at 8A70)
.xdata$x:0000D578 __unwindtable$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z db 0FFh
.xdata$x:0000D578                                         ; DATA XREF: .xdata$x:0000D588o
.xdata$x:0000D579                 db 0FFh
.xdata$x:0000D57A                 db 0FFh
.xdata$x:0000D57B                 db 0FFh
.xdata$x:0000D57C                 dd offset __unwindfunclet$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z$0
.xdata$x:0000D580 __ehfuncinfo$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z db  22h ; "
.xdata$x:0000D580                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z+11o
.xdata$x:0000D581                 db    5
.xdata$x:0000D582                 db  93h ; 
.xdata$x:0000D583                 db  19h
.xdata$x:0000D584                 db    1
.xdata$x:0000D585                 db    0
.xdata$x:0000D586                 db    0
.xdata$x:0000D587                 db    0
.xdata$x:0000D588                 dd offset __unwindtable$?_Orphan_range@?$vector@UPluginCommand@@V?$allocator@UPluginCommand@@@std@@@std@@IBEXPAUPluginCommand@@0@Z
.xdata$x:0000D58C                 db    0
.xdata$x:0000D58D                 db    0
.xdata$x:0000D58E                 db    0
.xdata$x:0000D58F                 db    0
.xdata$x:0000D590                 db    0
.xdata$x:0000D591                 db    0
.xdata$x:0000D592                 db    0
.xdata$x:0000D593                 db    0
.xdata$x:0000D594                 db    0
.xdata$x:0000D595                 db    0
.xdata$x:0000D596                 db    0
.xdata$x:0000D597                 db    0
.xdata$x:0000D598                 db    0
.xdata$x:0000D599                 db    0
.xdata$x:0000D59A                 db    0
.xdata$x:0000D59B                 db    0
.xdata$x:0000D59C                 db    0
.xdata$x:0000D59D                 db    0
.xdata$x:0000D59E                 db    0
.xdata$x:0000D59F                 db    0
.xdata$x:0000D5A0                 db    0
.xdata$x:0000D5A1                 db    0
.xdata$x:0000D5A2                 db    0
.xdata$x:0000D5A3                 db    0
.xdata$x:0000D5A3 _xdata$x        ends
.xdata$x:0000D5A3
.xdata$x:0000D5A4 ; ===========================================================================
.xdata$x:0000D5A4
.xdata$x:0000D5A4 ; Segment type: Pure data
.xdata$x:0000D5A4 ; Segment permissions: Read
.xdata$x:0000D5A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D5A4                 assume cs:_xdata$x
.xdata$x:0000D5A4                 ;org 0D5A4h
.xdata$x:0000D5A4 ; COMDAT (pick associative to section at B81C)
.xdata$x:0000D5A4 __unwindtable$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z db 0FFh
.xdata$x:0000D5A4                                         ; DATA XREF: .xdata$x:0000D5B4o
.xdata$x:0000D5A5                 db 0FFh
.xdata$x:0000D5A6                 db 0FFh
.xdata$x:0000D5A7                 db 0FFh
.xdata$x:0000D5A8                 dd offset __unwindfunclet$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z$0
.xdata$x:0000D5AC __ehfuncinfo$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z db  22h ; "
.xdata$x:0000D5AC                                         ; DATA XREF: __ehhandler$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z+1Bo
.xdata$x:0000D5AD                 db    5
.xdata$x:0000D5AE                 db  93h ; 
.xdata$x:0000D5AF                 db  19h
.xdata$x:0000D5B0                 db    1
.xdata$x:0000D5B1                 db    0
.xdata$x:0000D5B2                 db    0
.xdata$x:0000D5B3                 db    0
.xdata$x:0000D5B4                 dd offset __unwindtable$?pluginCrashAlert@PluginsManager@@AAEXPB_W0@Z
.xdata$x:0000D5B8                 db    0
.xdata$x:0000D5B9                 db    0
.xdata$x:0000D5BA                 db    0
.xdata$x:0000D5BB                 db    0
.xdata$x:0000D5BC                 db    0
.xdata$x:0000D5BD                 db    0
.xdata$x:0000D5BE                 db    0
.xdata$x:0000D5BF                 db    0
.xdata$x:0000D5C0                 db    0
.xdata$x:0000D5C1                 db    0
.xdata$x:0000D5C2                 db    0
.xdata$x:0000D5C3                 db    0
.xdata$x:0000D5C4                 db    0
.xdata$x:0000D5C5                 db    0
.xdata$x:0000D5C6                 db    0
.xdata$x:0000D5C7                 db    0
.xdata$x:0000D5C8                 db    0
.xdata$x:0000D5C9                 db    0
.xdata$x:0000D5CA                 db    0
.xdata$x:0000D5CB                 db    0
.xdata$x:0000D5CC                 db    0
.xdata$x:0000D5CD                 db    0
.xdata$x:0000D5CE                 db    0
.xdata$x:0000D5CF                 db    0
.xdata$x:0000D5CF _xdata$x        ends
.xdata$x:0000D5CF
.xdata$x:0000D5D0 ; ===========================================================================
.xdata$x:0000D5D0
.xdata$x:0000D5D0 ; Segment type: Pure data
.xdata$x:0000D5D0 ; Segment permissions: Read
.xdata$x:0000D5D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D5D0                 assume cs:_xdata$x
.xdata$x:0000D5D0                 ;org 0D5D0h
.xdata$x:0000D5D0 ; COMDAT (pick associative to section at 9B94)
.xdata$x:0000D5D0 __unwindtable$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z db 0FFh
.xdata$x:0000D5D0                                         ; DATA XREF: .xdata$x:0000D5E0o
.xdata$x:0000D5D1                 db 0FFh
.xdata$x:0000D5D2                 db 0FFh
.xdata$x:0000D5D3                 db 0FFh
.xdata$x:0000D5D4                 dd offset __unwindfunclet$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z$0
.xdata$x:0000D5D8 __ehfuncinfo$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z db  22h ; "
.xdata$x:0000D5D8                                         ; DATA XREF: __ehhandler$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z+1Bo
.xdata$x:0000D5D9                 db    5
.xdata$x:0000D5DA                 db  93h ; 
.xdata$x:0000D5DB                 db  19h
.xdata$x:0000D5DC                 db    1
.xdata$x:0000D5DD                 db    0
.xdata$x:0000D5DE                 db    0
.xdata$x:0000D5DF                 db    0
.xdata$x:0000D5E0                 dd offset __unwindtable$?addInLoadedDlls@PluginsManager@@AAEXPB_W@Z
.xdata$x:0000D5E4                 db    0
.xdata$x:0000D5E5                 db    0
.xdata$x:0000D5E6                 db    0
.xdata$x:0000D5E7                 db    0
.xdata$x:0000D5E8                 db    0
.xdata$x:0000D5E9                 db    0
.xdata$x:0000D5EA                 db    0
.xdata$x:0000D5EB                 db    0
.xdata$x:0000D5EC                 db    0
.xdata$x:0000D5ED                 db    0
.xdata$x:0000D5EE                 db    0
.xdata$x:0000D5EF                 db    0
.xdata$x:0000D5F0                 db    0
.xdata$x:0000D5F1                 db    0
.xdata$x:0000D5F2                 db    0
.xdata$x:0000D5F3                 db    0
.xdata$x:0000D5F4                 db    0
.xdata$x:0000D5F5                 db    0
.xdata$x:0000D5F6                 db    0
.xdata$x:0000D5F7                 db    0
.xdata$x:0000D5F8                 db    0
.xdata$x:0000D5F9                 db    0
.xdata$x:0000D5FA                 db    0
.xdata$x:0000D5FB                 db    0
.xdata$x:0000D5FB _xdata$x        ends
.xdata$x:0000D5FB
.xdata$x:0000D5FC ; ===========================================================================
.xdata$x:0000D5FC
.xdata$x:0000D5FC ; Segment type: Pure data
.xdata$x:0000D5FC ; Segment permissions: Read
.xdata$x:0000D5FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D5FC                 assume cs:_xdata$x
.xdata$x:0000D5FC                 ;org 0D5FCh
.xdata$x:0000D5FC ; COMDAT (pick associative to section at 31FC)
.xdata$x:0000D5FC __unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z db 0FFh
.xdata$x:0000D5FC                                         ; DATA XREF: .xdata$x:0000D60Co
.xdata$x:0000D5FD                 db 0FFh
.xdata$x:0000D5FE                 db 0FFh
.xdata$x:0000D5FF                 db 0FFh
.xdata$x:0000D600                 dd offset __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z$0
.xdata$x:0000D604 __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z db  22h ; "
.xdata$x:0000D604                                         ; DATA XREF: __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z+11o
.xdata$x:0000D605                 db    5
.xdata$x:0000D606                 db  93h ; 
.xdata$x:0000D607                 db  19h
.xdata$x:0000D608                 db    1
.xdata$x:0000D609                 db    0
.xdata$x:0000D60A                 db    0
.xdata$x:0000D60B                 db    0
.xdata$x:0000D60C                 dd offset __unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
.xdata$x:0000D610                 db    0
.xdata$x:0000D611                 db    0
.xdata$x:0000D612                 db    0
.xdata$x:0000D613                 db    0
.xdata$x:0000D614                 db    0
.xdata$x:0000D615                 db    0
.xdata$x:0000D616                 db    0
.xdata$x:0000D617                 db    0
.xdata$x:0000D618                 db    0
.xdata$x:0000D619                 db    0
.xdata$x:0000D61A                 db    0
.xdata$x:0000D61B                 db    0
.xdata$x:0000D61C                 db    0
.xdata$x:0000D61D                 db    0
.xdata$x:0000D61E                 db    0
.xdata$x:0000D61F                 db    0
.xdata$x:0000D620                 db    0
.xdata$x:0000D621                 db    0
.xdata$x:0000D622                 db    0
.xdata$x:0000D623                 db    0
.xdata$x:0000D624                 db    0
.xdata$x:0000D625                 db    0
.xdata$x:0000D626                 db    0
.xdata$x:0000D627                 db    0
.xdata$x:0000D627 _xdata$x        ends
.xdata$x:0000D627
.xdata$x:0000D628 ; ===========================================================================
.xdata$x:0000D628
.xdata$x:0000D628 ; Segment type: Pure data
.xdata$x:0000D628 ; Segment permissions: Read
.xdata$x:0000D628 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D628                 assume cs:_xdata$x
.xdata$x:0000D628                 ;org 0D628h
.xdata$x:0000D628 ; COMDAT (pick associative to section at 4D20)
.xdata$x:0000D628 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:0000D628                                         ; DATA XREF: .xdata$x:0000D638o
.xdata$x:0000D629                 db 0FFh
.xdata$x:0000D62A                 db 0FFh
.xdata$x:0000D62B                 db 0FFh
.xdata$x:0000D62C                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000D630 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000D630                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000D631                 db    5
.xdata$x:0000D632                 db  93h ; 
.xdata$x:0000D633                 db  19h
.xdata$x:0000D634                 db    1
.xdata$x:0000D635                 db    0
.xdata$x:0000D636                 db    0
.xdata$x:0000D637                 db    0
.xdata$x:0000D638                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:0000D63C                 db    0
.xdata$x:0000D63D                 db    0
.xdata$x:0000D63E                 db    0
.xdata$x:0000D63F                 db    0
.xdata$x:0000D640                 db    0
.xdata$x:0000D641                 db    0
.xdata$x:0000D642                 db    0
.xdata$x:0000D643                 db    0
.xdata$x:0000D644                 db    0
.xdata$x:0000D645                 db    0
.xdata$x:0000D646                 db    0
.xdata$x:0000D647                 db    0
.xdata$x:0000D648                 db    0
.xdata$x:0000D649                 db    0
.xdata$x:0000D64A                 db    0
.xdata$x:0000D64B                 db    0
.xdata$x:0000D64C                 db    0
.xdata$x:0000D64D                 db    0
.xdata$x:0000D64E                 db    0
.xdata$x:0000D64F                 db    0
.xdata$x:0000D650                 db    0
.xdata$x:0000D651                 db    0
.xdata$x:0000D652                 db    0
.xdata$x:0000D653                 db    0
.xdata$x:0000D653 _xdata$x        ends
.xdata$x:0000D653
.xdata$x:0000D654 ; ===========================================================================
.xdata$x:0000D654
.xdata$x:0000D654 ; Segment type: Pure data
.xdata$x:0000D654 ; Segment permissions: Read
.xdata$x:0000D654 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D654                 assume cs:_xdata$x
.xdata$x:0000D654                 ;org 0D654h
.xdata$x:0000D654 ; COMDAT (pick associative to section at 4F70)
.xdata$x:0000D654 __unwindtable$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z db 0FFh
.xdata$x:0000D654                                         ; DATA XREF: .xdata$x:0000D664o
.xdata$x:0000D655                 db 0FFh
.xdata$x:0000D656                 db 0FFh
.xdata$x:0000D657                 db 0FFh
.xdata$x:0000D658                 dd offset __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z$0
.xdata$x:0000D65C __ehfuncinfo$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z db  22h ; "
.xdata$x:0000D65C                                         ; DATA XREF: __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z+11o
.xdata$x:0000D65D                 db    5
.xdata$x:0000D65E                 db  93h ; 
.xdata$x:0000D65F                 db  19h
.xdata$x:0000D660                 db    1
.xdata$x:0000D661                 db    0
.xdata$x:0000D662                 db    0
.xdata$x:0000D663                 db    0
.xdata$x:0000D664                 dd offset __unwindtable$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QAV21@@Z
.xdata$x:0000D668                 align 20h
.xdata$x:0000D668 _xdata$x        ends
.xdata$x:0000D668
.xdata$x:0000D680 ; ===========================================================================
.xdata$x:0000D680
.xdata$x:0000D680 ; Segment type: Pure data
.xdata$x:0000D680 ; Segment permissions: Read
.xdata$x:0000D680 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D680                 assume cs:_xdata$x
.xdata$x:0000D680                 ;org 0D680h
.xdata$x:0000D680 ; COMDAT (pick associative to section at 4E24)
.xdata$x:0000D680 __unwindtable$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z db 0FFh
.xdata$x:0000D680                                         ; DATA XREF: .xdata$x:0000D690o
.xdata$x:0000D681                 db 0FFh
.xdata$x:0000D682                 db 0FFh
.xdata$x:0000D683                 db 0FFh
.xdata$x:0000D684                 dd offset __unwindfunclet$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z$0
.xdata$x:0000D688 __ehfuncinfo$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z db  22h ; "
.xdata$x:0000D688                                         ; DATA XREF: __ehhandler$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z+11o
.xdata$x:0000D689                 db    5
.xdata$x:0000D68A                 db  93h ; 
.xdata$x:0000D68B                 db  19h
.xdata$x:0000D68C                 db    1
.xdata$x:0000D68D                 db    0
.xdata$x:0000D68E                 db    0
.xdata$x:0000D68F                 db    0
.xdata$x:0000D690                 dd offset __unwindtable$??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAV12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAV21@@Z
.xdata$x:0000D694                 db    0
.xdata$x:0000D695                 db    0
.xdata$x:0000D696                 db    0
.xdata$x:0000D697                 db    0
.xdata$x:0000D698                 db    0
.xdata$x:0000D699                 db    0
.xdata$x:0000D69A                 db    0
.xdata$x:0000D69B                 db    0
.xdata$x:0000D69C                 db    0
.xdata$x:0000D69D                 db    0
.xdata$x:0000D69E                 db    0
.xdata$x:0000D69F                 db    0
.xdata$x:0000D6A0                 db    0
.xdata$x:0000D6A1                 db    0
.xdata$x:0000D6A2                 db    0
.xdata$x:0000D6A3                 db    0
.xdata$x:0000D6A4                 db    0
.xdata$x:0000D6A5                 db    0
.xdata$x:0000D6A6                 db    0
.xdata$x:0000D6A7                 db    0
.xdata$x:0000D6A8                 db    0
.xdata$x:0000D6A9                 db    0
.xdata$x:0000D6AA                 db    0
.xdata$x:0000D6AB                 db    0
.xdata$x:0000D6AB _xdata$x        ends
.xdata$x:0000D6AB
.xdata$x:0000D6AC ; ===========================================================================
.xdata$x:0000D6AC
.xdata$x:0000D6AC ; Segment type: Pure data
.xdata$x:0000D6AC ; Segment permissions: Read
.xdata$x:0000D6AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D6AC                 assume cs:_xdata$x
.xdata$x:0000D6AC                 ;org 0D6ACh
.xdata$x:0000D6AC ; COMDAT (pick associative to section at 4B20)
.xdata$x:0000D6AC __unwindtable$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z db 0FFh
.xdata$x:0000D6AC                                         ; DATA XREF: .xdata$x:0000D6BCo
.xdata$x:0000D6AD                 db 0FFh
.xdata$x:0000D6AE                 db 0FFh
.xdata$x:0000D6AF                 db 0FFh
.xdata$x:0000D6B0                 dd offset __unwindfunclet$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z$0
.xdata$x:0000D6B4 __ehfuncinfo$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000D6B4                                         ; DATA XREF: __ehhandler$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z+11o
.xdata$x:0000D6B5                 db    5
.xdata$x:0000D6B6                 db  93h ; 
.xdata$x:0000D6B7                 db  19h
.xdata$x:0000D6B8                 db    1
.xdata$x:0000D6B9                 db    0
.xdata$x:0000D6BA                 db    0
.xdata$x:0000D6BB                 db    0
.xdata$x:0000D6BC                 dd offset __unwindtable$??$construct@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@U12@@?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAEXPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@$$QAU21@@Z
.xdata$x:0000D6C0                 db    0
.xdata$x:0000D6C1                 db    0
.xdata$x:0000D6C2                 db    0
.xdata$x:0000D6C3                 db    0
.xdata$x:0000D6C4                 db    0
.xdata$x:0000D6C5                 db    0
.xdata$x:0000D6C6                 db    0
.xdata$x:0000D6C7                 db    0
.xdata$x:0000D6C8                 db    0
.xdata$x:0000D6C9                 db    0
.xdata$x:0000D6CA                 db    0
.xdata$x:0000D6CB                 db    0
.xdata$x:0000D6CC                 db    0
.xdata$x:0000D6CD                 db    0
.xdata$x:0000D6CE                 db    0
.xdata$x:0000D6CF                 db    0
.xdata$x:0000D6D0                 db    0
.xdata$x:0000D6D1                 db    0
.xdata$x:0000D6D2                 db    0
.xdata$x:0000D6D3                 db    0
.xdata$x:0000D6D4                 db    0
.xdata$x:0000D6D5                 db    0
.xdata$x:0000D6D6                 db    0
.xdata$x:0000D6D7                 db    0
.xdata$x:0000D6D7 _xdata$x        ends
.xdata$x:0000D6D7
.xdata$x:0000D6D8 ; ===========================================================================
.xdata$x:0000D6D8
.xdata$x:0000D6D8 ; Segment type: Pure data
.xdata$x:0000D6D8 ; Segment permissions: Read
.xdata$x:0000D6D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D6D8                 assume cs:_xdata$x
.xdata$x:0000D6D8                 ;org 0D6D8h
.xdata$x:0000D6D8 ; COMDAT (pick associative to section at 48D4)
.xdata$x:0000D6D8 __unwindtable$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z db 0FFh
.xdata$x:0000D6D8                                         ; DATA XREF: .xdata$x:0000D6E8o
.xdata$x:0000D6D9                 db 0FFh
.xdata$x:0000D6DA                 db 0FFh
.xdata$x:0000D6DB                 db 0FFh
.xdata$x:0000D6DC                 dd offset __unwindfunclet$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z$0
.xdata$x:0000D6E0 __ehfuncinfo$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z db  22h ; "
.xdata$x:0000D6E0                                         ; DATA XREF: __ehhandler$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z+11o
.xdata$x:0000D6E1                 db    5
.xdata$x:0000D6E2                 db  93h ; 
.xdata$x:0000D6E3                 db  19h
.xdata$x:0000D6E4                 db    1
.xdata$x:0000D6E5                 db    0
.xdata$x:0000D6E6                 db    0
.xdata$x:0000D6E7                 db    0
.xdata$x:0000D6E8                 dd offset __unwindtable$??$construct@PAVTiXmlDocument@@AAPAV1@@?$allocator@PAVTiXmlDocument@@@std@@QAEXPAPAVTiXmlDocument@@AAPAV2@@Z
.xdata$x:0000D6EC                 db    0
.xdata$x:0000D6ED                 db    0
.xdata$x:0000D6EE                 db    0
.xdata$x:0000D6EF                 db    0
.xdata$x:0000D6F0                 db    0
.xdata$x:0000D6F1                 db    0
.xdata$x:0000D6F2                 db    0
.xdata$x:0000D6F3                 db    0
.xdata$x:0000D6F4                 db    0
.xdata$x:0000D6F5                 db    0
.xdata$x:0000D6F6                 db    0
.xdata$x:0000D6F7                 db    0
.xdata$x:0000D6F8                 db    0
.xdata$x:0000D6F9                 db    0
.xdata$x:0000D6FA                 db    0
.xdata$x:0000D6FB                 db    0
.xdata$x:0000D6FC                 db    0
.xdata$x:0000D6FD                 db    0
.xdata$x:0000D6FE                 db    0
.xdata$x:0000D6FF                 db    0
.xdata$x:0000D700                 db    0
.xdata$x:0000D701                 db    0
.xdata$x:0000D702                 db    0
.xdata$x:0000D703                 db    0
.xdata$x:0000D703 _xdata$x        ends
.xdata$x:0000D703
.xdata$x:0000D704 ; ===========================================================================
.xdata$x:0000D704
.xdata$x:0000D704 ; Segment type: Pure data
.xdata$x:0000D704 ; Segment permissions: Read
.xdata$x:0000D704 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D704                 assume cs:_xdata$x
.xdata$x:0000D704                 ;org 0D704h
.xdata$x:0000D704 ; COMDAT (pick associative to section at 5070)
.xdata$x:0000D704 __unwindtable$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z db 0FFh
.xdata$x:0000D704                                         ; DATA XREF: .xdata$x:0000D714o
.xdata$x:0000D705                 db 0FFh
.xdata$x:0000D706                 db 0FFh
.xdata$x:0000D707                 db 0FFh
.xdata$x:0000D708                 dd offset __unwindfunclet$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z$0
.xdata$x:0000D70C __ehfuncinfo$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z db  22h ; "
.xdata$x:0000D70C                                         ; DATA XREF: __ehhandler$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z+11o
.xdata$x:0000D70D                 db    5
.xdata$x:0000D70E                 db  93h ; 
.xdata$x:0000D70F                 db  19h
.xdata$x:0000D710                 db    1
.xdata$x:0000D711                 db    0
.xdata$x:0000D712                 db    0
.xdata$x:0000D713                 db    0
.xdata$x:0000D714                 dd offset __unwindtable$??$construct@VPluginCmdShortcut@@AAV1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@AAV2@@Z
.xdata$x:0000D718                 db    0
.xdata$x:0000D719                 db    0
.xdata$x:0000D71A                 db    0
.xdata$x:0000D71B                 db    0
.xdata$x:0000D71C                 db    0
.xdata$x:0000D71D                 db    0
.xdata$x:0000D71E                 db    0
.xdata$x:0000D71F                 db    0
.xdata$x:0000D720                 db    0
.xdata$x:0000D721                 db    0
.xdata$x:0000D722                 db    0
.xdata$x:0000D723                 db    0
.xdata$x:0000D724                 db    0
.xdata$x:0000D725                 db    0
.xdata$x:0000D726                 db    0
.xdata$x:0000D727                 db    0
.xdata$x:0000D728                 db    0
.xdata$x:0000D729                 db    0
.xdata$x:0000D72A                 db    0
.xdata$x:0000D72B                 db    0
.xdata$x:0000D72C                 db    0
.xdata$x:0000D72D                 db    0
.xdata$x:0000D72E                 db    0
.xdata$x:0000D72F                 db    0
.xdata$x:0000D72F _xdata$x        ends
.xdata$x:0000D72F
.xdata$x:0000D730 ; ===========================================================================
.xdata$x:0000D730
.xdata$x:0000D730 ; Segment type: Pure data
.xdata$x:0000D730 ; Segment permissions: Read
.xdata$x:0000D730 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D730                 assume cs:_xdata$x
.xdata$x:0000D730                 ;org 0D730h
.xdata$x:0000D730 ; COMDAT (pick associative to section at 4788)
.xdata$x:0000D730 __unwindtable$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z db 0FFh
.xdata$x:0000D730                                         ; DATA XREF: .xdata$x:0000D740o
.xdata$x:0000D731                 db 0FFh
.xdata$x:0000D732                 db 0FFh
.xdata$x:0000D733                 db 0FFh
.xdata$x:0000D734                 dd offset __unwindfunclet$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z$0
.xdata$x:0000D738 __ehfuncinfo$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z db  22h ; "
.xdata$x:0000D738                                         ; DATA XREF: __ehhandler$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z+11o
.xdata$x:0000D739                 db    5
.xdata$x:0000D73A                 db  93h ; 
.xdata$x:0000D73B                 db  19h
.xdata$x:0000D73C                 db    1
.xdata$x:0000D73D                 db    0
.xdata$x:0000D73E                 db    0
.xdata$x:0000D73F                 db    0
.xdata$x:0000D740                 dd offset __unwindtable$??$construct@PAUPluginInfo@@AAPAU1@@?$allocator@PAUPluginInfo@@@std@@QAEXPAPAUPluginInfo@@AAPAU2@@Z
.xdata$x:0000D744                 db    0
.xdata$x:0000D745                 db    0
.xdata$x:0000D746                 db    0
.xdata$x:0000D747                 db    0
.xdata$x:0000D748                 db    0
.xdata$x:0000D749                 db    0
.xdata$x:0000D74A                 db    0
.xdata$x:0000D74B                 db    0
.xdata$x:0000D74C                 db    0
.xdata$x:0000D74D                 db    0
.xdata$x:0000D74E                 db    0
.xdata$x:0000D74F                 db    0
.xdata$x:0000D750                 db    0
.xdata$x:0000D751                 db    0
.xdata$x:0000D752                 db    0
.xdata$x:0000D753                 db    0
.xdata$x:0000D754                 db    0
.xdata$x:0000D755                 db    0
.xdata$x:0000D756                 db    0
.xdata$x:0000D757                 db    0
.xdata$x:0000D758                 db    0
.xdata$x:0000D759                 db    0
.xdata$x:0000D75A                 db    0
.xdata$x:0000D75B                 db    0
.xdata$x:0000D75B _xdata$x        ends
.xdata$x:0000D75B
.xdata$x:0000D75C ; ===========================================================================
.xdata$x:0000D75C
.xdata$x:0000D75C ; Segment type: Pure data
.xdata$x:0000D75C ; Segment permissions: Read
.xdata$x:0000D75C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D75C                 assume cs:_xdata$x
.xdata$x:0000D75C                 ;org 0D75Ch
.xdata$x:0000D75C ; COMDAT (pick associative to section at 4C20)
.xdata$x:0000D75C __unwindtable$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z db 0FFh
.xdata$x:0000D75C                                         ; DATA XREF: .xdata$x:0000D76Co
.xdata$x:0000D75D                 db 0FFh
.xdata$x:0000D75E                 db 0FFh
.xdata$x:0000D75F                 db 0FFh
.xdata$x:0000D760                 dd offset __unwindfunclet$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z$0
.xdata$x:0000D764 __ehfuncinfo$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z db  22h ; "
.xdata$x:0000D764                                         ; DATA XREF: __ehhandler$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z+11o
.xdata$x:0000D765                 db    5
.xdata$x:0000D766                 db  93h ; 
.xdata$x:0000D767                 db  19h
.xdata$x:0000D768                 db    1
.xdata$x:0000D769                 db    0
.xdata$x:0000D76A                 db    0
.xdata$x:0000D76B                 db    0
.xdata$x:0000D76C                 dd offset __unwindtable$??$construct@UPluginCommand@@U1@@?$allocator@UPluginCommand@@@std@@QAEXPAUPluginCommand@@$$QAU2@@Z
.xdata$x:0000D770                 db    0
.xdata$x:0000D771                 db    0
.xdata$x:0000D772                 db    0
.xdata$x:0000D773                 db    0
.xdata$x:0000D774                 db    0
.xdata$x:0000D775                 db    0
.xdata$x:0000D776                 db    0
.xdata$x:0000D777                 db    0
.xdata$x:0000D778                 db    0
.xdata$x:0000D779                 db    0
.xdata$x:0000D77A                 db    0
.xdata$x:0000D77B                 db    0
.xdata$x:0000D77C                 db    0
.xdata$x:0000D77D                 db    0
.xdata$x:0000D77E                 db    0
.xdata$x:0000D77F                 db    0
.xdata$x:0000D780                 db    0
.xdata$x:0000D781                 db    0
.xdata$x:0000D782                 db    0
.xdata$x:0000D783                 db    0
.xdata$x:0000D784                 db    0
.xdata$x:0000D785                 db    0
.xdata$x:0000D786                 db    0
.xdata$x:0000D787                 db    0
.xdata$x:0000D787 _xdata$x        ends
.xdata$x:0000D787
.xdata$x:0000D788 ; ===========================================================================
.xdata$x:0000D788
.xdata$x:0000D788 ; Segment type: Pure data
.xdata$x:0000D788 ; Segment permissions: Read
.xdata$x:0000D788 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D788                 assume cs:_xdata$x
.xdata$x:0000D788                 ;org 0D788h
.xdata$x:0000D788 ; COMDAT (pick associative to section at 4688)
.xdata$x:0000D788 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:0000D788                                         ; DATA XREF: .xdata$x:0000D798o
.xdata$x:0000D789                 db 0FFh
.xdata$x:0000D78A                 db 0FFh
.xdata$x:0000D78B                 db 0FFh
.xdata$x:0000D78C                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0000D790 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0000D790                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0000D791                 db    5
.xdata$x:0000D792                 db  93h ; 
.xdata$x:0000D793                 db  19h
.xdata$x:0000D794                 db    1
.xdata$x:0000D795                 db    0
.xdata$x:0000D796                 db    0
.xdata$x:0000D797                 db    0
.xdata$x:0000D798                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000D79C                 db    0
.xdata$x:0000D79D                 db    0
.xdata$x:0000D79E                 db    0
.xdata$x:0000D79F                 db    0
.xdata$x:0000D7A0                 db    0
.xdata$x:0000D7A1                 db    0
.xdata$x:0000D7A2                 db    0
.xdata$x:0000D7A3                 db    0
.xdata$x:0000D7A4                 db    0
.xdata$x:0000D7A5                 db    0
.xdata$x:0000D7A6                 db    0
.xdata$x:0000D7A7                 db    0
.xdata$x:0000D7A8                 db    0
.xdata$x:0000D7A9                 db    0
.xdata$x:0000D7AA                 db    0
.xdata$x:0000D7AB                 db    0
.xdata$x:0000D7AC                 db    0
.xdata$x:0000D7AD                 db    0
.xdata$x:0000D7AE                 db    0
.xdata$x:0000D7AF                 db    0
.xdata$x:0000D7B0                 db    0
.xdata$x:0000D7B1                 db    0
.xdata$x:0000D7B2                 db    0
.xdata$x:0000D7B3                 db    0
.xdata$x:0000D7B3 _xdata$x        ends
.xdata$x:0000D7B3
.xdata$x:0000D7B4 ; ===========================================================================
.xdata$x:0000D7B4
.xdata$x:0000D7B4 ; Segment type: Pure data
.xdata$x:0000D7B4 ; Segment permissions: Read
.xdata$x:0000D7B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D7B4                 assume cs:_xdata$x
.xdata$x:0000D7B4                 ;org 0D7B4h
.xdata$x:0000D7B4 ; COMDAT (pick associative to section at 4A20)
.xdata$x:0000D7B4 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:0000D7B4                                         ; DATA XREF: .xdata$x:0000D7C4o
.xdata$x:0000D7B5                 db 0FFh
.xdata$x:0000D7B6                 db 0FFh
.xdata$x:0000D7B7                 db 0FFh
.xdata$x:0000D7B8                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:0000D7BC __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:0000D7BC                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:0000D7BD                 db    5
.xdata$x:0000D7BE                 db  93h ; 
.xdata$x:0000D7BF                 db  19h
.xdata$x:0000D7C0                 db    1
.xdata$x:0000D7C1                 db    0
.xdata$x:0000D7C2                 db    0
.xdata$x:0000D7C3                 db    0
.xdata$x:0000D7C4                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:0000D7C8                 align 20h
.xdata$x:0000D7C8 _xdata$x        ends
.xdata$x:0000D7C8
.xdata$x:0000D7E0 ; ===========================================================================
.xdata$x:0000D7E0
.xdata$x:0000D7E0 ; Segment type: Pure data
.xdata$x:0000D7E0 ; Segment permissions: Read
.xdata$x:0000D7E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D7E0                 assume cs:_xdata$x
.xdata$x:0000D7E0                 ;org 0D7E0h
.xdata$x:0000D7E0 ; COMDAT (pick associative to section at 3138)
.xdata$x:0000D7E0 __unwindtable$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z db 0FFh
.xdata$x:0000D7E0                                         ; DATA XREF: .xdata$x:0000D7F0o
.xdata$x:0000D7E1                 db 0FFh
.xdata$x:0000D7E2                 db 0FFh
.xdata$x:0000D7E3                 db 0FFh
.xdata$x:0000D7E4                 dd offset __unwindfunclet$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z$0
.xdata$x:0000D7E8 __ehfuncinfo$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z db  22h ; "
.xdata$x:0000D7E8                                         ; DATA XREF: __ehhandler$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z+11o
.xdata$x:0000D7E9                 db    5
.xdata$x:0000D7EA                 db  93h ; 
.xdata$x:0000D7EB                 db  19h
.xdata$x:0000D7EC                 db    1
.xdata$x:0000D7ED                 db    0
.xdata$x:0000D7EE                 db    0
.xdata$x:0000D7EF                 db    0
.xdata$x:0000D7F0                 dd offset __unwindtable$??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NX@?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@$$QAU01@@Z
.xdata$x:0000D7F4                 db    0
.xdata$x:0000D7F5                 db    0
.xdata$x:0000D7F6                 db    0
.xdata$x:0000D7F7                 db    0
.xdata$x:0000D7F8                 db    0
.xdata$x:0000D7F9                 db    0
.xdata$x:0000D7FA                 db    0
.xdata$x:0000D7FB                 db    0
.xdata$x:0000D7FC                 db    0
.xdata$x:0000D7FD                 db    0
.xdata$x:0000D7FE                 db    0
.xdata$x:0000D7FF                 db    0
.xdata$x:0000D800                 db    0
.xdata$x:0000D801                 db    0
.xdata$x:0000D802                 db    0
.xdata$x:0000D803                 db    0
.xdata$x:0000D804                 db    0
.xdata$x:0000D805                 db    0
.xdata$x:0000D806                 db    0
.xdata$x:0000D807                 db    0
.xdata$x:0000D808                 db    0
.xdata$x:0000D809                 db    0
.xdata$x:0000D80A                 db    0
.xdata$x:0000D80B                 db    0
.xdata$x:0000D80B _xdata$x        ends
.xdata$x:0000D80B
.xdata$x:0000D80C ; ===========================================================================
.xdata$x:0000D80C
.xdata$x:0000D80C ; Segment type: Pure data
.xdata$x:0000D80C ; Segment permissions: Read
.xdata$x:0000D80C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D80C                 assume cs:_xdata$x
.xdata$x:0000D80C                 ;org 0D80Ch
.xdata$x:0000D80C ; COMDAT (pick associative to section at 4170)
.xdata$x:0000D80C __catchsym$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000D80C                                         ; DATA XREF: .xdata$x:0000D83Co
.xdata$x:0000D80D                 db    0
.xdata$x:0000D80E                 db    0
.xdata$x:0000D80F                 db    0
.xdata$x:0000D810                 db    0
.xdata$x:0000D811                 db    0
.xdata$x:0000D812                 db    0
.xdata$x:0000D813                 db    0
.xdata$x:0000D814                 db    0
.xdata$x:0000D815                 db    0
.xdata$x:0000D816                 db    0
.xdata$x:0000D817                 db    0
.xdata$x:0000D818                 dd offset __catch$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000D81C __unwindtable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000D81C                                         ; DATA XREF: .xdata$x:0000D848o
.xdata$x:0000D81D                 db 0FFh
.xdata$x:0000D81E                 db 0FFh
.xdata$x:0000D81F                 db 0FFh
.xdata$x:0000D820                 db    0
.xdata$x:0000D821                 db    0
.xdata$x:0000D822                 db    0
.xdata$x:0000D823                 db    0
.xdata$x:0000D824                 db 0FFh
.xdata$x:0000D825                 db 0FFh
.xdata$x:0000D826                 db 0FFh
.xdata$x:0000D827                 db 0FFh
.xdata$x:0000D828                 db    0
.xdata$x:0000D829                 db    0
.xdata$x:0000D82A                 db    0
.xdata$x:0000D82B                 db    0
.xdata$x:0000D82C __tryblocktable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000D82C                                         ; DATA XREF: .xdata$x:0000D850o
.xdata$x:0000D82D                 db    0
.xdata$x:0000D82E                 db    0
.xdata$x:0000D82F                 db    0
.xdata$x:0000D830                 db    0
.xdata$x:0000D831                 db    0
.xdata$x:0000D832                 db    0
.xdata$x:0000D833                 db    0
.xdata$x:0000D834                 db    1
.xdata$x:0000D835                 db    0
.xdata$x:0000D836                 db    0
.xdata$x:0000D837                 db    0
.xdata$x:0000D838                 db    1
.xdata$x:0000D839                 db    0
.xdata$x:0000D83A                 db    0
.xdata$x:0000D83B                 db    0
.xdata$x:0000D83C                 dd offset __catchsym$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000D840 __ehfuncinfo$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000D840                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000D841                 db    5
.xdata$x:0000D842                 db  93h ; 
.xdata$x:0000D843                 db  19h
.xdata$x:0000D844                 db    2
.xdata$x:0000D845                 db    0
.xdata$x:0000D846                 db    0
.xdata$x:0000D847                 db    0
.xdata$x:0000D848                 dd offset __unwindtable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000D84C                 db    1
.xdata$x:0000D84D                 db    0
.xdata$x:0000D84E                 db    0
.xdata$x:0000D84F                 db    0
.xdata$x:0000D850                 dd offset __tryblocktable$??$_Uninit_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000D854                 db    0
.xdata$x:0000D855                 db    0
.xdata$x:0000D856                 db    0
.xdata$x:0000D857                 db    0
.xdata$x:0000D858                 db    0
.xdata$x:0000D859                 db    0
.xdata$x:0000D85A                 db    0
.xdata$x:0000D85B                 db    0
.xdata$x:0000D85C                 db    0
.xdata$x:0000D85D                 db    0
.xdata$x:0000D85E                 db    0
.xdata$x:0000D85F                 db    0
.xdata$x:0000D860                 db    0
.xdata$x:0000D861                 db    0
.xdata$x:0000D862                 db    0
.xdata$x:0000D863                 db    0
.xdata$x:0000D863 _xdata$x        ends
.xdata$x:0000D863
.xdata$x:0000D864 ; ===========================================================================
.xdata$x:0000D864
.xdata$x:0000D864 ; Segment type: Pure data
.xdata$x:0000D864 ; Segment permissions: Read
.xdata$x:0000D864 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D864                 assume cs:_xdata$x
.xdata$x:0000D864                 ;org 0D864h
.xdata$x:0000D864 ; COMDAT (pick associative to section at 3E6C)
.xdata$x:0000D864 __catchsym$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000D864                                         ; DATA XREF: .xdata$x:0000D894o
.xdata$x:0000D865                 db    0
.xdata$x:0000D866                 db    0
.xdata$x:0000D867                 db    0
.xdata$x:0000D868                 db    0
.xdata$x:0000D869                 db    0
.xdata$x:0000D86A                 db    0
.xdata$x:0000D86B                 db    0
.xdata$x:0000D86C                 db    0
.xdata$x:0000D86D                 db    0
.xdata$x:0000D86E                 db    0
.xdata$x:0000D86F                 db    0
.xdata$x:0000D870                 dd offset __catch$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000D874 __unwindtable$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000D874                                         ; DATA XREF: .xdata$x:0000D8A0o
.xdata$x:0000D875                 db 0FFh
.xdata$x:0000D876                 db 0FFh
.xdata$x:0000D877                 db 0FFh
.xdata$x:0000D878                 db    0
.xdata$x:0000D879                 db    0
.xdata$x:0000D87A                 db    0
.xdata$x:0000D87B                 db    0
.xdata$x:0000D87C                 db 0FFh
.xdata$x:0000D87D                 db 0FFh
.xdata$x:0000D87E                 db 0FFh
.xdata$x:0000D87F                 db 0FFh
.xdata$x:0000D880                 db    0
.xdata$x:0000D881                 db    0
.xdata$x:0000D882                 db    0
.xdata$x:0000D883                 db    0
.xdata$x:0000D884 __tryblocktable$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000D884                                         ; DATA XREF: .xdata$x:0000D8A8o
.xdata$x:0000D885                 db    0
.xdata$x:0000D886                 db    0
.xdata$x:0000D887                 db    0
.xdata$x:0000D888                 db    0
.xdata$x:0000D889                 db    0
.xdata$x:0000D88A                 db    0
.xdata$x:0000D88B                 db    0
.xdata$x:0000D88C                 db    1
.xdata$x:0000D88D                 db    0
.xdata$x:0000D88E                 db    0
.xdata$x:0000D88F                 db    0
.xdata$x:0000D890                 db    1
.xdata$x:0000D891                 db    0
.xdata$x:0000D892                 db    0
.xdata$x:0000D893                 db    0
.xdata$x:0000D894                 dd offset __catchsym$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000D898 __ehfuncinfo$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000D898                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000D899                 db    5
.xdata$x:0000D89A                 db  93h ; 
.xdata$x:0000D89B                 db  19h
.xdata$x:0000D89C                 db    2
.xdata$x:0000D89D                 db    0
.xdata$x:0000D89E                 db    0
.xdata$x:0000D89F                 db    0
.xdata$x:0000D8A0                 dd offset __unwindtable$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000D8A4                 db    1
.xdata$x:0000D8A5                 db    0
.xdata$x:0000D8A6                 db    0
.xdata$x:0000D8A7                 db    0
.xdata$x:0000D8A8                 dd offset __tryblocktable$??$_Uninit_move@PAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAU12@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@U12@@std@@YAPAU?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000D8AC                 db    0
.xdata$x:0000D8AD                 db    0
.xdata$x:0000D8AE                 db    0
.xdata$x:0000D8AF                 db    0
.xdata$x:0000D8B0                 db    0
.xdata$x:0000D8B1                 db    0
.xdata$x:0000D8B2                 db    0
.xdata$x:0000D8B3                 db    0
.xdata$x:0000D8B4                 db    0
.xdata$x:0000D8B5                 db    0
.xdata$x:0000D8B6                 db    0
.xdata$x:0000D8B7                 db    0
.xdata$x:0000D8B8                 db    0
.xdata$x:0000D8B9                 db    0
.xdata$x:0000D8BA                 db    0
.xdata$x:0000D8BB                 db    0
.xdata$x:0000D8BB _xdata$x        ends
.xdata$x:0000D8BB
.xdata$x:0000D8BC ; ===========================================================================
.xdata$x:0000D8BC
.xdata$x:0000D8BC ; Segment type: Pure data
.xdata$x:0000D8BC ; Segment permissions: Read
.xdata$x:0000D8BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D8BC                 assume cs:_xdata$x
.xdata$x:0000D8BC                 ;org 0D8BCh
.xdata$x:0000D8BC ; COMDAT (pick associative to section at 42C0)
.xdata$x:0000D8BC __catchsym$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000D8BC                                         ; DATA XREF: .xdata$x:0000D8ECo
.xdata$x:0000D8BD                 db    0
.xdata$x:0000D8BE                 db    0
.xdata$x:0000D8BF                 db    0
.xdata$x:0000D8C0                 db    0
.xdata$x:0000D8C1                 db    0
.xdata$x:0000D8C2                 db    0
.xdata$x:0000D8C3                 db    0
.xdata$x:0000D8C4                 db    0
.xdata$x:0000D8C5                 db    0
.xdata$x:0000D8C6                 db    0
.xdata$x:0000D8C7                 db    0
.xdata$x:0000D8C8                 dd offset __catch$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000D8CC __unwindtable$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000D8CC                                         ; DATA XREF: .xdata$x:0000D8F8o
.xdata$x:0000D8CD                 db 0FFh
.xdata$x:0000D8CE                 db 0FFh
.xdata$x:0000D8CF                 db 0FFh
.xdata$x:0000D8D0                 db    0
.xdata$x:0000D8D1                 db    0
.xdata$x:0000D8D2                 db    0
.xdata$x:0000D8D3                 db    0
.xdata$x:0000D8D4                 db 0FFh
.xdata$x:0000D8D5                 db 0FFh
.xdata$x:0000D8D6                 db 0FFh
.xdata$x:0000D8D7                 db 0FFh
.xdata$x:0000D8D8                 db    0
.xdata$x:0000D8D9                 db    0
.xdata$x:0000D8DA                 db    0
.xdata$x:0000D8DB                 db    0
.xdata$x:0000D8DC __tryblocktable$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000D8DC                                         ; DATA XREF: .xdata$x:0000D900o
.xdata$x:0000D8DD                 db    0
.xdata$x:0000D8DE                 db    0
.xdata$x:0000D8DF                 db    0
.xdata$x:0000D8E0                 db    0
.xdata$x:0000D8E1                 db    0
.xdata$x:0000D8E2                 db    0
.xdata$x:0000D8E3                 db    0
.xdata$x:0000D8E4                 db    1
.xdata$x:0000D8E5                 db    0
.xdata$x:0000D8E6                 db    0
.xdata$x:0000D8E7                 db    0
.xdata$x:0000D8E8                 db    1
.xdata$x:0000D8E9                 db    0
.xdata$x:0000D8EA                 db    0
.xdata$x:0000D8EB                 db    0
.xdata$x:0000D8EC                 dd offset __catchsym$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000D8F0 __ehfuncinfo$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000D8F0                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000D8F1                 db    5
.xdata$x:0000D8F2                 db  93h ; 
.xdata$x:0000D8F3                 db  19h
.xdata$x:0000D8F4                 db    2
.xdata$x:0000D8F5                 db    0
.xdata$x:0000D8F6                 db    0
.xdata$x:0000D8F7                 db    0
.xdata$x:0000D8F8                 dd offset __unwindtable$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000D8FC                 db    1
.xdata$x:0000D8FD                 db    0
.xdata$x:0000D8FE                 db    0
.xdata$x:0000D8FF                 db    0
.xdata$x:0000D900                 dd offset __tryblocktable$??$_Uninit_move@PAVPluginCmdShortcut@@PAV1@V?$allocator@VPluginCmdShortcut@@@std@@V1@@std@@YAPAVPluginCmdShortcut@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPluginCmdShortcut@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000D904                 db    0
.xdata$x:0000D905                 db    0
.xdata$x:0000D906                 db    0
.xdata$x:0000D907                 db    0
.xdata$x:0000D908                 db    0
.xdata$x:0000D909                 db    0
.xdata$x:0000D90A                 db    0
.xdata$x:0000D90B                 db    0
.xdata$x:0000D90C                 db    0
.xdata$x:0000D90D                 db    0
.xdata$x:0000D90E                 db    0
.xdata$x:0000D90F                 db    0
.xdata$x:0000D910                 db    0
.xdata$x:0000D911                 db    0
.xdata$x:0000D912                 db    0
.xdata$x:0000D913                 db    0
.xdata$x:0000D913 _xdata$x        ends
.xdata$x:0000D913
.xdata$x:0000D914 ; ===========================================================================
.xdata$x:0000D914
.xdata$x:0000D914 ; Segment type: Pure data
.xdata$x:0000D914 ; Segment permissions: Read
.xdata$x:0000D914 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D914                 assume cs:_xdata$x
.xdata$x:0000D914                 ;org 0D914h
.xdata$x:0000D914 ; COMDAT (pick associative to section at 3FBC)
.xdata$x:0000D914 __catchsym$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000D914                                         ; DATA XREF: .xdata$x:0000D944o
.xdata$x:0000D915                 db    0
.xdata$x:0000D916                 db    0
.xdata$x:0000D917                 db    0
.xdata$x:0000D918                 db    0
.xdata$x:0000D919                 db    0
.xdata$x:0000D91A                 db    0
.xdata$x:0000D91B                 db    0
.xdata$x:0000D91C                 db    0
.xdata$x:0000D91D                 db    0
.xdata$x:0000D91E                 db    0
.xdata$x:0000D91F                 db    0
.xdata$x:0000D920                 dd offset __catch$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000D924 __unwindtable$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000D924                                         ; DATA XREF: .xdata$x:0000D950o
.xdata$x:0000D925                 db 0FFh
.xdata$x:0000D926                 db 0FFh
.xdata$x:0000D927                 db 0FFh
.xdata$x:0000D928                 db    0
.xdata$x:0000D929                 db    0
.xdata$x:0000D92A                 db    0
.xdata$x:0000D92B                 db    0
.xdata$x:0000D92C                 db 0FFh
.xdata$x:0000D92D                 db 0FFh
.xdata$x:0000D92E                 db 0FFh
.xdata$x:0000D92F                 db 0FFh
.xdata$x:0000D930                 db    0
.xdata$x:0000D931                 db    0
.xdata$x:0000D932                 db    0
.xdata$x:0000D933                 db    0
.xdata$x:0000D934 __tryblocktable$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000D934                                         ; DATA XREF: .xdata$x:0000D958o
.xdata$x:0000D935                 db    0
.xdata$x:0000D936                 db    0
.xdata$x:0000D937                 db    0
.xdata$x:0000D938                 db    0
.xdata$x:0000D939                 db    0
.xdata$x:0000D93A                 db    0
.xdata$x:0000D93B                 db    0
.xdata$x:0000D93C                 db    1
.xdata$x:0000D93D                 db    0
.xdata$x:0000D93E                 db    0
.xdata$x:0000D93F                 db    0
.xdata$x:0000D940                 db    1
.xdata$x:0000D941                 db    0
.xdata$x:0000D942                 db    0
.xdata$x:0000D943                 db    0
.xdata$x:0000D944                 dd offset __catchsym$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000D948 __ehfuncinfo$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000D948                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000D949                 db    5
.xdata$x:0000D94A                 db  93h ; 
.xdata$x:0000D94B                 db  19h
.xdata$x:0000D94C                 db    2
.xdata$x:0000D94D                 db    0
.xdata$x:0000D94E                 db    0
.xdata$x:0000D94F                 db    0
.xdata$x:0000D950                 dd offset __unwindtable$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000D954                 db    1
.xdata$x:0000D955                 db    0
.xdata$x:0000D956                 db    0
.xdata$x:0000D957                 db    0
.xdata$x:0000D958                 dd offset __tryblocktable$??$_Uninit_move@PAUPluginCommand@@PAU1@V?$allocator@UPluginCommand@@@std@@U1@@std@@YAPAUPluginCommand@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UPluginCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000D95C                 db    0
.xdata$x:0000D95D                 db    0
.xdata$x:0000D95E                 db    0
.xdata$x:0000D95F                 db    0
.xdata$x:0000D960                 db    0
.xdata$x:0000D961                 db    0
.xdata$x:0000D962                 db    0
.xdata$x:0000D963                 db    0
.xdata$x:0000D964                 db    0
.xdata$x:0000D965                 db    0
.xdata$x:0000D966                 db    0
.xdata$x:0000D967                 db    0
.xdata$x:0000D968                 db    0
.xdata$x:0000D969                 db    0
.xdata$x:0000D96A                 db    0
.xdata$x:0000D96B                 db    0
.xdata$x:0000D96B _xdata$x        ends
.xdata$x:0000D96B
.xdata$x:0000D96C ; ===========================================================================
.xdata$x:0000D96C
.xdata$x:0000D96C ; Segment type: Pure data
.xdata$x:0000D96C ; Segment permissions: Read
.xdata$x:0000D96C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000D96C                 assume cs:_xdata$x
.xdata$x:0000D96C                 ;org 0D96Ch
.xdata$x:0000D96C ; COMDAT (pick associative to section at 51BC)
.xdata$x:0000D96C __unwindtable$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z db 0FFh
.xdata$x:0000D96C                                         ; DATA XREF: .xdata$x:0000D97Co
.xdata$x:0000D96D                 db 0FFh
.xdata$x:0000D96E                 db 0FFh
.xdata$x:0000D96F                 db 0FFh
.xdata$x:0000D970                 dd offset __unwindfunclet$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z$0
.xdata$x:0000D974 __ehfuncinfo$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z db  22h ; "
.xdata$x:0000D974                                         ; DATA XREF: __ehhandler$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z+11o
.xdata$x:0000D975                 db    5
.xdata$x:0000D976                 db  93h ; 
.xdata$x:0000D977                 db  19h
.xdata$x:0000D978                 db    1
.xdata$x:0000D979                 db    0
.xdata$x:0000D97A                 db    0
.xdata$x:0000D97B                 db    0
.xdata$x:0000D97C                 dd offset __unwindtable$??$construct@VPluginCmdShortcut@@V1@@?$allocator@VPluginCmdShortcut@@@std@@QAEXPAVPluginCmdShortcut@@$$QAV2@@Z
.xdata$x:0000D980                 db    0
.xdata$x:0000D981                 db    0
.xdata$x:0000D982                 db    0
.xdata$x:0000D983                 db    0
.xdata$x:0000D984                 db    0
.xdata$x:0000D985                 db    0
.xdata$x:0000D986                 db    0
.xdata$x:0000D987                 db    0
.xdata$x:0000D988                 db    0
.xdata$x:0000D989                 db    0
.xdata$x:0000D98A                 db    0
.xdata$x:0000D98B                 db    0
.xdata$x:0000D98C                 db    0
.xdata$x:0000D98D                 db    0
.xdata$x:0000D98E                 db    0
.xdata$x:0000D98F                 db    0
.xdata$x:0000D990                 db    0
.xdata$x:0000D991                 db    0
.xdata$x:0000D992                 db    0
.xdata$x:0000D993                 db    0
.xdata$x:0000D994                 db    0
.xdata$x:0000D995                 db    0
.xdata$x:0000D996                 db    0
.xdata$x:0000D997                 db    0
.xdata$x:0000D997 _xdata$x        ends
.xdata$x:0000D997
.bss:0000D998 ; ===========================================================================
.bss:0000D998
.bss:0000D998 ; Segment type: Uninitialized
.bss:0000D998 ; Segment permissions: Read/Write
.bss:0000D998 _bss            segment byte public 'BSS' use32
.bss:0000D998                 assume cs:_bss
.bss:0000D998                 ;org 0D998h
.bss:0000D998                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000D998 _allocator_arg  db    ? ;
.bss:0000D999 _piecewise_construct db    ? ;
.bss:0000D99A                 align 4
.bss:0000D99A _bss            ends
.bss:0000D99A
.data$r:0000D99C ; ===========================================================================
.data$r:0000D99C
.data$r:0000D99C ; Segment type: Pure data
.data$r:0000D99C ; Segment permissions: Read/Write
.data$r:0000D99C _data$r         segment dword public 'DATA' use32
.data$r:0000D99C                 assume cs:_data$r
.data$r:0000D99C                 ;org 0D99Ch
.data$r:0000D99C ; COMDAT (pick any)
.data$r:0000D99C                 public ??_R0?AVexception@std@@@8
.data$r:0000D99C ; class std::exception `RTTI Type Descriptor'
.data$r:0000D99C ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000D99C                                         ; DATA XREF: .xdata$x:0000D160o
.data$r:0000D99C                                         ; .xdata$x:0000D180o ...
.data$r:0000D99C                                         ; const type_info::`vftable'
.data$r:0000D9A0                 db    0
.data$r:0000D9A1                 db    0
.data$r:0000D9A2                 db    0
.data$r:0000D9A3                 db    0
.data$r:0000D9A4                 db  2Eh ; .
.data$r:0000D9A5                 db  3Fh ; ?
.data$r:0000D9A6                 db  41h ; A
.data$r:0000D9A7                 db  56h ; V
.data$r:0000D9A8                 db  65h ; e
.data$r:0000D9A9                 db  78h ; x
.data$r:0000D9AA                 db  63h ; c
.data$r:0000D9AB                 db  65h ; e
.data$r:0000D9AC                 db  70h ; p
.data$r:0000D9AD                 db  74h ; t
.data$r:0000D9AE                 db  69h ; i
.data$r:0000D9AF                 db  6Fh ; o
.data$r:0000D9B0                 db  6Eh ; n
.data$r:0000D9B1                 db  40h ; @
.data$r:0000D9B2                 db  73h ; s
.data$r:0000D9B3                 db  74h ; t
.data$r:0000D9B4                 db  64h ; d
.data$r:0000D9B5                 db  40h ; @
.data$r:0000D9B6                 db  40h ; @
.data$r:0000D9B7                 db    0
.data$r:0000D9B7 _data$r         ends
.data$r:0000D9B7
.rdata:0000D9B8 ; ===========================================================================
.rdata:0000D9B8
.rdata:0000D9B8 ; Segment type: Pure data
.rdata:0000D9B8 ; Segment permissions: Read
.rdata:0000D9B8 _rdata          segment dword public 'DATA' use32
.rdata:0000D9B8                 assume cs:_rdata
.rdata:0000D9B8                 ;org 0D9B8h
.rdata:0000D9B8 ; COMDAT (pick largest)
.rdata:0000D9B8                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000D9BC                 public ??_7error_category@std@@6B@
.rdata:0000D9BC ; const std::error_category::`vftable'
.rdata:0000D9BC ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000D9BC                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000D9BC                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000D9BC                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000D9C0                 dd offset __purecall
.rdata:0000D9C4                 dd offset __purecall
.rdata:0000D9C8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000D9CC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000D9D0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000D9D0 _rdata          ends
.rdata:0000D9D0
.rdata:0000D9D4 ; ===========================================================================
.rdata:0000D9D4
.rdata:0000D9D4 ; Segment type: Pure data
.rdata:0000D9D4 ; Segment permissions: Read
.rdata:0000D9D4 _rdata          segment dword public 'DATA' use32
.rdata:0000D9D4                 assume cs:_rdata
.rdata:0000D9D4                 ;org 0D9D4h
.rdata:0000D9D4 ; COMDAT (pick largest)
.rdata:0000D9D4                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000D9D8                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000D9D8 ; const std::_Generic_error_category::`vftable'
.rdata:0000D9D8 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000D9D8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000D9D8                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000D9DC                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000D9E0                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:0000D9E4                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000D9E8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000D9EC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000D9EC _rdata          ends
.rdata:0000D9EC
.rdata:0000D9F0 ; ===========================================================================
.rdata:0000D9F0
.rdata:0000D9F0 ; Segment type: Pure data
.rdata:0000D9F0 ; Segment permissions: Read
.rdata:0000D9F0 _rdata          segment dword public 'DATA' use32
.rdata:0000D9F0                 assume cs:_rdata
.rdata:0000D9F0                 ;org 0D9F0h
.rdata:0000D9F0 ; COMDAT (pick any)
.rdata:0000D9F0                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000D9F0 ; `string'
.rdata:0000D9F0 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000D9F0                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000D9F0 _rdata          ends
.rdata:0000D9F0
.rdata:0000D9F8 ; ===========================================================================
.rdata:0000D9F8
.rdata:0000D9F8 ; Segment type: Pure data
.rdata:0000D9F8 ; Segment permissions: Read
.rdata:0000D9F8 _rdata          segment dword public 'DATA' use32
.rdata:0000D9F8                 assume cs:_rdata
.rdata:0000D9F8                 ;org 0D9F8h
.rdata:0000D9F8 ; COMDAT (pick any)
.rdata:0000D9F8                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000D9F8 ; `string'
.rdata:0000D9F8 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000D9F8                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_B5A4o
.rdata:0000D9F8                                         ; std::_System_error_category::message(int):loc_B720o
.rdata:0000DA06                 align 4
.rdata:0000DA06 _rdata          ends
.rdata:0000DA06
.rdata:0000DA08 ; ===========================================================================
.rdata:0000DA08
.rdata:0000DA08 ; Segment type: Pure data
.rdata:0000DA08 ; Segment permissions: Read
.rdata:0000DA08 _rdata          segment dword public 'DATA' use32
.rdata:0000DA08                 assume cs:_rdata
.rdata:0000DA08                 ;org 0DA08h
.rdata:0000DA08 ; COMDAT (pick largest)
.rdata:0000DA08                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000DA0C                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000DA0C ; const std::_Iostream_error_category::`vftable'
.rdata:0000DA0C ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000DA0C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000DA0C                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000DA10                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000DA14                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000DA18                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000DA1C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000DA20                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000DA20 _rdata          ends
.rdata:0000DA20
.rdata:0000DA24 ; ===========================================================================
.rdata:0000DA24
.rdata:0000DA24 ; Segment type: Pure data
.rdata:0000DA24 ; Segment permissions: Read
.rdata:0000DA24 _rdata          segment dword public 'DATA' use32
.rdata:0000DA24                 assume cs:_rdata
.rdata:0000DA24                 ;org 0DA24h
.rdata:0000DA24 ; COMDAT (pick any)
.rdata:0000DA24                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000DA24 ; `string'
.rdata:0000DA24 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000DA24                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000DA2D                 align 10h
.rdata:0000DA2D _rdata          ends
.rdata:0000DA2D
.rdata:0000DA30 ; ===========================================================================
.rdata:0000DA30
.rdata:0000DA30 ; Segment type: Pure data
.rdata:0000DA30 ; Segment permissions: Read
.rdata:0000DA30 _rdata          segment dword public 'DATA' use32
.rdata:0000DA30                 assume cs:_rdata
.rdata:0000DA30                 ;org 0DA30h
.rdata:0000DA30 ; COMDAT (pick any)
.rdata:0000DA30                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000DA30 ; char `string'[]
.rdata:0000DA30 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000DA30                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000DA46                 align 4
.rdata:0000DA46 _rdata          ends
.rdata:0000DA46
.rdata:0000DA48 ; ===========================================================================
.rdata:0000DA48
.rdata:0000DA48 ; Segment type: Pure data
.rdata:0000DA48 ; Segment permissions: Read
.rdata:0000DA48 _rdata          segment dword public 'DATA' use32
.rdata:0000DA48                 assume cs:_rdata
.rdata:0000DA48                 ;org 0DA48h
.rdata:0000DA48 ; COMDAT (pick largest)
.rdata:0000DA48                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000DA4C                 public ??_7_System_error_category@std@@6B@
.rdata:0000DA4C ; const std::_System_error_category::`vftable'
.rdata:0000DA4C ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000DA4C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000DA4C                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000DA50                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000DA54                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000DA58                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000DA5C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000DA60                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000DA60 _rdata          ends
.rdata:0000DA60
.rdata:0000DA64 ; ===========================================================================
.rdata:0000DA64
.rdata:0000DA64 ; Segment type: Pure data
.rdata:0000DA64 ; Segment permissions: Read
.rdata:0000DA64 _rdata          segment dword public 'DATA' use32
.rdata:0000DA64                 assume cs:_rdata
.rdata:0000DA64                 ;org 0DA64h
.rdata:0000DA64 ; COMDAT (pick any)
.rdata:0000DA64                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000DA64 ; `string'
.rdata:0000DA64 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000DA64                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000DA6B                 align 4
.rdata:0000DA6B _rdata          ends
.rdata:0000DA6B
.bss:0000DA6C ; ===========================================================================
.bss:0000DA6C
.bss:0000DA6C ; Segment type: Uninitialized
.bss:0000DA6C ; Segment permissions: Read/Write
.bss:0000DA6C _bss            segment dword public 'BSS' use32
.bss:0000DA6C                 assume cs:_bss
.bss:0000DA6C                 ;org 0DA6Ch
.bss:0000DA6C ; COMDAT (pick any)
.bss:0000DA6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DA6C                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000DA6C ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000DA6C ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000DA6C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000DA6C                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000DA6D                 db    ? ;
.bss:0000DA6E                 db    ? ;
.bss:0000DA6F                 db    ? ;
.bss:0000DA6F _bss            ends
.bss:0000DA6F
.bss:0000DA70 ; ===========================================================================
.bss:0000DA70
.bss:0000DA70 ; Segment type: Uninitialized
.bss:0000DA70 ; Segment permissions: Read/Write
.bss:0000DA70 _bss            segment dword public 'BSS' use32
.bss:0000DA70                 assume cs:_bss
.bss:0000DA70                 ;org 0DA70h
.bss:0000DA70 ; COMDAT (pick any)
.bss:0000DA70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DA70                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000DA70 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000DA70 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000DA70                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000DA70                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000DA71                 db    ? ;
.bss:0000DA72                 db    ? ;
.bss:0000DA73                 db    ? ;
.bss:0000DA73 _bss            ends
.bss:0000DA73
.bss:0000DA74 ; ===========================================================================
.bss:0000DA74
.bss:0000DA74 ; Segment type: Uninitialized
.bss:0000DA74 ; Segment permissions: Read/Write
.bss:0000DA74 _bss            segment dword public 'BSS' use32
.bss:0000DA74                 assume cs:_bss
.bss:0000DA74                 ;org 0DA74h
.bss:0000DA74 ; COMDAT (pick any)
.bss:0000DA74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DA74                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000DA74 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000DA74 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000DA74                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000DA74                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000DA75                 db    ? ;
.bss:0000DA76                 db    ? ;
.bss:0000DA77                 db    ? ;
.bss:0000DA77 _bss            ends
.bss:0000DA77
.rdata:0000DA78 ; ===========================================================================
.rdata:0000DA78
.rdata:0000DA78 ; Segment type: Pure data
.rdata:0000DA78 ; Segment permissions: Read
.rdata:0000DA78 _rdata          segment dword public 'DATA' use32
.rdata:0000DA78                 assume cs:_rdata
.rdata:0000DA78                 ;org 0DA78h
.rdata:0000DA78 ; COMDAT (pick any)
.rdata:0000DA78                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:0000DA78 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:0000DA78 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:0000DA78                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Br
.rdata:0000DA78                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7r ...
.rdata:0000DA78 _rdata          ends
.rdata:0000DA78
.bss:0000DA7C ; ===========================================================================
.bss:0000DA7C
.bss:0000DA7C ; Segment type: Uninitialized
.bss:0000DA7C ; Segment permissions: Read/Write
.bss:0000DA7C _bss            segment dword public 'BSS' use32
.bss:0000DA7C                 assume cs:_bss
.bss:0000DA7C                 ;org 0DA7Ch
.bss:0000DA7C ; COMDAT (pick any)
.bss:0000DA7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DA7C                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000DA7C ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000DA7C ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000DA7C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000DA7D                 db    ? ;
.bss:0000DA7E                 db    ? ;
.bss:0000DA7F                 db    ? ;
.bss:0000DA7F _bss            ends
.bss:0000DA7F
.bss:0000DA80 ; ===========================================================================
.bss:0000DA80
.bss:0000DA80 ; Segment type: Uninitialized
.bss:0000DA80 ; Segment permissions: Read/Write
.bss:0000DA80 _bss            segment dword public 'BSS' use32
.bss:0000DA80                 assume cs:_bss
.bss:0000DA80                 ;org 0DA80h
.bss:0000DA80 ; COMDAT (pick any)
.bss:0000DA80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DA80                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000DA80 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000DA80 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000DA80                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000DA81                 db    ? ;
.bss:0000DA82                 db    ? ;
.bss:0000DA83                 db    ? ;
.bss:0000DA83 _bss            ends
.bss:0000DA83
.rdata:0000DA84 ; ===========================================================================
.rdata:0000DA84
.rdata:0000DA84 ; Segment type: Pure data
.rdata:0000DA84 ; Segment permissions: Read
.rdata:0000DA84 _rdata          segment dword public 'DATA' use32
.rdata:0000DA84                 assume cs:_rdata
.rdata:0000DA84                 ;org 0DA84h
.rdata:0000DA84 ; COMDAT (pick any)
.rdata:0000DA84                 public ??_C@_11LOCGONAA@?$AA?$AA@
.rdata:0000DA84 ; wchar_t `string'
.rdata:0000DA84 ??_C@_11LOCGONAA@?$AA?$AA@ dw 0         ; DATA XREF: Shortcut::Shortcut(wchar_t const *,bool,bool,bool,uchar):loc_64CBo
.rdata:0000DA86                 align 4
.rdata:0000DA86 _rdata          ends
.rdata:0000DA86
.rdata:0000DA88 ; ===========================================================================
.rdata:0000DA88
.rdata:0000DA88 ; Segment type: Pure data
.rdata:0000DA88 ; Segment permissions: Read
.rdata:0000DA88 _rdata          segment dword public 'DATA' use32
.rdata:0000DA88                 assume cs:_rdata
.rdata:0000DA88                 ;org 0DA88h
.rdata:0000DA88 ; COMDAT (pick largest)
.rdata:0000DA88                 dd offset ??_R4Window@@6B@ ; const Window::`RTTI Complete Object Locator'
.rdata:0000DA8C                 public ??_7Window@@6B@
.rdata:0000DA8C ; const Window::`vftable'
.rdata:0000DA8C ??_7Window@@6B@ dd offset ??_EWindow@@UAEPAXI@Z
.rdata:0000DA8C                                         ; DATA XREF: Window::Window(void)+Ao
.rdata:0000DA8C                                         ; Window::~Window(void)+Ao
.rdata:0000DA8C                                         ; Window::`vector deleting destructor'(uint)
.rdata:0000DA90                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000DA94                 dd offset __purecall
.rdata:0000DA98                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:0000DA9C                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000DAA0                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000DAA4                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000DAA8                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000DAAC                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000DAB0                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000DAB4                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000DAB8                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000DAB8 _rdata          ends
.rdata:0000DAB8
.rdata:0000DABC ; ===========================================================================
.rdata:0000DABC
.rdata:0000DABC ; Segment type: Pure data
.rdata:0000DABC ; Segment permissions: Read
.rdata:0000DABC _rdata          segment dword public 'DATA' use32
.rdata:0000DABC                 assume cs:_rdata
.rdata:0000DABC                 ;org 0DABCh
.rdata:0000DABC ; COMDAT (pick largest)
.rdata:0000DABC                 dd offset ??_R4StaticDialog@@6B@ ; const StaticDialog::`RTTI Complete Object Locator'
.rdata:0000DAC0                 public ??_7StaticDialog@@6B@
.rdata:0000DAC0 ; const StaticDialog::`vftable'
.rdata:0000DAC0 ??_7StaticDialog@@6B@ dd offset ??_EStaticDialog@@UAEPAXI@Z
.rdata:0000DAC0                                         ; DATA XREF: StaticDialog::StaticDialog(void)+38o
.rdata:0000DAC0                                         ; StaticDialog::~StaticDialog(void)+29o
.rdata:0000DAC0                                         ; StaticDialog::`vector deleting destructor'(uint)
.rdata:0000DAC4                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000DAC8                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000DACC                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000DAD0                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000DAD4                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000DAD8                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000DADC                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000DAE0                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000DAE4                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000DAE8                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000DAEC                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000DAF0                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000DAF4                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000DAF8                 dd offset __purecall
.rdata:0000DAF8 _rdata          ends
.rdata:0000DAF8
.rdata:0000DAFC ; ===========================================================================
.rdata:0000DAFC
.rdata:0000DAFC ; Segment type: Pure data
.rdata:0000DAFC ; Segment permissions: Read
.rdata:0000DAFC _rdata          segment dword public 'DATA' use32
.rdata:0000DAFC                 assume cs:_rdata
.rdata:0000DAFC                 ;org 0DAFCh
.rdata:0000DAFC ; COMDAT (pick largest)
.rdata:0000DAFC                 dd offset ??_R4Shortcut@@6B@ ; const Shortcut::`RTTI Complete Object Locator'
.rdata:0000DB00                 public ??_7Shortcut@@6B@
.rdata:0000DB00 ; const Shortcut::`vftable'
.rdata:0000DB00 ??_7Shortcut@@6B@ dd offset ??_EShortcut@@UAEPAXI@Z
.rdata:0000DB00                                         ; DATA XREF: Shortcut::Shortcut(Shortcut const &)+38o
.rdata:0000DB00                                         ; Shortcut::Shortcut(wchar_t const *,bool,bool,bool,uchar)+38o
.rdata:0000DB00                                         ; Shortcut::`vector deleting destructor'(uint)
.rdata:0000DB04                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000DB08                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000DB0C                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000DB10                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000DB14                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000DB18                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000DB1C                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000DB20                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000DB24                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000DB28                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000DB2C                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000DB30                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000DB34                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000DB38                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:0000DB3C                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:0000DB40                 dd offset ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.rdata:0000DB44                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:0000DB48                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:0000DB48 _rdata          ends
.rdata:0000DB48
.rdata:0000DB4C ; ===========================================================================
.rdata:0000DB4C
.rdata:0000DB4C ; Segment type: Pure data
.rdata:0000DB4C ; Segment permissions: Read
.rdata:0000DB4C _rdata          segment dword public 'DATA' use32
.rdata:0000DB4C                 assume cs:_rdata
.rdata:0000DB4C                 ;org 0DB4Ch
.rdata:0000DB4C ; COMDAT (pick largest)
.rdata:0000DB4C                 dd offset ??_R4CommandShortcut@@6B@ ; const CommandShortcut::`RTTI Complete Object Locator'
.rdata:0000DB50                 public ??_7CommandShortcut@@6B@
.rdata:0000DB50 ; const CommandShortcut::`vftable'
.rdata:0000DB50 ??_7CommandShortcut@@6B@ dd offset ??_ECommandShortcut@@UAEPAXI@Z
.rdata:0000DB50                                         ; DATA XREF: CommandShortcut::CommandShortcut(CommandShortcut const &)+3Co
.rdata:0000DB50                                         ; CommandShortcut::CommandShortcut(Shortcut,long)+40o
.rdata:0000DB50                                         ; CommandShortcut::`vector deleting destructor'(uint)
.rdata:0000DB54                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000DB58                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000DB5C                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000DB60                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000DB64                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000DB68                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000DB6C                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000DB70                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000DB74                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000DB78                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000DB7C                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000DB80                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000DB84                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000DB88                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:0000DB8C                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:0000DB90                 dd offset ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.rdata:0000DB94                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:0000DB98                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:0000DB98 _rdata          ends
.rdata:0000DB98
.rdata:0000DB9C ; ===========================================================================
.rdata:0000DB9C
.rdata:0000DB9C ; Segment type: Pure data
.rdata:0000DB9C ; Segment permissions: Read
.rdata:0000DB9C _rdata          segment dword public 'DATA' use32
.rdata:0000DB9C                 assume cs:_rdata
.rdata:0000DB9C                 ;org 0DB9Ch
.rdata:0000DB9C ; COMDAT (pick largest)
.rdata:0000DB9C                 dd offset ??_R4PluginCmdShortcut@@6B@ ; const PluginCmdShortcut::`RTTI Complete Object Locator'
.rdata:0000DBA0                 public ??_7PluginCmdShortcut@@6B@
.rdata:0000DBA0 ; const PluginCmdShortcut::`vftable'
.rdata:0000DBA0 ??_7PluginCmdShortcut@@6B@ dd offset ??_EPluginCmdShortcut@@UAEPAXI@Z
.rdata:0000DBA0                                         ; DATA XREF: PluginCmdShortcut::PluginCmdShortcut(PluginCmdShortcut const &)+3Co
.rdata:0000DBA0                                         ; PluginCmdShortcut::PluginCmdShortcut(Shortcut,int,wchar_t const *,ushort)+6Do
.rdata:0000DBA0                                         ; PluginCmdShortcut::`vector deleting destructor'(uint)
.rdata:0000DBA4                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000DBA8                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:0000DBAC                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000DBB0                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:0000DBB4                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000DBB8                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:0000DBBC                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000DBC0                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:0000DBC4                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000DBC8                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:0000DBCC                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000DBD0                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:0000DBD4                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000DBD8                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:0000DBDC                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:0000DBE0                 dd offset ?isValid@PluginCmdShortcut@@UBE_NXZ ; PluginCmdShortcut::isValid(void)
.rdata:0000DBE4                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:0000DBE8                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:0000DBE8 _rdata          ends
.rdata:0000DBE8
.rdata:0000DBEC ; ===========================================================================
.rdata:0000DBEC
.rdata:0000DBEC ; Segment type: Pure data
.rdata:0000DBEC ; Segment permissions: Read
.rdata:0000DBEC _rdata          segment dword public 'DATA' use32
.rdata:0000DBEC                 assume cs:_rdata
.rdata:0000DBEC                 ;org 0DBECh
.rdata:0000DBEC ; COMDAT (pick any)
.rdata:0000DBEC                 public ??_C@_1CA@FEODNHCM@?$AA?5?$AAj?$AAu?$AAs?$AAt?$AA?5?$AAc?$AAr?$AAa?$AAs?$AAh?$AA?5?$AAi?$AAn?$AA?$AN?$AA?$AA@
.rdata:0000DBEC ; const WCHAR `string'
.rdata:0000DBEC ??_C@_1CA@FEODNHCM@?$AA?5?$AAj?$AAu?$AAs?$AAt?$AA?5?$AAc?$AAr?$AAa?$AAs?$AAh?$AA?5?$AAi?$AAn?$AA?$AN?$AA?$AA@:
.rdata:0000DBEC                                         ; DATA XREF: PluginsManager::pluginCrashAlert(wchar_t const *,wchar_t const *)+3Eo
.rdata:0000DBEC                                         ; PluginsManager::pluginCrashAlert(wchar_t const *,wchar_t const *)+59o
.rdata:0000DBEC                 unicode 0, < just crash in>
.rdata:0000DBEC                 dw 0Dh, 0
.rdata:0000DBEC _rdata          ends
.rdata:0000DBEC
.xdata$x:0000DC0C ; ===========================================================================
.xdata$x:0000DC0C
.xdata$x:0000DC0C ; Segment type: Pure data
.xdata$x:0000DC0C ; Segment permissions: Read
.xdata$x:0000DC0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DC0C                 assume cs:_xdata$x
.xdata$x:0000DC0C                 ;org 0DC0Ch
.xdata$x:0000DC0C ; COMDAT (pick any)
.xdata$x:0000DC0C                 public __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.xdata$x:0000DC0C __TI4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ db    0
.xdata$x:0000DC0C                                         ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+111o
.xdata$x:0000DC0C                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+16Ao ...
.xdata$x:0000DC0D                 db    0
.xdata$x:0000DC0E                 db    0
.xdata$x:0000DC0F                 db    0
.xdata$x:0000DC10                 dd offset ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.xdata$x:0000DC14                 align 8
.xdata$x:0000DC18                 dd offset __CTA4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.xdata$x:0000DC18 _xdata$x        ends
.xdata$x:0000DC18
.xdata$x:0000DC1C ; ===========================================================================
.xdata$x:0000DC1C
.xdata$x:0000DC1C ; Segment type: Pure data
.xdata$x:0000DC1C ; Segment permissions: Read
.xdata$x:0000DC1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DC1C                 assume cs:_xdata$x
.xdata$x:0000DC1C                 ;org 0DC1Ch
.xdata$x:0000DC1C ; COMDAT (pick any)
.xdata$x:0000DC1C                 public __CTA4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@
.xdata$x:0000DC1C __CTA4?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ db    4
.xdata$x:0000DC1C                                         ; DATA XREF: .xdata$x:0000DC18o
.xdata$x:0000DC1D                 db    0
.xdata$x:0000DC1E                 db    0
.xdata$x:0000DC1F                 db    0
.xdata$x:0000DC20                 dd offset __CT??_R0?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z28
.xdata$x:0000DC24                 dd offset __CT??_R0?AV?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@@8??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z28
.xdata$x:0000DC28                 dd offset __CT??_R0?AV?$_String_val@U?$_Simple_types@_W@std@@@std@@@8??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z28
.xdata$x:0000DC2C                 dd offset __CT??_R0?AU_Container_base12@std@@@8??0_Container_base12@std@@QAE@ABU01@@Z4
.xdata$x:0000DC2C _xdata$x        ends
.xdata$x:0000DC2C
.data$r:0000DC30 ; ===========================================================================
.data$r:0000DC30
.data$r:0000DC30 ; Segment type: Pure data
.data$r:0000DC30 ; Segment permissions: Read/Write
.data$r:0000DC30 ; Segment alignment 'qword' can not be represented in assembly
.data$r:0000DC30 _data$r         segment para public 'DATA' use32
.data$r:0000DC30                 assume cs:_data$r
.data$r:0000DC30                 ;org 0DC30h
.data$r:0000DC30 ; COMDAT (pick any)
.data$r:0000DC30                 public ??_R0?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
.data$r:0000DC30 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> `RTTI Type Descriptor'
.data$r:0000DC30 ??_R0?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000DC30                                         ; DATA XREF: .xdata$x:0000D330o
.data$r:0000DC30                                         ; .xdata$x:0000DC84o
.data$r:0000DC30                                         ; const type_info::`vftable'
.data$r:0000DC34                 align 8
.data$r:0000DC38 a_?av?Basic_str db '.?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@st'
.data$r:0000DC38                 db 'd@@',0
.data$r:0000DC7D                 align 10h
.data$r:0000DC7D _data$r         ends
.data$r:0000DC7D
.xdata$x:0000DC80 ; ===========================================================================
.xdata$x:0000DC80
.xdata$x:0000DC80 ; Segment type: Pure data
.xdata$x:0000DC80 ; Segment permissions: Read
.xdata$x:0000DC80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DC80                 assume cs:_xdata$x
.xdata$x:0000DC80                 ;org 0DC80h
.xdata$x:0000DC80 ; COMDAT (pick any)
.xdata$x:0000DC80                 public __CT??_R0?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z28
.xdata$x:0000DC80 __CT??_R0?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z28 db    0
.xdata$x:0000DC80                                         ; DATA XREF: .xdata$x:0000DC20o
.xdata$x:0000DC81                 db    0
.xdata$x:0000DC82                 db    0
.xdata$x:0000DC83                 db    0
.xdata$x:0000DC84                 dd offset ??_R0?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> `RTTI Type Descriptor'
.xdata$x:0000DC88                 db    0
.xdata$x:0000DC89                 db    0
.xdata$x:0000DC8A                 db    0
.xdata$x:0000DC8B                 db    0
.xdata$x:0000DC8C                 db 0FFh
.xdata$x:0000DC8D                 db 0FFh
.xdata$x:0000DC8E                 db 0FFh
.xdata$x:0000DC8F                 db 0FFh
.xdata$x:0000DC90                 db    0
.xdata$x:0000DC91                 db    0
.xdata$x:0000DC92                 db    0
.xdata$x:0000DC93                 db    0
.xdata$x:0000DC94                 db  1Ch
.xdata$x:0000DC95                 db    0
.xdata$x:0000DC96                 db    0
.xdata$x:0000DC97                 db    0
.xdata$x:0000DC98                 dd offset ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.xdata$x:0000DC98 _xdata$x        ends
.xdata$x:0000DC98
.data$r:0000DC9C ; ===========================================================================
.data$r:0000DC9C
.data$r:0000DC9C ; Segment type: Pure data
.data$r:0000DC9C ; Segment permissions: Read/Write
.data$r:0000DC9C ; Segment alignment 'qword' can not be represented in assembly
.data$r:0000DC9C _data$r         segment para public 'DATA' use32
.data$r:0000DC9C                 assume cs:_data$r
.data$r:0000DC9C                 ;org 0DC9Ch
.data$r:0000DC9C ; COMDAT (pick any)
.data$r:0000DC9C                 public ??_R0?AV?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@@8
.data$r:0000DC9C ; class std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>> `RTTI Type Descriptor'
.data$r:0000DC9C ??_R0?AV?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000DC9C                                         ; DATA XREF: .xdata$x:0000DCFCo
.data$r:0000DC9C                                         ; const type_info::`vftable'
.data$r:0000DCA0                 db    0
.data$r:0000DCA1                 db    0
.data$r:0000DCA2                 db    0
.data$r:0000DCA3                 db    0
.data$r:0000DCA4                 db  2Eh ; .
.data$r:0000DCA5                 db  3Fh ; ?
.data$r:0000DCA6                 db  41h ; A
.data$r:0000DCA7                 db  56h ; V
.data$r:0000DCA8                 db  3Fh ; ?
.data$r:0000DCA9                 db  24h ; $
.data$r:0000DCAA                 db  5Fh ; _
.data$r:0000DCAB                 db  53h ; S
.data$r:0000DCAC                 db  74h ; t
.data$r:0000DCAD                 db  72h ; r
.data$r:0000DCAE                 db  69h ; i
.data$r:0000DCAF                 db  6Eh ; n
.data$r:0000DCB0                 db  67h ; g
.data$r:0000DCB1                 db  5Fh ; _
.data$r:0000DCB2                 db  61h ; a
.data$r:0000DCB3                 db  6Ch ; l
.data$r:0000DCB4                 db  6Ch ; l
.data$r:0000DCB5                 db  6Fh ; o
.data$r:0000DCB6                 db  63h ; c
.data$r:0000DCB7                 db  40h ; @
.data$r:0000DCB8                 db  24h ; $
.data$r:0000DCB9                 db  30h ; 0
.data$r:0000DCBA                 db  41h ; A
.data$r:0000DCBB                 db  40h ; @
.data$r:0000DCBC                 db  55h ; U
.data$r:0000DCBD                 db  3Fh ; ?
.data$r:0000DCBE                 db  24h ; $
.data$r:0000DCBF                 db  5Fh ; _
.data$r:0000DCC0                 db  53h ; S
.data$r:0000DCC1                 db  74h ; t
.data$r:0000DCC2                 db  72h ; r
.data$r:0000DCC3                 db  69h ; i
.data$r:0000DCC4                 db  6Eh ; n
.data$r:0000DCC5                 db  67h ; g
.data$r:0000DCC6                 db  5Fh ; _
.data$r:0000DCC7                 db  62h ; b
.data$r:0000DCC8                 db  61h ; a
.data$r:0000DCC9                 db  73h ; s
.data$r:0000DCCA                 db  65h ; e
.data$r:0000DCCB                 db  5Fh ; _
.data$r:0000DCCC                 db  74h ; t
.data$r:0000DCCD                 db  79h ; y
.data$r:0000DCCE                 db  70h ; p
.data$r:0000DCCF                 db  65h ; e
.data$r:0000DCD0                 db  73h ; s
.data$r:0000DCD1                 db  40h ; @
.data$r:0000DCD2                 db  5Fh ; _
.data$r:0000DCD3                 db  57h ; W
.data$r:0000DCD4                 db  56h ; V
.data$r:0000DCD5                 db  3Fh ; ?
.data$r:0000DCD6                 db  24h ; $
.data$r:0000DCD7                 db  61h ; a
.data$r:0000DCD8                 db  6Ch ; l
.data$r:0000DCD9                 db  6Ch ; l
.data$r:0000DCDA                 db  6Fh ; o
.data$r:0000DCDB                 db  63h ; c
.data$r:0000DCDC                 db  61h ; a
.data$r:0000DCDD                 db  74h ; t
.data$r:0000DCDE                 db  6Fh ; o
.data$r:0000DCDF                 db  72h ; r
.data$r:0000DCE0                 db  40h ; @
.data$r:0000DCE1                 db  5Fh ; _
.data$r:0000DCE2                 db  57h ; W
.data$r:0000DCE3                 db  40h ; @
.data$r:0000DCE4                 db  73h ; s
.data$r:0000DCE5                 db  74h ; t
.data$r:0000DCE6                 db  64h ; d
.data$r:0000DCE7                 db  40h ; @
.data$r:0000DCE8                 db  40h ; @
.data$r:0000DCE9                 db  40h ; @
.data$r:0000DCEA                 db  73h ; s
.data$r:0000DCEB                 db  74h ; t
.data$r:0000DCEC                 db  64h ; d
.data$r:0000DCED                 db  40h ; @
.data$r:0000DCEE                 db  40h ; @
.data$r:0000DCEF                 db  40h ; @
.data$r:0000DCF0                 db  73h ; s
.data$r:0000DCF1                 db  74h ; t
.data$r:0000DCF2                 db  64h ; d
.data$r:0000DCF3                 db  40h ; @
.data$r:0000DCF4                 db  40h ; @
.data$r:0000DCF5                 db    0
.data$r:0000DCF6                 align 4
.data$r:0000DCF6 _data$r         ends
.data$r:0000DCF6
.xdata$x:0000DCF8 ; ===========================================================================
.xdata$x:0000DCF8
.xdata$x:0000DCF8 ; Segment type: Pure data
.xdata$x:0000DCF8 ; Segment permissions: Read
.xdata$x:0000DCF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DCF8                 assume cs:_xdata$x
.xdata$x:0000DCF8                 ;org 0DCF8h
.xdata$x:0000DCF8 ; COMDAT (pick any)
.xdata$x:0000DCF8                 public __CT??_R0?AV?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@@8??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z28
.xdata$x:0000DCF8 __CT??_R0?AV?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@@8??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z28 db    0
.xdata$x:0000DCF8                                         ; DATA XREF: .xdata$x:0000DC24o
.xdata$x:0000DCF9                 db    0
.xdata$x:0000DCFA                 db    0
.xdata$x:0000DCFB                 db    0
.xdata$x:0000DCFC                 dd offset ??_R0?AV?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@@8 ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>> `RTTI Type Descriptor'
.xdata$x:0000DD00                 db    0
.xdata$x:0000DD01                 db    0
.xdata$x:0000DD02                 db    0
.xdata$x:0000DD03                 db    0
.xdata$x:0000DD04                 db 0FFh
.xdata$x:0000DD05                 db 0FFh
.xdata$x:0000DD06                 db 0FFh
.xdata$x:0000DD07                 db 0FFh
.xdata$x:0000DD08                 db    0
.xdata$x:0000DD09                 db    0
.xdata$x:0000DD0A                 db    0
.xdata$x:0000DD0B                 db    0
.xdata$x:0000DD0C                 db  1Ch
.xdata$x:0000DD0D                 db    0
.xdata$x:0000DD0E                 db    0
.xdata$x:0000DD0F                 db    0
.xdata$x:0000DD10                 dd offset ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>> const &)
.xdata$x:0000DD10 _xdata$x        ends
.xdata$x:0000DD10
.data$r:0000DD14 ; ===========================================================================
.data$r:0000DD14
.data$r:0000DD14 ; Segment type: Pure data
.data$r:0000DD14 ; Segment permissions: Read/Write
.data$r:0000DD14 _data$r         segment dword public 'DATA' use32
.data$r:0000DD14                 assume cs:_data$r
.data$r:0000DD14                 ;org 0DD14h
.data$r:0000DD14 ; COMDAT (pick any)
.data$r:0000DD14                 public ??_R0?AV?$_String_val@U?$_Simple_types@_W@std@@@std@@@8
.data$r:0000DD14 ; class std::_String_val<struct std::_Simple_types<wchar_t>> `RTTI Type Descriptor'
.data$r:0000DD14 ??_R0?AV?$_String_val@U?$_Simple_types@_W@std@@@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000DD14                                         ; DATA XREF: .xdata$x:0000DD54o
.data$r:0000DD14                                         ; const type_info::`vftable'
.data$r:0000DD18                 db    0
.data$r:0000DD19                 db    0
.data$r:0000DD1A                 db    0
.data$r:0000DD1B                 db    0
.data$r:0000DD1C                 db  2Eh ; .
.data$r:0000DD1D                 db  3Fh ; ?
.data$r:0000DD1E                 db  41h ; A
.data$r:0000DD1F                 db  56h ; V
.data$r:0000DD20                 db  3Fh ; ?
.data$r:0000DD21                 db  24h ; $
.data$r:0000DD22                 db  5Fh ; _
.data$r:0000DD23                 db  53h ; S
.data$r:0000DD24                 db  74h ; t
.data$r:0000DD25                 db  72h ; r
.data$r:0000DD26                 db  69h ; i
.data$r:0000DD27                 db  6Eh ; n
.data$r:0000DD28                 db  67h ; g
.data$r:0000DD29                 db  5Fh ; _
.data$r:0000DD2A                 db  76h ; v
.data$r:0000DD2B                 db  61h ; a
.data$r:0000DD2C                 db  6Ch ; l
.data$r:0000DD2D                 db  40h ; @
.data$r:0000DD2E                 db  55h ; U
.data$r:0000DD2F                 db  3Fh ; ?
.data$r:0000DD30                 db  24h ; $
.data$r:0000DD31                 db  5Fh ; _
.data$r:0000DD32                 db  53h ; S
.data$r:0000DD33                 db  69h ; i
.data$r:0000DD34                 db  6Dh ; m
.data$r:0000DD35                 db  70h ; p
.data$r:0000DD36                 db  6Ch ; l
.data$r:0000DD37                 db  65h ; e
.data$r:0000DD38                 db  5Fh ; _
.data$r:0000DD39                 db  74h ; t
.data$r:0000DD3A                 db  79h ; y
.data$r:0000DD3B                 db  70h ; p
.data$r:0000DD3C                 db  65h ; e
.data$r:0000DD3D                 db  73h ; s
.data$r:0000DD3E                 db  40h ; @
.data$r:0000DD3F                 db  5Fh ; _
.data$r:0000DD40                 db  57h ; W
.data$r:0000DD41                 db  40h ; @
.data$r:0000DD42                 db  73h ; s
.data$r:0000DD43                 db  74h ; t
.data$r:0000DD44                 db  64h ; d
.data$r:0000DD45                 db  40h ; @
.data$r:0000DD46                 db  40h ; @
.data$r:0000DD47                 db  40h ; @
.data$r:0000DD48                 db  73h ; s
.data$r:0000DD49                 db  74h ; t
.data$r:0000DD4A                 db  64h ; d
.data$r:0000DD4B                 db  40h ; @
.data$r:0000DD4C                 db  40h ; @
.data$r:0000DD4D                 db    0
.data$r:0000DD4E                 align 10h
.data$r:0000DD4E _data$r         ends
.data$r:0000DD4E
.xdata$x:0000DD50 ; ===========================================================================
.xdata$x:0000DD50
.xdata$x:0000DD50 ; Segment type: Pure data
.xdata$x:0000DD50 ; Segment permissions: Read
.xdata$x:0000DD50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DD50                 assume cs:_xdata$x
.xdata$x:0000DD50                 ;org 0DD50h
.xdata$x:0000DD50 ; COMDAT (pick any)
.xdata$x:0000DD50                 public __CT??_R0?AV?$_String_val@U?$_Simple_types@_W@std@@@std@@@8??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z28
.xdata$x:0000DD50 __CT??_R0?AV?$_String_val@U?$_Simple_types@_W@std@@@std@@@8??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z28 db    0
.xdata$x:0000DD50                                         ; DATA XREF: .xdata$x:0000DC28o
.xdata$x:0000DD51                 db    0
.xdata$x:0000DD52                 db    0
.xdata$x:0000DD53                 db    0
.xdata$x:0000DD54                 dd offset ??_R0?AV?$_String_val@U?$_Simple_types@_W@std@@@std@@@8 ; std::_String_val<std::_Simple_types<wchar_t>> `RTTI Type Descriptor'
.xdata$x:0000DD58                 db    0
.xdata$x:0000DD59                 db    0
.xdata$x:0000DD5A                 db    0
.xdata$x:0000DD5B                 db    0
.xdata$x:0000DD5C                 db 0FFh
.xdata$x:0000DD5D                 db 0FFh
.xdata$x:0000DD5E                 db 0FFh
.xdata$x:0000DD5F                 db 0FFh
.xdata$x:0000DD60                 db    0
.xdata$x:0000DD61                 db    0
.xdata$x:0000DD62                 db    0
.xdata$x:0000DD63                 db    0
.xdata$x:0000DD64                 db  1Ch
.xdata$x:0000DD65                 db    0
.xdata$x:0000DD66                 db    0
.xdata$x:0000DD67                 db    0
.xdata$x:0000DD68                 dd offset ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@ABV01@@Z ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(std::_String_val<std::_Simple_types<wchar_t>> const &)
.xdata$x:0000DD68 _xdata$x        ends
.xdata$x:0000DD68
.data$r:0000DD6C ; ===========================================================================
.data$r:0000DD6C
.data$r:0000DD6C ; Segment type: Pure data
.data$r:0000DD6C ; Segment permissions: Read/Write
.data$r:0000DD6C _data$r         segment dword public 'DATA' use32
.data$r:0000DD6C                 assume cs:_data$r
.data$r:0000DD6C                 ;org 0DD6Ch
.data$r:0000DD6C ; COMDAT (pick any)
.data$r:0000DD6C                 public ??_R0?AU_Container_base12@std@@@8
.data$r:0000DD6C ; struct std::_Container_base12 `RTTI Type Descriptor'
.data$r:0000DD6C ??_R0?AU_Container_base12@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000DD6C                                         ; DATA XREF: .xdata$x:0000DD94o
.data$r:0000DD6C                                         ; const type_info::`vftable'
.data$r:0000DD70                 db    0
.data$r:0000DD71                 db    0
.data$r:0000DD72                 db    0
.data$r:0000DD73                 db    0
.data$r:0000DD74                 db  2Eh ; .
.data$r:0000DD75                 db  3Fh ; ?
.data$r:0000DD76                 db  41h ; A
.data$r:0000DD77                 db  55h ; U
.data$r:0000DD78                 db  5Fh ; _
.data$r:0000DD79                 db  43h ; C
.data$r:0000DD7A                 db  6Fh ; o
.data$r:0000DD7B                 db  6Eh ; n
.data$r:0000DD7C                 db  74h ; t
.data$r:0000DD7D                 db  61h ; a
.data$r:0000DD7E                 db  69h ; i
.data$r:0000DD7F                 db  6Eh ; n
.data$r:0000DD80                 db  65h ; e
.data$r:0000DD81                 db  72h ; r
.data$r:0000DD82                 db  5Fh ; _
.data$r:0000DD83                 db  62h ; b
.data$r:0000DD84                 db  61h ; a
.data$r:0000DD85                 db  73h ; s
.data$r:0000DD86                 db  65h ; e
.data$r:0000DD87                 db  31h ; 1
.data$r:0000DD88                 db  32h ; 2
.data$r:0000DD89                 db  40h ; @
.data$r:0000DD8A                 db  73h ; s
.data$r:0000DD8B                 db  74h ; t
.data$r:0000DD8C                 db  64h ; d
.data$r:0000DD8D                 db  40h ; @
.data$r:0000DD8E                 db  40h ; @
.data$r:0000DD8F                 db    0
.data$r:0000DD8F _data$r         ends
.data$r:0000DD8F
.xdata$x:0000DD90 ; ===========================================================================
.xdata$x:0000DD90
.xdata$x:0000DD90 ; Segment type: Pure data
.xdata$x:0000DD90 ; Segment permissions: Read
.xdata$x:0000DD90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000DD90                 assume cs:_xdata$x
.xdata$x:0000DD90                 ;org 0DD90h
.xdata$x:0000DD90 ; COMDAT (pick any)
.xdata$x:0000DD90                 public __CT??_R0?AU_Container_base12@std@@@8??0_Container_base12@std@@QAE@ABU01@@Z4
.xdata$x:0000DD90 __CT??_R0?AU_Container_base12@std@@@8??0_Container_base12@std@@QAE@ABU01@@Z4 db    0
.xdata$x:0000DD90                                         ; DATA XREF: .xdata$x:0000DC2Co
.xdata$x:0000DD91                 db    0
.xdata$x:0000DD92                 db    0
.xdata$x:0000DD93                 db    0
.xdata$x:0000DD94                 dd offset ??_R0?AU_Container_base12@std@@@8 ; std::_Container_base12 `RTTI Type Descriptor'
.xdata$x:0000DD98                 db    0
.xdata$x:0000DD99                 db    0
.xdata$x:0000DD9A                 db    0
.xdata$x:0000DD9B                 db    0
.xdata$x:0000DD9C                 db 0FFh
.xdata$x:0000DD9D                 db 0FFh
.xdata$x:0000DD9E                 db 0FFh
.xdata$x:0000DD9F                 db 0FFh
.xdata$x:0000DDA0                 db    0
.xdata$x:0000DDA1                 db    0
.xdata$x:0000DDA2                 db    0
.xdata$x:0000DDA3                 db    0
.xdata$x:0000DDA4                 db    4
.xdata$x:0000DDA5                 db    0
.xdata$x:0000DDA6                 db    0
.xdata$x:0000DDA7                 db    0
.xdata$x:0000DDA8                 dd offset ??0_Container_base12@std@@QAE@ABU01@@Z ; std::_Container_base12::_Container_base12(std::_Container_base12 const &)
.xdata$x:0000DDA8 _xdata$x        ends
.xdata$x:0000DDA8
.rdata:0000DDAC ; ===========================================================================
.rdata:0000DDAC
.rdata:0000DDAC ; Segment type: Pure data
.rdata:0000DDAC ; Segment permissions: Read
.rdata:0000DDAC ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000DDAC _rdata          segment para public 'DATA' use32
.rdata:0000DDAC                 assume cs:_rdata
.rdata:0000DDAC                 ;org 0DDACh
.rdata:0000DDAC ; COMDAT (pick any)
.rdata:0000DDAC                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000DDAC ; wchar_t `string'
.rdata:0000DDAC ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000DDAC                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+17o
.rdata:0000DDAC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+Co ...
.rdata:0000DDAC                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000DDAC                 unicode 0, <clude\xstring>,0
.rdata:0000DE3A                 align 4
.rdata:0000DE3A _rdata          ends
.rdata:0000DE3A
.rdata:0000DE3C ; ===========================================================================
.rdata:0000DE3C
.rdata:0000DE3C ; Segment type: Pure data
.rdata:0000DE3C ; Segment permissions: Read
.rdata:0000DE3C _rdata          segment dword public 'DATA' use32
.rdata:0000DE3C                 assume cs:_rdata
.rdata:0000DE3C                 ;org 0DE3Ch
.rdata:0000DE3C ; COMDAT (pick any)
.rdata:0000DE3C                 public ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000DE3C ; wchar_t `string'
.rdata:0000DE3C ??_C@_1DM@GMPLOCPK@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000DE3C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator[](uint)+1Co
.rdata:0000DE3C                 unicode 0, <string subscript out of range>,0
.rdata:0000DE3C _rdata          ends
.rdata:0000DE3C
.bss:0000DE78 ; ===========================================================================
.bss:0000DE78
.bss:0000DE78 ; Segment type: Uninitialized
.bss:0000DE78 ; Segment permissions: Read/Write
.bss:0000DE78 _bss            segment dword public 'BSS' use32
.bss:0000DE78                 assume cs:_bss
.bss:0000DE78                 ;org 0DE78h
.bss:0000DE78 ; COMDAT (pick any)
.bss:0000DE78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DE78                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000DE78 ; std::locale::id std::numpunct<char>::id
.bss:0000DE78 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000DE78                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000DE79                 db    ? ;
.bss:0000DE7A                 db    ? ;
.bss:0000DE7B                 db    ? ;
.bss:0000DE7B _bss            ends
.bss:0000DE7B
.bss:0000DE7C ; ===========================================================================
.bss:0000DE7C
.bss:0000DE7C ; Segment type: Uninitialized
.bss:0000DE7C ; Segment permissions: Read/Write
.bss:0000DE7C _bss            segment dword public 'BSS' use32
.bss:0000DE7C                 assume cs:_bss
.bss:0000DE7C                 ;org 0DE7Ch
.bss:0000DE7C ; COMDAT (pick any)
.bss:0000DE7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000DE7C                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:0000DE7C ; std::locale::id std::numpunct<wchar_t>::id
.bss:0000DE7C ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:0000DE7C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:0000DE7D                 db    ? ;
.bss:0000DE7E                 db    ? ;
.bss:0000DE7F                 db    ? ;
.bss:0000DE7F _bss            ends
.bss:0000DE7F
.rdata:0000DE80 ; ===========================================================================
.rdata:0000DE80
.rdata:0000DE80 ; Segment type: Pure data
.rdata:0000DE80 ; Segment permissions: Read
.rdata:0000DE80 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000DE80 _rdata          segment para public 'DATA' use32
.rdata:0000DE80                 assume cs:_rdata
.rdata:0000DE80                 ;org 0DE80h
.rdata:0000DE80 ; COMDAT (pick any)
.rdata:0000DE80                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000DE80 ; wchar_t `string'
.rdata:0000DE80 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000DE80                                         ; DATA XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+19o
.rdata:0000DE80                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+49o ...
.rdata:0000DE80                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000DE80                 unicode 0, <clude\vector>,0
.rdata:0000DE80 _rdata          ends
.rdata:0000DE80
.rdata:0000DF0C ; ===========================================================================
.rdata:0000DF0C
.rdata:0000DF0C ; Segment type: Pure data
.rdata:0000DF0C ; Segment permissions: Read
.rdata:0000DF0C _rdata          segment dword public 'DATA' use32
.rdata:0000DF0C                 assume cs:_rdata
.rdata:0000DF0C                 ;org 0DF0Ch
.rdata:0000DF0C ; COMDAT (pick any)
.rdata:0000DF0C                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000DF0C ; wchar_t `string'
.rdata:0000DF0C ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000DF0C                                         ; DATA XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+1Eo
.rdata:0000DF0C                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+1Eo ...
.rdata:0000DF0C                 unicode 0, <vector subscript out of range>,0
.rdata:0000DF0C _rdata          ends
.rdata:0000DF0C
.rdata:0000DF48 ; ===========================================================================
.rdata:0000DF48
.rdata:0000DF48 ; Segment type: Pure data
.rdata:0000DF48 ; Segment permissions: Read
.rdata:0000DF48 _rdata          segment dword public 'DATA' use32
.rdata:0000DF48                 assume cs:_rdata
.rdata:0000DF48                 ;org 0DF48h
.rdata:0000DF48 ; COMDAT (pick any)
.rdata:0000DF48                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:0000DF48 ; `string'
.rdata:0000DF48 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:0000DF48                                         ; DATA XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+2Bo
.rdata:0000DF48                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+2Bo ...
.rdata:0000DF48 _rdata          ends
.rdata:0000DF48
.rdata:0000DF6C ; ===========================================================================
.rdata:0000DF6C
.rdata:0000DF6C ; Segment type: Pure data
.rdata:0000DF6C ; Segment permissions: Read
.rdata:0000DF6C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000DF6C _rdata          segment para public 'DATA' use32
.rdata:0000DF6C                 assume cs:_rdata
.rdata:0000DF6C                 ;org 0DF6Ch
.rdata:0000DF6C ; COMDAT (pick any)
.rdata:0000DF6C                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:0000DF6C ; `string'
.rdata:0000DF6C ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:0000DF6C                                         ; DATA XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint):loc_7284o
.rdata:0000DF6C                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint):loc_7314o ...
.rdata:0000DF6C                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000DFC2                 align 4
.rdata:0000DFC2 _rdata          ends
.rdata:0000DFC2
.rdata:0000DFC4 ; ===========================================================================
.rdata:0000DFC4
.rdata:0000DFC4 ; Segment type: Pure data
.rdata:0000DFC4 ; Segment permissions: Read
.rdata:0000DFC4 _rdata          segment dword public 'DATA' use32
.rdata:0000DFC4                 assume cs:_rdata
.rdata:0000DFC4                 ;org 0DFC4h
.rdata:0000DFC4 ; COMDAT (pick any)
.rdata:0000DFC4                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000DFC4 ; `string'
.rdata:0000DFC4 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000DFC4                                         ; DATA XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+3Do
.rdata:0000DFC4                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+3Do ...
.rdata:0000DFC4                 unicode 0, <%s>,0
.rdata:0000DFCA                 align 4
.rdata:0000DFCA _rdata          ends
.rdata:0000DFCA
.rdata:0000DFCC ; ===========================================================================
.rdata:0000DFCC
.rdata:0000DFCC ; Segment type: Pure data
.rdata:0000DFCC ; Segment permissions: Read
.rdata:0000DFCC _rdata          segment dword public 'DATA' use32
.rdata:0000DFCC                 assume cs:_rdata
.rdata:0000DFCC                 ;org 0DFCCh
.rdata:0000DFCC ; COMDAT (pick any)
.rdata:0000DFCC                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000DFCC ; `string'
.rdata:0000DFCC ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000DFCC                                         ; DATA XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+6Fo
.rdata:0000DFCC                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+6Fo ...
.rdata:0000DFCC                 unicode 0, <"out of range">,0
.rdata:0000DFEA                 align 4
.rdata:0000DFEA _rdata          ends
.rdata:0000DFEA
.rdata:0000DFEC ; ===========================================================================
.rdata:0000DFEC
.rdata:0000DFEC ; Segment type: Pure data
.rdata:0000DFEC ; Segment permissions: Read
.rdata:0000DFEC ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000DFEC _rdata          segment para public 'DATA' use32
.rdata:0000DFEC                 assume cs:_rdata
.rdata:0000DFEC                 ;org 0DFECh
.rdata:0000DFEC ; COMDAT (pick any)
.rdata:0000DFEC                 public ??_C@_1BOI@OCMBMPPD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@
.rdata:0000DFEC ; `string'
.rdata:0000DFEC ??_C@_1BOI@OCMBMPPD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAb?$AAa?$AAs?$AAi?$AAc?$AA_?$AAs?$AAt?$AAr@:
.rdata:0000DFEC                                         ; DATA XREF: std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+6Ao
.rdata:0000DFEC                                         ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::operator[](uint)+6Ao
.rdata:0000DFEC                 unicode 0, <std::vector>
.rdata:0000DFEC                 dw 3Ch
.rdata:0000DFEC                 unicode 0, <class std::basic_string>
.rdata:0000DFEC                 dw 3Ch
.rdata:0000DFEC                 unicode 0, <wchar_t,struct std::char_traits>
.rdata:0000DFEC                 dw 3Ch
.rdata:0000DFEC                 unicode 0, <wchar_t>
.rdata:0000DFEC                 dw 3Eh
.rdata:0000DFEC                 unicode 0, <,class std::allocator>
.rdata:0000DFEC                 dw 3Ch
.rdata:0000DFEC                 unicode 0, <wchar_t>
.rdata:0000DFEC                 dw 3Eh
.rdata:0000DFEC                 unicode 0, < >
.rdata:0000DFEC                 dw 3Eh
.rdata:0000DFEC                 unicode 0, <,class std::allocator>
.rdata:0000DFEC                 dw 3Ch
.rdata:0000DFEC                 unicode 0, <class std::basic_string>
.rdata:0000DFEC                 dw 3Ch
.rdata:0000DFEC                 unicode 0, <wchar_t,struct std::char_traits>
.rdata:0000DFEC                 dw 3Ch
.rdata:0000DFEC                 unicode 0, <wchar_t>
.rdata:0000DFEC                 dw 3Eh
.rdata:0000DFEC                 unicode 0, <,class std::allocator>
.rdata:0000DFEC                 dw 3Ch
.rdata:0000DFEC                 unicode 0, <wchar_t>
.rdata:0000DFEC                 dw 3Eh
.rdata:0000DFEC                 unicode 0, < >
.rdata:0000DFEC                 dw 3Eh
.rdata:0000DFEC                 unicode 0, < >
.rdata:0000DFEC                 dw 3Eh
.rdata:0000DFEC                 unicode 0, < >
.rdata:0000DFEC                 dw 3Eh
.rdata:0000DFEC                 unicode 0, <::operator []>,0
.rdata:0000DFEC _rdata          ends
.rdata:0000DFEC
.rdata:0000E1D4 ; ===========================================================================
.rdata:0000E1D4
.rdata:0000E1D4 ; Segment type: Pure data
.rdata:0000E1D4 ; Segment permissions: Read
.rdata:0000E1D4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E1D4 _rdata          segment para public 'DATA' use32
.rdata:0000E1D4                 assume cs:_rdata
.rdata:0000E1D4                 ;org 0E1D4h
.rdata:0000E1D4 ; COMDAT (pick any)
.rdata:0000E1D4                 public ??_C@_1MC@MGKONNEA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAC?$AAm?$AAd?$AAS?$AAh?$AAo?$AAr?$AAt@
.rdata:0000E1D4 ; `string'
.rdata:0000E1D4 ??_C@_1MC@MGKONNEA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAC?$AAm?$AAd?$AAS?$AAh?$AAo?$AAr?$AAt@:
.rdata:0000E1D4                                         ; DATA XREF: std::vector<PluginCmdShortcut,std::allocator<PluginCmdShortcut>>::operator[](uint)+6Ao
.rdata:0000E1D4                 unicode 0, <std::vector>
.rdata:0000E1D4                 dw 3Ch
.rdata:0000E1D4                 unicode 0, <class PluginCmdShortcut,class std::allocator>
.rdata:0000E1D4                 dw 3Ch
.rdata:0000E1D4                 unicode 0, <class PluginCmdShortcut>
.rdata:0000E1D4                 dw 3Eh
.rdata:0000E1D4                 unicode 0, < >
.rdata:0000E1D4                 dw 3Eh
.rdata:0000E1D4                 unicode 0, <::operator []>,0
.rdata:0000E296                 align 4
.rdata:0000E296 _rdata          ends
.rdata:0000E296
.rdata:0000E298 ; ===========================================================================
.rdata:0000E298
.rdata:0000E298 ; Segment type: Pure data
.rdata:0000E298 ; Segment permissions: Read
.rdata:0000E298 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E298 _rdata          segment para public 'DATA' use32
.rdata:0000E298                 assume cs:_rdata
.rdata:0000E298                 ;org 0E298h
.rdata:0000E298 ; COMDAT (pick any)
.rdata:0000E298                 public ??_C@_1LC@MEDJDKJA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAI?$AAn?$AAf?$AAo?$AA?5?$AA?$CK?$AA?0@
.rdata:0000E298 ; `string'
.rdata:0000E298 ??_C@_1LC@MEDJDKJA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAI?$AAn?$AAf?$AAo?$AA?5?$AA?$CK?$AA?0@:
.rdata:0000E298                                         ; DATA XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+6Ao
.rdata:0000E298                 unicode 0, <std::vector>
.rdata:0000E298                 dw 3Ch
.rdata:0000E298                 unicode 0, <struct PluginInfo *,class std::allocator>
.rdata:0000E298                 dw 3Ch
.rdata:0000E298                 unicode 0, <struct PluginInfo *>
.rdata:0000E298                 dw 3Eh
.rdata:0000E298                 unicode 0, < >
.rdata:0000E298                 dw 3Eh
.rdata:0000E298                 unicode 0, <::operator []>,0
.rdata:0000E34A                 align 4
.rdata:0000E34A _rdata          ends
.rdata:0000E34A
.rdata:0000E34C ; ===========================================================================
.rdata:0000E34C
.rdata:0000E34C ; Segment type: Pure data
.rdata:0000E34C ; Segment permissions: Read
.rdata:0000E34C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E34C _rdata          segment para public 'DATA' use32
.rdata:0000E34C                 assume cs:_rdata
.rdata:0000E34C                 ;org 0E34Ch
.rdata:0000E34C ; COMDAT (pick any)
.rdata:0000E34C                 public ??_C@_1LG@PIMEHHBL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd@
.rdata:0000E34C ; `string'
.rdata:0000E34C ??_C@_1LG@PIMEHHBL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAP?$AAl?$AAu?$AAg?$AAi?$AAn?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd@:
.rdata:0000E34C                                         ; DATA XREF: std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+6Ao
.rdata:0000E34C                 unicode 0, <std::vector>
.rdata:0000E34C                 dw 3Ch
.rdata:0000E34C                 unicode 0, <struct PluginCommand,class std::allocator>
.rdata:0000E34C                 dw 3Ch
.rdata:0000E34C                 unicode 0, <struct PluginCommand>
.rdata:0000E34C                 dw 3Eh
.rdata:0000E34C                 unicode 0, < >
.rdata:0000E34C                 dw 3Eh
.rdata:0000E34C                 unicode 0, <::operator []>,0
.rdata:0000E402                 align 4
.rdata:0000E402 _rdata          ends
.rdata:0000E402
.rdata:0000E404 ; ===========================================================================
.rdata:0000E404
.rdata:0000E404 ; Segment type: Pure data
.rdata:0000E404 ; Segment permissions: Read
.rdata:0000E404 _rdata          segment dword public 'DATA' use32
.rdata:0000E404                 assume cs:_rdata
.rdata:0000E404                 ;org 0E404h
.rdata:0000E404 ; COMDAT (pick any)
.rdata:0000E404                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000E404 ; char `string'[]
.rdata:0000E404 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000E404                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000E404                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:0000E404 _rdata          ends
.rdata:0000E404
.rdata:0000E414 ; ===========================================================================
.rdata:0000E414
.rdata:0000E414 ; Segment type: Pure data
.rdata:0000E414 ; Segment permissions: Read
.rdata:0000E414 _rdata          segment dword public 'DATA' use32
.rdata:0000E414                 assume cs:_rdata
.rdata:0000E414                 ;org 0E414h
.rdata:0000E414 ; COMDAT (pick any)
.rdata:0000E414                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000E414 ; char `string'[]
.rdata:0000E414 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000E414                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000E414                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:0000E414 _rdata          ends
.rdata:0000E414
.rdata:0000E42C ; ===========================================================================
.rdata:0000E42C
.rdata:0000E42C ; Segment type: Pure data
.rdata:0000E42C ; Segment permissions: Read
.rdata:0000E42C _rdata          segment dword public 'DATA' use32
.rdata:0000E42C                 assume cs:_rdata
.rdata:0000E42C                 ;org 0E42Ch
.rdata:0000E42C ; COMDAT (pick any)
.rdata:0000E42C                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000E42C ; char `string'[]
.rdata:0000E42C ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000E42C                                         ; DATA XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Xlen(void)+7o
.rdata:0000E42C                                         ; std::vector<TiXmlDocument *,std::allocator<TiXmlDocument *>>::_Xlen(void)+7o ...
.rdata:0000E43F                 align 10h
.rdata:0000E43F _rdata          ends
.rdata:0000E43F
.rdata:0000E440 ; ===========================================================================
.rdata:0000E440
.rdata:0000E440 ; Segment type: Pure data
.rdata:0000E440 ; Segment permissions: Read
.rdata:0000E440 _rdata          segment dword public 'DATA' use32
.rdata:0000E440                 assume cs:_rdata
.rdata:0000E440                 ;org 0E440h
.rdata:0000E440 ; COMDAT (pick any)
.rdata:0000E440                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000E440 ; wchar_t `string'
.rdata:0000E440 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000E440                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000E440                                         ; std::_Debug_pointer<PluginInfo *>(PluginInfo * *,wchar_t const *,uint)+11o ...
.rdata:0000E440                 unicode 0, <invalid null pointer>,0
.rdata:0000E46A                 align 4
.rdata:0000E46A _rdata          ends
.rdata:0000E46A
.rdata:0000E46C ; ===========================================================================
.rdata:0000E46C
.rdata:0000E46C ; Segment type: Pure data
.rdata:0000E46C ; Segment permissions: Read
.rdata:0000E46C _rdata          segment dword public 'DATA' use32
.rdata:0000E46C                 assume cs:_rdata
.rdata:0000E46C                 ;org 0E46Ch
.rdata:0000E46C ; COMDAT (pick any)
.rdata:0000E46C                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000E46C ; wchar_t `string'
.rdata:0000E46C ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000E46C                                         ; DATA XREF: std::_Debug_range2<PluginInfo * *>(PluginInfo * *,PluginInfo * *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000E46C                                         ; std::_Debug_range2<TiXmlDocument * *>(TiXmlDocument * *,TiXmlDocument * *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:0000E46C                 unicode 0, <invalid iterator range>,0
.rdata:0000E49A                 align 4
.rdata:0000E49A _rdata          ends
.rdata:0000E49A
.rdata:0000E49C ; ===========================================================================
.rdata:0000E49C
.rdata:0000E49C ; Segment type: Pure data
.rdata:0000E49C ; Segment permissions: Read
.rdata:0000E49C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000E49C _rdata          segment para public 'DATA' use32
.rdata:0000E49C                 assume cs:_rdata
.rdata:0000E49C                 ;org 0E49Ch
.rdata:0000E49C ; COMDAT (pick any)
.rdata:0000E49C                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000E49C ; wchar_t `string'
.rdata:0000E49C ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000E49C                                         ; DATA XREF: std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag)+2Fo
.rdata:0000E49C                                         ; std::_Uninit_move<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>(std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Wrap_alloc<std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool>>> &,std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,bool> *,std::_Nonscalar_ptr_iterator_tag)+49o ...
.rdata:0000E49C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000E49C                 unicode 0, <clude\xmemory>,0
.rdata:0000E52A                 align 4
.rdata:0000E52A _rdata          ends
.rdata:0000E52A
.rdata$r:0000E52C ; ===========================================================================
.rdata$r:0000E52C
.rdata$r:0000E52C ; Segment type: Pure data
.rdata$r:0000E52C ; Segment permissions: Read
.rdata$r:0000E52C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E52C                 assume cs:_rdata$r
.rdata$r:0000E52C                 ;org 0E52Ch
.rdata$r:0000E52C ; COMDAT (pick any)
.rdata$r:0000E52C                 public ??_R4error_category@std@@6B@
.rdata$r:0000E52C ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000E52C ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000D9B8o
.rdata$r:0000E52D                 db    0
.rdata$r:0000E52E                 db    0
.rdata$r:0000E52F                 db    0
.rdata$r:0000E530                 db    0
.rdata$r:0000E531                 db    0
.rdata$r:0000E532                 db    0
.rdata$r:0000E533                 db    0
.rdata$r:0000E534                 db    0
.rdata$r:0000E535                 db    0
.rdata$r:0000E536                 db    0
.rdata$r:0000E537                 db    0
.rdata$r:0000E538                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000E53C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E53C _rdata$r        ends
.rdata$r:0000E53C
.data$r:0000E540 ; ===========================================================================
.data$r:0000E540
.data$r:0000E540 ; Segment type: Pure data
.data$r:0000E540 ; Segment permissions: Read/Write
.data$r:0000E540 _data$r         segment dword public 'DATA' use32
.data$r:0000E540                 assume cs:_data$r
.data$r:0000E540                 ;org 0E540h
.data$r:0000E540 ; COMDAT (pick any)
.data$r:0000E540                 public ??_R0?AVerror_category@std@@@8
.data$r:0000E540 ; class std::error_category `RTTI Type Descriptor'
.data$r:0000E540 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E540                                         ; DATA XREF: .rdata$r:0000E538o
.data$r:0000E540                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E540                                         ; const type_info::`vftable'
.data$r:0000E544                 align 8
.data$r:0000E548 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:0000E561                 align 4
.data$r:0000E561 _data$r         ends
.data$r:0000E561
.rdata$r:0000E564 ; ===========================================================================
.rdata$r:0000E564
.rdata$r:0000E564 ; Segment type: Pure data
.rdata$r:0000E564 ; Segment permissions: Read
.rdata$r:0000E564 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E564                 assume cs:_rdata$r
.rdata$r:0000E564                 ;org 0E564h
.rdata$r:0000E564 ; COMDAT (pick any)
.rdata$r:0000E564                 public ??_R3error_category@std@@8
.rdata$r:0000E564 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E564 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000E53Co
.rdata$r:0000E564                                         ; .rdata$r:0000E594o
.rdata$r:0000E565                 db    0
.rdata$r:0000E566                 db    0
.rdata$r:0000E567                 db    0
.rdata$r:0000E568                 db    0
.rdata$r:0000E569                 db    0
.rdata$r:0000E56A                 db    0
.rdata$r:0000E56B                 db    0
.rdata$r:0000E56C                 db    1
.rdata$r:0000E56D                 db    0
.rdata$r:0000E56E                 db    0
.rdata$r:0000E56F                 db    0
.rdata$r:0000E570                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000E570 _rdata$r        ends
.rdata$r:0000E570
.rdata$r:0000E574 ; ===========================================================================
.rdata$r:0000E574
.rdata$r:0000E574 ; Segment type: Pure data
.rdata$r:0000E574 ; Segment permissions: Read
.rdata$r:0000E574 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E574                 assume cs:_rdata$r
.rdata$r:0000E574                 ;org 0E574h
.rdata$r:0000E574 ; COMDAT (pick any)
.rdata$r:0000E574                 public ??_R2error_category@std@@8
.rdata$r:0000E574 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000E574 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000E574                                         ; DATA XREF: .rdata$r:0000E570o
.rdata$r:0000E574                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E578                 db    0
.rdata$r:0000E579                 align 4
.rdata$r:0000E579 _rdata$r        ends
.rdata$r:0000E579
.rdata$r:0000E57C ; ===========================================================================
.rdata$r:0000E57C
.rdata$r:0000E57C ; Segment type: Pure data
.rdata$r:0000E57C ; Segment permissions: Read
.rdata$r:0000E57C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E57C                 assume cs:_rdata$r
.rdata$r:0000E57C                 ;org 0E57Ch
.rdata$r:0000E57C ; COMDAT (pick any)
.rdata$r:0000E57C                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000E57C ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E57C ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000E57C                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000E57C                                         ; .rdata$r:0000E5ECo ...
.rdata$r:0000E57C                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000E580                 db    0
.rdata$r:0000E581                 db    0
.rdata$r:0000E582                 db    0
.rdata$r:0000E583                 db    0
.rdata$r:0000E584                 db    0
.rdata$r:0000E585                 db    0
.rdata$r:0000E586                 db    0
.rdata$r:0000E587                 db    0
.rdata$r:0000E588                 db 0FFh
.rdata$r:0000E589                 db 0FFh
.rdata$r:0000E58A                 db 0FFh
.rdata$r:0000E58B                 db 0FFh
.rdata$r:0000E58C                 db    0
.rdata$r:0000E58D                 db    0
.rdata$r:0000E58E                 db    0
.rdata$r:0000E58F                 db    0
.rdata$r:0000E590                 db  40h ; @
.rdata$r:0000E591                 db    0
.rdata$r:0000E592                 db    0
.rdata$r:0000E593                 db    0
.rdata$r:0000E594                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E594 _rdata$r        ends
.rdata$r:0000E594
.rdata$r:0000E598 ; ===========================================================================
.rdata$r:0000E598
.rdata$r:0000E598 ; Segment type: Pure data
.rdata$r:0000E598 ; Segment permissions: Read
.rdata$r:0000E598 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E598                 assume cs:_rdata$r
.rdata$r:0000E598                 ;org 0E598h
.rdata$r:0000E598 ; COMDAT (pick any)
.rdata$r:0000E598                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000E598 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000E598 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000E598                                         ; DATA XREF: .rdata:0000D9D4o
.rdata$r:0000E599                 db    0
.rdata$r:0000E59A                 db    0
.rdata$r:0000E59B                 db    0
.rdata$r:0000E59C                 db    0
.rdata$r:0000E59D                 db    0
.rdata$r:0000E59E                 db    0
.rdata$r:0000E59F                 db    0
.rdata$r:0000E5A0                 db    0
.rdata$r:0000E5A1                 db    0
.rdata$r:0000E5A2                 db    0
.rdata$r:0000E5A3                 db    0
.rdata$r:0000E5A4                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000E5A8                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E5A8 _rdata$r        ends
.rdata$r:0000E5A8
.data$r:0000E5AC ; ===========================================================================
.data$r:0000E5AC
.data$r:0000E5AC ; Segment type: Pure data
.data$r:0000E5AC ; Segment permissions: Read/Write
.data$r:0000E5AC _data$r         segment dword public 'DATA' use32
.data$r:0000E5AC                 assume cs:_data$r
.data$r:0000E5AC                 ;org 0E5ACh
.data$r:0000E5AC ; COMDAT (pick any)
.data$r:0000E5AC                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000E5AC ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000E5AC ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E5AC                                         ; DATA XREF: .rdata$r:0000E5A4o
.data$r:0000E5AC                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E5AC                                         ; const type_info::`vftable'
.data$r:0000E5B0                 db    0
.data$r:0000E5B1                 db    0
.data$r:0000E5B2                 db    0
.data$r:0000E5B3                 db    0
.data$r:0000E5B4                 db  2Eh ; .
.data$r:0000E5B5                 db  3Fh ; ?
.data$r:0000E5B6                 db  41h ; A
.data$r:0000E5B7                 db  56h ; V
.data$r:0000E5B8                 db  5Fh ; _
.data$r:0000E5B9                 db  47h ; G
.data$r:0000E5BA                 db  65h ; e
.data$r:0000E5BB                 db  6Eh ; n
.data$r:0000E5BC                 db  65h ; e
.data$r:0000E5BD                 db  72h ; r
.data$r:0000E5BE                 db  69h ; i
.data$r:0000E5BF                 db  63h ; c
.data$r:0000E5C0                 db  5Fh ; _
.data$r:0000E5C1                 db  65h ; e
.data$r:0000E5C2                 db  72h ; r
.data$r:0000E5C3                 db  72h ; r
.data$r:0000E5C4                 db  6Fh ; o
.data$r:0000E5C5                 db  72h ; r
.data$r:0000E5C6                 db  5Fh ; _
.data$r:0000E5C7                 db  63h ; c
.data$r:0000E5C8                 db  61h ; a
.data$r:0000E5C9                 db  74h ; t
.data$r:0000E5CA                 db  65h ; e
.data$r:0000E5CB                 db  67h ; g
.data$r:0000E5CC                 db  6Fh ; o
.data$r:0000E5CD                 db  72h ; r
.data$r:0000E5CE                 db  79h ; y
.data$r:0000E5CF                 db  40h ; @
.data$r:0000E5D0                 db  73h ; s
.data$r:0000E5D1                 db  74h ; t
.data$r:0000E5D2                 db  64h ; d
.data$r:0000E5D3                 db  40h ; @
.data$r:0000E5D4                 db  40h ; @
.data$r:0000E5D5                 db    0
.data$r:0000E5D6                 align 4
.data$r:0000E5D6 _data$r         ends
.data$r:0000E5D6
.rdata$r:0000E5D8 ; ===========================================================================
.rdata$r:0000E5D8
.rdata$r:0000E5D8 ; Segment type: Pure data
.rdata$r:0000E5D8 ; Segment permissions: Read
.rdata$r:0000E5D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E5D8                 assume cs:_rdata$r
.rdata$r:0000E5D8                 ;org 0E5D8h
.rdata$r:0000E5D8 ; COMDAT (pick any)
.rdata$r:0000E5D8                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000E5D8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E5D8 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000E5D8                                         ; DATA XREF: .rdata$r:0000E5A8o
.rdata$r:0000E5D8                                         ; .rdata$r:0000E60Co
.rdata$r:0000E5D9                 db    0
.rdata$r:0000E5DA                 db    0
.rdata$r:0000E5DB                 db    0
.rdata$r:0000E5DC                 db    0
.rdata$r:0000E5DD                 db    0
.rdata$r:0000E5DE                 db    0
.rdata$r:0000E5DF                 db    0
.rdata$r:0000E5E0                 db    2
.rdata$r:0000E5E1                 db    0
.rdata$r:0000E5E2                 db    0
.rdata$r:0000E5E3                 db    0
.rdata$r:0000E5E4                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000E5E4 _rdata$r        ends
.rdata$r:0000E5E4
.rdata$r:0000E5E8 ; ===========================================================================
.rdata$r:0000E5E8
.rdata$r:0000E5E8 ; Segment type: Pure data
.rdata$r:0000E5E8 ; Segment permissions: Read
.rdata$r:0000E5E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E5E8                 assume cs:_rdata$r
.rdata$r:0000E5E8                 ;org 0E5E8h
.rdata$r:0000E5E8 ; COMDAT (pick any)
.rdata$r:0000E5E8                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000E5E8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000E5E8 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000E5E8                                         ; DATA XREF: .rdata$r:0000E5E4o
.rdata$r:0000E5E8                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E5EC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E5F0                 db    0
.rdata$r:0000E5F1                 align 4
.rdata$r:0000E5F1 _rdata$r        ends
.rdata$r:0000E5F1
.rdata$r:0000E5F4 ; ===========================================================================
.rdata$r:0000E5F4
.rdata$r:0000E5F4 ; Segment type: Pure data
.rdata$r:0000E5F4 ; Segment permissions: Read
.rdata$r:0000E5F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E5F4                 assume cs:_rdata$r
.rdata$r:0000E5F4                 ;org 0E5F4h
.rdata$r:0000E5F4 ; COMDAT (pick any)
.rdata$r:0000E5F4                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000E5F4 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E5F4 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000E5F4                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000E5F4                                         ; .rdata$r:0000E664o ...
.rdata$r:0000E5F4                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000E5F8                 db    1
.rdata$r:0000E5F9                 db    0
.rdata$r:0000E5FA                 db    0
.rdata$r:0000E5FB                 db    0
.rdata$r:0000E5FC                 db    0
.rdata$r:0000E5FD                 db    0
.rdata$r:0000E5FE                 db    0
.rdata$r:0000E5FF                 db    0
.rdata$r:0000E600                 db 0FFh
.rdata$r:0000E601                 db 0FFh
.rdata$r:0000E602                 db 0FFh
.rdata$r:0000E603                 db 0FFh
.rdata$r:0000E604                 db    0
.rdata$r:0000E605                 db    0
.rdata$r:0000E606                 db    0
.rdata$r:0000E607                 db    0
.rdata$r:0000E608                 db  40h ; @
.rdata$r:0000E609                 db    0
.rdata$r:0000E60A                 db    0
.rdata$r:0000E60B                 db    0
.rdata$r:0000E60C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E60C _rdata$r        ends
.rdata$r:0000E60C
.rdata$r:0000E610 ; ===========================================================================
.rdata$r:0000E610
.rdata$r:0000E610 ; Segment type: Pure data
.rdata$r:0000E610 ; Segment permissions: Read
.rdata$r:0000E610 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E610                 assume cs:_rdata$r
.rdata$r:0000E610                 ;org 0E610h
.rdata$r:0000E610 ; COMDAT (pick any)
.rdata$r:0000E610                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000E610 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000E610 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000E610                                         ; DATA XREF: .rdata:0000DA08o
.rdata$r:0000E611                 db    0
.rdata$r:0000E612                 db    0
.rdata$r:0000E613                 db    0
.rdata$r:0000E614                 db    0
.rdata$r:0000E615                 db    0
.rdata$r:0000E616                 db    0
.rdata$r:0000E617                 db    0
.rdata$r:0000E618                 db    0
.rdata$r:0000E619                 db    0
.rdata$r:0000E61A                 db    0
.rdata$r:0000E61B                 db    0
.rdata$r:0000E61C                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000E620                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E620 _rdata$r        ends
.rdata$r:0000E620
.data$r:0000E624 ; ===========================================================================
.data$r:0000E624
.data$r:0000E624 ; Segment type: Pure data
.data$r:0000E624 ; Segment permissions: Read/Write
.data$r:0000E624 _data$r         segment dword public 'DATA' use32
.data$r:0000E624                 assume cs:_data$r
.data$r:0000E624                 ;org 0E624h
.data$r:0000E624 ; COMDAT (pick any)
.data$r:0000E624                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000E624 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000E624 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E624                                         ; DATA XREF: .rdata$r:0000E61Co
.data$r:0000E624                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E624                                         ; const type_info::`vftable'
.data$r:0000E628                 db    0
.data$r:0000E629                 db    0
.data$r:0000E62A                 db    0
.data$r:0000E62B                 db    0
.data$r:0000E62C                 db  2Eh ; .
.data$r:0000E62D                 db  3Fh ; ?
.data$r:0000E62E                 db  41h ; A
.data$r:0000E62F                 db  56h ; V
.data$r:0000E630                 db  5Fh ; _
.data$r:0000E631                 db  49h ; I
.data$r:0000E632                 db  6Fh ; o
.data$r:0000E633                 db  73h ; s
.data$r:0000E634                 db  74h ; t
.data$r:0000E635                 db  72h ; r
.data$r:0000E636                 db  65h ; e
.data$r:0000E637                 db  61h ; a
.data$r:0000E638                 db  6Dh ; m
.data$r:0000E639                 db  5Fh ; _
.data$r:0000E63A                 db  65h ; e
.data$r:0000E63B                 db  72h ; r
.data$r:0000E63C                 db  72h ; r
.data$r:0000E63D                 db  6Fh ; o
.data$r:0000E63E                 db  72h ; r
.data$r:0000E63F                 db  5Fh ; _
.data$r:0000E640                 db  63h ; c
.data$r:0000E641                 db  61h ; a
.data$r:0000E642                 db  74h ; t
.data$r:0000E643                 db  65h ; e
.data$r:0000E644                 db  67h ; g
.data$r:0000E645                 db  6Fh ; o
.data$r:0000E646                 db  72h ; r
.data$r:0000E647                 db  79h ; y
.data$r:0000E648                 db  40h ; @
.data$r:0000E649                 db  73h ; s
.data$r:0000E64A                 db  74h ; t
.data$r:0000E64B                 db  64h ; d
.data$r:0000E64C                 db  40h ; @
.data$r:0000E64D                 db  40h ; @
.data$r:0000E64E                 db    0
.data$r:0000E64F                 align 10h
.data$r:0000E64F _data$r         ends
.data$r:0000E64F
.rdata$r:0000E650 ; ===========================================================================
.rdata$r:0000E650
.rdata$r:0000E650 ; Segment type: Pure data
.rdata$r:0000E650 ; Segment permissions: Read
.rdata$r:0000E650 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E650                 assume cs:_rdata$r
.rdata$r:0000E650                 ;org 0E650h
.rdata$r:0000E650 ; COMDAT (pick any)
.rdata$r:0000E650                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000E650 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E650 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000E650                                         ; DATA XREF: .rdata$r:0000E620o
.rdata$r:0000E650                                         ; .rdata$r:0000E688o
.rdata$r:0000E651                 db    0
.rdata$r:0000E652                 db    0
.rdata$r:0000E653                 db    0
.rdata$r:0000E654                 db    0
.rdata$r:0000E655                 db    0
.rdata$r:0000E656                 db    0
.rdata$r:0000E657                 db    0
.rdata$r:0000E658                 db    3
.rdata$r:0000E659                 db    0
.rdata$r:0000E65A                 db    0
.rdata$r:0000E65B                 db    0
.rdata$r:0000E65C                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000E65C _rdata$r        ends
.rdata$r:0000E65C
.rdata$r:0000E660 ; ===========================================================================
.rdata$r:0000E660
.rdata$r:0000E660 ; Segment type: Pure data
.rdata$r:0000E660 ; Segment permissions: Read
.rdata$r:0000E660 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E660                 assume cs:_rdata$r
.rdata$r:0000E660                 ;org 0E660h
.rdata$r:0000E660 ; COMDAT (pick any)
.rdata$r:0000E660                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000E660 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000E660 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000E660                                         ; DATA XREF: .rdata$r:0000E65Co
.rdata$r:0000E660                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E664                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E668                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E66C                 db    0
.rdata$r:0000E66D                 align 10h
.rdata$r:0000E66D _rdata$r        ends
.rdata$r:0000E66D
.rdata$r:0000E670 ; ===========================================================================
.rdata$r:0000E670
.rdata$r:0000E670 ; Segment type: Pure data
.rdata$r:0000E670 ; Segment permissions: Read
.rdata$r:0000E670 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E670                 assume cs:_rdata$r
.rdata$r:0000E670                 ;org 0E670h
.rdata$r:0000E670 ; COMDAT (pick any)
.rdata$r:0000E670                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000E670 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E670 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000E670                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000E670                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000E674                 db    2
.rdata$r:0000E675                 db    0
.rdata$r:0000E676                 db    0
.rdata$r:0000E677                 db    0
.rdata$r:0000E678                 db    0
.rdata$r:0000E679                 db    0
.rdata$r:0000E67A                 db    0
.rdata$r:0000E67B                 db    0
.rdata$r:0000E67C                 db 0FFh
.rdata$r:0000E67D                 db 0FFh
.rdata$r:0000E67E                 db 0FFh
.rdata$r:0000E67F                 db 0FFh
.rdata$r:0000E680                 db    0
.rdata$r:0000E681                 db    0
.rdata$r:0000E682                 db    0
.rdata$r:0000E683                 db    0
.rdata$r:0000E684                 db  40h ; @
.rdata$r:0000E685                 db    0
.rdata$r:0000E686                 db    0
.rdata$r:0000E687                 db    0
.rdata$r:0000E688                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E688 _rdata$r        ends
.rdata$r:0000E688
.rdata$r:0000E68C ; ===========================================================================
.rdata$r:0000E68C
.rdata$r:0000E68C ; Segment type: Pure data
.rdata$r:0000E68C ; Segment permissions: Read
.rdata$r:0000E68C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E68C                 assume cs:_rdata$r
.rdata$r:0000E68C                 ;org 0E68Ch
.rdata$r:0000E68C ; COMDAT (pick any)
.rdata$r:0000E68C                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000E68C ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000E68C ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000DA48o
.rdata$r:0000E68D                 db    0
.rdata$r:0000E68E                 db    0
.rdata$r:0000E68F                 db    0
.rdata$r:0000E690                 db    0
.rdata$r:0000E691                 db    0
.rdata$r:0000E692                 db    0
.rdata$r:0000E693                 db    0
.rdata$r:0000E694                 db    0
.rdata$r:0000E695                 db    0
.rdata$r:0000E696                 db    0
.rdata$r:0000E697                 db    0
.rdata$r:0000E698                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000E69C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E69C _rdata$r        ends
.rdata$r:0000E69C
.data$r:0000E6A0 ; ===========================================================================
.data$r:0000E6A0
.data$r:0000E6A0 ; Segment type: Pure data
.data$r:0000E6A0 ; Segment permissions: Read/Write
.data$r:0000E6A0 _data$r         segment dword public 'DATA' use32
.data$r:0000E6A0                 assume cs:_data$r
.data$r:0000E6A0                 ;org 0E6A0h
.data$r:0000E6A0 ; COMDAT (pick any)
.data$r:0000E6A0                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000E6A0 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000E6A0 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E6A0                                         ; DATA XREF: .rdata$r:0000E698o
.data$r:0000E6A0                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E6A0                                         ; const type_info::`vftable'
.data$r:0000E6A4                 align 8
.data$r:0000E6A8 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:0000E6C9                 align 4
.data$r:0000E6C9 _data$r         ends
.data$r:0000E6C9
.rdata$r:0000E6CC ; ===========================================================================
.rdata$r:0000E6CC
.rdata$r:0000E6CC ; Segment type: Pure data
.rdata$r:0000E6CC ; Segment permissions: Read
.rdata$r:0000E6CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E6CC                 assume cs:_rdata$r
.rdata$r:0000E6CC                 ;org 0E6CCh
.rdata$r:0000E6CC ; COMDAT (pick any)
.rdata$r:0000E6CC                 public ??_R3_System_error_category@std@@8
.rdata$r:0000E6CC ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E6CC ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000E69Co
.rdata$r:0000E6CC                                         ; .rdata$r:0000E704o
.rdata$r:0000E6CD                 db    0
.rdata$r:0000E6CE                 db    0
.rdata$r:0000E6CF                 db    0
.rdata$r:0000E6D0                 db    0
.rdata$r:0000E6D1                 db    0
.rdata$r:0000E6D2                 db    0
.rdata$r:0000E6D3                 db    0
.rdata$r:0000E6D4                 db    3
.rdata$r:0000E6D5                 db    0
.rdata$r:0000E6D6                 db    0
.rdata$r:0000E6D7                 db    0
.rdata$r:0000E6D8                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000E6D8 _rdata$r        ends
.rdata$r:0000E6D8
.rdata$r:0000E6DC ; ===========================================================================
.rdata$r:0000E6DC
.rdata$r:0000E6DC ; Segment type: Pure data
.rdata$r:0000E6DC ; Segment permissions: Read
.rdata$r:0000E6DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E6DC                 assume cs:_rdata$r
.rdata$r:0000E6DC                 ;org 0E6DCh
.rdata$r:0000E6DC ; COMDAT (pick any)
.rdata$r:0000E6DC                 public ??_R2_System_error_category@std@@8
.rdata$r:0000E6DC ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000E6DC ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000E6DC                                         ; DATA XREF: .rdata$r:0000E6D8o
.rdata$r:0000E6DC                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E6E0                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E6E4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E6E8                 db    0
.rdata$r:0000E6E9                 align 4
.rdata$r:0000E6E9 _rdata$r        ends
.rdata$r:0000E6E9
.rdata$r:0000E6EC ; ===========================================================================
.rdata$r:0000E6EC
.rdata$r:0000E6EC ; Segment type: Pure data
.rdata$r:0000E6EC ; Segment permissions: Read
.rdata$r:0000E6EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E6EC                 assume cs:_rdata$r
.rdata$r:0000E6EC                 ;org 0E6ECh
.rdata$r:0000E6EC ; COMDAT (pick any)
.rdata$r:0000E6EC                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000E6EC ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E6EC ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0000E6EC                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0000E6EC                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000E6F0                 db    2
.rdata$r:0000E6F1                 db    0
.rdata$r:0000E6F2                 db    0
.rdata$r:0000E6F3                 db    0
.rdata$r:0000E6F4                 db    0
.rdata$r:0000E6F5                 db    0
.rdata$r:0000E6F6                 db    0
.rdata$r:0000E6F7                 db    0
.rdata$r:0000E6F8                 db 0FFh
.rdata$r:0000E6F9                 db 0FFh
.rdata$r:0000E6FA                 db 0FFh
.rdata$r:0000E6FB                 db 0FFh
.rdata$r:0000E6FC                 db    0
.rdata$r:0000E6FD                 db    0
.rdata$r:0000E6FE                 db    0
.rdata$r:0000E6FF                 db    0
.rdata$r:0000E700                 db  40h ; @
.rdata$r:0000E701                 db    0
.rdata$r:0000E702                 db    0
.rdata$r:0000E703                 db    0
.rdata$r:0000E704                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E704 _rdata$r        ends
.rdata$r:0000E704
.rdata$r:0000E708 ; ===========================================================================
.rdata$r:0000E708
.rdata$r:0000E708 ; Segment type: Pure data
.rdata$r:0000E708 ; Segment permissions: Read
.rdata$r:0000E708 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E708                 assume cs:_rdata$r
.rdata$r:0000E708                 ;org 0E708h
.rdata$r:0000E708 ; COMDAT (pick any)
.rdata$r:0000E708                 public ??_R4Window@@6B@
.rdata$r:0000E708 ; const Window::`RTTI Complete Object Locator'
.rdata$r:0000E708 ??_R4Window@@6B@ db    0                ; DATA XREF: .rdata:0000DA88o
.rdata$r:0000E709                 db    0
.rdata$r:0000E70A                 db    0
.rdata$r:0000E70B                 db    0
.rdata$r:0000E70C                 db    0
.rdata$r:0000E70D                 db    0
.rdata$r:0000E70E                 db    0
.rdata$r:0000E70F                 db    0
.rdata$r:0000E710                 db    0
.rdata$r:0000E711                 db    0
.rdata$r:0000E712                 db    0
.rdata$r:0000E713                 db    0
.rdata$r:0000E714                 dd offset ??_R0?AVWindow@@@8 ; Window `RTTI Type Descriptor'
.rdata$r:0000E718                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E718 _rdata$r        ends
.rdata$r:0000E718
.data$r:0000E71C ; ===========================================================================
.data$r:0000E71C
.data$r:0000E71C ; Segment type: Pure data
.data$r:0000E71C ; Segment permissions: Read/Write
.data$r:0000E71C _data$r         segment dword public 'DATA' use32
.data$r:0000E71C                 assume cs:_data$r
.data$r:0000E71C                 ;org 0E71Ch
.data$r:0000E71C ; COMDAT (pick any)
.data$r:0000E71C                 public ??_R0?AVWindow@@@8
.data$r:0000E71C ; class Window `RTTI Type Descriptor'
.data$r:0000E71C ??_R0?AVWindow@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E71C                                         ; DATA XREF: .rdata$r:0000E714o
.data$r:0000E71C                                         ; .rdata$r:Window::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E71C                                         ; const type_info::`vftable'
.data$r:0000E720                 db    0
.data$r:0000E721                 db    0
.data$r:0000E722                 db    0
.data$r:0000E723                 db    0
.data$r:0000E724                 db  2Eh ; .
.data$r:0000E725                 db  3Fh ; ?
.data$r:0000E726                 db  41h ; A
.data$r:0000E727                 db  56h ; V
.data$r:0000E728                 db  57h ; W
.data$r:0000E729                 db  69h ; i
.data$r:0000E72A                 db  6Eh ; n
.data$r:0000E72B                 db  64h ; d
.data$r:0000E72C                 db  6Fh ; o
.data$r:0000E72D                 db  77h ; w
.data$r:0000E72E                 db  40h ; @
.data$r:0000E72F                 db  40h ; @
.data$r:0000E730                 db    0
.data$r:0000E731                 align 4
.data$r:0000E731 _data$r         ends
.data$r:0000E731
.rdata$r:0000E734 ; ===========================================================================
.rdata$r:0000E734
.rdata$r:0000E734 ; Segment type: Pure data
.rdata$r:0000E734 ; Segment permissions: Read
.rdata$r:0000E734 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E734                 assume cs:_rdata$r
.rdata$r:0000E734                 ;org 0E734h
.rdata$r:0000E734 ; COMDAT (pick any)
.rdata$r:0000E734                 public ??_R3Window@@8
.rdata$r:0000E734 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E734 ??_R3Window@@8  db    0                 ; DATA XREF: .rdata$r:0000E718o
.rdata$r:0000E734                                         ; .rdata$r:0000E764o
.rdata$r:0000E735                 db    0
.rdata$r:0000E736                 db    0
.rdata$r:0000E737                 db    0
.rdata$r:0000E738                 db    0
.rdata$r:0000E739                 db    0
.rdata$r:0000E73A                 db    0
.rdata$r:0000E73B                 db    0
.rdata$r:0000E73C                 db    1
.rdata$r:0000E73D                 db    0
.rdata$r:0000E73E                 db    0
.rdata$r:0000E73F                 db    0
.rdata$r:0000E740                 dd offset ??_R2Window@@8 ; Window::`RTTI Base Class Array'
.rdata$r:0000E740 _rdata$r        ends
.rdata$r:0000E740
.rdata$r:0000E744 ; ===========================================================================
.rdata$r:0000E744
.rdata$r:0000E744 ; Segment type: Pure data
.rdata$r:0000E744 ; Segment permissions: Read
.rdata$r:0000E744 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E744                 assume cs:_rdata$r
.rdata$r:0000E744                 ;org 0E744h
.rdata$r:0000E744 ; COMDAT (pick any)
.rdata$r:0000E744                 public ??_R2Window@@8
.rdata$r:0000E744 ; Window::`RTTI Base Class Array'
.rdata$r:0000E744 ??_R2Window@@8  dd offset ??_R1A@?0A@EA@Window@@8
.rdata$r:0000E744                                         ; DATA XREF: .rdata$r:0000E740o
.rdata$r:0000E744                                         ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E748                 db    0
.rdata$r:0000E749                 align 4
.rdata$r:0000E749 _rdata$r        ends
.rdata$r:0000E749
.rdata$r:0000E74C ; ===========================================================================
.rdata$r:0000E74C
.rdata$r:0000E74C ; Segment type: Pure data
.rdata$r:0000E74C ; Segment permissions: Read
.rdata$r:0000E74C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E74C                 assume cs:_rdata$r
.rdata$r:0000E74C                 ;org 0E74Ch
.rdata$r:0000E74C ; COMDAT (pick any)
.rdata$r:0000E74C                 public ??_R1A@?0A@EA@Window@@8
.rdata$r:0000E74C ; Window::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E74C ??_R1A@?0A@EA@Window@@8 dd offset ??_R0?AVWindow@@@8
.rdata$r:0000E74C                                         ; DATA XREF: .rdata$r:Window::`RTTI Base Class Array'o
.rdata$r:0000E74C                                         ; .rdata$r:0000E7ACo ...
.rdata$r:0000E74C                                         ; Window `RTTI Type Descriptor'
.rdata$r:0000E750                 db    0
.rdata$r:0000E751                 db    0
.rdata$r:0000E752                 db    0
.rdata$r:0000E753                 db    0
.rdata$r:0000E754                 db    0
.rdata$r:0000E755                 db    0
.rdata$r:0000E756                 db    0
.rdata$r:0000E757                 db    0
.rdata$r:0000E758                 db 0FFh
.rdata$r:0000E759                 db 0FFh
.rdata$r:0000E75A                 db 0FFh
.rdata$r:0000E75B                 db 0FFh
.rdata$r:0000E75C                 db    0
.rdata$r:0000E75D                 db    0
.rdata$r:0000E75E                 db    0
.rdata$r:0000E75F                 db    0
.rdata$r:0000E760                 db  40h ; @
.rdata$r:0000E761                 db    0
.rdata$r:0000E762                 db    0
.rdata$r:0000E763                 db    0
.rdata$r:0000E764                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E764 _rdata$r        ends
.rdata$r:0000E764
.rdata$r:0000E768 ; ===========================================================================
.rdata$r:0000E768
.rdata$r:0000E768 ; Segment type: Pure data
.rdata$r:0000E768 ; Segment permissions: Read
.rdata$r:0000E768 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E768                 assume cs:_rdata$r
.rdata$r:0000E768                 ;org 0E768h
.rdata$r:0000E768 ; COMDAT (pick any)
.rdata$r:0000E768                 public ??_R4StaticDialog@@6B@
.rdata$r:0000E768 ; const StaticDialog::`RTTI Complete Object Locator'
.rdata$r:0000E768 ??_R4StaticDialog@@6B@ db    0          ; DATA XREF: .rdata:0000DABCo
.rdata$r:0000E769                 db    0
.rdata$r:0000E76A                 db    0
.rdata$r:0000E76B                 db    0
.rdata$r:0000E76C                 db    0
.rdata$r:0000E76D                 db    0
.rdata$r:0000E76E                 db    0
.rdata$r:0000E76F                 db    0
.rdata$r:0000E770                 db    0
.rdata$r:0000E771                 db    0
.rdata$r:0000E772                 db    0
.rdata$r:0000E773                 db    0
.rdata$r:0000E774                 dd offset ??_R0?AVStaticDialog@@@8 ; StaticDialog `RTTI Type Descriptor'
.rdata$r:0000E778                 dd offset ??_R3StaticDialog@@8 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E778 _rdata$r        ends
.rdata$r:0000E778
.data$r:0000E77C ; ===========================================================================
.data$r:0000E77C
.data$r:0000E77C ; Segment type: Pure data
.data$r:0000E77C ; Segment permissions: Read/Write
.data$r:0000E77C _data$r         segment dword public 'DATA' use32
.data$r:0000E77C                 assume cs:_data$r
.data$r:0000E77C                 ;org 0E77Ch
.data$r:0000E77C ; COMDAT (pick any)
.data$r:0000E77C                 public ??_R0?AVStaticDialog@@@8
.data$r:0000E77C ; class StaticDialog `RTTI Type Descriptor'
.data$r:0000E77C ??_R0?AVStaticDialog@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E77C                                         ; DATA XREF: .rdata$r:0000E774o
.data$r:0000E77C                                         ; .rdata$r:StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E77C                                         ; const type_info::`vftable'
.data$r:0000E780                 db    0
.data$r:0000E781                 db    0
.data$r:0000E782                 db    0
.data$r:0000E783                 db    0
.data$r:0000E784                 db  2Eh ; .
.data$r:0000E785                 db  3Fh ; ?
.data$r:0000E786                 db  41h ; A
.data$r:0000E787                 db  56h ; V
.data$r:0000E788                 db  53h ; S
.data$r:0000E789                 db  74h ; t
.data$r:0000E78A                 db  61h ; a
.data$r:0000E78B                 db  74h ; t
.data$r:0000E78C                 db  69h ; i
.data$r:0000E78D                 db  63h ; c
.data$r:0000E78E                 db  44h ; D
.data$r:0000E78F                 db  69h ; i
.data$r:0000E790                 db  61h ; a
.data$r:0000E791                 db  6Ch ; l
.data$r:0000E792                 db  6Fh ; o
.data$r:0000E793                 db  67h ; g
.data$r:0000E794                 db  40h ; @
.data$r:0000E795                 db  40h ; @
.data$r:0000E796                 db    0
.data$r:0000E797                 align 4
.data$r:0000E797 _data$r         ends
.data$r:0000E797
.rdata$r:0000E798 ; ===========================================================================
.rdata$r:0000E798
.rdata$r:0000E798 ; Segment type: Pure data
.rdata$r:0000E798 ; Segment permissions: Read
.rdata$r:0000E798 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E798                 assume cs:_rdata$r
.rdata$r:0000E798                 ;org 0E798h
.rdata$r:0000E798 ; COMDAT (pick any)
.rdata$r:0000E798                 public ??_R3StaticDialog@@8
.rdata$r:0000E798 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E798 ??_R3StaticDialog@@8 db    0            ; DATA XREF: .rdata$r:0000E778o
.rdata$r:0000E798                                         ; .rdata$r:0000E7CCo
.rdata$r:0000E799                 db    0
.rdata$r:0000E79A                 db    0
.rdata$r:0000E79B                 db    0
.rdata$r:0000E79C                 db    0
.rdata$r:0000E79D                 db    0
.rdata$r:0000E79E                 db    0
.rdata$r:0000E79F                 db    0
.rdata$r:0000E7A0                 db    2
.rdata$r:0000E7A1                 db    0
.rdata$r:0000E7A2                 db    0
.rdata$r:0000E7A3                 db    0
.rdata$r:0000E7A4                 dd offset ??_R2StaticDialog@@8 ; StaticDialog::`RTTI Base Class Array'
.rdata$r:0000E7A4 _rdata$r        ends
.rdata$r:0000E7A4
.rdata$r:0000E7A8 ; ===========================================================================
.rdata$r:0000E7A8
.rdata$r:0000E7A8 ; Segment type: Pure data
.rdata$r:0000E7A8 ; Segment permissions: Read
.rdata$r:0000E7A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E7A8                 assume cs:_rdata$r
.rdata$r:0000E7A8                 ;org 0E7A8h
.rdata$r:0000E7A8 ; COMDAT (pick any)
.rdata$r:0000E7A8                 public ??_R2StaticDialog@@8
.rdata$r:0000E7A8 ; StaticDialog::`RTTI Base Class Array'
.rdata$r:0000E7A8 ??_R2StaticDialog@@8 dd offset ??_R1A@?0A@EA@StaticDialog@@8
.rdata$r:0000E7A8                                         ; DATA XREF: .rdata$r:0000E7A4o
.rdata$r:0000E7A8                                         ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E7AC                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E7B0                 db    0
.rdata$r:0000E7B1                 align 4
.rdata$r:0000E7B1 _rdata$r        ends
.rdata$r:0000E7B1
.rdata$r:0000E7B4 ; ===========================================================================
.rdata$r:0000E7B4
.rdata$r:0000E7B4 ; Segment type: Pure data
.rdata$r:0000E7B4 ; Segment permissions: Read
.rdata$r:0000E7B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E7B4                 assume cs:_rdata$r
.rdata$r:0000E7B4                 ;org 0E7B4h
.rdata$r:0000E7B4 ; COMDAT (pick any)
.rdata$r:0000E7B4                 public ??_R1A@?0A@EA@StaticDialog@@8
.rdata$r:0000E7B4 ; StaticDialog::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E7B4 ??_R1A@?0A@EA@StaticDialog@@8 dd offset ??_R0?AVStaticDialog@@@8
.rdata$r:0000E7B4                                         ; DATA XREF: .rdata$r:StaticDialog::`RTTI Base Class Array'o
.rdata$r:0000E7B4                                         ; .rdata$r:0000E810o ...
.rdata$r:0000E7B4                                         ; StaticDialog `RTTI Type Descriptor'
.rdata$r:0000E7B8                 db    1
.rdata$r:0000E7B9                 db    0
.rdata$r:0000E7BA                 db    0
.rdata$r:0000E7BB                 db    0
.rdata$r:0000E7BC                 db    0
.rdata$r:0000E7BD                 db    0
.rdata$r:0000E7BE                 db    0
.rdata$r:0000E7BF                 db    0
.rdata$r:0000E7C0                 db 0FFh
.rdata$r:0000E7C1                 db 0FFh
.rdata$r:0000E7C2                 db 0FFh
.rdata$r:0000E7C3                 db 0FFh
.rdata$r:0000E7C4                 db    0
.rdata$r:0000E7C5                 db    0
.rdata$r:0000E7C6                 db    0
.rdata$r:0000E7C7                 db    0
.rdata$r:0000E7C8                 db  40h ; @
.rdata$r:0000E7C9                 db    0
.rdata$r:0000E7CA                 db    0
.rdata$r:0000E7CB                 db    0
.rdata$r:0000E7CC                 dd offset ??_R3StaticDialog@@8 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E7CC _rdata$r        ends
.rdata$r:0000E7CC
.rdata$r:0000E7D0 ; ===========================================================================
.rdata$r:0000E7D0
.rdata$r:0000E7D0 ; Segment type: Pure data
.rdata$r:0000E7D0 ; Segment permissions: Read
.rdata$r:0000E7D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E7D0                 assume cs:_rdata$r
.rdata$r:0000E7D0                 ;org 0E7D0h
.rdata$r:0000E7D0 ; COMDAT (pick any)
.rdata$r:0000E7D0                 public ??_R4Shortcut@@6B@
.rdata$r:0000E7D0 ; const Shortcut::`RTTI Complete Object Locator'
.rdata$r:0000E7D0 ??_R4Shortcut@@6B@ db    0              ; DATA XREF: .rdata:0000DAFCo
.rdata$r:0000E7D1                 db    0
.rdata$r:0000E7D2                 db    0
.rdata$r:0000E7D3                 db    0
.rdata$r:0000E7D4                 db    0
.rdata$r:0000E7D5                 db    0
.rdata$r:0000E7D6                 db    0
.rdata$r:0000E7D7                 db    0
.rdata$r:0000E7D8                 db    0
.rdata$r:0000E7D9                 db    0
.rdata$r:0000E7DA                 db    0
.rdata$r:0000E7DB                 db    0
.rdata$r:0000E7DC                 dd offset ??_R0?AVShortcut@@@8 ; Shortcut `RTTI Type Descriptor'
.rdata$r:0000E7E0                 dd offset ??_R3Shortcut@@8 ; Shortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E7E0 _rdata$r        ends
.rdata$r:0000E7E0
.data$r:0000E7E4 ; ===========================================================================
.data$r:0000E7E4
.data$r:0000E7E4 ; Segment type: Pure data
.data$r:0000E7E4 ; Segment permissions: Read/Write
.data$r:0000E7E4 _data$r         segment dword public 'DATA' use32
.data$r:0000E7E4                 assume cs:_data$r
.data$r:0000E7E4                 ;org 0E7E4h
.data$r:0000E7E4 ; COMDAT (pick any)
.data$r:0000E7E4                 public ??_R0?AVShortcut@@@8
.data$r:0000E7E4 ; class Shortcut `RTTI Type Descriptor'
.data$r:0000E7E4 ??_R0?AVShortcut@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E7E4                                         ; DATA XREF: .rdata$r:0000E7DCo
.data$r:0000E7E4                                         ; .rdata$r:Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E7E4                                         ; const type_info::`vftable'
.data$r:0000E7E8                 db    0
.data$r:0000E7E9                 db    0
.data$r:0000E7EA                 db    0
.data$r:0000E7EB                 db    0
.data$r:0000E7EC                 db  2Eh ; .
.data$r:0000E7ED                 db  3Fh ; ?
.data$r:0000E7EE                 db  41h ; A
.data$r:0000E7EF                 db  56h ; V
.data$r:0000E7F0                 db  53h ; S
.data$r:0000E7F1                 db  68h ; h
.data$r:0000E7F2                 db  6Fh ; o
.data$r:0000E7F3                 db  72h ; r
.data$r:0000E7F4                 db  74h ; t
.data$r:0000E7F5                 db  63h ; c
.data$r:0000E7F6                 db  75h ; u
.data$r:0000E7F7                 db  74h ; t
.data$r:0000E7F8                 db  40h ; @
.data$r:0000E7F9                 db  40h ; @
.data$r:0000E7FA                 db    0
.data$r:0000E7FB                 align 4
.data$r:0000E7FB _data$r         ends
.data$r:0000E7FB
.rdata$r:0000E7FC ; ===========================================================================
.rdata$r:0000E7FC
.rdata$r:0000E7FC ; Segment type: Pure data
.rdata$r:0000E7FC ; Segment permissions: Read
.rdata$r:0000E7FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E7FC                 assume cs:_rdata$r
.rdata$r:0000E7FC                 ;org 0E7FCh
.rdata$r:0000E7FC ; COMDAT (pick any)
.rdata$r:0000E7FC                 public ??_R3Shortcut@@8
.rdata$r:0000E7FC ; Shortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E7FC ??_R3Shortcut@@8 db    0                ; DATA XREF: .rdata$r:0000E7E0o
.rdata$r:0000E7FC                                         ; .rdata$r:0000E834o
.rdata$r:0000E7FD                 db    0
.rdata$r:0000E7FE                 db    0
.rdata$r:0000E7FF                 db    0
.rdata$r:0000E800                 db    0
.rdata$r:0000E801                 db    0
.rdata$r:0000E802                 db    0
.rdata$r:0000E803                 db    0
.rdata$r:0000E804                 db    3
.rdata$r:0000E805                 db    0
.rdata$r:0000E806                 db    0
.rdata$r:0000E807                 db    0
.rdata$r:0000E808                 dd offset ??_R2Shortcut@@8 ; Shortcut::`RTTI Base Class Array'
.rdata$r:0000E808 _rdata$r        ends
.rdata$r:0000E808
.rdata$r:0000E80C ; ===========================================================================
.rdata$r:0000E80C
.rdata$r:0000E80C ; Segment type: Pure data
.rdata$r:0000E80C ; Segment permissions: Read
.rdata$r:0000E80C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E80C                 assume cs:_rdata$r
.rdata$r:0000E80C                 ;org 0E80Ch
.rdata$r:0000E80C ; COMDAT (pick any)
.rdata$r:0000E80C                 public ??_R2Shortcut@@8
.rdata$r:0000E80C ; Shortcut::`RTTI Base Class Array'
.rdata$r:0000E80C ??_R2Shortcut@@8 dd offset ??_R1A@?0A@EA@Shortcut@@8
.rdata$r:0000E80C                                         ; DATA XREF: .rdata$r:0000E808o
.rdata$r:0000E80C                                         ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E810                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E814                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E818                 db    0
.rdata$r:0000E819                 align 4
.rdata$r:0000E819 _rdata$r        ends
.rdata$r:0000E819
.rdata$r:0000E81C ; ===========================================================================
.rdata$r:0000E81C
.rdata$r:0000E81C ; Segment type: Pure data
.rdata$r:0000E81C ; Segment permissions: Read
.rdata$r:0000E81C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E81C                 assume cs:_rdata$r
.rdata$r:0000E81C                 ;org 0E81Ch
.rdata$r:0000E81C ; COMDAT (pick any)
.rdata$r:0000E81C                 public ??_R1A@?0A@EA@Shortcut@@8
.rdata$r:0000E81C ; Shortcut::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E81C ??_R1A@?0A@EA@Shortcut@@8 dd offset ??_R0?AVShortcut@@@8
.rdata$r:0000E81C                                         ; DATA XREF: .rdata$r:Shortcut::`RTTI Base Class Array'o
.rdata$r:0000E81C                                         ; .rdata$r:0000E880o ...
.rdata$r:0000E81C                                         ; Shortcut `RTTI Type Descriptor'
.rdata$r:0000E820                 db    2
.rdata$r:0000E821                 db    0
.rdata$r:0000E822                 db    0
.rdata$r:0000E823                 db    0
.rdata$r:0000E824                 db    0
.rdata$r:0000E825                 db    0
.rdata$r:0000E826                 db    0
.rdata$r:0000E827                 db    0
.rdata$r:0000E828                 db 0FFh
.rdata$r:0000E829                 db 0FFh
.rdata$r:0000E82A                 db 0FFh
.rdata$r:0000E82B                 db 0FFh
.rdata$r:0000E82C                 db    0
.rdata$r:0000E82D                 db    0
.rdata$r:0000E82E                 db    0
.rdata$r:0000E82F                 db    0
.rdata$r:0000E830                 db  40h ; @
.rdata$r:0000E831                 db    0
.rdata$r:0000E832                 db    0
.rdata$r:0000E833                 db    0
.rdata$r:0000E834                 dd offset ??_R3Shortcut@@8 ; Shortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E834 _rdata$r        ends
.rdata$r:0000E834
.rdata$r:0000E838 ; ===========================================================================
.rdata$r:0000E838
.rdata$r:0000E838 ; Segment type: Pure data
.rdata$r:0000E838 ; Segment permissions: Read
.rdata$r:0000E838 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E838                 assume cs:_rdata$r
.rdata$r:0000E838                 ;org 0E838h
.rdata$r:0000E838 ; COMDAT (pick any)
.rdata$r:0000E838                 public ??_R4CommandShortcut@@6B@
.rdata$r:0000E838 ; const CommandShortcut::`RTTI Complete Object Locator'
.rdata$r:0000E838 ??_R4CommandShortcut@@6B@ db    0       ; DATA XREF: .rdata:0000DB4Co
.rdata$r:0000E839                 db    0
.rdata$r:0000E83A                 db    0
.rdata$r:0000E83B                 db    0
.rdata$r:0000E83C                 db    0
.rdata$r:0000E83D                 db    0
.rdata$r:0000E83E                 db    0
.rdata$r:0000E83F                 db    0
.rdata$r:0000E840                 db    0
.rdata$r:0000E841                 db    0
.rdata$r:0000E842                 db    0
.rdata$r:0000E843                 db    0
.rdata$r:0000E844                 dd offset ??_R0?AVCommandShortcut@@@8 ; CommandShortcut `RTTI Type Descriptor'
.rdata$r:0000E848                 dd offset ??_R3CommandShortcut@@8 ; CommandShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E848 _rdata$r        ends
.rdata$r:0000E848
.data$r:0000E84C ; ===========================================================================
.data$r:0000E84C
.data$r:0000E84C ; Segment type: Pure data
.data$r:0000E84C ; Segment permissions: Read/Write
.data$r:0000E84C _data$r         segment dword public 'DATA' use32
.data$r:0000E84C                 assume cs:_data$r
.data$r:0000E84C                 ;org 0E84Ch
.data$r:0000E84C ; COMDAT (pick any)
.data$r:0000E84C                 public ??_R0?AVCommandShortcut@@@8
.data$r:0000E84C ; class CommandShortcut `RTTI Type Descriptor'
.data$r:0000E84C ??_R0?AVCommandShortcut@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E84C                                         ; DATA XREF: .rdata$r:0000E844o
.data$r:0000E84C                                         ; .rdata$r:CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E84C                                         ; const type_info::`vftable'
.data$r:0000E850                 db    0
.data$r:0000E851                 db    0
.data$r:0000E852                 db    0
.data$r:0000E853                 db    0
.data$r:0000E854                 db  2Eh ; .
.data$r:0000E855                 db  3Fh ; ?
.data$r:0000E856                 db  41h ; A
.data$r:0000E857                 db  56h ; V
.data$r:0000E858                 db  43h ; C
.data$r:0000E859                 db  6Fh ; o
.data$r:0000E85A                 db  6Dh ; m
.data$r:0000E85B                 db  6Dh ; m
.data$r:0000E85C                 db  61h ; a
.data$r:0000E85D                 db  6Eh ; n
.data$r:0000E85E                 db  64h ; d
.data$r:0000E85F                 db  53h ; S
.data$r:0000E860                 db  68h ; h
.data$r:0000E861                 db  6Fh ; o
.data$r:0000E862                 db  72h ; r
.data$r:0000E863                 db  74h ; t
.data$r:0000E864                 db  63h ; c
.data$r:0000E865                 db  75h ; u
.data$r:0000E866                 db  74h ; t
.data$r:0000E867                 db  40h ; @
.data$r:0000E868                 db  40h ; @
.data$r:0000E869                 db    0
.data$r:0000E86A                 align 4
.data$r:0000E86A _data$r         ends
.data$r:0000E86A
.rdata$r:0000E86C ; ===========================================================================
.rdata$r:0000E86C
.rdata$r:0000E86C ; Segment type: Pure data
.rdata$r:0000E86C ; Segment permissions: Read
.rdata$r:0000E86C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E86C                 assume cs:_rdata$r
.rdata$r:0000E86C                 ;org 0E86Ch
.rdata$r:0000E86C ; COMDAT (pick any)
.rdata$r:0000E86C                 public ??_R3CommandShortcut@@8
.rdata$r:0000E86C ; CommandShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E86C ??_R3CommandShortcut@@8 db    0         ; DATA XREF: .rdata$r:0000E848o
.rdata$r:0000E86C                                         ; .rdata$r:0000E8A8o
.rdata$r:0000E86D                 db    0
.rdata$r:0000E86E                 db    0
.rdata$r:0000E86F                 db    0
.rdata$r:0000E870                 db    0
.rdata$r:0000E871                 db    0
.rdata$r:0000E872                 db    0
.rdata$r:0000E873                 db    0
.rdata$r:0000E874                 db    4
.rdata$r:0000E875                 db    0
.rdata$r:0000E876                 db    0
.rdata$r:0000E877                 db    0
.rdata$r:0000E878                 dd offset ??_R2CommandShortcut@@8 ; CommandShortcut::`RTTI Base Class Array'
.rdata$r:0000E878 _rdata$r        ends
.rdata$r:0000E878
.rdata$r:0000E87C ; ===========================================================================
.rdata$r:0000E87C
.rdata$r:0000E87C ; Segment type: Pure data
.rdata$r:0000E87C ; Segment permissions: Read
.rdata$r:0000E87C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E87C                 assume cs:_rdata$r
.rdata$r:0000E87C                 ;org 0E87Ch
.rdata$r:0000E87C ; COMDAT (pick any)
.rdata$r:0000E87C                 public ??_R2CommandShortcut@@8
.rdata$r:0000E87C ; CommandShortcut::`RTTI Base Class Array'
.rdata$r:0000E87C ??_R2CommandShortcut@@8 dd offset ??_R1A@?0A@EA@CommandShortcut@@8
.rdata$r:0000E87C                                         ; DATA XREF: .rdata$r:0000E878o
.rdata$r:0000E87C                                         ; CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E880                 dd offset ??_R1A@?0A@EA@Shortcut@@8 ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E884                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E888                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E88C                 db    0
.rdata$r:0000E88D                 align 10h
.rdata$r:0000E88D _rdata$r        ends
.rdata$r:0000E88D
.rdata$r:0000E890 ; ===========================================================================
.rdata$r:0000E890
.rdata$r:0000E890 ; Segment type: Pure data
.rdata$r:0000E890 ; Segment permissions: Read
.rdata$r:0000E890 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E890                 assume cs:_rdata$r
.rdata$r:0000E890                 ;org 0E890h
.rdata$r:0000E890 ; COMDAT (pick any)
.rdata$r:0000E890                 public ??_R1A@?0A@EA@CommandShortcut@@8
.rdata$r:0000E890 ; CommandShortcut::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E890 ??_R1A@?0A@EA@CommandShortcut@@8 dd offset ??_R0?AVCommandShortcut@@@8
.rdata$r:0000E890                                         ; DATA XREF: .rdata$r:CommandShortcut::`RTTI Base Class Array'o
.rdata$r:0000E890                                         ; .rdata$r:0000E8F4o
.rdata$r:0000E890                                         ; CommandShortcut `RTTI Type Descriptor'
.rdata$r:0000E894                 db    3
.rdata$r:0000E895                 db    0
.rdata$r:0000E896                 db    0
.rdata$r:0000E897                 db    0
.rdata$r:0000E898                 db    0
.rdata$r:0000E899                 db    0
.rdata$r:0000E89A                 db    0
.rdata$r:0000E89B                 db    0
.rdata$r:0000E89C                 db 0FFh
.rdata$r:0000E89D                 db 0FFh
.rdata$r:0000E89E                 db 0FFh
.rdata$r:0000E89F                 db 0FFh
.rdata$r:0000E8A0                 db    0
.rdata$r:0000E8A1                 db    0
.rdata$r:0000E8A2                 db    0
.rdata$r:0000E8A3                 db    0
.rdata$r:0000E8A4                 db  40h ; @
.rdata$r:0000E8A5                 db    0
.rdata$r:0000E8A6                 db    0
.rdata$r:0000E8A7                 db    0
.rdata$r:0000E8A8                 dd offset ??_R3CommandShortcut@@8 ; CommandShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E8A8 _rdata$r        ends
.rdata$r:0000E8A8
.rdata$r:0000E8AC ; ===========================================================================
.rdata$r:0000E8AC
.rdata$r:0000E8AC ; Segment type: Pure data
.rdata$r:0000E8AC ; Segment permissions: Read
.rdata$r:0000E8AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E8AC                 assume cs:_rdata$r
.rdata$r:0000E8AC                 ;org 0E8ACh
.rdata$r:0000E8AC ; COMDAT (pick any)
.rdata$r:0000E8AC                 public ??_R4PluginCmdShortcut@@6B@
.rdata$r:0000E8AC ; const PluginCmdShortcut::`RTTI Complete Object Locator'
.rdata$r:0000E8AC ??_R4PluginCmdShortcut@@6B@ db    0     ; DATA XREF: .rdata:0000DB9Co
.rdata$r:0000E8AD                 db    0
.rdata$r:0000E8AE                 db    0
.rdata$r:0000E8AF                 db    0
.rdata$r:0000E8B0                 db    0
.rdata$r:0000E8B1                 db    0
.rdata$r:0000E8B2                 db    0
.rdata$r:0000E8B3                 db    0
.rdata$r:0000E8B4                 db    0
.rdata$r:0000E8B5                 db    0
.rdata$r:0000E8B6                 db    0
.rdata$r:0000E8B7                 db    0
.rdata$r:0000E8B8                 dd offset ??_R0?AVPluginCmdShortcut@@@8 ; PluginCmdShortcut `RTTI Type Descriptor'
.rdata$r:0000E8BC                 dd offset ??_R3PluginCmdShortcut@@8 ; PluginCmdShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E8BC _rdata$r        ends
.rdata$r:0000E8BC
.data$r:0000E8C0 ; ===========================================================================
.data$r:0000E8C0
.data$r:0000E8C0 ; Segment type: Pure data
.data$r:0000E8C0 ; Segment permissions: Read/Write
.data$r:0000E8C0 _data$r         segment dword public 'DATA' use32
.data$r:0000E8C0                 assume cs:_data$r
.data$r:0000E8C0                 ;org 0E8C0h
.data$r:0000E8C0 ; COMDAT (pick any)
.data$r:0000E8C0                 public ??_R0?AVPluginCmdShortcut@@@8
.data$r:0000E8C0 ; class PluginCmdShortcut `RTTI Type Descriptor'
.data$r:0000E8C0 ??_R0?AVPluginCmdShortcut@@@8 dd offset ??_7type_info@@6B@
.data$r:0000E8C0                                         ; DATA XREF: .rdata$r:0000E8B8o
.data$r:0000E8C0                                         ; .rdata$r:PluginCmdShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000E8C0                                         ; const type_info::`vftable'
.data$r:0000E8C4                 align 8
.data$r:0000E8C8 a_?avplugincmds db '.?AVPluginCmdShortcut@@',0
.data$r:0000E8C8 _data$r         ends
.data$r:0000E8C8
.rdata$r:0000E8E0 ; ===========================================================================
.rdata$r:0000E8E0
.rdata$r:0000E8E0 ; Segment type: Pure data
.rdata$r:0000E8E0 ; Segment permissions: Read
.rdata$r:0000E8E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E8E0                 assume cs:_rdata$r
.rdata$r:0000E8E0                 ;org 0E8E0h
.rdata$r:0000E8E0 ; COMDAT (pick any)
.rdata$r:0000E8E0                 public ??_R3PluginCmdShortcut@@8
.rdata$r:0000E8E0 ; PluginCmdShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E8E0 ??_R3PluginCmdShortcut@@8 db    0       ; DATA XREF: .rdata$r:0000E8BCo
.rdata$r:0000E8E0                                         ; .rdata$r:0000E920o
.rdata$r:0000E8E1                 db    0
.rdata$r:0000E8E2                 db    0
.rdata$r:0000E8E3                 db    0
.rdata$r:0000E8E4                 db    0
.rdata$r:0000E8E5                 db    0
.rdata$r:0000E8E6                 db    0
.rdata$r:0000E8E7                 db    0
.rdata$r:0000E8E8                 db    5
.rdata$r:0000E8E9                 db    0
.rdata$r:0000E8EA                 db    0
.rdata$r:0000E8EB                 db    0
.rdata$r:0000E8EC                 dd offset ??_R2PluginCmdShortcut@@8 ; PluginCmdShortcut::`RTTI Base Class Array'
.rdata$r:0000E8EC _rdata$r        ends
.rdata$r:0000E8EC
.rdata$r:0000E8F0 ; ===========================================================================
.rdata$r:0000E8F0
.rdata$r:0000E8F0 ; Segment type: Pure data
.rdata$r:0000E8F0 ; Segment permissions: Read
.rdata$r:0000E8F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E8F0                 assume cs:_rdata$r
.rdata$r:0000E8F0                 ;org 0E8F0h
.rdata$r:0000E8F0 ; COMDAT (pick any)
.rdata$r:0000E8F0                 public ??_R2PluginCmdShortcut@@8
.rdata$r:0000E8F0 ; PluginCmdShortcut::`RTTI Base Class Array'
.rdata$r:0000E8F0 ??_R2PluginCmdShortcut@@8 dd offset ??_R1A@?0A@EA@PluginCmdShortcut@@8
.rdata$r:0000E8F0                                         ; DATA XREF: .rdata$r:0000E8ECo
.rdata$r:0000E8F0                                         ; PluginCmdShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E8F4                 dd offset ??_R1A@?0A@EA@CommandShortcut@@8 ; CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E8F8                 dd offset ??_R1A@?0A@EA@Shortcut@@8 ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E8FC                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E900                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000E904                 db    0
.rdata$r:0000E905                 align 4
.rdata$r:0000E905 _rdata$r        ends
.rdata$r:0000E905
.rdata$r:0000E908 ; ===========================================================================
.rdata$r:0000E908
.rdata$r:0000E908 ; Segment type: Pure data
.rdata$r:0000E908 ; Segment permissions: Read
.rdata$r:0000E908 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000E908                 assume cs:_rdata$r
.rdata$r:0000E908                 ;org 0E908h
.rdata$r:0000E908 ; COMDAT (pick any)
.rdata$r:0000E908                 public ??_R1A@?0A@EA@PluginCmdShortcut@@8
.rdata$r:0000E908 ; PluginCmdShortcut::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000E908 ??_R1A@?0A@EA@PluginCmdShortcut@@8 dd offset ??_R0?AVPluginCmdShortcut@@@8
.rdata$r:0000E908                                         ; DATA XREF: .rdata$r:PluginCmdShortcut::`RTTI Base Class Array'o
.rdata$r:0000E908                                         ; PluginCmdShortcut `RTTI Type Descriptor'
.rdata$r:0000E90C                 db    4
.rdata$r:0000E90D                 db    0
.rdata$r:0000E90E                 db    0
.rdata$r:0000E90F                 db    0
.rdata$r:0000E910                 db    0
.rdata$r:0000E911                 db    0
.rdata$r:0000E912                 db    0
.rdata$r:0000E913                 db    0
.rdata$r:0000E914                 db 0FFh
.rdata$r:0000E915                 db 0FFh
.rdata$r:0000E916                 db 0FFh
.rdata$r:0000E917                 db 0FFh
.rdata$r:0000E918                 db    0
.rdata$r:0000E919                 db    0
.rdata$r:0000E91A                 db    0
.rdata$r:0000E91B                 db    0
.rdata$r:0000E91C                 db  40h ; @
.rdata$r:0000E91D                 db    0
.rdata$r:0000E91E                 db    0
.rdata$r:0000E91F                 db    0
.rdata$r:0000E920                 dd offset ??_R3PluginCmdShortcut@@8 ; PluginCmdShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000E920 _rdata$r        ends
.rdata$r:0000E920
.CRT$XCU:0000E924 ; ===========================================================================
.CRT$XCU:0000E924
.CRT$XCU:0000E924 ; Segment type: Pure data
.CRT$XCU:0000E924 ; Segment permissions: Read
.CRT$XCU:0000E924 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000E924                 assume cs:_CRT$XCU
.CRT$XCU:0000E924                 ;org 0E924h
.CRT$XCU:0000E924 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0000E928 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:0000E928 _CRT$XCU        ends
.CRT$XCU:0000E928
.CRT$XCU:0000E92C ; ===========================================================================
.CRT$XCU:0000E92C
.CRT$XCU:0000E92C ; Segment type: Pure data
.CRT$XCU:0000E92C ; Segment permissions: Read
.CRT$XCU:0000E92C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000E92C                 assume cs:_CRT$XCU
.CRT$XCU:0000E92C                 ;org 0E92Ch
.CRT$XCU:0000E92C ; COMDAT (pick associative to section at DA6C)
.CRT$XCU:0000E92C ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000E92C ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000E92C _CRT$XCU        ends
.CRT$XCU:0000E92C
.CRT$XCU:0000E930 ; ===========================================================================
.CRT$XCU:0000E930
.CRT$XCU:0000E930 ; Segment type: Pure data
.CRT$XCU:0000E930 ; Segment permissions: Read
.CRT$XCU:0000E930 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000E930                 assume cs:_CRT$XCU
.CRT$XCU:0000E930                 ;org 0E930h
.CRT$XCU:0000E930 ; COMDAT (pick associative to section at DA70)
.CRT$XCU:0000E930 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000E930 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000E930 _CRT$XCU        ends
.CRT$XCU:0000E930
.CRT$XCU:0000E934 ; ===========================================================================
.CRT$XCU:0000E934
.CRT$XCU:0000E934 ; Segment type: Pure data
.CRT$XCU:0000E934 ; Segment permissions: Read
.CRT$XCU:0000E934 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000E934                 assume cs:_CRT$XCU
.CRT$XCU:0000E934                 ;org 0E934h
.CRT$XCU:0000E934 ; COMDAT (pick associative to section at DA74)
.CRT$XCU:0000E934 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000E934 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000E934 _CRT$XCU        ends
.CRT$XCU:0000E934
.CRT$XCU:0000E938 ; ===========================================================================
.CRT$XCU:0000E938
.CRT$XCU:0000E938 ; Segment type: Pure data
.CRT$XCU:0000E938 ; Segment permissions: Read
.CRT$XCU:0000E938 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000E938                 assume cs:_CRT$XCU
.CRT$XCU:0000E938                 ;org 0E938h
.CRT$XCU:0000E938 ; COMDAT (pick associative to section at DA7C)
.CRT$XCU:0000E938 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:0000E938 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:0000E938 _CRT$XCU        ends
.CRT$XCU:0000E938
.CRT$XCU:0000E93C ; ===========================================================================
.CRT$XCU:0000E93C
.CRT$XCU:0000E93C ; Segment type: Pure data
.CRT$XCU:0000E93C ; Segment permissions: Read
.CRT$XCU:0000E93C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000E93C                 assume cs:_CRT$XCU
.CRT$XCU:0000E93C                 ;org 0E93Ch
.CRT$XCU:0000E93C ; COMDAT (pick associative to section at DA80)
.CRT$XCU:0000E93C ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000E93C ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000E93C _CRT$XCU        ends
.CRT$XCU:0000E93C
.CRT$XCU:0000E940 ; ===========================================================================
.CRT$XCU:0000E940
.CRT$XCU:0000E940 ; Segment type: Pure data
.CRT$XCU:0000E940 ; Segment permissions: Read
.CRT$XCU:0000E940 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000E940                 assume cs:_CRT$XCU
.CRT$XCU:0000E940                 ;org 0E940h
.CRT$XCU:0000E940 ; COMDAT (pick associative to section at DE78)
.CRT$XCU:0000E940 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000E940 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000E940 _CRT$XCU        ends
.CRT$XCU:0000E940
.CRT$XCU:0000E944 ; ===========================================================================
.CRT$XCU:0000E944
.CRT$XCU:0000E944 ; Segment type: Pure data
.CRT$XCU:0000E944 ; Segment permissions: Read
.CRT$XCU:0000E944 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000E944                 assume cs:_CRT$XCU
.CRT$XCU:0000E944                 ;org 0E944h
.CRT$XCU:0000E944 ; COMDAT (pick associative to section at DE7C)
.CRT$XCU:0000E944 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:0000E944 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:0000E944 _CRT$XCU        ends
.CRT$XCU:0000E944
UNDEF:0000E950 ; ===========================================================================
UNDEF:0000E950
UNDEF:0000E950 ; Segment type: Externs
UNDEF:0000E950 ; UNDEF
UNDEF:0000E950                 extrn __purecall:near   ; DATA XREF: .rdata:0000D9C0o
UNDEF:0000E950                                         ; .rdata:0000D9C4o ...
UNDEF:0000E954 ; void *__cdecl operator new(unsigned int)
UNDEF:0000E954                 extrn ??2@YAPAXI@Z:near ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+6Ap
UNDEF:0000E954                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+541p ...
UNDEF:0000E958 ; void __cdecl operator delete(void *)
UNDEF:0000E958                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$4+7p
UNDEF:0000E958                                         ; __unwindfunclet$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$5+7p ...
UNDEF:0000E95C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000E95C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000E95C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:0000E960                 extrn ___report_rangecheckfailure:near
UNDEF:0000E960                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_ECBp
UNDEF:0000E960                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_EF4p
UNDEF:0000E964                 extrn __invalid_parameter:near
UNDEF:0000E964                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+74p
UNDEF:0000E964                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+74p ...
UNDEF:0000E968 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000E968                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:0000E968                                         ; _wmemcpy+11p
UNDEF:0000E96C ; size_t __cdecl strlen(const char *Str)
UNDEF:0000E96C                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000E970 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000E970                 extrn _memmove:near     ; CODE XREF: std::_Uninit_move<PluginInfo *,PluginInfo *,PluginInfo *>(PluginInfo * *,PluginInfo * *,PluginInfo * *,std::_Wrap_alloc<std::allocator<PluginInfo *>> &,PluginInfo * *,std::_Scalar_ptr_iterator_tag)+4Fp
UNDEF:0000E970                                         ; std::_Uninit_move<TiXmlDocument *,TiXmlDocument *,TiXmlDocument *>(TiXmlDocument * *,TiXmlDocument * *,TiXmlDocument * *,std::_Wrap_alloc<std::allocator<TiXmlDocument *>> &,TiXmlDocument * *,std::_Scalar_ptr_iterator_tag)+4Fp ...
UNDEF:0000E974 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:0000E974                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:0000E978 ; wchar_t *__cdecl wcsncpy(wchar_t *Dest, const wchar_t *Source, size_t Count)
UNDEF:0000E978                 extrn _wcsncpy:near     ; CODE XREF: ExternalLangContainer::ExternalLangContainer(wchar_t const *,wchar_t const *)+11p
UNDEF:0000E978                                         ; ExternalLangContainer::ExternalLangContainer(wchar_t const *,wchar_t const *)+26p
UNDEF:0000E97C ; int __cdecl wcsicmp(const wchar_t *Str1, const wchar_t *Str2)
UNDEF:0000E97C                 extrn _wcsicmp:near     ; CODE XREF: PluginsManager::runPluginCommand(wchar_t const *,int)+9Ap
UNDEF:0000E97C                                         ; PluginsManager::isInLoadedDlls(wchar_t const *)+46p
UNDEF:0000E980 ; BOOL __stdcall DeleteFileW(LPCWSTR lpFileName)
UNDEF:0000E980                 extrn __imp__DeleteFileW@4:near
UNDEF:0000E980                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+593p
UNDEF:0000E980                                         ; DATA XREF: PluginsManager::loadPlugins(wchar_t const *)+593r
UNDEF:0000E984 ; BOOL __stdcall FindClose(HANDLE hFindFile)
UNDEF:0000E984                 extrn __imp__FindClose@4:near
UNDEF:0000E984                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+4C5p
UNDEF:0000E984                                         ; DATA XREF: PluginsManager::loadPlugins(wchar_t const *)+4C5r
UNDEF:0000E988 ; HANDLE __stdcall FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
UNDEF:0000E988                 extrn __imp__FindFirstFileW@8:near
UNDEF:0000E988                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+1AAp
UNDEF:0000E988                                         ; DATA XREF: PluginsManager::loadPlugins(wchar_t const *)+1AAr
UNDEF:0000E98C ; BOOL __stdcall FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
UNDEF:0000E98C                 extrn __imp__FindNextFileW@8:near
UNDEF:0000E98C                                         ; CODE XREF: PluginsManager::loadPlugins(wchar_t const *)+2FAp
UNDEF:0000E98C                                         ; DATA XREF: PluginsManager::loadPlugins(wchar_t const *)+2FAr
UNDEF:0000E990 ; BOOL __stdcall FreeLibrary(HMODULE hLibModule)
UNDEF:0000E990                 extrn __imp__FreeLibrary@4:near
UNDEF:0000E990                                         ; CODE XREF: PluginsManager::unloadPlugin(int,HWND__ *)+4Ep
UNDEF:0000E990                                         ; PluginInfo::~PluginInfo(void)+51p
UNDEF:0000E990                                         ; DATA XREF: ...
UNDEF:0000E994 ; FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
UNDEF:0000E994                 extrn __imp__GetProcAddress@8:near
UNDEF:0000E994                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+130p
UNDEF:0000E994                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+189p ...
UNDEF:0000E998 ; int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:0000E998                 extrn __imp__lstrcmpW@8:near
UNDEF:0000E998                                         ; CODE XREF: NppParameters::isExistingExternalLangName(wchar_t const *)+58p
UNDEF:0000E998                                         ; DATA XREF: NppParameters::isExistingExternalLangName(wchar_t const *)+58r
UNDEF:0000E99C ; LPWSTR __stdcall lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
UNDEF:0000E99C                 extrn __imp__lstrcpynW@12:near
UNDEF:0000E99C                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+682p
UNDEF:0000E99C                                         ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+682r
UNDEF:0000E9A0 ; LPWSTR __stdcall lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
UNDEF:0000E9A0                 extrn __imp__lstrcpyW@8:near
UNDEF:0000E9A0                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+5FAp
UNDEF:0000E9A0                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+69Bp
UNDEF:0000E9A0                                         ; DATA XREF: ...
UNDEF:0000E9A4 ; HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName)
UNDEF:0000E9A4                 extrn __imp__LoadLibraryW@4:near
UNDEF:0000E9A4                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+E8p
UNDEF:0000E9A4                                         ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+E8r
UNDEF:0000E9A8 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000E9A8                 extrn __imp__SendMessageW@16:near
UNDEF:0000E9A8                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+9ADp
UNDEF:0000E9A8                                         ; StaticDialog::destroy(void)+1Cp
UNDEF:0000E9A8                                         ; DATA XREF: ...
UNDEF:0000E9AC ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:0000E9AC                 extrn __imp__DestroyWindow@4:near
UNDEF:0000E9AC                                         ; CODE XREF: StaticDialog::destroy(void)+29p
UNDEF:0000E9AC                                         ; DATA XREF: StaticDialog::destroy(void)+29r
UNDEF:0000E9B0 ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:0000E9B0                 extrn __imp__ShowWindow@8:near
UNDEF:0000E9B0                                         ; CODE XREF: Window::display(bool)+2Cp
UNDEF:0000E9B0                                         ; DATA XREF: Window::display(bool)+2Cr
UNDEF:0000E9B4 ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:0000E9B4                 extrn __imp__MoveWindow@24:near
UNDEF:0000E9B4                                         ; CODE XREF: Window::reSizeTo(tagRECT &)+2Bp
UNDEF:0000E9B4                                         ; Window::reSizeToWH(tagRECT &)+36p
UNDEF:0000E9B4                                         ; DATA XREF: ...
UNDEF:0000E9B8 ; BOOL __stdcall IsWindowVisible(HWND hWnd)
UNDEF:0000E9B8                 extrn __imp__IsWindowVisible@4:near
UNDEF:0000E9B8                                         ; CODE XREF: Window::getHeight(void)+2Bp
UNDEF:0000E9B8                                         ; Window::isVisible(void)+10p
UNDEF:0000E9B8                                         ; DATA XREF: ...
UNDEF:0000E9BC ; INT_PTR __stdcall DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
UNDEF:0000E9BC                 extrn __imp__DialogBoxParamW@20:near
UNDEF:0000E9BC                                         ; CODE XREF: Shortcut::doDialog(void)+23p
UNDEF:0000E9BC                                         ; DATA XREF: Shortcut::doDialog(void)+23r
UNDEF:0000E9C0 ; HMENU __stdcall CreateMenu()
UNDEF:0000E9C0                 extrn __imp__CreateMenu@0:near
UNDEF:0000E9C0                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &):loc_DF4p
UNDEF:0000E9C0                                         ; PluginsManager::setMenu(HMENU__ *,wchar_t const *)+53p
UNDEF:0000E9C0                                         ; DATA XREF: ...
UNDEF:0000E9C4 ; BOOL __stdcall DestroyMenu(HMENU hMenu)
UNDEF:0000E9C4                 extrn __imp__DestroyMenu@4:near
UNDEF:0000E9C4                                         ; CODE XREF: PluginInfo::~PluginInfo(void)+3Dp
UNDEF:0000E9C4                                         ; DATA XREF: PluginInfo::~PluginInfo(void)+3Dr
UNDEF:0000E9C8 ; DWORD __stdcall CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
UNDEF:0000E9C8                 extrn __imp__CheckMenuItem@12:near
UNDEF:0000E9C8                                         ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+508p
UNDEF:0000E9C8                                         ; DATA XREF: PluginsManager::addInMenuFromPMIndex(int)+508r
UNDEF:0000E9CC ; BOOL __stdcall InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
UNDEF:0000E9CC                 extrn __imp__InsertMenuW@20:near
UNDEF:0000E9CC                                         ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+89p
UNDEF:0000E9CC                                         ; PluginsManager::addInMenuFromPMIndex(int)+12Ap ...
UNDEF:0000E9D0 ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:0000E9D0                 extrn __imp__UpdateWindow@4:near
UNDEF:0000E9D0                                         ; CODE XREF: Window::redraw(bool)+27p
UNDEF:0000E9D0                                         ; DATA XREF: Window::redraw(bool)+27r
UNDEF:0000E9D4 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:0000E9D4                 extrn __imp__InvalidateRect@12:near
UNDEF:0000E9D4                                         ; CODE XREF: Window::redraw(bool)+12p
UNDEF:0000E9D4                                         ; DATA XREF: Window::redraw(bool)+12r
UNDEF:0000E9D8 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000E9D8                 extrn __imp__GetClientRect@8:near
UNDEF:0000E9D8                                         ; CODE XREF: Window::getClientRect(tagRECT &)+12p
UNDEF:0000E9D8                                         ; Window::getHeight(void)+1Ep ...
UNDEF:0000E9DC ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000E9DC                 extrn __imp__GetWindowRect@8:near
UNDEF:0000E9DC                                         ; CODE XREF: Window::getWindowRect(tagRECT &)+12p
UNDEF:0000E9DC                                         ; DATA XREF: Window::getWindowRect(tagRECT &)+12r
UNDEF:0000E9E0 ; int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
UNDEF:0000E9E0                 extrn __imp__MessageBoxA@16:near
UNDEF:0000E9E0                                         ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$0+19p
UNDEF:0000E9E0                                         ; __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$0+19p ...
UNDEF:0000E9E4 ; int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
UNDEF:0000E9E4                 extrn __imp__MessageBoxW@16:near
UNDEF:0000E9E4                                         ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$1+3Ap
UNDEF:0000E9E4                                         ; __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$2+4Ap ...
UNDEF:0000E9E8 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:0000E9E8                 extrn __imp__SetWindowLongW@12:near
UNDEF:0000E9E8                                         ; CODE XREF: StaticDialog::~StaticDialog(void)+50p
UNDEF:0000E9E8                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+50r
UNDEF:0000E9EC ; BOOL __stdcall PathAddExtensionW(LPWSTR pszPath, LPCWSTR pszExt)
UNDEF:0000E9EC                 extrn __imp__PathAddExtensionW@8:near
UNDEF:0000E9EC                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+656p
UNDEF:0000E9EC                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+6E8p
UNDEF:0000E9EC                                         ; DATA XREF: ...
UNDEF:0000E9F0 ; BOOL __stdcall PathAppendW(LPWSTR pszPath, LPCWSTR pMore)
UNDEF:0000E9F0                 extrn __imp__PathAppendW@8:near
UNDEF:0000E9F0                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+61Bp
UNDEF:0000E9F0                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+637p ...
UNDEF:0000E9F4 ; BOOL __stdcall PathFileExistsW(LPCWSTR pszPath)
UNDEF:0000E9F4                 extrn __imp__PathFileExistsW@4:near
UNDEF:0000E9F4                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+663p
UNDEF:0000E9F4                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+6F5p
UNDEF:0000E9F4                                         ; DATA XREF: ...
UNDEF:0000E9F8 ; LPWSTR __stdcall PathFindFileNameW(LPCWSTR pszPath)
UNDEF:0000E9F8                 extrn __imp__PathFindFileNameW@4:near
UNDEF:0000E9F8                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+3Cp
UNDEF:0000E9F8                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+CFp
UNDEF:0000E9F8                                         ; DATA XREF: ...
UNDEF:0000E9FC ; void __stdcall PathRemoveExtensionW(LPWSTR pszPath)
UNDEF:0000E9FC                 extrn __imp__PathRemoveExtensionW@4:near
UNDEF:0000E9FC                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+644p
UNDEF:0000E9FC                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+6D6p
UNDEF:0000E9FC                                         ; DATA XREF: ...
UNDEF:0000EA00 ; int __cdecl _vswprintf(wchar_t *Dest, const wchar_t *Format, va_list Args)
UNDEF:0000EA00                 extrn __vswprintf:near  ; CODE XREF: swprintf(wchar_t *,wchar_t const *,...)+18p
UNDEF:0000EA04 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000EA04                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000EA04                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:0000EA04                                         ; std::vector<PluginInfo *,std::allocator<PluginInfo *>>::_Orphan_range(PluginInfo * *,PluginInfo * *)+2Dp ...
UNDEF:0000EA08 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000EA08                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000EA08                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:0000EA08                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j ...
UNDEF:0000EA0C                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000EA10 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:0000EA10                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:0000EA10                                         ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$0+33p
UNDEF:0000EA10                                         ; __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$0+29p ...
UNDEF:0000EA14 ; const char *__thiscall std::exception::what(std::exception *__hidden this)
UNDEF:0000EA14                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:0000EA14                                         ; CODE XREF: __catch$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z$0+11p
UNDEF:0000EA14                                         ; __catch$?runPluginCommand@PluginsManager@@QAEXI@Z$0+11p ...
UNDEF:0000EA18                 extrn __CrtDbgReportW:near
UNDEF:0000EA18                                         ; CODE XREF: std::vector<PluginInfo *,std::allocator<PluginInfo *>>::operator[](uint)+50p
UNDEF:0000EA18                                         ; std::vector<PluginCommand,std::allocator<PluginCommand>>::operator[](uint)+50p ...
UNDEF:0000EA1C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000EA1C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000EA1C                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000EA1C                                         ; std::_Debug_pointer<PluginInfo *>(PluginInfo * *,wchar_t const *,uint)+16p ...
UNDEF:0000EA20 ; void __cdecl std::_Xbad_alloc()
UNDEF:0000EA20                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000EA20                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_32CAp
UNDEF:0000EA20                                         ; std::_Allocate<PluginInfo *>(uint,PluginInfo * *):loc_330Cp ...
UNDEF:0000EA24 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000EA24                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000EA24                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000EA24                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:0000EA28 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000EA28                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000EA28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000EA28                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:0000EA2C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000EA2C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000EA2C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000EA30 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000EA30                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000EA30                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000EA30                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000EA34 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000EA34                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000EA34                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000EA38 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000EA38                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000EA38                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000EA3C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000EA3C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000EA3C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000EA40 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000EA40                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000EA40                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000EA44 ; void __cdecl printStr(const wchar_t *)
UNDEF:0000EA44                 extrn ?printStr@@YAXPB_W@Z:near
UNDEF:0000EA44                                         ; CODE XREF: PluginsManager::unloadPlugin(int,HWND__ *)+76p
UNDEF:0000EA48 ; const wchar_t *__thiscall WcharMbcsConvertor::char2wchar(WcharMbcsConvertor *__hidden this, const char *, unsigned int, int, int *, int *)
UNDEF:0000EA48                 extrn ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z:near
UNDEF:0000EA48                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+509p
UNDEF:0000EA4C ; const char *__thiscall WcharMbcsConvertor::wchar2char(WcharMbcsConvertor *__hidden this, const wchar_t *, unsigned int, int, int *)
UNDEF:0000EA4C                 extrn ?wchar2char@WcharMbcsConvertor@@QAEPBDPB_WIHPAH@Z:near
UNDEF:0000EA4C                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+98Ap
UNDEF:0000EA50 ; _DWORD __thiscall TiXmlDocument::TiXmlDocument(TiXmlDocument *__hidden this, const wchar_t *)
UNDEF:0000EA50                 extrn ??0TiXmlDocument@@QAE@PB_W@Z:near
UNDEF:0000EA50                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+7C7p
UNDEF:0000EA54 ; bool __thiscall TiXmlDocument::LoadFile(TiXmlDocument *__hidden this)
UNDEF:0000EA54                 extrn ?LoadFile@TiXmlDocument@@QAE_NXZ:near
UNDEF:0000EA54                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+800p
UNDEF:0000EA58 ; public: virtual void * __thiscall Window::`vector deleting destructor'(unsigned int)
UNDEF:0000EA58                 extrn ??_EWindow@@UAEPAXI@Z:near ; weak
UNDEF:0000EA58                                         ; DATA XREF: .rdata:const Window::`vftable'o
UNDEF:0000EA5C ; public: virtual void __thiscall StaticDialog::create(int, bool, bool)
UNDEF:0000EA5C                 extrn ?create@StaticDialog@@UAEXH_N0@Z:near
UNDEF:0000EA5C                                         ; DATA XREF: .rdata:0000DAF0o
UNDEF:0000EA5C                                         ; .rdata:0000DB30o ...
UNDEF:0000EA60 ; public: virtual void __thiscall StaticDialog::display(bool)const
UNDEF:0000EA60                 extrn ?display@StaticDialog@@UBEX_N@Z:near
UNDEF:0000EA60                                         ; DATA XREF: .rdata:0000DACCo
UNDEF:0000EA60                                         ; .rdata:0000DB0Co ...
UNDEF:0000EA64 ; INT_PTR __stdcall StaticDialog::dlgProc(HWND, UINT, WPARAM, LPARAM)
UNDEF:0000EA64                 extrn ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z:near
UNDEF:0000EA64                                         ; DATA XREF: Shortcut::doDialog(void)+Bo
UNDEF:0000EA68 ; public: virtual void * __thiscall StaticDialog::`vector deleting destructor'(unsigned int)
UNDEF:0000EA68                 extrn ??_EStaticDialog@@UAEPAXI@Z:near ; weak
UNDEF:0000EA68                                         ; DATA XREF: .rdata:const StaticDialog::`vftable'o
UNDEF:0000EA6C ; public: virtual class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall Shortcut::toString(void)const
UNDEF:0000EA6C                 extrn ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ:near
UNDEF:0000EA6C                                         ; CODE XREF: PluginsManager::addInMenuFromPMIndex(int)+37Bp
UNDEF:0000EA6C                                         ; DATA XREF: .rdata:0000DB48o ...
UNDEF:0000EA70 ; void __thiscall Shortcut::setName(Shortcut *__hidden this, const wchar_t *)
UNDEF:0000EA70                 extrn ?setName@Shortcut@@QAEXPB_W@Z:near
UNDEF:0000EA70                                         ; CODE XREF: Shortcut::Shortcut(Shortcut const &)+4Ap
UNDEF:0000EA70                                         ; Shortcut::Shortcut(wchar_t const *,bool,bool,bool,uchar)+64p ...
UNDEF:0000EA74 ; protected: virtual int __stdcall Shortcut::run_dlgProc(unsigned int, unsigned int, long)
UNDEF:0000EA74                 extrn ?run_dlgProc@Shortcut@@MAGHIIJ@Z:near
UNDEF:0000EA74                                         ; DATA XREF: .rdata:0000DB38o
UNDEF:0000EA74                                         ; .rdata:0000DB88o ...
UNDEF:0000EA78 ; public: virtual void * __thiscall Shortcut::`vector deleting destructor'(unsigned int)
UNDEF:0000EA78                 extrn ??_EShortcut@@UAEPAXI@Z:near ; weak
UNDEF:0000EA78                                         ; DATA XREF: .rdata:const Shortcut::`vftable'o
UNDEF:0000EA7C ; public: virtual void * __thiscall CommandShortcut::`vector deleting destructor'(unsigned int)
UNDEF:0000EA7C                 extrn ??_ECommandShortcut@@UAEPAXI@Z:near ; weak
UNDEF:0000EA7C                                         ; DATA XREF: .rdata:const CommandShortcut::`vftable'o
UNDEF:0000EA80 ; public: virtual void * __thiscall PluginCmdShortcut::`vector deleting destructor'(unsigned int)
UNDEF:0000EA80                 extrn ??_EPluginCmdShortcut@@UAEPAXI@Z:near ; weak
UNDEF:0000EA80                                         ; DATA XREF: .rdata:const PluginCmdShortcut::`vftable'o
UNDEF:0000EA84 ; void __thiscall NppParameters::getExternalLexerFromXmlTree(NppParameters *__hidden this, struct TiXmlDocument *)
UNDEF:0000EA84                 extrn ?getExternalLexerFromXmlTree@NppParameters@@QAEXPAVTiXmlDocument@@@Z:near
UNDEF:0000EA84                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+95Cp
UNDEF:0000EA88 ; int __thiscall NppParameters::addExternalLangToEnd(NppParameters *__hidden this, struct ExternalLangContainer *)
UNDEF:0000EA88                 extrn ?addExternalLangToEnd@NppParameters@@QAEHPAVExternalLangContainer@@@Z:near
UNDEF:0000EA88                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+948p
UNDEF:0000EA8C ; int __thiscall IDAllocator::allocate(IDAllocator *__hidden this, int)
UNDEF:0000EA8C                 extrn ?allocate@IDAllocator@@QAEHH@Z:near
UNDEF:0000EA8C                                         ; CODE XREF: PluginsManager::allocateCmdID(int,int *)+17p
UNDEF:0000EA8C                                         ; PluginsManager::allocateMarker(int,int *)+17p
UNDEF:0000EA90 ; __fastcall __security_check_cookie(x)
UNDEF:0000EA90                 extrn @__security_check_cookie@4:near
UNDEF:0000EA90                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+C45p
UNDEF:0000EA90                                         ; PluginsManager::loadPlugins(wchar_t const *)+5F1p ...
UNDEF:0000EA94 ; __stdcall _CxxThrowException(x, x)
UNDEF:0000EA94                 extrn __CxxThrowException@8:near
UNDEF:0000EA94                                         ; CODE XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+11Dp
UNDEF:0000EA94                                         ; PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+176p ...
UNDEF:0000EA98                 extrn ___CxxFrameHandler3:near
UNDEF:0000EA98                                         ; CODE XREF: __ehhandler$?loadPlugin@PluginsManager@@QAEHPB_WAAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@Z+23j
UNDEF:0000EA98                                         ; __ehhandler$?loadPlugins@PluginsManager@@QAE_NPB_W@Z+23j ...
UNDEF:0000EA9C ; const type_info::`vftable'
UNDEF:0000EA9C                 extrn ??_7type_info@@6B@:near
UNDEF:0000EA9C                                         ; DATA XREF: .data$r:std::exception `RTTI Type Descriptor'o
UNDEF:0000EA9C                                         ; .data$r:std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> `RTTI Type Descriptor'o ...
UNDEF:0000EAA0 ; protected: static class WcharMbcsConvertor * WcharMbcsConvertor::_pSelf
UNDEF:0000EAA0                 extrn ?_pSelf@WcharMbcsConvertor@@1PAV1@A:near
UNDEF:0000EAA0                                         ; DATA XREF: WcharMbcsConvertor::getInstance(void)+3r
UNDEF:0000EAA4 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:0000EAA4                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:0000EAA4                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:0000EAA8                 extrn ___security_cookie:near
UNDEF:0000EAA8                                         ; DATA XREF: PluginsManager::loadPlugin(wchar_t const *,std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>> &)+18r
UNDEF:0000EAA8                                         ; PluginsManager::loadPlugins(wchar_t const *)+17r ...
UNDEF:0000EAAC                 extrn __fltused:near
UNDEF:0000EAAC
UNDEF:0000EAAC
UNDEF:0000EAAC                 end