.bss:00000000 ;
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.bss:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.bss:00000000 ; |                      License info: 48-3677-7074-51                      |
.bss:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ;
.bss:00000000 ; Input MD5   : 0874A8C15073F78B20156A010ED556F2
.bss:00000000 ; Input CRC32 : C4D62B94
.bss:00000000
.bss:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\DockingManager.obj
.bss:00000000 ; Format      : COFF (X386MAGIC)
.bss:00000000 ; includelib "libcpmtd"
.bss:00000000 ; includelib "uuid.lib"
.bss:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00000000 ; includelib "LIBCMTD"
.bss:00000000 ; includelib "OLDNAMES"
.bss:00000000
.bss:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.bss:00000000
.bss:00000000                 .686p
.bss:00000000                 .mmx
.bss:00000000                 .model flat
.bss:00000000
.bss:00000000 ; ===========================================================================
.bss:00000000
.bss:00000000 ; Segment type: Uninitialized
.bss:00000000 ; Segment permissions: Read/Write
.bss:00000000 _bss            segment dword public 'BSS' use32
.bss:00000000                 assume cs:_bss
.bss:00000000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00000000 ; HWND hWndServer
.bss:00000000 _hWndServer     dd ?                    ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *):loc_5DAr
.bss:00000000                                         ; DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+22Dw ...
.bss:00000004 ; HHOOK gWinCallHook
.bss:00000004 _gWinCallHook   dd ?                    ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+23Br
.bss:00000004                                         ; DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+25Cw ...
.bss:00000008                 public ?_isRegistered@DockingManager@@0HA
.bss:00000008 ; private: static int DockingManager::_isRegistered
.bss:00000008 ?_isRegistered@DockingManager@@0HA dd ? ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+19r
.bss:00000008                                         ; DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *):loc_45Fw
.bss:0000000C _allocator_arg  db    ? ;
.bss:0000000D _piecewise_construct db    ? ;
.bss:0000000E                 align 10h
.bss:0000000E _bss            ends
.bss:0000000E
.rdata:00000010 ; ===========================================================================
.rdata:00000010
.rdata:00000010 ; Segment type: Pure data
.rdata:00000010 ; Segment permissions: Read
.rdata:00000010 _rdata          segment dword public 'DATA' use32
.rdata:00000010                 assume cs:_rdata
.rdata:00000010                 ;org 10h
.rdata:00000010 $SG126048:                              ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+70o
.rdata:00000010                 unicode 0, <dockingManager>,0
.rdata:0000002E                 align 10h
.rdata:00000030 ; char _SG126052[]
.rdata:00000030 $SG126052       db 'DockingManager::init : RegisterClass() function failed',0
.rdata:00000030                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+88o
.rdata:00000067                 align 4
.rdata:00000068 ; const WCHAR _SG126058
.rdata:00000068 $SG126058       dw 0                    ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+DAo
.rdata:0000006A                 align 4
.rdata:0000006C ; const WCHAR _SG126059
.rdata:0000006C $SG126059:                              ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+DFo
.rdata:0000006C                 unicode 0, <dockingManager>,0
.rdata:0000008A                 align 4
.rdata:0000008C ; char _SG126063[]
.rdata:0000008C $SG126063       db 'DockingManager::init : CreateWindowEx() function return null',0
.rdata:0000008C                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+FBo
.rdata:000000C9                 align 4
.rdata:000000CC ; char _SG126076[]
.rdata:000000CC $SG126076       db 'DockingManager::init : SetWindowsHookEx() function return null',0
.rdata:000000CC                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+26Ao
.rdata:0000010B                 align 4
.rdata:0000010B _rdata          ends
.rdata:0000010B
.text$mn:0000010C ; ===========================================================================
.text$mn:0000010C
.text$mn:0000010C ; Segment type: Pure code
.text$mn:0000010C ; Segment permissions: Read/Execute
.text$mn:0000010C _text$mn        segment para public 'CODE' use32
.text$mn:0000010C                 assume cs:_text$mn
.text$mn:0000010C                 ;org 10Ch
.text$mn:0000010C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000010C
.text$mn:0000010C ; =============== S U B R O U T I N E =======================================
.text$mn:0000010C
.text$mn:0000010C ; Attributes: bp-based frame
.text$mn:0000010C
.text$mn:0000010C ; public: __thiscall DockingManager::DockingManager(void)
.text$mn:0000010C                 public ??0DockingManager@@QAE@XZ
.text$mn:0000010C ??0DockingManager@@QAE@XZ proc near
.text$mn:0000010C
.text$mn:0000010C var_34          = dword ptr -34h
.text$mn:0000010C var_30          = dword ptr -30h
.text$mn:0000010C var_2C          = dword ptr -2Ch
.text$mn:0000010C var_28          = dword ptr -28h
.text$mn:0000010C var_24          = dword ptr -24h
.text$mn:0000010C var_20          = dword ptr -20h
.text$mn:0000010C var_1C          = dword ptr -1Ch
.text$mn:0000010C var_18          = dword ptr -18h
.text$mn:0000010C var_14          = dword ptr -14h
.text$mn:0000010C var_10          = dword ptr -10h
.text$mn:0000010C var_C           = dword ptr -0Ch
.text$mn:0000010C var_4           = dword ptr -4
.text$mn:0000010C
.text$mn:0000010C                 push    ebp
.text$mn:0000010D                 mov     ebp, esp
.text$mn:0000010F                 push    0FFFFFFFFh
.text$mn:00000111                 push    offset __ehhandler$??0DockingManager@@QAE@XZ
.text$mn:00000116                 mov     eax, large fs:0
.text$mn:0000011C                 push    eax
.text$mn:0000011D                 sub     esp, 28h
.text$mn:00000120                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000125                 xor     eax, ebp
.text$mn:00000127                 push    eax
.text$mn:00000128                 lea     eax, [ebp+var_C]
.text$mn:0000012B                 mov     large fs:0, eax
.text$mn:00000131                 mov     [ebp+var_10], ecx
.text$mn:00000134                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000137                 call    ??0Window@@QAE@XZ ; Window::Window(void)
.text$mn:0000013C                 mov     [ebp+var_4], 0
.text$mn:00000143                 mov     eax, [ebp+var_10]
.text$mn:00000146                 mov     dword ptr [eax], offset ??_7DockingManager@@6B@ ; const DockingManager::`vftable'
.text$mn:0000014C                 mov     ecx, [ebp+var_10]
.text$mn:0000014F                 add     ecx, 38h ; '8'
.text$mn:00000152                 call    ??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::vector<HWND__ *,std::allocator<HWND__ *>>(void)
.text$mn:00000157                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000015B                 mov     ecx, [ebp+var_10]
.text$mn:0000015E                 add     ecx, 4Ch ; 'L'
.text$mn:00000161                 call    ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:00000166                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000016A                 mov     ecx, [ebp+var_10]
.text$mn:0000016D                 add     ecx, 16Ch
.text$mn:00000173                 call    ??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::vector<DockingSplitter *,std::allocator<DockingSplitter *>>(void)
.text$mn:00000178                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000017C                 mov     ecx, [ebp+var_10]
.text$mn:0000017F                 mov     dword ptr [ecx+0A0h], 0
.text$mn:00000189                 mov     edx, [ebp+var_10]
.text$mn:0000018C                 mov     dword ptr [edx+48h], 0
.text$mn:00000193                 push    0C8h ; '+'      ; Size
.text$mn:00000198                 push    0FFFFFFFFh      ; Val
.text$mn:0000019A                 mov     eax, [ebp+var_10]
.text$mn:0000019D                 add     eax, 0A4h ; 'ñ'
.text$mn:000001A2                 push    eax             ; Dst
.text$mn:000001A3                 call    _memset
.text$mn:000001A8                 add     esp, 0Ch
.text$mn:000001AB                 mov     ecx, 4
.text$mn:000001B0                 imul    edx, ecx, 0
.text$mn:000001B3                 mov     eax, [ebp+var_10]
.text$mn:000001B6                 mov     dword ptr [eax+edx+0A4h], 0
.text$mn:000001C1                 mov     ecx, 4
.text$mn:000001C6                 shl     ecx, 0
.text$mn:000001C9                 mov     edx, [ebp+var_10]
.text$mn:000001CC                 mov     dword ptr [edx+ecx+0A4h], 1
.text$mn:000001D7                 mov     eax, 4
.text$mn:000001DC                 shl     eax, 1
.text$mn:000001DE                 mov     ecx, [ebp+var_10]
.text$mn:000001E1                 mov     dword ptr [ecx+eax+0A4h], 2
.text$mn:000001EC                 mov     edx, 4
.text$mn:000001F1                 imul    eax, edx, 3
.text$mn:000001F4                 mov     ecx, [ebp+var_10]
.text$mn:000001F7                 mov     dword ptr [ecx+eax+0A4h], 3
.text$mn:00000202                 mov     [ebp+var_14], 0
.text$mn:00000209                 jmp     short loc_214
.text$mn:0000020B ; ---------------------------------------------------------------------------
.text$mn:0000020B
.text$mn:0000020B loc_20B:                                ; CODE XREF: DockingManager::DockingManager(void)+1ACj
.text$mn:0000020B                 mov     edx, [ebp+var_14]
.text$mn:0000020E                 add     edx, 1
.text$mn:00000211                 mov     [ebp+var_14], edx
.text$mn:00000214
.text$mn:00000214 loc_214:                                ; CODE XREF: DockingManager::DockingManager(void)+FDj
.text$mn:00000214                 cmp     [ebp+var_14], 4
.text$mn:00000218                 jge     loc_2BD
.text$mn:0000021E                 push    0ACh ; '¼'      ; unsigned int
.text$mn:00000223                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000228                 add     esp, 4
.text$mn:0000022B                 mov     [ebp+var_18], eax
.text$mn:0000022E                 mov     byte ptr [ebp+var_4], 4
.text$mn:00000232                 cmp     [ebp+var_18], 0
.text$mn:00000236                 jz      short loc_245
.text$mn:00000238                 mov     ecx, [ebp+var_18]
.text$mn:0000023B                 call    ??0DockingCont@@QAE@XZ ; DockingCont::DockingCont(void)
.text$mn:00000240                 mov     [ebp+var_1C], eax
.text$mn:00000243                 jmp     short loc_24C
.text$mn:00000245 ; ---------------------------------------------------------------------------
.text$mn:00000245
.text$mn:00000245 loc_245:                                ; CODE XREF: DockingManager::DockingManager(void)+12Aj
.text$mn:00000245                 mov     [ebp+var_1C], 0
.text$mn:0000024C
.text$mn:0000024C loc_24C:                                ; CODE XREF: DockingManager::DockingManager(void)+137j
.text$mn:0000024C                 mov     eax, [ebp+var_1C]
.text$mn:0000024F                 mov     [ebp+var_28], eax
.text$mn:00000252                 mov     byte ptr [ebp+var_4], 3
.text$mn:00000256                 mov     ecx, [ebp+var_28]
.text$mn:00000259                 mov     [ebp+var_2C], ecx
.text$mn:0000025C                 lea     edx, [ebp+var_2C]
.text$mn:0000025F                 push    edx
.text$mn:00000260                 mov     ecx, [ebp+var_10]
.text$mn:00000263                 add     ecx, 4Ch ; 'L'
.text$mn:00000266                 call    ?push_back@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXABQAVDockingCont@@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)
.text$mn:0000026B                 push    24h ; '$'       ; unsigned int
.text$mn:0000026D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000272                 add     esp, 4
.text$mn:00000275                 mov     [ebp+var_20], eax
.text$mn:00000278                 mov     byte ptr [ebp+var_4], 5
.text$mn:0000027C                 cmp     [ebp+var_20], 0
.text$mn:00000280                 jz      short loc_28F
.text$mn:00000282                 mov     ecx, [ebp+var_20]
.text$mn:00000285                 call    ??0DockingSplitter@@QAE@XZ ; DockingSplitter::DockingSplitter(void)
.text$mn:0000028A                 mov     [ebp+var_24], eax
.text$mn:0000028D                 jmp     short loc_296
.text$mn:0000028F ; ---------------------------------------------------------------------------
.text$mn:0000028F
.text$mn:0000028F loc_28F:                                ; CODE XREF: DockingManager::DockingManager(void)+174j
.text$mn:0000028F                 mov     [ebp+var_24], 0
.text$mn:00000296
.text$mn:00000296 loc_296:                                ; CODE XREF: DockingManager::DockingManager(void)+181j
.text$mn:00000296                 mov     eax, [ebp+var_24]
.text$mn:00000299                 mov     [ebp+var_30], eax
.text$mn:0000029C                 mov     byte ptr [ebp+var_4], 3
.text$mn:000002A0                 mov     ecx, [ebp+var_30]
.text$mn:000002A3                 mov     [ebp+var_34], ecx
.text$mn:000002A6                 lea     edx, [ebp+var_34]
.text$mn:000002A9                 push    edx
.text$mn:000002AA                 mov     ecx, [ebp+var_10]
.text$mn:000002AD                 add     ecx, 16Ch
.text$mn:000002B3                 call    ?push_back@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXABQAVDockingSplitter@@@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)
.text$mn:000002B8                 jmp     loc_20B
.text$mn:000002BD ; ---------------------------------------------------------------------------
.text$mn:000002BD
.text$mn:000002BD loc_2BD:                                ; CODE XREF: DockingManager::DockingManager(void)+10Cj
.text$mn:000002BD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000002C4                 mov     eax, [ebp+var_10]
.text$mn:000002C7                 mov     ecx, [ebp+var_C]
.text$mn:000002CA                 mov     large fs:0, ecx
.text$mn:000002D1                 pop     ecx
.text$mn:000002D2                 mov     esp, ebp
.text$mn:000002D4                 pop     ebp
.text$mn:000002D5                 retn
.text$mn:000002D5 ??0DockingManager@@QAE@XZ endp
.text$mn:000002D5
.text$mn:000002D5 ; ---------------------------------------------------------------------------
.text$mn:000002D6                 db 6 dup(0CCh)
.text$mn:000002DC
.text$mn:000002DC ; =============== S U B R O U T I N E =======================================
.text$mn:000002DC
.text$mn:000002DC ; Attributes: bp-based frame
.text$mn:000002DC
.text$mn:000002DC ; _DWORD __thiscall DockingManager::~DockingManager(DockingManager *__hidden this)
.text$mn:000002DC                 public ??1DockingManager@@UAE@XZ
.text$mn:000002DC ??1DockingManager@@UAE@XZ proc near     ; CODE XREF: DockingManager::`scalar deleting destructor'(uint)+Ap
.text$mn:000002DC
.text$mn:000002DC var_20          = dword ptr -20h
.text$mn:000002DC var_1C          = dword ptr -1Ch
.text$mn:000002DC var_18          = dword ptr -18h
.text$mn:000002DC var_14          = dword ptr -14h
.text$mn:000002DC var_10          = dword ptr -10h
.text$mn:000002DC var_C           = dword ptr -0Ch
.text$mn:000002DC var_4           = dword ptr -4
.text$mn:000002DC
.text$mn:000002DC                 push    ebp
.text$mn:000002DD                 mov     ebp, esp
.text$mn:000002DF                 push    0FFFFFFFFh
.text$mn:000002E1                 push    offset __ehhandler$??1DockingManager@@UAE@XZ
.text$mn:000002E6                 mov     eax, large fs:0
.text$mn:000002EC                 push    eax
.text$mn:000002ED                 sub     esp, 14h
.text$mn:000002F0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000002F5                 xor     eax, ebp
.text$mn:000002F7                 push    eax
.text$mn:000002F8                 lea     eax, [ebp+var_C]
.text$mn:000002FB                 mov     large fs:0, eax
.text$mn:00000301                 mov     [ebp+var_10], ecx
.text$mn:00000304                 mov     eax, [ebp+var_10]
.text$mn:00000307                 mov     dword ptr [eax], offset ??_7DockingManager@@6B@ ; const DockingManager::`vftable'
.text$mn:0000030D                 mov     [ebp+var_4], 3
.text$mn:00000314                 mov     [ebp+var_14], 0
.text$mn:0000031B                 jmp     short loc_326
.text$mn:0000031D ; ---------------------------------------------------------------------------
.text$mn:0000031D
.text$mn:0000031D loc_31D:                                ; CODE XREF: DockingManager::~DockingManager(void):loc_369j
.text$mn:0000031D                 mov     ecx, [ebp+var_14]
.text$mn:00000320                 add     ecx, 1
.text$mn:00000323                 mov     [ebp+var_14], ecx
.text$mn:00000326
.text$mn:00000326 loc_326:                                ; CODE XREF: DockingManager::~DockingManager(void)+3Fj
.text$mn:00000326                 cmp     [ebp+var_14], 4
.text$mn:0000032A                 jge     short loc_36B
.text$mn:0000032C                 mov     edx, [ebp+var_14]
.text$mn:0000032F                 push    edx
.text$mn:00000330                 mov     ecx, [ebp+var_10]
.text$mn:00000333                 add     ecx, 16Ch
.text$mn:00000339                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:0000033E                 mov     eax, [eax]
.text$mn:00000340                 mov     [ebp+var_1C], eax
.text$mn:00000343                 mov     ecx, [ebp+var_1C]
.text$mn:00000346                 mov     [ebp+var_18], ecx
.text$mn:00000349                 cmp     [ebp+var_18], 0
.text$mn:0000034D                 jz      short loc_362
.text$mn:0000034F                 push    1
.text$mn:00000351                 mov     edx, [ebp+var_18]
.text$mn:00000354                 mov     eax, [edx]
.text$mn:00000356                 mov     ecx, [ebp+var_18]
.text$mn:00000359                 mov     edx, [eax]
.text$mn:0000035B                 call    edx
.text$mn:0000035D                 mov     [ebp+var_20], eax
.text$mn:00000360                 jmp     short loc_369
.text$mn:00000362 ; ---------------------------------------------------------------------------
.text$mn:00000362
.text$mn:00000362 loc_362:                                ; CODE XREF: DockingManager::~DockingManager(void)+71j
.text$mn:00000362                 mov     [ebp+var_20], 0
.text$mn:00000369
.text$mn:00000369 loc_369:                                ; CODE XREF: DockingManager::~DockingManager(void)+84j
.text$mn:00000369                 jmp     short loc_31D
.text$mn:0000036B ; ---------------------------------------------------------------------------
.text$mn:0000036B
.text$mn:0000036B loc_36B:                                ; CODE XREF: DockingManager::~DockingManager(void)+4Ej
.text$mn:0000036B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000036F                 mov     ecx, [ebp+var_10]
.text$mn:00000372                 add     ecx, 16Ch
.text$mn:00000378                 call    ??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::~vector<DockingSplitter *,std::allocator<DockingSplitter *>>(void)
.text$mn:0000037D                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000381                 mov     ecx, [ebp+var_10]
.text$mn:00000384                 add     ecx, 4Ch ; 'L'
.text$mn:00000387                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:0000038C                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000390                 mov     ecx, [ebp+var_10]
.text$mn:00000393                 add     ecx, 38h ; '8'
.text$mn:00000396                 call    ??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::~vector<HWND__ *,std::allocator<HWND__ *>>(void)
.text$mn:0000039B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000003A2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000003A5                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:000003AA                 mov     ecx, [ebp+var_C]
.text$mn:000003AD                 mov     large fs:0, ecx
.text$mn:000003B4                 pop     ecx
.text$mn:000003B5                 mov     esp, ebp
.text$mn:000003B7                 pop     ebp
.text$mn:000003B8                 retn
.text$mn:000003B8 ??1DockingManager@@UAE@XZ endp
.text$mn:000003B8
.text$mn:000003B8 ; ---------------------------------------------------------------------------
.text$mn:000003B9                 align 4
.text$mn:000003BC
.text$mn:000003BC ; =============== S U B R O U T I N E =======================================
.text$mn:000003BC
.text$mn:000003BC ; Attributes: bp-based frame
.text$mn:000003BC
.text$mn:000003BC ; void __thiscall DockingManager::init(DockingManager *this, HINSTANCE hmod, HWND, struct Window **)
.text$mn:000003BC                 public ?init@DockingManager@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAPAVWindow@@@Z
.text$mn:000003BC ?init@DockingManager@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAPAVWindow@@@Z proc near
.text$mn:000003BC
.text$mn:000003BC WndClass        = WNDCLASSW ptr -58h
.text$mn:000003BC var_30          = byte ptr -30h
.text$mn:000003BC var_24          = byte ptr -24h
.text$mn:000003BC var_18          = byte ptr -18h
.text$mn:000003BC var_C           = dword ptr -0Ch
.text$mn:000003BC var_8           = dword ptr -8
.text$mn:000003BC lpParam         = dword ptr -4
.text$mn:000003BC hmod            = dword ptr  8
.text$mn:000003BC arg_4           = dword ptr  0Ch
.text$mn:000003BC arg_8           = dword ptr  10h
.text$mn:000003BC
.text$mn:000003BC                 push    ebp
.text$mn:000003BD                 mov     ebp, esp
.text$mn:000003BF                 sub     esp, 58h
.text$mn:000003C2                 mov     [ebp+lpParam], ecx
.text$mn:000003C5                 mov     eax, [ebp+arg_4]
.text$mn:000003C8                 push    eax             ; HWND
.text$mn:000003C9                 mov     ecx, [ebp+hmod]
.text$mn:000003CC                 push    ecx             ; HINSTANCE
.text$mn:000003CD                 mov     ecx, [ebp+lpParam] ; this
.text$mn:000003D0                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:000003D5                 cmp     ds:?_isRegistered@DockingManager@@0HA, 0 ; int DockingManager::_isRegistered
.text$mn:000003DC                 jnz     loc_469
.text$mn:000003E2                 mov     [ebp+WndClass.style], 0
.text$mn:000003E9                 mov     [ebp+WndClass.lpfnWndProc], offset ?staticWinProc@DockingManager@@CGJPAUHWND__@@IIJ@Z ; DockingManager::staticWinProc(HWND__ *,uint,uint,long)
.text$mn:000003F0                 mov     [ebp+WndClass.cbClsExtra], 0
.text$mn:000003F7                 mov     [ebp+WndClass.cbWndExtra], 0
.text$mn:000003FE                 mov     edx, [ebp+lpParam]
.text$mn:00000401                 mov     eax, [edx+4]
.text$mn:00000404                 mov     [ebp+WndClass.hInstance], eax
.text$mn:00000407                 mov     [ebp+WndClass.hIcon], 0
.text$mn:0000040E                 push    (offset loc_7EFE+2) ; lpCursorName
.text$mn:00000413                 push    0               ; hInstance
.text$mn:00000415                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:0000041B                 mov     [ebp+WndClass.hCursor], eax
.text$mn:0000041E                 mov     [ebp+WndClass.hbrBackground], 0
.text$mn:00000425                 mov     [ebp+WndClass.lpszMenuName], 0
.text$mn:0000042C                 mov     [ebp+WndClass.lpszClassName], offset $SG126048 ; "dockingManager"
.text$mn:00000433                 lea     ecx, [ebp+WndClass]
.text$mn:00000436                 push    ecx             ; lpWndClass
.text$mn:00000437                 call    dword ptr ds:__imp__RegisterClassW@4 ; RegisterClassW(x)
.text$mn:0000043D                 movzx   edx, ax
.text$mn:00000440                 test    edx, edx
.text$mn:00000442                 jnz     short loc_45F
.text$mn:00000444                 push    offset $SG126052 ; "DockingManager::init : RegisterClass() "...
.text$mn:00000449                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000044C                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000451                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00000456                 lea     eax, [ebp+var_18]
.text$mn:00000459                 push    eax
.text$mn:0000045A                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000045F ; ---------------------------------------------------------------------------
.text$mn:0000045F
.text$mn:0000045F loc_45F:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+86j
.text$mn:0000045F                 mov     ds:?_isRegistered@DockingManager@@0HA, 1 ; int DockingManager::_isRegistered
.text$mn:00000469
.text$mn:00000469 loc_469:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+20j
.text$mn:00000469                 mov     ecx, [ebp+lpParam]
.text$mn:0000046C                 push    ecx             ; lpParam
.text$mn:0000046D                 mov     edx, [ebp+lpParam]
.text$mn:00000470                 mov     eax, [edx+4]
.text$mn:00000473                 push    eax             ; hInstance
.text$mn:00000474                 push    0               ; hMenu
.text$mn:00000476                 mov     ecx, [ebp+lpParam]
.text$mn:00000479                 mov     edx, [ecx+8]
.text$mn:0000047C                 push    edx             ; hWndParent
.text$mn:0000047D                 push    80000000h       ; nHeight
.text$mn:00000482                 push    80000000h       ; nWidth
.text$mn:00000487                 push    80000000h       ; Y
.text$mn:0000048C                 push    80000000h       ; X
.text$mn:00000491                 push    42000000h       ; dwStyle
.text$mn:00000496                 push    offset $SG126058 ; lpWindowName
.text$mn:0000049B                 push    offset $SG126059 ; "dockingManager"
.text$mn:000004A0                 push    0               ; dwExStyle
.text$mn:000004A2                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:000004A8                 mov     ecx, [ebp+lpParam]
.text$mn:000004AB                 mov     [ecx+0Ch], eax
.text$mn:000004AE                 mov     edx, [ebp+lpParam]
.text$mn:000004B1                 cmp     dword ptr [edx+0Ch], 0
.text$mn:000004B5                 jnz     short loc_4D2
.text$mn:000004B7                 push    offset $SG126063 ; "DockingManager::init : CreateWindowEx()"...
.text$mn:000004BC                 lea     ecx, [ebp+var_24] ; this
.text$mn:000004BF                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000004C4                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000004C9                 lea     eax, [ebp+var_24]
.text$mn:000004CC                 push    eax
.text$mn:000004CD                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000004D2 ; ---------------------------------------------------------------------------
.text$mn:000004D2
.text$mn:000004D2 loc_4D2:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+F9j
.text$mn:000004D2                 mov     ecx, [ebp+arg_8]
.text$mn:000004D5                 push    ecx             ; struct Window **
.text$mn:000004D6                 mov     ecx, [ebp+lpParam] ; this
.text$mn:000004D9                 call    ?setClientWnd@DockingManager@@QAEXPAPAVWindow@@@Z ; DockingManager::setClientWnd(Window * *)
.text$mn:000004DE                 mov     [ebp+var_8], 0
.text$mn:000004E5                 jmp     short loc_4F0
.text$mn:000004E7 ; ---------------------------------------------------------------------------
.text$mn:000004E7
.text$mn:000004E7 loc_4E7:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *):loc_5D5j
.text$mn:000004E7                 mov     edx, [ebp+var_8]
.text$mn:000004EA                 add     edx, 1
.text$mn:000004ED                 mov     [ebp+var_8], edx
.text$mn:000004F0
.text$mn:000004F0 loc_4F0:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+129j
.text$mn:000004F0                 cmp     [ebp+var_8], 4
.text$mn:000004F4                 jge     loc_5DA
.text$mn:000004FA                 mov     eax, [ebp+var_8]
.text$mn:000004FD                 push    eax
.text$mn:000004FE                 mov     ecx, [ebp+lpParam]
.text$mn:00000501                 add     ecx, 4Ch ; 'L'
.text$mn:00000504                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000509                 mov     ecx, [eax]
.text$mn:0000050B                 mov     [ebp+var_C], ecx
.text$mn:0000050E                 mov     edx, [ebp+lpParam]
.text$mn:00000511                 mov     eax, [edx+0Ch]
.text$mn:00000514                 push    eax
.text$mn:00000515                 mov     ecx, [ebp+lpParam]
.text$mn:00000518                 mov     edx, [ecx+4]
.text$mn:0000051B                 push    edx
.text$mn:0000051C                 mov     eax, [ebp+var_C]
.text$mn:0000051F                 mov     edx, [eax]
.text$mn:00000521                 mov     ecx, [ebp+var_C]
.text$mn:00000524                 mov     eax, [edx+4]
.text$mn:00000527                 call    eax
.text$mn:00000529                 push    0               ; bool
.text$mn:0000052B                 push    0               ; bool
.text$mn:0000052D                 mov     ecx, [ebp+var_8]
.text$mn:00000530                 push    ecx
.text$mn:00000531                 mov     ecx, [ebp+lpParam]
.text$mn:00000534                 add     ecx, 4Ch ; 'L'
.text$mn:00000537                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:0000053C                 mov     ecx, [eax]      ; this
.text$mn:0000053E                 call    ?doDialog@DockingCont@@QAEX_N0@Z ; DockingCont::doDialog(bool,bool)
.text$mn:00000543                 mov     edx, [ebp+lpParam]
.text$mn:00000546                 mov     eax, [edx+8]
.text$mn:00000549                 push    eax             ; hWndNewParent
.text$mn:0000054A                 mov     ecx, [ebp+var_8]
.text$mn:0000054D                 push    ecx
.text$mn:0000054E                 mov     ecx, [ebp+lpParam]
.text$mn:00000551                 add     ecx, 4Ch ; 'L'
.text$mn:00000554                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000559                 mov     ecx, [eax]      ; this
.text$mn:0000055B                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000560                 push    eax             ; hWndChild
.text$mn:00000561                 call    dword ptr ds:__imp__SetParent@8 ; SetParent(x,x)
.text$mn:00000567                 cmp     [ebp+var_8], 2
.text$mn:0000056B                 jz      short loc_573
.text$mn:0000056D                 cmp     [ebp+var_8], 3
.text$mn:00000571                 jnz     short loc_5A5
.text$mn:00000573
.text$mn:00000573 loc_573:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+1AFj
.text$mn:00000573                 push    2               ; unsigned int
.text$mn:00000575                 mov     edx, [ebp+lpParam]
.text$mn:00000578                 mov     eax, [edx+0Ch]
.text$mn:0000057B                 push    eax             ; HWND
.text$mn:0000057C                 mov     ecx, [ebp+lpParam]
.text$mn:0000057F                 mov     edx, [ecx+8]
.text$mn:00000582                 push    edx             ; HWND
.text$mn:00000583                 mov     eax, [ebp+lpParam]
.text$mn:00000586                 mov     ecx, [eax+4]
.text$mn:00000589                 push    ecx             ; HINSTANCE
.text$mn:0000058A                 mov     edx, [ebp+var_8]
.text$mn:0000058D                 push    edx
.text$mn:0000058E                 mov     ecx, [ebp+lpParam]
.text$mn:00000591                 add     ecx, 16Ch
.text$mn:00000597                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:0000059C                 mov     ecx, [eax]      ; this
.text$mn:0000059E                 call    ?init@DockingSplitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@1I@Z ; DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)
.text$mn:000005A3                 jmp     short loc_5D5
.text$mn:000005A5 ; ---------------------------------------------------------------------------
.text$mn:000005A5
.text$mn:000005A5 loc_5A5:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+1B5j
.text$mn:000005A5                 push    1               ; unsigned int
.text$mn:000005A7                 mov     eax, [ebp+lpParam]
.text$mn:000005AA                 mov     ecx, [eax+0Ch]
.text$mn:000005AD                 push    ecx             ; HWND
.text$mn:000005AE                 mov     edx, [ebp+lpParam]
.text$mn:000005B1                 mov     eax, [edx+8]
.text$mn:000005B4                 push    eax             ; HWND
.text$mn:000005B5                 mov     ecx, [ebp+lpParam]
.text$mn:000005B8                 mov     edx, [ecx+4]
.text$mn:000005BB                 push    edx             ; HINSTANCE
.text$mn:000005BC                 mov     eax, [ebp+var_8]
.text$mn:000005BF                 push    eax
.text$mn:000005C0                 mov     ecx, [ebp+lpParam]
.text$mn:000005C3                 add     ecx, 16Ch
.text$mn:000005C9                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:000005CE                 mov     ecx, [eax]      ; this
.text$mn:000005D0                 call    ?init@DockingSplitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@1I@Z ; DockingSplitter::init(HINSTANCE__ *,HWND__ *,HWND__ *,uint)
.text$mn:000005D5
.text$mn:000005D5 loc_5D5:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+1E7j
.text$mn:000005D5                 jmp     loc_4E7
.text$mn:000005DA ; ---------------------------------------------------------------------------
.text$mn:000005DA
.text$mn:000005DA loc_5DA:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+138j
.text$mn:000005DA                 cmp     ds:_hWndServer, 0
.text$mn:000005E1                 jnz     short loc_5EF
.text$mn:000005E3                 mov     ecx, [ebp+lpParam]
.text$mn:000005E6                 mov     edx, [ecx+0Ch]
.text$mn:000005E9                 mov     ds:_hWndServer, edx
.text$mn:000005EF
.text$mn:000005EF loc_5EF:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+225j
.text$mn:000005EF                 push    0               ; pvReserved
.text$mn:000005F1                 call    dword ptr ds:__imp__CoInitialize@4 ; CoInitialize(x)
.text$mn:000005F7                 cmp     ds:_gWinCallHook, 0
.text$mn:000005FE                 jnz     short loc_61D
.text$mn:00000600                 call    dword ptr ds:__imp__GetCurrentThreadId@0 ; GetCurrentThreadId()
.text$mn:00000606                 push    eax             ; dwThreadId
.text$mn:00000607                 mov     eax, [ebp+hmod]
.text$mn:0000060A                 push    eax             ; hmod
.text$mn:0000060B                 push    offset ?FocusWndProc@@YGJHIJ@Z ; lpfn
.text$mn:00000610                 push    4               ; idHook
.text$mn:00000612                 call    dword ptr ds:__imp__SetWindowsHookExW@16 ; SetWindowsHookExW(x,x,x,x)
.text$mn:00000618                 mov     ds:_gWinCallHook, eax
.text$mn:0000061D
.text$mn:0000061D loc_61D:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+242j
.text$mn:0000061D                 cmp     ds:_gWinCallHook, 0
.text$mn:00000624                 jnz     short loc_641
.text$mn:00000626                 push    offset $SG126076 ; "DockingManager::init : SetWindowsHookEx"...
.text$mn:0000062B                 lea     ecx, [ebp+var_30] ; this
.text$mn:0000062E                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000633                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00000638                 lea     ecx, [ebp+var_30]
.text$mn:0000063B                 push    ecx
.text$mn:0000063C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000641 ; ---------------------------------------------------------------------------
.text$mn:00000641
.text$mn:00000641 loc_641:                                ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+268j
.text$mn:00000641                 mov     edx, [ebp+lpParam]
.text$mn:00000644                 mov     eax, [ebp+lpParam]
.text$mn:00000647                 mov     ecx, [eax+0Ch]
.text$mn:0000064A                 mov     [edx+5Ch], ecx
.text$mn:0000064D                 mov     edx, [ebp+lpParam]
.text$mn:00000650                 mov     dword ptr [edx+0A0h], 1
.text$mn:0000065A                 mov     esp, ebp
.text$mn:0000065C                 pop     ebp
.text$mn:0000065D                 retn    0Ch
.text$mn:0000065D ?init@DockingManager@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAPAVWindow@@@Z endp
.text$mn:0000065D
.text$mn:0000065D ; ---------------------------------------------------------------------------
.text$mn:00000660                 db 0Ch dup(0CCh)
.text$mn:0000066C
.text$mn:0000066C ; =============== S U B R O U T I N E =======================================
.text$mn:0000066C
.text$mn:0000066C ; Attributes: bp-based frame
.text$mn:0000066C
.text$mn:0000066C ; void __thiscall DockingManager::reSizeTo(DockingManager *this, struct tagRECT *)
.text$mn:0000066C                 public ?reSizeTo@DockingManager@@UAEXAAUtagRECT@@@Z
.text$mn:0000066C ?reSizeTo@DockingManager@@UAEXAAUtagRECT@@@Z proc near
.text$mn:0000066C                                         ; DATA XREF: .rdata:00009E1Co
.text$mn:0000066C
.text$mn:0000066C var_B8          = dword ptr -0B8h
.text$mn:0000066C var_B4          = dword ptr -0B4h
.text$mn:0000066C var_B0          = dword ptr -0B0h
.text$mn:0000066C var_AC          = dword ptr -0ACh
.text$mn:0000066C var_A8          = dword ptr -0A8h
.text$mn:0000066C var_A4          = dword ptr -0A4h
.text$mn:0000066C var_A0          = dword ptr -0A0h
.text$mn:0000066C var_9C          = dword ptr -9Ch
.text$mn:0000066C var_98          = dword ptr -98h
.text$mn:0000066C var_94          = dword ptr -94h
.text$mn:0000066C var_90          = dword ptr -90h
.text$mn:0000066C var_8C          = dword ptr -8Ch
.text$mn:0000066C var_88          = dword ptr -88h
.text$mn:0000066C var_84          = dword ptr -84h
.text$mn:0000066C var_80          = dword ptr -80h
.text$mn:0000066C var_7C          = dword ptr -7Ch
.text$mn:0000066C var_78          = dword ptr -78h
.text$mn:0000066C var_74          = dword ptr -74h
.text$mn:0000066C var_70          = dword ptr -70h
.text$mn:0000066C var_6C          = dword ptr -6Ch
.text$mn:0000066C var_68          = dword ptr -68h
.text$mn:0000066C var_64          = dword ptr -64h
.text$mn:0000066C var_60          = dword ptr -60h
.text$mn:0000066C var_5C          = dword ptr -5Ch
.text$mn:0000066C var_58          = dword ptr -58h
.text$mn:0000066C var_54          = dword ptr -54h
.text$mn:0000066C var_50          = dword ptr -50h
.text$mn:0000066C var_4C          = dword ptr -4Ch
.text$mn:0000066C var_48          = dword ptr -48h
.text$mn:0000066C var_44          = dword ptr -44h
.text$mn:0000066C var_40          = dword ptr -40h
.text$mn:0000066C var_3C          = dword ptr -3Ch
.text$mn:0000066C var_38          = dword ptr -38h
.text$mn:0000066C var_34          = dword ptr -34h
.text$mn:0000066C var_30          = dword ptr -30h
.text$mn:0000066C var_2C          = dword ptr -2Ch
.text$mn:0000066C var_28          = dword ptr -28h
.text$mn:0000066C var_24          = dword ptr -24h
.text$mn:0000066C var_20          = dword ptr -20h
.text$mn:0000066C var_1C          = dword ptr -1Ch
.text$mn:0000066C var_18          = dword ptr -18h
.text$mn:0000066C X               = dword ptr -14h
.text$mn:0000066C Y               = dword ptr -10h
.text$mn:0000066C var_C           = dword ptr -0Ch
.text$mn:0000066C cy              = dword ptr -8
.text$mn:0000066C var_4           = dword ptr -4
.text$mn:0000066C arg_0           = dword ptr  8
.text$mn:0000066C
.text$mn:0000066C                 push    ebp
.text$mn:0000066D                 mov     ebp, esp
.text$mn:0000066F                 sub     esp, 0B8h
.text$mn:00000675                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000067A                 xor     eax, ebp
.text$mn:0000067C                 mov     [ebp+var_4], eax
.text$mn:0000067F                 mov     [ebp+var_68], ecx
.text$mn:00000682                 mov     eax, [ebp+var_68]
.text$mn:00000685                 add     eax, 24h ; '$'
.text$mn:00000688                 mov     ecx, [ebp+arg_0]
.text$mn:0000068B                 mov     edx, [ecx]
.text$mn:0000068D                 mov     [eax], edx
.text$mn:0000068F                 mov     edx, [ecx+4]
.text$mn:00000692                 mov     [eax+4], edx
.text$mn:00000695                 mov     edx, [ecx+8]
.text$mn:00000698                 mov     [eax+8], edx
.text$mn:0000069B                 mov     ecx, [ecx+0Ch]
.text$mn:0000069E                 mov     [eax+0Ch], ecx
.text$mn:000006A1                 mov     edx, [ebp+var_68]
.text$mn:000006A4                 add     edx, 14h
.text$mn:000006A7                 mov     eax, [ebp+arg_0]
.text$mn:000006AA                 mov     ecx, [eax]
.text$mn:000006AC                 mov     [edx], ecx
.text$mn:000006AE                 mov     ecx, [eax+4]
.text$mn:000006B1                 mov     [edx+4], ecx
.text$mn:000006B4                 mov     ecx, [eax+8]
.text$mn:000006B7                 mov     [edx+8], ecx
.text$mn:000006BA                 mov     eax, [eax+0Ch]
.text$mn:000006BD                 mov     [edx+0Ch], eax
.text$mn:000006C0                 mov     ecx, [ebp+var_68]
.text$mn:000006C3                 cmp     dword ptr [ecx+0A0h], 0
.text$mn:000006CA                 jnz     short loc_6D1
.text$mn:000006CC                 jmp     loc_EFE
.text$mn:000006D1 ; ---------------------------------------------------------------------------
.text$mn:000006D1
.text$mn:000006D1 loc_6D1:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+5Ej
.text$mn:000006D1                 mov     edx, 10h
.text$mn:000006D6                 shl     edx, 1
.text$mn:000006D8                 mov     eax, [ebp+var_68]
.text$mn:000006DB                 mov     ecx, [ebp+arg_0]
.text$mn:000006DE                 mov     ecx, [ecx]
.text$mn:000006E0                 mov     [eax+edx+60h], ecx
.text$mn:000006E4                 mov     edx, 10h
.text$mn:000006E9                 shl     edx, 1
.text$mn:000006EB                 mov     eax, [ebp+var_68]
.text$mn:000006EE                 mov     ecx, [ebp+arg_0]
.text$mn:000006F1                 mov     ecx, [ecx+4]
.text$mn:000006F4                 mov     [eax+edx+64h], ecx
.text$mn:000006F8                 mov     edx, [ebp+arg_0]
.text$mn:000006FB                 mov     eax, [ebp+arg_0]
.text$mn:000006FE                 mov     ecx, [edx+8]
.text$mn:00000701                 sub     ecx, [eax]
.text$mn:00000703                 mov     edx, 10h
.text$mn:00000708                 shl     edx, 1
.text$mn:0000070A                 mov     eax, [ebp+var_68]
.text$mn:0000070D                 mov     [eax+edx+68h], ecx
.text$mn:00000711                 push    2
.text$mn:00000713                 mov     ecx, [ebp+var_68]
.text$mn:00000716                 add     ecx, 16Ch
.text$mn:0000071C                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:00000721                 mov     ecx, [eax]
.text$mn:00000723                 mov     [ebp+var_AC], ecx
.text$mn:00000729                 push    0
.text$mn:0000072B                 mov     edx, [ebp+var_AC]
.text$mn:00000731                 mov     eax, [edx]
.text$mn:00000733                 mov     ecx, [ebp+var_AC]
.text$mn:00000739                 mov     edx, [eax+0Ch]
.text$mn:0000073C                 call    edx
.text$mn:0000073E                 push    2
.text$mn:00000740                 mov     ecx, [ebp+var_68]
.text$mn:00000743                 add     ecx, 4Ch ; 'L'
.text$mn:00000746                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:0000074B                 mov     eax, [eax]
.text$mn:0000074D                 mov     [ebp+var_90], eax
.text$mn:00000753                 mov     ecx, [ebp+var_90]
.text$mn:00000759                 mov     edx, [ecx]
.text$mn:0000075B                 mov     ecx, [ebp+var_90]
.text$mn:00000761                 mov     eax, [edx+2Ch]
.text$mn:00000764                 call    eax
.text$mn:00000766                 movzx   ecx, al
.text$mn:00000769                 test    ecx, ecx
.text$mn:0000076B                 jz      loc_825
.text$mn:00000771                 mov     edx, 10h
.text$mn:00000776                 shl     edx, 1
.text$mn:00000778                 mov     eax, [ebp+var_68]
.text$mn:0000077B                 mov     ecx, [eax+edx+6Ch]
.text$mn:0000077F                 mov     edx, [ebp+var_68]
.text$mn:00000782                 mov     eax, [edx+18h]
.text$mn:00000785                 lea     ecx, [ecx+eax+4]
.text$mn:00000789                 mov     edx, [ebp+var_68]
.text$mn:0000078C                 mov     [edx+18h], ecx
.text$mn:0000078F                 mov     eax, 10h
.text$mn:00000794                 shl     eax, 1
.text$mn:00000796                 mov     ecx, [ebp+var_68]
.text$mn:00000799                 mov     edx, [ecx+eax+6Ch]
.text$mn:0000079D                 add     edx, 4
.text$mn:000007A0                 mov     eax, [ebp+var_68]
.text$mn:000007A3                 mov     ecx, [eax+20h]
.text$mn:000007A6                 sub     ecx, edx
.text$mn:000007A8                 mov     edx, [ebp+var_68]
.text$mn:000007AB                 mov     [edx+20h], ecx
.text$mn:000007AE                 mov     eax, 10h
.text$mn:000007B3                 shl     eax, 1
.text$mn:000007B5                 mov     ecx, [ebp+var_68]
.text$mn:000007B8                 mov     edx, [ecx+eax+60h]
.text$mn:000007BC                 mov     [ebp+var_34], edx
.text$mn:000007BF                 mov     eax, 10h
.text$mn:000007C4                 shl     eax, 1
.text$mn:000007C6                 mov     ecx, 10h
.text$mn:000007CB                 shl     ecx, 1
.text$mn:000007CD                 mov     edx, [ebp+var_68]
.text$mn:000007D0                 mov     eax, [edx+eax+64h]
.text$mn:000007D4                 mov     edx, [ebp+var_68]
.text$mn:000007D7                 add     eax, [edx+ecx+6Ch]
.text$mn:000007DB                 mov     [ebp+var_30], eax
.text$mn:000007DE                 mov     eax, 10h
.text$mn:000007E3                 shl     eax, 1
.text$mn:000007E5                 mov     ecx, [ebp+var_68]
.text$mn:000007E8                 mov     edx, [ecx+eax+68h]
.text$mn:000007EC                 mov     [ebp+var_2C], edx
.text$mn:000007EF                 mov     [ebp+var_28], 4
.text$mn:000007F6                 push    2
.text$mn:000007F8                 mov     ecx, [ebp+var_68]
.text$mn:000007FB                 add     ecx, 16Ch
.text$mn:00000801                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:00000806                 mov     eax, [eax]
.text$mn:00000808                 mov     [ebp+var_98], eax
.text$mn:0000080E                 lea     ecx, [ebp+var_34]
.text$mn:00000811                 push    ecx
.text$mn:00000812                 mov     edx, [ebp+var_98]
.text$mn:00000818                 mov     eax, [edx]
.text$mn:0000081A                 mov     ecx, [ebp+var_98]
.text$mn:00000820                 mov     edx, [eax+10h]
.text$mn:00000823                 call    edx
.text$mn:00000825
.text$mn:00000825 loc_825:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+FFj
.text$mn:00000825                 mov     eax, 10h
.text$mn:0000082A                 imul    ecx, eax, 3
.text$mn:0000082D                 mov     edx, [ebp+var_68]
.text$mn:00000830                 mov     eax, [ebp+arg_0]
.text$mn:00000833                 mov     eax, [eax]
.text$mn:00000835                 mov     [edx+ecx+60h], eax
.text$mn:00000839                 mov     ecx, [ebp+arg_0]
.text$mn:0000083C                 mov     edx, [ecx+4]
.text$mn:0000083F                 mov     eax, [ebp+arg_0]
.text$mn:00000842                 add     edx, [eax+0Ch]
.text$mn:00000845                 mov     ecx, 10h
.text$mn:0000084A                 imul    eax, ecx, 3
.text$mn:0000084D                 mov     ecx, [ebp+var_68]
.text$mn:00000850                 sub     edx, [ecx+eax+6Ch]
.text$mn:00000854                 mov     eax, 10h
.text$mn:00000859                 imul    ecx, eax, 3
.text$mn:0000085C                 mov     eax, [ebp+var_68]
.text$mn:0000085F                 mov     [eax+ecx+64h], edx
.text$mn:00000863                 mov     ecx, [ebp+arg_0]
.text$mn:00000866                 mov     edx, [ebp+arg_0]
.text$mn:00000869                 mov     eax, [ecx+8]
.text$mn:0000086C                 sub     eax, [edx]
.text$mn:0000086E                 mov     ecx, 10h
.text$mn:00000873                 imul    edx, ecx, 3
.text$mn:00000876                 mov     ecx, [ebp+var_68]
.text$mn:00000879                 mov     [ecx+edx+68h], eax
.text$mn:0000087D                 mov     edx, 10h
.text$mn:00000882                 imul    eax, edx, 3
.text$mn:00000885                 mov     ecx, [ebp+var_68]
.text$mn:00000888                 lea     edx, [ecx+eax+60h]
.text$mn:0000088C                 mov     eax, [edx]
.text$mn:0000088E                 mov     [ebp+X], eax
.text$mn:00000891                 mov     ecx, [edx+4]
.text$mn:00000894                 mov     [ebp+Y], ecx
.text$mn:00000897                 mov     eax, [edx+8]
.text$mn:0000089A                 mov     [ebp+var_C], eax
.text$mn:0000089D                 mov     ecx, [edx+0Ch]
.text$mn:000008A0                 mov     [ebp+cy], ecx
.text$mn:000008A3                 push    3
.text$mn:000008A5                 mov     ecx, [ebp+var_68]
.text$mn:000008A8                 add     ecx, 16Ch
.text$mn:000008AE                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:000008B3                 mov     edx, [eax]
.text$mn:000008B5                 mov     [ebp+var_A0], edx
.text$mn:000008BB                 push    0
.text$mn:000008BD                 mov     eax, [ebp+var_A0]
.text$mn:000008C3                 mov     edx, [eax]
.text$mn:000008C5                 mov     ecx, [ebp+var_A0]
.text$mn:000008CB                 mov     eax, [edx+0Ch]
.text$mn:000008CE                 call    eax
.text$mn:000008D0                 push    3
.text$mn:000008D2                 mov     ecx, [ebp+var_68]
.text$mn:000008D5                 add     ecx, 4Ch ; 'L'
.text$mn:000008D8                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000008DD                 mov     ecx, [eax]
.text$mn:000008DF                 mov     [ebp+var_A8], ecx
.text$mn:000008E5                 mov     edx, [ebp+var_A8]
.text$mn:000008EB                 mov     eax, [edx]
.text$mn:000008ED                 mov     ecx, [ebp+var_A8]
.text$mn:000008F3                 mov     edx, [eax+2Ch]
.text$mn:000008F6                 call    edx
.text$mn:000008F8                 movzx   eax, al
.text$mn:000008FB                 test    eax, eax
.text$mn:000008FD                 jz      loc_9CF
.text$mn:00000903                 mov     ecx, 10h
.text$mn:00000908                 imul    edx, ecx, 3
.text$mn:0000090B                 mov     eax, [ebp+var_68]
.text$mn:0000090E                 mov     ecx, [eax+edx+6Ch]
.text$mn:00000912                 add     ecx, 4
.text$mn:00000915                 mov     edx, [ebp+var_68]
.text$mn:00000918                 mov     eax, [edx+20h]
.text$mn:0000091B                 sub     eax, ecx
.text$mn:0000091D                 mov     ecx, [ebp+var_68]
.text$mn:00000920                 mov     [ecx+20h], eax
.text$mn:00000923                 mov     edx, [ebp+var_68]
.text$mn:00000926                 mov     eax, [ebp+arg_0]
.text$mn:00000929                 mov     ecx, [edx+20h]
.text$mn:0000092C                 cmp     ecx, [eax+4]
.text$mn:0000092F                 jge     short loc_962
.text$mn:00000931                 mov     edx, [ebp+var_68]
.text$mn:00000934                 mov     eax, [edx+18h]
.text$mn:00000937                 mov     ecx, [ebp+arg_0]
.text$mn:0000093A                 mov     edx, [ecx+4]
.text$mn:0000093D                 lea     eax, [eax+edx+4]
.text$mn:00000941                 mov     [ebp+Y], eax
.text$mn:00000944                 mov     ecx, [ebp+var_68]
.text$mn:00000947                 mov     edx, [ebp+arg_0]
.text$mn:0000094A                 mov     eax, [ecx+20h]
.text$mn:0000094D                 sub     eax, [edx+4]
.text$mn:00000950                 add     eax, [ebp+cy]
.text$mn:00000953                 mov     [ebp+cy], eax
.text$mn:00000956                 mov     ecx, [ebp+var_68]
.text$mn:00000959                 mov     edx, [ebp+arg_0]
.text$mn:0000095C                 mov     eax, [edx+4]
.text$mn:0000095F                 mov     [ecx+20h], eax
.text$mn:00000962
.text$mn:00000962 loc_962:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+2C3j
.text$mn:00000962                 mov     ecx, [ebp+cy]
.text$mn:00000965                 add     ecx, 4
.text$mn:00000968                 jns     short loc_984
.text$mn:0000096A                 mov     edx, 10h
.text$mn:0000096F                 shl     edx, 1
.text$mn:00000971                 mov     eax, [ebp+arg_0]
.text$mn:00000974                 mov     ecx, [ebp+var_68]
.text$mn:00000977                 mov     eax, [eax+0Ch]
.text$mn:0000097A                 sub     eax, [ecx+edx+6Ch]
.text$mn:0000097E                 mov     ecx, [ebp+var_68]
.text$mn:00000981                 mov     [ecx+20h], eax
.text$mn:00000984
.text$mn:00000984 loc_984:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+2FCj
.text$mn:00000984                 mov     edx, [ebp+X]
.text$mn:00000987                 mov     [ebp+var_64], edx
.text$mn:0000098A                 mov     eax, [ebp+Y]
.text$mn:0000098D                 sub     eax, 4
.text$mn:00000990                 mov     [ebp+var_60], eax
.text$mn:00000993                 mov     ecx, [ebp+var_C]
.text$mn:00000996                 mov     [ebp+var_5C], ecx
.text$mn:00000999                 mov     [ebp+var_58], 4
.text$mn:000009A0                 push    3
.text$mn:000009A2                 mov     ecx, [ebp+var_68]
.text$mn:000009A5                 add     ecx, 16Ch
.text$mn:000009AB                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:000009B0                 mov     edx, [eax]
.text$mn:000009B2                 mov     [ebp+var_B0], edx
.text$mn:000009B8                 lea     eax, [ebp+var_64]
.text$mn:000009BB                 push    eax
.text$mn:000009BC                 mov     ecx, [ebp+var_B0]
.text$mn:000009C2                 mov     edx, [ecx]
.text$mn:000009C4                 mov     ecx, [ebp+var_B0]
.text$mn:000009CA                 mov     eax, [edx+10h]
.text$mn:000009CD                 call    eax
.text$mn:000009CF
.text$mn:000009CF loc_9CF:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+291j
.text$mn:000009CF                 mov     ecx, 10h
.text$mn:000009D4                 imul    edx, ecx, 0
.text$mn:000009D7                 mov     eax, [ebp+var_68]
.text$mn:000009DA                 mov     ecx, [ebp+arg_0]
.text$mn:000009DD                 mov     ecx, [ecx]
.text$mn:000009DF                 mov     [eax+edx+60h], ecx
.text$mn:000009E3                 mov     edx, 10h
.text$mn:000009E8                 imul    eax, edx, 0
.text$mn:000009EB                 mov     ecx, [ebp+var_68]
.text$mn:000009EE                 mov     edx, [ebp+var_68]
.text$mn:000009F1                 mov     edx, [edx+18h]
.text$mn:000009F4                 mov     [ecx+eax+64h], edx
.text$mn:000009F8                 mov     eax, 10h
.text$mn:000009FD                 imul    ecx, eax, 0
.text$mn:00000A00                 mov     edx, [ebp+var_68]
.text$mn:00000A03                 mov     eax, [ebp+var_68]
.text$mn:00000A06                 mov     eax, [eax+20h]
.text$mn:00000A09                 mov     [edx+ecx+6Ch], eax
.text$mn:00000A0D                 push    0
.text$mn:00000A0F                 mov     ecx, [ebp+var_68]
.text$mn:00000A12                 add     ecx, 16Ch
.text$mn:00000A18                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:00000A1D                 mov     ecx, [eax]
.text$mn:00000A1F                 mov     [ebp+var_B8], ecx
.text$mn:00000A25                 push    0
.text$mn:00000A27                 mov     edx, [ebp+var_B8]
.text$mn:00000A2D                 mov     eax, [edx]
.text$mn:00000A2F                 mov     ecx, [ebp+var_B8]
.text$mn:00000A35                 mov     edx, [eax+0Ch]
.text$mn:00000A38                 call    edx
.text$mn:00000A3A                 push    0
.text$mn:00000A3C                 mov     ecx, [ebp+var_68]
.text$mn:00000A3F                 add     ecx, 4Ch ; 'L'
.text$mn:00000A42                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000A47                 mov     eax, [eax]
.text$mn:00000A49                 mov     [ebp+var_74], eax
.text$mn:00000A4C                 mov     ecx, [ebp+var_74]
.text$mn:00000A4F                 mov     edx, [ecx]
.text$mn:00000A51                 mov     ecx, [ebp+var_74]
.text$mn:00000A54                 mov     eax, [edx+2Ch]
.text$mn:00000A57                 call    eax
.text$mn:00000A59                 movzx   ecx, al
.text$mn:00000A5C                 test    ecx, ecx
.text$mn:00000A5E                 jz      loc_B0F
.text$mn:00000A64                 mov     edx, 10h
.text$mn:00000A69                 imul    eax, edx, 0
.text$mn:00000A6C                 mov     ecx, [ebp+var_68]
.text$mn:00000A6F                 mov     edx, [ecx+eax+68h]
.text$mn:00000A73                 mov     eax, [ebp+var_68]
.text$mn:00000A76                 mov     ecx, [eax+14h]
.text$mn:00000A79                 lea     edx, [edx+ecx+4]
.text$mn:00000A7D                 mov     eax, [ebp+var_68]
.text$mn:00000A80                 mov     [eax+14h], edx
.text$mn:00000A83                 mov     ecx, 10h
.text$mn:00000A88                 imul    edx, ecx, 0
.text$mn:00000A8B                 mov     eax, [ebp+var_68]
.text$mn:00000A8E                 mov     ecx, [eax+edx+68h]
.text$mn:00000A92                 add     ecx, 4
.text$mn:00000A95                 mov     edx, [ebp+var_68]
.text$mn:00000A98                 mov     eax, [edx+1Ch]
.text$mn:00000A9B                 sub     eax, ecx
.text$mn:00000A9D                 mov     ecx, [ebp+var_68]
.text$mn:00000AA0                 mov     [ecx+1Ch], eax
.text$mn:00000AA3                 mov     edx, 10h
.text$mn:00000AA8                 imul    eax, edx, 0
.text$mn:00000AAB                 mov     ecx, [ebp+var_68]
.text$mn:00000AAE                 mov     edx, [ecx+eax+68h]
.text$mn:00000AB2                 mov     [ebp+var_54], edx
.text$mn:00000AB5                 mov     eax, 10h
.text$mn:00000ABA                 imul    ecx, eax, 0
.text$mn:00000ABD                 mov     edx, [ebp+var_68]
.text$mn:00000AC0                 mov     eax, [edx+ecx+64h]
.text$mn:00000AC4                 mov     [ebp+var_50], eax
.text$mn:00000AC7                 mov     [ebp+var_4C], 4
.text$mn:00000ACE                 mov     ecx, 10h
.text$mn:00000AD3                 imul    edx, ecx, 0
.text$mn:00000AD6                 mov     eax, [ebp+var_68]
.text$mn:00000AD9                 mov     ecx, [eax+edx+6Ch]
.text$mn:00000ADD                 mov     [ebp+var_48], ecx
.text$mn:00000AE0                 push    0
.text$mn:00000AE2                 mov     ecx, [ebp+var_68]
.text$mn:00000AE5                 add     ecx, 16Ch
.text$mn:00000AEB                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:00000AF0                 mov     edx, [eax]
.text$mn:00000AF2                 mov     [ebp+var_B4], edx
.text$mn:00000AF8                 lea     eax, [ebp+var_54]
.text$mn:00000AFB                 push    eax
.text$mn:00000AFC                 mov     ecx, [ebp+var_B4]
.text$mn:00000B02                 mov     edx, [ecx]
.text$mn:00000B04                 mov     ecx, [ebp+var_B4]
.text$mn:00000B0A                 mov     eax, [edx+10h]
.text$mn:00000B0D                 call    eax
.text$mn:00000B0F
.text$mn:00000B0F loc_B0F:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+3F2j
.text$mn:00000B0F                 mov     ecx, 10h
.text$mn:00000B14                 shl     ecx, 0
.text$mn:00000B17                 mov     edx, [ebp+arg_0]
.text$mn:00000B1A                 mov     eax, [ebp+var_68]
.text$mn:00000B1D                 mov     edx, [edx+8]
.text$mn:00000B20                 sub     edx, [eax+ecx+68h]
.text$mn:00000B24                 mov     eax, 10h
.text$mn:00000B29                 shl     eax, 0
.text$mn:00000B2C                 mov     ecx, [ebp+var_68]
.text$mn:00000B2F                 mov     [ecx+eax+60h], edx
.text$mn:00000B33                 mov     edx, 10h
.text$mn:00000B38                 shl     edx, 0
.text$mn:00000B3B                 mov     eax, [ebp+var_68]
.text$mn:00000B3E                 mov     ecx, [ebp+var_68]
.text$mn:00000B41                 mov     ecx, [ecx+18h]
.text$mn:00000B44                 mov     [eax+edx+64h], ecx
.text$mn:00000B48                 mov     edx, 10h
.text$mn:00000B4D                 shl     edx, 0
.text$mn:00000B50                 mov     eax, [ebp+var_68]
.text$mn:00000B53                 mov     ecx, [ebp+var_68]
.text$mn:00000B56                 mov     ecx, [ecx+20h]
.text$mn:00000B59                 mov     [eax+edx+6Ch], ecx
.text$mn:00000B5D                 mov     edx, 10h
.text$mn:00000B62                 shl     edx, 0
.text$mn:00000B65                 mov     eax, [ebp+var_68]
.text$mn:00000B68                 lea     ecx, [eax+edx+60h]
.text$mn:00000B6C                 mov     edx, [ecx]
.text$mn:00000B6E                 mov     [ebp+var_24], edx
.text$mn:00000B71                 mov     eax, [ecx+4]
.text$mn:00000B74                 mov     [ebp+var_20], eax
.text$mn:00000B77                 mov     edx, [ecx+8]
.text$mn:00000B7A                 mov     [ebp+var_1C], edx
.text$mn:00000B7D                 mov     eax, [ecx+0Ch]
.text$mn:00000B80                 mov     [ebp+var_18], eax
.text$mn:00000B83                 push    1
.text$mn:00000B85                 mov     ecx, [ebp+var_68]
.text$mn:00000B88                 add     ecx, 16Ch
.text$mn:00000B8E                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:00000B93                 mov     ecx, [eax]
.text$mn:00000B95                 mov     [ebp+var_7C], ecx
.text$mn:00000B98                 push    0
.text$mn:00000B9A                 mov     edx, [ebp+var_7C]
.text$mn:00000B9D                 mov     eax, [edx]
.text$mn:00000B9F                 mov     ecx, [ebp+var_7C]
.text$mn:00000BA2                 mov     edx, [eax+0Ch]
.text$mn:00000BA5                 call    edx
.text$mn:00000BA7                 push    1
.text$mn:00000BA9                 mov     ecx, [ebp+var_68]
.text$mn:00000BAC                 add     ecx, 4Ch ; 'L'
.text$mn:00000BAF                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000BB4                 mov     eax, [eax]
.text$mn:00000BB6                 mov     [ebp+var_9C], eax
.text$mn:00000BBC                 mov     ecx, [ebp+var_9C]
.text$mn:00000BC2                 mov     edx, [ecx]
.text$mn:00000BC4                 mov     ecx, [ebp+var_9C]
.text$mn:00000BCA                 mov     eax, [edx+2Ch]
.text$mn:00000BCD                 call    eax
.text$mn:00000BCF                 movzx   ecx, al
.text$mn:00000BD2                 test    ecx, ecx
.text$mn:00000BD4                 jz      loc_C74
.text$mn:00000BDA                 mov     edx, 10h
.text$mn:00000BDF                 shl     edx, 0
.text$mn:00000BE2                 mov     eax, [ebp+var_68]
.text$mn:00000BE5                 mov     ecx, [eax+edx+68h]
.text$mn:00000BE9                 add     ecx, 4
.text$mn:00000BEC                 mov     edx, [ebp+var_68]
.text$mn:00000BEF                 mov     eax, [edx+1Ch]
.text$mn:00000BF2                 sub     eax, ecx
.text$mn:00000BF4                 mov     ecx, [ebp+var_68]
.text$mn:00000BF7                 mov     [ecx+1Ch], eax
.text$mn:00000BFA                 mov     edx, [ebp+var_68]
.text$mn:00000BFD                 cmp     dword ptr [edx+1Ch], 0Fh
.text$mn:00000C01                 jge     short loc_C29
.text$mn:00000C03                 mov     eax, [ebp+var_68]
.text$mn:00000C06                 mov     ecx, [eax+14h]
.text$mn:00000C09                 add     ecx, 13h
.text$mn:00000C0C                 mov     [ebp+var_24], ecx
.text$mn:00000C0F                 mov     edx, [ebp+var_68]
.text$mn:00000C12                 mov     eax, [edx+1Ch]
.text$mn:00000C15                 mov     ecx, [ebp+var_1C]
.text$mn:00000C18                 lea     edx, [ecx+eax-0Fh]
.text$mn:00000C1C                 mov     [ebp+var_1C], edx
.text$mn:00000C1F                 mov     eax, [ebp+var_68]
.text$mn:00000C22                 mov     dword ptr [eax+1Ch], 0Fh
.text$mn:00000C29
.text$mn:00000C29 loc_C29:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+595j
.text$mn:00000C29                 mov     ecx, [ebp+var_24]
.text$mn:00000C2C                 sub     ecx, 4
.text$mn:00000C2F                 mov     [ebp+var_44], ecx
.text$mn:00000C32                 mov     edx, [ebp+var_20]
.text$mn:00000C35                 mov     [ebp+var_40], edx
.text$mn:00000C38                 mov     [ebp+var_3C], 4
.text$mn:00000C3F                 mov     eax, [ebp+var_18]
.text$mn:00000C42                 mov     [ebp+var_38], eax
.text$mn:00000C45                 push    1
.text$mn:00000C47                 mov     ecx, [ebp+var_68]
.text$mn:00000C4A                 add     ecx, 16Ch
.text$mn:00000C50                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:00000C55                 mov     ecx, [eax]
.text$mn:00000C57                 mov     [ebp+var_84], ecx
.text$mn:00000C5D                 lea     edx, [ebp+var_44]
.text$mn:00000C60                 push    edx
.text$mn:00000C61                 mov     eax, [ebp+var_84]
.text$mn:00000C67                 mov     edx, [eax]
.text$mn:00000C69                 mov     ecx, [ebp+var_84]
.text$mn:00000C6F                 mov     eax, [edx+10h]
.text$mn:00000C72                 call    eax
.text$mn:00000C74
.text$mn:00000C74 loc_C74:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+568j
.text$mn:00000C74                 push    3
.text$mn:00000C76                 mov     ecx, [ebp+var_68]
.text$mn:00000C79                 add     ecx, 4Ch ; 'L'
.text$mn:00000C7C                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000C81                 mov     ecx, [eax]
.text$mn:00000C83                 mov     [ebp+var_6C], ecx
.text$mn:00000C86                 mov     edx, [ebp+var_6C]
.text$mn:00000C89                 mov     eax, [edx]
.text$mn:00000C8B                 mov     ecx, [ebp+var_6C]
.text$mn:00000C8E                 mov     edx, [eax+2Ch]
.text$mn:00000C91                 call    edx
.text$mn:00000C93                 movzx   eax, al
.text$mn:00000C96                 test    eax, eax
.text$mn:00000C98                 jz      short loc_CF6
.text$mn:00000C9A                 push    4               ; uFlags
.text$mn:00000C9C                 mov     ecx, [ebp+cy]
.text$mn:00000C9F                 push    ecx             ; cy
.text$mn:00000CA0                 mov     edx, [ebp+var_C]
.text$mn:00000CA3                 push    edx             ; cx
.text$mn:00000CA4                 mov     eax, [ebp+Y]
.text$mn:00000CA7                 push    eax             ; Y
.text$mn:00000CA8                 mov     ecx, [ebp+X]
.text$mn:00000CAB                 push    ecx             ; X
.text$mn:00000CAC                 push    0               ; hWndInsertAfter
.text$mn:00000CAE                 push    3
.text$mn:00000CB0                 mov     ecx, [ebp+var_68]
.text$mn:00000CB3                 add     ecx, 4Ch ; 'L'
.text$mn:00000CB6                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000CBB                 mov     ecx, [eax]      ; this
.text$mn:00000CBD                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000CC2                 push    eax             ; hWnd
.text$mn:00000CC3                 call    dword ptr ds:__imp__SetWindowPos@28 ; SetWindowPos(x,x,x,x,x,x,x)
.text$mn:00000CC9                 push    3
.text$mn:00000CCB                 mov     ecx, [ebp+var_68]
.text$mn:00000CCE                 add     ecx, 16Ch
.text$mn:00000CD4                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:00000CD9                 mov     edx, [eax]
.text$mn:00000CDB                 mov     [ebp+var_8C], edx
.text$mn:00000CE1                 push    1
.text$mn:00000CE3                 mov     eax, [ebp+var_8C]
.text$mn:00000CE9                 mov     edx, [eax]
.text$mn:00000CEB                 mov     ecx, [ebp+var_8C]
.text$mn:00000CF1                 mov     eax, [edx+0Ch]
.text$mn:00000CF4                 call    eax
.text$mn:00000CF6
.text$mn:00000CF6 loc_CF6:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+62Cj
.text$mn:00000CF6                 push    2
.text$mn:00000CF8                 mov     ecx, [ebp+var_68]
.text$mn:00000CFB                 add     ecx, 4Ch ; 'L'
.text$mn:00000CFE                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000D03                 mov     ecx, [eax]
.text$mn:00000D05                 mov     [ebp+var_A4], ecx
.text$mn:00000D0B                 mov     edx, [ebp+var_A4]
.text$mn:00000D11                 mov     eax, [edx]
.text$mn:00000D13                 mov     ecx, [ebp+var_A4]
.text$mn:00000D19                 mov     edx, [eax+2Ch]
.text$mn:00000D1C                 call    edx
.text$mn:00000D1E                 movzx   eax, al
.text$mn:00000D21                 test    eax, eax
.text$mn:00000D23                 jz      loc_DB1
.text$mn:00000D29                 push    4               ; uFlags
.text$mn:00000D2B                 mov     ecx, 10h
.text$mn:00000D30                 shl     ecx, 1
.text$mn:00000D32                 mov     edx, [ebp+var_68]
.text$mn:00000D35                 mov     eax, [edx+ecx+6Ch]
.text$mn:00000D39                 push    eax             ; cy
.text$mn:00000D3A                 mov     ecx, 10h
.text$mn:00000D3F                 shl     ecx, 1
.text$mn:00000D41                 mov     edx, [ebp+var_68]
.text$mn:00000D44                 mov     eax, [edx+ecx+68h]
.text$mn:00000D48                 push    eax             ; cx
.text$mn:00000D49                 mov     ecx, 10h
.text$mn:00000D4E                 shl     ecx, 1
.text$mn:00000D50                 mov     edx, [ebp+var_68]
.text$mn:00000D53                 mov     eax, [edx+ecx+64h]
.text$mn:00000D57                 push    eax             ; Y
.text$mn:00000D58                 mov     ecx, 10h
.text$mn:00000D5D                 shl     ecx, 1
.text$mn:00000D5F                 mov     edx, [ebp+var_68]
.text$mn:00000D62                 mov     eax, [edx+ecx+60h]
.text$mn:00000D66                 push    eax             ; X
.text$mn:00000D67                 push    0               ; hWndInsertAfter
.text$mn:00000D69                 push    2
.text$mn:00000D6B                 mov     ecx, [ebp+var_68]
.text$mn:00000D6E                 add     ecx, 4Ch ; 'L'
.text$mn:00000D71                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000D76                 mov     ecx, [eax]      ; this
.text$mn:00000D78                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000D7D                 push    eax             ; hWnd
.text$mn:00000D7E                 call    dword ptr ds:__imp__SetWindowPos@28 ; SetWindowPos(x,x,x,x,x,x,x)
.text$mn:00000D84                 push    2
.text$mn:00000D86                 mov     ecx, [ebp+var_68]
.text$mn:00000D89                 add     ecx, 16Ch
.text$mn:00000D8F                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:00000D94                 mov     ecx, [eax]
.text$mn:00000D96                 mov     [ebp+var_94], ecx
.text$mn:00000D9C                 push    1
.text$mn:00000D9E                 mov     edx, [ebp+var_94]
.text$mn:00000DA4                 mov     eax, [edx]
.text$mn:00000DA6                 mov     ecx, [ebp+var_94]
.text$mn:00000DAC                 mov     edx, [eax+0Ch]
.text$mn:00000DAF                 call    edx
.text$mn:00000DB1
.text$mn:00000DB1 loc_DB1:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+6B7j
.text$mn:00000DB1                 push    1
.text$mn:00000DB3                 mov     ecx, [ebp+var_68]
.text$mn:00000DB6                 add     ecx, 4Ch ; 'L'
.text$mn:00000DB9                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000DBE                 mov     eax, [eax]
.text$mn:00000DC0                 mov     [ebp+var_70], eax
.text$mn:00000DC3                 mov     ecx, [ebp+var_70]
.text$mn:00000DC6                 mov     edx, [ecx]
.text$mn:00000DC8                 mov     ecx, [ebp+var_70]
.text$mn:00000DCB                 mov     eax, [edx+2Ch]
.text$mn:00000DCE                 call    eax
.text$mn:00000DD0                 movzx   ecx, al
.text$mn:00000DD3                 test    ecx, ecx
.text$mn:00000DD5                 jz      short loc_E2A
.text$mn:00000DD7                 push    4               ; uFlags
.text$mn:00000DD9                 mov     edx, [ebp+var_18]
.text$mn:00000DDC                 push    edx             ; cy
.text$mn:00000DDD                 mov     eax, [ebp+var_1C]
.text$mn:00000DE0                 push    eax             ; cx
.text$mn:00000DE1                 mov     ecx, [ebp+var_20]
.text$mn:00000DE4                 push    ecx             ; Y
.text$mn:00000DE5                 mov     edx, [ebp+var_24]
.text$mn:00000DE8                 push    edx             ; X
.text$mn:00000DE9                 push    0               ; hWndInsertAfter
.text$mn:00000DEB                 push    1
.text$mn:00000DED                 mov     ecx, [ebp+var_68]
.text$mn:00000DF0                 add     ecx, 4Ch ; 'L'
.text$mn:00000DF3                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000DF8                 mov     ecx, [eax]      ; this
.text$mn:00000DFA                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000DFF                 push    eax             ; hWnd
.text$mn:00000E00                 call    dword ptr ds:__imp__SetWindowPos@28 ; SetWindowPos(x,x,x,x,x,x,x)
.text$mn:00000E06                 push    1
.text$mn:00000E08                 mov     ecx, [ebp+var_68]
.text$mn:00000E0B                 add     ecx, 16Ch
.text$mn:00000E11                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:00000E16                 mov     eax, [eax]
.text$mn:00000E18                 mov     [ebp+var_78], eax
.text$mn:00000E1B                 push    1
.text$mn:00000E1D                 mov     ecx, [ebp+var_78]
.text$mn:00000E20                 mov     edx, [ecx]
.text$mn:00000E22                 mov     ecx, [ebp+var_78]
.text$mn:00000E25                 mov     eax, [edx+0Ch]
.text$mn:00000E28                 call    eax
.text$mn:00000E2A
.text$mn:00000E2A loc_E2A:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+769j
.text$mn:00000E2A                 push    0
.text$mn:00000E2C                 mov     ecx, [ebp+var_68]
.text$mn:00000E2F                 add     ecx, 4Ch ; 'L'
.text$mn:00000E32                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000E37                 mov     ecx, [eax]
.text$mn:00000E39                 mov     [ebp+var_80], ecx
.text$mn:00000E3C                 mov     edx, [ebp+var_80]
.text$mn:00000E3F                 mov     eax, [edx]
.text$mn:00000E41                 mov     ecx, [ebp+var_80]
.text$mn:00000E44                 mov     edx, [eax+2Ch]
.text$mn:00000E47                 call    edx
.text$mn:00000E49                 movzx   eax, al
.text$mn:00000E4C                 test    eax, eax
.text$mn:00000E4E                 jz      loc_EE0
.text$mn:00000E54                 push    4               ; uFlags
.text$mn:00000E56                 mov     ecx, 10h
.text$mn:00000E5B                 imul    edx, ecx, 0
.text$mn:00000E5E                 mov     eax, [ebp+var_68]
.text$mn:00000E61                 mov     ecx, [eax+edx+6Ch]
.text$mn:00000E65                 push    ecx             ; cy
.text$mn:00000E66                 mov     edx, 10h
.text$mn:00000E6B                 imul    eax, edx, 0
.text$mn:00000E6E                 mov     ecx, [ebp+var_68]
.text$mn:00000E71                 mov     edx, [ecx+eax+68h]
.text$mn:00000E75                 push    edx             ; cx
.text$mn:00000E76                 mov     eax, 10h
.text$mn:00000E7B                 imul    ecx, eax, 0
.text$mn:00000E7E                 mov     edx, [ebp+var_68]
.text$mn:00000E81                 mov     eax, [edx+ecx+64h]
.text$mn:00000E85                 push    eax             ; Y
.text$mn:00000E86                 mov     ecx, 10h
.text$mn:00000E8B                 imul    edx, ecx, 0
.text$mn:00000E8E                 mov     eax, [ebp+var_68]
.text$mn:00000E91                 mov     ecx, [eax+edx+60h]
.text$mn:00000E95                 push    ecx             ; X
.text$mn:00000E96                 push    0               ; hWndInsertAfter
.text$mn:00000E98                 push    0
.text$mn:00000E9A                 mov     ecx, [ebp+var_68]
.text$mn:00000E9D                 add     ecx, 4Ch ; 'L'
.text$mn:00000EA0                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000EA5                 mov     ecx, [eax]      ; this
.text$mn:00000EA7                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000EAC                 push    eax             ; hWnd
.text$mn:00000EAD                 call    dword ptr ds:__imp__SetWindowPos@28 ; SetWindowPos(x,x,x,x,x,x,x)
.text$mn:00000EB3                 push    0
.text$mn:00000EB5                 mov     ecx, [ebp+var_68]
.text$mn:00000EB8                 add     ecx, 16Ch
.text$mn:00000EBE                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:00000EC3                 mov     edx, [eax]
.text$mn:00000EC5                 mov     [ebp+var_88], edx
.text$mn:00000ECB                 push    1
.text$mn:00000ECD                 mov     eax, [ebp+var_88]
.text$mn:00000ED3                 mov     edx, [eax]
.text$mn:00000ED5                 mov     ecx, [ebp+var_88]
.text$mn:00000EDB                 mov     eax, [edx+0Ch]
.text$mn:00000EDE                 call    eax
.text$mn:00000EE0
.text$mn:00000EE0 loc_EE0:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+7E2j
.text$mn:00000EE0                 mov     ecx, [ebp+var_68]
.text$mn:00000EE3                 add     ecx, 14h
.text$mn:00000EE6                 push    ecx
.text$mn:00000EE7                 mov     edx, [ebp+var_68]
.text$mn:00000EEA                 mov     eax, [edx+34h]
.text$mn:00000EED                 mov     ecx, [eax]
.text$mn:00000EEF                 mov     edx, [ebp+var_68]
.text$mn:00000EF2                 mov     eax, [edx+34h]
.text$mn:00000EF5                 mov     edx, [ecx]
.text$mn:00000EF7                 mov     ecx, [eax]
.text$mn:00000EF9                 mov     eax, [edx+10h]
.text$mn:00000EFC                 call    eax
.text$mn:00000EFE
.text$mn:00000EFE loc_EFE:                                ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+60j
.text$mn:00000EFE                 mov     ecx, [ebp+var_4]
.text$mn:00000F01                 xor     ecx, ebp
.text$mn:00000F03                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000F08                 mov     esp, ebp
.text$mn:00000F0A                 pop     ebp
.text$mn:00000F0B                 retn    4
.text$mn:00000F0B ?reSizeTo@DockingManager@@UAEXAAUtagRECT@@@Z endp
.text$mn:00000F0B
.text$mn:00000F0B ; ---------------------------------------------------------------------------
.text$mn:00000F0E                 db 0Eh dup(0CCh)
.text$mn:00000F1C
.text$mn:00000F1C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F1C
.text$mn:00000F1C ; Attributes: bp-based frame
.text$mn:00000F1C
.text$mn:00000F1C ; void __thiscall DockingManager::showContainer(DockingManager *this, HWND, int)
.text$mn:00000F1C                 public ?showContainer@DockingManager@@QAEXPAUHWND__@@H@Z
.text$mn:00000F1C ?showContainer@DockingManager@@QAEXPAUHWND__@@H@Z proc near
.text$mn:00000F1C
.text$mn:00000F1C var_C           = dword ptr -0Ch
.text$mn:00000F1C var_8           = dword ptr -8
.text$mn:00000F1C var_4           = dword ptr -4
.text$mn:00000F1C arg_0           = dword ptr  8
.text$mn:00000F1C arg_4           = dword ptr  0Ch
.text$mn:00000F1C
.text$mn:00000F1C                 push    ebp
.text$mn:00000F1D                 mov     ebp, esp
.text$mn:00000F1F                 sub     esp, 0Ch
.text$mn:00000F22                 mov     [ebp+var_8], ecx
.text$mn:00000F25                 mov     [ebp+var_4], 0
.text$mn:00000F2C                 mov     ecx, [ebp+var_8]
.text$mn:00000F2F                 add     ecx, 4Ch ; 'L'
.text$mn:00000F32                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00000F37                 mov     [ebp+var_C], eax
.text$mn:00000F3A                 jmp     short loc_F45
.text$mn:00000F3C ; ---------------------------------------------------------------------------
.text$mn:00000F3C
.text$mn:00000F3C loc_F3C:                                ; CODE XREF: DockingManager::showContainer(HWND__ *,int):loc_F78j
.text$mn:00000F3C                 mov     eax, [ebp+var_4]
.text$mn:00000F3F                 add     eax, 1
.text$mn:00000F42                 mov     [ebp+var_4], eax
.text$mn:00000F45
.text$mn:00000F45 loc_F45:                                ; CODE XREF: DockingManager::showContainer(HWND__ *,int)+1Ej
.text$mn:00000F45                 mov     ecx, [ebp+var_4]
.text$mn:00000F48                 cmp     ecx, [ebp+var_C]
.text$mn:00000F4B                 jnb     short loc_F7A
.text$mn:00000F4D                 mov     edx, [ebp+var_4]
.text$mn:00000F50                 push    edx
.text$mn:00000F51                 mov     ecx, [ebp+var_8]
.text$mn:00000F54                 add     ecx, 4Ch ; 'L'
.text$mn:00000F57                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000F5C                 mov     ecx, [eax]      ; this
.text$mn:00000F5E                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000F63                 cmp     eax, [ebp+arg_0]
.text$mn:00000F66                 jnz     short loc_F78
.text$mn:00000F68                 mov     eax, [ebp+arg_4]
.text$mn:00000F6B                 push    eax             ; int
.text$mn:00000F6C                 mov     ecx, [ebp+var_4]
.text$mn:00000F6F                 push    ecx             ; unsigned int
.text$mn:00000F70                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000F73                 call    ?showContainer@DockingManager@@QAEXIH@Z ; DockingManager::showContainer(uint,int)
.text$mn:00000F78
.text$mn:00000F78 loc_F78:                                ; CODE XREF: DockingManager::showContainer(HWND__ *,int)+4Aj
.text$mn:00000F78                 jmp     short loc_F3C
.text$mn:00000F7A ; ---------------------------------------------------------------------------
.text$mn:00000F7A
.text$mn:00000F7A loc_F7A:                                ; CODE XREF: DockingManager::showContainer(HWND__ *,int)+2Fj
.text$mn:00000F7A                 mov     esp, ebp
.text$mn:00000F7C                 pop     ebp
.text$mn:00000F7D                 retn    8
.text$mn:00000F7D ?showContainer@DockingManager@@QAEXPAUHWND__@@H@Z endp
.text$mn:00000F7D
.text$mn:00000F7D ; ---------------------------------------------------------------------------
.text$mn:00000F80                 db 0Ch dup(0CCh)
.text$mn:00000F8C
.text$mn:00000F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F8C
.text$mn:00000F8C ; Attributes: bp-based frame
.text$mn:00000F8C
.text$mn:00000F8C ; void __thiscall DockingManager::updateContainerInfo(DockingManager *this, HWND)
.text$mn:00000F8C                 public ?updateContainerInfo@DockingManager@@QAEXPAUHWND__@@@Z
.text$mn:00000F8C ?updateContainerInfo@DockingManager@@QAEXPAUHWND__@@@Z proc near
.text$mn:00000F8C
.text$mn:00000F8C var_C           = dword ptr -0Ch
.text$mn:00000F8C var_8           = dword ptr -8
.text$mn:00000F8C var_4           = dword ptr -4
.text$mn:00000F8C arg_0           = dword ptr  8
.text$mn:00000F8C
.text$mn:00000F8C                 push    ebp
.text$mn:00000F8D                 mov     ebp, esp
.text$mn:00000F8F                 sub     esp, 0Ch
.text$mn:00000F92                 mov     [ebp+var_8], ecx
.text$mn:00000F95                 mov     [ebp+var_4], 0
.text$mn:00000F9C                 mov     ecx, [ebp+var_8]
.text$mn:00000F9F                 add     ecx, 4Ch ; 'L'
.text$mn:00000FA2                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00000FA7                 mov     [ebp+var_C], eax
.text$mn:00000FAA                 jmp     short loc_FB5
.text$mn:00000FAC ; ---------------------------------------------------------------------------
.text$mn:00000FAC
.text$mn:00000FAC loc_FAC:                                ; CODE XREF: DockingManager::updateContainerInfo(HWND__ *):loc_FDEj
.text$mn:00000FAC                 mov     eax, [ebp+var_4]
.text$mn:00000FAF                 add     eax, 1
.text$mn:00000FB2                 mov     [ebp+var_4], eax
.text$mn:00000FB5
.text$mn:00000FB5 loc_FB5:                                ; CODE XREF: DockingManager::updateContainerInfo(HWND__ *)+1Ej
.text$mn:00000FB5                 mov     ecx, [ebp+var_4]
.text$mn:00000FB8                 cmp     ecx, [ebp+var_C]
.text$mn:00000FBB                 jnb     short loc_FE0
.text$mn:00000FBD                 mov     edx, [ebp+arg_0]
.text$mn:00000FC0                 push    edx             ; HWND
.text$mn:00000FC1                 mov     eax, [ebp+var_4]
.text$mn:00000FC4                 push    eax
.text$mn:00000FC5                 mov     ecx, [ebp+var_8]
.text$mn:00000FC8                 add     ecx, 4Ch ; 'L'
.text$mn:00000FCB                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000FD0                 mov     ecx, [eax]      ; this
.text$mn:00000FD2                 call    ?updateInfo@DockingCont@@QAEHPAUHWND__@@@Z ; DockingCont::updateInfo(HWND__ *)
.text$mn:00000FD7                 cmp     eax, 1
.text$mn:00000FDA                 jnz     short loc_FDE
.text$mn:00000FDC                 jmp     short loc_FE0
.text$mn:00000FDE ; ---------------------------------------------------------------------------
.text$mn:00000FDE
.text$mn:00000FDE loc_FDE:                                ; CODE XREF: DockingManager::updateContainerInfo(HWND__ *)+4Ej
.text$mn:00000FDE                 jmp     short loc_FAC
.text$mn:00000FE0 ; ---------------------------------------------------------------------------
.text$mn:00000FE0
.text$mn:00000FE0 loc_FE0:                                ; CODE XREF: DockingManager::updateContainerInfo(HWND__ *)+2Fj
.text$mn:00000FE0                                         ; DockingManager::updateContainerInfo(HWND__ *)+50j
.text$mn:00000FE0                 mov     esp, ebp
.text$mn:00000FE2                 pop     ebp
.text$mn:00000FE3                 retn    4
.text$mn:00000FE3 ?updateContainerInfo@DockingManager@@QAEXPAUHWND__@@@Z endp
.text$mn:00000FE3
.text$mn:00000FE3 ; ---------------------------------------------------------------------------
.text$mn:00000FE6                 db 6 dup(0CCh)
.text$mn:00000FEC
.text$mn:00000FEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000FEC
.text$mn:00000FEC ; Attributes: bp-based frame
.text$mn:00000FEC
.text$mn:00000FEC ; public: void __thiscall DockingManager::createDockableDlg(struct tTbData, int, bool)
.text$mn:00000FEC                 public ?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z
.text$mn:00000FEC ?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z proc near
.text$mn:00000FEC
.text$mn:00000FEC var_54          = dword ptr -54h
.text$mn:00000FEC var_50          = dword ptr -50h
.text$mn:00000FEC var_4C          = dword ptr -4Ch
.text$mn:00000FEC var_48          = dword ptr -48h
.text$mn:00000FEC var_44          = dword ptr -44h
.text$mn:00000FEC cy              = dword ptr -40h
.text$mn:00000FEC var_3C          = dword ptr -3Ch
.text$mn:00000FEC var_38          = dword ptr -38h
.text$mn:00000FEC var_34          = dword ptr -34h
.text$mn:00000FEC var_30          = dword ptr -30h
.text$mn:00000FEC var_2C          = dword ptr -2Ch
.text$mn:00000FEC var_28          = dword ptr -28h
.text$mn:00000FEC var_24          = dword ptr -24h
.text$mn:00000FEC Buf2            = dword ptr -20h
.text$mn:00000FEC var_1C          = dword ptr -1Ch
.text$mn:00000FEC var_18          = dword ptr -18h
.text$mn:00000FEC var_14          = dword ptr -14h
.text$mn:00000FEC var_10          = dword ptr -10h
.text$mn:00000FEC var_C           = dword ptr -0Ch
.text$mn:00000FEC var_4           = dword ptr -4
.text$mn:00000FEC hWnd            = dword ptr  8
.text$mn:00000FEC arg_C           = dword ptr  14h
.text$mn:00000FEC hicon           = dword ptr  18h
.text$mn:00000FEC Buf1            = byte ptr  20h
.text$mn:00000FEC arg_28          = dword ptr  30h
.text$mn:00000FEC arg_30          = dword ptr  38h
.text$mn:00000FEC arg_34          = byte ptr  3Ch
.text$mn:00000FEC
.text$mn:00000FEC                 push    ebp
.text$mn:00000FED                 mov     ebp, esp
.text$mn:00000FEF                 push    0FFFFFFFFh
.text$mn:00000FF1                 push    offset __ehhandler$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z
.text$mn:00000FF6                 mov     eax, large fs:0
.text$mn:00000FFC                 push    eax
.text$mn:00000FFD                 sub     esp, 48h
.text$mn:00001000                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001005                 xor     eax, ebp
.text$mn:00001007                 mov     [ebp+var_10], eax
.text$mn:0000100A                 push    esi
.text$mn:0000100B                 push    edi
.text$mn:0000100C                 push    eax
.text$mn:0000100D                 lea     eax, [ebp+var_C]
.text$mn:00001010                 mov     large fs:0, eax
.text$mn:00001016                 mov     [ebp+var_24], ecx
.text$mn:00001019                 mov     eax, [ebp+arg_C]
.text$mn:0000101C                 and     eax, 1
.text$mn:0000101F                 jz      short loc_1080
.text$mn:00001021                 cmp     [ebp+hicon], 0
.text$mn:00001025                 jz      short loc_1080
.text$mn:00001027                 mov     ecx, [ebp+var_24]
.text$mn:0000102A                 cmp     dword ptr [ecx+48h], 0
.text$mn:0000102E                 jnz     short loc_105E
.text$mn:00001030                 push    0Eh             ; int
.text$mn:00001032                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001037                 add     eax, 0Ch
.text$mn:0000103A                 mov     ecx, eax        ; this
.text$mn:0000103C                 call    ?scaleY@DPIManager@@QAEHH@Z ; DPIManager::scaleY(int)
.text$mn:00001041                 mov     [ebp+cy], eax
.text$mn:00001044                 push    0               ; cGrow
.text$mn:00001046                 push    0               ; cInitial
.text$mn:00001048                 push    8               ; flags
.text$mn:0000104A                 mov     edx, [ebp+cy]
.text$mn:0000104D                 push    edx             ; cy
.text$mn:0000104E                 mov     eax, [ebp+cy]
.text$mn:00001051                 push    eax             ; cx
.text$mn:00001052                 call    dword ptr ds:__imp__ImageList_Create@20 ; ImageList_Create(x,x,x,x,x)
.text$mn:00001058                 mov     ecx, [ebp+var_24]
.text$mn:0000105B                 mov     [ecx+48h], eax
.text$mn:0000105E
.text$mn:0000105E loc_105E:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+42j
.text$mn:0000105E                 mov     edx, [ebp+hicon]
.text$mn:00001061                 push    edx             ; hicon
.text$mn:00001062                 push    0FFFFFFFFh      ; i
.text$mn:00001064                 mov     eax, [ebp+var_24]
.text$mn:00001067                 mov     ecx, [eax+48h]
.text$mn:0000106A                 push    ecx             ; himl
.text$mn:0000106B                 call    dword ptr ds:__imp__ImageList_ReplaceIcon@12 ; ImageList_ReplaceIcon(x,x,x)
.text$mn:00001071                 lea     edx, [ebp+hWnd]
.text$mn:00001074                 push    edx
.text$mn:00001075                 mov     ecx, [ebp+var_24]
.text$mn:00001078                 add     ecx, 38h ; '8'
.text$mn:0000107B                 call    ?push_back@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAEXABQAUHWND__@@@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)
.text$mn:00001080
.text$mn:00001080 loc_1080:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+33j
.text$mn:00001080                                         ; DockingManager::createDockableDlg(tTbData,int,bool)+39j
.text$mn:00001080                 mov     [ebp+Buf2], 0
.text$mn:00001087                 mov     [ebp+var_1C], 0
.text$mn:0000108E                 mov     [ebp+var_18], 0
.text$mn:00001095                 mov     [ebp+var_14], 0
.text$mn:0000109C                 mov     [ebp+var_28], 0
.text$mn:000010A3                 push    10h             ; Size
.text$mn:000010A5                 lea     eax, [ebp+Buf2]
.text$mn:000010A8                 push    eax             ; Buf2
.text$mn:000010A9                 lea     ecx, [ebp+Buf1]
.text$mn:000010AC                 push    ecx             ; Buf1
.text$mn:000010AD                 call    _memcmp
.text$mn:000010B2                 add     esp, 0Ch
.text$mn:000010B5                 test    eax, eax
.text$mn:000010B7                 jnz     loc_11C2
.text$mn:000010BD                 lea     edx, [ebp+Buf1]
.text$mn:000010C0                 push    edx             ; lpRect
.text$mn:000010C1                 mov     eax, [ebp+hWnd]
.text$mn:000010C4                 push    eax             ; hWnd
.text$mn:000010C5                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:000010CB                 cmp     [ebp+arg_30], 0FFFFFFFFh
.text$mn:000010CF                 jnz     loc_11BD
.text$mn:000010D5                 mov     ecx, [ebp+hWnd]
.text$mn:000010D8                 push    ecx             ; hWnd
.text$mn:000010D9                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:000010DF                 cmp     eax, 1
.text$mn:000010E2                 jnz     short loc_10ED
.text$mn:000010E4                 mov     [ebp+var_44], 1
.text$mn:000010EB                 jmp     short loc_10F4
.text$mn:000010ED ; ---------------------------------------------------------------------------
.text$mn:000010ED
.text$mn:000010ED loc_10ED:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+F6j
.text$mn:000010ED                 mov     [ebp+var_44], 0
.text$mn:000010F4
.text$mn:000010F4 loc_10F4:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+FFj
.text$mn:000010F4                 mov     dl, byte ptr [ebp+var_44]
.text$mn:000010F7                 mov     [ebp+arg_34], dl
.text$mn:000010FA                 mov     eax, [ebp+arg_C]
.text$mn:000010FD                 and     eax, 80000000h
.text$mn:00001102                 jz      loc_11A7
.text$mn:00001108                 push    0ACh ; '¼'      ; unsigned int
.text$mn:0000110D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001112                 add     esp, 4
.text$mn:00001115                 mov     [ebp+var_3C], eax
.text$mn:00001118                 mov     [ebp+var_4], 0
.text$mn:0000111F                 cmp     [ebp+var_3C], 0
.text$mn:00001123                 jz      short loc_1132
.text$mn:00001125                 mov     ecx, [ebp+var_3C]
.text$mn:00001128                 call    ??0DockingCont@@QAE@XZ ; DockingCont::DockingCont(void)
.text$mn:0000112D                 mov     [ebp+var_38], eax
.text$mn:00001130                 jmp     short loc_1139
.text$mn:00001132 ; ---------------------------------------------------------------------------
.text$mn:00001132
.text$mn:00001132 loc_1132:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+137j
.text$mn:00001132                 mov     [ebp+var_38], 0
.text$mn:00001139
.text$mn:00001139 loc_1139:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+144j
.text$mn:00001139                 mov     ecx, [ebp+var_38]
.text$mn:0000113C                 mov     [ebp+var_4C], ecx
.text$mn:0000113F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001146                 mov     edx, [ebp+var_4C]
.text$mn:00001149                 mov     [ebp+var_28], edx
.text$mn:0000114C                 lea     eax, [ebp+var_28]
.text$mn:0000114F                 push    eax
.text$mn:00001150                 mov     ecx, [ebp+var_24]
.text$mn:00001153                 add     ecx, 4Ch ; 'L'
.text$mn:00001156                 call    ?push_back@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXABQAVDockingCont@@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)
.text$mn:0000115B                 mov     ecx, [ebp+var_24]
.text$mn:0000115E                 mov     edx, [ecx+0Ch]
.text$mn:00001161                 push    edx
.text$mn:00001162                 mov     eax, [ebp+var_24]
.text$mn:00001165                 mov     ecx, [eax+4]
.text$mn:00001168                 push    ecx
.text$mn:00001169                 mov     edx, [ebp+var_28]
.text$mn:0000116C                 mov     eax, [edx]
.text$mn:0000116E                 mov     ecx, [ebp+var_28]
.text$mn:00001171                 mov     edx, [eax+4]
.text$mn:00001174                 call    edx
.text$mn:00001176                 push    1               ; bool
.text$mn:00001178                 movzx   eax, [ebp+arg_34]
.text$mn:0000117C                 push    eax             ; bool
.text$mn:0000117D                 mov     ecx, [ebp+var_28] ; this
.text$mn:00001180                 call    ?doDialog@DockingCont@@QAEX_N0@Z ; DockingCont::doDialog(bool,bool)
.text$mn:00001185                 mov     ecx, [ebp+arg_C]
.text$mn:00001188                 and     ecx, 30000000h
.text$mn:0000118E                 shr     ecx, 1Ch
.text$mn:00001191                 mov     [ebp+arg_28], ecx
.text$mn:00001194                 mov     ecx, [ebp+var_24]
.text$mn:00001197                 add     ecx, 4Ch ; 'L'
.text$mn:0000119A                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:0000119F                 sub     eax, 1
.text$mn:000011A2                 mov     [ebp+arg_30], eax
.text$mn:000011A5                 jmp     short loc_11BD
.text$mn:000011A7 ; ---------------------------------------------------------------------------
.text$mn:000011A7
.text$mn:000011A7 loc_11A7:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+116j
.text$mn:000011A7                 mov     edx, [ebp+arg_C]
.text$mn:000011AA                 and     edx, 30000000h
.text$mn:000011B0                 shr     edx, 1Ch
.text$mn:000011B3                 mov     [ebp+arg_30], edx
.text$mn:000011B6                 mov     [ebp+arg_28], 0FFFFFFFFh
.text$mn:000011BD
.text$mn:000011BD loc_11BD:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+E3j
.text$mn:000011BD                                         ; DockingManager::createDockableDlg(tTbData,int,bool)+1B9j
.text$mn:000011BD                 jmp     loc_1367
.text$mn:000011C2 ; ---------------------------------------------------------------------------
.text$mn:000011C2
.text$mn:000011C2 loc_11C2:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+CBj
.text$mn:000011C2                 cmp     [ebp+arg_30], 4
.text$mn:000011C6                 jge     short loc_11D2
.text$mn:000011C8                 cmp     [ebp+arg_28], 4
.text$mn:000011CC                 jl      loc_1367
.text$mn:000011D2
.text$mn:000011D2 loc_11D2:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+1DAj
.text$mn:000011D2                 cmp     [ebp+arg_30], 4
.text$mn:000011D6                 jl      loc_129D
.text$mn:000011DC                 mov     eax, [ebp+arg_30]
.text$mn:000011DF                 mov     ecx, [ebp+var_24]
.text$mn:000011E2                 cmp     dword ptr [ecx+eax*4+0A4h], 0FFFFFFFFh
.text$mn:000011EA                 jnz     loc_1288
.text$mn:000011F0                 push    0ACh ; '¼'      ; unsigned int
.text$mn:000011F5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000011FA                 add     esp, 4
.text$mn:000011FD                 mov     [ebp+var_2C], eax
.text$mn:00001200                 mov     [ebp+var_4], 1
.text$mn:00001207                 cmp     [ebp+var_2C], 0
.text$mn:0000120B                 jz      short loc_121A
.text$mn:0000120D                 mov     ecx, [ebp+var_2C]
.text$mn:00001210                 call    ??0DockingCont@@QAE@XZ ; DockingCont::DockingCont(void)
.text$mn:00001215                 mov     [ebp+var_48], eax
.text$mn:00001218                 jmp     short loc_1221
.text$mn:0000121A ; ---------------------------------------------------------------------------
.text$mn:0000121A
.text$mn:0000121A loc_121A:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+21Fj
.text$mn:0000121A                 mov     [ebp+var_48], 0
.text$mn:00001221
.text$mn:00001221 loc_1221:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+22Cj
.text$mn:00001221                 mov     edx, [ebp+var_48]
.text$mn:00001224                 mov     [ebp+var_54], edx
.text$mn:00001227                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000122E                 mov     eax, [ebp+var_54]
.text$mn:00001231                 mov     [ebp+var_28], eax
.text$mn:00001234                 lea     ecx, [ebp+var_28]
.text$mn:00001237                 push    ecx
.text$mn:00001238                 mov     ecx, [ebp+var_24]
.text$mn:0000123B                 add     ecx, 4Ch ; 'L'
.text$mn:0000123E                 call    ?push_back@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXABQAVDockingCont@@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)
.text$mn:00001243                 mov     edx, [ebp+var_24]
.text$mn:00001246                 mov     eax, [edx+0Ch]
.text$mn:00001249                 push    eax
.text$mn:0000124A                 mov     ecx, [ebp+var_24]
.text$mn:0000124D                 mov     edx, [ecx+4]
.text$mn:00001250                 push    edx
.text$mn:00001251                 mov     eax, [ebp+var_28]
.text$mn:00001254                 mov     edx, [eax]
.text$mn:00001256                 mov     ecx, [ebp+var_28]
.text$mn:00001259                 mov     eax, [edx+4]
.text$mn:0000125C                 call    eax
.text$mn:0000125E                 push    1               ; bool
.text$mn:00001260                 movzx   ecx, [ebp+arg_34]
.text$mn:00001264                 push    ecx             ; bool
.text$mn:00001265                 mov     ecx, [ebp+var_28] ; this
.text$mn:00001268                 call    ?doDialog@DockingCont@@QAEX_N0@Z ; DockingCont::doDialog(bool,bool)
.text$mn:0000126D                 mov     ecx, [ebp+var_24]
.text$mn:00001270                 add     ecx, 4Ch ; 'L'
.text$mn:00001273                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00001278                 sub     eax, 1
.text$mn:0000127B                 mov     edx, [ebp+arg_30]
.text$mn:0000127E                 mov     ecx, [ebp+var_24]
.text$mn:00001281                 mov     [ecx+edx*4+0A4h], eax
.text$mn:00001288
.text$mn:00001288 loc_1288:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+1FEj
.text$mn:00001288                 mov     edx, [ebp+arg_30]
.text$mn:0000128B                 mov     eax, [ebp+var_24]
.text$mn:0000128E                 mov     ecx, [eax+edx*4+0A4h]
.text$mn:00001295                 mov     [ebp+arg_30], ecx
.text$mn:00001298                 jmp     loc_1367
.text$mn:0000129D ; ---------------------------------------------------------------------------
.text$mn:0000129D
.text$mn:0000129D loc_129D:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+1EAj
.text$mn:0000129D                 mov     edx, [ebp+arg_28]
.text$mn:000012A0                 mov     eax, [ebp+var_24]
.text$mn:000012A3                 cmp     dword ptr [eax+edx*4+0A4h], 0FFFFFFFFh
.text$mn:000012AB                 jnz     loc_1357
.text$mn:000012B1                 push    0ACh ; '¼'      ; unsigned int
.text$mn:000012B6                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000012BB                 add     esp, 4
.text$mn:000012BE                 mov     [ebp+var_30], eax
.text$mn:000012C1                 mov     [ebp+var_4], 2
.text$mn:000012C8                 cmp     [ebp+var_30], 0
.text$mn:000012CC                 jz      short loc_12DB
.text$mn:000012CE                 mov     ecx, [ebp+var_30]
.text$mn:000012D1                 call    ??0DockingCont@@QAE@XZ ; DockingCont::DockingCont(void)
.text$mn:000012D6                 mov     [ebp+var_34], eax
.text$mn:000012D9                 jmp     short loc_12E2
.text$mn:000012DB ; ---------------------------------------------------------------------------
.text$mn:000012DB
.text$mn:000012DB loc_12DB:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+2E0j
.text$mn:000012DB                 mov     [ebp+var_34], 0
.text$mn:000012E2
.text$mn:000012E2 loc_12E2:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+2EDj
.text$mn:000012E2                 mov     ecx, [ebp+var_34]
.text$mn:000012E5                 mov     [ebp+var_50], ecx
.text$mn:000012E8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012EF                 mov     edx, [ebp+var_50]
.text$mn:000012F2                 mov     [ebp+var_28], edx
.text$mn:000012F5                 lea     eax, [ebp+var_28]
.text$mn:000012F8                 push    eax
.text$mn:000012F9                 mov     ecx, [ebp+var_24]
.text$mn:000012FC                 add     ecx, 4Ch ; 'L'
.text$mn:000012FF                 call    ?push_back@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXABQAVDockingCont@@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)
.text$mn:00001304                 mov     ecx, [ebp+var_24]
.text$mn:00001307                 mov     edx, [ecx+0Ch]
.text$mn:0000130A                 push    edx
.text$mn:0000130B                 mov     eax, [ebp+var_24]
.text$mn:0000130E                 mov     ecx, [eax+4]
.text$mn:00001311                 push    ecx
.text$mn:00001312                 mov     edx, [ebp+var_28]
.text$mn:00001315                 mov     eax, [edx]
.text$mn:00001317                 mov     ecx, [ebp+var_28]
.text$mn:0000131A                 mov     edx, [eax+4]
.text$mn:0000131D                 call    edx
.text$mn:0000131F                 push    1               ; bool
.text$mn:00001321                 push    0               ; bool
.text$mn:00001323                 mov     ecx, [ebp+var_28] ; this
.text$mn:00001326                 call    ?doDialog@DockingCont@@QAEX_N0@Z ; DockingCont::doDialog(bool,bool)
.text$mn:0000132B                 lea     eax, [ebp+Buf1]
.text$mn:0000132E                 push    eax
.text$mn:0000132F                 mov     ecx, [ebp+var_28]
.text$mn:00001332                 mov     edx, [ecx]
.text$mn:00001334                 mov     ecx, [ebp+var_28]
.text$mn:00001337                 mov     eax, [edx+14h]
.text$mn:0000133A                 call    eax
.text$mn:0000133C                 mov     ecx, [ebp+var_24]
.text$mn:0000133F                 add     ecx, 4Ch ; 'L'
.text$mn:00001342                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00001347                 sub     eax, 1
.text$mn:0000134A                 mov     ecx, [ebp+arg_28]
.text$mn:0000134D                 mov     edx, [ebp+var_24]
.text$mn:00001350                 mov     [edx+ecx*4+0A4h], eax
.text$mn:00001357
.text$mn:00001357 loc_1357:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+2BFj
.text$mn:00001357                 mov     eax, [ebp+arg_28]
.text$mn:0000135A                 mov     ecx, [ebp+var_24]
.text$mn:0000135D                 mov     edx, [ecx+eax*4+0A4h]
.text$mn:00001364                 mov     [ebp+arg_28], edx
.text$mn:00001367
.text$mn:00001367 loc_1367:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool):loc_11BDj
.text$mn:00001367                                         ; DockingManager::createDockableDlg(tTbData,int,bool)+1E0j ...
.text$mn:00001367                 mov     ecx, [ebp+var_24]
.text$mn:0000136A                 add     ecx, 4Ch ; 'L'
.text$mn:0000136D                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00001372                 cmp     eax, [ebp+arg_30]
.text$mn:00001375                 jbe     short loc_13B0
.text$mn:00001377                 mov     eax, [ebp+arg_30]
.text$mn:0000137A                 push    eax
.text$mn:0000137B                 mov     ecx, [ebp+var_24]
.text$mn:0000137E                 add     ecx, 4Ch ; 'L'
.text$mn:00001381                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001386                 cmp     dword ptr [eax], 0
.text$mn:00001389                 jz      short loc_13B0
.text$mn:0000138B                 sub     esp, 30h
.text$mn:0000138E                 mov     ecx, 0Ch
.text$mn:00001393                 lea     esi, [ebp+hWnd]
.text$mn:00001396                 mov     edi, esp
.text$mn:00001398                 rep movsd
.text$mn:0000139A                 mov     ecx, [ebp+arg_30]
.text$mn:0000139D                 push    ecx
.text$mn:0000139E                 mov     ecx, [ebp+var_24]
.text$mn:000013A1                 add     ecx, 4Ch ; 'L'
.text$mn:000013A4                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000013A9                 mov     ecx, [eax]
.text$mn:000013AB                 call    ?createToolbar@DockingCont@@QAEPAUtTbData@@U2@@Z ; DockingCont::createToolbar(tTbData)
.text$mn:000013B0
.text$mn:000013B0 loc_13B0:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+389j
.text$mn:000013B0                                         ; DockingManager::createDockableDlg(tTbData,int,bool)+39Dj
.text$mn:000013B0                 cmp     [ebp+arg_30], 4
.text$mn:000013B4                 jge     short loc_13D9
.text$mn:000013B6                 mov     edx, [ebp+arg_30]
.text$mn:000013B9                 and     edx, 0FFFFh
.text$mn:000013BF                 movzx   eax, dx
.text$mn:000013C2                 shl     eax, 10h
.text$mn:000013C5                 or      eax, 41Ch
.text$mn:000013CA                 push    eax             ; unsigned int
.text$mn:000013CB                 mov     ecx, [ebp+hWnd]
.text$mn:000013CE                 push    ecx             ; hWnd
.text$mn:000013CF                 mov     ecx, [ebp+var_24] ; this
.text$mn:000013D2                 call    ?SendNotify@DockingManager@@AAEJPAUHWND__@@I@Z ; DockingManager::SendNotify(HWND__ *,uint)
.text$mn:000013D7                 jmp     short loc_13FA
.text$mn:000013D9 ; ---------------------------------------------------------------------------
.text$mn:000013D9
.text$mn:000013D9 loc_13D9:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+3C8j
.text$mn:000013D9                 mov     edx, [ebp+arg_30]
.text$mn:000013DC                 and     edx, 0FFFFh
.text$mn:000013E2                 movzx   eax, dx
.text$mn:000013E5                 shl     eax, 10h
.text$mn:000013E8                 or      eax, 41Dh
.text$mn:000013ED                 push    eax             ; unsigned int
.text$mn:000013EE                 mov     ecx, [ebp+hWnd]
.text$mn:000013F1                 push    ecx             ; hWnd
.text$mn:000013F2                 mov     ecx, [ebp+var_24] ; this
.text$mn:000013F5                 call    ?SendNotify@DockingManager@@AAEJPAUHWND__@@I@Z ; DockingManager::SendNotify(HWND__ *,uint)
.text$mn:000013FA
.text$mn:000013FA loc_13FA:                               ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+3EBj
.text$mn:000013FA                 mov     ecx, [ebp+var_C]
.text$mn:000013FD                 mov     large fs:0, ecx
.text$mn:00001404                 pop     ecx
.text$mn:00001405                 pop     edi
.text$mn:00001406                 pop     esi
.text$mn:00001407                 mov     ecx, [ebp+var_10]
.text$mn:0000140A                 xor     ecx, ebp
.text$mn:0000140C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001411                 mov     esp, ebp
.text$mn:00001413                 pop     ebp
.text$mn:00001414                 retn    38h
.text$mn:00001414 ?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z endp ; sp-analysis failed
.text$mn:00001414
.text$mn:00001414 ; ---------------------------------------------------------------------------
.text$mn:00001417                 db 5 dup(0CCh)
.text$mn:0000141C
.text$mn:0000141C ; =============== S U B R O U T I N E =======================================
.text$mn:0000141C
.text$mn:0000141C ; Attributes: bp-based frame
.text$mn:0000141C
.text$mn:0000141C ; void __thiscall DockingManager::setActiveTab(DockingManager *this, int, int)
.text$mn:0000141C                 public ?setActiveTab@DockingManager@@QAEXHH@Z
.text$mn:0000141C ?setActiveTab@DockingManager@@QAEXHH@Z proc near
.text$mn:0000141C
.text$mn:0000141C var_4           = dword ptr -4
.text$mn:0000141C arg_0           = dword ptr  8
.text$mn:0000141C arg_4           = dword ptr  0Ch
.text$mn:0000141C
.text$mn:0000141C                 push    ebp
.text$mn:0000141D                 mov     ebp, esp
.text$mn:0000141F                 push    ecx
.text$mn:00001420                 mov     [ebp+var_4], ecx
.text$mn:00001423                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00001427                 jz      short loc_1439
.text$mn:00001429                 mov     eax, [ebp+arg_0]
.text$mn:0000142C                 mov     ecx, [ebp+var_4]
.text$mn:0000142F                 cmp     dword ptr [ecx+eax*4+0A4h], 0FFFFFFFFh
.text$mn:00001437                 jnz     short loc_143B
.text$mn:00001439
.text$mn:00001439 loc_1439:                               ; CODE XREF: DockingManager::setActiveTab(int,int)+Bj
.text$mn:00001439                 jmp     short loc_145F
.text$mn:0000143B ; ---------------------------------------------------------------------------
.text$mn:0000143B
.text$mn:0000143B loc_143B:                               ; CODE XREF: DockingManager::setActiveTab(int,int)+1Bj
.text$mn:0000143B                 mov     edx, [ebp+arg_4]
.text$mn:0000143E                 push    edx             ; int
.text$mn:0000143F                 mov     eax, [ebp+arg_0]
.text$mn:00001442                 mov     ecx, [ebp+var_4]
.text$mn:00001445                 mov     edx, [ecx+eax*4+0A4h]
.text$mn:0000144C                 push    edx
.text$mn:0000144D                 mov     ecx, [ebp+var_4]
.text$mn:00001450                 add     ecx, 4Ch ; 'L'
.text$mn:00001453                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001458                 mov     ecx, [eax]      ; this
.text$mn:0000145A                 call    ?setActiveTb@DockingCont@@QAEXH@Z ; DockingCont::setActiveTb(int)
.text$mn:0000145F
.text$mn:0000145F loc_145F:                               ; CODE XREF: DockingManager::setActiveTab(int,int):loc_1439j
.text$mn:0000145F                 mov     esp, ebp
.text$mn:00001461                 pop     ebp
.text$mn:00001462                 retn    8
.text$mn:00001462 ?setActiveTab@DockingManager@@QAEXHH@Z endp
.text$mn:00001462
.text$mn:00001462 ; ---------------------------------------------------------------------------
.text$mn:00001465                 db 7 dup(0CCh)
.text$mn:0000146C
.text$mn:0000146C ; =============== S U B R O U T I N E =======================================
.text$mn:0000146C
.text$mn:0000146C ; Attributes: bp-based frame
.text$mn:0000146C
.text$mn:0000146C ; void __thiscall DockingManager::showDockableDlg(DockingManager *this, HWND, int)
.text$mn:0000146C                 public ?showDockableDlg@DockingManager@@QAEXPAUHWND__@@H@Z
.text$mn:0000146C ?showDockableDlg@DockingManager@@QAEXPAUHWND__@@H@Z proc near
.text$mn:0000146C
.text$mn:0000146C var_10          = dword ptr -10h
.text$mn:0000146C var_C           = dword ptr -0Ch
.text$mn:0000146C var_8           = dword ptr -8
.text$mn:0000146C var_4           = dword ptr -4
.text$mn:0000146C arg_0           = dword ptr  8
.text$mn:0000146C arg_4           = dword ptr  0Ch
.text$mn:0000146C
.text$mn:0000146C                 push    ebp
.text$mn:0000146D                 mov     ebp, esp
.text$mn:0000146F                 sub     esp, 10h
.text$mn:00001472                 mov     [ebp+var_8], ecx
.text$mn:00001475                 mov     [ebp+var_4], 0
.text$mn:0000147C                 mov     ecx, [ebp+var_8]
.text$mn:0000147F                 add     ecx, 4Ch ; 'L'
.text$mn:00001482                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00001487                 mov     [ebp+var_10], eax
.text$mn:0000148A                 jmp     short loc_1495
.text$mn:0000148C ; ---------------------------------------------------------------------------
.text$mn:0000148C
.text$mn:0000148C loc_148C:                               ; CODE XREF: DockingManager::showDockableDlg(HWND__ *,int):loc_14E0j
.text$mn:0000148C                 mov     eax, [ebp+var_4]
.text$mn:0000148F                 add     eax, 1
.text$mn:00001492                 mov     [ebp+var_4], eax
.text$mn:00001495
.text$mn:00001495 loc_1495:                               ; CODE XREF: DockingManager::showDockableDlg(HWND__ *,int)+1Ej
.text$mn:00001495                 mov     ecx, [ebp+var_4]
.text$mn:00001498                 cmp     ecx, [ebp+var_10]
.text$mn:0000149B                 jnb     short loc_14E2
.text$mn:0000149D                 mov     edx, [ebp+arg_0]
.text$mn:000014A0                 push    edx             ; HWND
.text$mn:000014A1                 mov     eax, [ebp+var_4]
.text$mn:000014A4                 push    eax
.text$mn:000014A5                 mov     ecx, [ebp+var_8]
.text$mn:000014A8                 add     ecx, 4Ch ; 'L'
.text$mn:000014AB                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000014B0                 mov     ecx, [eax]      ; this
.text$mn:000014B2                 call    ?findToolbarByWnd@DockingCont@@QAEPAUtTbData@@PAUHWND__@@@Z ; DockingCont::findToolbarByWnd(HWND__ *)
.text$mn:000014B7                 mov     [ebp+var_C], eax
.text$mn:000014BA                 cmp     [ebp+var_C], 0
.text$mn:000014BE                 jz      short loc_14E0
.text$mn:000014C0                 mov     ecx, [ebp+arg_4]
.text$mn:000014C3                 push    ecx             ; int
.text$mn:000014C4                 mov     edx, [ebp+var_C]
.text$mn:000014C7                 push    edx             ; struct tTbData *
.text$mn:000014C8                 mov     eax, [ebp+var_4]
.text$mn:000014CB                 push    eax
.text$mn:000014CC                 mov     ecx, [ebp+var_8]
.text$mn:000014CF                 add     ecx, 4Ch ; 'L'
.text$mn:000014D2                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000014D7                 mov     ecx, [eax]      ; this
.text$mn:000014D9                 call    ?showToolbar@DockingCont@@QAEXPAUtTbData@@H@Z ; DockingCont::showToolbar(tTbData *,int)
.text$mn:000014DE                 jmp     short loc_14E2
.text$mn:000014E0 ; ---------------------------------------------------------------------------
.text$mn:000014E0
.text$mn:000014E0 loc_14E0:                               ; CODE XREF: DockingManager::showDockableDlg(HWND__ *,int)+52j
.text$mn:000014E0                 jmp     short loc_148C
.text$mn:000014E2 ; ---------------------------------------------------------------------------
.text$mn:000014E2
.text$mn:000014E2 loc_14E2:                               ; CODE XREF: DockingManager::showDockableDlg(HWND__ *,int)+2Fj
.text$mn:000014E2                                         ; DockingManager::showDockableDlg(HWND__ *,int)+72j
.text$mn:000014E2                 mov     esp, ebp
.text$mn:000014E4                 pop     ebp
.text$mn:000014E5                 retn    8
.text$mn:000014E5 ?showDockableDlg@DockingManager@@QAEXPAUHWND__@@H@Z endp
.text$mn:000014E5
.text$mn:000014E5 ; ---------------------------------------------------------------------------
.text$mn:000014E8                 db 4 dup(0CCh)
.text$mn:000014EC
.text$mn:000014EC ; =============== S U B R O U T I N E =======================================
.text$mn:000014EC
.text$mn:000014EC ; Attributes: bp-based frame
.text$mn:000014EC
.text$mn:000014EC ; void __thiscall DockingManager::showDockableDlg(DockingManager *this, wchar_t *, int)
.text$mn:000014EC                 public ?showDockableDlg@DockingManager@@QAEXPA_WH@Z
.text$mn:000014EC ?showDockableDlg@DockingManager@@QAEXPA_WH@Z proc near
.text$mn:000014EC
.text$mn:000014EC var_10          = dword ptr -10h
.text$mn:000014EC var_C           = dword ptr -0Ch
.text$mn:000014EC var_8           = dword ptr -8
.text$mn:000014EC var_4           = dword ptr -4
.text$mn:000014EC arg_0           = dword ptr  8
.text$mn:000014EC arg_4           = dword ptr  0Ch
.text$mn:000014EC
.text$mn:000014EC                 push    ebp
.text$mn:000014ED                 mov     ebp, esp
.text$mn:000014EF                 sub     esp, 10h
.text$mn:000014F2                 mov     [ebp+var_C], ecx
.text$mn:000014F5                 mov     [ebp+var_8], 0
.text$mn:000014FC                 mov     [ebp+var_4], 0
.text$mn:00001503                 mov     ecx, [ebp+var_C]
.text$mn:00001506                 add     ecx, 4Ch ; 'L'
.text$mn:00001509                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:0000150E                 mov     [ebp+var_10], eax
.text$mn:00001511                 jmp     short loc_151C
.text$mn:00001513 ; ---------------------------------------------------------------------------
.text$mn:00001513
.text$mn:00001513 loc_1513:                               ; CODE XREF: DockingManager::showDockableDlg(wchar_t *,int):loc_1567j
.text$mn:00001513                 mov     eax, [ebp+var_4]
.text$mn:00001516                 add     eax, 1
.text$mn:00001519                 mov     [ebp+var_4], eax
.text$mn:0000151C
.text$mn:0000151C loc_151C:                               ; CODE XREF: DockingManager::showDockableDlg(wchar_t *,int)+25j
.text$mn:0000151C                 mov     ecx, [ebp+var_4]
.text$mn:0000151F                 cmp     ecx, [ebp+var_10]
.text$mn:00001522                 jnb     short loc_1569
.text$mn:00001524                 mov     edx, [ebp+arg_0]
.text$mn:00001527                 push    edx             ; wchar_t *
.text$mn:00001528                 mov     eax, [ebp+var_4]
.text$mn:0000152B                 push    eax
.text$mn:0000152C                 mov     ecx, [ebp+var_C]
.text$mn:0000152F                 add     ecx, 4Ch ; 'L'
.text$mn:00001532                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001537                 mov     ecx, [eax]      ; this
.text$mn:00001539                 call    ?findToolbarByName@DockingCont@@QAEPAUtTbData@@PA_W@Z ; DockingCont::findToolbarByName(wchar_t *)
.text$mn:0000153E                 mov     [ebp+var_8], eax
.text$mn:00001541                 cmp     [ebp+var_8], 0
.text$mn:00001545                 jz      short loc_1567
.text$mn:00001547                 mov     ecx, [ebp+arg_4]
.text$mn:0000154A                 push    ecx             ; int
.text$mn:0000154B                 mov     edx, [ebp+var_8]
.text$mn:0000154E                 push    edx             ; struct tTbData *
.text$mn:0000154F                 mov     eax, [ebp+var_4]
.text$mn:00001552                 push    eax
.text$mn:00001553                 mov     ecx, [ebp+var_C]
.text$mn:00001556                 add     ecx, 4Ch ; 'L'
.text$mn:00001559                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:0000155E                 mov     ecx, [eax]      ; this
.text$mn:00001560                 call    ?showToolbar@DockingCont@@QAEXPAUtTbData@@H@Z ; DockingCont::showToolbar(tTbData *,int)
.text$mn:00001565                 jmp     short loc_1569
.text$mn:00001567 ; ---------------------------------------------------------------------------
.text$mn:00001567
.text$mn:00001567 loc_1567:                               ; CODE XREF: DockingManager::showDockableDlg(wchar_t *,int)+59j
.text$mn:00001567                 jmp     short loc_1513
.text$mn:00001569 ; ---------------------------------------------------------------------------
.text$mn:00001569
.text$mn:00001569 loc_1569:                               ; CODE XREF: DockingManager::showDockableDlg(wchar_t *,int)+36j
.text$mn:00001569                                         ; DockingManager::showDockableDlg(wchar_t *,int)+79j
.text$mn:00001569                 mov     esp, ebp
.text$mn:0000156B                 pop     ebp
.text$mn:0000156C                 retn    8
.text$mn:0000156C ?showDockableDlg@DockingManager@@QAEXPA_WH@Z endp
.text$mn:0000156C
.text$mn:0000156C ; ---------------------------------------------------------------------------
.text$mn:0000156F                 db 0Dh dup(0CCh)
.text$mn:0000157C
.text$mn:0000157C ; =============== S U B R O U T I N E =======================================
.text$mn:0000157C
.text$mn:0000157C ; Attributes: bp-based frame
.text$mn:0000157C
.text$mn:0000157C ; struct DockingCont *__thiscall DockingManager::toggleActiveTb(DockingManager *this, struct DockingCont *, unsigned int, int, struct tagRECT *)
.text$mn:0000157C                 public ?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z
.text$mn:0000157C ?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z proc near
.text$mn:0000157C                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+50Cp
.text$mn:0000157C
.text$mn:0000157C var_68          = dword ptr -68h
.text$mn:0000157C var_64          = dword ptr -64h
.text$mn:0000157C var_60          = dword ptr -60h
.text$mn:0000157C var_5C          = dword ptr -5Ch
.text$mn:0000157C var_58          = dword ptr -58h
.text$mn:0000157C var_54          = dword ptr -54h
.text$mn:0000157C var_50          = dword ptr -50h
.text$mn:0000157C var_4C          = dword ptr -4Ch
.text$mn:0000157C var_48          = dword ptr -48h
.text$mn:0000157C var_44          = dword ptr -44h
.text$mn:0000157C hWnd            = dword ptr -40h
.text$mn:0000157C var_28          = dword ptr -28h
.text$mn:0000157C var_24          = dword ptr -24h
.text$mn:0000157C var_20          = dword ptr -20h
.text$mn:0000157C var_1C          = dword ptr -1Ch
.text$mn:0000157C var_18          = dword ptr -18h
.text$mn:0000157C var_10          = dword ptr -10h
.text$mn:0000157C var_C           = dword ptr -0Ch
.text$mn:0000157C var_4           = dword ptr -4
.text$mn:0000157C arg_0           = dword ptr  8
.text$mn:0000157C arg_4           = dword ptr  0Ch
.text$mn:0000157C arg_8           = dword ptr  10h
.text$mn:0000157C arg_C           = dword ptr  14h
.text$mn:0000157C
.text$mn:0000157C                 push    ebp
.text$mn:0000157D                 mov     ebp, esp
.text$mn:0000157F                 push    0FFFFFFFFh
.text$mn:00001581                 push    offset __ehhandler$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z
.text$mn:00001586                 mov     eax, large fs:0
.text$mn:0000158C                 push    eax
.text$mn:0000158D                 sub     esp, 5Ch
.text$mn:00001590                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001595                 xor     eax, ebp
.text$mn:00001597                 mov     [ebp+var_10], eax
.text$mn:0000159A                 push    esi
.text$mn:0000159B                 push    edi
.text$mn:0000159C                 push    eax
.text$mn:0000159D                 lea     eax, [ebp+var_C]
.text$mn:000015A0                 mov     large fs:0, eax
.text$mn:000015A6                 mov     [ebp+var_48], ecx
.text$mn:000015A9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000015AC                 call    ?getDataOfActiveTb@DockingCont@@QAEPAUtTbData@@XZ ; DockingCont::getDataOfActiveTb(void)
.text$mn:000015B1                 mov     ecx, 0Ch
.text$mn:000015B6                 mov     esi, eax
.text$mn:000015B8                 lea     edi, [ebp+hWnd]
.text$mn:000015BB                 rep movsd
.text$mn:000015BD                 mov     eax, [ebp+arg_0]
.text$mn:000015C0                 push    eax             ; struct DockingCont *
.text$mn:000015C1                 mov     ecx, [ebp+var_48] ; this
.text$mn:000015C4                 call    ?GetContainer@DockingManager@@QAEHPAVDockingCont@@@Z ; DockingManager::GetContainer(DockingCont *)
.text$mn:000015C9                 mov     [ebp+var_4C], eax
.text$mn:000015CC                 mov     ecx, [ebp+var_18]
.text$mn:000015CF                 mov     [ebp+var_60], ecx
.text$mn:000015D2                 mov     edx, [ebp+var_60]
.text$mn:000015D5                 push    edx             ; unsigned int
.text$mn:000015D6                 mov     ecx, [ebp+var_48] ; this
.text$mn:000015D9                 call    ?ContExists@DockingManager@@AAEHI@Z ; DockingManager::ContExists(uint)
.text$mn:000015DE                 mov     [ebp+var_64], eax
.text$mn:000015E1                 mov     [ebp+var_44], 0
.text$mn:000015E8                 cmp     [ebp+arg_C], 0
.text$mn:000015EC                 jz      short loc_1608
.text$mn:000015EE                 mov     eax, [ebp+arg_C]
.text$mn:000015F1                 mov     ecx, [eax]
.text$mn:000015F3                 mov     [ebp+var_28], ecx
.text$mn:000015F6                 mov     edx, [eax+4]
.text$mn:000015F9                 mov     [ebp+var_24], edx
.text$mn:000015FC                 mov     ecx, [eax+8]
.text$mn:000015FF                 mov     [ebp+var_20], ecx
.text$mn:00001602                 mov     edx, [eax+0Ch]
.text$mn:00001605                 mov     [ebp+var_1C], edx
.text$mn:00001608
.text$mn:00001608 loc_1608:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+70j
.text$mn:00001608                 cmp     [ebp+var_64], 0
.text$mn:0000160C                 jz      short loc_1618
.text$mn:0000160E                 cmp     [ebp+arg_8], 1
.text$mn:00001612                 jnz     loc_1728
.text$mn:00001618
.text$mn:00001618 loc_1618:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+90j
.text$mn:00001618                 mov     ecx, [ebp+var_48] ; this
.text$mn:0000161B                 call    ?FindEmptyContainer@DockingManager@@AAEHXZ ; DockingManager::FindEmptyContainer(void)
.text$mn:00001620                 mov     [ebp+var_50], eax
.text$mn:00001623                 cmp     [ebp+var_50], 0FFFFFFFFh
.text$mn:00001627                 jnz     loc_16DB
.text$mn:0000162D                 push    0ACh ; '¼'      ; unsigned int
.text$mn:00001632                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001637                 add     esp, 4
.text$mn:0000163A                 mov     [ebp+var_58], eax
.text$mn:0000163D                 mov     [ebp+var_4], 0
.text$mn:00001644                 cmp     [ebp+var_58], 0
.text$mn:00001648                 jz      short loc_1657
.text$mn:0000164A                 mov     ecx, [ebp+var_58]
.text$mn:0000164D                 call    ??0DockingCont@@QAE@XZ ; DockingCont::DockingCont(void)
.text$mn:00001652                 mov     [ebp+var_5C], eax
.text$mn:00001655                 jmp     short loc_165E
.text$mn:00001657 ; ---------------------------------------------------------------------------
.text$mn:00001657
.text$mn:00001657 loc_1657:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+CCj
.text$mn:00001657                 mov     [ebp+var_5C], 0
.text$mn:0000165E
.text$mn:0000165E loc_165E:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+D9j
.text$mn:0000165E                 mov     eax, [ebp+var_5C]
.text$mn:00001661                 mov     [ebp+var_68], eax
.text$mn:00001664                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000166B                 mov     ecx, [ebp+var_68]
.text$mn:0000166E                 mov     [ebp+var_44], ecx
.text$mn:00001671                 mov     edx, [ebp+var_48]
.text$mn:00001674                 mov     eax, [edx+0Ch]
.text$mn:00001677                 push    eax
.text$mn:00001678                 mov     ecx, [ebp+var_48]
.text$mn:0000167B                 mov     edx, [ecx+4]
.text$mn:0000167E                 push    edx
.text$mn:0000167F                 mov     eax, [ebp+var_44]
.text$mn:00001682                 mov     edx, [eax]
.text$mn:00001684                 mov     ecx, [ebp+var_44]
.text$mn:00001687                 mov     eax, [edx+4]
.text$mn:0000168A                 call    eax
.text$mn:0000168C                 push    1               ; bool
.text$mn:0000168E                 push    1               ; bool
.text$mn:00001690                 mov     ecx, [ebp+var_44] ; this
.text$mn:00001693                 call    ?doDialog@DockingCont@@QAEX_N0@Z ; DockingCont::doDialog(bool,bool)
.text$mn:00001698                 cmp     [ebp+arg_8], 0
.text$mn:0000169C                 jz      short loc_16AD
.text$mn:0000169E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000016A1                 call    ?isFloating@DockingCont@@QAE_NXZ ; DockingCont::isFloating(void)
.text$mn:000016A6                 movzx   ecx, al
.text$mn:000016A9                 test    ecx, ecx
.text$mn:000016AB                 jnz     short loc_16B3
.text$mn:000016AD
.text$mn:000016AD loc_16AD:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+120j
.text$mn:000016AD                 mov     edx, [ebp+var_4C]
.text$mn:000016B0                 mov     [ebp+var_18], edx
.text$mn:000016B3
.text$mn:000016B3 loc_16B3:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+12Fj
.text$mn:000016B3                 sub     esp, 30h
.text$mn:000016B6                 mov     ecx, 0Ch
.text$mn:000016BB                 lea     esi, [ebp+hWnd]
.text$mn:000016BE                 mov     edi, esp
.text$mn:000016C0                 rep movsd
.text$mn:000016C2                 mov     ecx, [ebp+var_44]
.text$mn:000016C5                 call    ?createToolbar@DockingCont@@QAEPAUtTbData@@U2@@Z ; DockingCont::createToolbar(tTbData)
.text$mn:000016CA                 lea     eax, [ebp+var_44]
.text$mn:000016CD                 push    eax
.text$mn:000016CE                 mov     ecx, [ebp+var_48]
.text$mn:000016D1                 add     ecx, 4Ch ; 'L'
.text$mn:000016D4                 call    ?push_back@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXABQAVDockingCont@@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)
.text$mn:000016D9                 jmp     short loc_1726
.text$mn:000016DB ; ---------------------------------------------------------------------------
.text$mn:000016DB
.text$mn:000016DB loc_16DB:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+ABj
.text$mn:000016DB                 mov     ecx, [ebp+var_50]
.text$mn:000016DE                 push    ecx
.text$mn:000016DF                 mov     ecx, [ebp+var_48]
.text$mn:000016E2                 add     ecx, 4Ch ; 'L'
.text$mn:000016E5                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000016EA                 mov     edx, [eax]
.text$mn:000016EC                 mov     [ebp+var_44], edx
.text$mn:000016EF                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000016F2                 call    ?isFloating@DockingCont@@QAE_NXZ ; DockingCont::isFloating(void)
.text$mn:000016F7                 movzx   esi, al
.text$mn:000016FA                 mov     ecx, [ebp+var_44] ; this
.text$mn:000016FD                 call    ?isFloating@DockingCont@@QAE_NXZ ; DockingCont::isFloating(void)
.text$mn:00001702                 movzx   eax, al
.text$mn:00001705                 cmp     esi, eax
.text$mn:00001707                 jz      short loc_170F
.text$mn:00001709                 mov     ecx, [ebp+var_4C]
.text$mn:0000170C                 mov     [ebp+var_18], ecx
.text$mn:0000170F
.text$mn:0000170F loc_170F:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+18Bj
.text$mn:0000170F                 sub     esp, 30h
.text$mn:00001712                 mov     ecx, 0Ch
.text$mn:00001717                 lea     esi, [ebp+hWnd]
.text$mn:0000171A                 mov     edi, esp
.text$mn:0000171C                 rep movsd
.text$mn:0000171E                 mov     ecx, [ebp+var_44]
.text$mn:00001721                 call    ?createToolbar@DockingCont@@QAEPAUtTbData@@U2@@Z ; DockingCont::createToolbar(tTbData)
.text$mn:00001726
.text$mn:00001726 loc_1726:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+15Dj
.text$mn:00001726                 jmp     short loc_1759
.text$mn:00001728 ; ---------------------------------------------------------------------------
.text$mn:00001728
.text$mn:00001728 loc_1728:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+96j
.text$mn:00001728                 mov     edx, [ebp+var_60]
.text$mn:0000172B                 push    edx
.text$mn:0000172C                 mov     ecx, [ebp+var_48]
.text$mn:0000172F                 add     ecx, 4Ch ; 'L'
.text$mn:00001732                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001737                 mov     eax, [eax]
.text$mn:00001739                 mov     [ebp+var_44], eax
.text$mn:0000173C                 mov     ecx, [ebp+var_4C]
.text$mn:0000173F                 mov     [ebp+var_18], ecx
.text$mn:00001742                 sub     esp, 30h
.text$mn:00001745                 mov     ecx, 0Ch
.text$mn:0000174A                 lea     esi, [ebp+hWnd]
.text$mn:0000174D                 mov     edi, esp
.text$mn:0000174F                 rep movsd
.text$mn:00001751                 mov     ecx, [ebp+var_44]
.text$mn:00001754                 call    ?createToolbar@DockingCont@@QAEPAUtTbData@@U2@@Z ; DockingCont::createToolbar(tTbData)
.text$mn:00001759
.text$mn:00001759 loc_1759:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *):loc_1726j
.text$mn:00001759                 cmp     [ebp+arg_4], 5002h
.text$mn:00001760                 jnz     short loc_176B
.text$mn:00001762                 mov     [ebp+var_54], 41Ch
.text$mn:00001769                 jmp     short loc_1772
.text$mn:0000176B ; ---------------------------------------------------------------------------
.text$mn:0000176B
.text$mn:0000176B loc_176B:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+1E4j
.text$mn:0000176B                 mov     [ebp+var_54], 41Dh
.text$mn:00001772
.text$mn:00001772 loc_1772:                               ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+1EDj
.text$mn:00001772                 mov     edx, [ebp+var_54]
.text$mn:00001775                 and     edx, 0FFFFh
.text$mn:0000177B                 movzx   esi, dx
.text$mn:0000177E                 mov     eax, [ebp+var_44]
.text$mn:00001781                 push    eax             ; struct DockingCont *
.text$mn:00001782                 mov     ecx, [ebp+var_48] ; this
.text$mn:00001785                 call    ?GetContainer@DockingManager@@QAEHPAVDockingCont@@@Z ; DockingManager::GetContainer(DockingCont *)
.text$mn:0000178A                 and     eax, 0FFFFh
.text$mn:0000178F                 movzx   ecx, ax
.text$mn:00001792                 shl     ecx, 10h
.text$mn:00001795                 or      esi, ecx
.text$mn:00001797                 push    esi             ; unsigned int
.text$mn:00001798                 mov     edx, [ebp+hWnd]
.text$mn:0000179B                 push    edx             ; hWnd
.text$mn:0000179C                 mov     ecx, [ebp+var_48] ; this
.text$mn:0000179F                 call    ?SendNotify@DockingManager@@AAEJPAUHWND__@@I@Z ; DockingManager::SendNotify(HWND__ *,uint)
.text$mn:000017A4                 sub     esp, 30h
.text$mn:000017A7                 mov     ecx, 0Ch
.text$mn:000017AC                 lea     esi, [ebp+hWnd]
.text$mn:000017AF                 mov     edi, esp
.text$mn:000017B1                 rep movsd
.text$mn:000017B3                 mov     eax, [ebp+var_4C]
.text$mn:000017B6                 push    eax
.text$mn:000017B7                 mov     ecx, [ebp+var_48]
.text$mn:000017BA                 add     ecx, 4Ch ; 'L'
.text$mn:000017BD                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000017C2                 mov     ecx, [eax]
.text$mn:000017C4                 call    ?removeToolbar@DockingCont@@QAEXUtTbData@@@Z ; DockingCont::removeToolbar(tTbData)
.text$mn:000017C9                 mov     eax, [ebp+var_44]
.text$mn:000017CC                 mov     ecx, [ebp+var_C]
.text$mn:000017CF                 mov     large fs:0, ecx
.text$mn:000017D6                 pop     ecx
.text$mn:000017D7                 pop     edi
.text$mn:000017D8                 pop     esi
.text$mn:000017D9                 mov     ecx, [ebp+var_10]
.text$mn:000017DC                 xor     ecx, ebp
.text$mn:000017DE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000017E3                 mov     esp, ebp
.text$mn:000017E5                 pop     ebp
.text$mn:000017E6                 retn    10h
.text$mn:000017E6 ?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z endp
.text$mn:000017E6
.text$mn:000017E6 ; ---------------------------------------------------------------------------
.text$mn:000017E9                 align 4
.text$mn:000017EC
.text$mn:000017EC ; =============== S U B R O U T I N E =======================================
.text$mn:000017EC
.text$mn:000017EC ; Attributes: bp-based frame
.text$mn:000017EC
.text$mn:000017EC ; struct DockingCont *__thiscall DockingManager::toggleVisTb(DockingManager *this, struct DockingCont *, unsigned int, struct tagRECT *)
.text$mn:000017EC                 public ?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z
.text$mn:000017EC ?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z proc near
.text$mn:000017EC                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+56Fp
.text$mn:000017EC                                         ; DockingManager::runProc(HWND__ *,uint,uint,long)+589p
.text$mn:000017EC
.text$mn:000017EC var_84          = byte ptr -84h
.text$mn:000017EC var_74          = dword ptr -74h
.text$mn:000017EC var_70          = dword ptr -70h
.text$mn:000017EC var_6C          = dword ptr -6Ch
.text$mn:000017EC var_68          = dword ptr -68h
.text$mn:000017EC var_64          = dword ptr -64h
.text$mn:000017EC var_60          = dword ptr -60h
.text$mn:000017EC var_5C          = dword ptr -5Ch
.text$mn:000017EC var_58          = dword ptr -58h
.text$mn:000017EC var_54          = dword ptr -54h
.text$mn:000017EC var_50          = dword ptr -50h
.text$mn:000017EC var_4C          = dword ptr -4Ch
.text$mn:000017EC var_48          = dword ptr -48h
.text$mn:000017EC var_44          = dword ptr -44h
.text$mn:000017EC hWnd            = dword ptr -40h
.text$mn:000017EC var_28          = dword ptr -28h
.text$mn:000017EC var_24          = dword ptr -24h
.text$mn:000017EC var_20          = dword ptr -20h
.text$mn:000017EC var_1C          = dword ptr -1Ch
.text$mn:000017EC var_18          = dword ptr -18h
.text$mn:000017EC var_10          = dword ptr -10h
.text$mn:000017EC var_C           = dword ptr -0Ch
.text$mn:000017EC var_4           = dword ptr -4
.text$mn:000017EC arg_0           = dword ptr  8
.text$mn:000017EC arg_4           = dword ptr  0Ch
.text$mn:000017EC arg_8           = dword ptr  10h
.text$mn:000017EC
.text$mn:000017EC                 push    ebp
.text$mn:000017ED                 mov     ebp, esp
.text$mn:000017EF                 push    0FFFFFFFFh
.text$mn:000017F1                 push    offset __ehhandler$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z
.text$mn:000017F6                 mov     eax, large fs:0
.text$mn:000017FC                 push    eax
.text$mn:000017FD                 sub     esp, 78h
.text$mn:00001800                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001805                 xor     eax, ebp
.text$mn:00001807                 mov     [ebp+var_10], eax
.text$mn:0000180A                 push    esi
.text$mn:0000180B                 push    edi
.text$mn:0000180C                 push    eax
.text$mn:0000180D                 lea     eax, [ebp+var_C]
.text$mn:00001810                 mov     large fs:0, eax
.text$mn:00001816                 mov     [ebp+var_44], ecx
.text$mn:00001819                 lea     eax, [ebp+var_84]
.text$mn:0000181F                 push    eax
.text$mn:00001820                 mov     ecx, [ebp+arg_0]
.text$mn:00001823                 call    ?getDataOfVisTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ ; DockingCont::getDataOfVisTb(void)
.text$mn:00001828                 mov     [ebp+var_4], 0
.text$mn:0000182F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001832                 call    ?getDataOfActiveTb@DockingCont@@QAEPAUtTbData@@XZ ; DockingCont::getDataOfActiveTb(void)
.text$mn:00001837                 mov     [ebp+var_60], eax
.text$mn:0000183A                 mov     ecx, [ebp+arg_0]
.text$mn:0000183D                 push    ecx             ; struct DockingCont *
.text$mn:0000183E                 mov     ecx, [ebp+var_44] ; this
.text$mn:00001841                 call    ?GetContainer@DockingManager@@QAEHPAVDockingCont@@@Z ; DockingManager::GetContainer(DockingCont *)
.text$mn:00001846                 mov     [ebp+var_54], eax
.text$mn:00001849                 mov     edx, [ebp+var_60]
.text$mn:0000184C                 mov     eax, [edx+28h]
.text$mn:0000184F                 mov     [ebp+var_50], eax
.text$mn:00001852                 mov     ecx, [ebp+var_50]
.text$mn:00001855                 push    ecx             ; unsigned int
.text$mn:00001856                 mov     ecx, [ebp+var_44] ; this
.text$mn:00001859                 call    ?ContExists@DockingManager@@AAEHI@Z ; DockingManager::ContExists(uint)
.text$mn:0000185E                 mov     [ebp+var_58], eax
.text$mn:00001861                 mov     [ebp+var_48], 0
.text$mn:00001868                 push    0               ; bool
.text$mn:0000186A                 push    0               ; bool
.text$mn:0000186C                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000186F                 call    ?doDialog@DockingCont@@QAEX_N0@Z ; DockingCont::doDialog(bool,bool)
.text$mn:00001874                 mov     ecx, [ebp+var_44] ; this
.text$mn:00001877                 call    ?onSize@DockingManager@@AAEXXZ ; DockingManager::onSize(void)
.text$mn:0000187C                 mov     [ebp+var_4C], 0
.text$mn:00001883                 lea     ecx, [ebp+var_84]
.text$mn:00001889                 call    ?size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ ; std::vector<tTbData *,std::allocator<tTbData *>>::size(void)
.text$mn:0000188E                 mov     [ebp+var_6C], eax
.text$mn:00001891                 jmp     short loc_189C
.text$mn:00001893 ; ---------------------------------------------------------------------------
.text$mn:00001893
.text$mn:00001893 loc_1893:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+24Aj
.text$mn:00001893                 mov     edx, [ebp+var_4C]
.text$mn:00001896                 add     edx, 1
.text$mn:00001899                 mov     [ebp+var_4C], edx
.text$mn:0000189C
.text$mn:0000189C loc_189C:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+A5j
.text$mn:0000189C                 mov     eax, [ebp+var_4C]
.text$mn:0000189F                 cmp     eax, [ebp+var_6C]
.text$mn:000018A2                 jnb     loc_1A3B
.text$mn:000018A8                 mov     ecx, [ebp+var_4C]
.text$mn:000018AB                 push    ecx
.text$mn:000018AC                 lea     ecx, [ebp+var_84]
.text$mn:000018B2                 call    ??A?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAEAAPAUtTbData@@I@Z ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)
.text$mn:000018B7                 mov     esi, [eax]
.text$mn:000018B9                 mov     ecx, 0Ch
.text$mn:000018BE                 lea     edi, [ebp+hWnd]
.text$mn:000018C1                 rep movsd
.text$mn:000018C3                 cmp     [ebp+arg_8], 0
.text$mn:000018C7                 jz      short loc_18E3
.text$mn:000018C9                 mov     edx, [ebp+arg_8]
.text$mn:000018CC                 mov     eax, [edx]
.text$mn:000018CE                 mov     [ebp+var_28], eax
.text$mn:000018D1                 mov     ecx, [edx+4]
.text$mn:000018D4                 mov     [ebp+var_24], ecx
.text$mn:000018D7                 mov     eax, [edx+8]
.text$mn:000018DA                 mov     [ebp+var_20], eax
.text$mn:000018DD                 mov     ecx, [edx+0Ch]
.text$mn:000018E0                 mov     [ebp+var_1C], ecx
.text$mn:000018E3
.text$mn:000018E3 loc_18E3:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+DBj
.text$mn:000018E3                 cmp     [ebp+var_58], 0
.text$mn:000018E7                 jnz     loc_1996
.text$mn:000018ED                 push    0ACh ; '¼'      ; unsigned int
.text$mn:000018F2                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000018F7                 add     esp, 4
.text$mn:000018FA                 mov     [ebp+var_68], eax
.text$mn:000018FD                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001901                 cmp     [ebp+var_68], 0
.text$mn:00001905                 jz      short loc_1914
.text$mn:00001907                 mov     ecx, [ebp+var_68]
.text$mn:0000190A                 call    ??0DockingCont@@QAE@XZ ; DockingCont::DockingCont(void)
.text$mn:0000190F                 mov     [ebp+var_64], eax
.text$mn:00001912                 jmp     short loc_191B
.text$mn:00001914 ; ---------------------------------------------------------------------------
.text$mn:00001914
.text$mn:00001914 loc_1914:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+119j
.text$mn:00001914                 mov     [ebp+var_64], 0
.text$mn:0000191B
.text$mn:0000191B loc_191B:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+126j
.text$mn:0000191B                 mov     edx, [ebp+var_64]
.text$mn:0000191E                 mov     [ebp+var_70], edx
.text$mn:00001921                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001925                 mov     eax, [ebp+var_70]
.text$mn:00001928                 mov     [ebp+var_48], eax
.text$mn:0000192B                 mov     ecx, [ebp+var_44]
.text$mn:0000192E                 mov     edx, [ecx+0Ch]
.text$mn:00001931                 push    edx
.text$mn:00001932                 mov     eax, [ebp+var_44]
.text$mn:00001935                 mov     ecx, [eax+4]
.text$mn:00001938                 push    ecx
.text$mn:00001939                 mov     edx, [ebp+var_48]
.text$mn:0000193C                 mov     eax, [edx]
.text$mn:0000193E                 mov     ecx, [ebp+var_48]
.text$mn:00001941                 mov     edx, [eax+4]
.text$mn:00001944                 call    edx
.text$mn:00001946                 push    1               ; bool
.text$mn:00001948                 push    1               ; bool
.text$mn:0000194A                 mov     ecx, [ebp+var_48] ; this
.text$mn:0000194D                 call    ?doDialog@DockingCont@@QAEX_N0@Z ; DockingCont::doDialog(bool,bool)
.text$mn:00001952                 mov     eax, [ebp+var_54]
.text$mn:00001955                 mov     [ebp+var_18], eax
.text$mn:00001958                 sub     esp, 30h
.text$mn:0000195B                 mov     ecx, 0Ch
.text$mn:00001960                 lea     esi, [ebp+hWnd]
.text$mn:00001963                 mov     edi, esp
.text$mn:00001965                 rep movsd
.text$mn:00001967                 mov     ecx, [ebp+var_48]
.text$mn:0000196A                 call    ?createToolbar@DockingCont@@QAEPAUtTbData@@U2@@Z ; DockingCont::createToolbar(tTbData)
.text$mn:0000196F                 lea     ecx, [ebp+var_48]
.text$mn:00001972                 push    ecx
.text$mn:00001973                 mov     ecx, [ebp+var_44]
.text$mn:00001976                 add     ecx, 4Ch ; 'L'
.text$mn:00001979                 call    ?push_back@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXABQAVDockingCont@@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)
.text$mn:0000197E                 mov     [ebp+var_58], 1
.text$mn:00001985                 mov     edx, [ebp+var_48]
.text$mn:00001988                 push    edx             ; struct DockingCont *
.text$mn:00001989                 mov     ecx, [ebp+var_44] ; this
.text$mn:0000198C                 call    ?GetContainer@DockingManager@@QAEHPAVDockingCont@@@Z ; DockingManager::GetContainer(DockingCont *)
.text$mn:00001991                 mov     [ebp+var_50], eax
.text$mn:00001994                 jmp     short loc_19C7
.text$mn:00001996 ; ---------------------------------------------------------------------------
.text$mn:00001996
.text$mn:00001996 loc_1996:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+FBj
.text$mn:00001996                 mov     eax, [ebp+var_50]
.text$mn:00001999                 push    eax
.text$mn:0000199A                 mov     ecx, [ebp+var_44]
.text$mn:0000199D                 add     ecx, 4Ch ; 'L'
.text$mn:000019A0                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000019A5                 mov     ecx, [eax]
.text$mn:000019A7                 mov     [ebp+var_48], ecx
.text$mn:000019AA                 mov     edx, [ebp+var_54]
.text$mn:000019AD                 mov     [ebp+var_18], edx
.text$mn:000019B0                 sub     esp, 30h
.text$mn:000019B3                 mov     ecx, 0Ch
.text$mn:000019B8                 lea     esi, [ebp+hWnd]
.text$mn:000019BB                 mov     edi, esp
.text$mn:000019BD                 rep movsd
.text$mn:000019BF                 mov     ecx, [ebp+var_48]
.text$mn:000019C2                 call    ?createToolbar@DockingCont@@QAEPAUtTbData@@U2@@Z ; DockingCont::createToolbar(tTbData)
.text$mn:000019C7
.text$mn:000019C7 loc_19C7:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+1A8j
.text$mn:000019C7                 cmp     [ebp+arg_4], 5002h
.text$mn:000019CE                 jnz     short loc_19D9
.text$mn:000019D0                 mov     [ebp+var_5C], 41Ch
.text$mn:000019D7                 jmp     short loc_19E0
.text$mn:000019D9 ; ---------------------------------------------------------------------------
.text$mn:000019D9
.text$mn:000019D9 loc_19D9:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+1E2j
.text$mn:000019D9                 mov     [ebp+var_5C], 41Dh
.text$mn:000019E0
.text$mn:000019E0 loc_19E0:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+1EBj
.text$mn:000019E0                 mov     eax, [ebp+var_5C]
.text$mn:000019E3                 and     eax, 0FFFFh
.text$mn:000019E8                 movzx   esi, ax
.text$mn:000019EB                 mov     ecx, [ebp+var_48]
.text$mn:000019EE                 push    ecx             ; struct DockingCont *
.text$mn:000019EF                 mov     ecx, [ebp+var_44] ; this
.text$mn:000019F2                 call    ?GetContainer@DockingManager@@QAEHPAVDockingCont@@@Z ; DockingManager::GetContainer(DockingCont *)
.text$mn:000019F7                 and     eax, 0FFFFh
.text$mn:000019FC                 movzx   edx, ax
.text$mn:000019FF                 shl     edx, 10h
.text$mn:00001A02                 or      esi, edx
.text$mn:00001A04                 push    esi             ; unsigned int
.text$mn:00001A05                 mov     eax, [ebp+hWnd]
.text$mn:00001A08                 push    eax             ; hWnd
.text$mn:00001A09                 mov     ecx, [ebp+var_44] ; this
.text$mn:00001A0C                 call    ?SendNotify@DockingManager@@AAEJPAUHWND__@@I@Z ; DockingManager::SendNotify(HWND__ *,uint)
.text$mn:00001A11                 sub     esp, 30h
.text$mn:00001A14                 mov     ecx, 0Ch
.text$mn:00001A19                 lea     esi, [ebp+hWnd]
.text$mn:00001A1C                 mov     edi, esp
.text$mn:00001A1E                 rep movsd
.text$mn:00001A20                 mov     ecx, [ebp+var_54]
.text$mn:00001A23                 push    ecx
.text$mn:00001A24                 mov     ecx, [ebp+var_44]
.text$mn:00001A27                 add     ecx, 4Ch ; 'L'
.text$mn:00001A2A                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001A2F                 mov     ecx, [eax]
.text$mn:00001A31                 call    ?removeToolbar@DockingCont@@QAEXUtTbData@@@Z ; DockingCont::removeToolbar(tTbData)
.text$mn:00001A36                 jmp     loc_1893
.text$mn:00001A3B ; ---------------------------------------------------------------------------
.text$mn:00001A3B
.text$mn:00001A3B loc_1A3B:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+B6j
.text$mn:00001A3B                 mov     edx, [ebp+var_60]
.text$mn:00001A3E                 push    edx             ; struct tTbData *
.text$mn:00001A3F                 mov     eax, [ebp+var_50]
.text$mn:00001A42                 push    eax
.text$mn:00001A43                 mov     ecx, [ebp+var_44]
.text$mn:00001A46                 add     ecx, 4Ch ; 'L'
.text$mn:00001A49                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001A4E                 mov     ecx, [eax]      ; this
.text$mn:00001A50                 call    ?setActiveTb@DockingCont@@QAEXPAUtTbData@@@Z ; DockingCont::setActiveTb(tTbData *)
.text$mn:00001A55                 mov     ecx, [ebp+var_48]
.text$mn:00001A58                 mov     [ebp+var_74], ecx
.text$mn:00001A5B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A62                 lea     ecx, [ebp+var_84]
.text$mn:00001A68                 call    ??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ ; std::vector<tTbData *,std::allocator<tTbData *>>::~vector<tTbData *,std::allocator<tTbData *>>(void)
.text$mn:00001A6D                 mov     eax, [ebp+var_74]
.text$mn:00001A70                 mov     ecx, [ebp+var_C]
.text$mn:00001A73                 mov     large fs:0, ecx
.text$mn:00001A7A                 pop     ecx
.text$mn:00001A7B                 pop     edi
.text$mn:00001A7C                 pop     esi
.text$mn:00001A7D                 mov     ecx, [ebp+var_10]
.text$mn:00001A80                 xor     ecx, ebp
.text$mn:00001A82                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001A87                 mov     esp, ebp
.text$mn:00001A89                 pop     ebp
.text$mn:00001A8A                 retn    0Ch
.text$mn:00001A8A ?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z endp ; sp-analysis failed
.text$mn:00001A8A
.text$mn:00001A8A ; ---------------------------------------------------------------------------
.text$mn:00001A8D                 db 0Fh dup(0CCh)
.text$mn:00001A9C
.text$mn:00001A9C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A9C
.text$mn:00001A9C ; Attributes: bp-based frame
.text$mn:00001A9C
.text$mn:00001A9C ; void __thiscall DockingManager::toggleActiveTb(DockingManager *this, struct DockingCont *, struct DockingCont *)
.text$mn:00001A9C                 public ?toggleActiveTb@DockingManager@@QAEXPAVDockingCont@@0@Z
.text$mn:00001A9C ?toggleActiveTb@DockingManager@@QAEXPAVDockingCont@@0@Z proc near
.text$mn:00001A9C
.text$mn:00001A9C var_38          = dword ptr -38h
.text$mn:00001A9C var_34          = byte ptr -34h
.text$mn:00001A9C var_4           = dword ptr -4
.text$mn:00001A9C arg_0           = dword ptr  8
.text$mn:00001A9C arg_4           = dword ptr  0Ch
.text$mn:00001A9C
.text$mn:00001A9C                 push    ebp
.text$mn:00001A9D                 mov     ebp, esp
.text$mn:00001A9F                 sub     esp, 38h
.text$mn:00001AA2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001AA7                 xor     eax, ebp
.text$mn:00001AA9                 mov     [ebp+var_4], eax
.text$mn:00001AAC                 push    esi
.text$mn:00001AAD                 push    edi
.text$mn:00001AAE                 mov     [ebp+var_38], ecx
.text$mn:00001AB1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001AB4                 call    ?getDataOfActiveTb@DockingCont@@QAEPAUtTbData@@XZ ; DockingCont::getDataOfActiveTb(void)
.text$mn:00001AB9                 mov     ecx, 0Ch
.text$mn:00001ABE                 mov     esi, eax
.text$mn:00001AC0                 lea     edi, [ebp+var_34]
.text$mn:00001AC3                 rep movsd
.text$mn:00001AC5                 sub     esp, 30h
.text$mn:00001AC8                 mov     ecx, 0Ch
.text$mn:00001ACD                 lea     esi, [ebp+var_34]
.text$mn:00001AD0                 mov     edi, esp
.text$mn:00001AD2                 rep movsd
.text$mn:00001AD4                 mov     eax, [ebp+arg_4]
.text$mn:00001AD7                 push    eax
.text$mn:00001AD8                 mov     ecx, [ebp+arg_0]
.text$mn:00001ADB                 push    ecx
.text$mn:00001ADC                 mov     ecx, [ebp+var_38]
.text$mn:00001ADF                 call    ?toggleTb@DockingManager@@AAEXPAVDockingCont@@0UtTbData@@@Z ; DockingManager::toggleTb(DockingCont *,DockingCont *,tTbData)
.text$mn:00001AE4                 pop     edi
.text$mn:00001AE5                 pop     esi
.text$mn:00001AE6                 mov     ecx, [ebp+var_4]
.text$mn:00001AE9                 xor     ecx, ebp
.text$mn:00001AEB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001AF0                 mov     esp, ebp
.text$mn:00001AF2                 pop     ebp
.text$mn:00001AF3                 retn    8
.text$mn:00001AF3 ?toggleActiveTb@DockingManager@@QAEXPAVDockingCont@@0@Z endp
.text$mn:00001AF3
.text$mn:00001AF3 ; ---------------------------------------------------------------------------
.text$mn:00001AF6                 db 6 dup(0CCh)
.text$mn:00001AFC
.text$mn:00001AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001AFC
.text$mn:00001AFC ; Attributes: bp-based frame
.text$mn:00001AFC
.text$mn:00001AFC ; void __thiscall DockingManager::toggleVisTb(DockingManager *this, struct DockingCont *, struct DockingCont *)
.text$mn:00001AFC                 public ?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z
.text$mn:00001AFC ?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z proc near
.text$mn:00001AFC
.text$mn:00001AFC var_60          = byte ptr -60h
.text$mn:00001AFC var_50          = dword ptr -50h
.text$mn:00001AFC var_4C          = dword ptr -4Ch
.text$mn:00001AFC var_48          = dword ptr -48h
.text$mn:00001AFC var_44          = dword ptr -44h
.text$mn:00001AFC var_40          = byte ptr -40h
.text$mn:00001AFC var_10          = dword ptr -10h
.text$mn:00001AFC var_C           = dword ptr -0Ch
.text$mn:00001AFC var_4           = dword ptr -4
.text$mn:00001AFC arg_0           = dword ptr  8
.text$mn:00001AFC arg_4           = dword ptr  0Ch
.text$mn:00001AFC
.text$mn:00001AFC                 push    ebp
.text$mn:00001AFD                 mov     ebp, esp
.text$mn:00001AFF                 push    0FFFFFFFFh
.text$mn:00001B01                 push    offset __ehhandler$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z
.text$mn:00001B06                 mov     eax, large fs:0
.text$mn:00001B0C                 push    eax
.text$mn:00001B0D                 sub     esp, 54h
.text$mn:00001B10                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B15                 xor     eax, ebp
.text$mn:00001B17                 mov     [ebp+var_10], eax
.text$mn:00001B1A                 push    esi
.text$mn:00001B1B                 push    edi
.text$mn:00001B1C                 push    eax
.text$mn:00001B1D                 lea     eax, [ebp+var_C]
.text$mn:00001B20                 mov     large fs:0, eax
.text$mn:00001B26                 mov     [ebp+var_48], ecx
.text$mn:00001B29                 lea     eax, [ebp+var_60]
.text$mn:00001B2C                 push    eax
.text$mn:00001B2D                 mov     ecx, [ebp+arg_0]
.text$mn:00001B30                 call    ?getDataOfVisTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ ; DockingCont::getDataOfVisTb(void)
.text$mn:00001B35                 mov     [ebp+var_4], 0
.text$mn:00001B3C                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001B3F                 call    ?getDataOfActiveTb@DockingCont@@QAEPAUtTbData@@XZ ; DockingCont::getDataOfActiveTb(void)
.text$mn:00001B44                 mov     [ebp+var_50], eax
.text$mn:00001B47                 push    0               ; bool
.text$mn:00001B49                 push    0               ; bool
.text$mn:00001B4B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001B4E                 call    ?doDialog@DockingCont@@QAEX_N0@Z ; DockingCont::doDialog(bool,bool)
.text$mn:00001B53                 mov     ecx, [ebp+var_48] ; this
.text$mn:00001B56                 call    ?onSize@DockingManager@@AAEXXZ ; DockingManager::onSize(void)
.text$mn:00001B5B                 mov     [ebp+var_44], 0
.text$mn:00001B62                 lea     ecx, [ebp+var_60]
.text$mn:00001B65                 call    ?size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ ; std::vector<tTbData *,std::allocator<tTbData *>>::size(void)
.text$mn:00001B6A                 mov     [ebp+var_4C], eax
.text$mn:00001B6D                 jmp     short loc_1B78
.text$mn:00001B6F ; ---------------------------------------------------------------------------
.text$mn:00001B6F
.text$mn:00001B6F loc_1B6F:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,DockingCont *)+BBj
.text$mn:00001B6F                 mov     ecx, [ebp+var_44]
.text$mn:00001B72                 add     ecx, 1
.text$mn:00001B75                 mov     [ebp+var_44], ecx
.text$mn:00001B78
.text$mn:00001B78 loc_1B78:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,DockingCont *)+71j
.text$mn:00001B78                 mov     edx, [ebp+var_44]
.text$mn:00001B7B                 cmp     edx, [ebp+var_4C]
.text$mn:00001B7E                 jnb     short loc_1BB9
.text$mn:00001B80                 mov     eax, [ebp+var_44]
.text$mn:00001B83                 push    eax
.text$mn:00001B84                 lea     ecx, [ebp+var_60]
.text$mn:00001B87                 call    ??A?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAEAAPAUtTbData@@I@Z ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)
.text$mn:00001B8C                 mov     esi, [eax]
.text$mn:00001B8E                 mov     ecx, 0Ch
.text$mn:00001B93                 lea     edi, [ebp+var_40]
.text$mn:00001B96                 rep movsd
.text$mn:00001B98                 sub     esp, 30h
.text$mn:00001B9B                 mov     ecx, 0Ch
.text$mn:00001BA0                 lea     esi, [ebp+var_40]
.text$mn:00001BA3                 mov     edi, esp
.text$mn:00001BA5                 rep movsd
.text$mn:00001BA7                 mov     ecx, [ebp+arg_4]
.text$mn:00001BAA                 push    ecx
.text$mn:00001BAB                 mov     edx, [ebp+arg_0]
.text$mn:00001BAE                 push    edx
.text$mn:00001BAF                 mov     ecx, [ebp+var_48]
.text$mn:00001BB2                 call    ?toggleTb@DockingManager@@AAEXPAVDockingCont@@0UtTbData@@@Z ; DockingManager::toggleTb(DockingCont *,DockingCont *,tTbData)
.text$mn:00001BB7                 jmp     short loc_1B6F
.text$mn:00001BB9 ; ---------------------------------------------------------------------------
.text$mn:00001BB9
.text$mn:00001BB9 loc_1BB9:                               ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,DockingCont *)+82j
.text$mn:00001BB9                 mov     eax, [ebp+var_50]
.text$mn:00001BBC                 push    eax             ; struct tTbData *
.text$mn:00001BBD                 mov     ecx, [ebp+arg_4] ; this
.text$mn:00001BC0                 call    ?setActiveTb@DockingCont@@QAEXPAUtTbData@@@Z ; DockingCont::setActiveTb(tTbData *)
.text$mn:00001BC5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BCC                 lea     ecx, [ebp+var_60]
.text$mn:00001BCF                 call    ??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ ; std::vector<tTbData *,std::allocator<tTbData *>>::~vector<tTbData *,std::allocator<tTbData *>>(void)
.text$mn:00001BD4                 mov     ecx, [ebp+var_C]
.text$mn:00001BD7                 mov     large fs:0, ecx
.text$mn:00001BDE                 pop     ecx
.text$mn:00001BDF                 pop     edi
.text$mn:00001BE0                 pop     esi
.text$mn:00001BE1                 mov     ecx, [ebp+var_10]
.text$mn:00001BE4                 xor     ecx, ebp
.text$mn:00001BE6                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001BEB                 mov     esp, ebp
.text$mn:00001BED                 pop     ebp
.text$mn:00001BEE                 retn    8
.text$mn:00001BEE ?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z endp
.text$mn:00001BEE
.text$mn:00001BEE ; ---------------------------------------------------------------------------
.text$mn:00001BF1                 db 0Bh dup(0CCh)
.text$mn:00001BFC
.text$mn:00001BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001BFC
.text$mn:00001BFC ; Attributes: bp-based frame
.text$mn:00001BFC
.text$mn:00001BFC ; int __thiscall DockingManager::GetContainer(DockingManager *this, struct DockingCont *)
.text$mn:00001BFC                 public ?GetContainer@DockingManager@@QAEHPAVDockingCont@@@Z
.text$mn:00001BFC ?GetContainer@DockingManager@@QAEHPAVDockingCont@@@Z proc near
.text$mn:00001BFC                                         ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+48p
.text$mn:00001BFC                                         ; DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+209p ...
.text$mn:00001BFC
.text$mn:00001BFC var_10          = dword ptr -10h
.text$mn:00001BFC var_C           = dword ptr -0Ch
.text$mn:00001BFC var_8           = dword ptr -8
.text$mn:00001BFC var_4           = dword ptr -4
.text$mn:00001BFC arg_0           = dword ptr  8
.text$mn:00001BFC
.text$mn:00001BFC                 push    ebp
.text$mn:00001BFD                 mov     ebp, esp
.text$mn:00001BFF                 sub     esp, 10h
.text$mn:00001C02                 mov     [ebp+var_8], ecx
.text$mn:00001C05                 mov     [ebp+var_C], 0FFFFFFFFh
.text$mn:00001C0C                 mov     [ebp+var_4], 0
.text$mn:00001C13                 mov     ecx, [ebp+var_8]
.text$mn:00001C16                 add     ecx, 4Ch ; 'L'
.text$mn:00001C19                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00001C1E                 mov     [ebp+var_10], eax
.text$mn:00001C21                 jmp     short loc_1C2C
.text$mn:00001C23 ; ---------------------------------------------------------------------------
.text$mn:00001C23
.text$mn:00001C23 loc_1C23:                               ; CODE XREF: DockingManager::GetContainer(DockingCont *):loc_1C52j
.text$mn:00001C23                 mov     eax, [ebp+var_4]
.text$mn:00001C26                 add     eax, 1
.text$mn:00001C29                 mov     [ebp+var_4], eax
.text$mn:00001C2C
.text$mn:00001C2C loc_1C2C:                               ; CODE XREF: DockingManager::GetContainer(DockingCont *)+25j
.text$mn:00001C2C                 mov     ecx, [ebp+var_4]
.text$mn:00001C2F                 cmp     ecx, [ebp+var_10]
.text$mn:00001C32                 jnb     short loc_1C54
.text$mn:00001C34                 mov     edx, [ebp+var_4]
.text$mn:00001C37                 push    edx
.text$mn:00001C38                 mov     ecx, [ebp+var_8]
.text$mn:00001C3B                 add     ecx, 4Ch ; 'L'
.text$mn:00001C3E                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001C43                 mov     eax, [eax]
.text$mn:00001C45                 cmp     eax, [ebp+arg_0]
.text$mn:00001C48                 jnz     short loc_1C52
.text$mn:00001C4A                 mov     ecx, [ebp+var_4]
.text$mn:00001C4D                 mov     [ebp+var_C], ecx
.text$mn:00001C50                 jmp     short loc_1C54
.text$mn:00001C52 ; ---------------------------------------------------------------------------
.text$mn:00001C52
.text$mn:00001C52 loc_1C52:                               ; CODE XREF: DockingManager::GetContainer(DockingCont *)+4Cj
.text$mn:00001C52                 jmp     short loc_1C23
.text$mn:00001C54 ; ---------------------------------------------------------------------------
.text$mn:00001C54
.text$mn:00001C54 loc_1C54:                               ; CODE XREF: DockingManager::GetContainer(DockingCont *)+36j
.text$mn:00001C54                                         ; DockingManager::GetContainer(DockingCont *)+54j
.text$mn:00001C54                 mov     eax, [ebp+var_C]
.text$mn:00001C57                 mov     esp, ebp
.text$mn:00001C59                 pop     ebp
.text$mn:00001C5A                 retn    4
.text$mn:00001C5A ?GetContainer@DockingManager@@QAEHPAVDockingCont@@@Z endp
.text$mn:00001C5A
.text$mn:00001C5A ; ---------------------------------------------------------------------------
.text$mn:00001C5D                 db 0Fh dup(0CCh)
.text$mn:00001C6C
.text$mn:00001C6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C6C
.text$mn:00001C6C ; Attributes: bp-based frame
.text$mn:00001C6C
.text$mn:00001C6C ; int __thiscall DockingManager::getDockedContSize(DockingManager *this, int)
.text$mn:00001C6C                 public ?getDockedContSize@DockingManager@@QAEHH@Z
.text$mn:00001C6C ?getDockedContSize@DockingManager@@QAEHH@Z proc near
.text$mn:00001C6C
.text$mn:00001C6C var_4           = dword ptr -4
.text$mn:00001C6C arg_0           = dword ptr  8
.text$mn:00001C6C
.text$mn:00001C6C                 push    ebp
.text$mn:00001C6D                 mov     ebp, esp
.text$mn:00001C6F                 push    ecx
.text$mn:00001C70                 mov     [ebp+var_4], ecx
.text$mn:00001C73                 cmp     [ebp+arg_0], 2
.text$mn:00001C77                 jz      short loc_1C7F
.text$mn:00001C79                 cmp     [ebp+arg_0], 3
.text$mn:00001C7D                 jnz     short loc_1C90
.text$mn:00001C7F
.text$mn:00001C7F loc_1C7F:                               ; CODE XREF: DockingManager::getDockedContSize(int)+Bj
.text$mn:00001C7F                 mov     eax, [ebp+arg_0]
.text$mn:00001C82                 shl     eax, 4
.text$mn:00001C85                 mov     ecx, [ebp+var_4]
.text$mn:00001C88                 mov     eax, [ecx+eax+6Ch]
.text$mn:00001C8C                 jmp     short loc_1CB0
.text$mn:00001C8E ; ---------------------------------------------------------------------------
.text$mn:00001C8E                 jmp     short loc_1CB0
.text$mn:00001C90 ; ---------------------------------------------------------------------------
.text$mn:00001C90
.text$mn:00001C90 loc_1C90:                               ; CODE XREF: DockingManager::getDockedContSize(int)+11j
.text$mn:00001C90                 cmp     [ebp+arg_0], 0
.text$mn:00001C94                 jz      short loc_1C9C
.text$mn:00001C96                 cmp     [ebp+arg_0], 1
.text$mn:00001C9A                 jnz     short loc_1CAD
.text$mn:00001C9C
.text$mn:00001C9C loc_1C9C:                               ; CODE XREF: DockingManager::getDockedContSize(int)+28j
.text$mn:00001C9C                 mov     edx, [ebp+arg_0]
.text$mn:00001C9F                 shl     edx, 4
.text$mn:00001CA2                 mov     eax, [ebp+var_4]
.text$mn:00001CA5                 mov     eax, [eax+edx+68h]
.text$mn:00001CA9                 jmp     short loc_1CB0
.text$mn:00001CAB ; ---------------------------------------------------------------------------
.text$mn:00001CAB                 jmp     short loc_1CB0
.text$mn:00001CAD ; ---------------------------------------------------------------------------
.text$mn:00001CAD
.text$mn:00001CAD loc_1CAD:                               ; CODE XREF: DockingManager::getDockedContSize(int)+2Ej
.text$mn:00001CAD                 or      eax, 0FFFFFFFFh
.text$mn:00001CB0
.text$mn:00001CB0 loc_1CB0:                               ; CODE XREF: DockingManager::getDockedContSize(int)+20j
.text$mn:00001CB0                                         ; DockingManager::getDockedContSize(int)+22j ...
.text$mn:00001CB0                 mov     esp, ebp
.text$mn:00001CB2                 pop     ebp
.text$mn:00001CB3                 retn    4
.text$mn:00001CB3 ?getDockedContSize@DockingManager@@QAEHH@Z endp
.text$mn:00001CB3
.text$mn:00001CB3 ; ---------------------------------------------------------------------------
.text$mn:00001CB6                 db 6 dup(0CCh)
.text$mn:00001CBC
.text$mn:00001CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00001CBC
.text$mn:00001CBC ; Attributes: bp-based frame
.text$mn:00001CBC
.text$mn:00001CBC ; void __thiscall DockingManager::setDockedContSize(DockingManager *this, int, int)
.text$mn:00001CBC                 public ?setDockedContSize@DockingManager@@QAEXHH@Z
.text$mn:00001CBC ?setDockedContSize@DockingManager@@QAEXHH@Z proc near
.text$mn:00001CBC
.text$mn:00001CBC var_4           = dword ptr -4
.text$mn:00001CBC arg_0           = dword ptr  8
.text$mn:00001CBC arg_4           = dword ptr  0Ch
.text$mn:00001CBC
.text$mn:00001CBC                 push    ebp
.text$mn:00001CBD                 mov     ebp, esp
.text$mn:00001CBF                 push    ecx
.text$mn:00001CC0                 mov     [ebp+var_4], ecx
.text$mn:00001CC3                 cmp     [ebp+arg_0], 2
.text$mn:00001CC7                 jz      short loc_1CCF
.text$mn:00001CC9                 cmp     [ebp+arg_0], 3
.text$mn:00001CCD                 jnz     short loc_1CE1
.text$mn:00001CCF
.text$mn:00001CCF loc_1CCF:                               ; CODE XREF: DockingManager::setDockedContSize(int,int)+Bj
.text$mn:00001CCF                 mov     eax, [ebp+arg_0]
.text$mn:00001CD2                 shl     eax, 4
.text$mn:00001CD5                 mov     ecx, [ebp+var_4]
.text$mn:00001CD8                 mov     edx, [ebp+arg_4]
.text$mn:00001CDB                 mov     [ecx+eax+6Ch], edx
.text$mn:00001CDF                 jmp     short loc_1D01
.text$mn:00001CE1 ; ---------------------------------------------------------------------------
.text$mn:00001CE1
.text$mn:00001CE1 loc_1CE1:                               ; CODE XREF: DockingManager::setDockedContSize(int,int)+11j
.text$mn:00001CE1                 cmp     [ebp+arg_0], 0
.text$mn:00001CE5                 jz      short loc_1CED
.text$mn:00001CE7                 cmp     [ebp+arg_0], 1
.text$mn:00001CEB                 jnz     short loc_1CFF
.text$mn:00001CED
.text$mn:00001CED loc_1CED:                               ; CODE XREF: DockingManager::setDockedContSize(int,int)+29j
.text$mn:00001CED                 mov     eax, [ebp+arg_0]
.text$mn:00001CF0                 shl     eax, 4
.text$mn:00001CF3                 mov     ecx, [ebp+var_4]
.text$mn:00001CF6                 mov     edx, [ebp+arg_4]
.text$mn:00001CF9                 mov     [ecx+eax+68h], edx
.text$mn:00001CFD                 jmp     short loc_1D01
.text$mn:00001CFF ; ---------------------------------------------------------------------------
.text$mn:00001CFF
.text$mn:00001CFF loc_1CFF:                               ; CODE XREF: DockingManager::setDockedContSize(int,int)+2Fj
.text$mn:00001CFF                 jmp     short loc_1D09
.text$mn:00001D01 ; ---------------------------------------------------------------------------
.text$mn:00001D01
.text$mn:00001D01 loc_1D01:                               ; CODE XREF: DockingManager::setDockedContSize(int,int)+23j
.text$mn:00001D01                                         ; DockingManager::setDockedContSize(int,int)+41j
.text$mn:00001D01                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001D04                 call    ?onSize@DockingManager@@AAEXXZ ; DockingManager::onSize(void)
.text$mn:00001D09
.text$mn:00001D09 loc_1D09:                               ; CODE XREF: DockingManager::setDockedContSize(int,int):loc_1CFFj
.text$mn:00001D09                 mov     esp, ebp
.text$mn:00001D0B                 pop     ebp
.text$mn:00001D0C                 retn    8
.text$mn:00001D0C ?setDockedContSize@DockingManager@@QAEXHH@Z endp
.text$mn:00001D0C
.text$mn:00001D0C ; ---------------------------------------------------------------------------
.text$mn:00001D0F                 db 0Dh dup(0CCh)
.text$mn:00001D1C
.text$mn:00001D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D1C
.text$mn:00001D1C ; Attributes: bp-based frame
.text$mn:00001D1C
.text$mn:00001D1C ; void __thiscall DockingManager::destroy(DockingManager *__hidden this)
.text$mn:00001D1C                 public ?destroy@DockingManager@@UAEXXZ
.text$mn:00001D1C ?destroy@DockingManager@@UAEXXZ proc near ; DATA XREF: .rdata:00009E14o
.text$mn:00001D1C
.text$mn:00001D1C var_4           = dword ptr -4
.text$mn:00001D1C
.text$mn:00001D1C                 push    ebp
.text$mn:00001D1D                 mov     ebp, esp
.text$mn:00001D1F                 push    ecx
.text$mn:00001D20                 mov     [ebp+var_4], ecx
.text$mn:00001D23                 mov     eax, [ebp+var_4]
.text$mn:00001D26                 mov     ecx, [eax+0Ch]
.text$mn:00001D29                 push    ecx             ; hWnd
.text$mn:00001D2A                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:00001D30                 mov     esp, ebp
.text$mn:00001D32                 pop     ebp
.text$mn:00001D33                 retn
.text$mn:00001D33 ?destroy@DockingManager@@UAEXXZ endp
.text$mn:00001D33
.text$mn:00001D33 ; ---------------------------------------------------------------------------
.text$mn:00001D34                 db 8 dup(0CCh)
.text$mn:00001D3C
.text$mn:00001D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D3C
.text$mn:00001D3C ; Attributes: bp-based frame
.text$mn:00001D3C
.text$mn:00001D3C ; __int32 __stdcall DockingManager::staticWinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
.text$mn:00001D3C                 public ?staticWinProc@DockingManager@@CGJPAUHWND__@@IIJ@Z
.text$mn:00001D3C ?staticWinProc@DockingManager@@CGJPAUHWND__@@IIJ@Z proc near
.text$mn:00001D3C                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+2Do
.text$mn:00001D3C
.text$mn:00001D3C var_8           = dword ptr -8
.text$mn:00001D3C dwNewLong       = dword ptr -4
.text$mn:00001D3C hWnd            = dword ptr  8
.text$mn:00001D3C Msg             = dword ptr  0Ch
.text$mn:00001D3C wParam          = dword ptr  10h
.text$mn:00001D3C lParam          = dword ptr  14h
.text$mn:00001D3C
.text$mn:00001D3C                 push    ebp
.text$mn:00001D3D                 mov     ebp, esp
.text$mn:00001D3F                 sub     esp, 8
.text$mn:00001D42                 mov     [ebp+dwNewLong], 0
.text$mn:00001D49                 mov     eax, [ebp+Msg]
.text$mn:00001D4C                 mov     [ebp+var_8], eax
.text$mn:00001D4F                 cmp     [ebp+var_8], 81h ; 'ü'
.text$mn:00001D56                 jz      short loc_1D5A
.text$mn:00001D58                 jmp     short loc_1D82
.text$mn:00001D5A ; ---------------------------------------------------------------------------
.text$mn:00001D5A
.text$mn:00001D5A loc_1D5A:                               ; CODE XREF: DockingManager::staticWinProc(HWND__ *,uint,uint,long)+1Aj
.text$mn:00001D5A                 mov     ecx, [ebp+lParam]
.text$mn:00001D5D                 mov     edx, [ecx]
.text$mn:00001D5F                 mov     [ebp+dwNewLong], edx
.text$mn:00001D62                 mov     eax, [ebp+dwNewLong]
.text$mn:00001D65                 mov     ecx, [ebp+hWnd]
.text$mn:00001D68                 mov     [eax+0Ch], ecx
.text$mn:00001D6B                 mov     edx, [ebp+dwNewLong]
.text$mn:00001D6E                 push    edx             ; dwNewLong
.text$mn:00001D6F                 push    0FFFFFFEBh      ; nIndex
.text$mn:00001D71                 mov     eax, [ebp+hWnd]
.text$mn:00001D74                 push    eax             ; hWnd
.text$mn:00001D75                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00001D7B                 mov     eax, 1
.text$mn:00001D80                 jmp     short loc_1DC7
.text$mn:00001D82 ; ---------------------------------------------------------------------------
.text$mn:00001D82
.text$mn:00001D82 loc_1D82:                               ; CODE XREF: DockingManager::staticWinProc(HWND__ *,uint,uint,long)+1Cj
.text$mn:00001D82                 push    0FFFFFFEBh      ; nIndex
.text$mn:00001D84                 mov     ecx, [ebp+hWnd]
.text$mn:00001D87                 push    ecx             ; hWnd
.text$mn:00001D88                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00001D8E                 mov     [ebp+dwNewLong], eax
.text$mn:00001D91                 cmp     [ebp+dwNewLong], 0
.text$mn:00001D95                 jnz     short loc_1DAF
.text$mn:00001D97                 mov     edx, [ebp+lParam]
.text$mn:00001D9A                 push    edx             ; lParam
.text$mn:00001D9B                 mov     eax, [ebp+wParam]
.text$mn:00001D9E                 push    eax             ; wParam
.text$mn:00001D9F                 mov     ecx, [ebp+Msg]
.text$mn:00001DA2                 push    ecx             ; Msg
.text$mn:00001DA3                 mov     edx, [ebp+hWnd]
.text$mn:00001DA6                 push    edx             ; hWnd
.text$mn:00001DA7                 call    dword ptr ds:__imp__DefWindowProcW@16 ; DefWindowProcW(x,x,x,x)
.text$mn:00001DAD                 jmp     short loc_1DC7
.text$mn:00001DAF ; ---------------------------------------------------------------------------
.text$mn:00001DAF
.text$mn:00001DAF loc_1DAF:                               ; CODE XREF: DockingManager::staticWinProc(HWND__ *,uint,uint,long)+59j
.text$mn:00001DAF                 mov     eax, [ebp+lParam]
.text$mn:00001DB2                 push    eax             ; __int32
.text$mn:00001DB3                 mov     ecx, [ebp+wParam]
.text$mn:00001DB6                 push    ecx             ; wParam
.text$mn:00001DB7                 mov     edx, [ebp+Msg]
.text$mn:00001DBA                 push    edx             ; Msg
.text$mn:00001DBB                 mov     eax, [ebp+hWnd]
.text$mn:00001DBE                 push    eax             ; HWND
.text$mn:00001DBF                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:00001DC2                 call    ?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z ; DockingManager::runProc(HWND__ *,uint,uint,long)
.text$mn:00001DC7
.text$mn:00001DC7 loc_1DC7:                               ; CODE XREF: DockingManager::staticWinProc(HWND__ *,uint,uint,long)+44j
.text$mn:00001DC7                                         ; DockingManager::staticWinProc(HWND__ *,uint,uint,long)+71j
.text$mn:00001DC7                 mov     esp, ebp
.text$mn:00001DC9                 pop     ebp
.text$mn:00001DCA                 retn    10h
.text$mn:00001DCA ?staticWinProc@DockingManager@@CGJPAUHWND__@@IIJ@Z endp
.text$mn:00001DCA
.text$mn:00001DCA ; ---------------------------------------------------------------------------
.text$mn:00001DCD                 db 0Fh dup(0CCh)
.text$mn:00001DDC
.text$mn:00001DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DDC
.text$mn:00001DDC ; Attributes: bp-based frame
.text$mn:00001DDC
.text$mn:00001DDC ; __int32 __thiscall DockingManager::runProc(DockingManager *this, HWND, UINT Msg, WPARAM wParam, __int32)
.text$mn:00001DDC                 public ?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z
.text$mn:00001DDC ?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z proc near
.text$mn:00001DDC                                         ; CODE XREF: DockingManager::staticWinProc(HWND__ *,uint,uint,long)+86p
.text$mn:00001DDC
.text$mn:00001DDC var_90          = dword ptr -90h
.text$mn:00001DDC var_8C          = dword ptr -8Ch
.text$mn:00001DDC var_88          = dword ptr -88h
.text$mn:00001DDC var_84          = dword ptr -84h
.text$mn:00001DDC var_80          = dword ptr -80h
.text$mn:00001DDC var_7C          = dword ptr -7Ch
.text$mn:00001DDC var_78          = dword ptr -78h
.text$mn:00001DDC var_74          = dword ptr -74h
.text$mn:00001DDC var_70          = dword ptr -70h
.text$mn:00001DDC var_6C          = dword ptr -6Ch
.text$mn:00001DDC var_68          = dword ptr -68h
.text$mn:00001DDC var_64          = dword ptr -64h
.text$mn:00001DDC var_60          = dword ptr -60h
.text$mn:00001DDC var_5C          = dword ptr -5Ch
.text$mn:00001DDC var_58          = dword ptr -58h
.text$mn:00001DDC var_54          = dword ptr -54h
.text$mn:00001DDC var_50          = dword ptr -50h
.text$mn:00001DDC var_4C          = dword ptr -4Ch
.text$mn:00001DDC var_48          = dword ptr -48h
.text$mn:00001DDC var_44          = dword ptr -44h
.text$mn:00001DDC hWnd            = dword ptr -40h
.text$mn:00001DDC var_10          = dword ptr -10h
.text$mn:00001DDC var_C           = dword ptr -0Ch
.text$mn:00001DDC var_4           = dword ptr -4
.text$mn:00001DDC arg_0           = dword ptr  8
.text$mn:00001DDC Msg             = dword ptr  0Ch
.text$mn:00001DDC wParam          = dword ptr  10h
.text$mn:00001DDC lParam          = dword ptr  14h
.text$mn:00001DDC
.text$mn:00001DDC                 push    ebp
.text$mn:00001DDD                 mov     ebp, esp
.text$mn:00001DDF                 push    0FFFFFFFFh
.text$mn:00001DE1                 push    offset __ehhandler$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z
.text$mn:00001DE6                 mov     eax, large fs:0
.text$mn:00001DEC                 push    eax
.text$mn:00001DED                 sub     esp, 84h
.text$mn:00001DF3                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001DF8                 xor     eax, ebp
.text$mn:00001DFA                 mov     [ebp+var_10], eax
.text$mn:00001DFD                 push    esi
.text$mn:00001DFE                 push    edi
.text$mn:00001DFF                 push    eax
.text$mn:00001E00                 lea     eax, [ebp+var_C]
.text$mn:00001E03                 mov     large fs:0, eax
.text$mn:00001E09                 mov     [ebp+var_44], ecx
.text$mn:00001E0C                 mov     eax, [ebp+Msg]
.text$mn:00001E0F                 mov     [ebp+var_50], eax
.text$mn:00001E12                 cmp     [ebp+var_50], 5001h
.text$mn:00001E19                 ja      short loc_1E4F
.text$mn:00001E1B                 cmp     [ebp+var_50], 5001h
.text$mn:00001E22                 jz      loc_22F4
.text$mn:00001E28                 mov     ecx, [ebp+var_50]
.text$mn:00001E2B                 sub     ecx, 2
.text$mn:00001E2E                 mov     [ebp+var_50], ecx
.text$mn:00001E31                 cmp     [ebp+var_50], 84h ; 'ä' ; switch 133 cases
.text$mn:00001E38                 ja      $LN50           ; jumptable 00001E48 default case
.text$mn:00001E3E                 mov     edx, [ebp+var_50]
.text$mn:00001E41                 movzx   eax, ds:$LN60[edx]
.text$mn:00001E48                 jmp     ds:$LN62[eax*4] ; switch jump
.text$mn:00001E4F ; ---------------------------------------------------------------------------
.text$mn:00001E4F
.text$mn:00001E4F loc_1E4F:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+3Dj
.text$mn:00001E4F                 mov     ecx, [ebp+var_50]
.text$mn:00001E52                 sub     ecx, 5002h
.text$mn:00001E58                 mov     [ebp+var_50], ecx
.text$mn:00001E5B                 cmp     [ebp+var_50], 0Bh ; switch 12 cases
.text$mn:00001E5F                 ja      $LN50           ; jumptable 00001E48 default case
.text$mn:00001E65                 mov     edx, [ebp+var_50]
.text$mn:00001E68                 jmp     ds:$LN63[edx*4] ; switch jump
.text$mn:00001E6F ; ---------------------------------------------------------------------------
.text$mn:00001E6F
.text$mn:00001E6F $LN49:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+6Cj
.text$mn:00001E6F                                         ; DATA XREF: .text$mn:$LN62o
.text$mn:00001E6F                 mov     [ebp+var_60], 4 ; jumptable 00001E48 case 132
.text$mn:00001E76                 mov     ecx, [ebp+var_44]
.text$mn:00001E79                 add     ecx, 4Ch ; 'L'
.text$mn:00001E7C                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00001E81                 mov     [ebp+var_80], eax
.text$mn:00001E84                 jmp     short loc_1E8F
.text$mn:00001E86 ; ---------------------------------------------------------------------------
.text$mn:00001E86
.text$mn:00001E86 loc_1E86:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+E3j
.text$mn:00001E86                 mov     eax, [ebp+var_60]
.text$mn:00001E89                 add     eax, 1
.text$mn:00001E8C                 mov     [ebp+var_60], eax
.text$mn:00001E8F
.text$mn:00001E8F loc_1E8F:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+A8j
.text$mn:00001E8F                 mov     ecx, [ebp+var_60]
.text$mn:00001E92                 cmp     ecx, [ebp+var_80]
.text$mn:00001E95                 jnb     short loc_1EC1
.text$mn:00001E97                 push    0FFFFFFFFh      ; lParam
.text$mn:00001E99                 mov     edx, [ebp+wParam]
.text$mn:00001E9C                 push    edx             ; wParam
.text$mn:00001E9D                 push    86h ; 'å'       ; Msg
.text$mn:00001EA2                 mov     eax, [ebp+var_60]
.text$mn:00001EA5                 push    eax
.text$mn:00001EA6                 mov     ecx, [ebp+var_44]
.text$mn:00001EA9                 add     ecx, 4Ch ; 'L'
.text$mn:00001EAC                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001EB1                 mov     ecx, [eax]      ; this
.text$mn:00001EB3                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001EB8                 push    eax             ; hWnd
.text$mn:00001EB9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001EBF                 jmp     short loc_1E86
.text$mn:00001EC1 ; ---------------------------------------------------------------------------
.text$mn:00001EC1
.text$mn:00001EC1 loc_1EC1:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+B9j
.text$mn:00001EC1                 cmp     [ebp+lParam], 0FFFFFFFFh
.text$mn:00001EC5                 jz      short loc_1EDF
.text$mn:00001EC7                 push    0FFFFFFFFh      ; lParam
.text$mn:00001EC9                 mov     ecx, [ebp+wParam]
.text$mn:00001ECC                 push    ecx             ; wParam
.text$mn:00001ECD                 push    86h ; 'å'       ; Msg
.text$mn:00001ED2                 mov     edx, [ebp+var_44]
.text$mn:00001ED5                 mov     eax, [edx+8]
.text$mn:00001ED8                 push    eax             ; hWnd
.text$mn:00001ED9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001EDF
.text$mn:00001EDF loc_1EDF:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+E9j
.text$mn:00001EDF                 jmp     $LN50           ; jumptable 00001E48 default case
.text$mn:00001EE4 ; ---------------------------------------------------------------------------
.text$mn:00001EE4
.text$mn:00001EE4 $LN44:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+6Cj
.text$mn:00001EE4                                         ; DATA XREF: .text$mn:$LN62o
.text$mn:00001EE4                 mov     ecx, [ebp+var_44] ; jumptable 00001E48 cases 1,3
.text$mn:00001EE7                 call    ?onSize@DockingManager@@AAEXXZ ; DockingManager::onSize(void)
.text$mn:00001EEC                 jmp     $LN50           ; jumptable 00001E48 default case
.text$mn:00001EF1 ; ---------------------------------------------------------------------------
.text$mn:00001EF1
.text$mn:00001EF1 $LN43:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+6Cj
.text$mn:00001EF1                                         ; DATA XREF: .text$mn:$LN62o
.text$mn:00001EF1                 mov     ecx, ds:_hWndServer ; jumptable 00001E48 case 0
.text$mn:00001EF7                 cmp     ecx, [ebp+arg_0]
.text$mn:00001EFA                 jnz     short loc_1F1D
.text$mn:00001EFC                 mov     edx, ds:_gWinCallHook
.text$mn:00001F02                 push    edx             ; hhk
.text$mn:00001F03                 call    dword ptr ds:__imp__UnhookWindowsHookEx@4 ; UnhookWindowsHookEx(x)
.text$mn:00001F09                 mov     ds:_gWinCallHook, 0
.text$mn:00001F13                 mov     ds:_hWndServer, 0
.text$mn:00001F1D
.text$mn:00001F1D loc_1F1D:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+11Ej
.text$mn:00001F1D                 mov     eax, [ebp+var_44]
.text$mn:00001F20                 cmp     dword ptr [eax+48h], 0
.text$mn:00001F24                 jz      short loc_1F33
.text$mn:00001F26                 mov     ecx, [ebp+var_44]
.text$mn:00001F29                 mov     edx, [ecx+48h]
.text$mn:00001F2C                 push    edx             ; himl
.text$mn:00001F2D                 call    dword ptr ds:__imp__ImageList_Destroy@4 ; ImageList_Destroy(x)
.text$mn:00001F33
.text$mn:00001F33 loc_1F33:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+148j
.text$mn:00001F33                 mov     ecx, [ebp+var_44]
.text$mn:00001F36                 add     ecx, 4Ch ; 'L'
.text$mn:00001F39                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00001F3E                 mov     [ebp+var_54], eax
.text$mn:00001F41                 jmp     short loc_1F4C
.text$mn:00001F43 ; ---------------------------------------------------------------------------
.text$mn:00001F43
.text$mn:00001F43 loc_1F43:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long):loc_1FBFj
.text$mn:00001F43                 mov     eax, [ebp+var_54]
.text$mn:00001F46                 sub     eax, 1
.text$mn:00001F49                 mov     [ebp+var_54], eax
.text$mn:00001F4C
.text$mn:00001F4C loc_1F4C:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+165j
.text$mn:00001F4C                 cmp     [ebp+var_54], 0
.text$mn:00001F50                 jle     short loc_1FC1
.text$mn:00001F52                 mov     ecx, [ebp+var_54]
.text$mn:00001F55                 sub     ecx, 1
.text$mn:00001F58                 push    ecx
.text$mn:00001F59                 mov     ecx, [ebp+var_44]
.text$mn:00001F5C                 add     ecx, 4Ch ; 'L'
.text$mn:00001F5F                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001F64                 mov     edx, [eax]
.text$mn:00001F66                 mov     [ebp+var_70], edx
.text$mn:00001F69                 mov     eax, [ebp+var_70]
.text$mn:00001F6C                 mov     edx, [eax]
.text$mn:00001F6E                 mov     ecx, [ebp+var_70]
.text$mn:00001F71                 mov     eax, [edx+8]
.text$mn:00001F74                 call    eax
.text$mn:00001F76                 mov     ecx, [ebp+var_54]
.text$mn:00001F79                 sub     ecx, 1
.text$mn:00001F7C                 push    ecx
.text$mn:00001F7D                 mov     ecx, [ebp+var_44]
.text$mn:00001F80                 add     ecx, 4Ch ; 'L'
.text$mn:00001F83                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001F88                 mov     edx, [eax]
.text$mn:00001F8A                 mov     [ebp+var_90], edx
.text$mn:00001F90                 mov     eax, [ebp+var_90]
.text$mn:00001F96                 mov     [ebp+var_64], eax
.text$mn:00001F99                 cmp     [ebp+var_64], 0
.text$mn:00001F9D                 jz      short loc_1FB5
.text$mn:00001F9F                 push    1
.text$mn:00001FA1                 mov     ecx, [ebp+var_64]
.text$mn:00001FA4                 mov     edx, [ecx]
.text$mn:00001FA6                 mov     ecx, [ebp+var_64]
.text$mn:00001FA9                 mov     eax, [edx]
.text$mn:00001FAB                 call    eax
.text$mn:00001FAD                 mov     [ebp+var_8C], eax
.text$mn:00001FB3                 jmp     short loc_1FBF
.text$mn:00001FB5 ; ---------------------------------------------------------------------------
.text$mn:00001FB5
.text$mn:00001FB5 loc_1FB5:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+1C1j
.text$mn:00001FB5                 mov     [ebp+var_8C], 0
.text$mn:00001FBF
.text$mn:00001FBF loc_1FBF:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+1D7j
.text$mn:00001FBF                 jmp     short loc_1F43
.text$mn:00001FC1 ; ---------------------------------------------------------------------------
.text$mn:00001FC1
.text$mn:00001FC1 loc_1FC1:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+174j
.text$mn:00001FC1                 call    dword ptr ds:__imp__CoUninitialize@0 ; CoUninitialize()
.text$mn:00001FC7                 jmp     $LN50           ; jumptable 00001E48 default case
.text$mn:00001FCC ; ---------------------------------------------------------------------------
.text$mn:00001FCC
.text$mn:00001FCC $LN37:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+8Cj
.text$mn:00001FCC                                         ; DATA XREF: .text$mn:$LN63o
.text$mn:00001FCC                 call    dword ptr ds:__imp__GetActiveWindow@0 ; jumptable 00001E68 case 11
.text$mn:00001FD2                 mov     ecx, [ebp+var_44]
.text$mn:00001FD5                 cmp     eax, [ecx+8]
.text$mn:00001FD8                 jz      short loc_1FDF
.text$mn:00001FDA                 jmp     $LN50           ; jumptable 00001E48 default case
.text$mn:00001FDF ; ---------------------------------------------------------------------------
.text$mn:00001FDF
.text$mn:00001FDF loc_1FDF:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+1FCj
.text$mn:00001FDF                 mov     [ebp+var_58], 0
.text$mn:00001FE6                 jmp     short loc_1FF1
.text$mn:00001FE8 ; ---------------------------------------------------------------------------
.text$mn:00001FE8
.text$mn:00001FE8 loc_1FE8:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+256j
.text$mn:00001FE8                 mov     edx, [ebp+var_58]
.text$mn:00001FEB                 add     edx, 1
.text$mn:00001FEE                 mov     [ebp+var_58], edx
.text$mn:00001FF1
.text$mn:00001FF1 loc_1FF1:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+20Aj
.text$mn:00001FF1                 cmp     [ebp+var_58], 4
.text$mn:00001FF5                 jge     short loc_2034
.text$mn:00001FF7                 call    dword ptr ds:__imp__GetFocus@0 ; GetFocus()
.text$mn:00001FFD                 push    eax             ; hWnd
.text$mn:00001FFE                 mov     eax, [ebp+var_58]
.text$mn:00002001                 push    eax
.text$mn:00002002                 mov     ecx, [ebp+var_44]
.text$mn:00002005                 add     ecx, 4Ch ; 'L'
.text$mn:00002008                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:0000200D                 mov     ecx, [eax]      ; this
.text$mn:0000200F                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002014                 push    eax             ; hWndParent
.text$mn:00002015                 call    dword ptr ds:__imp__IsChild@8 ; IsChild(x,x)
.text$mn:0000201B                 push    eax             ; int
.text$mn:0000201C                 mov     ecx, [ebp+var_58]
.text$mn:0000201F                 push    ecx
.text$mn:00002020                 mov     ecx, [ebp+var_44]
.text$mn:00002023                 add     ecx, 4Ch ; 'L'
.text$mn:00002026                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:0000202B                 mov     ecx, [eax]      ; this
.text$mn:0000202D                 call    ?SetActive@DockingCont@@QAEXH@Z ; DockingCont::SetActive(int)
.text$mn:00002032                 jmp     short loc_1FE8
.text$mn:00002034 ; ---------------------------------------------------------------------------
.text$mn:00002034
.text$mn:00002034 loc_2034:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+219j
.text$mn:00002034                 mov     eax, 1
.text$mn:00002039                 jmp     loc_23DF
.text$mn:0000203E ; ---------------------------------------------------------------------------
.text$mn:0000203E
.text$mn:0000203E $LN32:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+8Cj
.text$mn:0000203E                                         ; DATA XREF: .text$mn:$LN63o
.text$mn:0000203E                 push    0C4h ; '-'      ; jumptable 00001E68 case 4
.text$mn:00002043                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002048                 add     esp, 4
.text$mn:0000204B                 mov     [ebp+var_68], eax
.text$mn:0000204E                 mov     [ebp+var_4], 0
.text$mn:00002055                 cmp     [ebp+var_68], 0
.text$mn:00002059                 jz      short loc_2068
.text$mn:0000205B                 mov     ecx, [ebp+var_68]
.text$mn:0000205E                 call    ??0Gripper@@QAE@XZ ; Gripper::Gripper(void)
.text$mn:00002063                 mov     [ebp+var_7C], eax
.text$mn:00002066                 jmp     short loc_206F
.text$mn:00002068 ; ---------------------------------------------------------------------------
.text$mn:00002068
.text$mn:00002068 loc_2068:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+27Dj
.text$mn:00002068                 mov     [ebp+var_7C], 0
.text$mn:0000206F
.text$mn:0000206F loc_206F:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+28Aj
.text$mn:0000206F                 mov     edx, [ebp+var_7C]
.text$mn:00002072                 mov     [ebp+var_84], edx
.text$mn:00002078                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000207F                 mov     eax, [ebp+var_84]
.text$mn:00002085                 mov     [ebp+var_78], eax
.text$mn:00002088                 mov     ecx, [ebp+var_44]
.text$mn:0000208B                 mov     edx, [ecx+8]
.text$mn:0000208E                 push    edx             ; HWND
.text$mn:0000208F                 mov     eax, [ebp+var_44]
.text$mn:00002092                 mov     ecx, [eax+4]
.text$mn:00002095                 push    ecx             ; HINSTANCE
.text$mn:00002096                 mov     ecx, [ebp+var_78] ; this
.text$mn:00002099                 call    ?init@Gripper@@QAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Gripper::init(HINSTANCE__ *,HWND__ *)
.text$mn:0000209E                 mov     edx, [ebp+var_44]
.text$mn:000020A1                 push    edx             ; struct DockingManager *
.text$mn:000020A2                 mov     eax, [ebp+lParam]
.text$mn:000020A5                 push    eax             ; struct DockingCont *
.text$mn:000020A6                 mov     ecx, [ebp+var_78] ; this
.text$mn:000020A9                 call    ?startGrip@Gripper@@QAEXPAVDockingCont@@PAVDockingManager@@@Z ; Gripper::startGrip(DockingCont *,DockingManager *)
.text$mn:000020AE                 jmp     $LN50           ; jumptable 00001E48 default case
.text$mn:000020B3 ; ---------------------------------------------------------------------------
.text$mn:000020B3
.text$mn:000020B3 $LN31:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+8Cj
.text$mn:000020B3                                         ; DATA XREF: .text$mn:$LN63o
.text$mn:000020B3                 mov     ecx, [ebp+wParam] ; jumptable 00001E68 case 9
.text$mn:000020B6                 mov     [ebp+var_4C], ecx
.text$mn:000020B9                 mov     [ebp+var_48], 0
.text$mn:000020C0                 jmp     short loc_20CB
.text$mn:000020C2 ; ---------------------------------------------------------------------------
.text$mn:000020C2
.text$mn:000020C2 loc_20C2:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long):loc_22CFj
.text$mn:000020C2                 mov     edx, [ebp+var_48]
.text$mn:000020C5                 add     edx, 1
.text$mn:000020C8                 mov     [ebp+var_48], edx
.text$mn:000020CB
.text$mn:000020CB loc_20CB:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+2E4j
.text$mn:000020CB                 cmp     [ebp+var_48], 4
.text$mn:000020CF                 jge     loc_22D4
.text$mn:000020D5                 mov     eax, [ebp+var_48]
.text$mn:000020D8                 push    eax
.text$mn:000020D9                 mov     ecx, [ebp+var_44]
.text$mn:000020DC                 add     ecx, 16Ch
.text$mn:000020E2                 call    ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)
.text$mn:000020E7                 mov     ecx, [eax]      ; this
.text$mn:000020E9                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000020EE                 cmp     eax, [ebp+lParam]
.text$mn:000020F1                 jnz     loc_22CF
.text$mn:000020F7                 mov     ecx, [ebp+var_48]
.text$mn:000020FA                 mov     [ebp+var_6C], ecx
.text$mn:000020FD                 cmp     [ebp+var_6C], 3 ; switch 4 cases
.text$mn:00002101                 ja      loc_22C5        ; jumptable 0000210A default case
.text$mn:00002107                 mov     edx, [ebp+var_6C]
.text$mn:0000210A                 jmp     ds:$LN64[edx*4] ; switch jump
.text$mn:00002111 ; ---------------------------------------------------------------------------
.text$mn:00002111
.text$mn:00002111 $LN24:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+32Ej
.text$mn:00002111                                         ; DATA XREF: .text$mn:$LN64o
.text$mn:00002111                 mov     eax, [ebp+var_48] ; jumptable 0000210A case 2
.text$mn:00002114                 shl     eax, 4
.text$mn:00002117                 mov     ecx, [ebp+var_44]
.text$mn:0000211A                 mov     edx, [ecx+eax+6Ch]
.text$mn:0000211E                 sub     edx, [ebp+var_4C]
.text$mn:00002121                 mov     eax, [ebp+var_48]
.text$mn:00002124                 shl     eax, 4
.text$mn:00002127                 mov     ecx, [ebp+var_44]
.text$mn:0000212A                 mov     [ecx+eax+6Ch], edx
.text$mn:0000212E                 mov     edx, [ebp+var_48]
.text$mn:00002131                 shl     edx, 4
.text$mn:00002134                 mov     eax, [ebp+var_44]
.text$mn:00002137                 cmp     dword ptr [eax+edx+6Ch], 0
.text$mn:0000213C                 jge     short loc_214F
.text$mn:0000213E                 mov     ecx, [ebp+var_48]
.text$mn:00002141                 shl     ecx, 4
.text$mn:00002144                 mov     edx, [ebp+var_44]
.text$mn:00002147                 mov     dword ptr [edx+ecx+6Ch], 0
.text$mn:0000214F
.text$mn:0000214F loc_214F:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+360j
.text$mn:0000214F                 mov     eax, [ebp+var_44]
.text$mn:00002152                 cmp     dword ptr [eax+20h], 0FFFFFFFCh
.text$mn:00002156                 jge     short loc_217B
.text$mn:00002158                 cmp     [ebp+var_4C], 0
.text$mn:0000215C                 jge     short loc_217B
.text$mn:0000215E                 mov     ecx, [ebp+var_48]
.text$mn:00002161                 shl     ecx, 4
.text$mn:00002164                 mov     edx, [ebp+var_44]
.text$mn:00002167                 mov     eax, [edx+ecx+6Ch]
.text$mn:0000216B                 add     eax, [ebp+var_4C]
.text$mn:0000216E                 mov     ecx, [ebp+var_48]
.text$mn:00002171                 shl     ecx, 4
.text$mn:00002174                 mov     edx, [ebp+var_44]
.text$mn:00002177                 mov     [edx+ecx+6Ch], eax
.text$mn:0000217B
.text$mn:0000217B loc_217B:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+37Aj
.text$mn:0000217B                                         ; DockingManager::runProc(HWND__ *,uint,uint,long)+380j
.text$mn:0000217B                 jmp     loc_22C5        ; jumptable 0000210A default case
.text$mn:00002180 ; ---------------------------------------------------------------------------
.text$mn:00002180
.text$mn:00002180 $LN21:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+32Ej
.text$mn:00002180                                         ; DATA XREF: .text$mn:$LN64o
.text$mn:00002180                 mov     eax, [ebp+var_48] ; jumptable 0000210A case 3
.text$mn:00002183                 shl     eax, 4
.text$mn:00002186                 mov     ecx, [ebp+var_44]
.text$mn:00002189                 mov     edx, [ecx+eax+6Ch]
.text$mn:0000218D                 add     edx, [ebp+var_4C]
.text$mn:00002190                 mov     eax, [ebp+var_48]
.text$mn:00002193                 shl     eax, 4
.text$mn:00002196                 mov     ecx, [ebp+var_44]
.text$mn:00002199                 mov     [ecx+eax+6Ch], edx
.text$mn:0000219D                 mov     edx, [ebp+var_48]
.text$mn:000021A0                 shl     edx, 4
.text$mn:000021A3                 mov     eax, [ebp+var_44]
.text$mn:000021A6                 cmp     dword ptr [eax+edx+6Ch], 0
.text$mn:000021AB                 jge     short loc_21BE
.text$mn:000021AD                 mov     ecx, [ebp+var_48]
.text$mn:000021B0                 shl     ecx, 4
.text$mn:000021B3                 mov     edx, [ebp+var_44]
.text$mn:000021B6                 mov     dword ptr [edx+ecx+6Ch], 0
.text$mn:000021BE
.text$mn:000021BE loc_21BE:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+3CFj
.text$mn:000021BE                 mov     eax, [ebp+var_44]
.text$mn:000021C1                 cmp     dword ptr [eax+20h], 0FFFFFFFCh
.text$mn:000021C5                 jge     short loc_21EA
.text$mn:000021C7                 cmp     [ebp+var_4C], 0
.text$mn:000021CB                 jle     short loc_21EA
.text$mn:000021CD                 mov     ecx, [ebp+var_48]
.text$mn:000021D0                 shl     ecx, 4
.text$mn:000021D3                 mov     edx, [ebp+var_44]
.text$mn:000021D6                 mov     eax, [edx+ecx+6Ch]
.text$mn:000021DA                 sub     eax, [ebp+var_4C]
.text$mn:000021DD                 mov     ecx, [ebp+var_48]
.text$mn:000021E0                 shl     ecx, 4
.text$mn:000021E3                 mov     edx, [ebp+var_44]
.text$mn:000021E6                 mov     [edx+ecx+6Ch], eax
.text$mn:000021EA
.text$mn:000021EA loc_21EA:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+3E9j
.text$mn:000021EA                                         ; DockingManager::runProc(HWND__ *,uint,uint,long)+3EFj
.text$mn:000021EA                 jmp     loc_22C5        ; jumptable 0000210A default case
.text$mn:000021EF ; ---------------------------------------------------------------------------
.text$mn:000021EF
.text$mn:000021EF $LN18:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+32Ej
.text$mn:000021EF                                         ; DATA XREF: .text$mn:$LN64o
.text$mn:000021EF                 mov     eax, [ebp+var_48] ; jumptable 0000210A case 0
.text$mn:000021F2                 shl     eax, 4
.text$mn:000021F5                 mov     ecx, [ebp+var_44]
.text$mn:000021F8                 mov     edx, [ecx+eax+68h]
.text$mn:000021FC                 sub     edx, [ebp+var_4C]
.text$mn:000021FF                 mov     eax, [ebp+var_48]
.text$mn:00002202                 shl     eax, 4
.text$mn:00002205                 mov     ecx, [ebp+var_44]
.text$mn:00002208                 mov     [ecx+eax+68h], edx
.text$mn:0000220C                 mov     edx, [ebp+var_48]
.text$mn:0000220F                 shl     edx, 4
.text$mn:00002212                 mov     eax, [ebp+var_44]
.text$mn:00002215                 cmp     dword ptr [eax+edx+68h], 0
.text$mn:0000221A                 jge     short loc_222D
.text$mn:0000221C                 mov     ecx, [ebp+var_48]
.text$mn:0000221F                 shl     ecx, 4
.text$mn:00002222                 mov     edx, [ebp+var_44]
.text$mn:00002225                 mov     dword ptr [edx+ecx+68h], 0
.text$mn:0000222D
.text$mn:0000222D loc_222D:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+43Ej
.text$mn:0000222D                 mov     eax, [ebp+var_44]
.text$mn:00002230                 cmp     dword ptr [eax+1Ch], 4
.text$mn:00002234                 jge     short loc_2259
.text$mn:00002236                 cmp     [ebp+var_4C], 0
.text$mn:0000223A                 jge     short loc_2259
.text$mn:0000223C                 mov     ecx, [ebp+var_48]
.text$mn:0000223F                 shl     ecx, 4
.text$mn:00002242                 mov     edx, [ebp+var_44]
.text$mn:00002245                 mov     eax, [edx+ecx+68h]
.text$mn:00002249                 add     eax, [ebp+var_4C]
.text$mn:0000224C                 mov     ecx, [ebp+var_48]
.text$mn:0000224F                 shl     ecx, 4
.text$mn:00002252                 mov     edx, [ebp+var_44]
.text$mn:00002255                 mov     [edx+ecx+68h], eax
.text$mn:00002259
.text$mn:00002259 loc_2259:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+458j
.text$mn:00002259                                         ; DockingManager::runProc(HWND__ *,uint,uint,long)+45Ej
.text$mn:00002259                 jmp     short loc_22C5  ; jumptable 0000210A default case
.text$mn:0000225B ; ---------------------------------------------------------------------------
.text$mn:0000225B
.text$mn:0000225B $LN15:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+32Ej
.text$mn:0000225B                                         ; DATA XREF: .text$mn:$LN64o
.text$mn:0000225B                 mov     eax, [ebp+var_48] ; jumptable 0000210A case 1
.text$mn:0000225E                 shl     eax, 4
.text$mn:00002261                 mov     ecx, [ebp+var_44]
.text$mn:00002264                 mov     edx, [ecx+eax+68h]
.text$mn:00002268                 add     edx, [ebp+var_4C]
.text$mn:0000226B                 mov     eax, [ebp+var_48]
.text$mn:0000226E                 shl     eax, 4
.text$mn:00002271                 mov     ecx, [ebp+var_44]
.text$mn:00002274                 mov     [ecx+eax+68h], edx
.text$mn:00002278                 mov     edx, [ebp+var_48]
.text$mn:0000227B                 shl     edx, 4
.text$mn:0000227E                 mov     eax, [ebp+var_44]
.text$mn:00002281                 cmp     dword ptr [eax+edx+68h], 0
.text$mn:00002286                 jge     short loc_2299
.text$mn:00002288                 mov     ecx, [ebp+var_48]
.text$mn:0000228B                 shl     ecx, 4
.text$mn:0000228E                 mov     edx, [ebp+var_44]
.text$mn:00002291                 mov     dword ptr [edx+ecx+68h], 0
.text$mn:00002299
.text$mn:00002299 loc_2299:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+4AAj
.text$mn:00002299                 mov     eax, [ebp+var_44]
.text$mn:0000229C                 cmp     dword ptr [eax+1Ch], 4
.text$mn:000022A0                 jge     short loc_22C5  ; jumptable 0000210A default case
.text$mn:000022A2                 cmp     [ebp+var_4C], 0
.text$mn:000022A6                 jle     short loc_22C5  ; jumptable 0000210A default case
.text$mn:000022A8                 mov     ecx, [ebp+var_48]
.text$mn:000022AB                 shl     ecx, 4
.text$mn:000022AE                 mov     edx, [ebp+var_44]
.text$mn:000022B1                 mov     eax, [edx+ecx+68h]
.text$mn:000022B5                 sub     eax, [ebp+var_4C]
.text$mn:000022B8                 mov     ecx, [ebp+var_48]
.text$mn:000022BB                 shl     ecx, 4
.text$mn:000022BE                 mov     edx, [ebp+var_44]
.text$mn:000022C1                 mov     [edx+ecx+68h], eax
.text$mn:000022C5
.text$mn:000022C5 loc_22C5:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+325j
.text$mn:000022C5                                         ; DockingManager::runProc(HWND__ *,uint,uint,long):loc_217Bj ...
.text$mn:000022C5                 mov     ecx, [ebp+var_44] ; jumptable 0000210A default case
.text$mn:000022C8                 call    ?onSize@DockingManager@@AAEXXZ ; DockingManager::onSize(void)
.text$mn:000022CD                 jmp     short loc_22D4
.text$mn:000022CF ; ---------------------------------------------------------------------------
.text$mn:000022CF
.text$mn:000022CF loc_22CF:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+315j
.text$mn:000022CF                 jmp     loc_20C2
.text$mn:000022D4 ; ---------------------------------------------------------------------------
.text$mn:000022D4
.text$mn:000022D4 loc_22D4:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+2F3j
.text$mn:000022D4                                         ; DockingManager::runProc(HWND__ *,uint,uint,long)+4F1j
.text$mn:000022D4                 jmp     $LN50           ; jumptable 00001E48 default case
.text$mn:000022D9 ; ---------------------------------------------------------------------------
.text$mn:000022D9
.text$mn:000022D9 $LN12:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+8Cj
.text$mn:000022D9                                         ; DATA XREF: .text$mn:$LN63o
.text$mn:000022D9                 push    0               ; jumptable 00001E68 cases 0,1
.text$mn:000022DB                 push    0               ; int
.text$mn:000022DD                 mov     eax, [ebp+Msg]
.text$mn:000022E0                 push    eax             ; unsigned int
.text$mn:000022E1                 mov     ecx, [ebp+lParam]
.text$mn:000022E4                 push    ecx             ; struct DockingCont *
.text$mn:000022E5                 mov     ecx, [ebp+var_44] ; this
.text$mn:000022E8                 call    ?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z ; DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)
.text$mn:000022ED                 xor     eax, eax
.text$mn:000022EF                 jmp     loc_23DF
.text$mn:000022F4 ; ---------------------------------------------------------------------------
.text$mn:000022F4
.text$mn:000022F4 loc_22F4:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+46j
.text$mn:000022F4                 mov     ecx, [ebp+lParam] ; this
.text$mn:000022F7                 call    ?getDataOfActiveTb@DockingCont@@QAEPAUtTbData@@XZ ; DockingCont::getDataOfActiveTb(void)
.text$mn:000022FC                 mov     ecx, 0Ch
.text$mn:00002301                 mov     esi, eax
.text$mn:00002303                 lea     edi, [ebp+hWnd]
.text$mn:00002306                 rep movsd
.text$mn:00002308                 push    41Bh            ; unsigned int
.text$mn:0000230D                 mov     edx, [ebp+hWnd]
.text$mn:00002310                 push    edx             ; hWnd
.text$mn:00002311                 mov     ecx, [ebp+var_44] ; this
.text$mn:00002314                 call    ?SendNotify@DockingManager@@AAEJPAUHWND__@@I@Z ; DockingManager::SendNotify(HWND__ *,uint)
.text$mn:00002319                 mov     [ebp+var_74], eax
.text$mn:0000231C                 cmp     [ebp+var_74], 0
.text$mn:00002320                 jnz     short loc_2335
.text$mn:00002322                 push    0               ; lParam
.text$mn:00002324                 push    1               ; wParam
.text$mn:00002326                 push    6               ; Msg
.text$mn:00002328                 mov     eax, [ebp+var_44]
.text$mn:0000232B                 mov     ecx, [eax+8]
.text$mn:0000232E                 push    ecx             ; hWnd
.text$mn:0000232F                 call    dword ptr ds:__imp__PostMessageW@16 ; PostMessageW(x,x,x,x)
.text$mn:00002335
.text$mn:00002335 loc_2335:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+544j
.text$mn:00002335                 mov     eax, [ebp+var_74]
.text$mn:00002338                 jmp     loc_23DF
.text$mn:0000233D ; ---------------------------------------------------------------------------
.text$mn:0000233D
.text$mn:0000233D $LN9:                                   ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+8Cj
.text$mn:0000233D                                         ; DATA XREF: .text$mn:$LN63o
.text$mn:0000233D                 push    0               ; jumptable 00001E68 case 3
.text$mn:0000233F                 push    5003h           ; unsigned int
.text$mn:00002344                 mov     edx, [ebp+lParam]
.text$mn:00002347                 push    edx             ; struct DockingCont *
.text$mn:00002348                 mov     ecx, [ebp+var_44] ; this
.text$mn:0000234B                 call    ?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z ; DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)
.text$mn:00002350                 xor     eax, eax
.text$mn:00002352                 jmp     loc_23DF
.text$mn:00002357 ; ---------------------------------------------------------------------------
.text$mn:00002357
.text$mn:00002357 $LN8:                                   ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+8Cj
.text$mn:00002357                                         ; DATA XREF: .text$mn:$LN63o
.text$mn:00002357                 push    0               ; jumptable 00001E68 case 2
.text$mn:00002359                 push    5002h           ; unsigned int
.text$mn:0000235E                 mov     eax, [ebp+lParam]
.text$mn:00002361                 push    eax             ; struct DockingCont *
.text$mn:00002362                 mov     ecx, [ebp+var_44] ; this
.text$mn:00002365                 call    ?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z ; DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)
.text$mn:0000236A                 xor     eax, eax
.text$mn:0000236C                 jmp     short loc_23DF
.text$mn:0000236E ; ---------------------------------------------------------------------------
.text$mn:0000236E
.text$mn:0000236E $LN7:                                   ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+8Cj
.text$mn:0000236E                                         ; DATA XREF: .text$mn:$LN63o
.text$mn:0000236E                 mov     ecx, [ebp+var_44] ; jumptable 00001E68 case 6
.text$mn:00002371                 mov     eax, [ecx+48h]
.text$mn:00002374                 jmp     short loc_23DF
.text$mn:00002376 ; ---------------------------------------------------------------------------
.text$mn:00002376
.text$mn:00002376 $LN6_2:                                 ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+8Cj
.text$mn:00002376                                         ; DATA XREF: .text$mn:$LN63o
.text$mn:00002376                 mov     [ebp+var_5C], 0 ; jumptable 00001E68 case 7
.text$mn:0000237D                 mov     ecx, [ebp+var_44]
.text$mn:00002380                 add     ecx, 38h ; '8'
.text$mn:00002383                 call    ?size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::size(void)
.text$mn:00002388                 mov     [ebp+var_88], eax
.text$mn:0000238E                 jmp     short loc_2399
.text$mn:00002390 ; ---------------------------------------------------------------------------
.text$mn:00002390
.text$mn:00002390 loc_2390:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long):loc_23BFj
.text$mn:00002390                 mov     edx, [ebp+var_5C]
.text$mn:00002393                 add     edx, 1
.text$mn:00002396                 mov     [ebp+var_5C], edx
.text$mn:00002399
.text$mn:00002399 loc_2399:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+5B2j
.text$mn:00002399                 mov     eax, [ebp+var_5C]
.text$mn:0000239C                 cmp     eax, [ebp+var_88]
.text$mn:000023A2                 jnb     short loc_23C1
.text$mn:000023A4                 mov     ecx, [ebp+var_5C]
.text$mn:000023A7                 push    ecx
.text$mn:000023A8                 mov     ecx, [ebp+var_44]
.text$mn:000023AB                 add     ecx, 38h ; '8'
.text$mn:000023AE                 call    ??A?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAEAAPAUHWND__@@I@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)
.text$mn:000023B3                 mov     edx, [ebp+lParam]
.text$mn:000023B6                 cmp     edx, [eax]
.text$mn:000023B8                 jnz     short loc_23BF
.text$mn:000023BA                 mov     eax, [ebp+var_5C]
.text$mn:000023BD                 jmp     short loc_23DF
.text$mn:000023BF ; ---------------------------------------------------------------------------
.text$mn:000023BF
.text$mn:000023BF loc_23BF:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+5DCj
.text$mn:000023BF                 jmp     short loc_2390
.text$mn:000023C1 ; ---------------------------------------------------------------------------
.text$mn:000023C1
.text$mn:000023C1 loc_23C1:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+5C6j
.text$mn:000023C1                 or      eax, 0FFFFFFFFh
.text$mn:000023C4                 jmp     short loc_23DF
.text$mn:000023C6 ; ---------------------------------------------------------------------------
.text$mn:000023C6
.text$mn:000023C6 $LN50:                                  ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+5Cj
.text$mn:000023C6                                         ; DockingManager::runProc(HWND__ *,uint,uint,long)+6Cj ...
.text$mn:000023C6                 mov     eax, [ebp+lParam] ; jumptable 00001E48 default case
.text$mn:000023C9                 push    eax             ; lParam
.text$mn:000023CA                 mov     ecx, [ebp+wParam]
.text$mn:000023CD                 push    ecx             ; wParam
.text$mn:000023CE                 mov     edx, [ebp+Msg]
.text$mn:000023D1                 push    edx             ; Msg
.text$mn:000023D2                 mov     eax, [ebp+var_44]
.text$mn:000023D5                 mov     ecx, [eax+0Ch]
.text$mn:000023D8                 push    ecx             ; hWnd
.text$mn:000023D9                 call    dword ptr ds:__imp__DefWindowProcW@16 ; DefWindowProcW(x,x,x,x)
.text$mn:000023DF
.text$mn:000023DF loc_23DF:                               ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+25Dj
.text$mn:000023DF                                         ; DockingManager::runProc(HWND__ *,uint,uint,long)+513j ...
.text$mn:000023DF                 mov     ecx, [ebp+var_C]
.text$mn:000023E2                 mov     large fs:0, ecx
.text$mn:000023E9                 pop     ecx
.text$mn:000023EA                 pop     edi
.text$mn:000023EB                 pop     esi
.text$mn:000023EC                 mov     ecx, [ebp+var_10]
.text$mn:000023EF                 xor     ecx, ebp
.text$mn:000023F1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000023F6                 mov     esp, ebp
.text$mn:000023F8                 pop     ebp
.text$mn:000023F9                 retn    10h
.text$mn:000023F9 ?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z endp
.text$mn:000023F9
.text$mn:000023F9 ; ---------------------------------------------------------------------------
.text$mn:000023FC $LN62           dd offset $LN43, offset $LN44, offset $LN49, offset $LN50
.text$mn:000023FC                                         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+6Cr
.text$mn:000023FC                                         ; jump table for switch statement
.text$mn:0000240C $LN60           db      0,     1,     3,     1
.text$mn:0000240C                                         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+65r
.text$mn:0000240C                 db      3,     3,     3,     3 ; indirect table for switch statement
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      3,     3,     3,     3
.text$mn:0000240C                 db      2
.text$mn:00002491                 align 4
.text$mn:00002494 $LN63           dd offset $LN12         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+8Cr
.text$mn:00002494                 dd offset $LN12         ; jump table for switch statement
.text$mn:00002494                 dd offset $LN8
.text$mn:00002494                 dd offset $LN9
.text$mn:00002494                 dd offset $LN32
.text$mn:00002494                 dd offset $LN50
.text$mn:00002494                 dd offset $LN7
.text$mn:00002494                 dd offset $LN6_2
.text$mn:00002494                 dd offset $LN50
.text$mn:00002494                 dd offset $LN31
.text$mn:00002494                 dd offset $LN50
.text$mn:00002494                 dd offset $LN37
.text$mn:000024C4 $LN64           dd offset $LN18         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+32Er
.text$mn:000024C4                 dd offset $LN15         ; jump table for switch statement
.text$mn:000024C4                 dd offset $LN24
.text$mn:000024C4                 dd offset $LN21
.text$mn:000024D4                 db 8 dup(0CCh)
.text$mn:000024DC
.text$mn:000024DC ; =============== S U B R O U T I N E =======================================
.text$mn:000024DC
.text$mn:000024DC ; Attributes: bp-based frame
.text$mn:000024DC
.text$mn:000024DC ; void __thiscall DockingManager::onSize(DockingManager *__hidden this)
.text$mn:000024DC                 public ?onSize@DockingManager@@AAEXXZ
.text$mn:000024DC ?onSize@DockingManager@@AAEXXZ proc near
.text$mn:000024DC                                         ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+8Bp
.text$mn:000024DC                                         ; DockingManager::toggleVisTb(DockingCont *,DockingCont *)+5Ap ...
.text$mn:000024DC
.text$mn:000024DC var_4           = dword ptr -4
.text$mn:000024DC
.text$mn:000024DC                 push    ebp
.text$mn:000024DD                 mov     ebp, esp
.text$mn:000024DF                 push    ecx
.text$mn:000024E0                 mov     [ebp+var_4], ecx
.text$mn:000024E3                 mov     eax, [ebp+var_4]
.text$mn:000024E6                 add     eax, 24h ; '$'
.text$mn:000024E9                 push    eax
.text$mn:000024EA                 mov     ecx, [ebp+var_4]
.text$mn:000024ED                 mov     edx, [ecx]
.text$mn:000024EF                 mov     ecx, [ebp+var_4]
.text$mn:000024F2                 mov     eax, [edx+10h]
.text$mn:000024F5                 call    eax
.text$mn:000024F7                 mov     esp, ebp
.text$mn:000024F9                 pop     ebp
.text$mn:000024FA                 retn
.text$mn:000024FA ?onSize@DockingManager@@AAEXXZ endp
.text$mn:000024FA
.text$mn:000024FA ; ---------------------------------------------------------------------------
.text$mn:000024FB                 align 4
.text$mn:000024FC
.text$mn:000024FC ; =============== S U B R O U T I N E =======================================
.text$mn:000024FC
.text$mn:000024FC ; Attributes: bp-based frame
.text$mn:000024FC
.text$mn:000024FC ; private: void __thiscall DockingManager::toggleTb(class DockingCont *, class DockingCont *, struct tTbData)
.text$mn:000024FC                 public ?toggleTb@DockingManager@@AAEXPAVDockingCont@@0UtTbData@@@Z
.text$mn:000024FC ?toggleTb@DockingManager@@AAEXPAVDockingCont@@0UtTbData@@@Z proc near
.text$mn:000024FC                                         ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,DockingCont *)+43p
.text$mn:000024FC                                         ; DockingManager::toggleVisTb(DockingCont *,DockingCont *)+B6p
.text$mn:000024FC
.text$mn:000024FC var_C           = dword ptr -0Ch
.text$mn:000024FC var_8           = dword ptr -8
.text$mn:000024FC var_4           = dword ptr -4
.text$mn:000024FC arg_0           = dword ptr  8
.text$mn:000024FC arg_4           = dword ptr  0Ch
.text$mn:000024FC hWnd            = dword ptr  10h
.text$mn:000024FC arg_30          = dword ptr  38h
.text$mn:000024FC
.text$mn:000024FC                 push    ebp
.text$mn:000024FD                 mov     ebp, esp
.text$mn:000024FF                 sub     esp, 0Ch
.text$mn:00002502                 push    esi
.text$mn:00002503                 push    edi
.text$mn:00002504                 mov     [ebp+var_8], ecx
.text$mn:00002507                 mov     eax, [ebp+arg_0]
.text$mn:0000250A                 push    eax             ; struct DockingCont *
.text$mn:0000250B                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000250E                 call    ?GetContainer@DockingManager@@QAEHPAVDockingCont@@@Z ; DockingManager::GetContainer(DockingCont *)
.text$mn:00002513                 mov     [ebp+var_C], eax
.text$mn:00002516                 mov     ecx, [ebp+arg_4]
.text$mn:00002519                 push    ecx             ; struct DockingCont *
.text$mn:0000251A                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000251D                 call    ?GetContainer@DockingManager@@QAEHPAVDockingCont@@@Z ; DockingManager::GetContainer(DockingCont *)
.text$mn:00002522                 mov     [ebp+var_4], eax
.text$mn:00002525                 cmp     [ebp+var_C], 4
.text$mn:00002529                 jge     short loc_2531
.text$mn:0000252B                 cmp     [ebp+var_4], 4
.text$mn:0000252F                 jge     short loc_253D
.text$mn:00002531
.text$mn:00002531 loc_2531:                               ; CODE XREF: DockingManager::toggleTb(DockingCont *,DockingCont *,tTbData)+2Dj
.text$mn:00002531                 cmp     [ebp+var_C], 4
.text$mn:00002535                 jl      short loc_2543
.text$mn:00002537                 cmp     [ebp+var_4], 4
.text$mn:0000253B                 jge     short loc_2543
.text$mn:0000253D
.text$mn:0000253D loc_253D:                               ; CODE XREF: DockingManager::toggleTb(DockingCont *,DockingCont *,tTbData)+33j
.text$mn:0000253D                 mov     edx, [ebp+var_C]
.text$mn:00002540                 mov     [ebp+arg_30], edx
.text$mn:00002543
.text$mn:00002543 loc_2543:                               ; CODE XREF: DockingManager::toggleTb(DockingCont *,DockingCont *,tTbData)+39j
.text$mn:00002543                                         ; DockingManager::toggleTb(DockingCont *,DockingCont *,tTbData)+3Fj
.text$mn:00002543                 cmp     [ebp+var_4], 4
.text$mn:00002547                 jge     short loc_256C
.text$mn:00002549                 mov     eax, [ebp+var_4]
.text$mn:0000254C                 and     eax, 0FFFFh
.text$mn:00002551                 movzx   ecx, ax
.text$mn:00002554                 shl     ecx, 10h
.text$mn:00002557                 or      ecx, 41Ch
.text$mn:0000255D                 push    ecx             ; unsigned int
.text$mn:0000255E                 mov     edx, [ebp+hWnd]
.text$mn:00002561                 push    edx             ; hWnd
.text$mn:00002562                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002565                 call    ?SendNotify@DockingManager@@AAEJPAUHWND__@@I@Z ; DockingManager::SendNotify(HWND__ *,uint)
.text$mn:0000256A                 jmp     short loc_258D
.text$mn:0000256C ; ---------------------------------------------------------------------------
.text$mn:0000256C
.text$mn:0000256C loc_256C:                               ; CODE XREF: DockingManager::toggleTb(DockingCont *,DockingCont *,tTbData)+4Bj
.text$mn:0000256C                 mov     eax, [ebp+var_4]
.text$mn:0000256F                 and     eax, 0FFFFh
.text$mn:00002574                 movzx   ecx, ax
.text$mn:00002577                 shl     ecx, 10h
.text$mn:0000257A                 or      ecx, 41Dh
.text$mn:00002580                 push    ecx             ; unsigned int
.text$mn:00002581                 mov     edx, [ebp+hWnd]
.text$mn:00002584                 push    edx             ; hWnd
.text$mn:00002585                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002588                 call    ?SendNotify@DockingManager@@AAEJPAUHWND__@@I@Z ; DockingManager::SendNotify(HWND__ *,uint)
.text$mn:0000258D
.text$mn:0000258D loc_258D:                               ; CODE XREF: DockingManager::toggleTb(DockingCont *,DockingCont *,tTbData)+6Ej
.text$mn:0000258D                 sub     esp, 30h
.text$mn:00002590                 mov     ecx, 0Ch
.text$mn:00002595                 lea     esi, [ebp+hWnd]
.text$mn:00002598                 mov     edi, esp
.text$mn:0000259A                 rep movsd
.text$mn:0000259C                 mov     ecx, [ebp+arg_4]
.text$mn:0000259F                 call    ?createToolbar@DockingCont@@QAEPAUtTbData@@U2@@Z ; DockingCont::createToolbar(tTbData)
.text$mn:000025A4                 sub     esp, 30h
.text$mn:000025A7                 mov     ecx, 0Ch
.text$mn:000025AC                 lea     esi, [ebp+hWnd]
.text$mn:000025AF                 mov     edi, esp
.text$mn:000025B1                 rep movsd
.text$mn:000025B3                 mov     eax, [ebp+var_C]
.text$mn:000025B6                 push    eax
.text$mn:000025B7                 mov     ecx, [ebp+var_8]
.text$mn:000025BA                 add     ecx, 4Ch ; 'L'
.text$mn:000025BD                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000025C2                 mov     ecx, [eax]
.text$mn:000025C4                 call    ?removeToolbar@DockingCont@@QAEXUtTbData@@@Z ; DockingCont::removeToolbar(tTbData)
.text$mn:000025C9                 pop     edi
.text$mn:000025CA                 pop     esi
.text$mn:000025CB                 mov     esp, ebp
.text$mn:000025CD                 pop     ebp
.text$mn:000025CE                 retn    38h
.text$mn:000025CE ?toggleTb@DockingManager@@AAEXPAVDockingCont@@0UtTbData@@@Z endp ; sp-analysis failed
.text$mn:000025CE
.text$mn:000025CE ; ---------------------------------------------------------------------------
.text$mn:000025D1                 db 0Bh dup(0CCh)
.text$mn:000025DC
.text$mn:000025DC ; =============== S U B R O U T I N E =======================================
.text$mn:000025DC
.text$mn:000025DC ; Attributes: bp-based frame
.text$mn:000025DC
.text$mn:000025DC ; int __thiscall DockingManager::ContExists(DockingManager *this, unsigned int)
.text$mn:000025DC                 public ?ContExists@DockingManager@@AAEHI@Z
.text$mn:000025DC ?ContExists@DockingManager@@AAEHI@Z proc near
.text$mn:000025DC                                         ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+5Dp
.text$mn:000025DC                                         ; DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+6Dp
.text$mn:000025DC
.text$mn:000025DC var_8           = dword ptr -8
.text$mn:000025DC var_4           = dword ptr -4
.text$mn:000025DC arg_0           = dword ptr  8
.text$mn:000025DC
.text$mn:000025DC                 push    ebp
.text$mn:000025DD                 mov     ebp, esp
.text$mn:000025DF                 sub     esp, 8
.text$mn:000025E2                 mov     [ebp+var_8], ecx
.text$mn:000025E5                 mov     [ebp+var_4], 0
.text$mn:000025EC                 mov     ecx, [ebp+var_8]
.text$mn:000025EF                 add     ecx, 4Ch ; 'L'
.text$mn:000025F2                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:000025F7                 cmp     [ebp+arg_0], eax
.text$mn:000025FA                 jnb     short loc_2603
.text$mn:000025FC                 mov     [ebp+var_4], 1
.text$mn:00002603
.text$mn:00002603 loc_2603:                               ; CODE XREF: DockingManager::ContExists(uint)+1Ej
.text$mn:00002603                 mov     eax, [ebp+var_4]
.text$mn:00002606                 mov     esp, ebp
.text$mn:00002608                 pop     ebp
.text$mn:00002609                 retn    4
.text$mn:00002609 ?ContExists@DockingManager@@AAEHI@Z endp
.text$mn:00002609
.text$mn:0000260C
.text$mn:0000260C ; =============== S U B R O U T I N E =======================================
.text$mn:0000260C
.text$mn:0000260C ; Attributes: bp-based frame
.text$mn:0000260C
.text$mn:0000260C ; int __thiscall DockingManager::FindEmptyContainer(DockingManager *__hidden this)
.text$mn:0000260C                 public ?FindEmptyContainer@DockingManager@@AAEHXZ
.text$mn:0000260C ?FindEmptyContainer@DockingManager@@AAEHXZ proc near
.text$mn:0000260C                                         ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+9Fp
.text$mn:0000260C
.text$mn:0000260C var_54          = byte ptr -54h
.text$mn:0000260C var_44          = dword ptr -44h
.text$mn:0000260C var_40          = dword ptr -40h
.text$mn:0000260C var_3C          = dword ptr -3Ch
.text$mn:0000260C var_38          = dword ptr -38h
.text$mn:0000260C var_34          = dword ptr -34h
.text$mn:0000260C var_30          = dword ptr -30h
.text$mn:0000260C var_2C          = dword ptr -2Ch
.text$mn:0000260C var_28          = dword ptr -28h
.text$mn:0000260C var_24          = dword ptr -24h
.text$mn:0000260C var_20          = dword ptr -20h
.text$mn:0000260C var_1C          = dword ptr -1Ch
.text$mn:0000260C var_18          = dword ptr -18h
.text$mn:0000260C var_14          = dword ptr -14h
.text$mn:0000260C var_10          = dword ptr -10h
.text$mn:0000260C var_C           = dword ptr -0Ch
.text$mn:0000260C var_4           = dword ptr -4
.text$mn:0000260C
.text$mn:0000260C                 push    ebp
.text$mn:0000260D                 mov     ebp, esp
.text$mn:0000260F                 push    0FFFFFFFFh
.text$mn:00002611                 push    offset __ehhandler$?FindEmptyContainer@DockingManager@@AAEHXZ
.text$mn:00002616                 mov     eax, large fs:0
.text$mn:0000261C                 push    eax
.text$mn:0000261D                 sub     esp, 48h
.text$mn:00002620                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002625                 xor     eax, ebp
.text$mn:00002627                 push    eax
.text$mn:00002628                 lea     eax, [ebp+var_C]
.text$mn:0000262B                 mov     large fs:0, eax
.text$mn:00002631                 mov     [ebp+var_14], ecx
.text$mn:00002634                 mov     [ebp+var_30], 0FFFFFFFFh
.text$mn:0000263B                 mov     ecx, [ebp+var_14]
.text$mn:0000263E                 add     ecx, 4Ch ; 'L'
.text$mn:00002641                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00002646                 add     eax, 1
.text$mn:00002649                 xor     ecx, ecx
.text$mn:0000264B                 mov     edx, 4
.text$mn:00002650                 mul     edx
.text$mn:00002652                 seto    cl
.text$mn:00002655                 neg     ecx
.text$mn:00002657                 or      ecx, eax
.text$mn:00002659                 push    ecx             ; unsigned int
.text$mn:0000265A                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:0000265F                 add     esp, 4
.text$mn:00002662                 mov     [ebp+var_34], eax
.text$mn:00002665                 mov     eax, [ebp+var_34]
.text$mn:00002668                 mov     [ebp+var_24], eax
.text$mn:0000266B                 mov     ecx, 4
.text$mn:00002670                 shl     ecx, 0
.text$mn:00002673                 add     ecx, [ebp+var_24]
.text$mn:00002676                 mov     [ebp+var_28], ecx
.text$mn:00002679                 mov     [ebp+var_18], 0
.text$mn:00002680                 mov     ecx, [ebp+var_14]
.text$mn:00002683                 add     ecx, 4Ch ; 'L'
.text$mn:00002686                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:0000268B                 add     eax, 1
.text$mn:0000268E                 mov     [ebp+var_38], eax
.text$mn:00002691                 jmp     short loc_269C
.text$mn:00002693 ; ---------------------------------------------------------------------------
.text$mn:00002693
.text$mn:00002693 loc_2693:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+A5j
.text$mn:00002693                 mov     edx, [ebp+var_18]
.text$mn:00002696                 add     edx, 1
.text$mn:00002699                 mov     [ebp+var_18], edx
.text$mn:0000269C
.text$mn:0000269C loc_269C:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+85j
.text$mn:0000269C                 mov     eax, [ebp+var_18]
.text$mn:0000269F                 cmp     eax, [ebp+var_38]
.text$mn:000026A2                 jnb     short loc_26B3
.text$mn:000026A4                 mov     ecx, [ebp+var_18]
.text$mn:000026A7                 mov     edx, [ebp+var_24]
.text$mn:000026AA                 mov     dword ptr [edx+ecx*4], 0
.text$mn:000026B1                 jmp     short loc_2693
.text$mn:000026B3 ; ---------------------------------------------------------------------------
.text$mn:000026B3
.text$mn:000026B3 loc_26B3:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+96j
.text$mn:000026B3                 mov     [ebp+var_1C], 0
.text$mn:000026BA                 jmp     short loc_26C5
.text$mn:000026BC ; ---------------------------------------------------------------------------
.text$mn:000026BC
.text$mn:000026BC loc_26BC:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+131j
.text$mn:000026BC                 mov     eax, [ebp+var_1C]
.text$mn:000026BF                 add     eax, 1
.text$mn:000026C2                 mov     [ebp+var_1C], eax
.text$mn:000026C5
.text$mn:000026C5 loc_26C5:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+AEj
.text$mn:000026C5                 cmp     [ebp+var_1C], 4
.text$mn:000026C9                 jnb     short loc_2742
.text$mn:000026CB                 lea     ecx, [ebp+var_54]
.text$mn:000026CE                 push    ecx
.text$mn:000026CF                 mov     edx, [ebp+var_1C]
.text$mn:000026D2                 push    edx
.text$mn:000026D3                 mov     ecx, [ebp+var_14]
.text$mn:000026D6                 add     ecx, 4Ch ; 'L'
.text$mn:000026D9                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000026DE                 mov     ecx, [eax]
.text$mn:000026E0                 call    ?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ ; DockingCont::getDataOfAllTb(void)
.text$mn:000026E5                 mov     [ebp+var_4], 0
.text$mn:000026EC                 mov     [ebp+var_20], 0
.text$mn:000026F3                 lea     ecx, [ebp+var_54]
.text$mn:000026F6                 call    ?size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ ; std::vector<tTbData *,std::allocator<tTbData *>>::size(void)
.text$mn:000026FB                 mov     [ebp+var_3C], eax
.text$mn:000026FE                 jmp     short loc_2709
.text$mn:00002700 ; ---------------------------------------------------------------------------
.text$mn:00002700
.text$mn:00002700 loc_2700:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+120j
.text$mn:00002700                 mov     eax, [ebp+var_20]
.text$mn:00002703                 add     eax, 1
.text$mn:00002706                 mov     [ebp+var_20], eax
.text$mn:00002709
.text$mn:00002709 loc_2709:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+F2j
.text$mn:00002709                 mov     ecx, [ebp+var_20]
.text$mn:0000270C                 cmp     ecx, [ebp+var_3C]
.text$mn:0000270F                 jnb     short loc_272E
.text$mn:00002711                 mov     edx, [ebp+var_20]
.text$mn:00002714                 push    edx
.text$mn:00002715                 lea     ecx, [ebp+var_54]
.text$mn:00002718                 call    ??A?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAEAAPAUtTbData@@I@Z ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)
.text$mn:0000271D                 mov     eax, [eax]
.text$mn:0000271F                 mov     ecx, [eax+28h]
.text$mn:00002722                 mov     edx, [ebp+var_28]
.text$mn:00002725                 mov     dword ptr [edx+ecx*4], 1
.text$mn:0000272C                 jmp     short loc_2700
.text$mn:0000272E ; ---------------------------------------------------------------------------
.text$mn:0000272E
.text$mn:0000272E loc_272E:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+103j
.text$mn:0000272E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002735                 lea     ecx, [ebp+var_54]
.text$mn:00002738                 call    ??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ ; std::vector<tTbData *,std::allocator<tTbData *>>::~vector<tTbData *,std::allocator<tTbData *>>(void)
.text$mn:0000273D                 jmp     loc_26BC
.text$mn:00002742 ; ---------------------------------------------------------------------------
.text$mn:00002742
.text$mn:00002742 loc_2742:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+BDj
.text$mn:00002742                 mov     [ebp+var_10], 4
.text$mn:00002749                 mov     ecx, [ebp+var_14]
.text$mn:0000274C                 add     ecx, 4Ch ; 'L'
.text$mn:0000274F                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00002754                 mov     [ebp+var_40], eax
.text$mn:00002757                 jmp     short loc_2762
.text$mn:00002759 ; ---------------------------------------------------------------------------
.text$mn:00002759
.text$mn:00002759 loc_2759:                               ; CODE XREF: DockingManager::FindEmptyContainer(void):loc_27A6j
.text$mn:00002759                 mov     eax, [ebp+var_10]
.text$mn:0000275C                 add     eax, 1
.text$mn:0000275F                 mov     [ebp+var_10], eax
.text$mn:00002762
.text$mn:00002762 loc_2762:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+14Bj
.text$mn:00002762                 mov     ecx, [ebp+var_10]
.text$mn:00002765                 cmp     ecx, [ebp+var_40]
.text$mn:00002768                 jnb     short loc_27A8
.text$mn:0000276A                 mov     edx, [ebp+var_10]
.text$mn:0000276D                 mov     eax, [ebp+var_28]
.text$mn:00002770                 cmp     dword ptr [eax+edx*4], 0
.text$mn:00002774                 jnz     short loc_27A6
.text$mn:00002776                 mov     ecx, [ebp+var_10]
.text$mn:00002779                 push    ecx
.text$mn:0000277A                 mov     ecx, [ebp+var_14]
.text$mn:0000277D                 add     ecx, 4Ch ; 'L'
.text$mn:00002780                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00002785                 mov     edx, [eax]
.text$mn:00002787                 mov     [ebp+var_2C], edx
.text$mn:0000278A                 mov     eax, [ebp+var_2C]
.text$mn:0000278D                 mov     edx, [eax]
.text$mn:0000278F                 mov     ecx, [ebp+var_2C]
.text$mn:00002792                 mov     eax, [edx+2Ch]
.text$mn:00002795                 call    eax
.text$mn:00002797                 movzx   ecx, al
.text$mn:0000279A                 test    ecx, ecx
.text$mn:0000279C                 jnz     short loc_27A6
.text$mn:0000279E                 mov     edx, [ebp+var_10]
.text$mn:000027A1                 mov     [ebp+var_30], edx
.text$mn:000027A4                 jmp     short loc_27A8
.text$mn:000027A6 ; ---------------------------------------------------------------------------
.text$mn:000027A6
.text$mn:000027A6 loc_27A6:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+168j
.text$mn:000027A6                                         ; DockingManager::FindEmptyContainer(void)+190j
.text$mn:000027A6                 jmp     short loc_2759
.text$mn:000027A8 ; ---------------------------------------------------------------------------
.text$mn:000027A8
.text$mn:000027A8 loc_27A8:                               ; CODE XREF: DockingManager::FindEmptyContainer(void)+15Cj
.text$mn:000027A8                                         ; DockingManager::FindEmptyContainer(void)+198j
.text$mn:000027A8                 mov     eax, [ebp+var_24]
.text$mn:000027AB                 mov     [ebp+var_44], eax
.text$mn:000027AE                 mov     ecx, [ebp+var_44]
.text$mn:000027B1                 push    ecx             ; void *
.text$mn:000027B2                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:000027B7                 add     esp, 4
.text$mn:000027BA                 mov     eax, [ebp+var_30]
.text$mn:000027BD                 mov     ecx, [ebp+var_C]
.text$mn:000027C0                 mov     large fs:0, ecx
.text$mn:000027C7                 pop     ecx
.text$mn:000027C8                 mov     esp, ebp
.text$mn:000027CA                 pop     ebp
.text$mn:000027CB                 retn
.text$mn:000027CB ?FindEmptyContainer@DockingManager@@AAEHXZ endp
.text$mn:000027CB
.text$mn:000027CC
.text$mn:000027CC ; =============== S U B R O U T I N E =======================================
.text$mn:000027CC
.text$mn:000027CC ; Attributes: bp-based frame
.text$mn:000027CC
.text$mn:000027CC ; __int32 __thiscall DockingManager::SendNotify(DockingManager *this, HWND hWnd, unsigned int)
.text$mn:000027CC                 public ?SendNotify@DockingManager@@AAEJPAUHWND__@@I@Z
.text$mn:000027CC ?SendNotify@DockingManager@@AAEJPAUHWND__@@I@Z proc near
.text$mn:000027CC                                         ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+3E6p
.text$mn:000027CC                                         ; DockingManager::createDockableDlg(tTbData,int,bool)+409p ...
.text$mn:000027CC
.text$mn:000027CC lParam          = dword ptr -10h
.text$mn:000027CC wParam          = dword ptr -0Ch
.text$mn:000027CC var_8           = dword ptr -8
.text$mn:000027CC var_4           = dword ptr -4
.text$mn:000027CC hWnd            = dword ptr  8
.text$mn:000027CC arg_4           = dword ptr  0Ch
.text$mn:000027CC
.text$mn:000027CC                 push    ebp
.text$mn:000027CD                 mov     ebp, esp
.text$mn:000027CF                 sub     esp, 10h
.text$mn:000027D2                 mov     [ebp+var_4], ecx
.text$mn:000027D5                 mov     eax, [ebp+arg_4]
.text$mn:000027D8                 mov     [ebp+var_8], eax
.text$mn:000027DB                 mov     ecx, [ebp+var_4]
.text$mn:000027DE                 mov     edx, [ecx+8]
.text$mn:000027E1                 mov     [ebp+lParam], edx
.text$mn:000027E4                 mov     eax, [ebp+var_4]
.text$mn:000027E7                 mov     ecx, [eax+8]
.text$mn:000027EA                 push    ecx             ; hWnd
.text$mn:000027EB                 call    dword ptr ds:__imp__GetDlgCtrlID@4 ; GetDlgCtrlID(x)
.text$mn:000027F1                 mov     [ebp+wParam], eax
.text$mn:000027F4                 lea     edx, [ebp+lParam]
.text$mn:000027F7                 push    edx             ; lParam
.text$mn:000027F8                 mov     eax, [ebp+wParam]
.text$mn:000027FB                 push    eax             ; wParam
.text$mn:000027FC                 push    4Eh ; 'N'       ; Msg
.text$mn:000027FE                 mov     ecx, [ebp+hWnd]
.text$mn:00002801                 push    ecx             ; hWnd
.text$mn:00002802                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00002808                 push    0               ; nIndex
.text$mn:0000280A                 mov     edx, [ebp+hWnd]
.text$mn:0000280D                 push    edx             ; hWnd
.text$mn:0000280E                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00002814                 mov     esp, ebp
.text$mn:00002816                 pop     ebp
.text$mn:00002817                 retn    8
.text$mn:00002817 ?SendNotify@DockingManager@@AAEJPAUHWND__@@I@Z endp
.text$mn:00002817
.text$mn:00002817 ; ---------------------------------------------------------------------------
.text$mn:0000281A                 align 4
.text$mn:0000281C
.text$mn:0000281C ; =============== S U B R O U T I N E =======================================
.text$mn:0000281C
.text$mn:0000281C ; Attributes: bp-based frame
.text$mn:0000281C
.text$mn:0000281C ; LRESULT __stdcall FocusWndProc(int code, WPARAM wParam, LPARAM lParam)
.text$mn:0000281C                 public ?FocusWndProc@@YGJHIJ@Z
.text$mn:0000281C ?FocusWndProc@@YGJHIJ@Z proc near       ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+24Fo
.text$mn:0000281C
.text$mn:0000281C var_14          = dword ptr -14h
.text$mn:0000281C var_10          = dword ptr -10h
.text$mn:0000281C var_C           = dword ptr -0Ch
.text$mn:0000281C var_8           = dword ptr -8
.text$mn:0000281C var_4           = dword ptr -4
.text$mn:0000281C code            = dword ptr  8
.text$mn:0000281C wParam          = dword ptr  0Ch
.text$mn:0000281C lParam          = dword ptr  10h
.text$mn:0000281C
.text$mn:0000281C                 push    ebp
.text$mn:0000281D                 mov     ebp, esp
.text$mn:0000281F                 sub     esp, 14h
.text$mn:00002822                 cmp     [ebp+code], 0
.text$mn:00002826                 jnz     loc_28F7
.text$mn:0000282C                 cmp     ds:_hWndServer, 0
.text$mn:00002833                 jz      loc_28F7
.text$mn:00002839                 push    0FFFFFFEBh      ; nIndex
.text$mn:0000283B                 mov     eax, ds:_hWndServer
.text$mn:00002840                 push    eax             ; hWnd
.text$mn:00002841                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00002847                 mov     [ebp+var_14], eax
.text$mn:0000284A                 cmp     [ebp+var_14], 0
.text$mn:0000284E                 jz      loc_28F7
.text$mn:00002854                 mov     ecx, [ebp+var_14]
.text$mn:00002857                 call    ?getContainerInfo@DockingManager@@QAEAAV?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@XZ ; DockingManager::getContainerInfo(void)
.text$mn:0000285C                 mov     [ebp+var_10], eax
.text$mn:0000285F                 mov     ecx, [ebp+lParam]
.text$mn:00002862                 mov     [ebp+var_C], ecx
.text$mn:00002865                 mov     edx, [ebp+var_C]
.text$mn:00002868                 cmp     dword ptr [edx+8], 8
.text$mn:0000286C                 jnz     short loc_289F
.text$mn:0000286E                 mov     [ebp+var_8], 0
.text$mn:00002875                 jmp     short loc_2880
.text$mn:00002877 ; ---------------------------------------------------------------------------
.text$mn:00002877
.text$mn:00002877 loc_2877:                               ; CODE XREF: FocusWndProc(int,uint,long)+7Fj
.text$mn:00002877                 mov     eax, [ebp+var_8]
.text$mn:0000287A                 add     eax, 1
.text$mn:0000287D                 mov     [ebp+var_8], eax
.text$mn:00002880
.text$mn:00002880 loc_2880:                               ; CODE XREF: FocusWndProc(int,uint,long)+59j
.text$mn:00002880                 cmp     [ebp+var_8], 4
.text$mn:00002884                 jge     short loc_289D
.text$mn:00002886                 push    0               ; int
.text$mn:00002888                 mov     ecx, [ebp+var_8]
.text$mn:0000288B                 push    ecx
.text$mn:0000288C                 mov     ecx, [ebp+var_10]
.text$mn:0000288F                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00002894                 mov     ecx, [eax]      ; this
.text$mn:00002896                 call    ?SetActive@DockingCont@@QAEXH@Z ; DockingCont::SetActive(int)
.text$mn:0000289B                 jmp     short loc_2877
.text$mn:0000289D ; ---------------------------------------------------------------------------
.text$mn:0000289D
.text$mn:0000289D loc_289D:                               ; CODE XREF: FocusWndProc(int,uint,long)+68j
.text$mn:0000289D                 jmp     short loc_28F7
.text$mn:0000289F ; ---------------------------------------------------------------------------
.text$mn:0000289F
.text$mn:0000289F loc_289F:                               ; CODE XREF: FocusWndProc(int,uint,long)+50j
.text$mn:0000289F                 mov     edx, [ebp+var_C]
.text$mn:000028A2                 cmp     dword ptr [edx+8], 7
.text$mn:000028A6                 jnz     short loc_28F7
.text$mn:000028A8                 mov     [ebp+var_4], 0
.text$mn:000028AF                 jmp     short loc_28BA
.text$mn:000028B1 ; ---------------------------------------------------------------------------
.text$mn:000028B1
.text$mn:000028B1 loc_28B1:                               ; CODE XREF: FocusWndProc(int,uint,long)+D9j
.text$mn:000028B1                 mov     eax, [ebp+var_4]
.text$mn:000028B4                 add     eax, 1
.text$mn:000028B7                 mov     [ebp+var_4], eax
.text$mn:000028BA
.text$mn:000028BA loc_28BA:                               ; CODE XREF: FocusWndProc(int,uint,long)+93j
.text$mn:000028BA                 cmp     [ebp+var_4], 4
.text$mn:000028BE                 jge     short loc_28F7
.text$mn:000028C0                 mov     ecx, [ebp+var_C]
.text$mn:000028C3                 mov     edx, [ecx+0Ch]
.text$mn:000028C6                 push    edx             ; hWnd
.text$mn:000028C7                 mov     eax, [ebp+var_4]
.text$mn:000028CA                 push    eax
.text$mn:000028CB                 mov     ecx, [ebp+var_10]
.text$mn:000028CE                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000028D3                 mov     ecx, [eax]      ; this
.text$mn:000028D5                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000028DA                 push    eax             ; hWndParent
.text$mn:000028DB                 call    dword ptr ds:__imp__IsChild@8 ; IsChild(x,x)
.text$mn:000028E1                 push    eax             ; int
.text$mn:000028E2                 mov     ecx, [ebp+var_4]
.text$mn:000028E5                 push    ecx
.text$mn:000028E6                 mov     ecx, [ebp+var_10]
.text$mn:000028E9                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000028EE                 mov     ecx, [eax]      ; this
.text$mn:000028F0                 call    ?SetActive@DockingCont@@QAEXH@Z ; DockingCont::SetActive(int)
.text$mn:000028F5                 jmp     short loc_28B1
.text$mn:000028F7 ; ---------------------------------------------------------------------------
.text$mn:000028F7
.text$mn:000028F7 loc_28F7:                               ; CODE XREF: FocusWndProc(int,uint,long)+Aj
.text$mn:000028F7                                         ; FocusWndProc(int,uint,long)+17j ...
.text$mn:000028F7                 mov     edx, [ebp+lParam]
.text$mn:000028FA                 push    edx             ; lParam
.text$mn:000028FB                 mov     eax, [ebp+wParam]
.text$mn:000028FE                 push    eax             ; wParam
.text$mn:000028FF                 mov     ecx, [ebp+code]
.text$mn:00002902                 push    ecx             ; nCode
.text$mn:00002903                 mov     edx, ds:_gWinCallHook
.text$mn:00002909                 push    edx             ; hhk
.text$mn:0000290A                 call    dword ptr ds:__imp__CallNextHookEx@16 ; CallNextHookEx(x,x,x,x)
.text$mn:00002910                 mov     esp, ebp
.text$mn:00002912                 pop     ebp
.text$mn:00002913                 retn    0Ch
.text$mn:00002913 ?FocusWndProc@@YGJHIJ@Z endp
.text$mn:00002913
.text$mn:00002913 ; ---------------------------------------------------------------------------
.text$mn:00002916                 align 4
.text$mn:00002916 _text$mn        ends
.text$mn:00002916
.text$x:00002918 ; ===========================================================================
.text$x:00002918
.text$x:00002918 ; Segment type: Pure code
.text$x:00002918 ; Segment permissions: Read/Execute
.text$x:00002918 _text$x         segment para public 'CODE' use32
.text$x:00002918                 assume cs:_text$x
.text$x:00002918                 ;org 2918h
.text$x:00002918                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002918
.text$x:00002918 ; =============== S U B R O U T I N E =======================================
.text$x:00002918
.text$x:00002918
.text$x:00002918 __unwindfunclet$??0DockingManager@@QAE@XZ$0 proc near
.text$x:00002918                                         ; DATA XREF: .xdata$x:000093ECo
.text$x:00002918                 mov     ecx, [ebp-10h]  ; this
.text$x:0000291B                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:0000291B __unwindfunclet$??0DockingManager@@QAE@XZ$0 endp
.text$x:0000291B
.text$x:00002920
.text$x:00002920 ; =============== S U B R O U T I N E =======================================
.text$x:00002920
.text$x:00002920
.text$x:00002920 __unwindfunclet$??0DockingManager@@QAE@XZ$1 proc near
.text$x:00002920                                         ; DATA XREF: .xdata$x:000093F4o
.text$x:00002920                 mov     ecx, [ebp-10h]
.text$x:00002923                 add     ecx, 38h ; '8'
.text$x:00002926                 jmp     ??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::~vector<HWND__ *,std::allocator<HWND__ *>>(void)
.text$x:00002926 __unwindfunclet$??0DockingManager@@QAE@XZ$1 endp
.text$x:00002926
.text$x:0000292B
.text$x:0000292B ; =============== S U B R O U T I N E =======================================
.text$x:0000292B
.text$x:0000292B
.text$x:0000292B __unwindfunclet$??0DockingManager@@QAE@XZ$2 proc near
.text$x:0000292B                                         ; DATA XREF: .xdata$x:000093FCo
.text$x:0000292B                 mov     ecx, [ebp-10h]
.text$x:0000292E                 add     ecx, 4Ch ; 'L'
.text$x:00002931                 jmp     ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$x:00002931 __unwindfunclet$??0DockingManager@@QAE@XZ$2 endp
.text$x:00002931
.text$x:00002936
.text$x:00002936 ; =============== S U B R O U T I N E =======================================
.text$x:00002936
.text$x:00002936
.text$x:00002936 __unwindfunclet$??0DockingManager@@QAE@XZ$3 proc near
.text$x:00002936                                         ; DATA XREF: .xdata$x:00009404o
.text$x:00002936                 mov     ecx, [ebp-10h]
.text$x:00002939                 add     ecx, 16Ch
.text$x:0000293F                 jmp     ??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::~vector<DockingSplitter *,std::allocator<DockingSplitter *>>(void)
.text$x:0000293F __unwindfunclet$??0DockingManager@@QAE@XZ$3 endp
.text$x:0000293F
.text$x:00002944
.text$x:00002944 ; =============== S U B R O U T I N E =======================================
.text$x:00002944
.text$x:00002944
.text$x:00002944 __unwindfunclet$??0DockingManager@@QAE@XZ$4 proc near
.text$x:00002944                                         ; DATA XREF: .xdata$x:0000940Co
.text$x:00002944                 mov     eax, [ebp-18h]
.text$x:00002947                 push    eax             ; void *
.text$x:00002948                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:0000294D                 pop     ecx
.text$x:0000294E                 retn
.text$x:0000294E __unwindfunclet$??0DockingManager@@QAE@XZ$4 endp
.text$x:0000294E
.text$x:0000294F
.text$x:0000294F ; =============== S U B R O U T I N E =======================================
.text$x:0000294F
.text$x:0000294F
.text$x:0000294F __unwindfunclet$??0DockingManager@@QAE@XZ$5 proc near
.text$x:0000294F                                         ; DATA XREF: .xdata$x:00009414o
.text$x:0000294F                 mov     eax, [ebp-20h]
.text$x:00002952                 push    eax             ; void *
.text$x:00002953                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002958                 pop     ecx
.text$x:00002959                 retn
.text$x:00002959 __unwindfunclet$??0DockingManager@@QAE@XZ$5 endp
.text$x:00002959
.text$x:0000295A
.text$x:0000295A ; =============== S U B R O U T I N E =======================================
.text$x:0000295A
.text$x:0000295A
.text$x:0000295A __ehhandler$??0DockingManager@@QAE@XZ proc near
.text$x:0000295A                                         ; DATA XREF: DockingManager::DockingManager(void)+5o
.text$x:0000295A
.text$x:0000295A arg_4           = dword ptr  8
.text$x:0000295A
.text$x:0000295A                 mov     edx, [esp+arg_4]
.text$x:0000295E                 lea     eax, [edx+0Ch]
.text$x:00002961                 mov     ecx, [edx-2Ch]
.text$x:00002964                 xor     ecx, eax
.text$x:00002966                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000296B                 mov     eax, offset __ehfuncinfo$??0DockingManager@@QAE@XZ
.text$x:00002970                 jmp     ___CxxFrameHandler3
.text$x:00002970 __ehhandler$??0DockingManager@@QAE@XZ endp
.text$x:00002970
.text$x:00002975
.text$x:00002975 ; =============== S U B R O U T I N E =======================================
.text$x:00002975
.text$x:00002975
.text$x:00002975 __unwindfunclet$??1DockingManager@@UAE@XZ$0 proc near
.text$x:00002975                                         ; DATA XREF: .xdata$x:000092ACo
.text$x:00002975                 mov     ecx, [ebp-10h]  ; this
.text$x:00002978                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:00002978 __unwindfunclet$??1DockingManager@@UAE@XZ$0 endp
.text$x:00002978
.text$x:0000297D
.text$x:0000297D ; =============== S U B R O U T I N E =======================================
.text$x:0000297D
.text$x:0000297D
.text$x:0000297D __unwindfunclet$??1DockingManager@@UAE@XZ$1 proc near
.text$x:0000297D                                         ; DATA XREF: .xdata$x:000092B4o
.text$x:0000297D                 mov     ecx, [ebp-10h]
.text$x:00002980                 add     ecx, 38h ; '8'
.text$x:00002983                 jmp     ??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::~vector<HWND__ *,std::allocator<HWND__ *>>(void)
.text$x:00002983 __unwindfunclet$??1DockingManager@@UAE@XZ$1 endp
.text$x:00002983
.text$x:00002988
.text$x:00002988 ; =============== S U B R O U T I N E =======================================
.text$x:00002988
.text$x:00002988
.text$x:00002988 __unwindfunclet$??1DockingManager@@UAE@XZ$2 proc near
.text$x:00002988                                         ; DATA XREF: .xdata$x:000092BCo
.text$x:00002988                 mov     ecx, [ebp-10h]
.text$x:0000298B                 add     ecx, 4Ch ; 'L'
.text$x:0000298E                 jmp     ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$x:0000298E __unwindfunclet$??1DockingManager@@UAE@XZ$2 endp
.text$x:0000298E
.text$x:00002993
.text$x:00002993 ; =============== S U B R O U T I N E =======================================
.text$x:00002993
.text$x:00002993
.text$x:00002993 __unwindfunclet$??1DockingManager@@UAE@XZ$3 proc near
.text$x:00002993                                         ; DATA XREF: .xdata$x:000092C4o
.text$x:00002993                 mov     ecx, [ebp-10h]
.text$x:00002996                 add     ecx, 16Ch
.text$x:0000299C                 jmp     ??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::~vector<DockingSplitter *,std::allocator<DockingSplitter *>>(void)
.text$x:0000299C __unwindfunclet$??1DockingManager@@UAE@XZ$3 endp
.text$x:0000299C
.text$x:000029A1
.text$x:000029A1 ; =============== S U B R O U T I N E =======================================
.text$x:000029A1
.text$x:000029A1
.text$x:000029A1 __ehhandler$??1DockingManager@@UAE@XZ proc near
.text$x:000029A1                                         ; DATA XREF: DockingManager::~DockingManager(void)+5o
.text$x:000029A1
.text$x:000029A1 arg_4           = dword ptr  8
.text$x:000029A1
.text$x:000029A1                 mov     edx, [esp+arg_4]
.text$x:000029A5                 lea     eax, [edx+0Ch]
.text$x:000029A8                 mov     ecx, [edx-18h]
.text$x:000029AB                 xor     ecx, eax
.text$x:000029AD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029B2                 mov     eax, offset __ehfuncinfo$??1DockingManager@@UAE@XZ
.text$x:000029B7                 jmp     ___CxxFrameHandler3
.text$x:000029B7 __ehhandler$??1DockingManager@@UAE@XZ endp
.text$x:000029B7
.text$x:000029BC
.text$x:000029BC ; =============== S U B R O U T I N E =======================================
.text$x:000029BC
.text$x:000029BC
.text$x:000029BC __unwindfunclet$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z$0 proc near
.text$x:000029BC                                         ; DATA XREF: .xdata$x:00009294o
.text$x:000029BC                 mov     eax, [ebp-3Ch]
.text$x:000029BF                 push    eax             ; void *
.text$x:000029C0                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000029C5                 pop     ecx
.text$x:000029C6                 retn
.text$x:000029C6 __unwindfunclet$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z$0 endp
.text$x:000029C6
.text$x:000029C7
.text$x:000029C7 ; =============== S U B R O U T I N E =======================================
.text$x:000029C7
.text$x:000029C7
.text$x:000029C7 __unwindfunclet$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z$1 proc near
.text$x:000029C7                                         ; DATA XREF: .xdata$x:0000929Co
.text$x:000029C7                 mov     eax, [ebp-2Ch]
.text$x:000029CA                 push    eax             ; void *
.text$x:000029CB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000029D0                 pop     ecx
.text$x:000029D1                 retn
.text$x:000029D1 __unwindfunclet$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z$1 endp
.text$x:000029D1
.text$x:000029D2
.text$x:000029D2 ; =============== S U B R O U T I N E =======================================
.text$x:000029D2
.text$x:000029D2
.text$x:000029D2 __unwindfunclet$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z$2 proc near
.text$x:000029D2                                         ; DATA XREF: .xdata$x:000092A4o
.text$x:000029D2                 mov     eax, [ebp-30h]
.text$x:000029D5                 push    eax             ; void *
.text$x:000029D6                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:000029DB                 pop     ecx
.text$x:000029DC                 retn
.text$x:000029DC __unwindfunclet$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z$2 endp
.text$x:000029DC
.text$x:000029DD
.text$x:000029DD ; =============== S U B R O U T I N E =======================================
.text$x:000029DD
.text$x:000029DD
.text$x:000029DD __ehhandler$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z proc near
.text$x:000029DD                                         ; DATA XREF: DockingManager::createDockableDlg(tTbData,int,bool)+5o
.text$x:000029DD
.text$x:000029DD arg_4           = dword ptr  8
.text$x:000029DD
.text$x:000029DD                 mov     edx, [esp+arg_4]
.text$x:000029E1                 lea     eax, [edx+0Ch]
.text$x:000029E4                 mov     ecx, [edx-54h]
.text$x:000029E7                 xor     ecx, eax
.text$x:000029E9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029EE                 mov     ecx, [edx-4]
.text$x:000029F1                 xor     ecx, eax
.text$x:000029F3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029F8                 mov     eax, offset __ehfuncinfo$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z
.text$x:000029FD                 jmp     ___CxxFrameHandler3
.text$x:000029FD __ehhandler$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z endp
.text$x:000029FD
.text$x:00002A02
.text$x:00002A02 ; =============== S U B R O U T I N E =======================================
.text$x:00002A02
.text$x:00002A02
.text$x:00002A02 __unwindfunclet$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z$0 proc near
.text$x:00002A02                                         ; DATA XREF: .xdata$x:0000927Co
.text$x:00002A02                 mov     eax, [ebp-58h]
.text$x:00002A05                 push    eax             ; void *
.text$x:00002A06                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002A0B                 pop     ecx
.text$x:00002A0C                 retn
.text$x:00002A0C __unwindfunclet$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z$0 endp
.text$x:00002A0C
.text$x:00002A0D
.text$x:00002A0D ; =============== S U B R O U T I N E =======================================
.text$x:00002A0D
.text$x:00002A0D
.text$x:00002A0D __ehhandler$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z proc near
.text$x:00002A0D                                         ; DATA XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+5o
.text$x:00002A0D
.text$x:00002A0D arg_4           = dword ptr  8
.text$x:00002A0D
.text$x:00002A0D                 mov     edx, [esp+arg_4]
.text$x:00002A11                 lea     eax, [edx+0Ch]
.text$x:00002A14                 mov     ecx, [edx-68h]
.text$x:00002A17                 xor     ecx, eax
.text$x:00002A19                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A1E                 mov     ecx, [edx-4]
.text$x:00002A21                 xor     ecx, eax
.text$x:00002A23                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A28                 mov     eax, offset __ehfuncinfo$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z
.text$x:00002A2D                 jmp     ___CxxFrameHandler3
.text$x:00002A2D __ehhandler$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z endp
.text$x:00002A2D
.text$x:00002A32
.text$x:00002A32 ; =============== S U B R O U T I N E =======================================
.text$x:00002A32
.text$x:00002A32
.text$x:00002A32 __unwindfunclet$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z$0 proc near
.text$x:00002A32                                         ; DATA XREF: .xdata$x:00009284o
.text$x:00002A32                 lea     ecx, [ebp-84h]
.text$x:00002A38                 jmp     ??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ ; std::vector<tTbData *,std::allocator<tTbData *>>::~vector<tTbData *,std::allocator<tTbData *>>(void)
.text$x:00002A38 __unwindfunclet$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z$0 endp
.text$x:00002A38
.text$x:00002A3D
.text$x:00002A3D ; =============== S U B R O U T I N E =======================================
.text$x:00002A3D
.text$x:00002A3D
.text$x:00002A3D __unwindfunclet$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z$1 proc near
.text$x:00002A3D                                         ; DATA XREF: .xdata$x:0000928Co
.text$x:00002A3D                 mov     eax, [ebp-68h]
.text$x:00002A40                 push    eax             ; void *
.text$x:00002A41                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002A46                 pop     ecx
.text$x:00002A47                 retn
.text$x:00002A47 __unwindfunclet$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z$1 endp
.text$x:00002A47
.text$x:00002A48
.text$x:00002A48 ; =============== S U B R O U T I N E =======================================
.text$x:00002A48
.text$x:00002A48
.text$x:00002A48 __ehhandler$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z proc near
.text$x:00002A48                                         ; DATA XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+5o
.text$x:00002A48
.text$x:00002A48 arg_4           = dword ptr  8
.text$x:00002A48
.text$x:00002A48                 mov     edx, [esp+arg_4]
.text$x:00002A4C                 lea     eax, [edx+0Ch]
.text$x:00002A4F                 mov     ecx, [edx-84h]
.text$x:00002A55                 xor     ecx, eax
.text$x:00002A57                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A5C                 mov     ecx, [edx-4]
.text$x:00002A5F                 xor     ecx, eax
.text$x:00002A61                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A66                 mov     eax, offset __ehfuncinfo$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z
.text$x:00002A6B                 jmp     ___CxxFrameHandler3
.text$x:00002A6B __ehhandler$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z endp
.text$x:00002A6B
.text$x:00002A70
.text$x:00002A70 ; =============== S U B R O U T I N E =======================================
.text$x:00002A70
.text$x:00002A70
.text$x:00002A70 __unwindfunclet$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z$0 proc near
.text$x:00002A70                                         ; DATA XREF: .xdata$x:00009274o
.text$x:00002A70                 lea     ecx, [ebp-60h]
.text$x:00002A73                 jmp     ??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ ; std::vector<tTbData *,std::allocator<tTbData *>>::~vector<tTbData *,std::allocator<tTbData *>>(void)
.text$x:00002A73 __unwindfunclet$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z$0 endp
.text$x:00002A73
.text$x:00002A78
.text$x:00002A78 ; =============== S U B R O U T I N E =======================================
.text$x:00002A78
.text$x:00002A78
.text$x:00002A78 __ehhandler$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z proc near
.text$x:00002A78                                         ; DATA XREF: DockingManager::toggleVisTb(DockingCont *,DockingCont *)+5o
.text$x:00002A78
.text$x:00002A78 arg_4           = dword ptr  8
.text$x:00002A78
.text$x:00002A78                 mov     edx, [esp+arg_4]
.text$x:00002A7C                 lea     eax, [edx+0Ch]
.text$x:00002A7F                 mov     ecx, [edx-60h]
.text$x:00002A82                 xor     ecx, eax
.text$x:00002A84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A89                 mov     ecx, [edx-4]
.text$x:00002A8C                 xor     ecx, eax
.text$x:00002A8E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A93                 mov     eax, offset __ehfuncinfo$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z
.text$x:00002A98                 jmp     ___CxxFrameHandler3
.text$x:00002A98 __ehhandler$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z endp
.text$x:00002A98
.text$x:00002A9D
.text$x:00002A9D ; =============== S U B R O U T I N E =======================================
.text$x:00002A9D
.text$x:00002A9D
.text$x:00002A9D __unwindfunclet$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z$0 proc near
.text$x:00002A9D                                         ; DATA XREF: .xdata$x:0000926Co
.text$x:00002A9D                 mov     eax, [ebp-68h]
.text$x:00002AA0                 push    eax             ; void *
.text$x:00002AA1                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00002AA6                 pop     ecx
.text$x:00002AA7                 retn
.text$x:00002AA7 __unwindfunclet$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z$0 endp
.text$x:00002AA7
.text$x:00002AA8
.text$x:00002AA8 ; =============== S U B R O U T I N E =======================================
.text$x:00002AA8
.text$x:00002AA8
.text$x:00002AA8 __ehhandler$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z proc near
.text$x:00002AA8                                         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+5o
.text$x:00002AA8
.text$x:00002AA8 arg_4           = dword ptr  8
.text$x:00002AA8
.text$x:00002AA8                 mov     edx, [esp+arg_4]
.text$x:00002AAC                 lea     eax, [edx+0Ch]
.text$x:00002AAF                 mov     ecx, [edx-90h]
.text$x:00002AB5                 xor     ecx, eax
.text$x:00002AB7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002ABC                 mov     ecx, [edx-4]
.text$x:00002ABF                 xor     ecx, eax
.text$x:00002AC1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AC6                 mov     eax, offset __ehfuncinfo$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z
.text$x:00002ACB                 jmp     ___CxxFrameHandler3
.text$x:00002ACB __ehhandler$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z endp
.text$x:00002ACB
.text$x:00002AD0
.text$x:00002AD0 ; =============== S U B R O U T I N E =======================================
.text$x:00002AD0
.text$x:00002AD0
.text$x:00002AD0 __unwindfunclet$?FindEmptyContainer@DockingManager@@AAEHXZ$0 proc near
.text$x:00002AD0                                         ; DATA XREF: .xdata$x:00009264o
.text$x:00002AD0                 lea     ecx, [ebp-54h]
.text$x:00002AD3                 jmp     ??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ ; std::vector<tTbData *,std::allocator<tTbData *>>::~vector<tTbData *,std::allocator<tTbData *>>(void)
.text$x:00002AD3 __unwindfunclet$?FindEmptyContainer@DockingManager@@AAEHXZ$0 endp
.text$x:00002AD3
.text$x:00002AD8
.text$x:00002AD8 ; =============== S U B R O U T I N E =======================================
.text$x:00002AD8
.text$x:00002AD8
.text$x:00002AD8 __ehhandler$?FindEmptyContainer@DockingManager@@AAEHXZ proc near
.text$x:00002AD8                                         ; DATA XREF: DockingManager::FindEmptyContainer(void)+5o
.text$x:00002AD8
.text$x:00002AD8 arg_4           = dword ptr  8
.text$x:00002AD8
.text$x:00002AD8                 mov     edx, [esp+arg_4]
.text$x:00002ADC                 lea     eax, [edx+0Ch]
.text$x:00002ADF                 mov     ecx, [edx-4Ch]
.text$x:00002AE2                 xor     ecx, eax
.text$x:00002AE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AE9                 mov     eax, offset __ehfuncinfo$?FindEmptyContainer@DockingManager@@AAEHXZ
.text$x:00002AEE                 jmp     ___CxxFrameHandler3
.text$x:00002AEE __ehhandler$?FindEmptyContainer@DockingManager@@AAEHXZ endp
.text$x:00002AEE
.text$x:00002AEE ; ---------------------------------------------------------------------------
.text$x:00002AF3                 align 4
.text$x:00002AF3 _text$x         ends
.text$x:00002AF3
.text$mn:00002AF4 ; ===========================================================================
.text$mn:00002AF4
.text$mn:00002AF4 ; Segment type: Pure code
.text$mn:00002AF4 ; Segment permissions: Read/Execute
.text$mn:00002AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00002AF4                 assume cs:_text$mn
.text$mn:00002AF4                 ;org 2AF4h
.text$mn:00002AF4 ; COMDAT (pick any)
.text$mn:00002AF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AF4
.text$mn:00002AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AF4
.text$mn:00002AF4 ; Attributes: bp-based frame
.text$mn:00002AF4
.text$mn:00002AF4 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00002AF4                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00002AF4 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00002AF4                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00002AF4
.text$mn:00002AF4 var_4           = dword ptr -4
.text$mn:00002AF4 arg_0           = dword ptr  8
.text$mn:00002AF4
.text$mn:00002AF4                 push    ebp
.text$mn:00002AF5                 mov     ebp, esp
.text$mn:00002AF7                 push    ecx
.text$mn:00002AF8                 mov     [ebp+var_4], 0
.text$mn:00002AFF                 cmp     [ebp+arg_0], 0
.text$mn:00002B03                 jnz     short loc_2B07
.text$mn:00002B05                 jmp     short loc_2B27
.text$mn:00002B07 ; ---------------------------------------------------------------------------
.text$mn:00002B07
.text$mn:00002B07 loc_2B07:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00002B07                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00002B0B                 ja      short loc_2B22
.text$mn:00002B0D                 mov     eax, [ebp+arg_0]
.text$mn:00002B10                 push    eax             ; unsigned int
.text$mn:00002B11                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002B16                 add     esp, 4
.text$mn:00002B19                 mov     [ebp+var_4], eax
.text$mn:00002B1C                 cmp     [ebp+var_4], 0
.text$mn:00002B20                 jnz     short loc_2B27
.text$mn:00002B22
.text$mn:00002B22 loc_2B22:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00002B22                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002B27
.text$mn:00002B27 loc_2B27:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00002B27                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00002B27                 mov     eax, [ebp+var_4]
.text$mn:00002B2A                 mov     esp, ebp
.text$mn:00002B2C                 pop     ebp
.text$mn:00002B2D                 retn
.text$mn:00002B2D ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00002B2D
.text$mn:00002B2D ; ---------------------------------------------------------------------------
.text$mn:00002B2E                 align 10h
.text$mn:00002B2E _text$mn        ends
.text$mn:00002B2E
.text$mn:00002B30 ; ===========================================================================
.text$mn:00002B30
.text$mn:00002B30 ; Segment type: Pure code
.text$mn:00002B30 ; Segment permissions: Read/Execute
.text$mn:00002B30 _text$mn        segment para public 'CODE' use32
.text$mn:00002B30                 assume cs:_text$mn
.text$mn:00002B30                 ;org 2B30h
.text$mn:00002B30 ; COMDAT (pick any)
.text$mn:00002B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B30
.text$mn:00002B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B30
.text$mn:00002B30 ; Attributes: bp-based frame
.text$mn:00002B30
.text$mn:00002B30 ; struct HWND__ * * __cdecl std::_Allocate<struct HWND__ *>(unsigned int, struct HWND__ * *)
.text$mn:00002B30                 public ??$_Allocate@PAUHWND__@@@std@@YAPAPAUHWND__@@IPAPAU1@@Z
.text$mn:00002B30 ??$_Allocate@PAUHWND__@@@std@@YAPAPAUHWND__@@IPAPAU1@@Z proc near
.text$mn:00002B30                                         ; CODE XREF: std::allocator<HWND__ *>::allocate(uint)+Dp
.text$mn:00002B30
.text$mn:00002B30 var_4           = dword ptr -4
.text$mn:00002B30 arg_0           = dword ptr  8
.text$mn:00002B30
.text$mn:00002B30                 push    ebp
.text$mn:00002B31                 mov     ebp, esp
.text$mn:00002B33                 push    ecx
.text$mn:00002B34                 mov     [ebp+var_4], 0
.text$mn:00002B3B                 cmp     [ebp+arg_0], 0
.text$mn:00002B3F                 jnz     short loc_2B43
.text$mn:00002B41                 jmp     short loc_2B69
.text$mn:00002B43 ; ---------------------------------------------------------------------------
.text$mn:00002B43
.text$mn:00002B43 loc_2B43:                               ; CODE XREF: std::_Allocate<HWND__ *>(uint,HWND__ * *)+Fj
.text$mn:00002B43                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00002B4A                 ja      short loc_2B64
.text$mn:00002B4C                 mov     eax, [ebp+arg_0]
.text$mn:00002B4F                 shl     eax, 2
.text$mn:00002B52                 push    eax             ; unsigned int
.text$mn:00002B53                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002B58                 add     esp, 4
.text$mn:00002B5B                 mov     [ebp+var_4], eax
.text$mn:00002B5E                 cmp     [ebp+var_4], 0
.text$mn:00002B62                 jnz     short loc_2B69
.text$mn:00002B64
.text$mn:00002B64 loc_2B64:                               ; CODE XREF: std::_Allocate<HWND__ *>(uint,HWND__ * *)+1Aj
.text$mn:00002B64                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002B69
.text$mn:00002B69 loc_2B69:                               ; CODE XREF: std::_Allocate<HWND__ *>(uint,HWND__ * *)+11j
.text$mn:00002B69                                         ; std::_Allocate<HWND__ *>(uint,HWND__ * *)+32j
.text$mn:00002B69                 mov     eax, [ebp+var_4]
.text$mn:00002B6C                 mov     esp, ebp
.text$mn:00002B6E                 pop     ebp
.text$mn:00002B6F                 retn
.text$mn:00002B6F ??$_Allocate@PAUHWND__@@@std@@YAPAPAUHWND__@@IPAPAU1@@Z endp
.text$mn:00002B6F
.text$mn:00002B6F _text$mn        ends
.text$mn:00002B6F
.text$mn:00002B70 ; ===========================================================================
.text$mn:00002B70
.text$mn:00002B70 ; Segment type: Pure code
.text$mn:00002B70 ; Segment permissions: Read/Execute
.text$mn:00002B70 _text$mn        segment para public 'CODE' use32
.text$mn:00002B70                 assume cs:_text$mn
.text$mn:00002B70                 ;org 2B70h
.text$mn:00002B70 ; COMDAT (pick any)
.text$mn:00002B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B70
.text$mn:00002B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B70
.text$mn:00002B70 ; Attributes: bp-based frame
.text$mn:00002B70
.text$mn:00002B70 ; struct tTbData * * __cdecl std::_Allocate<struct tTbData *>(unsigned int, struct tTbData * *)
.text$mn:00002B70                 public ??$_Allocate@PAUtTbData@@@std@@YAPAPAUtTbData@@IPAPAU1@@Z
.text$mn:00002B70 ??$_Allocate@PAUtTbData@@@std@@YAPAPAUtTbData@@IPAPAU1@@Z proc near
.text$mn:00002B70                                         ; CODE XREF: std::allocator<tTbData *>::allocate(uint)+Dp
.text$mn:00002B70
.text$mn:00002B70 var_4           = dword ptr -4
.text$mn:00002B70 arg_0           = dword ptr  8
.text$mn:00002B70
.text$mn:00002B70                 push    ebp
.text$mn:00002B71                 mov     ebp, esp
.text$mn:00002B73                 push    ecx
.text$mn:00002B74                 mov     [ebp+var_4], 0
.text$mn:00002B7B                 cmp     [ebp+arg_0], 0
.text$mn:00002B7F                 jnz     short loc_2B83
.text$mn:00002B81                 jmp     short loc_2BA9
.text$mn:00002B83 ; ---------------------------------------------------------------------------
.text$mn:00002B83
.text$mn:00002B83 loc_2B83:                               ; CODE XREF: std::_Allocate<tTbData *>(uint,tTbData * *)+Fj
.text$mn:00002B83                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00002B8A                 ja      short loc_2BA4
.text$mn:00002B8C                 mov     eax, [ebp+arg_0]
.text$mn:00002B8F                 shl     eax, 2
.text$mn:00002B92                 push    eax             ; unsigned int
.text$mn:00002B93                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002B98                 add     esp, 4
.text$mn:00002B9B                 mov     [ebp+var_4], eax
.text$mn:00002B9E                 cmp     [ebp+var_4], 0
.text$mn:00002BA2                 jnz     short loc_2BA9
.text$mn:00002BA4
.text$mn:00002BA4 loc_2BA4:                               ; CODE XREF: std::_Allocate<tTbData *>(uint,tTbData * *)+1Aj
.text$mn:00002BA4                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002BA9
.text$mn:00002BA9 loc_2BA9:                               ; CODE XREF: std::_Allocate<tTbData *>(uint,tTbData * *)+11j
.text$mn:00002BA9                                         ; std::_Allocate<tTbData *>(uint,tTbData * *)+32j
.text$mn:00002BA9                 mov     eax, [ebp+var_4]
.text$mn:00002BAC                 mov     esp, ebp
.text$mn:00002BAE                 pop     ebp
.text$mn:00002BAF                 retn
.text$mn:00002BAF ??$_Allocate@PAUtTbData@@@std@@YAPAPAUtTbData@@IPAPAU1@@Z endp
.text$mn:00002BAF
.text$mn:00002BAF _text$mn        ends
.text$mn:00002BAF
.text$mn:00002BB0 ; ===========================================================================
.text$mn:00002BB0
.text$mn:00002BB0 ; Segment type: Pure code
.text$mn:00002BB0 ; Segment permissions: Read/Execute
.text$mn:00002BB0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BB0                 assume cs:_text$mn
.text$mn:00002BB0                 ;org 2BB0h
.text$mn:00002BB0 ; COMDAT (pick any)
.text$mn:00002BB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BB0
.text$mn:00002BB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BB0
.text$mn:00002BB0 ; Attributes: bp-based frame
.text$mn:00002BB0
.text$mn:00002BB0 ; class DockingCont * * __cdecl std::_Allocate<class DockingCont *>(unsigned int, class DockingCont * *)
.text$mn:00002BB0                 public ??$_Allocate@PAVDockingCont@@@std@@YAPAPAVDockingCont@@IPAPAV1@@Z
.text$mn:00002BB0 ??$_Allocate@PAVDockingCont@@@std@@YAPAPAVDockingCont@@IPAPAV1@@Z proc near
.text$mn:00002BB0                                         ; CODE XREF: std::allocator<DockingCont *>::allocate(uint)+Dp
.text$mn:00002BB0
.text$mn:00002BB0 var_4           = dword ptr -4
.text$mn:00002BB0 arg_0           = dword ptr  8
.text$mn:00002BB0
.text$mn:00002BB0                 push    ebp
.text$mn:00002BB1                 mov     ebp, esp
.text$mn:00002BB3                 push    ecx
.text$mn:00002BB4                 mov     [ebp+var_4], 0
.text$mn:00002BBB                 cmp     [ebp+arg_0], 0
.text$mn:00002BBF                 jnz     short loc_2BC3
.text$mn:00002BC1                 jmp     short loc_2BE9
.text$mn:00002BC3 ; ---------------------------------------------------------------------------
.text$mn:00002BC3
.text$mn:00002BC3 loc_2BC3:                               ; CODE XREF: std::_Allocate<DockingCont *>(uint,DockingCont * *)+Fj
.text$mn:00002BC3                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00002BCA                 ja      short loc_2BE4
.text$mn:00002BCC                 mov     eax, [ebp+arg_0]
.text$mn:00002BCF                 shl     eax, 2
.text$mn:00002BD2                 push    eax             ; unsigned int
.text$mn:00002BD3                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002BD8                 add     esp, 4
.text$mn:00002BDB                 mov     [ebp+var_4], eax
.text$mn:00002BDE                 cmp     [ebp+var_4], 0
.text$mn:00002BE2                 jnz     short loc_2BE9
.text$mn:00002BE4
.text$mn:00002BE4 loc_2BE4:                               ; CODE XREF: std::_Allocate<DockingCont *>(uint,DockingCont * *)+1Aj
.text$mn:00002BE4                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002BE9
.text$mn:00002BE9 loc_2BE9:                               ; CODE XREF: std::_Allocate<DockingCont *>(uint,DockingCont * *)+11j
.text$mn:00002BE9                                         ; std::_Allocate<DockingCont *>(uint,DockingCont * *)+32j
.text$mn:00002BE9                 mov     eax, [ebp+var_4]
.text$mn:00002BEC                 mov     esp, ebp
.text$mn:00002BEE                 pop     ebp
.text$mn:00002BEF                 retn
.text$mn:00002BEF ??$_Allocate@PAVDockingCont@@@std@@YAPAPAVDockingCont@@IPAPAV1@@Z endp
.text$mn:00002BEF
.text$mn:00002BEF _text$mn        ends
.text$mn:00002BEF
.text$mn:00002BF0 ; ===========================================================================
.text$mn:00002BF0
.text$mn:00002BF0 ; Segment type: Pure code
.text$mn:00002BF0 ; Segment permissions: Read/Execute
.text$mn:00002BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BF0                 assume cs:_text$mn
.text$mn:00002BF0                 ;org 2BF0h
.text$mn:00002BF0 ; COMDAT (pick any)
.text$mn:00002BF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BF0
.text$mn:00002BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BF0
.text$mn:00002BF0 ; Attributes: bp-based frame
.text$mn:00002BF0
.text$mn:00002BF0 ; class DockingSplitter * * __cdecl std::_Allocate<class DockingSplitter *>(unsigned int, class DockingSplitter * *)
.text$mn:00002BF0                 public ??$_Allocate@PAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@IPAPAV1@@Z
.text$mn:00002BF0 ??$_Allocate@PAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@IPAPAV1@@Z proc near
.text$mn:00002BF0                                         ; CODE XREF: std::allocator<DockingSplitter *>::allocate(uint)+Dp
.text$mn:00002BF0
.text$mn:00002BF0 var_4           = dword ptr -4
.text$mn:00002BF0 arg_0           = dword ptr  8
.text$mn:00002BF0
.text$mn:00002BF0                 push    ebp
.text$mn:00002BF1                 mov     ebp, esp
.text$mn:00002BF3                 push    ecx
.text$mn:00002BF4                 mov     [ebp+var_4], 0
.text$mn:00002BFB                 cmp     [ebp+arg_0], 0
.text$mn:00002BFF                 jnz     short loc_2C03
.text$mn:00002C01                 jmp     short loc_2C29
.text$mn:00002C03 ; ---------------------------------------------------------------------------
.text$mn:00002C03
.text$mn:00002C03 loc_2C03:                               ; CODE XREF: std::_Allocate<DockingSplitter *>(uint,DockingSplitter * *)+Fj
.text$mn:00002C03                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00002C0A                 ja      short loc_2C24
.text$mn:00002C0C                 mov     eax, [ebp+arg_0]
.text$mn:00002C0F                 shl     eax, 2
.text$mn:00002C12                 push    eax             ; unsigned int
.text$mn:00002C13                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002C18                 add     esp, 4
.text$mn:00002C1B                 mov     [ebp+var_4], eax
.text$mn:00002C1E                 cmp     [ebp+var_4], 0
.text$mn:00002C22                 jnz     short loc_2C29
.text$mn:00002C24
.text$mn:00002C24 loc_2C24:                               ; CODE XREF: std::_Allocate<DockingSplitter *>(uint,DockingSplitter * *)+1Aj
.text$mn:00002C24                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002C29
.text$mn:00002C29 loc_2C29:                               ; CODE XREF: std::_Allocate<DockingSplitter *>(uint,DockingSplitter * *)+11j
.text$mn:00002C29                                         ; std::_Allocate<DockingSplitter *>(uint,DockingSplitter * *)+32j
.text$mn:00002C29                 mov     eax, [ebp+var_4]
.text$mn:00002C2C                 mov     esp, ebp
.text$mn:00002C2E                 pop     ebp
.text$mn:00002C2F                 retn
.text$mn:00002C2F ??$_Allocate@PAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@IPAPAV1@@Z endp
.text$mn:00002C2F
.text$mn:00002C2F _text$mn        ends
.text$mn:00002C2F
.text$mn:00002C30 ; ===========================================================================
.text$mn:00002C30
.text$mn:00002C30 ; Segment type: Pure code
.text$mn:00002C30 ; Segment permissions: Read/Execute
.text$mn:00002C30 _text$mn        segment para public 'CODE' use32
.text$mn:00002C30                 assume cs:_text$mn
.text$mn:00002C30                 ;org 2C30h
.text$mn:00002C30 ; COMDAT (pick any)
.text$mn:00002C30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C30
.text$mn:00002C30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C30
.text$mn:00002C30 ; Attributes: bp-based frame
.text$mn:00002C30
.text$mn:00002C30 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00002C30                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00002C30 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00002C30                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00002C30
.text$mn:00002C30 var_4           = dword ptr -4
.text$mn:00002C30 arg_0           = dword ptr  8
.text$mn:00002C30
.text$mn:00002C30                 push    ebp
.text$mn:00002C31                 mov     ebp, esp
.text$mn:00002C33                 push    ecx
.text$mn:00002C34                 mov     [ebp+var_4], 0
.text$mn:00002C3B                 cmp     [ebp+arg_0], 0
.text$mn:00002C3F                 jnz     short loc_2C43
.text$mn:00002C41                 jmp     short loc_2C69
.text$mn:00002C43 ; ---------------------------------------------------------------------------
.text$mn:00002C43
.text$mn:00002C43 loc_2C43:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00002C43                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00002C4A                 ja      short loc_2C64
.text$mn:00002C4C                 mov     eax, [ebp+arg_0]
.text$mn:00002C4F                 shl     eax, 3
.text$mn:00002C52                 push    eax             ; unsigned int
.text$mn:00002C53                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002C58                 add     esp, 4
.text$mn:00002C5B                 mov     [ebp+var_4], eax
.text$mn:00002C5E                 cmp     [ebp+var_4], 0
.text$mn:00002C62                 jnz     short loc_2C69
.text$mn:00002C64
.text$mn:00002C64 loc_2C64:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00002C64                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002C69
.text$mn:00002C69 loc_2C69:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00002C69                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00002C69                 mov     eax, [ebp+var_4]
.text$mn:00002C6C                 mov     esp, ebp
.text$mn:00002C6E                 pop     ebp
.text$mn:00002C6F                 retn
.text$mn:00002C6F ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00002C6F
.text$mn:00002C6F _text$mn        ends
.text$mn:00002C6F
.text$mn:00002C70 ; ===========================================================================
.text$mn:00002C70
.text$mn:00002C70 ; Segment type: Pure code
.text$mn:00002C70 ; Segment permissions: Read/Execute
.text$mn:00002C70 _text$mn        segment para public 'CODE' use32
.text$mn:00002C70                 assume cs:_text$mn
.text$mn:00002C70                 ;org 2C70h
.text$mn:00002C70 ; COMDAT (pick any)
.text$mn:00002C70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C70
.text$mn:00002C70 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C70
.text$mn:00002C70 ; Attributes: bp-based frame
.text$mn:00002C70
.text$mn:00002C70 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00002C70                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00002C70 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00002C70                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00002C70                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00002C70
.text$mn:00002C70 arg_0           = dword ptr  8
.text$mn:00002C70 arg_4           = dword ptr  0Ch
.text$mn:00002C70 arg_8           = dword ptr  10h
.text$mn:00002C70
.text$mn:00002C70                 push    ebp
.text$mn:00002C71                 mov     ebp, esp
.text$mn:00002C73                 cmp     [ebp+arg_0], 0
.text$mn:00002C77                 jnz     short loc_2C8E
.text$mn:00002C79                 mov     eax, [ebp+arg_8]
.text$mn:00002C7C                 push    eax             ; unsigned int
.text$mn:00002C7D                 mov     ecx, [ebp+arg_4]
.text$mn:00002C80                 push    ecx             ; wchar_t *
.text$mn:00002C81                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002C86                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002C8B                 add     esp, 0Ch
.text$mn:00002C8E
.text$mn:00002C8E loc_2C8E:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00002C8E                 pop     ebp
.text$mn:00002C8F                 retn
.text$mn:00002C8F ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00002C8F
.text$mn:00002C8F _text$mn        ends
.text$mn:00002C8F
.text$mn:00002C90 ; ===========================================================================
.text$mn:00002C90
.text$mn:00002C90 ; Segment type: Pure code
.text$mn:00002C90 ; Segment permissions: Read/Execute
.text$mn:00002C90 _text$mn        segment para public 'CODE' use32
.text$mn:00002C90                 assume cs:_text$mn
.text$mn:00002C90                 ;org 2C90h
.text$mn:00002C90 ; COMDAT (pick any)
.text$mn:00002C90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C90
.text$mn:00002C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C90
.text$mn:00002C90 ; Attributes: bp-based frame
.text$mn:00002C90
.text$mn:00002C90 ; int __cdecl std::_Debug_pointer<HWND__ *>(int, wchar_t *, unsigned int)
.text$mn:00002C90                 public ??$_Debug_pointer@PAUHWND__@@@std@@YAXPAPAUHWND__@@PB_WI@Z
.text$mn:00002C90 ??$_Debug_pointer@PAUHWND__@@@std@@YAXPAPAUHWND__@@PB_WI@Z proc near
.text$mn:00002C90                                         ; CODE XREF: std::_Debug_range2<HWND__ * *>(HWND__ * *,HWND__ * *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00002C90                                         ; std::_Debug_range2<HWND__ * *>(HWND__ * *,HWND__ * *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00002C90
.text$mn:00002C90 arg_0           = dword ptr  8
.text$mn:00002C90 arg_4           = dword ptr  0Ch
.text$mn:00002C90 arg_8           = dword ptr  10h
.text$mn:00002C90
.text$mn:00002C90                 push    ebp
.text$mn:00002C91                 mov     ebp, esp
.text$mn:00002C93                 cmp     [ebp+arg_0], 0
.text$mn:00002C97                 jnz     short loc_2CAE
.text$mn:00002C99                 mov     eax, [ebp+arg_8]
.text$mn:00002C9C                 push    eax             ; unsigned int
.text$mn:00002C9D                 mov     ecx, [ebp+arg_4]
.text$mn:00002CA0                 push    ecx             ; wchar_t *
.text$mn:00002CA1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002CA6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002CAB                 add     esp, 0Ch
.text$mn:00002CAE
.text$mn:00002CAE loc_2CAE:                               ; CODE XREF: std::_Debug_pointer<HWND__ *>(HWND__ * *,wchar_t const *,uint)+7j
.text$mn:00002CAE                 pop     ebp
.text$mn:00002CAF                 retn
.text$mn:00002CAF ??$_Debug_pointer@PAUHWND__@@@std@@YAXPAPAUHWND__@@PB_WI@Z endp
.text$mn:00002CAF
.text$mn:00002CAF _text$mn        ends
.text$mn:00002CAF
.text$mn:00002CB0 ; ===========================================================================
.text$mn:00002CB0
.text$mn:00002CB0 ; Segment type: Pure code
.text$mn:00002CB0 ; Segment permissions: Read/Execute
.text$mn:00002CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CB0                 assume cs:_text$mn
.text$mn:00002CB0                 ;org 2CB0h
.text$mn:00002CB0 ; COMDAT (pick any)
.text$mn:00002CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CB0
.text$mn:00002CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CB0
.text$mn:00002CB0 ; Attributes: bp-based frame
.text$mn:00002CB0
.text$mn:00002CB0 ; int __cdecl std::_Debug_pointer<tTbData *>(int, wchar_t *, unsigned int)
.text$mn:00002CB0                 public ??$_Debug_pointer@PAUtTbData@@@std@@YAXPAPAUtTbData@@PB_WI@Z
.text$mn:00002CB0 ??$_Debug_pointer@PAUtTbData@@@std@@YAXPAPAUtTbData@@PB_WI@Z proc near
.text$mn:00002CB0                                         ; CODE XREF: std::_Uninit_copy<tTbData * const,tTbData *>(tTbData * const *,tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &,std::_Scalar_ptr_iterator_tag)+2Cp
.text$mn:00002CB0
.text$mn:00002CB0 arg_0           = dword ptr  8
.text$mn:00002CB0 arg_4           = dword ptr  0Ch
.text$mn:00002CB0 arg_8           = dword ptr  10h
.text$mn:00002CB0
.text$mn:00002CB0                 push    ebp
.text$mn:00002CB1                 mov     ebp, esp
.text$mn:00002CB3                 cmp     [ebp+arg_0], 0
.text$mn:00002CB7                 jnz     short loc_2CCE
.text$mn:00002CB9                 mov     eax, [ebp+arg_8]
.text$mn:00002CBC                 push    eax             ; unsigned int
.text$mn:00002CBD                 mov     ecx, [ebp+arg_4]
.text$mn:00002CC0                 push    ecx             ; wchar_t *
.text$mn:00002CC1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002CC6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002CCB                 add     esp, 0Ch
.text$mn:00002CCE
.text$mn:00002CCE loc_2CCE:                               ; CODE XREF: std::_Debug_pointer<tTbData *>(tTbData * *,wchar_t const *,uint)+7j
.text$mn:00002CCE                 pop     ebp
.text$mn:00002CCF                 retn
.text$mn:00002CCF ??$_Debug_pointer@PAUtTbData@@@std@@YAXPAPAUtTbData@@PB_WI@Z endp
.text$mn:00002CCF
.text$mn:00002CCF _text$mn        ends
.text$mn:00002CCF
.text$mn:00002CD0 ; ===========================================================================
.text$mn:00002CD0
.text$mn:00002CD0 ; Segment type: Pure code
.text$mn:00002CD0 ; Segment permissions: Read/Execute
.text$mn:00002CD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CD0                 assume cs:_text$mn
.text$mn:00002CD0                 ;org 2CD0h
.text$mn:00002CD0 ; COMDAT (pick any)
.text$mn:00002CD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CD0
.text$mn:00002CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CD0
.text$mn:00002CD0 ; Attributes: bp-based frame
.text$mn:00002CD0
.text$mn:00002CD0 ; int __cdecl std::_Debug_pointer<tTbData *>(int, wchar_t *, unsigned int)
.text$mn:00002CD0                 public ??$_Debug_pointer@PAUtTbData@@@std@@YAXPBQAUtTbData@@PB_WI@Z
.text$mn:00002CD0 ??$_Debug_pointer@PAUtTbData@@@std@@YAXPBQAUtTbData@@PB_WI@Z proc near
.text$mn:00002CD0                                         ; CODE XREF: std::_Debug_range2<tTbData * const *>(tTbData * const *,tTbData * const *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00002CD0                                         ; std::_Debug_range2<tTbData * const *>(tTbData * const *,tTbData * const *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp
.text$mn:00002CD0
.text$mn:00002CD0 arg_0           = dword ptr  8
.text$mn:00002CD0 arg_4           = dword ptr  0Ch
.text$mn:00002CD0 arg_8           = dword ptr  10h
.text$mn:00002CD0
.text$mn:00002CD0                 push    ebp
.text$mn:00002CD1                 mov     ebp, esp
.text$mn:00002CD3                 cmp     [ebp+arg_0], 0
.text$mn:00002CD7                 jnz     short loc_2CEE
.text$mn:00002CD9                 mov     eax, [ebp+arg_8]
.text$mn:00002CDC                 push    eax             ; unsigned int
.text$mn:00002CDD                 mov     ecx, [ebp+arg_4]
.text$mn:00002CE0                 push    ecx             ; wchar_t *
.text$mn:00002CE1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002CE6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002CEB                 add     esp, 0Ch
.text$mn:00002CEE
.text$mn:00002CEE loc_2CEE:                               ; CODE XREF: std::_Debug_pointer<tTbData *>(tTbData * const *,wchar_t const *,uint)+7j
.text$mn:00002CEE                 pop     ebp
.text$mn:00002CEF                 retn
.text$mn:00002CEF ??$_Debug_pointer@PAUtTbData@@@std@@YAXPBQAUtTbData@@PB_WI@Z endp
.text$mn:00002CEF
.text$mn:00002CEF _text$mn        ends
.text$mn:00002CEF
.text$mn:00002CF0 ; ===========================================================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Segment type: Pure code
.text$mn:00002CF0 ; Segment permissions: Read/Execute
.text$mn:00002CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CF0                 assume cs:_text$mn
.text$mn:00002CF0                 ;org 2CF0h
.text$mn:00002CF0 ; COMDAT (pick any)
.text$mn:00002CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CF0
.text$mn:00002CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Attributes: bp-based frame
.text$mn:00002CF0
.text$mn:00002CF0 ; int __cdecl std::_Debug_pointer<DockingCont *>(int, wchar_t *, unsigned int)
.text$mn:00002CF0                 public ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPAPAVDockingCont@@PB_WI@Z
.text$mn:00002CF0 ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPAPAVDockingCont@@PB_WI@Z proc near
.text$mn:00002CF0                                         ; CODE XREF: std::_Debug_range2<DockingCont * *>(DockingCont * *,DockingCont * *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00002CF0                                         ; std::_Debug_range2<DockingCont * *>(DockingCont * *,DockingCont * *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00002CF0
.text$mn:00002CF0 arg_0           = dword ptr  8
.text$mn:00002CF0 arg_4           = dword ptr  0Ch
.text$mn:00002CF0 arg_8           = dword ptr  10h
.text$mn:00002CF0
.text$mn:00002CF0                 push    ebp
.text$mn:00002CF1                 mov     ebp, esp
.text$mn:00002CF3                 cmp     [ebp+arg_0], 0
.text$mn:00002CF7                 jnz     short loc_2D0E
.text$mn:00002CF9                 mov     eax, [ebp+arg_8]
.text$mn:00002CFC                 push    eax             ; unsigned int
.text$mn:00002CFD                 mov     ecx, [ebp+arg_4]
.text$mn:00002D00                 push    ecx             ; wchar_t *
.text$mn:00002D01                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002D06                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002D0B                 add     esp, 0Ch
.text$mn:00002D0E
.text$mn:00002D0E loc_2D0E:                               ; CODE XREF: std::_Debug_pointer<DockingCont *>(DockingCont * *,wchar_t const *,uint)+7j
.text$mn:00002D0E                 pop     ebp
.text$mn:00002D0F                 retn
.text$mn:00002D0F ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPAPAVDockingCont@@PB_WI@Z endp
.text$mn:00002D0F
.text$mn:00002D0F _text$mn        ends
.text$mn:00002D0F
.text$mn:00002D10 ; ===========================================================================
.text$mn:00002D10
.text$mn:00002D10 ; Segment type: Pure code
.text$mn:00002D10 ; Segment permissions: Read/Execute
.text$mn:00002D10 _text$mn        segment para public 'CODE' use32
.text$mn:00002D10                 assume cs:_text$mn
.text$mn:00002D10                 ;org 2D10h
.text$mn:00002D10 ; COMDAT (pick any)
.text$mn:00002D10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D10
.text$mn:00002D10 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D10
.text$mn:00002D10 ; Attributes: bp-based frame
.text$mn:00002D10
.text$mn:00002D10 ; int __cdecl std::_Debug_pointer<DockingSplitter *>(int, wchar_t *, unsigned int)
.text$mn:00002D10                 public ??$_Debug_pointer@PAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@PB_WI@Z
.text$mn:00002D10 ??$_Debug_pointer@PAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@PB_WI@Z proc near
.text$mn:00002D10                                         ; CODE XREF: std::_Debug_range2<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00002D10                                         ; std::_Debug_range2<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00002D10
.text$mn:00002D10 arg_0           = dword ptr  8
.text$mn:00002D10 arg_4           = dword ptr  0Ch
.text$mn:00002D10 arg_8           = dword ptr  10h
.text$mn:00002D10
.text$mn:00002D10                 push    ebp
.text$mn:00002D11                 mov     ebp, esp
.text$mn:00002D13                 cmp     [ebp+arg_0], 0
.text$mn:00002D17                 jnz     short loc_2D2E
.text$mn:00002D19                 mov     eax, [ebp+arg_8]
.text$mn:00002D1C                 push    eax             ; unsigned int
.text$mn:00002D1D                 mov     ecx, [ebp+arg_4]
.text$mn:00002D20                 push    ecx             ; wchar_t *
.text$mn:00002D21                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002D26                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002D2B                 add     esp, 0Ch
.text$mn:00002D2E
.text$mn:00002D2E loc_2D2E:                               ; CODE XREF: std::_Debug_pointer<DockingSplitter *>(DockingSplitter * *,wchar_t const *,uint)+7j
.text$mn:00002D2E                 pop     ebp
.text$mn:00002D2F                 retn
.text$mn:00002D2F ??$_Debug_pointer@PAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@PB_WI@Z endp
.text$mn:00002D2F
.text$mn:00002D2F _text$mn        ends
.text$mn:00002D2F
.text$mn:00002D30 ; ===========================================================================
.text$mn:00002D30
.text$mn:00002D30 ; Segment type: Pure code
.text$mn:00002D30 ; Segment permissions: Read/Execute
.text$mn:00002D30 _text$mn        segment para public 'CODE' use32
.text$mn:00002D30                 assume cs:_text$mn
.text$mn:00002D30                 ;org 2D30h
.text$mn:00002D30 ; COMDAT (pick any)
.text$mn:00002D30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D30
.text$mn:00002D30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D30
.text$mn:00002D30 ; Attributes: bp-based frame
.text$mn:00002D30
.text$mn:00002D30 ; int __cdecl std::_Debug_range2<HWND__ * *>(int, int, wchar_t *, unsigned int)
.text$mn:00002D30                 public ??$_Debug_range2@PAPAUHWND__@@@std@@YAXPAPAUHWND__@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002D30 ??$_Debug_range2@PAPAUHWND__@@@std@@YAXPAPAUHWND__@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002D30                                         ; CODE XREF: std::_Debug_range<HWND__ * *>(HWND__ * *,HWND__ * *,wchar_t const *,uint)+2Ap
.text$mn:00002D30
.text$mn:00002D30 arg_0           = dword ptr  8
.text$mn:00002D30 arg_4           = dword ptr  0Ch
.text$mn:00002D30 arg_8           = dword ptr  10h
.text$mn:00002D30 arg_C           = dword ptr  14h
.text$mn:00002D30
.text$mn:00002D30                 push    ebp
.text$mn:00002D31                 mov     ebp, esp
.text$mn:00002D33                 mov     eax, [ebp+arg_0]
.text$mn:00002D36                 cmp     eax, [ebp+arg_4]
.text$mn:00002D39                 jz      short loc_2D80
.text$mn:00002D3B                 mov     ecx, [ebp+arg_C]
.text$mn:00002D3E                 push    ecx             ; unsigned int
.text$mn:00002D3F                 mov     edx, [ebp+arg_8]
.text$mn:00002D42                 push    edx             ; wchar_t *
.text$mn:00002D43                 mov     eax, [ebp+arg_0]
.text$mn:00002D46                 push    eax             ; int
.text$mn:00002D47                 call    ??$_Debug_pointer@PAUHWND__@@@std@@YAXPAPAUHWND__@@PB_WI@Z ; std::_Debug_pointer<HWND__ *>(HWND__ * *,wchar_t const *,uint)
.text$mn:00002D4C                 add     esp, 0Ch
.text$mn:00002D4F                 mov     ecx, [ebp+arg_C]
.text$mn:00002D52                 push    ecx             ; unsigned int
.text$mn:00002D53                 mov     edx, [ebp+arg_8]
.text$mn:00002D56                 push    edx             ; wchar_t *
.text$mn:00002D57                 mov     eax, [ebp+arg_4]
.text$mn:00002D5A                 push    eax             ; int
.text$mn:00002D5B                 call    ??$_Debug_pointer@PAUHWND__@@@std@@YAXPAPAUHWND__@@PB_WI@Z ; std::_Debug_pointer<HWND__ *>(HWND__ * *,wchar_t const *,uint)
.text$mn:00002D60                 add     esp, 0Ch
.text$mn:00002D63                 mov     ecx, [ebp+arg_4]
.text$mn:00002D66                 cmp     ecx, [ebp+arg_0]
.text$mn:00002D69                 jnb     short loc_2D80
.text$mn:00002D6B                 mov     edx, [ebp+arg_C]
.text$mn:00002D6E                 push    edx             ; unsigned int
.text$mn:00002D6F                 mov     eax, [ebp+arg_8]
.text$mn:00002D72                 push    eax             ; wchar_t *
.text$mn:00002D73                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002D78                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002D7D                 add     esp, 0Ch
.text$mn:00002D80
.text$mn:00002D80 loc_2D80:                               ; CODE XREF: std::_Debug_range2<HWND__ * *>(HWND__ * *,HWND__ * *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002D80                                         ; std::_Debug_range2<HWND__ * *>(HWND__ * *,HWND__ * *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002D80                 pop     ebp
.text$mn:00002D81                 retn
.text$mn:00002D81 ??$_Debug_range2@PAPAUHWND__@@@std@@YAXPAPAUHWND__@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002D81
.text$mn:00002D81 ; ---------------------------------------------------------------------------
.text$mn:00002D82                 align 4
.text$mn:00002D82 _text$mn        ends
.text$mn:00002D82
.text$mn:00002D84 ; ===========================================================================
.text$mn:00002D84
.text$mn:00002D84 ; Segment type: Pure code
.text$mn:00002D84 ; Segment permissions: Read/Execute
.text$mn:00002D84 _text$mn        segment para public 'CODE' use32
.text$mn:00002D84                 assume cs:_text$mn
.text$mn:00002D84                 ;org 2D84h
.text$mn:00002D84 ; COMDAT (pick any)
.text$mn:00002D84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D84
.text$mn:00002D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D84
.text$mn:00002D84 ; Attributes: bp-based frame
.text$mn:00002D84
.text$mn:00002D84 ; int __cdecl std::_Debug_range2<DockingCont * *>(int, int, wchar_t *, unsigned int)
.text$mn:00002D84                 public ??$_Debug_range2@PAPAVDockingCont@@@std@@YAXPAPAVDockingCont@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002D84 ??$_Debug_range2@PAPAVDockingCont@@@std@@YAXPAPAVDockingCont@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002D84                                         ; CODE XREF: std::_Debug_range<DockingCont * *>(DockingCont * *,DockingCont * *,wchar_t const *,uint)+2Ap
.text$mn:00002D84
.text$mn:00002D84 arg_0           = dword ptr  8
.text$mn:00002D84 arg_4           = dword ptr  0Ch
.text$mn:00002D84 arg_8           = dword ptr  10h
.text$mn:00002D84 arg_C           = dword ptr  14h
.text$mn:00002D84
.text$mn:00002D84                 push    ebp
.text$mn:00002D85                 mov     ebp, esp
.text$mn:00002D87                 mov     eax, [ebp+arg_0]
.text$mn:00002D8A                 cmp     eax, [ebp+arg_4]
.text$mn:00002D8D                 jz      short loc_2DD4
.text$mn:00002D8F                 mov     ecx, [ebp+arg_C]
.text$mn:00002D92                 push    ecx             ; unsigned int
.text$mn:00002D93                 mov     edx, [ebp+arg_8]
.text$mn:00002D96                 push    edx             ; wchar_t *
.text$mn:00002D97                 mov     eax, [ebp+arg_0]
.text$mn:00002D9A                 push    eax             ; int
.text$mn:00002D9B                 call    ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPAPAVDockingCont@@PB_WI@Z ; std::_Debug_pointer<DockingCont *>(DockingCont * *,wchar_t const *,uint)
.text$mn:00002DA0                 add     esp, 0Ch
.text$mn:00002DA3                 mov     ecx, [ebp+arg_C]
.text$mn:00002DA6                 push    ecx             ; unsigned int
.text$mn:00002DA7                 mov     edx, [ebp+arg_8]
.text$mn:00002DAA                 push    edx             ; wchar_t *
.text$mn:00002DAB                 mov     eax, [ebp+arg_4]
.text$mn:00002DAE                 push    eax             ; int
.text$mn:00002DAF                 call    ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPAPAVDockingCont@@PB_WI@Z ; std::_Debug_pointer<DockingCont *>(DockingCont * *,wchar_t const *,uint)
.text$mn:00002DB4                 add     esp, 0Ch
.text$mn:00002DB7                 mov     ecx, [ebp+arg_4]
.text$mn:00002DBA                 cmp     ecx, [ebp+arg_0]
.text$mn:00002DBD                 jnb     short loc_2DD4
.text$mn:00002DBF                 mov     edx, [ebp+arg_C]
.text$mn:00002DC2                 push    edx             ; unsigned int
.text$mn:00002DC3                 mov     eax, [ebp+arg_8]
.text$mn:00002DC6                 push    eax             ; wchar_t *
.text$mn:00002DC7                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002DCC                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002DD1                 add     esp, 0Ch
.text$mn:00002DD4
.text$mn:00002DD4 loc_2DD4:                               ; CODE XREF: std::_Debug_range2<DockingCont * *>(DockingCont * *,DockingCont * *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002DD4                                         ; std::_Debug_range2<DockingCont * *>(DockingCont * *,DockingCont * *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002DD4                 pop     ebp
.text$mn:00002DD5                 retn
.text$mn:00002DD5 ??$_Debug_range2@PAPAVDockingCont@@@std@@YAXPAPAVDockingCont@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002DD5
.text$mn:00002DD5 ; ---------------------------------------------------------------------------
.text$mn:00002DD6                 align 4
.text$mn:00002DD6 _text$mn        ends
.text$mn:00002DD6
.text$mn:00002DD8 ; ===========================================================================
.text$mn:00002DD8
.text$mn:00002DD8 ; Segment type: Pure code
.text$mn:00002DD8 ; Segment permissions: Read/Execute
.text$mn:00002DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00002DD8                 assume cs:_text$mn
.text$mn:00002DD8                 ;org 2DD8h
.text$mn:00002DD8 ; COMDAT (pick any)
.text$mn:00002DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DD8
.text$mn:00002DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DD8
.text$mn:00002DD8 ; Attributes: bp-based frame
.text$mn:00002DD8
.text$mn:00002DD8 ; int __cdecl std::_Debug_range2<DockingSplitter * *>(int, int, wchar_t *, unsigned int)
.text$mn:00002DD8                 public ??$_Debug_range2@PAPAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002DD8 ??$_Debug_range2@PAPAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002DD8                                         ; CODE XREF: std::_Debug_range<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,wchar_t const *,uint)+2Ap
.text$mn:00002DD8
.text$mn:00002DD8 arg_0           = dword ptr  8
.text$mn:00002DD8 arg_4           = dword ptr  0Ch
.text$mn:00002DD8 arg_8           = dword ptr  10h
.text$mn:00002DD8 arg_C           = dword ptr  14h
.text$mn:00002DD8
.text$mn:00002DD8                 push    ebp
.text$mn:00002DD9                 mov     ebp, esp
.text$mn:00002DDB                 mov     eax, [ebp+arg_0]
.text$mn:00002DDE                 cmp     eax, [ebp+arg_4]
.text$mn:00002DE1                 jz      short loc_2E28
.text$mn:00002DE3                 mov     ecx, [ebp+arg_C]
.text$mn:00002DE6                 push    ecx             ; unsigned int
.text$mn:00002DE7                 mov     edx, [ebp+arg_8]
.text$mn:00002DEA                 push    edx             ; wchar_t *
.text$mn:00002DEB                 mov     eax, [ebp+arg_0]
.text$mn:00002DEE                 push    eax             ; int
.text$mn:00002DEF                 call    ??$_Debug_pointer@PAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@PB_WI@Z ; std::_Debug_pointer<DockingSplitter *>(DockingSplitter * *,wchar_t const *,uint)
.text$mn:00002DF4                 add     esp, 0Ch
.text$mn:00002DF7                 mov     ecx, [ebp+arg_C]
.text$mn:00002DFA                 push    ecx             ; unsigned int
.text$mn:00002DFB                 mov     edx, [ebp+arg_8]
.text$mn:00002DFE                 push    edx             ; wchar_t *
.text$mn:00002DFF                 mov     eax, [ebp+arg_4]
.text$mn:00002E02                 push    eax             ; int
.text$mn:00002E03                 call    ??$_Debug_pointer@PAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@PB_WI@Z ; std::_Debug_pointer<DockingSplitter *>(DockingSplitter * *,wchar_t const *,uint)
.text$mn:00002E08                 add     esp, 0Ch
.text$mn:00002E0B                 mov     ecx, [ebp+arg_4]
.text$mn:00002E0E                 cmp     ecx, [ebp+arg_0]
.text$mn:00002E11                 jnb     short loc_2E28
.text$mn:00002E13                 mov     edx, [ebp+arg_C]
.text$mn:00002E16                 push    edx             ; unsigned int
.text$mn:00002E17                 mov     eax, [ebp+arg_8]
.text$mn:00002E1A                 push    eax             ; wchar_t *
.text$mn:00002E1B                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002E20                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002E25                 add     esp, 0Ch
.text$mn:00002E28
.text$mn:00002E28 loc_2E28:                               ; CODE XREF: std::_Debug_range2<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002E28                                         ; std::_Debug_range2<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002E28                 pop     ebp
.text$mn:00002E29                 retn
.text$mn:00002E29 ??$_Debug_range2@PAPAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002E29
.text$mn:00002E29 ; ---------------------------------------------------------------------------
.text$mn:00002E2A                 align 4
.text$mn:00002E2A _text$mn        ends
.text$mn:00002E2A
.text$mn:00002E2C ; ===========================================================================
.text$mn:00002E2C
.text$mn:00002E2C ; Segment type: Pure code
.text$mn:00002E2C ; Segment permissions: Read/Execute
.text$mn:00002E2C _text$mn        segment para public 'CODE' use32
.text$mn:00002E2C                 assume cs:_text$mn
.text$mn:00002E2C                 ;org 2E2Ch
.text$mn:00002E2C ; COMDAT (pick any)
.text$mn:00002E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E2C
.text$mn:00002E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00002E2C
.text$mn:00002E2C ; Attributes: bp-based frame
.text$mn:00002E2C
.text$mn:00002E2C ; int __cdecl std::_Debug_range2<tTbData * const *>(int, int, wchar_t *, unsigned int)
.text$mn:00002E2C                 public ??$_Debug_range2@PBQAUtTbData@@@std@@YAXPBQAUtTbData@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002E2C ??$_Debug_range2@PBQAUtTbData@@@std@@YAXPBQAUtTbData@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002E2C                                         ; CODE XREF: std::_Debug_range<tTbData * const *>(tTbData * const *,tTbData * const *,wchar_t const *,uint)+2Ap
.text$mn:00002E2C
.text$mn:00002E2C arg_0           = dword ptr  8
.text$mn:00002E2C arg_4           = dword ptr  0Ch
.text$mn:00002E2C arg_8           = dword ptr  10h
.text$mn:00002E2C arg_C           = dword ptr  14h
.text$mn:00002E2C
.text$mn:00002E2C                 push    ebp
.text$mn:00002E2D                 mov     ebp, esp
.text$mn:00002E2F                 mov     eax, [ebp+arg_0]
.text$mn:00002E32                 cmp     eax, [ebp+arg_4]
.text$mn:00002E35                 jz      short loc_2E7C
.text$mn:00002E37                 mov     ecx, [ebp+arg_C]
.text$mn:00002E3A                 push    ecx             ; unsigned int
.text$mn:00002E3B                 mov     edx, [ebp+arg_8]
.text$mn:00002E3E                 push    edx             ; wchar_t *
.text$mn:00002E3F                 mov     eax, [ebp+arg_0]
.text$mn:00002E42                 push    eax             ; int
.text$mn:00002E43                 call    ??$_Debug_pointer@PAUtTbData@@@std@@YAXPBQAUtTbData@@PB_WI@Z ; std::_Debug_pointer<tTbData *>(tTbData * const *,wchar_t const *,uint)
.text$mn:00002E48                 add     esp, 0Ch
.text$mn:00002E4B                 mov     ecx, [ebp+arg_C]
.text$mn:00002E4E                 push    ecx             ; unsigned int
.text$mn:00002E4F                 mov     edx, [ebp+arg_8]
.text$mn:00002E52                 push    edx             ; wchar_t *
.text$mn:00002E53                 mov     eax, [ebp+arg_4]
.text$mn:00002E56                 push    eax             ; int
.text$mn:00002E57                 call    ??$_Debug_pointer@PAUtTbData@@@std@@YAXPBQAUtTbData@@PB_WI@Z ; std::_Debug_pointer<tTbData *>(tTbData * const *,wchar_t const *,uint)
.text$mn:00002E5C                 add     esp, 0Ch
.text$mn:00002E5F                 mov     ecx, [ebp+arg_4]
.text$mn:00002E62                 cmp     ecx, [ebp+arg_0]
.text$mn:00002E65                 jnb     short loc_2E7C
.text$mn:00002E67                 mov     edx, [ebp+arg_C]
.text$mn:00002E6A                 push    edx             ; unsigned int
.text$mn:00002E6B                 mov     eax, [ebp+arg_8]
.text$mn:00002E6E                 push    eax             ; wchar_t *
.text$mn:00002E6F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002E74                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002E79                 add     esp, 0Ch
.text$mn:00002E7C
.text$mn:00002E7C loc_2E7C:                               ; CODE XREF: std::_Debug_range2<tTbData * const *>(tTbData * const *,tTbData * const *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002E7C                                         ; std::_Debug_range2<tTbData * const *>(tTbData * const *,tTbData * const *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002E7C                 pop     ebp
.text$mn:00002E7D                 retn
.text$mn:00002E7D ??$_Debug_range2@PBQAUtTbData@@@std@@YAXPBQAUtTbData@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002E7D
.text$mn:00002E7D ; ---------------------------------------------------------------------------
.text$mn:00002E7E                 align 10h
.text$mn:00002E7E _text$mn        ends
.text$mn:00002E7E
.text$mn:00002E80 ; ===========================================================================
.text$mn:00002E80
.text$mn:00002E80 ; Segment type: Pure code
.text$mn:00002E80 ; Segment permissions: Read/Execute
.text$mn:00002E80 _text$mn        segment para public 'CODE' use32
.text$mn:00002E80                 assume cs:_text$mn
.text$mn:00002E80                 ;org 2E80h
.text$mn:00002E80 ; COMDAT (pick any)
.text$mn:00002E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E80
.text$mn:00002E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E80
.text$mn:00002E80 ; Attributes: bp-based frame
.text$mn:00002E80
.text$mn:00002E80 ; int __cdecl std::_Debug_range<HWND__ * *>(int, int, wchar_t *, unsigned int)
.text$mn:00002E80                 public ??$_Debug_range@PAPAUHWND__@@@std@@YAXPAPAUHWND__@@0PB_WI@Z
.text$mn:00002E80 ??$_Debug_range@PAPAUHWND__@@@std@@YAXPAPAUHWND__@@0PB_WI@Z proc near
.text$mn:00002E80                                         ; CODE XREF: std::_Uninit_move<HWND__ *,HWND__ *,HWND__ *>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &,HWND__ * *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00002E80
.text$mn:00002E80 var_1           = byte ptr -1
.text$mn:00002E80 arg_0           = dword ptr  8
.text$mn:00002E80 arg_4           = dword ptr  0Ch
.text$mn:00002E80 arg_8           = dword ptr  10h
.text$mn:00002E80 arg_C           = dword ptr  14h
.text$mn:00002E80
.text$mn:00002E80                 push    ebp
.text$mn:00002E81                 mov     ebp, esp
.text$mn:00002E83                 push    ecx
.text$mn:00002E84                 lea     eax, [ebp+arg_0]
.text$mn:00002E87                 push    eax
.text$mn:00002E88                 lea     ecx, [ebp+var_1]
.text$mn:00002E8B                 push    ecx
.text$mn:00002E8C                 call    ??$_Iter_cat@PAPAUHWND__@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUHWND__@@@Z ; std::_Iter_cat<HWND__ * *>(HWND__ * * const &)
.text$mn:00002E91                 add     esp, 8
.text$mn:00002E94                 mov     dl, [eax]
.text$mn:00002E96                 movzx   eax, dl
.text$mn:00002E99                 push    eax
.text$mn:00002E9A                 mov     ecx, [ebp+arg_C]
.text$mn:00002E9D                 push    ecx             ; unsigned int
.text$mn:00002E9E                 mov     edx, [ebp+arg_8]
.text$mn:00002EA1                 push    edx             ; wchar_t *
.text$mn:00002EA2                 mov     eax, [ebp+arg_4]
.text$mn:00002EA5                 push    eax             ; int
.text$mn:00002EA6                 mov     ecx, [ebp+arg_0]
.text$mn:00002EA9                 push    ecx             ; int
.text$mn:00002EAA                 call    ??$_Debug_range2@PAPAUHWND__@@@std@@YAXPAPAUHWND__@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<HWND__ * *>(HWND__ * *,HWND__ * *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002EAF                 add     esp, 14h
.text$mn:00002EB2                 mov     esp, ebp
.text$mn:00002EB4                 pop     ebp
.text$mn:00002EB5                 retn
.text$mn:00002EB5 ??$_Debug_range@PAPAUHWND__@@@std@@YAXPAPAUHWND__@@0PB_WI@Z endp
.text$mn:00002EB5
.text$mn:00002EB5 ; ---------------------------------------------------------------------------
.text$mn:00002EB6                 align 4
.text$mn:00002EB6 _text$mn        ends
.text$mn:00002EB6
.text$mn:00002EB8 ; ===========================================================================
.text$mn:00002EB8
.text$mn:00002EB8 ; Segment type: Pure code
.text$mn:00002EB8 ; Segment permissions: Read/Execute
.text$mn:00002EB8 _text$mn        segment para public 'CODE' use32
.text$mn:00002EB8                 assume cs:_text$mn
.text$mn:00002EB8                 ;org 2EB8h
.text$mn:00002EB8 ; COMDAT (pick any)
.text$mn:00002EB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EB8
.text$mn:00002EB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EB8
.text$mn:00002EB8 ; Attributes: bp-based frame
.text$mn:00002EB8
.text$mn:00002EB8 ; int __cdecl std::_Debug_range<DockingCont * *>(int, int, wchar_t *, unsigned int)
.text$mn:00002EB8                 public ??$_Debug_range@PAPAVDockingCont@@@std@@YAXPAPAVDockingCont@@0PB_WI@Z
.text$mn:00002EB8 ??$_Debug_range@PAPAVDockingCont@@@std@@YAXPAPAVDockingCont@@0PB_WI@Z proc near
.text$mn:00002EB8                                         ; CODE XREF: std::_Uninit_move<DockingCont *,DockingCont *,DockingCont *>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &,DockingCont * *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00002EB8
.text$mn:00002EB8 var_1           = byte ptr -1
.text$mn:00002EB8 arg_0           = dword ptr  8
.text$mn:00002EB8 arg_4           = dword ptr  0Ch
.text$mn:00002EB8 arg_8           = dword ptr  10h
.text$mn:00002EB8 arg_C           = dword ptr  14h
.text$mn:00002EB8
.text$mn:00002EB8                 push    ebp
.text$mn:00002EB9                 mov     ebp, esp
.text$mn:00002EBB                 push    ecx
.text$mn:00002EBC                 lea     eax, [ebp+arg_0]
.text$mn:00002EBF                 push    eax
.text$mn:00002EC0                 lea     ecx, [ebp+var_1]
.text$mn:00002EC3                 push    ecx
.text$mn:00002EC4                 call    ??$_Iter_cat@PAPAVDockingCont@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVDockingCont@@@Z ; std::_Iter_cat<DockingCont * *>(DockingCont * * const &)
.text$mn:00002EC9                 add     esp, 8
.text$mn:00002ECC                 mov     dl, [eax]
.text$mn:00002ECE                 movzx   eax, dl
.text$mn:00002ED1                 push    eax
.text$mn:00002ED2                 mov     ecx, [ebp+arg_C]
.text$mn:00002ED5                 push    ecx             ; unsigned int
.text$mn:00002ED6                 mov     edx, [ebp+arg_8]
.text$mn:00002ED9                 push    edx             ; wchar_t *
.text$mn:00002EDA                 mov     eax, [ebp+arg_4]
.text$mn:00002EDD                 push    eax             ; int
.text$mn:00002EDE                 mov     ecx, [ebp+arg_0]
.text$mn:00002EE1                 push    ecx             ; int
.text$mn:00002EE2                 call    ??$_Debug_range2@PAPAVDockingCont@@@std@@YAXPAPAVDockingCont@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<DockingCont * *>(DockingCont * *,DockingCont * *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002EE7                 add     esp, 14h
.text$mn:00002EEA                 mov     esp, ebp
.text$mn:00002EEC                 pop     ebp
.text$mn:00002EED                 retn
.text$mn:00002EED ??$_Debug_range@PAPAVDockingCont@@@std@@YAXPAPAVDockingCont@@0PB_WI@Z endp
.text$mn:00002EED
.text$mn:00002EED ; ---------------------------------------------------------------------------
.text$mn:00002EEE                 align 10h
.text$mn:00002EEE _text$mn        ends
.text$mn:00002EEE
.text$mn:00002EF0 ; ===========================================================================
.text$mn:00002EF0
.text$mn:00002EF0 ; Segment type: Pure code
.text$mn:00002EF0 ; Segment permissions: Read/Execute
.text$mn:00002EF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002EF0                 assume cs:_text$mn
.text$mn:00002EF0                 ;org 2EF0h
.text$mn:00002EF0 ; COMDAT (pick any)
.text$mn:00002EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EF0
.text$mn:00002EF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EF0
.text$mn:00002EF0 ; Attributes: bp-based frame
.text$mn:00002EF0
.text$mn:00002EF0 ; int __cdecl std::_Debug_range<DockingSplitter * *>(int, int, wchar_t *, unsigned int)
.text$mn:00002EF0                 public ??$_Debug_range@PAPAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@0PB_WI@Z
.text$mn:00002EF0 ??$_Debug_range@PAPAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@0PB_WI@Z proc near
.text$mn:00002EF0                                         ; CODE XREF: std::_Uninit_move<DockingSplitter *,DockingSplitter *,DockingSplitter *>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &,DockingSplitter * *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00002EF0
.text$mn:00002EF0 var_1           = byte ptr -1
.text$mn:00002EF0 arg_0           = dword ptr  8
.text$mn:00002EF0 arg_4           = dword ptr  0Ch
.text$mn:00002EF0 arg_8           = dword ptr  10h
.text$mn:00002EF0 arg_C           = dword ptr  14h
.text$mn:00002EF0
.text$mn:00002EF0                 push    ebp
.text$mn:00002EF1                 mov     ebp, esp
.text$mn:00002EF3                 push    ecx
.text$mn:00002EF4                 lea     eax, [ebp+arg_0]
.text$mn:00002EF7                 push    eax
.text$mn:00002EF8                 lea     ecx, [ebp+var_1]
.text$mn:00002EFB                 push    ecx
.text$mn:00002EFC                 call    ??$_Iter_cat@PAPAVDockingSplitter@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVDockingSplitter@@@Z ; std::_Iter_cat<DockingSplitter * *>(DockingSplitter * * const &)
.text$mn:00002F01                 add     esp, 8
.text$mn:00002F04                 mov     dl, [eax]
.text$mn:00002F06                 movzx   eax, dl
.text$mn:00002F09                 push    eax
.text$mn:00002F0A                 mov     ecx, [ebp+arg_C]
.text$mn:00002F0D                 push    ecx             ; unsigned int
.text$mn:00002F0E                 mov     edx, [ebp+arg_8]
.text$mn:00002F11                 push    edx             ; wchar_t *
.text$mn:00002F12                 mov     eax, [ebp+arg_4]
.text$mn:00002F15                 push    eax             ; int
.text$mn:00002F16                 mov     ecx, [ebp+arg_0]
.text$mn:00002F19                 push    ecx             ; int
.text$mn:00002F1A                 call    ??$_Debug_range2@PAPAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002F1F                 add     esp, 14h
.text$mn:00002F22                 mov     esp, ebp
.text$mn:00002F24                 pop     ebp
.text$mn:00002F25                 retn
.text$mn:00002F25 ??$_Debug_range@PAPAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@0PB_WI@Z endp
.text$mn:00002F25
.text$mn:00002F25 ; ---------------------------------------------------------------------------
.text$mn:00002F26                 align 4
.text$mn:00002F26 _text$mn        ends
.text$mn:00002F26
.text$mn:00002F28 ; ===========================================================================
.text$mn:00002F28
.text$mn:00002F28 ; Segment type: Pure code
.text$mn:00002F28 ; Segment permissions: Read/Execute
.text$mn:00002F28 _text$mn        segment para public 'CODE' use32
.text$mn:00002F28                 assume cs:_text$mn
.text$mn:00002F28                 ;org 2F28h
.text$mn:00002F28 ; COMDAT (pick any)
.text$mn:00002F28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F28
.text$mn:00002F28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F28
.text$mn:00002F28 ; Attributes: bp-based frame
.text$mn:00002F28
.text$mn:00002F28 ; int __cdecl std::_Debug_range<tTbData * const *>(int, int, wchar_t *, unsigned int)
.text$mn:00002F28                 public ??$_Debug_range@PBQAUtTbData@@@std@@YAXPBQAUtTbData@@0PB_WI@Z
.text$mn:00002F28 ??$_Debug_range@PBQAUtTbData@@@std@@YAXPBQAUtTbData@@0PB_WI@Z proc near
.text$mn:00002F28                                         ; CODE XREF: std::_Uninit_copy<tTbData * const,tTbData *>(tTbData * const *,tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00002F28
.text$mn:00002F28 var_1           = byte ptr -1
.text$mn:00002F28 arg_0           = dword ptr  8
.text$mn:00002F28 arg_4           = dword ptr  0Ch
.text$mn:00002F28 arg_8           = dword ptr  10h
.text$mn:00002F28 arg_C           = dword ptr  14h
.text$mn:00002F28
.text$mn:00002F28                 push    ebp
.text$mn:00002F29                 mov     ebp, esp
.text$mn:00002F2B                 push    ecx
.text$mn:00002F2C                 lea     eax, [ebp+arg_0]
.text$mn:00002F2F                 push    eax
.text$mn:00002F30                 lea     ecx, [ebp+var_1]
.text$mn:00002F33                 push    ecx
.text$mn:00002F34                 call    ??$_Iter_cat@PBQAUtTbData@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBQAUtTbData@@@Z ; std::_Iter_cat<tTbData * const *>(tTbData * const * const &)
.text$mn:00002F39                 add     esp, 8
.text$mn:00002F3C                 mov     dl, [eax]
.text$mn:00002F3E                 movzx   eax, dl
.text$mn:00002F41                 push    eax
.text$mn:00002F42                 mov     ecx, [ebp+arg_C]
.text$mn:00002F45                 push    ecx             ; unsigned int
.text$mn:00002F46                 mov     edx, [ebp+arg_8]
.text$mn:00002F49                 push    edx             ; wchar_t *
.text$mn:00002F4A                 mov     eax, [ebp+arg_4]
.text$mn:00002F4D                 push    eax             ; int
.text$mn:00002F4E                 mov     ecx, [ebp+arg_0]
.text$mn:00002F51                 push    ecx             ; int
.text$mn:00002F52                 call    ??$_Debug_range2@PBQAUtTbData@@@std@@YAXPBQAUtTbData@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<tTbData * const *>(tTbData * const *,tTbData * const *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002F57                 add     esp, 14h
.text$mn:00002F5A                 mov     esp, ebp
.text$mn:00002F5C                 pop     ebp
.text$mn:00002F5D                 retn
.text$mn:00002F5D ??$_Debug_range@PBQAUtTbData@@@std@@YAXPBQAUtTbData@@0PB_WI@Z endp
.text$mn:00002F5D
.text$mn:00002F5D ; ---------------------------------------------------------------------------
.text$mn:00002F5E                 align 10h
.text$mn:00002F5E _text$mn        ends
.text$mn:00002F5E
.text$mn:00002F60 ; ===========================================================================
.text$mn:00002F60
.text$mn:00002F60 ; Segment type: Pure code
.text$mn:00002F60 ; Segment permissions: Read/Execute
.text$mn:00002F60 _text$mn        segment para public 'CODE' use32
.text$mn:00002F60                 assume cs:_text$mn
.text$mn:00002F60                 ;org 2F60h
.text$mn:00002F60 ; COMDAT (pick any)
.text$mn:00002F60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F60
.text$mn:00002F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F60
.text$mn:00002F60 ; Attributes: bp-based frame
.text$mn:00002F60
.text$mn:00002F60 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct HWND__ *>>>(struct HWND__ * *, struct HWND__ * *, struct std::_Wrap_alloc<class std::allocator<struct HWND__ *>> &)
.text$mn:00002F60                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAXPAPAUHWND__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z
.text$mn:00002F60 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAXPAPAUHWND__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z proc near
.text$mn:00002F60                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Destroy(HWND__ * *,HWND__ * *)+21p
.text$mn:00002F60
.text$mn:00002F60 var_1           = byte ptr -1
.text$mn:00002F60 arg_0           = dword ptr  8
.text$mn:00002F60 arg_4           = dword ptr  0Ch
.text$mn:00002F60 arg_8           = dword ptr  10h
.text$mn:00002F60
.text$mn:00002F60                 push    ebp
.text$mn:00002F61                 mov     ebp, esp
.text$mn:00002F63                 push    ecx
.text$mn:00002F64                 mov     eax, [ebp+arg_4]
.text$mn:00002F67                 push    eax
.text$mn:00002F68                 mov     ecx, [ebp+arg_0]
.text$mn:00002F6B                 push    ecx
.text$mn:00002F6C                 call    ??$_Ptr_cat@PAUHWND__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHWND__@@0@Z ; std::_Ptr_cat<HWND__ *,HWND__ *>(HWND__ * *,HWND__ * *)
.text$mn:00002F71                 add     esp, 8
.text$mn:00002F74                 mov     [ebp+var_1], al
.text$mn:00002F77                 movzx   edx, [ebp+var_1]
.text$mn:00002F7B                 push    edx
.text$mn:00002F7C                 mov     eax, [ebp+arg_8]
.text$mn:00002F7F                 push    eax
.text$mn:00002F80                 mov     ecx, [ebp+arg_4]
.text$mn:00002F83                 push    ecx
.text$mn:00002F84                 mov     edx, [ebp+arg_0]
.text$mn:00002F87                 push    edx
.text$mn:00002F88                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAXPAPAUHWND__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00002F8D                 add     esp, 10h
.text$mn:00002F90                 mov     esp, ebp
.text$mn:00002F92                 pop     ebp
.text$mn:00002F93                 retn
.text$mn:00002F93 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAXPAPAUHWND__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z endp
.text$mn:00002F93
.text$mn:00002F93 _text$mn        ends
.text$mn:00002F93
.text$mn:00002F94 ; ===========================================================================
.text$mn:00002F94
.text$mn:00002F94 ; Segment type: Pure code
.text$mn:00002F94 ; Segment permissions: Read/Execute
.text$mn:00002F94 _text$mn        segment para public 'CODE' use32
.text$mn:00002F94                 assume cs:_text$mn
.text$mn:00002F94                 ;org 2F94h
.text$mn:00002F94 ; COMDAT (pick any)
.text$mn:00002F94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F94
.text$mn:00002F94 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F94
.text$mn:00002F94 ; Attributes: bp-based frame
.text$mn:00002F94
.text$mn:00002F94 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct HWND__ *>>>(struct HWND__ * *, struct HWND__ * *, struct std::_Wrap_alloc<class std::allocator<struct HWND__ *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00002F94                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAXPAPAUHWND__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002F94 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAXPAPAUHWND__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002F94                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)+28p
.text$mn:00002F94                 push    ebp
.text$mn:00002F95                 mov     ebp, esp
.text$mn:00002F97                 pop     ebp
.text$mn:00002F98                 retn
.text$mn:00002F98 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAXPAPAUHWND__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002F98
.text$mn:00002F98 ; ---------------------------------------------------------------------------
.text$mn:00002F99                 align 4
.text$mn:00002F99 _text$mn        ends
.text$mn:00002F99
.text$mn:00002F9C ; ===========================================================================
.text$mn:00002F9C
.text$mn:00002F9C ; Segment type: Pure code
.text$mn:00002F9C ; Segment permissions: Read/Execute
.text$mn:00002F9C _text$mn        segment para public 'CODE' use32
.text$mn:00002F9C                 assume cs:_text$mn
.text$mn:00002F9C                 ;org 2F9Ch
.text$mn:00002F9C ; COMDAT (pick any)
.text$mn:00002F9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F9C
.text$mn:00002F9C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F9C
.text$mn:00002F9C ; Attributes: bp-based frame
.text$mn:00002F9C
.text$mn:00002F9C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct tTbData *>>>(struct tTbData * *, struct tTbData * *, struct std::_Wrap_alloc<class std::allocator<struct tTbData *>> &)
.text$mn:00002F9C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAXPAPAUtTbData@@0AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z
.text$mn:00002F9C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAXPAPAUtTbData@@0AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z proc near
.text$mn:00002F9C                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Destroy(tTbData * *,tTbData * *)+21p
.text$mn:00002F9C
.text$mn:00002F9C var_1           = byte ptr -1
.text$mn:00002F9C arg_0           = dword ptr  8
.text$mn:00002F9C arg_4           = dword ptr  0Ch
.text$mn:00002F9C arg_8           = dword ptr  10h
.text$mn:00002F9C
.text$mn:00002F9C                 push    ebp
.text$mn:00002F9D                 mov     ebp, esp
.text$mn:00002F9F                 push    ecx
.text$mn:00002FA0                 mov     eax, [ebp+arg_4]
.text$mn:00002FA3                 push    eax
.text$mn:00002FA4                 mov     ecx, [ebp+arg_0]
.text$mn:00002FA7                 push    ecx
.text$mn:00002FA8                 call    ??$_Ptr_cat@PAUtTbData@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtTbData@@0@Z ; std::_Ptr_cat<tTbData *,tTbData *>(tTbData * *,tTbData * *)
.text$mn:00002FAD                 add     esp, 8
.text$mn:00002FB0                 mov     [ebp+var_1], al
.text$mn:00002FB3                 movzx   edx, [ebp+var_1]
.text$mn:00002FB7                 push    edx
.text$mn:00002FB8                 mov     eax, [ebp+arg_8]
.text$mn:00002FBB                 push    eax
.text$mn:00002FBC                 mov     ecx, [ebp+arg_4]
.text$mn:00002FBF                 push    ecx
.text$mn:00002FC0                 mov     edx, [ebp+arg_0]
.text$mn:00002FC3                 push    edx
.text$mn:00002FC4                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAXPAPAUtTbData@@0AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<tTbData *>>>(tTbData * *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00002FC9                 add     esp, 10h
.text$mn:00002FCC                 mov     esp, ebp
.text$mn:00002FCE                 pop     ebp
.text$mn:00002FCF                 retn
.text$mn:00002FCF ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAXPAPAUtTbData@@0AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z endp
.text$mn:00002FCF
.text$mn:00002FCF _text$mn        ends
.text$mn:00002FCF
.text$mn:00002FD0 ; ===========================================================================
.text$mn:00002FD0
.text$mn:00002FD0 ; Segment type: Pure code
.text$mn:00002FD0 ; Segment permissions: Read/Execute
.text$mn:00002FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002FD0                 assume cs:_text$mn
.text$mn:00002FD0                 ;org 2FD0h
.text$mn:00002FD0 ; COMDAT (pick any)
.text$mn:00002FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FD0
.text$mn:00002FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FD0
.text$mn:00002FD0 ; Attributes: bp-based frame
.text$mn:00002FD0
.text$mn:00002FD0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct tTbData *>>>(struct tTbData * *, struct tTbData * *, struct std::_Wrap_alloc<class std::allocator<struct tTbData *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00002FD0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAXPAPAUtTbData@@0AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002FD0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAXPAPAUtTbData@@0AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002FD0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<tTbData *>>>(tTbData * *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)+28p
.text$mn:00002FD0                 push    ebp
.text$mn:00002FD1                 mov     ebp, esp
.text$mn:00002FD3                 pop     ebp
.text$mn:00002FD4                 retn
.text$mn:00002FD4 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAXPAPAUtTbData@@0AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002FD4
.text$mn:00002FD4 ; ---------------------------------------------------------------------------
.text$mn:00002FD5                 align 4
.text$mn:00002FD5 _text$mn        ends
.text$mn:00002FD5
.text$mn:00002FD8 ; ===========================================================================
.text$mn:00002FD8
.text$mn:00002FD8 ; Segment type: Pure code
.text$mn:00002FD8 ; Segment permissions: Read/Execute
.text$mn:00002FD8 _text$mn        segment para public 'CODE' use32
.text$mn:00002FD8                 assume cs:_text$mn
.text$mn:00002FD8                 ;org 2FD8h
.text$mn:00002FD8 ; COMDAT (pick any)
.text$mn:00002FD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FD8
.text$mn:00002FD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FD8
.text$mn:00002FD8 ; Attributes: bp-based frame
.text$mn:00002FD8
.text$mn:00002FD8 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class DockingCont *>>>(class DockingCont * *, class DockingCont * *, struct std::_Wrap_alloc<class std::allocator<class DockingCont *>> &)
.text$mn:00002FD8                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z
.text$mn:00002FD8 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z proc near
.text$mn:00002FD8                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Destroy(DockingCont * *,DockingCont * *)+21p
.text$mn:00002FD8
.text$mn:00002FD8 var_1           = byte ptr -1
.text$mn:00002FD8 arg_0           = dword ptr  8
.text$mn:00002FD8 arg_4           = dword ptr  0Ch
.text$mn:00002FD8 arg_8           = dword ptr  10h
.text$mn:00002FD8
.text$mn:00002FD8                 push    ebp
.text$mn:00002FD9                 mov     ebp, esp
.text$mn:00002FDB                 push    ecx
.text$mn:00002FDC                 mov     eax, [ebp+arg_4]
.text$mn:00002FDF                 push    eax
.text$mn:00002FE0                 mov     ecx, [ebp+arg_0]
.text$mn:00002FE3                 push    ecx
.text$mn:00002FE4                 call    ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingCont@@0@Z ; std::_Ptr_cat<DockingCont *,DockingCont *>(DockingCont * *,DockingCont * *)
.text$mn:00002FE9                 add     esp, 8
.text$mn:00002FEC                 mov     [ebp+var_1], al
.text$mn:00002FEF                 movzx   edx, [ebp+var_1]
.text$mn:00002FF3                 push    edx
.text$mn:00002FF4                 mov     eax, [ebp+arg_8]
.text$mn:00002FF7                 push    eax
.text$mn:00002FF8                 mov     ecx, [ebp+arg_4]
.text$mn:00002FFB                 push    ecx
.text$mn:00002FFC                 mov     edx, [ebp+arg_0]
.text$mn:00002FFF                 push    edx
.text$mn:00003000                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00003005                 add     esp, 10h
.text$mn:00003008                 mov     esp, ebp
.text$mn:0000300A                 pop     ebp
.text$mn:0000300B                 retn
.text$mn:0000300B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z endp
.text$mn:0000300B
.text$mn:0000300B _text$mn        ends
.text$mn:0000300B
.text$mn:0000300C ; ===========================================================================
.text$mn:0000300C
.text$mn:0000300C ; Segment type: Pure code
.text$mn:0000300C ; Segment permissions: Read/Execute
.text$mn:0000300C _text$mn        segment para public 'CODE' use32
.text$mn:0000300C                 assume cs:_text$mn
.text$mn:0000300C                 ;org 300Ch
.text$mn:0000300C ; COMDAT (pick any)
.text$mn:0000300C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000300C
.text$mn:0000300C ; =============== S U B R O U T I N E =======================================
.text$mn:0000300C
.text$mn:0000300C ; Attributes: bp-based frame
.text$mn:0000300C
.text$mn:0000300C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class DockingCont *>>>(class DockingCont * *, class DockingCont * *, struct std::_Wrap_alloc<class std::allocator<class DockingCont *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:0000300C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:0000300C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000300C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+28p
.text$mn:0000300C                 push    ebp
.text$mn:0000300D                 mov     ebp, esp
.text$mn:0000300F                 pop     ebp
.text$mn:00003010                 retn
.text$mn:00003010 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003010
.text$mn:00003010 ; ---------------------------------------------------------------------------
.text$mn:00003011                 align 4
.text$mn:00003011 _text$mn        ends
.text$mn:00003011
.text$mn:00003014 ; ===========================================================================
.text$mn:00003014
.text$mn:00003014 ; Segment type: Pure code
.text$mn:00003014 ; Segment permissions: Read/Execute
.text$mn:00003014 _text$mn        segment para public 'CODE' use32
.text$mn:00003014                 assume cs:_text$mn
.text$mn:00003014                 ;org 3014h
.text$mn:00003014 ; COMDAT (pick any)
.text$mn:00003014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003014
.text$mn:00003014 ; =============== S U B R O U T I N E =======================================
.text$mn:00003014
.text$mn:00003014 ; Attributes: bp-based frame
.text$mn:00003014
.text$mn:00003014 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class DockingSplitter *>>>(class DockingSplitter * *, class DockingSplitter * *, struct std::_Wrap_alloc<class std::allocator<class DockingSplitter *>> &)
.text$mn:00003014                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAXPAPAVDockingSplitter@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z
.text$mn:00003014 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAXPAPAVDockingSplitter@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z proc near
.text$mn:00003014                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Destroy(DockingSplitter * *,DockingSplitter * *)+21p
.text$mn:00003014
.text$mn:00003014 var_1           = byte ptr -1
.text$mn:00003014 arg_0           = dword ptr  8
.text$mn:00003014 arg_4           = dword ptr  0Ch
.text$mn:00003014 arg_8           = dword ptr  10h
.text$mn:00003014
.text$mn:00003014                 push    ebp
.text$mn:00003015                 mov     ebp, esp
.text$mn:00003017                 push    ecx
.text$mn:00003018                 mov     eax, [ebp+arg_4]
.text$mn:0000301B                 push    eax
.text$mn:0000301C                 mov     ecx, [ebp+arg_0]
.text$mn:0000301F                 push    ecx
.text$mn:00003020                 call    ??$_Ptr_cat@PAVDockingSplitter@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingSplitter@@0@Z ; std::_Ptr_cat<DockingSplitter *,DockingSplitter *>(DockingSplitter * *,DockingSplitter * *)
.text$mn:00003025                 add     esp, 8
.text$mn:00003028                 mov     [ebp+var_1], al
.text$mn:0000302B                 movzx   edx, [ebp+var_1]
.text$mn:0000302F                 push    edx
.text$mn:00003030                 mov     eax, [ebp+arg_8]
.text$mn:00003033                 push    eax
.text$mn:00003034                 mov     ecx, [ebp+arg_4]
.text$mn:00003037                 push    ecx
.text$mn:00003038                 mov     edx, [ebp+arg_0]
.text$mn:0000303B                 push    edx
.text$mn:0000303C                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAXPAPAVDockingSplitter@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00003041                 add     esp, 10h
.text$mn:00003044                 mov     esp, ebp
.text$mn:00003046                 pop     ebp
.text$mn:00003047                 retn
.text$mn:00003047 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAXPAPAVDockingSplitter@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z endp
.text$mn:00003047
.text$mn:00003047 _text$mn        ends
.text$mn:00003047
.text$mn:00003048 ; ===========================================================================
.text$mn:00003048
.text$mn:00003048 ; Segment type: Pure code
.text$mn:00003048 ; Segment permissions: Read/Execute
.text$mn:00003048 _text$mn        segment para public 'CODE' use32
.text$mn:00003048                 assume cs:_text$mn
.text$mn:00003048                 ;org 3048h
.text$mn:00003048 ; COMDAT (pick any)
.text$mn:00003048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003048
.text$mn:00003048 ; =============== S U B R O U T I N E =======================================
.text$mn:00003048
.text$mn:00003048 ; Attributes: bp-based frame
.text$mn:00003048
.text$mn:00003048 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class DockingSplitter *>>>(class DockingSplitter * *, class DockingSplitter * *, struct std::_Wrap_alloc<class std::allocator<class DockingSplitter *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00003048                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAXPAPAVDockingSplitter@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00003048 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAXPAPAVDockingSplitter@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003048                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)+28p
.text$mn:00003048                 push    ebp
.text$mn:00003049                 mov     ebp, esp
.text$mn:0000304B                 pop     ebp
.text$mn:0000304C                 retn
.text$mn:0000304C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAXPAPAVDockingSplitter@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000304C
.text$mn:0000304C ; ---------------------------------------------------------------------------
.text$mn:0000304D                 align 10h
.text$mn:0000304D _text$mn        ends
.text$mn:0000304D
.text$mn:00003050 ; ===========================================================================
.text$mn:00003050
.text$mn:00003050 ; Segment type: Pure code
.text$mn:00003050 ; Segment permissions: Read/Execute
.text$mn:00003050 _text$mn        segment para public 'CODE' use32
.text$mn:00003050                 assume cs:_text$mn
.text$mn:00003050                 ;org 3050h
.text$mn:00003050 ; COMDAT (pick any)
.text$mn:00003050                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003050
.text$mn:00003050 ; =============== S U B R O U T I N E =======================================
.text$mn:00003050
.text$mn:00003050 ; Attributes: bp-based frame
.text$mn:00003050
.text$mn:00003050 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct HWND__ * *>(struct HWND__ * * const &)
.text$mn:00003050                 public ??$_Iter_cat@PAPAUHWND__@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUHWND__@@@Z
.text$mn:00003050 ??$_Iter_cat@PAPAUHWND__@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUHWND__@@@Z proc near
.text$mn:00003050                                         ; CODE XREF: std::_Debug_range<HWND__ * *>(HWND__ * *,HWND__ * *,wchar_t const *,uint)+Cp
.text$mn:00003050
.text$mn:00003050 var_1           = byte ptr -1
.text$mn:00003050 arg_0           = dword ptr  8
.text$mn:00003050
.text$mn:00003050                 push    ebp
.text$mn:00003051                 mov     ebp, esp
.text$mn:00003053                 push    ecx
.text$mn:00003054                 mov     eax, [ebp+arg_0]
.text$mn:00003057                 mov     cl, [ebp+var_1]
.text$mn:0000305A                 mov     [eax], cl
.text$mn:0000305C                 mov     eax, [ebp+arg_0]
.text$mn:0000305F                 mov     esp, ebp
.text$mn:00003061                 pop     ebp
.text$mn:00003062                 retn
.text$mn:00003062 ??$_Iter_cat@PAPAUHWND__@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUHWND__@@@Z endp
.text$mn:00003062
.text$mn:00003062 ; ---------------------------------------------------------------------------
.text$mn:00003063                 align 4
.text$mn:00003063 _text$mn        ends
.text$mn:00003063
.text$mn:00003064 ; ===========================================================================
.text$mn:00003064
.text$mn:00003064 ; Segment type: Pure code
.text$mn:00003064 ; Segment permissions: Read/Execute
.text$mn:00003064 _text$mn        segment para public 'CODE' use32
.text$mn:00003064                 assume cs:_text$mn
.text$mn:00003064                 ;org 3064h
.text$mn:00003064 ; COMDAT (pick any)
.text$mn:00003064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003064
.text$mn:00003064 ; =============== S U B R O U T I N E =======================================
.text$mn:00003064
.text$mn:00003064 ; Attributes: bp-based frame
.text$mn:00003064
.text$mn:00003064 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class DockingCont * *>(class DockingCont * * const &)
.text$mn:00003064                 public ??$_Iter_cat@PAPAVDockingCont@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVDockingCont@@@Z
.text$mn:00003064 ??$_Iter_cat@PAPAVDockingCont@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVDockingCont@@@Z proc near
.text$mn:00003064                                         ; CODE XREF: std::_Debug_range<DockingCont * *>(DockingCont * *,DockingCont * *,wchar_t const *,uint)+Cp
.text$mn:00003064
.text$mn:00003064 var_1           = byte ptr -1
.text$mn:00003064 arg_0           = dword ptr  8
.text$mn:00003064
.text$mn:00003064                 push    ebp
.text$mn:00003065                 mov     ebp, esp
.text$mn:00003067                 push    ecx
.text$mn:00003068                 mov     eax, [ebp+arg_0]
.text$mn:0000306B                 mov     cl, [ebp+var_1]
.text$mn:0000306E                 mov     [eax], cl
.text$mn:00003070                 mov     eax, [ebp+arg_0]
.text$mn:00003073                 mov     esp, ebp
.text$mn:00003075                 pop     ebp
.text$mn:00003076                 retn
.text$mn:00003076 ??$_Iter_cat@PAPAVDockingCont@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVDockingCont@@@Z endp
.text$mn:00003076
.text$mn:00003076 ; ---------------------------------------------------------------------------
.text$mn:00003077                 align 4
.text$mn:00003077 _text$mn        ends
.text$mn:00003077
.text$mn:00003078 ; ===========================================================================
.text$mn:00003078
.text$mn:00003078 ; Segment type: Pure code
.text$mn:00003078 ; Segment permissions: Read/Execute
.text$mn:00003078 _text$mn        segment para public 'CODE' use32
.text$mn:00003078                 assume cs:_text$mn
.text$mn:00003078                 ;org 3078h
.text$mn:00003078 ; COMDAT (pick any)
.text$mn:00003078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003078
.text$mn:00003078 ; =============== S U B R O U T I N E =======================================
.text$mn:00003078
.text$mn:00003078 ; Attributes: bp-based frame
.text$mn:00003078
.text$mn:00003078 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class DockingSplitter * *>(class DockingSplitter * * const &)
.text$mn:00003078                 public ??$_Iter_cat@PAPAVDockingSplitter@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVDockingSplitter@@@Z
.text$mn:00003078 ??$_Iter_cat@PAPAVDockingSplitter@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVDockingSplitter@@@Z proc near
.text$mn:00003078                                         ; CODE XREF: std::_Debug_range<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,wchar_t const *,uint)+Cp
.text$mn:00003078
.text$mn:00003078 var_1           = byte ptr -1
.text$mn:00003078 arg_0           = dword ptr  8
.text$mn:00003078
.text$mn:00003078                 push    ebp
.text$mn:00003079                 mov     ebp, esp
.text$mn:0000307B                 push    ecx
.text$mn:0000307C                 mov     eax, [ebp+arg_0]
.text$mn:0000307F                 mov     cl, [ebp+var_1]
.text$mn:00003082                 mov     [eax], cl
.text$mn:00003084                 mov     eax, [ebp+arg_0]
.text$mn:00003087                 mov     esp, ebp
.text$mn:00003089                 pop     ebp
.text$mn:0000308A                 retn
.text$mn:0000308A ??$_Iter_cat@PAPAVDockingSplitter@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVDockingSplitter@@@Z endp
.text$mn:0000308A
.text$mn:0000308A ; ---------------------------------------------------------------------------
.text$mn:0000308B                 align 4
.text$mn:0000308B _text$mn        ends
.text$mn:0000308B
.text$mn:0000308C ; ===========================================================================
.text$mn:0000308C
.text$mn:0000308C ; Segment type: Pure code
.text$mn:0000308C ; Segment permissions: Read/Execute
.text$mn:0000308C _text$mn        segment para public 'CODE' use32
.text$mn:0000308C                 assume cs:_text$mn
.text$mn:0000308C                 ;org 308Ch
.text$mn:0000308C ; COMDAT (pick any)
.text$mn:0000308C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000308C
.text$mn:0000308C ; =============== S U B R O U T I N E =======================================
.text$mn:0000308C
.text$mn:0000308C ; Attributes: bp-based frame
.text$mn:0000308C
.text$mn:0000308C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct tTbData * const *>(struct tTbData * const * const &)
.text$mn:0000308C                 public ??$_Iter_cat@PBQAUtTbData@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBQAUtTbData@@@Z
.text$mn:0000308C ??$_Iter_cat@PBQAUtTbData@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBQAUtTbData@@@Z proc near
.text$mn:0000308C                                         ; CODE XREF: std::_Debug_range<tTbData * const *>(tTbData * const *,tTbData * const *,wchar_t const *,uint)+Cp
.text$mn:0000308C
.text$mn:0000308C var_1           = byte ptr -1
.text$mn:0000308C arg_0           = dword ptr  8
.text$mn:0000308C
.text$mn:0000308C                 push    ebp
.text$mn:0000308D                 mov     ebp, esp
.text$mn:0000308F                 push    ecx
.text$mn:00003090                 mov     eax, [ebp+arg_0]
.text$mn:00003093                 mov     cl, [ebp+var_1]
.text$mn:00003096                 mov     [eax], cl
.text$mn:00003098                 mov     eax, [ebp+arg_0]
.text$mn:0000309B                 mov     esp, ebp
.text$mn:0000309D                 pop     ebp
.text$mn:0000309E                 retn
.text$mn:0000309E ??$_Iter_cat@PBQAUtTbData@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBQAUtTbData@@@Z endp
.text$mn:0000309E
.text$mn:0000309E ; ---------------------------------------------------------------------------
.text$mn:0000309F                 align 10h
.text$mn:0000309F _text$mn        ends
.text$mn:0000309F
.text$mn:000030A0 ; ===========================================================================
.text$mn:000030A0
.text$mn:000030A0 ; Segment type: Pure code
.text$mn:000030A0 ; Segment permissions: Read/Execute
.text$mn:000030A0 _text$mn        segment para public 'CODE' use32
.text$mn:000030A0                 assume cs:_text$mn
.text$mn:000030A0                 ;org 30A0h
.text$mn:000030A0 ; COMDAT (pick any)
.text$mn:000030A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030A0
.text$mn:000030A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000030A0
.text$mn:000030A0 ; Attributes: bp-based frame
.text$mn:000030A0
.text$mn:000030A0 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct HWND__ *, struct HWND__ *>(struct HWND__ * *, struct HWND__ * *)
.text$mn:000030A0                 public ??$_Ptr_cat@PAUHWND__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHWND__@@0@Z
.text$mn:000030A0 ??$_Ptr_cat@PAUHWND__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHWND__@@0@Z proc near
.text$mn:000030A0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)+Cp
.text$mn:000030A0                                         ; std::_Uninit_move<HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)+Cp
.text$mn:000030A0
.text$mn:000030A0 var_1           = byte ptr -1
.text$mn:000030A0
.text$mn:000030A0                 push    ebp
.text$mn:000030A1                 mov     ebp, esp
.text$mn:000030A3                 push    ecx
.text$mn:000030A4                 mov     al, [ebp+var_1]
.text$mn:000030A7                 mov     esp, ebp
.text$mn:000030A9                 pop     ebp
.text$mn:000030AA                 retn
.text$mn:000030AA ??$_Ptr_cat@PAUHWND__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHWND__@@0@Z endp
.text$mn:000030AA
.text$mn:000030AA ; ---------------------------------------------------------------------------
.text$mn:000030AB                 align 4
.text$mn:000030AB _text$mn        ends
.text$mn:000030AB
.text$mn:000030AC ; ===========================================================================
.text$mn:000030AC
.text$mn:000030AC ; Segment type: Pure code
.text$mn:000030AC ; Segment permissions: Read/Execute
.text$mn:000030AC _text$mn        segment para public 'CODE' use32
.text$mn:000030AC                 assume cs:_text$mn
.text$mn:000030AC                 ;org 30ACh
.text$mn:000030AC ; COMDAT (pick any)
.text$mn:000030AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030AC
.text$mn:000030AC ; =============== S U B R O U T I N E =======================================
.text$mn:000030AC
.text$mn:000030AC ; Attributes: bp-based frame
.text$mn:000030AC
.text$mn:000030AC ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct tTbData *, struct tTbData *>(struct tTbData * *, struct tTbData * *)
.text$mn:000030AC                 public ??$_Ptr_cat@PAUtTbData@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtTbData@@0@Z
.text$mn:000030AC ??$_Ptr_cat@PAUtTbData@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtTbData@@0@Z proc near
.text$mn:000030AC                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<tTbData *>>>(tTbData * *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)+Cp
.text$mn:000030AC
.text$mn:000030AC var_1           = byte ptr -1
.text$mn:000030AC
.text$mn:000030AC                 push    ebp
.text$mn:000030AD                 mov     ebp, esp
.text$mn:000030AF                 push    ecx
.text$mn:000030B0                 mov     al, [ebp+var_1]
.text$mn:000030B3                 mov     esp, ebp
.text$mn:000030B5                 pop     ebp
.text$mn:000030B6                 retn
.text$mn:000030B6 ??$_Ptr_cat@PAUtTbData@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUtTbData@@0@Z endp
.text$mn:000030B6
.text$mn:000030B6 ; ---------------------------------------------------------------------------
.text$mn:000030B7                 align 4
.text$mn:000030B7 _text$mn        ends
.text$mn:000030B7
.text$mn:000030B8 ; ===========================================================================
.text$mn:000030B8
.text$mn:000030B8 ; Segment type: Pure code
.text$mn:000030B8 ; Segment permissions: Read/Execute
.text$mn:000030B8 _text$mn        segment para public 'CODE' use32
.text$mn:000030B8                 assume cs:_text$mn
.text$mn:000030B8                 ;org 30B8h
.text$mn:000030B8 ; COMDAT (pick any)
.text$mn:000030B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030B8
.text$mn:000030B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000030B8
.text$mn:000030B8 ; Attributes: bp-based frame
.text$mn:000030B8
.text$mn:000030B8 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct tTbData *, struct tTbData *>(struct tTbData * const *, struct tTbData * *)
.text$mn:000030B8                 public ??$_Ptr_cat@PAUtTbData@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAUtTbData@@PAPAU2@@Z
.text$mn:000030B8 ??$_Ptr_cat@PAUtTbData@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAUtTbData@@PAPAU2@@Z proc near
.text$mn:000030B8                                         ; CODE XREF: std::_Uninit_copy<tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(tTbData * const *,tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)+Cp
.text$mn:000030B8
.text$mn:000030B8 var_1           = byte ptr -1
.text$mn:000030B8
.text$mn:000030B8                 push    ebp
.text$mn:000030B9                 mov     ebp, esp
.text$mn:000030BB                 push    ecx
.text$mn:000030BC                 mov     al, [ebp+var_1]
.text$mn:000030BF                 mov     esp, ebp
.text$mn:000030C1                 pop     ebp
.text$mn:000030C2                 retn
.text$mn:000030C2 ??$_Ptr_cat@PAUtTbData@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAUtTbData@@PAPAU2@@Z endp
.text$mn:000030C2
.text$mn:000030C2 ; ---------------------------------------------------------------------------
.text$mn:000030C3                 align 4
.text$mn:000030C3 _text$mn        ends
.text$mn:000030C3
.text$mn:000030C4 ; ===========================================================================
.text$mn:000030C4
.text$mn:000030C4 ; Segment type: Pure code
.text$mn:000030C4 ; Segment permissions: Read/Execute
.text$mn:000030C4 _text$mn        segment para public 'CODE' use32
.text$mn:000030C4                 assume cs:_text$mn
.text$mn:000030C4                 ;org 30C4h
.text$mn:000030C4 ; COMDAT (pick any)
.text$mn:000030C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030C4
.text$mn:000030C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000030C4
.text$mn:000030C4 ; Attributes: bp-based frame
.text$mn:000030C4
.text$mn:000030C4 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class DockingCont *, class DockingCont *>(class DockingCont * *, class DockingCont * *)
.text$mn:000030C4                 public ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingCont@@0@Z
.text$mn:000030C4 ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingCont@@0@Z proc near
.text$mn:000030C4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+Cp
.text$mn:000030C4                                         ; std::_Uninit_move<DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+Cp
.text$mn:000030C4
.text$mn:000030C4 var_1           = byte ptr -1
.text$mn:000030C4
.text$mn:000030C4                 push    ebp
.text$mn:000030C5                 mov     ebp, esp
.text$mn:000030C7                 push    ecx
.text$mn:000030C8                 mov     al, [ebp+var_1]
.text$mn:000030CB                 mov     esp, ebp
.text$mn:000030CD                 pop     ebp
.text$mn:000030CE                 retn
.text$mn:000030CE ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingCont@@0@Z endp
.text$mn:000030CE
.text$mn:000030CE ; ---------------------------------------------------------------------------
.text$mn:000030CF                 align 10h
.text$mn:000030CF _text$mn        ends
.text$mn:000030CF
.text$mn:000030D0 ; ===========================================================================
.text$mn:000030D0
.text$mn:000030D0 ; Segment type: Pure code
.text$mn:000030D0 ; Segment permissions: Read/Execute
.text$mn:000030D0 _text$mn        segment para public 'CODE' use32
.text$mn:000030D0                 assume cs:_text$mn
.text$mn:000030D0                 ;org 30D0h
.text$mn:000030D0 ; COMDAT (pick any)
.text$mn:000030D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030D0
.text$mn:000030D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000030D0
.text$mn:000030D0 ; Attributes: bp-based frame
.text$mn:000030D0
.text$mn:000030D0 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class DockingSplitter *, class DockingSplitter *>(class DockingSplitter * *, class DockingSplitter * *)
.text$mn:000030D0                 public ??$_Ptr_cat@PAVDockingSplitter@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingSplitter@@0@Z
.text$mn:000030D0 ??$_Ptr_cat@PAVDockingSplitter@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingSplitter@@0@Z proc near
.text$mn:000030D0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)+Cp
.text$mn:000030D0                                         ; std::_Uninit_move<DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)+Cp
.text$mn:000030D0
.text$mn:000030D0 var_1           = byte ptr -1
.text$mn:000030D0
.text$mn:000030D0                 push    ebp
.text$mn:000030D1                 mov     ebp, esp
.text$mn:000030D3                 push    ecx
.text$mn:000030D4                 mov     al, [ebp+var_1]
.text$mn:000030D7                 mov     esp, ebp
.text$mn:000030D9                 pop     ebp
.text$mn:000030DA                 retn
.text$mn:000030DA ??$_Ptr_cat@PAVDockingSplitter@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingSplitter@@0@Z endp
.text$mn:000030DA
.text$mn:000030DA ; ---------------------------------------------------------------------------
.text$mn:000030DB                 align 4
.text$mn:000030DB _text$mn        ends
.text$mn:000030DB
.text$mn:000030DC ; ===========================================================================
.text$mn:000030DC
.text$mn:000030DC ; Segment type: Pure code
.text$mn:000030DC ; Segment permissions: Read/Execute
.text$mn:000030DC _text$mn        segment para public 'CODE' use32
.text$mn:000030DC                 assume cs:_text$mn
.text$mn:000030DC                 ;org 30DCh
.text$mn:000030DC ; COMDAT (pick any)
.text$mn:000030DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030DC
.text$mn:000030DC ; =============== S U B R O U T I N E =======================================
.text$mn:000030DC
.text$mn:000030DC ; Attributes: bp-based frame
.text$mn:000030DC
.text$mn:000030DC ; struct HWND__ * * & __cdecl std::_Rechecked<struct HWND__ * *, struct HWND__ * *>(struct HWND__ * * &, struct HWND__ * *)
.text$mn:000030DC                 public ??$_Rechecked@PAPAUHWND__@@PAPAU1@@std@@YAAAPAPAUHWND__@@AAPAPAU1@PAPAU1@@Z
.text$mn:000030DC ??$_Rechecked@PAPAUHWND__@@PAPAU1@@std@@YAAAPAPAUHWND__@@AAPAPAU1@PAPAU1@@Z proc near
.text$mn:000030DC                                         ; CODE XREF: std::_Uninitialized_move<HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)+3Bp
.text$mn:000030DC
.text$mn:000030DC arg_0           = dword ptr  8
.text$mn:000030DC arg_4           = dword ptr  0Ch
.text$mn:000030DC
.text$mn:000030DC                 push    ebp
.text$mn:000030DD                 mov     ebp, esp
.text$mn:000030DF                 mov     eax, [ebp+arg_0]
.text$mn:000030E2                 mov     ecx, [ebp+arg_4]
.text$mn:000030E5                 mov     [eax], ecx
.text$mn:000030E7                 mov     eax, [ebp+arg_0]
.text$mn:000030EA                 pop     ebp
.text$mn:000030EB                 retn
.text$mn:000030EB ??$_Rechecked@PAPAUHWND__@@PAPAU1@@std@@YAAAPAPAUHWND__@@AAPAPAU1@PAPAU1@@Z endp
.text$mn:000030EB
.text$mn:000030EB _text$mn        ends
.text$mn:000030EB
.text$mn:000030EC ; ===========================================================================
.text$mn:000030EC
.text$mn:000030EC ; Segment type: Pure code
.text$mn:000030EC ; Segment permissions: Read/Execute
.text$mn:000030EC _text$mn        segment para public 'CODE' use32
.text$mn:000030EC                 assume cs:_text$mn
.text$mn:000030EC                 ;org 30ECh
.text$mn:000030EC ; COMDAT (pick any)
.text$mn:000030EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030EC
.text$mn:000030EC ; =============== S U B R O U T I N E =======================================
.text$mn:000030EC
.text$mn:000030EC ; Attributes: bp-based frame
.text$mn:000030EC
.text$mn:000030EC ; struct tTbData * * & __cdecl std::_Rechecked<struct tTbData * *, struct tTbData * *>(struct tTbData * * &, struct tTbData * *)
.text$mn:000030EC                 public ??$_Rechecked@PAPAUtTbData@@PAPAU1@@std@@YAAAPAPAUtTbData@@AAPAPAU1@PAPAU1@@Z
.text$mn:000030EC ??$_Rechecked@PAPAUtTbData@@PAPAU1@@std@@YAAAPAPAUtTbData@@AAPAPAU1@PAPAU1@@Z proc near
.text$mn:000030EC                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)+B2p
.text$mn:000030EC
.text$mn:000030EC arg_0           = dword ptr  8
.text$mn:000030EC arg_4           = dword ptr  0Ch
.text$mn:000030EC
.text$mn:000030EC                 push    ebp
.text$mn:000030ED                 mov     ebp, esp
.text$mn:000030EF                 mov     eax, [ebp+arg_0]
.text$mn:000030F2                 mov     ecx, [ebp+arg_4]
.text$mn:000030F5                 mov     [eax], ecx
.text$mn:000030F7                 mov     eax, [ebp+arg_0]
.text$mn:000030FA                 pop     ebp
.text$mn:000030FB                 retn
.text$mn:000030FB ??$_Rechecked@PAPAUtTbData@@PAPAU1@@std@@YAAAPAPAUtTbData@@AAPAPAU1@PAPAU1@@Z endp
.text$mn:000030FB
.text$mn:000030FB _text$mn        ends
.text$mn:000030FB
.text$mn:000030FC ; ===========================================================================
.text$mn:000030FC
.text$mn:000030FC ; Segment type: Pure code
.text$mn:000030FC ; Segment permissions: Read/Execute
.text$mn:000030FC _text$mn        segment para public 'CODE' use32
.text$mn:000030FC                 assume cs:_text$mn
.text$mn:000030FC                 ;org 30FCh
.text$mn:000030FC ; COMDAT (pick any)
.text$mn:000030FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030FC
.text$mn:000030FC ; =============== S U B R O U T I N E =======================================
.text$mn:000030FC
.text$mn:000030FC ; Attributes: bp-based frame
.text$mn:000030FC
.text$mn:000030FC ; class DockingCont * * & __cdecl std::_Rechecked<class DockingCont * *, class DockingCont * *>(class DockingCont * * &, class DockingCont * *)
.text$mn:000030FC                 public ??$_Rechecked@PAPAVDockingCont@@PAPAV1@@std@@YAAAPAPAVDockingCont@@AAPAPAV1@PAPAV1@@Z
.text$mn:000030FC ??$_Rechecked@PAPAVDockingCont@@PAPAV1@@std@@YAAAPAPAVDockingCont@@AAPAPAV1@PAPAV1@@Z proc near
.text$mn:000030FC                                         ; CODE XREF: std::_Uninitialized_move<DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+3Bp
.text$mn:000030FC
.text$mn:000030FC arg_0           = dword ptr  8
.text$mn:000030FC arg_4           = dword ptr  0Ch
.text$mn:000030FC
.text$mn:000030FC                 push    ebp
.text$mn:000030FD                 mov     ebp, esp
.text$mn:000030FF                 mov     eax, [ebp+arg_0]
.text$mn:00003102                 mov     ecx, [ebp+arg_4]
.text$mn:00003105                 mov     [eax], ecx
.text$mn:00003107                 mov     eax, [ebp+arg_0]
.text$mn:0000310A                 pop     ebp
.text$mn:0000310B                 retn
.text$mn:0000310B ??$_Rechecked@PAPAVDockingCont@@PAPAV1@@std@@YAAAPAPAVDockingCont@@AAPAPAV1@PAPAV1@@Z endp
.text$mn:0000310B
.text$mn:0000310B _text$mn        ends
.text$mn:0000310B
.text$mn:0000310C ; ===========================================================================
.text$mn:0000310C
.text$mn:0000310C ; Segment type: Pure code
.text$mn:0000310C ; Segment permissions: Read/Execute
.text$mn:0000310C _text$mn        segment para public 'CODE' use32
.text$mn:0000310C                 assume cs:_text$mn
.text$mn:0000310C                 ;org 310Ch
.text$mn:0000310C ; COMDAT (pick any)
.text$mn:0000310C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000310C
.text$mn:0000310C ; =============== S U B R O U T I N E =======================================
.text$mn:0000310C
.text$mn:0000310C ; Attributes: bp-based frame
.text$mn:0000310C
.text$mn:0000310C ; class DockingSplitter * * & __cdecl std::_Rechecked<class DockingSplitter * *, class DockingSplitter * *>(class DockingSplitter * * &, class DockingSplitter * *)
.text$mn:0000310C                 public ??$_Rechecked@PAPAVDockingSplitter@@PAPAV1@@std@@YAAAPAPAVDockingSplitter@@AAPAPAV1@PAPAV1@@Z
.text$mn:0000310C ??$_Rechecked@PAPAVDockingSplitter@@PAPAV1@@std@@YAAAPAPAVDockingSplitter@@AAPAPAV1@PAPAV1@@Z proc near
.text$mn:0000310C                                         ; CODE XREF: std::_Uninitialized_move<DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)+3Bp
.text$mn:0000310C
.text$mn:0000310C arg_0           = dword ptr  8
.text$mn:0000310C arg_4           = dword ptr  0Ch
.text$mn:0000310C
.text$mn:0000310C                 push    ebp
.text$mn:0000310D                 mov     ebp, esp
.text$mn:0000310F                 mov     eax, [ebp+arg_0]
.text$mn:00003112                 mov     ecx, [ebp+arg_4]
.text$mn:00003115                 mov     [eax], ecx
.text$mn:00003117                 mov     eax, [ebp+arg_0]
.text$mn:0000311A                 pop     ebp
.text$mn:0000311B                 retn
.text$mn:0000311B ??$_Rechecked@PAPAVDockingSplitter@@PAPAV1@@std@@YAAAPAPAVDockingSplitter@@AAPAPAV1@PAPAV1@@Z endp
.text$mn:0000311B
.text$mn:0000311B _text$mn        ends
.text$mn:0000311B
.text$mn:0000311C ; ===========================================================================
.text$mn:0000311C
.text$mn:0000311C ; Segment type: Pure code
.text$mn:0000311C ; Segment permissions: Read/Execute
.text$mn:0000311C _text$mn        segment para public 'CODE' use32
.text$mn:0000311C                 assume cs:_text$mn
.text$mn:0000311C                 ;org 311Ch
.text$mn:0000311C ; COMDAT (pick any)
.text$mn:0000311C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000311C
.text$mn:0000311C ; =============== S U B R O U T I N E =======================================
.text$mn:0000311C
.text$mn:0000311C ; Attributes: bp-based frame
.text$mn:0000311C
.text$mn:0000311C ; protected: struct tTbData * * __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::_Ucopy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>, struct tTbData * *)
.text$mn:0000311C                 public ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z
.text$mn:0000311C ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z proc near
.text$mn:0000311C                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+C0p
.text$mn:0000311C
.text$mn:0000311C var_34          = dword ptr -34h
.text$mn:0000311C var_30          = dword ptr -30h
.text$mn:0000311C var_2C          = dword ptr -2Ch
.text$mn:0000311C var_28          = dword ptr -28h
.text$mn:0000311C var_24          = dword ptr -24h
.text$mn:0000311C var_20          = dword ptr -20h
.text$mn:0000311C var_1C          = dword ptr -1Ch
.text$mn:0000311C var_18          = dword ptr -18h
.text$mn:0000311C var_14          = dword ptr -14h
.text$mn:0000311C var_D           = byte ptr -0Dh
.text$mn:0000311C var_C           = dword ptr -0Ch
.text$mn:0000311C var_4           = dword ptr -4
.text$mn:0000311C arg_0           = byte ptr  8
.text$mn:0000311C arg_C           = byte ptr  14h
.text$mn:0000311C arg_18          = dword ptr  20h
.text$mn:0000311C
.text$mn:0000311C                 push    ebp
.text$mn:0000311D                 mov     ebp, esp
.text$mn:0000311F                 push    0FFFFFFFFh
.text$mn:00003121                 push    offset __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z
.text$mn:00003126                 mov     eax, large fs:0
.text$mn:0000312C                 push    eax
.text$mn:0000312D                 sub     esp, 28h
.text$mn:00003130                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003135                 xor     eax, ebp
.text$mn:00003137                 push    eax
.text$mn:00003138                 lea     eax, [ebp+var_C]
.text$mn:0000313B                 mov     large fs:0, eax
.text$mn:00003141                 mov     [ebp+var_14], ecx
.text$mn:00003144                 mov     [ebp+var_4], 1
.text$mn:0000314B                 lea     eax, [ebp+var_D]
.text$mn:0000314E                 push    eax
.text$mn:0000314F                 mov     ecx, [ebp+var_14]
.text$mn:00003152                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Getal(void)
.text$mn:00003157                 lea     ecx, [ebp+var_D]
.text$mn:0000315A                 push    ecx
.text$mn:0000315B                 mov     edx, [ebp+arg_18]
.text$mn:0000315E                 push    edx
.text$mn:0000315F                 sub     esp, 0Ch
.text$mn:00003162                 mov     ecx, esp
.text$mn:00003164                 mov     [ebp+var_28], esp
.text$mn:00003167                 lea     eax, [ebp+arg_C]
.text$mn:0000316A                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000316B                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>> const &)
.text$mn:00003170                 mov     [ebp+var_18], eax
.text$mn:00003173                 mov     ecx, [ebp+var_18]
.text$mn:00003176                 mov     [ebp+var_2C], ecx
.text$mn:00003179                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000317D                 sub     esp, 0Ch
.text$mn:00003180                 mov     ecx, esp
.text$mn:00003182                 mov     [ebp+var_30], esp
.text$mn:00003185                 lea     edx, [ebp+arg_0]
.text$mn:00003188                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003189                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>> const &)
.text$mn:0000318E                 mov     [ebp+var_1C], eax
.text$mn:00003191                 mov     eax, [ebp+var_1C]
.text$mn:00003194                 mov     [ebp+var_34], eax
.text$mn:00003197                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000319B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000319F                 call    ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)
.text$mn:000031A4                 add     esp, 20h
.text$mn:000031A7                 mov     [ebp+var_20], eax
.text$mn:000031AA                 mov     ecx, [ebp+var_20]
.text$mn:000031AD                 mov     [ebp+var_24], ecx
.text$mn:000031B0                 mov     byte ptr [ebp+var_4], 0
.text$mn:000031B4                 lea     ecx, [ebp+arg_0]
.text$mn:000031B7                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$mn:000031BC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000031C3                 lea     ecx, [ebp+arg_C]
.text$mn:000031C6                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$mn:000031CB                 mov     eax, [ebp+var_24]
.text$mn:000031CE                 mov     ecx, [ebp+var_C]
.text$mn:000031D1                 mov     large fs:0, ecx
.text$mn:000031D8                 pop     ecx
.text$mn:000031D9                 mov     esp, ebp
.text$mn:000031DB                 pop     ebp
.text$mn:000031DC                 retn    1Ch
.text$mn:000031DC ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z endp
.text$mn:000031DC
.text$mn:000031DC ; ---------------------------------------------------------------------------
.text$mn:000031DF                 align 10h
.text$mn:000031DF _text$mn        ends
.text$mn:000031DF
.text$x:000031E0 ; ===========================================================================
.text$x:000031E0
.text$x:000031E0 ; Segment type: Pure code
.text$x:000031E0 ; Segment permissions: Read/Execute
.text$x:000031E0 _text$x         segment para public 'CODE' use32
.text$x:000031E0                 assume cs:_text$x
.text$x:000031E0                 ;org 31E0h
.text$x:000031E0 ; COMDAT (pick associative to section at 311C)
.text$x:000031E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000031E0
.text$x:000031E0 ; =============== S U B R O U T I N E =======================================
.text$x:000031E0
.text$x:000031E0
.text$x:000031E0 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$0 proc near
.text$x:000031E0                                         ; DATA XREF: .xdata$x:00009A20o
.text$x:000031E0                 lea     ecx, [ebp+14h]
.text$x:000031E3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:000031E3 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$0 endp
.text$x:000031E3
.text$x:000031E8
.text$x:000031E8 ; =============== S U B R O U T I N E =======================================
.text$x:000031E8
.text$x:000031E8
.text$x:000031E8 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$1 proc near
.text$x:000031E8                                         ; DATA XREF: .xdata$x:00009A28o
.text$x:000031E8                 lea     ecx, [ebp+8]
.text$x:000031EB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:000031EB __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$1 endp
.text$x:000031EB
.text$x:000031F0
.text$x:000031F0 ; =============== S U B R O U T I N E =======================================
.text$x:000031F0
.text$x:000031F0
.text$x:000031F0 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$2 proc near
.text$x:000031F0                                         ; DATA XREF: .xdata$x:00009A30o
.text$x:000031F0                 mov     ecx, [ebp-28h]
.text$x:000031F3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:000031F3 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$2 endp
.text$x:000031F3
.text$x:000031F8
.text$x:000031F8 ; =============== S U B R O U T I N E =======================================
.text$x:000031F8
.text$x:000031F8
.text$x:000031F8 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$3 proc near
.text$x:000031F8                                         ; DATA XREF: .xdata$x:00009A38o
.text$x:000031F8                 mov     ecx, [ebp-30h]
.text$x:000031FB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:000031FB __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$3 endp
.text$x:000031FB
.text$x:00003200
.text$x:00003200 ; =============== S U B R O U T I N E =======================================
.text$x:00003200
.text$x:00003200
.text$x:00003200 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z proc near
.text$x:00003200                                         ; DATA XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *)+5o
.text$x:00003200
.text$x:00003200 arg_4           = dword ptr  8
.text$x:00003200
.text$x:00003200                 mov     edx, [esp+arg_4]
.text$x:00003204                 lea     eax, [edx+0Ch]
.text$x:00003207                 mov     ecx, [edx-2Ch]
.text$x:0000320A                 xor     ecx, eax
.text$x:0000320C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003211                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z
.text$x:00003216                 jmp     ___CxxFrameHandler3
.text$x:00003216 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z endp
.text$x:00003216
.text$x:00003216 ; ---------------------------------------------------------------------------
.text$x:0000321B                 align 4
.text$x:0000321B _text$x         ends
.text$x:0000321B
.text$mn:0000321C ; ===========================================================================
.text$mn:0000321C
.text$mn:0000321C ; Segment type: Pure code
.text$mn:0000321C ; Segment permissions: Read/Execute
.text$mn:0000321C _text$mn        segment para public 'CODE' use32
.text$mn:0000321C                 assume cs:_text$mn
.text$mn:0000321C                 ;org 321Ch
.text$mn:0000321C ; COMDAT (pick any)
.text$mn:0000321C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000321C
.text$mn:0000321C ; =============== S U B R O U T I N E =======================================
.text$mn:0000321C
.text$mn:0000321C ; Attributes: bp-based frame
.text$mn:0000321C
.text$mn:0000321C ; protected: struct HWND__ * * __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::_Umove<struct HWND__ * *>(struct HWND__ * *, struct HWND__ * *, struct HWND__ * *)
.text$mn:0000321C                 public ??$_Umove@PAPAUHWND__@@@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEPAPAUHWND__@@PAPAU2@00@Z
.text$mn:0000321C ??$_Umove@PAPAUHWND__@@@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEPAPAUHWND__@@PAPAU2@00@Z proc near
.text$mn:0000321C                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reallocate(uint)+65p
.text$mn:0000321C
.text$mn:0000321C var_8           = dword ptr -8
.text$mn:0000321C var_1           = byte ptr -1
.text$mn:0000321C arg_0           = dword ptr  8
.text$mn:0000321C arg_4           = dword ptr  0Ch
.text$mn:0000321C arg_8           = dword ptr  10h
.text$mn:0000321C
.text$mn:0000321C                 push    ebp
.text$mn:0000321D                 mov     ebp, esp
.text$mn:0000321F                 sub     esp, 8
.text$mn:00003222                 mov     [ebp+var_8], ecx
.text$mn:00003225                 lea     eax, [ebp+var_1]
.text$mn:00003228                 push    eax
.text$mn:00003229                 mov     ecx, [ebp+var_8]
.text$mn:0000322C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Getal(void)
.text$mn:00003231                 lea     ecx, [ebp+var_1]
.text$mn:00003234                 push    ecx
.text$mn:00003235                 mov     edx, [ebp+arg_8]
.text$mn:00003238                 push    edx
.text$mn:00003239                 mov     eax, [ebp+arg_4]
.text$mn:0000323C                 push    eax
.text$mn:0000323D                 mov     ecx, [ebp+arg_0]
.text$mn:00003240                 push    ecx
.text$mn:00003241                 call    ??$_Uninitialized_move@PAPAUHWND__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z ; std::_Uninitialized_move<HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)
.text$mn:00003246                 add     esp, 10h
.text$mn:00003249                 mov     esp, ebp
.text$mn:0000324B                 pop     ebp
.text$mn:0000324C                 retn    0Ch
.text$mn:0000324C ??$_Umove@PAPAUHWND__@@@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEPAPAUHWND__@@PAPAU2@00@Z endp
.text$mn:0000324C
.text$mn:0000324C ; ---------------------------------------------------------------------------
.text$mn:0000324F                 align 10h
.text$mn:0000324F _text$mn        ends
.text$mn:0000324F
.text$mn:00003250 ; ===========================================================================
.text$mn:00003250
.text$mn:00003250 ; Segment type: Pure code
.text$mn:00003250 ; Segment permissions: Read/Execute
.text$mn:00003250 _text$mn        segment para public 'CODE' use32
.text$mn:00003250                 assume cs:_text$mn
.text$mn:00003250                 ;org 3250h
.text$mn:00003250 ; COMDAT (pick any)
.text$mn:00003250                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003250
.text$mn:00003250 ; =============== S U B R O U T I N E =======================================
.text$mn:00003250
.text$mn:00003250 ; Attributes: bp-based frame
.text$mn:00003250
.text$mn:00003250 ; protected: class DockingCont * * __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Umove<class DockingCont * *>(class DockingCont * *, class DockingCont * *, class DockingCont * *)
.text$mn:00003250                 public ??$_Umove@PAPAVDockingCont@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@PAPAV2@00@Z
.text$mn:00003250 ??$_Umove@PAPAVDockingCont@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@PAPAV2@00@Z proc near
.text$mn:00003250                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reallocate(uint)+65p
.text$mn:00003250
.text$mn:00003250 var_8           = dword ptr -8
.text$mn:00003250 var_1           = byte ptr -1
.text$mn:00003250 arg_0           = dword ptr  8
.text$mn:00003250 arg_4           = dword ptr  0Ch
.text$mn:00003250 arg_8           = dword ptr  10h
.text$mn:00003250
.text$mn:00003250                 push    ebp
.text$mn:00003251                 mov     ebp, esp
.text$mn:00003253                 sub     esp, 8
.text$mn:00003256                 mov     [ebp+var_8], ecx
.text$mn:00003259                 lea     eax, [ebp+var_1]
.text$mn:0000325C                 push    eax
.text$mn:0000325D                 mov     ecx, [ebp+var_8]
.text$mn:00003260                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:00003265                 lea     ecx, [ebp+var_1]
.text$mn:00003268                 push    ecx
.text$mn:00003269                 mov     edx, [ebp+arg_8]
.text$mn:0000326C                 push    edx
.text$mn:0000326D                 mov     eax, [ebp+arg_4]
.text$mn:00003270                 push    eax
.text$mn:00003271                 mov     ecx, [ebp+arg_0]
.text$mn:00003274                 push    ecx
.text$mn:00003275                 call    ??$_Uninitialized_move@PAPAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z ; std::_Uninitialized_move<DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)
.text$mn:0000327A                 add     esp, 10h
.text$mn:0000327D                 mov     esp, ebp
.text$mn:0000327F                 pop     ebp
.text$mn:00003280                 retn    0Ch
.text$mn:00003280 ??$_Umove@PAPAVDockingCont@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@PAPAV2@00@Z endp
.text$mn:00003280
.text$mn:00003280 ; ---------------------------------------------------------------------------
.text$mn:00003283                 align 4
.text$mn:00003283 _text$mn        ends
.text$mn:00003283
.text$mn:00003284 ; ===========================================================================
.text$mn:00003284
.text$mn:00003284 ; Segment type: Pure code
.text$mn:00003284 ; Segment permissions: Read/Execute
.text$mn:00003284 _text$mn        segment para public 'CODE' use32
.text$mn:00003284                 assume cs:_text$mn
.text$mn:00003284                 ;org 3284h
.text$mn:00003284 ; COMDAT (pick any)
.text$mn:00003284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003284
.text$mn:00003284 ; =============== S U B R O U T I N E =======================================
.text$mn:00003284
.text$mn:00003284 ; Attributes: bp-based frame
.text$mn:00003284
.text$mn:00003284 ; protected: class DockingSplitter * * __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::_Umove<class DockingSplitter * *>(class DockingSplitter * *, class DockingSplitter * *, class DockingSplitter * *)
.text$mn:00003284                 public ??$_Umove@PAPAVDockingSplitter@@@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEPAPAVDockingSplitter@@PAPAV2@00@Z
.text$mn:00003284 ??$_Umove@PAPAVDockingSplitter@@@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEPAPAVDockingSplitter@@PAPAV2@00@Z proc near
.text$mn:00003284                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reallocate(uint)+65p
.text$mn:00003284
.text$mn:00003284 var_8           = dword ptr -8
.text$mn:00003284 var_1           = byte ptr -1
.text$mn:00003284 arg_0           = dword ptr  8
.text$mn:00003284 arg_4           = dword ptr  0Ch
.text$mn:00003284 arg_8           = dword ptr  10h
.text$mn:00003284
.text$mn:00003284                 push    ebp
.text$mn:00003285                 mov     ebp, esp
.text$mn:00003287                 sub     esp, 8
.text$mn:0000328A                 mov     [ebp+var_8], ecx
.text$mn:0000328D                 lea     eax, [ebp+var_1]
.text$mn:00003290                 push    eax
.text$mn:00003291                 mov     ecx, [ebp+var_8]
.text$mn:00003294                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Getal(void)
.text$mn:00003299                 lea     ecx, [ebp+var_1]
.text$mn:0000329C                 push    ecx
.text$mn:0000329D                 mov     edx, [ebp+arg_8]
.text$mn:000032A0                 push    edx
.text$mn:000032A1                 mov     eax, [ebp+arg_4]
.text$mn:000032A4                 push    eax
.text$mn:000032A5                 mov     ecx, [ebp+arg_0]
.text$mn:000032A8                 push    ecx
.text$mn:000032A9                 call    ??$_Uninitialized_move@PAPAVDockingSplitter@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z ; std::_Uninitialized_move<DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)
.text$mn:000032AE                 add     esp, 10h
.text$mn:000032B1                 mov     esp, ebp
.text$mn:000032B3                 pop     ebp
.text$mn:000032B4                 retn    0Ch
.text$mn:000032B4 ??$_Umove@PAPAVDockingSplitter@@@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEPAPAVDockingSplitter@@PAPAV2@00@Z endp
.text$mn:000032B4
.text$mn:000032B4 ; ---------------------------------------------------------------------------
.text$mn:000032B7                 align 4
.text$mn:000032B7 _text$mn        ends
.text$mn:000032B7
.text$mn:000032B8 ; ===========================================================================
.text$mn:000032B8
.text$mn:000032B8 ; Segment type: Pure code
.text$mn:000032B8 ; Segment permissions: Read/Execute
.text$mn:000032B8 _text$mn        segment para public 'CODE' use32
.text$mn:000032B8                 assume cs:_text$mn
.text$mn:000032B8                 ;org 32B8h
.text$mn:000032B8 ; COMDAT (pick any)
.text$mn:000032B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032B8
.text$mn:000032B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000032B8
.text$mn:000032B8 ; Attributes: bp-based frame
.text$mn:000032B8
.text$mn:000032B8 ; struct HWND__ * * __cdecl std::_Unchecked<struct HWND__ * *>(struct HWND__ * *)
.text$mn:000032B8                 public ??$_Unchecked@PAPAUHWND__@@@std@@YAPAPAUHWND__@@PAPAU1@@Z
.text$mn:000032B8 ??$_Unchecked@PAPAUHWND__@@@std@@YAPAPAUHWND__@@PAPAU1@@Z proc near
.text$mn:000032B8                                         ; CODE XREF: std::_Uninitialized_move<HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)+Bp
.text$mn:000032B8                                         ; std::_Uninitialized_move<HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)+18p ...
.text$mn:000032B8
.text$mn:000032B8 arg_0           = dword ptr  8
.text$mn:000032B8
.text$mn:000032B8                 push    ebp
.text$mn:000032B9                 mov     ebp, esp
.text$mn:000032BB                 mov     eax, [ebp+arg_0]
.text$mn:000032BE                 pop     ebp
.text$mn:000032BF                 retn
.text$mn:000032BF ??$_Unchecked@PAPAUHWND__@@@std@@YAPAPAUHWND__@@PAPAU1@@Z endp
.text$mn:000032BF
.text$mn:000032BF _text$mn        ends
.text$mn:000032BF
.text$mn:000032C0 ; ===========================================================================
.text$mn:000032C0
.text$mn:000032C0 ; Segment type: Pure code
.text$mn:000032C0 ; Segment permissions: Read/Execute
.text$mn:000032C0 _text$mn        segment para public 'CODE' use32
.text$mn:000032C0                 assume cs:_text$mn
.text$mn:000032C0                 ;org 32C0h
.text$mn:000032C0 ; COMDAT (pick any)
.text$mn:000032C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032C0
.text$mn:000032C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000032C0
.text$mn:000032C0 ; Attributes: bp-based frame
.text$mn:000032C0
.text$mn:000032C0 ; struct tTbData * * __cdecl std::_Unchecked<struct tTbData * *>(struct tTbData * *)
.text$mn:000032C0                 public ??$_Unchecked@PAPAUtTbData@@@std@@YAPAPAUtTbData@@PAPAU1@@Z
.text$mn:000032C0 ??$_Unchecked@PAPAUtTbData@@@std@@YAPAPAUtTbData@@PAPAU1@@Z proc near
.text$mn:000032C0                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)+34p
.text$mn:000032C0
.text$mn:000032C0 arg_0           = dword ptr  8
.text$mn:000032C0
.text$mn:000032C0                 push    ebp
.text$mn:000032C1                 mov     ebp, esp
.text$mn:000032C3                 mov     eax, [ebp+arg_0]
.text$mn:000032C6                 pop     ebp
.text$mn:000032C7                 retn
.text$mn:000032C7 ??$_Unchecked@PAPAUtTbData@@@std@@YAPAPAUtTbData@@PAPAU1@@Z endp
.text$mn:000032C7
.text$mn:000032C7 _text$mn        ends
.text$mn:000032C7
.text$mn:000032C8 ; ===========================================================================
.text$mn:000032C8
.text$mn:000032C8 ; Segment type: Pure code
.text$mn:000032C8 ; Segment permissions: Read/Execute
.text$mn:000032C8 _text$mn        segment para public 'CODE' use32
.text$mn:000032C8                 assume cs:_text$mn
.text$mn:000032C8                 ;org 32C8h
.text$mn:000032C8 ; COMDAT (pick any)
.text$mn:000032C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032C8
.text$mn:000032C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000032C8
.text$mn:000032C8 ; Attributes: bp-based frame
.text$mn:000032C8
.text$mn:000032C8 ; class DockingCont * * __cdecl std::_Unchecked<class DockingCont * *>(class DockingCont * *)
.text$mn:000032C8                 public ??$_Unchecked@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z
.text$mn:000032C8 ??$_Unchecked@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z proc near
.text$mn:000032C8                                         ; CODE XREF: std::_Uninitialized_move<DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+Bp
.text$mn:000032C8                                         ; std::_Uninitialized_move<DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+18p ...
.text$mn:000032C8
.text$mn:000032C8 arg_0           = dword ptr  8
.text$mn:000032C8
.text$mn:000032C8                 push    ebp
.text$mn:000032C9                 mov     ebp, esp
.text$mn:000032CB                 mov     eax, [ebp+arg_0]
.text$mn:000032CE                 pop     ebp
.text$mn:000032CF                 retn
.text$mn:000032CF ??$_Unchecked@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z endp
.text$mn:000032CF
.text$mn:000032CF _text$mn        ends
.text$mn:000032CF
.text$mn:000032D0 ; ===========================================================================
.text$mn:000032D0
.text$mn:000032D0 ; Segment type: Pure code
.text$mn:000032D0 ; Segment permissions: Read/Execute
.text$mn:000032D0 _text$mn        segment para public 'CODE' use32
.text$mn:000032D0                 assume cs:_text$mn
.text$mn:000032D0                 ;org 32D0h
.text$mn:000032D0 ; COMDAT (pick any)
.text$mn:000032D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032D0
.text$mn:000032D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000032D0
.text$mn:000032D0 ; Attributes: bp-based frame
.text$mn:000032D0
.text$mn:000032D0 ; class DockingSplitter * * __cdecl std::_Unchecked<class DockingSplitter * *>(class DockingSplitter * *)
.text$mn:000032D0                 public ??$_Unchecked@PAPAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@PAPAV1@@Z
.text$mn:000032D0 ??$_Unchecked@PAPAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@PAPAV1@@Z proc near
.text$mn:000032D0                                         ; CODE XREF: std::_Uninitialized_move<DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)+Bp
.text$mn:000032D0                                         ; std::_Uninitialized_move<DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)+18p ...
.text$mn:000032D0
.text$mn:000032D0 arg_0           = dword ptr  8
.text$mn:000032D0
.text$mn:000032D0                 push    ebp
.text$mn:000032D1                 mov     ebp, esp
.text$mn:000032D3                 mov     eax, [ebp+arg_0]
.text$mn:000032D6                 pop     ebp
.text$mn:000032D7                 retn
.text$mn:000032D7 ??$_Unchecked@PAPAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@PAPAV1@@Z endp
.text$mn:000032D7
.text$mn:000032D7 _text$mn        ends
.text$mn:000032D7
.text$mn:000032D8 ; ===========================================================================
.text$mn:000032D8
.text$mn:000032D8 ; Segment type: Pure code
.text$mn:000032D8 ; Segment permissions: Read/Execute
.text$mn:000032D8 _text$mn        segment para public 'CODE' use32
.text$mn:000032D8                 assume cs:_text$mn
.text$mn:000032D8                 ;org 32D8h
.text$mn:000032D8 ; COMDAT (pick any)
.text$mn:000032D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032D8
.text$mn:000032D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000032D8
.text$mn:000032D8 ; Attributes: bp-based frame
.text$mn:000032D8
.text$mn:000032D8 ; struct tTbData * const * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>)
.text$mn:000032D8                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z
.text$mn:000032D8 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z proc near
.text$mn:000032D8                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)+5Fp
.text$mn:000032D8                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)+90p
.text$mn:000032D8
.text$mn:000032D8 var_10          = dword ptr -10h
.text$mn:000032D8 var_C           = dword ptr -0Ch
.text$mn:000032D8 var_4           = dword ptr -4
.text$mn:000032D8 arg_0           = byte ptr  8
.text$mn:000032D8
.text$mn:000032D8                 push    ebp
.text$mn:000032D9                 mov     ebp, esp
.text$mn:000032DB                 push    0FFFFFFFFh
.text$mn:000032DD                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z
.text$mn:000032E2                 mov     eax, large fs:0
.text$mn:000032E8                 push    eax
.text$mn:000032E9                 push    ecx
.text$mn:000032EA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000032EF                 xor     eax, ebp
.text$mn:000032F1                 push    eax
.text$mn:000032F2                 lea     eax, [ebp+var_C]
.text$mn:000032F5                 mov     large fs:0, eax
.text$mn:000032FB                 mov     [ebp+var_4], 0
.text$mn:00003302                 lea     ecx, [ebp+arg_0]
.text$mn:00003305                 call    ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QBEPBQAUtTbData@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Unchecked(void)
.text$mn:0000330A                 mov     [ebp+var_10], eax
.text$mn:0000330D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003314                 lea     ecx, [ebp+arg_0]
.text$mn:00003317                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$mn:0000331C                 mov     eax, [ebp+var_10]
.text$mn:0000331F                 mov     ecx, [ebp+var_C]
.text$mn:00003322                 mov     large fs:0, ecx
.text$mn:00003329                 pop     ecx
.text$mn:0000332A                 mov     esp, ebp
.text$mn:0000332C                 pop     ebp
.text$mn:0000332D                 retn
.text$mn:0000332D ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z endp
.text$mn:0000332D
.text$mn:0000332D ; ---------------------------------------------------------------------------
.text$mn:0000332E                 align 10h
.text$mn:0000332E _text$mn        ends
.text$mn:0000332E
.text$x:00003330 ; ===========================================================================
.text$x:00003330
.text$x:00003330 ; Segment type: Pure code
.text$x:00003330 ; Segment permissions: Read/Execute
.text$x:00003330 _text$x         segment para public 'CODE' use32
.text$x:00003330                 assume cs:_text$x
.text$x:00003330                 ;org 3330h
.text$x:00003330 ; COMDAT (pick associative to section at 32D8)
.text$x:00003330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003330
.text$x:00003330 ; =============== S U B R O U T I N E =======================================
.text$x:00003330
.text$x:00003330
.text$x:00003330 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z$0 proc near
.text$x:00003330                                         ; DATA XREF: .xdata$x:00009AD4o
.text$x:00003330                 lea     ecx, [ebp+8]
.text$x:00003333                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:00003333 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z$0 endp
.text$x:00003333
.text$x:00003338
.text$x:00003338 ; =============== S U B R O U T I N E =======================================
.text$x:00003338
.text$x:00003338
.text$x:00003338 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z proc near
.text$x:00003338                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>)+5o
.text$x:00003338
.text$x:00003338 arg_4           = dword ptr  8
.text$x:00003338
.text$x:00003338                 mov     edx, [esp+arg_4]
.text$x:0000333C                 lea     eax, [edx+0Ch]
.text$x:0000333F                 mov     ecx, [edx-8]
.text$x:00003342                 xor     ecx, eax
.text$x:00003344                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003349                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z
.text$x:0000334E                 jmp     ___CxxFrameHandler3
.text$x:0000334E __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z endp
.text$x:0000334E
.text$x:0000334E ; ---------------------------------------------------------------------------
.text$x:00003353                 align 4
.text$x:00003353 _text$x         ends
.text$x:00003353
.text$mn:00003354 ; ===========================================================================
.text$mn:00003354
.text$mn:00003354 ; Segment type: Pure code
.text$mn:00003354 ; Segment permissions: Read/Execute
.text$mn:00003354 _text$mn        segment para public 'CODE' use32
.text$mn:00003354                 assume cs:_text$mn
.text$mn:00003354                 ;org 3354h
.text$mn:00003354 ; COMDAT (pick any)
.text$mn:00003354                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003354
.text$mn:00003354 ; =============== S U B R O U T I N E =======================================
.text$mn:00003354
.text$mn:00003354 ; Attributes: bp-based frame
.text$mn:00003354
.text$mn:00003354 ; int __cdecl std::_Uninit_copy<tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(void *Src, int, void *Dst, int)
.text$mn:00003354                 public ??$_Uninit_copy@PBQAUtTbData@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAPAPAUtTbData@@PBQAU1@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z
.text$mn:00003354 ??$_Uninit_copy@PBQAUtTbData@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAPAPAUtTbData@@PBQAU1@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z proc near
.text$mn:00003354                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)+9Fp
.text$mn:00003354
.text$mn:00003354 var_1           = byte ptr -1
.text$mn:00003354 Src             = dword ptr  8
.text$mn:00003354 arg_4           = dword ptr  0Ch
.text$mn:00003354 Dst             = dword ptr  10h
.text$mn:00003354 arg_C           = dword ptr  14h
.text$mn:00003354
.text$mn:00003354                 push    ebp
.text$mn:00003355                 mov     ebp, esp
.text$mn:00003357                 push    ecx
.text$mn:00003358                 mov     eax, [ebp+Dst]
.text$mn:0000335B                 push    eax
.text$mn:0000335C                 mov     ecx, [ebp+Src]
.text$mn:0000335F                 push    ecx
.text$mn:00003360                 call    ??$_Ptr_cat@PAUtTbData@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAUtTbData@@PAPAU2@@Z ; std::_Ptr_cat<tTbData *,tTbData *>(tTbData * const *,tTbData * *)
.text$mn:00003365                 add     esp, 8
.text$mn:00003368                 mov     [ebp+var_1], al
.text$mn:0000336B                 movzx   edx, [ebp+var_1]
.text$mn:0000336F                 push    edx
.text$mn:00003370                 mov     eax, [ebp+arg_C]
.text$mn:00003373                 push    eax
.text$mn:00003374                 mov     ecx, [ebp+Dst]
.text$mn:00003377                 push    ecx             ; Dst
.text$mn:00003378                 mov     edx, [ebp+arg_4]
.text$mn:0000337B                 push    edx             ; int
.text$mn:0000337C                 mov     eax, [ebp+Src]
.text$mn:0000337F                 push    eax             ; Src
.text$mn:00003380                 call    ??$_Uninit_copy@QAUtTbData@@PAU1@@std@@YAPAPAUtTbData@@PBQAU1@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<tTbData * const,tTbData *>(tTbData * const *,tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00003385                 add     esp, 14h
.text$mn:00003388                 mov     esp, ebp
.text$mn:0000338A                 pop     ebp
.text$mn:0000338B                 retn
.text$mn:0000338B ??$_Uninit_copy@PBQAUtTbData@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAPAPAUtTbData@@PBQAU1@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z endp
.text$mn:0000338B
.text$mn:0000338B _text$mn        ends
.text$mn:0000338B
.text$mn:0000338C ; ===========================================================================
.text$mn:0000338C
.text$mn:0000338C ; Segment type: Pure code
.text$mn:0000338C ; Segment permissions: Read/Execute
.text$mn:0000338C _text$mn        segment para public 'CODE' use32
.text$mn:0000338C                 assume cs:_text$mn
.text$mn:0000338C                 ;org 338Ch
.text$mn:0000338C ; COMDAT (pick any)
.text$mn:0000338C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000338C
.text$mn:0000338C ; =============== S U B R O U T I N E =======================================
.text$mn:0000338C
.text$mn:0000338C ; Attributes: bp-based frame
.text$mn:0000338C
.text$mn:0000338C ; int __cdecl std::_Uninit_copy<tTbData * const,tTbData *>(void *Src, int, void *Dst)
.text$mn:0000338C                 public ??$_Uninit_copy@QAUtTbData@@PAU1@@std@@YAPAPAUtTbData@@PBQAU1@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:0000338C ??$_Uninit_copy@QAUtTbData@@PAU1@@std@@YAPAPAUtTbData@@PBQAU1@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000338C                                         ; CODE XREF: std::_Uninit_copy<tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(tTbData * const *,tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)+2Cp
.text$mn:0000338C
.text$mn:0000338C var_4           = dword ptr -4
.text$mn:0000338C Src             = dword ptr  8
.text$mn:0000338C arg_4           = dword ptr  0Ch
.text$mn:0000338C Dst             = dword ptr  10h
.text$mn:0000338C
.text$mn:0000338C                 push    ebp
.text$mn:0000338D                 mov     ebp, esp
.text$mn:0000338F                 push    ecx
.text$mn:00003390                 push    192h            ; unsigned int
.text$mn:00003395                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000339A                 mov     eax, [ebp+arg_4]
.text$mn:0000339D                 push    eax             ; int
.text$mn:0000339E                 mov     ecx, [ebp+Src]
.text$mn:000033A1                 push    ecx             ; int
.text$mn:000033A2                 call    ??$_Debug_range@PBQAUtTbData@@@std@@YAXPBQAUtTbData@@0PB_WI@Z ; std::_Debug_range<tTbData * const *>(tTbData * const *,tTbData * const *,wchar_t const *,uint)
.text$mn:000033A7                 add     esp, 10h
.text$mn:000033AA                 push    193h            ; unsigned int
.text$mn:000033AF                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000033B4                 mov     edx, [ebp+Dst]
.text$mn:000033B7                 push    edx             ; int
.text$mn:000033B8                 call    ??$_Debug_pointer@PAUtTbData@@@std@@YAXPAPAUtTbData@@PB_WI@Z ; std::_Debug_pointer<tTbData *>(tTbData * *,wchar_t const *,uint)
.text$mn:000033BD                 add     esp, 0Ch
.text$mn:000033C0                 mov     eax, [ebp+arg_4]
.text$mn:000033C3                 sub     eax, [ebp+Src]
.text$mn:000033C6                 sar     eax, 2
.text$mn:000033C9                 mov     [ebp+var_4], eax
.text$mn:000033CC                 mov     ecx, [ebp+var_4]
.text$mn:000033CF                 shl     ecx, 2
.text$mn:000033D2                 push    ecx             ; Size
.text$mn:000033D3                 mov     edx, [ebp+Src]
.text$mn:000033D6                 push    edx             ; Src
.text$mn:000033D7                 mov     eax, [ebp+Dst]
.text$mn:000033DA                 push    eax             ; Dst
.text$mn:000033DB                 call    _memmove
.text$mn:000033E0                 add     esp, 0Ch
.text$mn:000033E3                 mov     ecx, [ebp+var_4]
.text$mn:000033E6                 lea     eax, [eax+ecx*4]
.text$mn:000033E9                 mov     esp, ebp
.text$mn:000033EB                 pop     ebp
.text$mn:000033EC                 retn
.text$mn:000033EC ??$_Uninit_copy@QAUtTbData@@PAU1@@std@@YAPAPAUtTbData@@PBQAU1@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:000033EC
.text$mn:000033EC ; ---------------------------------------------------------------------------
.text$mn:000033ED                 align 10h
.text$mn:000033ED _text$mn        ends
.text$mn:000033ED
.text$mn:000033F0 ; ===========================================================================
.text$mn:000033F0
.text$mn:000033F0 ; Segment type: Pure code
.text$mn:000033F0 ; Segment permissions: Read/Execute
.text$mn:000033F0 _text$mn        segment para public 'CODE' use32
.text$mn:000033F0                 assume cs:_text$mn
.text$mn:000033F0                 ;org 33F0h
.text$mn:000033F0 ; COMDAT (pick any)
.text$mn:000033F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033F0
.text$mn:000033F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000033F0
.text$mn:000033F0 ; Attributes: bp-based frame
.text$mn:000033F0
.text$mn:000033F0 ; int __cdecl std::_Uninit_move<HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>>>(void *Src, int, void *Dst, int)
.text$mn:000033F0                 public ??$_Uninit_move@PAPAUHWND__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z
.text$mn:000033F0 ??$_Uninit_move@PAPAUHWND__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z proc near
.text$mn:000033F0                                         ; CODE XREF: std::_Uninitialized_move<HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)+2Ep
.text$mn:000033F0
.text$mn:000033F0 var_1           = byte ptr -1
.text$mn:000033F0 Src             = dword ptr  8
.text$mn:000033F0 arg_4           = dword ptr  0Ch
.text$mn:000033F0 Dst             = dword ptr  10h
.text$mn:000033F0 arg_C           = dword ptr  14h
.text$mn:000033F0
.text$mn:000033F0                 push    ebp
.text$mn:000033F1                 mov     ebp, esp
.text$mn:000033F3                 push    ecx
.text$mn:000033F4                 mov     eax, [ebp+Dst]
.text$mn:000033F7                 push    eax
.text$mn:000033F8                 mov     ecx, [ebp+Src]
.text$mn:000033FB                 push    ecx
.text$mn:000033FC                 call    ??$_Ptr_cat@PAUHWND__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHWND__@@0@Z ; std::_Ptr_cat<HWND__ *,HWND__ *>(HWND__ * *,HWND__ * *)
.text$mn:00003401                 add     esp, 8
.text$mn:00003404                 mov     [ebp+var_1], al
.text$mn:00003407                 movzx   edx, [ebp+var_1]
.text$mn:0000340B                 push    edx
.text$mn:0000340C                 mov     eax, [ebp+Src]
.text$mn:0000340F                 push    eax
.text$mn:00003410                 call    ??$_Val_type@PAPAUHWND__@@@std@@YAPAPAUHWND__@@PAPAU1@@Z ; std::_Val_type<HWND__ * *>(HWND__ * *)
.text$mn:00003415                 add     esp, 4
.text$mn:00003418                 push    eax
.text$mn:00003419                 mov     ecx, [ebp+arg_C]
.text$mn:0000341C                 push    ecx
.text$mn:0000341D                 mov     edx, [ebp+Dst]
.text$mn:00003420                 push    edx             ; Dst
.text$mn:00003421                 mov     eax, [ebp+arg_4]
.text$mn:00003424                 push    eax             ; int
.text$mn:00003425                 mov     ecx, [ebp+Src]
.text$mn:00003428                 push    ecx             ; Src
.text$mn:00003429                 call    ??$_Uninit_move@PAUHWND__@@PAU1@PAU1@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<HWND__ *,HWND__ *,HWND__ *>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &,HWND__ * *,std::_Scalar_ptr_iterator_tag)
.text$mn:0000342E                 add     esp, 18h
.text$mn:00003431                 mov     esp, ebp
.text$mn:00003433                 pop     ebp
.text$mn:00003434                 retn
.text$mn:00003434 ??$_Uninit_move@PAPAUHWND__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z endp
.text$mn:00003434
.text$mn:00003434 ; ---------------------------------------------------------------------------
.text$mn:00003435                 align 4
.text$mn:00003435 _text$mn        ends
.text$mn:00003435
.text$mn:00003438 ; ===========================================================================
.text$mn:00003438
.text$mn:00003438 ; Segment type: Pure code
.text$mn:00003438 ; Segment permissions: Read/Execute
.text$mn:00003438 _text$mn        segment para public 'CODE' use32
.text$mn:00003438                 assume cs:_text$mn
.text$mn:00003438                 ;org 3438h
.text$mn:00003438 ; COMDAT (pick any)
.text$mn:00003438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003438
.text$mn:00003438 ; =============== S U B R O U T I N E =======================================
.text$mn:00003438
.text$mn:00003438 ; Attributes: bp-based frame
.text$mn:00003438
.text$mn:00003438 ; int __cdecl std::_Uninit_move<DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(void *Src, int, void *Dst, int)
.text$mn:00003438                 public ??$_Uninit_move@PAPAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z
.text$mn:00003438 ??$_Uninit_move@PAPAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z proc near
.text$mn:00003438                                         ; CODE XREF: std::_Uninitialized_move<DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+2Ep
.text$mn:00003438
.text$mn:00003438 var_1           = byte ptr -1
.text$mn:00003438 Src             = dword ptr  8
.text$mn:00003438 arg_4           = dword ptr  0Ch
.text$mn:00003438 Dst             = dword ptr  10h
.text$mn:00003438 arg_C           = dword ptr  14h
.text$mn:00003438
.text$mn:00003438                 push    ebp
.text$mn:00003439                 mov     ebp, esp
.text$mn:0000343B                 push    ecx
.text$mn:0000343C                 mov     eax, [ebp+Dst]
.text$mn:0000343F                 push    eax
.text$mn:00003440                 mov     ecx, [ebp+Src]
.text$mn:00003443                 push    ecx
.text$mn:00003444                 call    ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingCont@@0@Z ; std::_Ptr_cat<DockingCont *,DockingCont *>(DockingCont * *,DockingCont * *)
.text$mn:00003449                 add     esp, 8
.text$mn:0000344C                 mov     [ebp+var_1], al
.text$mn:0000344F                 movzx   edx, [ebp+var_1]
.text$mn:00003453                 push    edx
.text$mn:00003454                 mov     eax, [ebp+Src]
.text$mn:00003457                 push    eax
.text$mn:00003458                 call    ??$_Val_type@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z ; std::_Val_type<DockingCont * *>(DockingCont * *)
.text$mn:0000345D                 add     esp, 4
.text$mn:00003460                 push    eax
.text$mn:00003461                 mov     ecx, [ebp+arg_C]
.text$mn:00003464                 push    ecx
.text$mn:00003465                 mov     edx, [ebp+Dst]
.text$mn:00003468                 push    edx             ; Dst
.text$mn:00003469                 mov     eax, [ebp+arg_4]
.text$mn:0000346C                 push    eax             ; int
.text$mn:0000346D                 mov     ecx, [ebp+Src]
.text$mn:00003470                 push    ecx             ; Src
.text$mn:00003471                 call    ??$_Uninit_move@PAVDockingCont@@PAV1@PAV1@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<DockingCont *,DockingCont *,DockingCont *>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &,DockingCont * *,std::_Scalar_ptr_iterator_tag)
.text$mn:00003476                 add     esp, 18h
.text$mn:00003479                 mov     esp, ebp
.text$mn:0000347B                 pop     ebp
.text$mn:0000347C                 retn
.text$mn:0000347C ??$_Uninit_move@PAPAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z endp
.text$mn:0000347C
.text$mn:0000347C ; ---------------------------------------------------------------------------
.text$mn:0000347D                 align 10h
.text$mn:0000347D _text$mn        ends
.text$mn:0000347D
.text$mn:00003480 ; ===========================================================================
.text$mn:00003480
.text$mn:00003480 ; Segment type: Pure code
.text$mn:00003480 ; Segment permissions: Read/Execute
.text$mn:00003480 _text$mn        segment para public 'CODE' use32
.text$mn:00003480                 assume cs:_text$mn
.text$mn:00003480                 ;org 3480h
.text$mn:00003480 ; COMDAT (pick any)
.text$mn:00003480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003480
.text$mn:00003480 ; =============== S U B R O U T I N E =======================================
.text$mn:00003480
.text$mn:00003480 ; Attributes: bp-based frame
.text$mn:00003480
.text$mn:00003480 ; int __cdecl std::_Uninit_move<DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(void *Src, int, void *Dst, int)
.text$mn:00003480                 public ??$_Uninit_move@PAPAVDockingSplitter@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z
.text$mn:00003480 ??$_Uninit_move@PAPAVDockingSplitter@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z proc near
.text$mn:00003480                                         ; CODE XREF: std::_Uninitialized_move<DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)+2Ep
.text$mn:00003480
.text$mn:00003480 var_1           = byte ptr -1
.text$mn:00003480 Src             = dword ptr  8
.text$mn:00003480 arg_4           = dword ptr  0Ch
.text$mn:00003480 Dst             = dword ptr  10h
.text$mn:00003480 arg_C           = dword ptr  14h
.text$mn:00003480
.text$mn:00003480                 push    ebp
.text$mn:00003481                 mov     ebp, esp
.text$mn:00003483                 push    ecx
.text$mn:00003484                 mov     eax, [ebp+Dst]
.text$mn:00003487                 push    eax
.text$mn:00003488                 mov     ecx, [ebp+Src]
.text$mn:0000348B                 push    ecx
.text$mn:0000348C                 call    ??$_Ptr_cat@PAVDockingSplitter@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingSplitter@@0@Z ; std::_Ptr_cat<DockingSplitter *,DockingSplitter *>(DockingSplitter * *,DockingSplitter * *)
.text$mn:00003491                 add     esp, 8
.text$mn:00003494                 mov     [ebp+var_1], al
.text$mn:00003497                 movzx   edx, [ebp+var_1]
.text$mn:0000349B                 push    edx
.text$mn:0000349C                 mov     eax, [ebp+Src]
.text$mn:0000349F                 push    eax
.text$mn:000034A0                 call    ??$_Val_type@PAPAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@PAPAV1@@Z ; std::_Val_type<DockingSplitter * *>(DockingSplitter * *)
.text$mn:000034A5                 add     esp, 4
.text$mn:000034A8                 push    eax
.text$mn:000034A9                 mov     ecx, [ebp+arg_C]
.text$mn:000034AC                 push    ecx
.text$mn:000034AD                 mov     edx, [ebp+Dst]
.text$mn:000034B0                 push    edx             ; Dst
.text$mn:000034B1                 mov     eax, [ebp+arg_4]
.text$mn:000034B4                 push    eax             ; int
.text$mn:000034B5                 mov     ecx, [ebp+Src]
.text$mn:000034B8                 push    ecx             ; Src
.text$mn:000034B9                 call    ??$_Uninit_move@PAVDockingSplitter@@PAV1@PAV1@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<DockingSplitter *,DockingSplitter *,DockingSplitter *>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &,DockingSplitter * *,std::_Scalar_ptr_iterator_tag)
.text$mn:000034BE                 add     esp, 18h
.text$mn:000034C1                 mov     esp, ebp
.text$mn:000034C3                 pop     ebp
.text$mn:000034C4                 retn
.text$mn:000034C4 ??$_Uninit_move@PAPAVDockingSplitter@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z endp
.text$mn:000034C4
.text$mn:000034C4 ; ---------------------------------------------------------------------------
.text$mn:000034C5                 align 4
.text$mn:000034C5 _text$mn        ends
.text$mn:000034C5
.text$mn:000034C8 ; ===========================================================================
.text$mn:000034C8
.text$mn:000034C8 ; Segment type: Pure code
.text$mn:000034C8 ; Segment permissions: Read/Execute
.text$mn:000034C8 _text$mn        segment para public 'CODE' use32
.text$mn:000034C8                 assume cs:_text$mn
.text$mn:000034C8                 ;org 34C8h
.text$mn:000034C8 ; COMDAT (pick any)
.text$mn:000034C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034C8
.text$mn:000034C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000034C8
.text$mn:000034C8 ; Attributes: bp-based frame
.text$mn:000034C8
.text$mn:000034C8 ; int __cdecl std::_Uninit_move<HWND__ *,HWND__ *,HWND__ *>(void *Src, int, void *Dst)
.text$mn:000034C8                 public ??$_Uninit_move@PAUHWND__@@PAU1@PAU1@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:000034C8 ??$_Uninit_move@PAUHWND__@@PAU1@PAU1@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000034C8                                         ; CODE XREF: std::_Uninit_move<HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)+39p
.text$mn:000034C8
.text$mn:000034C8 var_4           = dword ptr -4
.text$mn:000034C8 Src             = dword ptr  8
.text$mn:000034C8 arg_4           = dword ptr  0Ch
.text$mn:000034C8 Dst             = dword ptr  10h
.text$mn:000034C8
.text$mn:000034C8                 push    ebp
.text$mn:000034C9                 mov     ebp, esp
.text$mn:000034CB                 push    ecx
.text$mn:000034CC                 push    1D6h            ; unsigned int
.text$mn:000034D1                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000034D6                 mov     eax, [ebp+arg_4]
.text$mn:000034D9                 push    eax             ; int
.text$mn:000034DA                 mov     ecx, [ebp+Src]
.text$mn:000034DD                 push    ecx             ; int
.text$mn:000034DE                 call    ??$_Debug_range@PAPAUHWND__@@@std@@YAXPAPAUHWND__@@0PB_WI@Z ; std::_Debug_range<HWND__ * *>(HWND__ * *,HWND__ * *,wchar_t const *,uint)
.text$mn:000034E3                 add     esp, 10h
.text$mn:000034E6                 push    1D7h            ; unsigned int
.text$mn:000034EB                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000034F0                 mov     edx, [ebp+Dst]
.text$mn:000034F3                 push    edx             ; int
.text$mn:000034F4                 call    ??$_Debug_pointer@PAUHWND__@@@std@@YAXPAPAUHWND__@@PB_WI@Z ; std::_Debug_pointer<HWND__ *>(HWND__ * *,wchar_t const *,uint)
.text$mn:000034F9                 add     esp, 0Ch
.text$mn:000034FC                 mov     eax, [ebp+arg_4]
.text$mn:000034FF                 sub     eax, [ebp+Src]
.text$mn:00003502                 sar     eax, 2
.text$mn:00003505                 mov     [ebp+var_4], eax
.text$mn:00003508                 mov     ecx, [ebp+var_4]
.text$mn:0000350B                 shl     ecx, 2
.text$mn:0000350E                 push    ecx             ; Size
.text$mn:0000350F                 mov     edx, [ebp+Src]
.text$mn:00003512                 push    edx             ; Src
.text$mn:00003513                 mov     eax, [ebp+Dst]
.text$mn:00003516                 push    eax             ; Dst
.text$mn:00003517                 call    _memmove
.text$mn:0000351C                 add     esp, 0Ch
.text$mn:0000351F                 mov     ecx, [ebp+var_4]
.text$mn:00003522                 lea     eax, [eax+ecx*4]
.text$mn:00003525                 mov     esp, ebp
.text$mn:00003527                 pop     ebp
.text$mn:00003528                 retn
.text$mn:00003528 ??$_Uninit_move@PAUHWND__@@PAU1@PAU1@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003528
.text$mn:00003528 ; ---------------------------------------------------------------------------
.text$mn:00003529                 align 4
.text$mn:00003529 _text$mn        ends
.text$mn:00003529
.text$mn:0000352C ; ===========================================================================
.text$mn:0000352C
.text$mn:0000352C ; Segment type: Pure code
.text$mn:0000352C ; Segment permissions: Read/Execute
.text$mn:0000352C _text$mn        segment para public 'CODE' use32
.text$mn:0000352C                 assume cs:_text$mn
.text$mn:0000352C                 ;org 352Ch
.text$mn:0000352C ; COMDAT (pick any)
.text$mn:0000352C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000352C
.text$mn:0000352C ; =============== S U B R O U T I N E =======================================
.text$mn:0000352C
.text$mn:0000352C ; Attributes: bp-based frame
.text$mn:0000352C
.text$mn:0000352C ; int __cdecl std::_Uninit_move<DockingCont *,DockingCont *,DockingCont *>(void *Src, int, void *Dst)
.text$mn:0000352C                 public ??$_Uninit_move@PAVDockingCont@@PAV1@PAV1@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:0000352C ??$_Uninit_move@PAVDockingCont@@PAV1@PAV1@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000352C                                         ; CODE XREF: std::_Uninit_move<DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+39p
.text$mn:0000352C
.text$mn:0000352C var_4           = dword ptr -4
.text$mn:0000352C Src             = dword ptr  8
.text$mn:0000352C arg_4           = dword ptr  0Ch
.text$mn:0000352C Dst             = dword ptr  10h
.text$mn:0000352C
.text$mn:0000352C                 push    ebp
.text$mn:0000352D                 mov     ebp, esp
.text$mn:0000352F                 push    ecx
.text$mn:00003530                 push    1D6h            ; unsigned int
.text$mn:00003535                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000353A                 mov     eax, [ebp+arg_4]
.text$mn:0000353D                 push    eax             ; int
.text$mn:0000353E                 mov     ecx, [ebp+Src]
.text$mn:00003541                 push    ecx             ; int
.text$mn:00003542                 call    ??$_Debug_range@PAPAVDockingCont@@@std@@YAXPAPAVDockingCont@@0PB_WI@Z ; std::_Debug_range<DockingCont * *>(DockingCont * *,DockingCont * *,wchar_t const *,uint)
.text$mn:00003547                 add     esp, 10h
.text$mn:0000354A                 push    1D7h            ; unsigned int
.text$mn:0000354F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003554                 mov     edx, [ebp+Dst]
.text$mn:00003557                 push    edx             ; int
.text$mn:00003558                 call    ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPAPAVDockingCont@@PB_WI@Z ; std::_Debug_pointer<DockingCont *>(DockingCont * *,wchar_t const *,uint)
.text$mn:0000355D                 add     esp, 0Ch
.text$mn:00003560                 mov     eax, [ebp+arg_4]
.text$mn:00003563                 sub     eax, [ebp+Src]
.text$mn:00003566                 sar     eax, 2
.text$mn:00003569                 mov     [ebp+var_4], eax
.text$mn:0000356C                 mov     ecx, [ebp+var_4]
.text$mn:0000356F                 shl     ecx, 2
.text$mn:00003572                 push    ecx             ; Size
.text$mn:00003573                 mov     edx, [ebp+Src]
.text$mn:00003576                 push    edx             ; Src
.text$mn:00003577                 mov     eax, [ebp+Dst]
.text$mn:0000357A                 push    eax             ; Dst
.text$mn:0000357B                 call    _memmove
.text$mn:00003580                 add     esp, 0Ch
.text$mn:00003583                 mov     ecx, [ebp+var_4]
.text$mn:00003586                 lea     eax, [eax+ecx*4]
.text$mn:00003589                 mov     esp, ebp
.text$mn:0000358B                 pop     ebp
.text$mn:0000358C                 retn
.text$mn:0000358C ??$_Uninit_move@PAVDockingCont@@PAV1@PAV1@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000358C
.text$mn:0000358C ; ---------------------------------------------------------------------------
.text$mn:0000358D                 align 10h
.text$mn:0000358D _text$mn        ends
.text$mn:0000358D
.text$mn:00003590 ; ===========================================================================
.text$mn:00003590
.text$mn:00003590 ; Segment type: Pure code
.text$mn:00003590 ; Segment permissions: Read/Execute
.text$mn:00003590 _text$mn        segment para public 'CODE' use32
.text$mn:00003590                 assume cs:_text$mn
.text$mn:00003590                 ;org 3590h
.text$mn:00003590 ; COMDAT (pick any)
.text$mn:00003590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003590
.text$mn:00003590 ; =============== S U B R O U T I N E =======================================
.text$mn:00003590
.text$mn:00003590 ; Attributes: bp-based frame
.text$mn:00003590
.text$mn:00003590 ; int __cdecl std::_Uninit_move<DockingSplitter *,DockingSplitter *,DockingSplitter *>(void *Src, int, void *Dst)
.text$mn:00003590                 public ??$_Uninit_move@PAVDockingSplitter@@PAV1@PAV1@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00003590 ??$_Uninit_move@PAVDockingSplitter@@PAV1@PAV1@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003590                                         ; CODE XREF: std::_Uninit_move<DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)+39p
.text$mn:00003590
.text$mn:00003590 var_4           = dword ptr -4
.text$mn:00003590 Src             = dword ptr  8
.text$mn:00003590 arg_4           = dword ptr  0Ch
.text$mn:00003590 Dst             = dword ptr  10h
.text$mn:00003590
.text$mn:00003590                 push    ebp
.text$mn:00003591                 mov     ebp, esp
.text$mn:00003593                 push    ecx
.text$mn:00003594                 push    1D6h            ; unsigned int
.text$mn:00003599                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000359E                 mov     eax, [ebp+arg_4]
.text$mn:000035A1                 push    eax             ; int
.text$mn:000035A2                 mov     ecx, [ebp+Src]
.text$mn:000035A5                 push    ecx             ; int
.text$mn:000035A6                 call    ??$_Debug_range@PAPAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@0PB_WI@Z ; std::_Debug_range<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,wchar_t const *,uint)
.text$mn:000035AB                 add     esp, 10h
.text$mn:000035AE                 push    1D7h            ; unsigned int
.text$mn:000035B3                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000035B8                 mov     edx, [ebp+Dst]
.text$mn:000035BB                 push    edx             ; int
.text$mn:000035BC                 call    ??$_Debug_pointer@PAVDockingSplitter@@@std@@YAXPAPAVDockingSplitter@@PB_WI@Z ; std::_Debug_pointer<DockingSplitter *>(DockingSplitter * *,wchar_t const *,uint)
.text$mn:000035C1                 add     esp, 0Ch
.text$mn:000035C4                 mov     eax, [ebp+arg_4]
.text$mn:000035C7                 sub     eax, [ebp+Src]
.text$mn:000035CA                 sar     eax, 2
.text$mn:000035CD                 mov     [ebp+var_4], eax
.text$mn:000035D0                 mov     ecx, [ebp+var_4]
.text$mn:000035D3                 shl     ecx, 2
.text$mn:000035D6                 push    ecx             ; Size
.text$mn:000035D7                 mov     edx, [ebp+Src]
.text$mn:000035DA                 push    edx             ; Src
.text$mn:000035DB                 mov     eax, [ebp+Dst]
.text$mn:000035DE                 push    eax             ; Dst
.text$mn:000035DF                 call    _memmove
.text$mn:000035E4                 add     esp, 0Ch
.text$mn:000035E7                 mov     ecx, [ebp+var_4]
.text$mn:000035EA                 lea     eax, [eax+ecx*4]
.text$mn:000035ED                 mov     esp, ebp
.text$mn:000035EF                 pop     ebp
.text$mn:000035F0                 retn
.text$mn:000035F0 ??$_Uninit_move@PAVDockingSplitter@@PAV1@PAV1@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:000035F0
.text$mn:000035F0 ; ---------------------------------------------------------------------------
.text$mn:000035F1                 align 4
.text$mn:000035F1 _text$mn        ends
.text$mn:000035F1
.text$mn:000035F4 ; ===========================================================================
.text$mn:000035F4
.text$mn:000035F4 ; Segment type: Pure code
.text$mn:000035F4 ; Segment permissions: Read/Execute
.text$mn:000035F4 _text$mn        segment para public 'CODE' use32
.text$mn:000035F4                 assume cs:_text$mn
.text$mn:000035F4                 ;org 35F4h
.text$mn:000035F4 ; COMDAT (pick any)
.text$mn:000035F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035F4
.text$mn:000035F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000035F4
.text$mn:000035F4 ; Attributes: bp-based frame
.text$mn:000035F4
.text$mn:000035F4 ; struct tTbData * * __cdecl std::_Uninitialized_copy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>, struct tTbData * *, struct std::_Wrap_alloc<class std::allocator<struct tTbData *>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>, struct tTbData * *, struct std::_Wrap_alloc<class std::allocator<struct tTbData *>> &)
.text$mn:000035F4                 public ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z
.text$mn:000035F4 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z proc near
.text$mn:000035F4                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *)+83p
.text$mn:000035F4
.text$mn:000035F4 var_34          = dword ptr -34h
.text$mn:000035F4 var_30          = dword ptr -30h
.text$mn:000035F4 var_2C          = dword ptr -2Ch
.text$mn:000035F4 var_28          = dword ptr -28h
.text$mn:000035F4 var_24          = dword ptr -24h
.text$mn:000035F4 var_20          = dword ptr -20h
.text$mn:000035F4 Src             = dword ptr -1Ch
.text$mn:000035F4 var_18          = dword ptr -18h
.text$mn:000035F4 var_14          = dword ptr -14h
.text$mn:000035F4 var_10          = dword ptr -10h
.text$mn:000035F4 var_C           = dword ptr -0Ch
.text$mn:000035F4 var_4           = dword ptr -4
.text$mn:000035F4 arg_0           = byte ptr  8
.text$mn:000035F4 arg_C           = byte ptr  14h
.text$mn:000035F4 arg_18          = dword ptr  20h
.text$mn:000035F4 arg_1C          = dword ptr  24h
.text$mn:000035F4
.text$mn:000035F4                 push    ebp
.text$mn:000035F5                 mov     ebp, esp
.text$mn:000035F7                 push    0FFFFFFFFh
.text$mn:000035F9                 push    offset __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z
.text$mn:000035FE                 mov     eax, large fs:0
.text$mn:00003604                 push    eax
.text$mn:00003605                 sub     esp, 28h
.text$mn:00003608                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000360D                 xor     eax, ebp
.text$mn:0000360F                 push    eax
.text$mn:00003610                 lea     eax, [ebp+var_C]
.text$mn:00003613                 mov     large fs:0, eax
.text$mn:00003619                 mov     [ebp+var_4], 1
.text$mn:00003620                 mov     eax, [ebp+arg_1C]
.text$mn:00003623                 push    eax             ; int
.text$mn:00003624                 mov     ecx, [ebp+arg_18]
.text$mn:00003627                 push    ecx
.text$mn:00003628                 call    ??$_Unchecked@PAPAUtTbData@@@std@@YAPAPAUtTbData@@PAPAU1@@Z ; std::_Unchecked<tTbData * *>(tTbData * *)
.text$mn:0000362D                 add     esp, 4
.text$mn:00003630                 push    eax             ; Dst
.text$mn:00003631                 sub     esp, 0Ch
.text$mn:00003634                 mov     ecx, esp
.text$mn:00003636                 mov     [ebp+var_28], esp
.text$mn:00003639                 lea     edx, [ebp+arg_C]
.text$mn:0000363C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000363D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>> const &)
.text$mn:00003642                 mov     [ebp+var_10], eax
.text$mn:00003645                 mov     eax, [ebp+var_10]
.text$mn:00003648                 mov     [ebp+var_2C], eax
.text$mn:0000364B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000364F                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003653                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>)
.text$mn:00003658                 add     esp, 0Ch
.text$mn:0000365B                 mov     [ebp+var_14], eax
.text$mn:0000365E                 mov     ecx, [ebp+var_14]
.text$mn:00003661                 push    ecx             ; int
.text$mn:00003662                 sub     esp, 0Ch
.text$mn:00003665                 mov     ecx, esp
.text$mn:00003667                 mov     [ebp+var_30], esp
.text$mn:0000366A                 lea     edx, [ebp+arg_0]
.text$mn:0000366D                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000366E                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>> const &)
.text$mn:00003673                 mov     [ebp+var_18], eax
.text$mn:00003676                 mov     eax, [ebp+var_18]
.text$mn:00003679                 mov     [ebp+var_34], eax
.text$mn:0000367C                 mov     byte ptr [ebp+var_4], 3
.text$mn:00003680                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003684                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>)
.text$mn:00003689                 add     esp, 0Ch
.text$mn:0000368C                 mov     [ebp+Src], eax
.text$mn:0000368F                 mov     ecx, [ebp+Src]
.text$mn:00003692                 push    ecx             ; Src
.text$mn:00003693                 call    ??$_Uninit_copy@PBQAUtTbData@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAPAPAUtTbData@@PBQAU1@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z ; std::_Uninit_copy<tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(tTbData * const *,tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)
.text$mn:00003698                 add     esp, 10h
.text$mn:0000369B                 mov     [ebp+var_20], eax
.text$mn:0000369E                 mov     edx, [ebp+var_20]
.text$mn:000036A1                 push    edx
.text$mn:000036A2                 lea     eax, [ebp+arg_18]
.text$mn:000036A5                 push    eax
.text$mn:000036A6                 call    ??$_Rechecked@PAPAUtTbData@@PAPAU1@@std@@YAAAPAPAUtTbData@@AAPAPAU1@PAPAU1@@Z ; std::_Rechecked<tTbData * *,tTbData * *>(tTbData * * &,tTbData * *)
.text$mn:000036AB                 add     esp, 8
.text$mn:000036AE                 mov     ecx, [eax]
.text$mn:000036B0                 mov     [ebp+var_24], ecx
.text$mn:000036B3                 mov     byte ptr [ebp+var_4], 0
.text$mn:000036B7                 lea     ecx, [ebp+arg_0]
.text$mn:000036BA                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$mn:000036BF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000036C6                 lea     ecx, [ebp+arg_C]
.text$mn:000036C9                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$mn:000036CE                 mov     eax, [ebp+var_24]
.text$mn:000036D1                 mov     ecx, [ebp+var_C]
.text$mn:000036D4                 mov     large fs:0, ecx
.text$mn:000036DB                 pop     ecx
.text$mn:000036DC                 mov     esp, ebp
.text$mn:000036DE                 pop     ebp
.text$mn:000036DF                 retn
.text$mn:000036DF ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z endp
.text$mn:000036DF
.text$mn:000036DF _text$mn        ends
.text$mn:000036DF
.text$x:000036E0 ; ===========================================================================
.text$x:000036E0
.text$x:000036E0 ; Segment type: Pure code
.text$x:000036E0 ; Segment permissions: Read/Execute
.text$x:000036E0 _text$x         segment para public 'CODE' use32
.text$x:000036E0                 assume cs:_text$x
.text$x:000036E0                 ;org 36E0h
.text$x:000036E0 ; COMDAT (pick associative to section at 35F4)
.text$x:000036E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000036E0
.text$x:000036E0 ; =============== S U B R O U T I N E =======================================
.text$x:000036E0
.text$x:000036E0
.text$x:000036E0 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$0 proc near
.text$x:000036E0                                         ; DATA XREF: .xdata$x:00009A90o
.text$x:000036E0                 lea     ecx, [ebp+14h]
.text$x:000036E3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:000036E3 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$0 endp
.text$x:000036E3
.text$x:000036E8
.text$x:000036E8 ; =============== S U B R O U T I N E =======================================
.text$x:000036E8
.text$x:000036E8
.text$x:000036E8 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$1 proc near
.text$x:000036E8                                         ; DATA XREF: .xdata$x:00009A98o
.text$x:000036E8                 lea     ecx, [ebp+8]
.text$x:000036EB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:000036EB __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$1 endp
.text$x:000036EB
.text$x:000036F0
.text$x:000036F0 ; =============== S U B R O U T I N E =======================================
.text$x:000036F0
.text$x:000036F0
.text$x:000036F0 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$2 proc near
.text$x:000036F0                                         ; DATA XREF: .xdata$x:00009AA0o
.text$x:000036F0                 mov     ecx, [ebp-28h]
.text$x:000036F3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:000036F3 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$2 endp
.text$x:000036F3
.text$x:000036F8
.text$x:000036F8 ; =============== S U B R O U T I N E =======================================
.text$x:000036F8
.text$x:000036F8
.text$x:000036F8 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$3 proc near
.text$x:000036F8                                         ; DATA XREF: .xdata$x:00009AA8o
.text$x:000036F8                 mov     ecx, [ebp-30h]
.text$x:000036FB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:000036FB __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$3 endp
.text$x:000036FB
.text$x:00003700
.text$x:00003700 ; =============== S U B R O U T I N E =======================================
.text$x:00003700
.text$x:00003700
.text$x:00003700 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z proc near
.text$x:00003700                                         ; DATA XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)+5o
.text$x:00003700
.text$x:00003700 arg_4           = dword ptr  8
.text$x:00003700
.text$x:00003700                 mov     edx, [esp+arg_4]
.text$x:00003704                 lea     eax, [edx+0Ch]
.text$x:00003707                 mov     ecx, [edx-2Ch]
.text$x:0000370A                 xor     ecx, eax
.text$x:0000370C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003711                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z
.text$x:00003716                 jmp     ___CxxFrameHandler3
.text$x:00003716 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z endp
.text$x:00003716
.text$x:00003716 ; ---------------------------------------------------------------------------
.text$x:0000371B                 align 4
.text$x:0000371B _text$x         ends
.text$x:0000371B
.text$mn:0000371C ; ===========================================================================
.text$mn:0000371C
.text$mn:0000371C ; Segment type: Pure code
.text$mn:0000371C ; Segment permissions: Read/Execute
.text$mn:0000371C _text$mn        segment para public 'CODE' use32
.text$mn:0000371C                 assume cs:_text$mn
.text$mn:0000371C                 ;org 371Ch
.text$mn:0000371C ; COMDAT (pick any)
.text$mn:0000371C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000371C
.text$mn:0000371C ; =============== S U B R O U T I N E =======================================
.text$mn:0000371C
.text$mn:0000371C ; Attributes: bp-based frame
.text$mn:0000371C
.text$mn:0000371C ; struct HWND__ * * __cdecl std::_Uninitialized_move<struct HWND__ * *, struct HWND__ * *, struct std::_Wrap_alloc<class std::allocator<struct HWND__ *>>>(struct HWND__ * *, struct HWND__ * *, struct HWND__ * *, struct std::_Wrap_alloc<class std::allocator<struct HWND__ *>> &)
.text$mn:0000371C                 public ??$_Uninitialized_move@PAPAUHWND__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z
.text$mn:0000371C ??$_Uninitialized_move@PAPAUHWND__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z proc near
.text$mn:0000371C                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Umove<HWND__ * *>(HWND__ * *,HWND__ * *,HWND__ * *)+25p
.text$mn:0000371C
.text$mn:0000371C arg_0           = dword ptr  8
.text$mn:0000371C arg_4           = dword ptr  0Ch
.text$mn:0000371C arg_8           = dword ptr  10h
.text$mn:0000371C arg_C           = dword ptr  14h
.text$mn:0000371C
.text$mn:0000371C                 push    ebp
.text$mn:0000371D                 mov     ebp, esp
.text$mn:0000371F                 mov     eax, [ebp+arg_C]
.text$mn:00003722                 push    eax             ; int
.text$mn:00003723                 mov     ecx, [ebp+arg_8]
.text$mn:00003726                 push    ecx
.text$mn:00003727                 call    ??$_Unchecked@PAPAUHWND__@@@std@@YAPAPAUHWND__@@PAPAU1@@Z ; std::_Unchecked<HWND__ * *>(HWND__ * *)
.text$mn:0000372C                 add     esp, 4
.text$mn:0000372F                 push    eax             ; Dst
.text$mn:00003730                 mov     edx, [ebp+arg_4]
.text$mn:00003733                 push    edx
.text$mn:00003734                 call    ??$_Unchecked@PAPAUHWND__@@@std@@YAPAPAUHWND__@@PAPAU1@@Z ; std::_Unchecked<HWND__ * *>(HWND__ * *)
.text$mn:00003739                 add     esp, 4
.text$mn:0000373C                 push    eax             ; int
.text$mn:0000373D                 mov     eax, [ebp+arg_0]
.text$mn:00003740                 push    eax
.text$mn:00003741                 call    ??$_Unchecked@PAPAUHWND__@@@std@@YAPAPAUHWND__@@PAPAU1@@Z ; std::_Unchecked<HWND__ * *>(HWND__ * *)
.text$mn:00003746                 add     esp, 4
.text$mn:00003749                 push    eax             ; Src
.text$mn:0000374A                 call    ??$_Uninit_move@PAPAUHWND__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z ; std::_Uninit_move<HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)
.text$mn:0000374F                 add     esp, 10h
.text$mn:00003752                 push    eax
.text$mn:00003753                 lea     ecx, [ebp+arg_8]
.text$mn:00003756                 push    ecx
.text$mn:00003757                 call    ??$_Rechecked@PAPAUHWND__@@PAPAU1@@std@@YAAAPAPAUHWND__@@AAPAPAU1@PAPAU1@@Z ; std::_Rechecked<HWND__ * *,HWND__ * *>(HWND__ * * &,HWND__ * *)
.text$mn:0000375C                 add     esp, 8
.text$mn:0000375F                 mov     eax, [eax]
.text$mn:00003761                 pop     ebp
.text$mn:00003762                 retn
.text$mn:00003762 ??$_Uninitialized_move@PAPAUHWND__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAPAPAUHWND__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z endp
.text$mn:00003762
.text$mn:00003762 ; ---------------------------------------------------------------------------
.text$mn:00003763                 align 4
.text$mn:00003763 _text$mn        ends
.text$mn:00003763
.text$mn:00003764 ; ===========================================================================
.text$mn:00003764
.text$mn:00003764 ; Segment type: Pure code
.text$mn:00003764 ; Segment permissions: Read/Execute
.text$mn:00003764 _text$mn        segment para public 'CODE' use32
.text$mn:00003764                 assume cs:_text$mn
.text$mn:00003764                 ;org 3764h
.text$mn:00003764 ; COMDAT (pick any)
.text$mn:00003764                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003764
.text$mn:00003764 ; =============== S U B R O U T I N E =======================================
.text$mn:00003764
.text$mn:00003764 ; Attributes: bp-based frame
.text$mn:00003764
.text$mn:00003764 ; class DockingCont * * __cdecl std::_Uninitialized_move<class DockingCont * *, class DockingCont * *, struct std::_Wrap_alloc<class std::allocator<class DockingCont *>>>(class DockingCont * *, class DockingCont * *, class DockingCont * *, struct std::_Wrap_alloc<class std::allocator<class DockingCont *>> &)
.text$mn:00003764                 public ??$_Uninitialized_move@PAPAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z
.text$mn:00003764 ??$_Uninitialized_move@PAPAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z proc near
.text$mn:00003764                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Umove<DockingCont * *>(DockingCont * *,DockingCont * *,DockingCont * *)+25p
.text$mn:00003764
.text$mn:00003764 arg_0           = dword ptr  8
.text$mn:00003764 arg_4           = dword ptr  0Ch
.text$mn:00003764 arg_8           = dword ptr  10h
.text$mn:00003764 arg_C           = dword ptr  14h
.text$mn:00003764
.text$mn:00003764                 push    ebp
.text$mn:00003765                 mov     ebp, esp
.text$mn:00003767                 mov     eax, [ebp+arg_C]
.text$mn:0000376A                 push    eax             ; int
.text$mn:0000376B                 mov     ecx, [ebp+arg_8]
.text$mn:0000376E                 push    ecx
.text$mn:0000376F                 call    ??$_Unchecked@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z ; std::_Unchecked<DockingCont * *>(DockingCont * *)
.text$mn:00003774                 add     esp, 4
.text$mn:00003777                 push    eax             ; Dst
.text$mn:00003778                 mov     edx, [ebp+arg_4]
.text$mn:0000377B                 push    edx
.text$mn:0000377C                 call    ??$_Unchecked@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z ; std::_Unchecked<DockingCont * *>(DockingCont * *)
.text$mn:00003781                 add     esp, 4
.text$mn:00003784                 push    eax             ; int
.text$mn:00003785                 mov     eax, [ebp+arg_0]
.text$mn:00003788                 push    eax
.text$mn:00003789                 call    ??$_Unchecked@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z ; std::_Unchecked<DockingCont * *>(DockingCont * *)
.text$mn:0000378E                 add     esp, 4
.text$mn:00003791                 push    eax             ; Src
.text$mn:00003792                 call    ??$_Uninit_move@PAPAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z ; std::_Uninit_move<DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)
.text$mn:00003797                 add     esp, 10h
.text$mn:0000379A                 push    eax
.text$mn:0000379B                 lea     ecx, [ebp+arg_8]
.text$mn:0000379E                 push    ecx
.text$mn:0000379F                 call    ??$_Rechecked@PAPAVDockingCont@@PAPAV1@@std@@YAAAPAPAVDockingCont@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<DockingCont * *,DockingCont * *>(DockingCont * * &,DockingCont * *)
.text$mn:000037A4                 add     esp, 8
.text$mn:000037A7                 mov     eax, [eax]
.text$mn:000037A9                 pop     ebp
.text$mn:000037AA                 retn
.text$mn:000037AA ??$_Uninitialized_move@PAPAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z endp
.text$mn:000037AA
.text$mn:000037AA ; ---------------------------------------------------------------------------
.text$mn:000037AB                 align 4
.text$mn:000037AB _text$mn        ends
.text$mn:000037AB
.text$mn:000037AC ; ===========================================================================
.text$mn:000037AC
.text$mn:000037AC ; Segment type: Pure code
.text$mn:000037AC ; Segment permissions: Read/Execute
.text$mn:000037AC _text$mn        segment para public 'CODE' use32
.text$mn:000037AC                 assume cs:_text$mn
.text$mn:000037AC                 ;org 37ACh
.text$mn:000037AC ; COMDAT (pick any)
.text$mn:000037AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037AC
.text$mn:000037AC ; =============== S U B R O U T I N E =======================================
.text$mn:000037AC
.text$mn:000037AC ; Attributes: bp-based frame
.text$mn:000037AC
.text$mn:000037AC ; class DockingSplitter * * __cdecl std::_Uninitialized_move<class DockingSplitter * *, class DockingSplitter * *, struct std::_Wrap_alloc<class std::allocator<class DockingSplitter *>>>(class DockingSplitter * *, class DockingSplitter * *, class DockingSplitter * *, struct std::_Wrap_alloc<class std::allocator<class DockingSplitter *>> &)
.text$mn:000037AC                 public ??$_Uninitialized_move@PAPAVDockingSplitter@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z
.text$mn:000037AC ??$_Uninitialized_move@PAPAVDockingSplitter@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z proc near
.text$mn:000037AC                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Umove<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *)+25p
.text$mn:000037AC
.text$mn:000037AC arg_0           = dword ptr  8
.text$mn:000037AC arg_4           = dword ptr  0Ch
.text$mn:000037AC arg_8           = dword ptr  10h
.text$mn:000037AC arg_C           = dword ptr  14h
.text$mn:000037AC
.text$mn:000037AC                 push    ebp
.text$mn:000037AD                 mov     ebp, esp
.text$mn:000037AF                 mov     eax, [ebp+arg_C]
.text$mn:000037B2                 push    eax             ; int
.text$mn:000037B3                 mov     ecx, [ebp+arg_8]
.text$mn:000037B6                 push    ecx
.text$mn:000037B7                 call    ??$_Unchecked@PAPAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@PAPAV1@@Z ; std::_Unchecked<DockingSplitter * *>(DockingSplitter * *)
.text$mn:000037BC                 add     esp, 4
.text$mn:000037BF                 push    eax             ; Dst
.text$mn:000037C0                 mov     edx, [ebp+arg_4]
.text$mn:000037C3                 push    edx
.text$mn:000037C4                 call    ??$_Unchecked@PAPAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@PAPAV1@@Z ; std::_Unchecked<DockingSplitter * *>(DockingSplitter * *)
.text$mn:000037C9                 add     esp, 4
.text$mn:000037CC                 push    eax             ; int
.text$mn:000037CD                 mov     eax, [ebp+arg_0]
.text$mn:000037D0                 push    eax
.text$mn:000037D1                 call    ??$_Unchecked@PAPAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@PAPAV1@@Z ; std::_Unchecked<DockingSplitter * *>(DockingSplitter * *)
.text$mn:000037D6                 add     esp, 4
.text$mn:000037D9                 push    eax             ; Src
.text$mn:000037DA                 call    ??$_Uninit_move@PAPAVDockingSplitter@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z ; std::_Uninit_move<DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)
.text$mn:000037DF                 add     esp, 10h
.text$mn:000037E2                 push    eax
.text$mn:000037E3                 lea     ecx, [ebp+arg_8]
.text$mn:000037E6                 push    ecx
.text$mn:000037E7                 call    ??$_Rechecked@PAPAVDockingSplitter@@PAPAV1@@std@@YAAAPAPAVDockingSplitter@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<DockingSplitter * *,DockingSplitter * *>(DockingSplitter * * &,DockingSplitter * *)
.text$mn:000037EC                 add     esp, 8
.text$mn:000037EF                 mov     eax, [eax]
.text$mn:000037F1                 pop     ebp
.text$mn:000037F2                 retn
.text$mn:000037F2 ??$_Uninitialized_move@PAPAVDockingSplitter@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAPAPAVDockingSplitter@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z endp
.text$mn:000037F2
.text$mn:000037F2 ; ---------------------------------------------------------------------------
.text$mn:000037F3                 align 4
.text$mn:000037F3 _text$mn        ends
.text$mn:000037F3
.text$mn:000037F4 ; ===========================================================================
.text$mn:000037F4
.text$mn:000037F4 ; Segment type: Pure code
.text$mn:000037F4 ; Segment permissions: Read/Execute
.text$mn:000037F4 _text$mn        segment para public 'CODE' use32
.text$mn:000037F4                 assume cs:_text$mn
.text$mn:000037F4                 ;org 37F4h
.text$mn:000037F4 ; COMDAT (pick any)
.text$mn:000037F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037F4
.text$mn:000037F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000037F4
.text$mn:000037F4 ; Attributes: bp-based frame
.text$mn:000037F4
.text$mn:000037F4 ; struct HWND__ * * __cdecl std::_Val_type<struct HWND__ * *>(struct HWND__ * *)
.text$mn:000037F4                 public ??$_Val_type@PAPAUHWND__@@@std@@YAPAPAUHWND__@@PAPAU1@@Z
.text$mn:000037F4 ??$_Val_type@PAPAUHWND__@@@std@@YAPAPAUHWND__@@PAPAU1@@Z proc near
.text$mn:000037F4                                         ; CODE XREF: std::_Uninit_move<HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)+20p
.text$mn:000037F4                 push    ebp
.text$mn:000037F5                 mov     ebp, esp
.text$mn:000037F7                 xor     eax, eax
.text$mn:000037F9                 pop     ebp
.text$mn:000037FA                 retn
.text$mn:000037FA ??$_Val_type@PAPAUHWND__@@@std@@YAPAPAUHWND__@@PAPAU1@@Z endp
.text$mn:000037FA
.text$mn:000037FA ; ---------------------------------------------------------------------------
.text$mn:000037FB                 align 4
.text$mn:000037FB _text$mn        ends
.text$mn:000037FB
.text$mn:000037FC ; ===========================================================================
.text$mn:000037FC
.text$mn:000037FC ; Segment type: Pure code
.text$mn:000037FC ; Segment permissions: Read/Execute
.text$mn:000037FC _text$mn        segment para public 'CODE' use32
.text$mn:000037FC                 assume cs:_text$mn
.text$mn:000037FC                 ;org 37FCh
.text$mn:000037FC ; COMDAT (pick any)
.text$mn:000037FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037FC
.text$mn:000037FC ; =============== S U B R O U T I N E =======================================
.text$mn:000037FC
.text$mn:000037FC ; Attributes: bp-based frame
.text$mn:000037FC
.text$mn:000037FC ; class DockingCont * * __cdecl std::_Val_type<class DockingCont * *>(class DockingCont * *)
.text$mn:000037FC                 public ??$_Val_type@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z
.text$mn:000037FC ??$_Val_type@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z proc near
.text$mn:000037FC                                         ; CODE XREF: std::_Uninit_move<DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+20p
.text$mn:000037FC                 push    ebp
.text$mn:000037FD                 mov     ebp, esp
.text$mn:000037FF                 xor     eax, eax
.text$mn:00003801                 pop     ebp
.text$mn:00003802                 retn
.text$mn:00003802 ??$_Val_type@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z endp
.text$mn:00003802
.text$mn:00003802 ; ---------------------------------------------------------------------------
.text$mn:00003803                 align 4
.text$mn:00003803 _text$mn        ends
.text$mn:00003803
.text$mn:00003804 ; ===========================================================================
.text$mn:00003804
.text$mn:00003804 ; Segment type: Pure code
.text$mn:00003804 ; Segment permissions: Read/Execute
.text$mn:00003804 _text$mn        segment para public 'CODE' use32
.text$mn:00003804                 assume cs:_text$mn
.text$mn:00003804                 ;org 3804h
.text$mn:00003804 ; COMDAT (pick any)
.text$mn:00003804                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003804
.text$mn:00003804 ; =============== S U B R O U T I N E =======================================
.text$mn:00003804
.text$mn:00003804 ; Attributes: bp-based frame
.text$mn:00003804
.text$mn:00003804 ; class DockingSplitter * * __cdecl std::_Val_type<class DockingSplitter * *>(class DockingSplitter * *)
.text$mn:00003804                 public ??$_Val_type@PAPAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@PAPAV1@@Z
.text$mn:00003804 ??$_Val_type@PAPAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@PAPAV1@@Z proc near
.text$mn:00003804                                         ; CODE XREF: std::_Uninit_move<DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)+20p
.text$mn:00003804                 push    ebp
.text$mn:00003805                 mov     ebp, esp
.text$mn:00003807                 xor     eax, eax
.text$mn:00003809                 pop     ebp
.text$mn:0000380A                 retn
.text$mn:0000380A ??$_Val_type@PAPAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@PAPAV1@@Z endp
.text$mn:0000380A
.text$mn:0000380A ; ---------------------------------------------------------------------------
.text$mn:0000380B                 align 4
.text$mn:0000380B _text$mn        ends
.text$mn:0000380B
.text$mn:0000380C ; ===========================================================================
.text$mn:0000380C
.text$mn:0000380C ; Segment type: Pure code
.text$mn:0000380C ; Segment permissions: Read/Execute
.text$mn:0000380C _text$mn        segment para public 'CODE' use32
.text$mn:0000380C                 assume cs:_text$mn
.text$mn:0000380C                 ;org 380Ch
.text$mn:0000380C ; COMDAT (pick any)
.text$mn:0000380C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000380C
.text$mn:0000380C ; =============== S U B R O U T I N E =======================================
.text$mn:0000380C
.text$mn:0000380C ; Attributes: bp-based frame
.text$mn:0000380C
.text$mn:0000380C ; char * __cdecl std::addressof<char>(char &)
.text$mn:0000380C                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:0000380C ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:0000380C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:0000380C                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:0000380C
.text$mn:0000380C arg_0           = dword ptr  8
.text$mn:0000380C
.text$mn:0000380C                 push    ebp
.text$mn:0000380D                 mov     ebp, esp
.text$mn:0000380F                 mov     eax, [ebp+arg_0]
.text$mn:00003812                 pop     ebp
.text$mn:00003813                 retn
.text$mn:00003813 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00003813
.text$mn:00003813 _text$mn        ends
.text$mn:00003813
.text$mn:00003814 ; ===========================================================================
.text$mn:00003814
.text$mn:00003814 ; Segment type: Pure code
.text$mn:00003814 ; Segment permissions: Read/Execute
.text$mn:00003814 _text$mn        segment para public 'CODE' use32
.text$mn:00003814                 assume cs:_text$mn
.text$mn:00003814                 ;org 3814h
.text$mn:00003814 ; COMDAT (pick any)
.text$mn:00003814                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003814
.text$mn:00003814 ; =============== S U B R O U T I N E =======================================
.text$mn:00003814
.text$mn:00003814 ; Attributes: bp-based frame
.text$mn:00003814
.text$mn:00003814 ; struct HWND__ * const * __cdecl std::addressof<struct HWND__ * const>(struct HWND__ * const &)
.text$mn:00003814                 public ??$addressof@QAUHWND__@@@std@@YAPBQAUHWND__@@ABQAU1@@Z
.text$mn:00003814 ??$addressof@QAUHWND__@@@std@@YAPBQAUHWND__@@ABQAU1@@Z proc near
.text$mn:00003814                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+Dp
.text$mn:00003814                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+29p
.text$mn:00003814
.text$mn:00003814 arg_0           = dword ptr  8
.text$mn:00003814
.text$mn:00003814                 push    ebp
.text$mn:00003815                 mov     ebp, esp
.text$mn:00003817                 mov     eax, [ebp+arg_0]
.text$mn:0000381A                 pop     ebp
.text$mn:0000381B                 retn
.text$mn:0000381B ??$addressof@QAUHWND__@@@std@@YAPBQAUHWND__@@ABQAU1@@Z endp
.text$mn:0000381B
.text$mn:0000381B _text$mn        ends
.text$mn:0000381B
.text$mn:0000381C ; ===========================================================================
.text$mn:0000381C
.text$mn:0000381C ; Segment type: Pure code
.text$mn:0000381C ; Segment permissions: Read/Execute
.text$mn:0000381C _text$mn        segment para public 'CODE' use32
.text$mn:0000381C                 assume cs:_text$mn
.text$mn:0000381C                 ;org 381Ch
.text$mn:0000381C ; COMDAT (pick any)
.text$mn:0000381C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000381C
.text$mn:0000381C ; =============== S U B R O U T I N E =======================================
.text$mn:0000381C
.text$mn:0000381C ; Attributes: bp-based frame
.text$mn:0000381C
.text$mn:0000381C ; class DockingCont * const * __cdecl std::addressof<class DockingCont * const>(class DockingCont * const &)
.text$mn:0000381C                 public ??$addressof@QAVDockingCont@@@std@@YAPBQAVDockingCont@@ABQAV1@@Z
.text$mn:0000381C ??$addressof@QAVDockingCont@@@std@@YAPBQAVDockingCont@@ABQAV1@@Z proc near
.text$mn:0000381C                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+Dp
.text$mn:0000381C                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+29p
.text$mn:0000381C
.text$mn:0000381C arg_0           = dword ptr  8
.text$mn:0000381C
.text$mn:0000381C                 push    ebp
.text$mn:0000381D                 mov     ebp, esp
.text$mn:0000381F                 mov     eax, [ebp+arg_0]
.text$mn:00003822                 pop     ebp
.text$mn:00003823                 retn
.text$mn:00003823 ??$addressof@QAVDockingCont@@@std@@YAPBQAVDockingCont@@ABQAV1@@Z endp
.text$mn:00003823
.text$mn:00003823 _text$mn        ends
.text$mn:00003823
.text$mn:00003824 ; ===========================================================================
.text$mn:00003824
.text$mn:00003824 ; Segment type: Pure code
.text$mn:00003824 ; Segment permissions: Read/Execute
.text$mn:00003824 _text$mn        segment para public 'CODE' use32
.text$mn:00003824                 assume cs:_text$mn
.text$mn:00003824                 ;org 3824h
.text$mn:00003824 ; COMDAT (pick any)
.text$mn:00003824                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003824
.text$mn:00003824 ; =============== S U B R O U T I N E =======================================
.text$mn:00003824
.text$mn:00003824 ; Attributes: bp-based frame
.text$mn:00003824
.text$mn:00003824 ; class DockingSplitter * const * __cdecl std::addressof<class DockingSplitter * const>(class DockingSplitter * const &)
.text$mn:00003824                 public ??$addressof@QAVDockingSplitter@@@std@@YAPBQAVDockingSplitter@@ABQAV1@@Z
.text$mn:00003824 ??$addressof@QAVDockingSplitter@@@std@@YAPBQAVDockingSplitter@@ABQAV1@@Z proc near
.text$mn:00003824                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+Dp
.text$mn:00003824                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+29p
.text$mn:00003824
.text$mn:00003824 arg_0           = dword ptr  8
.text$mn:00003824
.text$mn:00003824                 push    ebp
.text$mn:00003825                 mov     ebp, esp
.text$mn:00003827                 mov     eax, [ebp+arg_0]
.text$mn:0000382A                 pop     ebp
.text$mn:0000382B                 retn
.text$mn:0000382B ??$addressof@QAVDockingSplitter@@@std@@YAPBQAVDockingSplitter@@ABQAV1@@Z endp
.text$mn:0000382B
.text$mn:0000382B _text$mn        ends
.text$mn:0000382B
.text$mn:0000382C ; ===========================================================================
.text$mn:0000382C
.text$mn:0000382C ; Segment type: Pure code
.text$mn:0000382C ; Segment permissions: Read/Execute
.text$mn:0000382C _text$mn        segment para public 'CODE' use32
.text$mn:0000382C                 assume cs:_text$mn
.text$mn:0000382C                 ;org 382Ch
.text$mn:0000382C ; COMDAT (pick any)
.text$mn:0000382C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000382C
.text$mn:0000382C ; =============== S U B R O U T I N E =======================================
.text$mn:0000382C
.text$mn:0000382C ; Attributes: bp-based frame
.text$mn:0000382C
.text$mn:0000382C ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:0000382C                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:0000382C ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000382C                                         ; CODE XREF: $LN19+4Bp
.text$mn:0000382C
.text$mn:0000382C var_4           = dword ptr -4
.text$mn:0000382C arg_0           = dword ptr  8
.text$mn:0000382C arg_4           = dword ptr  0Ch
.text$mn:0000382C
.text$mn:0000382C                 push    ebp
.text$mn:0000382D                 mov     ebp, esp
.text$mn:0000382F                 push    ecx
.text$mn:00003830                 mov     [ebp+var_4], ecx
.text$mn:00003833                 mov     eax, [ebp+arg_4]
.text$mn:00003836                 push    eax
.text$mn:00003837                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000383C                 add     esp, 4
.text$mn:0000383F                 push    eax             ; int
.text$mn:00003840                 mov     ecx, [ebp+arg_0]
.text$mn:00003843                 push    ecx             ; void *
.text$mn:00003844                 mov     edx, [ebp+var_4]
.text$mn:00003847                 push    edx             ; int
.text$mn:00003848                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:0000384D                 add     esp, 0Ch
.text$mn:00003850                 mov     esp, ebp
.text$mn:00003852                 pop     ebp
.text$mn:00003853                 retn    8
.text$mn:00003853 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00003853
.text$mn:00003853 ; ---------------------------------------------------------------------------
.text$mn:00003856                 align 4
.text$mn:00003856 _text$mn        ends
.text$mn:00003856
.text$mn:00003858 ; ===========================================================================
.text$mn:00003858
.text$mn:00003858 ; Segment type: Pure code
.text$mn:00003858 ; Segment permissions: Read/Execute
.text$mn:00003858 _text$mn        segment para public 'CODE' use32
.text$mn:00003858                 assume cs:_text$mn
.text$mn:00003858                 ;org 3858h
.text$mn:00003858 ; COMDAT (pick any)
.text$mn:00003858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003858
.text$mn:00003858 ; =============== S U B R O U T I N E =======================================
.text$mn:00003858
.text$mn:00003858 ; Attributes: bp-based frame
.text$mn:00003858
.text$mn:00003858 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00003858                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00003858 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00003858                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00003858
.text$mn:00003858 var_1C          = dword ptr -1Ch
.text$mn:00003858 var_18          = dword ptr -18h
.text$mn:00003858 var_14          = dword ptr -14h
.text$mn:00003858 var_10          = dword ptr -10h
.text$mn:00003858 var_C           = dword ptr -0Ch
.text$mn:00003858 var_4           = dword ptr -4
.text$mn:00003858 arg_0           = dword ptr  8
.text$mn:00003858 arg_4           = dword ptr  0Ch
.text$mn:00003858
.text$mn:00003858                 push    ebp
.text$mn:00003859                 mov     ebp, esp
.text$mn:0000385B                 push    0FFFFFFFFh
.text$mn:0000385D                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00003862                 mov     eax, large fs:0
.text$mn:00003868                 push    eax
.text$mn:00003869                 sub     esp, 10h
.text$mn:0000386C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003871                 xor     eax, ebp
.text$mn:00003873                 push    eax
.text$mn:00003874                 lea     eax, [ebp+var_C]
.text$mn:00003877                 mov     large fs:0, eax
.text$mn:0000387D                 mov     [ebp+var_18], ecx
.text$mn:00003880                 mov     eax, [ebp+arg_0]
.text$mn:00003883                 push    eax             ; void *
.text$mn:00003884                 push    4               ; unsigned int
.text$mn:00003886                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000388B                 add     esp, 8
.text$mn:0000388E                 mov     [ebp+var_10], eax
.text$mn:00003891                 mov     [ebp+var_4], 0
.text$mn:00003898                 cmp     [ebp+var_10], 0
.text$mn:0000389C                 jz      short loc_38B9
.text$mn:0000389E                 mov     ecx, [ebp+arg_4]
.text$mn:000038A1                 push    ecx
.text$mn:000038A2                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000038A7                 add     esp, 4
.text$mn:000038AA                 mov     edx, [ebp+var_10]
.text$mn:000038AD                 mov     eax, [eax]
.text$mn:000038AF                 mov     [edx], eax
.text$mn:000038B1                 mov     ecx, [ebp+var_10]
.text$mn:000038B4                 mov     [ebp+var_14], ecx
.text$mn:000038B7                 jmp     short loc_38C0
.text$mn:000038B9 ; ---------------------------------------------------------------------------
.text$mn:000038B9
.text$mn:000038B9 loc_38B9:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000038B9                 mov     [ebp+var_14], 0
.text$mn:000038C0
.text$mn:000038C0 loc_38C0:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000038C0                 mov     edx, [ebp+var_14]
.text$mn:000038C3                 mov     [ebp+var_1C], edx
.text$mn:000038C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000038CD                 mov     ecx, [ebp+var_C]
.text$mn:000038D0                 mov     large fs:0, ecx
.text$mn:000038D7                 pop     ecx
.text$mn:000038D8                 mov     esp, ebp
.text$mn:000038DA                 pop     ebp
.text$mn:000038DB                 retn    8
.text$mn:000038DB ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000038DB
.text$mn:000038DB ; ---------------------------------------------------------------------------
.text$mn:000038DE                 align 10h
.text$mn:000038DE _text$mn        ends
.text$mn:000038DE
.text$x:000038E0 ; ===========================================================================
.text$x:000038E0
.text$x:000038E0 ; Segment type: Pure code
.text$x:000038E0 ; Segment permissions: Read/Execute
.text$x:000038E0 _text$x         segment para public 'CODE' use32
.text$x:000038E0                 assume cs:_text$x
.text$x:000038E0                 ;org 38E0h
.text$x:000038E0 ; COMDAT (pick associative to section at 3858)
.text$x:000038E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000038E0
.text$x:000038E0 ; =============== S U B R O U T I N E =======================================
.text$x:000038E0
.text$x:000038E0
.text$x:000038E0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000038E0                                         ; DATA XREF: .xdata$x:00009B84o
.text$x:000038E0                 mov     eax, [ebp+8]
.text$x:000038E3                 push    eax
.text$x:000038E4                 mov     eax, [ebp-10h]
.text$x:000038E7                 push    eax             ; void *
.text$x:000038E8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000038ED                 add     esp, 8
.text$x:000038F0                 retn
.text$x:000038F0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000038F0
.text$x:000038F1
.text$x:000038F1 ; =============== S U B R O U T I N E =======================================
.text$x:000038F1
.text$x:000038F1
.text$x:000038F1 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000038F1                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000038F1
.text$x:000038F1 arg_4           = dword ptr  8
.text$x:000038F1
.text$x:000038F1                 mov     edx, [esp+arg_4]
.text$x:000038F5                 lea     eax, [edx+0Ch]
.text$x:000038F8                 mov     ecx, [edx-14h]
.text$x:000038FB                 xor     ecx, eax
.text$x:000038FD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003902                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00003907                 jmp     ___CxxFrameHandler3
.text$x:00003907 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00003907
.text$x:00003907 _text$x         ends
.text$x:00003907
.text$mn:0000390C ; ===========================================================================
.text$mn:0000390C
.text$mn:0000390C ; Segment type: Pure code
.text$mn:0000390C ; Segment permissions: Read/Execute
.text$mn:0000390C _text$mn        segment para public 'CODE' use32
.text$mn:0000390C                 assume cs:_text$mn
.text$mn:0000390C                 ;org 390Ch
.text$mn:0000390C ; COMDAT (pick any)
.text$mn:0000390C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000390C
.text$mn:0000390C ; =============== S U B R O U T I N E =======================================
.text$mn:0000390C
.text$mn:0000390C ; Attributes: bp-based frame
.text$mn:0000390C
.text$mn:0000390C ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:0000390C                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:0000390C ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:0000390C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:0000390C
.text$mn:0000390C arg_0           = dword ptr  8
.text$mn:0000390C arg_4           = dword ptr  0Ch
.text$mn:0000390C arg_8           = dword ptr  10h
.text$mn:0000390C
.text$mn:0000390C                 push    ebp
.text$mn:0000390D                 mov     ebp, esp
.text$mn:0000390F                 mov     eax, [ebp+arg_8]
.text$mn:00003912                 push    eax
.text$mn:00003913                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00003918                 add     esp, 4
.text$mn:0000391B                 push    eax             ; int
.text$mn:0000391C                 mov     ecx, [ebp+arg_4]
.text$mn:0000391F                 push    ecx             ; void *
.text$mn:00003920                 mov     ecx, [ebp+arg_0]
.text$mn:00003923                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00003928                 pop     ebp
.text$mn:00003929                 retn
.text$mn:00003929 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00003929
.text$mn:00003929 ; ---------------------------------------------------------------------------
.text$mn:0000392A                 align 4
.text$mn:0000392A _text$mn        ends
.text$mn:0000392A
.text$mn:0000392C ; ===========================================================================
.text$mn:0000392C
.text$mn:0000392C ; Segment type: Pure code
.text$mn:0000392C ; Segment permissions: Read/Execute
.text$mn:0000392C _text$mn        segment para public 'CODE' use32
.text$mn:0000392C                 assume cs:_text$mn
.text$mn:0000392C                 ;org 392Ch
.text$mn:0000392C ; COMDAT (pick any)
.text$mn:0000392C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000392C
.text$mn:0000392C ; =============== S U B R O U T I N E =======================================
.text$mn:0000392C
.text$mn:0000392C ; Attributes: bp-based frame
.text$mn:0000392C
.text$mn:0000392C ; int __stdcall std::_Wrap_alloc<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * &>(void *, int)
.text$mn:0000392C                 public ??$construct@PAUHWND__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z
.text$mn:0000392C ??$construct@PAUHWND__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z proc near
.text$mn:0000392C                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+8Dp
.text$mn:0000392C
.text$mn:0000392C var_4           = dword ptr -4
.text$mn:0000392C arg_0           = dword ptr  8
.text$mn:0000392C arg_4           = dword ptr  0Ch
.text$mn:0000392C
.text$mn:0000392C                 push    ebp
.text$mn:0000392D                 mov     ebp, esp
.text$mn:0000392F                 push    ecx
.text$mn:00003930                 mov     [ebp+var_4], ecx
.text$mn:00003933                 mov     eax, [ebp+arg_4]
.text$mn:00003936                 push    eax
.text$mn:00003937                 call    ??$forward@AAPAUHWND__@@@std@@YAAAPAUHWND__@@AAPAU1@@Z ; std::forward<HWND__ * &>(HWND__ * &)
.text$mn:0000393C                 add     esp, 4
.text$mn:0000393F                 push    eax             ; int
.text$mn:00003940                 mov     ecx, [ebp+arg_0]
.text$mn:00003943                 push    ecx             ; void *
.text$mn:00003944                 mov     edx, [ebp+var_4]
.text$mn:00003947                 push    edx             ; int
.text$mn:00003948                 call    ??$construct@PAUHWND__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAXAAV?$allocator@PAUHWND__@@@1@PAPAUHWND__@@AAPAU3@@Z ; std::allocator_traits<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * &>(std::allocator<HWND__ *> &,HWND__ * *,HWND__ * &)
.text$mn:0000394D                 add     esp, 0Ch
.text$mn:00003950                 mov     esp, ebp
.text$mn:00003952                 pop     ebp
.text$mn:00003953                 retn    8
.text$mn:00003953 ??$construct@PAUHWND__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z endp
.text$mn:00003953
.text$mn:00003953 ; ---------------------------------------------------------------------------
.text$mn:00003956                 align 4
.text$mn:00003956 _text$mn        ends
.text$mn:00003956
.text$mn:00003958 ; ===========================================================================
.text$mn:00003958
.text$mn:00003958 ; Segment type: Pure code
.text$mn:00003958 ; Segment permissions: Read/Execute
.text$mn:00003958 _text$mn        segment para public 'CODE' use32
.text$mn:00003958                 assume cs:_text$mn
.text$mn:00003958                 ;org 3958h
.text$mn:00003958 ; COMDAT (pick any)
.text$mn:00003958                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003958
.text$mn:00003958 ; =============== S U B R O U T I N E =======================================
.text$mn:00003958
.text$mn:00003958 ; Attributes: bp-based frame
.text$mn:00003958
.text$mn:00003958 ; int __stdcall std::allocator<HWND__ *>::construct<HWND__ *,HWND__ * &>(void *, int)
.text$mn:00003958                 public ??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z
.text$mn:00003958 ??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z proc near
.text$mn:00003958                                         ; CODE XREF: std::allocator_traits<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * &>(std::allocator<HWND__ *> &,HWND__ * *,HWND__ * &)+17p
.text$mn:00003958
.text$mn:00003958 var_1C          = dword ptr -1Ch
.text$mn:00003958 var_18          = dword ptr -18h
.text$mn:00003958 var_14          = dword ptr -14h
.text$mn:00003958 var_10          = dword ptr -10h
.text$mn:00003958 var_C           = dword ptr -0Ch
.text$mn:00003958 var_4           = dword ptr -4
.text$mn:00003958 arg_0           = dword ptr  8
.text$mn:00003958 arg_4           = dword ptr  0Ch
.text$mn:00003958
.text$mn:00003958                 push    ebp
.text$mn:00003959                 mov     ebp, esp
.text$mn:0000395B                 push    0FFFFFFFFh
.text$mn:0000395D                 push    offset __ehhandler$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z
.text$mn:00003962                 mov     eax, large fs:0
.text$mn:00003968                 push    eax
.text$mn:00003969                 sub     esp, 10h
.text$mn:0000396C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003971                 xor     eax, ebp
.text$mn:00003973                 push    eax
.text$mn:00003974                 lea     eax, [ebp+var_C]
.text$mn:00003977                 mov     large fs:0, eax
.text$mn:0000397D                 mov     [ebp+var_18], ecx
.text$mn:00003980                 mov     eax, [ebp+arg_0]
.text$mn:00003983                 push    eax             ; void *
.text$mn:00003984                 push    4               ; unsigned int
.text$mn:00003986                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000398B                 add     esp, 8
.text$mn:0000398E                 mov     [ebp+var_10], eax
.text$mn:00003991                 mov     [ebp+var_4], 0
.text$mn:00003998                 cmp     [ebp+var_10], 0
.text$mn:0000399C                 jz      short loc_39B9
.text$mn:0000399E                 mov     ecx, [ebp+arg_4]
.text$mn:000039A1                 push    ecx
.text$mn:000039A2                 call    ??$forward@AAPAUHWND__@@@std@@YAAAPAUHWND__@@AAPAU1@@Z ; std::forward<HWND__ * &>(HWND__ * &)
.text$mn:000039A7                 add     esp, 4
.text$mn:000039AA                 mov     edx, [ebp+var_10]
.text$mn:000039AD                 mov     eax, [eax]
.text$mn:000039AF                 mov     [edx], eax
.text$mn:000039B1                 mov     ecx, [ebp+var_10]
.text$mn:000039B4                 mov     [ebp+var_14], ecx
.text$mn:000039B7                 jmp     short loc_39C0
.text$mn:000039B9 ; ---------------------------------------------------------------------------
.text$mn:000039B9
.text$mn:000039B9 loc_39B9:                               ; CODE XREF: std::allocator<HWND__ *>::construct<HWND__ *,HWND__ * &>(HWND__ * *,HWND__ * &)+44j
.text$mn:000039B9                 mov     [ebp+var_14], 0
.text$mn:000039C0
.text$mn:000039C0 loc_39C0:                               ; CODE XREF: std::allocator<HWND__ *>::construct<HWND__ *,HWND__ * &>(HWND__ * *,HWND__ * &)+5Fj
.text$mn:000039C0                 mov     edx, [ebp+var_14]
.text$mn:000039C3                 mov     [ebp+var_1C], edx
.text$mn:000039C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000039CD                 mov     ecx, [ebp+var_C]
.text$mn:000039D0                 mov     large fs:0, ecx
.text$mn:000039D7                 pop     ecx
.text$mn:000039D8                 mov     esp, ebp
.text$mn:000039DA                 pop     ebp
.text$mn:000039DB                 retn    8
.text$mn:000039DB ??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z endp
.text$mn:000039DB
.text$mn:000039DB ; ---------------------------------------------------------------------------
.text$mn:000039DE                 align 10h
.text$mn:000039DE _text$mn        ends
.text$mn:000039DE
.text$x:000039E0 ; ===========================================================================
.text$x:000039E0
.text$x:000039E0 ; Segment type: Pure code
.text$x:000039E0 ; Segment permissions: Read/Execute
.text$x:000039E0 _text$x         segment para public 'CODE' use32
.text$x:000039E0                 assume cs:_text$x
.text$x:000039E0                 ;org 39E0h
.text$x:000039E0 ; COMDAT (pick associative to section at 3958)
.text$x:000039E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000039E0
.text$x:000039E0 ; =============== S U B R O U T I N E =======================================
.text$x:000039E0
.text$x:000039E0
.text$x:000039E0 __unwindfunclet$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z$0 proc near
.text$x:000039E0                                         ; DATA XREF: .xdata$x:00009B00o
.text$x:000039E0                 mov     eax, [ebp+8]
.text$x:000039E3                 push    eax
.text$x:000039E4                 mov     eax, [ebp-10h]
.text$x:000039E7                 push    eax             ; void *
.text$x:000039E8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000039ED                 add     esp, 8
.text$x:000039F0                 retn
.text$x:000039F0 __unwindfunclet$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z$0 endp
.text$x:000039F0
.text$x:000039F1
.text$x:000039F1 ; =============== S U B R O U T I N E =======================================
.text$x:000039F1
.text$x:000039F1
.text$x:000039F1 __ehhandler$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z proc near
.text$x:000039F1                                         ; DATA XREF: std::allocator<HWND__ *>::construct<HWND__ *,HWND__ * &>(HWND__ * *,HWND__ * &)+5o
.text$x:000039F1
.text$x:000039F1 arg_4           = dword ptr  8
.text$x:000039F1
.text$x:000039F1                 mov     edx, [esp+arg_4]
.text$x:000039F5                 lea     eax, [edx+0Ch]
.text$x:000039F8                 mov     ecx, [edx-14h]
.text$x:000039FB                 xor     ecx, eax
.text$x:000039FD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003A02                 mov     eax, offset __ehfuncinfo$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z
.text$x:00003A07                 jmp     ___CxxFrameHandler3
.text$x:00003A07 __ehhandler$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z endp
.text$x:00003A07
.text$x:00003A07 _text$x         ends
.text$x:00003A07
.text$mn:00003A0C ; ===========================================================================
.text$mn:00003A0C
.text$mn:00003A0C ; Segment type: Pure code
.text$mn:00003A0C ; Segment permissions: Read/Execute
.text$mn:00003A0C _text$mn        segment para public 'CODE' use32
.text$mn:00003A0C                 assume cs:_text$mn
.text$mn:00003A0C                 ;org 3A0Ch
.text$mn:00003A0C ; COMDAT (pick any)
.text$mn:00003A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A0C
.text$mn:00003A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A0C
.text$mn:00003A0C ; Attributes: bp-based frame
.text$mn:00003A0C
.text$mn:00003A0C ; int __cdecl std::allocator_traits<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * &>(int, void *, int)
.text$mn:00003A0C                 public ??$construct@PAUHWND__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAXAAV?$allocator@PAUHWND__@@@1@PAPAUHWND__@@AAPAU3@@Z
.text$mn:00003A0C ??$construct@PAUHWND__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAXAAV?$allocator@PAUHWND__@@@1@PAPAUHWND__@@AAPAU3@@Z proc near
.text$mn:00003A0C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * &>(HWND__ * *,HWND__ * &)+1Cp
.text$mn:00003A0C
.text$mn:00003A0C arg_0           = dword ptr  8
.text$mn:00003A0C arg_4           = dword ptr  0Ch
.text$mn:00003A0C arg_8           = dword ptr  10h
.text$mn:00003A0C
.text$mn:00003A0C                 push    ebp
.text$mn:00003A0D                 mov     ebp, esp
.text$mn:00003A0F                 mov     eax, [ebp+arg_8]
.text$mn:00003A12                 push    eax
.text$mn:00003A13                 call    ??$forward@AAPAUHWND__@@@std@@YAAAPAUHWND__@@AAPAU1@@Z ; std::forward<HWND__ * &>(HWND__ * &)
.text$mn:00003A18                 add     esp, 4
.text$mn:00003A1B                 push    eax             ; int
.text$mn:00003A1C                 mov     ecx, [ebp+arg_4]
.text$mn:00003A1F                 push    ecx             ; void *
.text$mn:00003A20                 mov     ecx, [ebp+arg_0]
.text$mn:00003A23                 call    ??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z ; std::allocator<HWND__ *>::construct<HWND__ *,HWND__ * &>(HWND__ * *,HWND__ * &)
.text$mn:00003A28                 pop     ebp
.text$mn:00003A29                 retn
.text$mn:00003A29 ??$construct@PAUHWND__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAXAAV?$allocator@PAUHWND__@@@1@PAPAUHWND__@@AAPAU3@@Z endp
.text$mn:00003A29
.text$mn:00003A29 ; ---------------------------------------------------------------------------
.text$mn:00003A2A                 align 4
.text$mn:00003A2A _text$mn        ends
.text$mn:00003A2A
.text$mn:00003A2C ; ===========================================================================
.text$mn:00003A2C
.text$mn:00003A2C ; Segment type: Pure code
.text$mn:00003A2C ; Segment permissions: Read/Execute
.text$mn:00003A2C _text$mn        segment para public 'CODE' use32
.text$mn:00003A2C                 assume cs:_text$mn
.text$mn:00003A2C                 ;org 3A2Ch
.text$mn:00003A2C ; COMDAT (pick any)
.text$mn:00003A2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A2C
.text$mn:00003A2C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A2C
.text$mn:00003A2C ; Attributes: bp-based frame
.text$mn:00003A2C
.text$mn:00003A2C ; int __stdcall std::_Wrap_alloc<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * const &>(void *, int)
.text$mn:00003A2C                 public ??$construct@PAUHWND__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@ABQAU2@@Z
.text$mn:00003A2C ??$construct@PAUHWND__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@ABQAU2@@Z proc near
.text$mn:00003A2C                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+EAp
.text$mn:00003A2C
.text$mn:00003A2C var_4           = dword ptr -4
.text$mn:00003A2C arg_0           = dword ptr  8
.text$mn:00003A2C arg_4           = dword ptr  0Ch
.text$mn:00003A2C
.text$mn:00003A2C                 push    ebp
.text$mn:00003A2D                 mov     ebp, esp
.text$mn:00003A2F                 push    ecx
.text$mn:00003A30                 mov     [ebp+var_4], ecx
.text$mn:00003A33                 mov     eax, [ebp+arg_4]
.text$mn:00003A36                 push    eax
.text$mn:00003A37                 call    ??$forward@ABQAUHWND__@@@std@@YAABQAUHWND__@@ABQAU1@@Z ; std::forward<HWND__ * const &>(HWND__ * const &)
.text$mn:00003A3C                 add     esp, 4
.text$mn:00003A3F                 push    eax             ; int
.text$mn:00003A40                 mov     ecx, [ebp+arg_0]
.text$mn:00003A43                 push    ecx             ; void *
.text$mn:00003A44                 mov     edx, [ebp+var_4]
.text$mn:00003A47                 push    edx             ; int
.text$mn:00003A48                 call    ??$construct@PAUHWND__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAXAAV?$allocator@PAUHWND__@@@1@PAPAUHWND__@@ABQAU3@@Z ; std::allocator_traits<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * const &>(std::allocator<HWND__ *> &,HWND__ * *,HWND__ * const &)
.text$mn:00003A4D                 add     esp, 0Ch
.text$mn:00003A50                 mov     esp, ebp
.text$mn:00003A52                 pop     ebp
.text$mn:00003A53                 retn    8
.text$mn:00003A53 ??$construct@PAUHWND__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@ABQAU2@@Z endp
.text$mn:00003A53
.text$mn:00003A53 ; ---------------------------------------------------------------------------
.text$mn:00003A56                 align 4
.text$mn:00003A56 _text$mn        ends
.text$mn:00003A56
.text$mn:00003A58 ; ===========================================================================
.text$mn:00003A58
.text$mn:00003A58 ; Segment type: Pure code
.text$mn:00003A58 ; Segment permissions: Read/Execute
.text$mn:00003A58 _text$mn        segment para public 'CODE' use32
.text$mn:00003A58                 assume cs:_text$mn
.text$mn:00003A58                 ;org 3A58h
.text$mn:00003A58 ; COMDAT (pick any)
.text$mn:00003A58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A58
.text$mn:00003A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A58
.text$mn:00003A58 ; Attributes: bp-based frame
.text$mn:00003A58
.text$mn:00003A58 ; int __cdecl std::allocator_traits<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * const &>(int, void *, int)
.text$mn:00003A58                 public ??$construct@PAUHWND__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAXAAV?$allocator@PAUHWND__@@@1@PAPAUHWND__@@ABQAU3@@Z
.text$mn:00003A58 ??$construct@PAUHWND__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAXAAV?$allocator@PAUHWND__@@@1@PAPAUHWND__@@ABQAU3@@Z proc near
.text$mn:00003A58                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * const &>(HWND__ * *,HWND__ * const &)+1Cp
.text$mn:00003A58
.text$mn:00003A58 arg_0           = dword ptr  8
.text$mn:00003A58 arg_4           = dword ptr  0Ch
.text$mn:00003A58 arg_8           = dword ptr  10h
.text$mn:00003A58
.text$mn:00003A58                 push    ebp
.text$mn:00003A59                 mov     ebp, esp
.text$mn:00003A5B                 mov     eax, [ebp+arg_8]
.text$mn:00003A5E                 push    eax
.text$mn:00003A5F                 call    ??$forward@ABQAUHWND__@@@std@@YAABQAUHWND__@@ABQAU1@@Z ; std::forward<HWND__ * const &>(HWND__ * const &)
.text$mn:00003A64                 add     esp, 4
.text$mn:00003A67                 push    eax             ; int
.text$mn:00003A68                 mov     ecx, [ebp+arg_4]
.text$mn:00003A6B                 push    ecx             ; void *
.text$mn:00003A6C                 mov     ecx, [ebp+arg_0]
.text$mn:00003A6F                 call    ?construct@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@ABQAU3@@Z ; std::allocator<HWND__ *>::construct(HWND__ * *,HWND__ * const &)
.text$mn:00003A74                 pop     ebp
.text$mn:00003A75                 retn
.text$mn:00003A75 ??$construct@PAUHWND__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAXAAV?$allocator@PAUHWND__@@@1@PAPAUHWND__@@ABQAU3@@Z endp
.text$mn:00003A75
.text$mn:00003A75 ; ---------------------------------------------------------------------------
.text$mn:00003A76                 align 4
.text$mn:00003A76 _text$mn        ends
.text$mn:00003A76
.text$mn:00003A78 ; ===========================================================================
.text$mn:00003A78
.text$mn:00003A78 ; Segment type: Pure code
.text$mn:00003A78 ; Segment permissions: Read/Execute
.text$mn:00003A78 _text$mn        segment para public 'CODE' use32
.text$mn:00003A78                 assume cs:_text$mn
.text$mn:00003A78                 ;org 3A78h
.text$mn:00003A78 ; COMDAT (pick any)
.text$mn:00003A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A78
.text$mn:00003A78 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A78
.text$mn:00003A78 ; Attributes: bp-based frame
.text$mn:00003A78
.text$mn:00003A78 ; int __stdcall std::_Wrap_alloc<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * &>(void *, int)
.text$mn:00003A78                 public ??$construct@PAVDockingCont@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z
.text$mn:00003A78 ??$construct@PAVDockingCont@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z proc near
.text$mn:00003A78                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+8Dp
.text$mn:00003A78
.text$mn:00003A78 var_4           = dword ptr -4
.text$mn:00003A78 arg_0           = dword ptr  8
.text$mn:00003A78 arg_4           = dword ptr  0Ch
.text$mn:00003A78
.text$mn:00003A78                 push    ebp
.text$mn:00003A79                 mov     ebp, esp
.text$mn:00003A7B                 push    ecx
.text$mn:00003A7C                 mov     [ebp+var_4], ecx
.text$mn:00003A7F                 mov     eax, [ebp+arg_4]
.text$mn:00003A82                 push    eax
.text$mn:00003A83                 call    ??$forward@AAPAVDockingCont@@@std@@YAAAPAVDockingCont@@AAPAV1@@Z ; std::forward<DockingCont * &>(DockingCont * &)
.text$mn:00003A88                 add     esp, 4
.text$mn:00003A8B                 push    eax             ; int
.text$mn:00003A8C                 mov     ecx, [ebp+arg_0]
.text$mn:00003A8F                 push    ecx             ; void *
.text$mn:00003A90                 mov     edx, [ebp+var_4]
.text$mn:00003A93                 push    edx             ; int
.text$mn:00003A94                 call    ??$construct@PAVDockingCont@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAXAAV?$allocator@PAVDockingCont@@@1@PAPAVDockingCont@@AAPAV3@@Z ; std::allocator_traits<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * &>(std::allocator<DockingCont *> &,DockingCont * *,DockingCont * &)
.text$mn:00003A99                 add     esp, 0Ch
.text$mn:00003A9C                 mov     esp, ebp
.text$mn:00003A9E                 pop     ebp
.text$mn:00003A9F                 retn    8
.text$mn:00003A9F ??$construct@PAVDockingCont@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z endp
.text$mn:00003A9F
.text$mn:00003A9F ; ---------------------------------------------------------------------------
.text$mn:00003AA2                 align 4
.text$mn:00003AA2 _text$mn        ends
.text$mn:00003AA2
.text$mn:00003AA4 ; ===========================================================================
.text$mn:00003AA4
.text$mn:00003AA4 ; Segment type: Pure code
.text$mn:00003AA4 ; Segment permissions: Read/Execute
.text$mn:00003AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00003AA4                 assume cs:_text$mn
.text$mn:00003AA4                 ;org 3AA4h
.text$mn:00003AA4 ; COMDAT (pick any)
.text$mn:00003AA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AA4
.text$mn:00003AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AA4
.text$mn:00003AA4 ; Attributes: bp-based frame
.text$mn:00003AA4
.text$mn:00003AA4 ; int __stdcall std::allocator<DockingCont *>::construct<DockingCont *,DockingCont * &>(void *, int)
.text$mn:00003AA4                 public ??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z
.text$mn:00003AA4 ??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z proc near
.text$mn:00003AA4                                         ; CODE XREF: std::allocator_traits<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * &>(std::allocator<DockingCont *> &,DockingCont * *,DockingCont * &)+17p
.text$mn:00003AA4
.text$mn:00003AA4 var_1C          = dword ptr -1Ch
.text$mn:00003AA4 var_18          = dword ptr -18h
.text$mn:00003AA4 var_14          = dword ptr -14h
.text$mn:00003AA4 var_10          = dword ptr -10h
.text$mn:00003AA4 var_C           = dword ptr -0Ch
.text$mn:00003AA4 var_4           = dword ptr -4
.text$mn:00003AA4 arg_0           = dword ptr  8
.text$mn:00003AA4 arg_4           = dword ptr  0Ch
.text$mn:00003AA4
.text$mn:00003AA4                 push    ebp
.text$mn:00003AA5                 mov     ebp, esp
.text$mn:00003AA7                 push    0FFFFFFFFh
.text$mn:00003AA9                 push    offset __ehhandler$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z
.text$mn:00003AAE                 mov     eax, large fs:0
.text$mn:00003AB4                 push    eax
.text$mn:00003AB5                 sub     esp, 10h
.text$mn:00003AB8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003ABD                 xor     eax, ebp
.text$mn:00003ABF                 push    eax
.text$mn:00003AC0                 lea     eax, [ebp+var_C]
.text$mn:00003AC3                 mov     large fs:0, eax
.text$mn:00003AC9                 mov     [ebp+var_18], ecx
.text$mn:00003ACC                 mov     eax, [ebp+arg_0]
.text$mn:00003ACF                 push    eax             ; void *
.text$mn:00003AD0                 push    4               ; unsigned int
.text$mn:00003AD2                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003AD7                 add     esp, 8
.text$mn:00003ADA                 mov     [ebp+var_10], eax
.text$mn:00003ADD                 mov     [ebp+var_4], 0
.text$mn:00003AE4                 cmp     [ebp+var_10], 0
.text$mn:00003AE8                 jz      short loc_3B05
.text$mn:00003AEA                 mov     ecx, [ebp+arg_4]
.text$mn:00003AED                 push    ecx
.text$mn:00003AEE                 call    ??$forward@AAPAVDockingCont@@@std@@YAAAPAVDockingCont@@AAPAV1@@Z ; std::forward<DockingCont * &>(DockingCont * &)
.text$mn:00003AF3                 add     esp, 4
.text$mn:00003AF6                 mov     edx, [ebp+var_10]
.text$mn:00003AF9                 mov     eax, [eax]
.text$mn:00003AFB                 mov     [edx], eax
.text$mn:00003AFD                 mov     ecx, [ebp+var_10]
.text$mn:00003B00                 mov     [ebp+var_14], ecx
.text$mn:00003B03                 jmp     short loc_3B0C
.text$mn:00003B05 ; ---------------------------------------------------------------------------
.text$mn:00003B05
.text$mn:00003B05 loc_3B05:                               ; CODE XREF: std::allocator<DockingCont *>::construct<DockingCont *,DockingCont * &>(DockingCont * *,DockingCont * &)+44j
.text$mn:00003B05                 mov     [ebp+var_14], 0
.text$mn:00003B0C
.text$mn:00003B0C loc_3B0C:                               ; CODE XREF: std::allocator<DockingCont *>::construct<DockingCont *,DockingCont * &>(DockingCont * *,DockingCont * &)+5Fj
.text$mn:00003B0C                 mov     edx, [ebp+var_14]
.text$mn:00003B0F                 mov     [ebp+var_1C], edx
.text$mn:00003B12                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B19                 mov     ecx, [ebp+var_C]
.text$mn:00003B1C                 mov     large fs:0, ecx
.text$mn:00003B23                 pop     ecx
.text$mn:00003B24                 mov     esp, ebp
.text$mn:00003B26                 pop     ebp
.text$mn:00003B27                 retn    8
.text$mn:00003B27 ??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z endp
.text$mn:00003B27
.text$mn:00003B27 ; ---------------------------------------------------------------------------
.text$mn:00003B2A                 align 4
.text$mn:00003B2A _text$mn        ends
.text$mn:00003B2A
.text$x:00003B2C ; ===========================================================================
.text$x:00003B2C
.text$x:00003B2C ; Segment type: Pure code
.text$x:00003B2C ; Segment permissions: Read/Execute
.text$x:00003B2C _text$x         segment para public 'CODE' use32
.text$x:00003B2C                 assume cs:_text$x
.text$x:00003B2C                 ;org 3B2Ch
.text$x:00003B2C ; COMDAT (pick associative to section at 3AA4)
.text$x:00003B2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003B2C
.text$x:00003B2C ; =============== S U B R O U T I N E =======================================
.text$x:00003B2C
.text$x:00003B2C
.text$x:00003B2C __unwindfunclet$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z$0 proc near
.text$x:00003B2C                                         ; DATA XREF: .xdata$x:00009B2Co
.text$x:00003B2C                 mov     eax, [ebp+8]
.text$x:00003B2F                 push    eax
.text$x:00003B30                 mov     eax, [ebp-10h]
.text$x:00003B33                 push    eax             ; void *
.text$x:00003B34                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003B39                 add     esp, 8
.text$x:00003B3C                 retn
.text$x:00003B3C __unwindfunclet$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z$0 endp
.text$x:00003B3C
.text$x:00003B3D
.text$x:00003B3D ; =============== S U B R O U T I N E =======================================
.text$x:00003B3D
.text$x:00003B3D
.text$x:00003B3D __ehhandler$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z proc near
.text$x:00003B3D                                         ; DATA XREF: std::allocator<DockingCont *>::construct<DockingCont *,DockingCont * &>(DockingCont * *,DockingCont * &)+5o
.text$x:00003B3D
.text$x:00003B3D arg_4           = dword ptr  8
.text$x:00003B3D
.text$x:00003B3D                 mov     edx, [esp+arg_4]
.text$x:00003B41                 lea     eax, [edx+0Ch]
.text$x:00003B44                 mov     ecx, [edx-14h]
.text$x:00003B47                 xor     ecx, eax
.text$x:00003B49                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003B4E                 mov     eax, offset __ehfuncinfo$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z
.text$x:00003B53                 jmp     ___CxxFrameHandler3
.text$x:00003B53 __ehhandler$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z endp
.text$x:00003B53
.text$x:00003B53 _text$x         ends
.text$x:00003B53
.text$mn:00003B58 ; ===========================================================================
.text$mn:00003B58
.text$mn:00003B58 ; Segment type: Pure code
.text$mn:00003B58 ; Segment permissions: Read/Execute
.text$mn:00003B58 _text$mn        segment para public 'CODE' use32
.text$mn:00003B58                 assume cs:_text$mn
.text$mn:00003B58                 ;org 3B58h
.text$mn:00003B58 ; COMDAT (pick any)
.text$mn:00003B58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B58
.text$mn:00003B58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B58
.text$mn:00003B58 ; Attributes: bp-based frame
.text$mn:00003B58
.text$mn:00003B58 ; int __cdecl std::allocator_traits<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * &>(int, void *, int)
.text$mn:00003B58                 public ??$construct@PAVDockingCont@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAXAAV?$allocator@PAVDockingCont@@@1@PAPAVDockingCont@@AAPAV3@@Z
.text$mn:00003B58 ??$construct@PAVDockingCont@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAXAAV?$allocator@PAVDockingCont@@@1@PAPAVDockingCont@@AAPAV3@@Z proc near
.text$mn:00003B58                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * &>(DockingCont * *,DockingCont * &)+1Cp
.text$mn:00003B58
.text$mn:00003B58 arg_0           = dword ptr  8
.text$mn:00003B58 arg_4           = dword ptr  0Ch
.text$mn:00003B58 arg_8           = dword ptr  10h
.text$mn:00003B58
.text$mn:00003B58                 push    ebp
.text$mn:00003B59                 mov     ebp, esp
.text$mn:00003B5B                 mov     eax, [ebp+arg_8]
.text$mn:00003B5E                 push    eax
.text$mn:00003B5F                 call    ??$forward@AAPAVDockingCont@@@std@@YAAAPAVDockingCont@@AAPAV1@@Z ; std::forward<DockingCont * &>(DockingCont * &)
.text$mn:00003B64                 add     esp, 4
.text$mn:00003B67                 push    eax             ; int
.text$mn:00003B68                 mov     ecx, [ebp+arg_4]
.text$mn:00003B6B                 push    ecx             ; void *
.text$mn:00003B6C                 mov     ecx, [ebp+arg_0]
.text$mn:00003B6F                 call    ??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z ; std::allocator<DockingCont *>::construct<DockingCont *,DockingCont * &>(DockingCont * *,DockingCont * &)
.text$mn:00003B74                 pop     ebp
.text$mn:00003B75                 retn
.text$mn:00003B75 ??$construct@PAVDockingCont@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAXAAV?$allocator@PAVDockingCont@@@1@PAPAVDockingCont@@AAPAV3@@Z endp
.text$mn:00003B75
.text$mn:00003B75 ; ---------------------------------------------------------------------------
.text$mn:00003B76                 align 4
.text$mn:00003B76 _text$mn        ends
.text$mn:00003B76
.text$mn:00003B78 ; ===========================================================================
.text$mn:00003B78
.text$mn:00003B78 ; Segment type: Pure code
.text$mn:00003B78 ; Segment permissions: Read/Execute
.text$mn:00003B78 _text$mn        segment para public 'CODE' use32
.text$mn:00003B78                 assume cs:_text$mn
.text$mn:00003B78                 ;org 3B78h
.text$mn:00003B78 ; COMDAT (pick any)
.text$mn:00003B78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B78
.text$mn:00003B78 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B78
.text$mn:00003B78 ; Attributes: bp-based frame
.text$mn:00003B78
.text$mn:00003B78 ; int __stdcall std::_Wrap_alloc<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * const &>(void *, int)
.text$mn:00003B78                 public ??$construct@PAVDockingCont@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@ABQAV2@@Z
.text$mn:00003B78 ??$construct@PAVDockingCont@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@ABQAV2@@Z proc near
.text$mn:00003B78                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+EAp
.text$mn:00003B78
.text$mn:00003B78 var_4           = dword ptr -4
.text$mn:00003B78 arg_0           = dword ptr  8
.text$mn:00003B78 arg_4           = dword ptr  0Ch
.text$mn:00003B78
.text$mn:00003B78                 push    ebp
.text$mn:00003B79                 mov     ebp, esp
.text$mn:00003B7B                 push    ecx
.text$mn:00003B7C                 mov     [ebp+var_4], ecx
.text$mn:00003B7F                 mov     eax, [ebp+arg_4]
.text$mn:00003B82                 push    eax
.text$mn:00003B83                 call    ??$forward@ABQAVDockingCont@@@std@@YAABQAVDockingCont@@ABQAV1@@Z ; std::forward<DockingCont * const &>(DockingCont * const &)
.text$mn:00003B88                 add     esp, 4
.text$mn:00003B8B                 push    eax             ; int
.text$mn:00003B8C                 mov     ecx, [ebp+arg_0]
.text$mn:00003B8F                 push    ecx             ; void *
.text$mn:00003B90                 mov     edx, [ebp+var_4]
.text$mn:00003B93                 push    edx             ; int
.text$mn:00003B94                 call    ??$construct@PAVDockingCont@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAXAAV?$allocator@PAVDockingCont@@@1@PAPAVDockingCont@@ABQAV3@@Z ; std::allocator_traits<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * const &>(std::allocator<DockingCont *> &,DockingCont * *,DockingCont * const &)
.text$mn:00003B99                 add     esp, 0Ch
.text$mn:00003B9C                 mov     esp, ebp
.text$mn:00003B9E                 pop     ebp
.text$mn:00003B9F                 retn    8
.text$mn:00003B9F ??$construct@PAVDockingCont@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@ABQAV2@@Z endp
.text$mn:00003B9F
.text$mn:00003B9F ; ---------------------------------------------------------------------------
.text$mn:00003BA2                 align 4
.text$mn:00003BA2 _text$mn        ends
.text$mn:00003BA2
.text$mn:00003BA4 ; ===========================================================================
.text$mn:00003BA4
.text$mn:00003BA4 ; Segment type: Pure code
.text$mn:00003BA4 ; Segment permissions: Read/Execute
.text$mn:00003BA4 _text$mn        segment para public 'CODE' use32
.text$mn:00003BA4                 assume cs:_text$mn
.text$mn:00003BA4                 ;org 3BA4h
.text$mn:00003BA4 ; COMDAT (pick any)
.text$mn:00003BA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BA4
.text$mn:00003BA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BA4
.text$mn:00003BA4 ; Attributes: bp-based frame
.text$mn:00003BA4
.text$mn:00003BA4 ; int __cdecl std::allocator_traits<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * const &>(int, void *, int)
.text$mn:00003BA4                 public ??$construct@PAVDockingCont@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAXAAV?$allocator@PAVDockingCont@@@1@PAPAVDockingCont@@ABQAV3@@Z
.text$mn:00003BA4 ??$construct@PAVDockingCont@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAXAAV?$allocator@PAVDockingCont@@@1@PAPAVDockingCont@@ABQAV3@@Z proc near
.text$mn:00003BA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * const &>(DockingCont * *,DockingCont * const &)+1Cp
.text$mn:00003BA4
.text$mn:00003BA4 arg_0           = dword ptr  8
.text$mn:00003BA4 arg_4           = dword ptr  0Ch
.text$mn:00003BA4 arg_8           = dword ptr  10h
.text$mn:00003BA4
.text$mn:00003BA4                 push    ebp
.text$mn:00003BA5                 mov     ebp, esp
.text$mn:00003BA7                 mov     eax, [ebp+arg_8]
.text$mn:00003BAA                 push    eax
.text$mn:00003BAB                 call    ??$forward@ABQAVDockingCont@@@std@@YAABQAVDockingCont@@ABQAV1@@Z ; std::forward<DockingCont * const &>(DockingCont * const &)
.text$mn:00003BB0                 add     esp, 4
.text$mn:00003BB3                 push    eax             ; int
.text$mn:00003BB4                 mov     ecx, [ebp+arg_4]
.text$mn:00003BB7                 push    ecx             ; void *
.text$mn:00003BB8                 mov     ecx, [ebp+arg_0]
.text$mn:00003BBB                 call    ?construct@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@ABQAV3@@Z ; std::allocator<DockingCont *>::construct(DockingCont * *,DockingCont * const &)
.text$mn:00003BC0                 pop     ebp
.text$mn:00003BC1                 retn
.text$mn:00003BC1 ??$construct@PAVDockingCont@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAXAAV?$allocator@PAVDockingCont@@@1@PAPAVDockingCont@@ABQAV3@@Z endp
.text$mn:00003BC1
.text$mn:00003BC1 ; ---------------------------------------------------------------------------
.text$mn:00003BC2                 align 4
.text$mn:00003BC2 _text$mn        ends
.text$mn:00003BC2
.text$mn:00003BC4 ; ===========================================================================
.text$mn:00003BC4
.text$mn:00003BC4 ; Segment type: Pure code
.text$mn:00003BC4 ; Segment permissions: Read/Execute
.text$mn:00003BC4 _text$mn        segment para public 'CODE' use32
.text$mn:00003BC4                 assume cs:_text$mn
.text$mn:00003BC4                 ;org 3BC4h
.text$mn:00003BC4 ; COMDAT (pick any)
.text$mn:00003BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BC4
.text$mn:00003BC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BC4
.text$mn:00003BC4 ; Attributes: bp-based frame
.text$mn:00003BC4
.text$mn:00003BC4 ; int __stdcall std::_Wrap_alloc<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * &>(void *, int)
.text$mn:00003BC4                 public ??$construct@PAVDockingSplitter@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z
.text$mn:00003BC4 ??$construct@PAVDockingSplitter@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z proc near
.text$mn:00003BC4                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+8Dp
.text$mn:00003BC4
.text$mn:00003BC4 var_4           = dword ptr -4
.text$mn:00003BC4 arg_0           = dword ptr  8
.text$mn:00003BC4 arg_4           = dword ptr  0Ch
.text$mn:00003BC4
.text$mn:00003BC4                 push    ebp
.text$mn:00003BC5                 mov     ebp, esp
.text$mn:00003BC7                 push    ecx
.text$mn:00003BC8                 mov     [ebp+var_4], ecx
.text$mn:00003BCB                 mov     eax, [ebp+arg_4]
.text$mn:00003BCE                 push    eax
.text$mn:00003BCF                 call    ??$forward@AAPAVDockingSplitter@@@std@@YAAAPAVDockingSplitter@@AAPAV1@@Z ; std::forward<DockingSplitter * &>(DockingSplitter * &)
.text$mn:00003BD4                 add     esp, 4
.text$mn:00003BD7                 push    eax             ; int
.text$mn:00003BD8                 mov     ecx, [ebp+arg_0]
.text$mn:00003BDB                 push    ecx             ; void *
.text$mn:00003BDC                 mov     edx, [ebp+var_4]
.text$mn:00003BDF                 push    edx             ; int
.text$mn:00003BE0                 call    ??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAXAAV?$allocator@PAVDockingSplitter@@@1@PAPAVDockingSplitter@@AAPAV3@@Z ; std::allocator_traits<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * &>(std::allocator<DockingSplitter *> &,DockingSplitter * *,DockingSplitter * &)
.text$mn:00003BE5                 add     esp, 0Ch
.text$mn:00003BE8                 mov     esp, ebp
.text$mn:00003BEA                 pop     ebp
.text$mn:00003BEB                 retn    8
.text$mn:00003BEB ??$construct@PAVDockingSplitter@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z endp
.text$mn:00003BEB
.text$mn:00003BEB ; ---------------------------------------------------------------------------
.text$mn:00003BEE                 align 10h
.text$mn:00003BEE _text$mn        ends
.text$mn:00003BEE
.text$mn:00003BF0 ; ===========================================================================
.text$mn:00003BF0
.text$mn:00003BF0 ; Segment type: Pure code
.text$mn:00003BF0 ; Segment permissions: Read/Execute
.text$mn:00003BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00003BF0                 assume cs:_text$mn
.text$mn:00003BF0                 ;org 3BF0h
.text$mn:00003BF0 ; COMDAT (pick any)
.text$mn:00003BF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BF0
.text$mn:00003BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BF0
.text$mn:00003BF0 ; Attributes: bp-based frame
.text$mn:00003BF0
.text$mn:00003BF0 ; int __stdcall std::allocator<DockingSplitter *>::construct<DockingSplitter *,DockingSplitter * &>(void *, int)
.text$mn:00003BF0                 public ??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z
.text$mn:00003BF0 ??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z proc near
.text$mn:00003BF0                                         ; CODE XREF: std::allocator_traits<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * &>(std::allocator<DockingSplitter *> &,DockingSplitter * *,DockingSplitter * &)+17p
.text$mn:00003BF0
.text$mn:00003BF0 var_1C          = dword ptr -1Ch
.text$mn:00003BF0 var_18          = dword ptr -18h
.text$mn:00003BF0 var_14          = dword ptr -14h
.text$mn:00003BF0 var_10          = dword ptr -10h
.text$mn:00003BF0 var_C           = dword ptr -0Ch
.text$mn:00003BF0 var_4           = dword ptr -4
.text$mn:00003BF0 arg_0           = dword ptr  8
.text$mn:00003BF0 arg_4           = dword ptr  0Ch
.text$mn:00003BF0
.text$mn:00003BF0                 push    ebp
.text$mn:00003BF1                 mov     ebp, esp
.text$mn:00003BF3                 push    0FFFFFFFFh
.text$mn:00003BF5                 push    offset __ehhandler$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z
.text$mn:00003BFA                 mov     eax, large fs:0
.text$mn:00003C00                 push    eax
.text$mn:00003C01                 sub     esp, 10h
.text$mn:00003C04                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C09                 xor     eax, ebp
.text$mn:00003C0B                 push    eax
.text$mn:00003C0C                 lea     eax, [ebp+var_C]
.text$mn:00003C0F                 mov     large fs:0, eax
.text$mn:00003C15                 mov     [ebp+var_18], ecx
.text$mn:00003C18                 mov     eax, [ebp+arg_0]
.text$mn:00003C1B                 push    eax             ; void *
.text$mn:00003C1C                 push    4               ; unsigned int
.text$mn:00003C1E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003C23                 add     esp, 8
.text$mn:00003C26                 mov     [ebp+var_10], eax
.text$mn:00003C29                 mov     [ebp+var_4], 0
.text$mn:00003C30                 cmp     [ebp+var_10], 0
.text$mn:00003C34                 jz      short loc_3C51
.text$mn:00003C36                 mov     ecx, [ebp+arg_4]
.text$mn:00003C39                 push    ecx
.text$mn:00003C3A                 call    ??$forward@AAPAVDockingSplitter@@@std@@YAAAPAVDockingSplitter@@AAPAV1@@Z ; std::forward<DockingSplitter * &>(DockingSplitter * &)
.text$mn:00003C3F                 add     esp, 4
.text$mn:00003C42                 mov     edx, [ebp+var_10]
.text$mn:00003C45                 mov     eax, [eax]
.text$mn:00003C47                 mov     [edx], eax
.text$mn:00003C49                 mov     ecx, [ebp+var_10]
.text$mn:00003C4C                 mov     [ebp+var_14], ecx
.text$mn:00003C4F                 jmp     short loc_3C58
.text$mn:00003C51 ; ---------------------------------------------------------------------------
.text$mn:00003C51
.text$mn:00003C51 loc_3C51:                               ; CODE XREF: std::allocator<DockingSplitter *>::construct<DockingSplitter *,DockingSplitter * &>(DockingSplitter * *,DockingSplitter * &)+44j
.text$mn:00003C51                 mov     [ebp+var_14], 0
.text$mn:00003C58
.text$mn:00003C58 loc_3C58:                               ; CODE XREF: std::allocator<DockingSplitter *>::construct<DockingSplitter *,DockingSplitter * &>(DockingSplitter * *,DockingSplitter * &)+5Fj
.text$mn:00003C58                 mov     edx, [ebp+var_14]
.text$mn:00003C5B                 mov     [ebp+var_1C], edx
.text$mn:00003C5E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003C65                 mov     ecx, [ebp+var_C]
.text$mn:00003C68                 mov     large fs:0, ecx
.text$mn:00003C6F                 pop     ecx
.text$mn:00003C70                 mov     esp, ebp
.text$mn:00003C72                 pop     ebp
.text$mn:00003C73                 retn    8
.text$mn:00003C73 ??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z endp
.text$mn:00003C73
.text$mn:00003C73 ; ---------------------------------------------------------------------------
.text$mn:00003C76                 align 4
.text$mn:00003C76 _text$mn        ends
.text$mn:00003C76
.text$x:00003C78 ; ===========================================================================
.text$x:00003C78
.text$x:00003C78 ; Segment type: Pure code
.text$x:00003C78 ; Segment permissions: Read/Execute
.text$x:00003C78 _text$x         segment para public 'CODE' use32
.text$x:00003C78                 assume cs:_text$x
.text$x:00003C78                 ;org 3C78h
.text$x:00003C78 ; COMDAT (pick associative to section at 3BF0)
.text$x:00003C78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003C78
.text$x:00003C78 ; =============== S U B R O U T I N E =======================================
.text$x:00003C78
.text$x:00003C78
.text$x:00003C78 __unwindfunclet$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z$0 proc near
.text$x:00003C78                                         ; DATA XREF: .xdata$x:00009B58o
.text$x:00003C78                 mov     eax, [ebp+8]
.text$x:00003C7B                 push    eax
.text$x:00003C7C                 mov     eax, [ebp-10h]
.text$x:00003C7F                 push    eax             ; void *
.text$x:00003C80                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003C85                 add     esp, 8
.text$x:00003C88                 retn
.text$x:00003C88 __unwindfunclet$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z$0 endp
.text$x:00003C88
.text$x:00003C89
.text$x:00003C89 ; =============== S U B R O U T I N E =======================================
.text$x:00003C89
.text$x:00003C89
.text$x:00003C89 __ehhandler$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z proc near
.text$x:00003C89                                         ; DATA XREF: std::allocator<DockingSplitter *>::construct<DockingSplitter *,DockingSplitter * &>(DockingSplitter * *,DockingSplitter * &)+5o
.text$x:00003C89
.text$x:00003C89 arg_4           = dword ptr  8
.text$x:00003C89
.text$x:00003C89                 mov     edx, [esp+arg_4]
.text$x:00003C8D                 lea     eax, [edx+0Ch]
.text$x:00003C90                 mov     ecx, [edx-14h]
.text$x:00003C93                 xor     ecx, eax
.text$x:00003C95                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003C9A                 mov     eax, offset __ehfuncinfo$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z
.text$x:00003C9F                 jmp     ___CxxFrameHandler3
.text$x:00003C9F __ehhandler$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z endp
.text$x:00003C9F
.text$x:00003C9F _text$x         ends
.text$x:00003C9F
.text$mn:00003CA4 ; ===========================================================================
.text$mn:00003CA4
.text$mn:00003CA4 ; Segment type: Pure code
.text$mn:00003CA4 ; Segment permissions: Read/Execute
.text$mn:00003CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00003CA4                 assume cs:_text$mn
.text$mn:00003CA4                 ;org 3CA4h
.text$mn:00003CA4 ; COMDAT (pick any)
.text$mn:00003CA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CA4
.text$mn:00003CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CA4
.text$mn:00003CA4 ; Attributes: bp-based frame
.text$mn:00003CA4
.text$mn:00003CA4 ; int __cdecl std::allocator_traits<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * &>(int, void *, int)
.text$mn:00003CA4                 public ??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAXAAV?$allocator@PAVDockingSplitter@@@1@PAPAVDockingSplitter@@AAPAV3@@Z
.text$mn:00003CA4 ??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAXAAV?$allocator@PAVDockingSplitter@@@1@PAPAVDockingSplitter@@AAPAV3@@Z proc near
.text$mn:00003CA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * &>(DockingSplitter * *,DockingSplitter * &)+1Cp
.text$mn:00003CA4
.text$mn:00003CA4 arg_0           = dword ptr  8
.text$mn:00003CA4 arg_4           = dword ptr  0Ch
.text$mn:00003CA4 arg_8           = dword ptr  10h
.text$mn:00003CA4
.text$mn:00003CA4                 push    ebp
.text$mn:00003CA5                 mov     ebp, esp
.text$mn:00003CA7                 mov     eax, [ebp+arg_8]
.text$mn:00003CAA                 push    eax
.text$mn:00003CAB                 call    ??$forward@AAPAVDockingSplitter@@@std@@YAAAPAVDockingSplitter@@AAPAV1@@Z ; std::forward<DockingSplitter * &>(DockingSplitter * &)
.text$mn:00003CB0                 add     esp, 4
.text$mn:00003CB3                 push    eax             ; int
.text$mn:00003CB4                 mov     ecx, [ebp+arg_4]
.text$mn:00003CB7                 push    ecx             ; void *
.text$mn:00003CB8                 mov     ecx, [ebp+arg_0]
.text$mn:00003CBB                 call    ??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z ; std::allocator<DockingSplitter *>::construct<DockingSplitter *,DockingSplitter * &>(DockingSplitter * *,DockingSplitter * &)
.text$mn:00003CC0                 pop     ebp
.text$mn:00003CC1                 retn
.text$mn:00003CC1 ??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAXAAV?$allocator@PAVDockingSplitter@@@1@PAPAVDockingSplitter@@AAPAV3@@Z endp
.text$mn:00003CC1
.text$mn:00003CC1 ; ---------------------------------------------------------------------------
.text$mn:00003CC2                 align 4
.text$mn:00003CC2 _text$mn        ends
.text$mn:00003CC2
.text$mn:00003CC4 ; ===========================================================================
.text$mn:00003CC4
.text$mn:00003CC4 ; Segment type: Pure code
.text$mn:00003CC4 ; Segment permissions: Read/Execute
.text$mn:00003CC4 _text$mn        segment para public 'CODE' use32
.text$mn:00003CC4                 assume cs:_text$mn
.text$mn:00003CC4                 ;org 3CC4h
.text$mn:00003CC4 ; COMDAT (pick any)
.text$mn:00003CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CC4
.text$mn:00003CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CC4
.text$mn:00003CC4 ; Attributes: bp-based frame
.text$mn:00003CC4
.text$mn:00003CC4 ; int __stdcall std::_Wrap_alloc<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * const &>(void *, int)
.text$mn:00003CC4                 public ??$construct@PAVDockingSplitter@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@ABQAV2@@Z
.text$mn:00003CC4 ??$construct@PAVDockingSplitter@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@ABQAV2@@Z proc near
.text$mn:00003CC4                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+EAp
.text$mn:00003CC4
.text$mn:00003CC4 var_4           = dword ptr -4
.text$mn:00003CC4 arg_0           = dword ptr  8
.text$mn:00003CC4 arg_4           = dword ptr  0Ch
.text$mn:00003CC4
.text$mn:00003CC4                 push    ebp
.text$mn:00003CC5                 mov     ebp, esp
.text$mn:00003CC7                 push    ecx
.text$mn:00003CC8                 mov     [ebp+var_4], ecx
.text$mn:00003CCB                 mov     eax, [ebp+arg_4]
.text$mn:00003CCE                 push    eax
.text$mn:00003CCF                 call    ??$forward@ABQAVDockingSplitter@@@std@@YAABQAVDockingSplitter@@ABQAV1@@Z ; std::forward<DockingSplitter * const &>(DockingSplitter * const &)
.text$mn:00003CD4                 add     esp, 4
.text$mn:00003CD7                 push    eax             ; int
.text$mn:00003CD8                 mov     ecx, [ebp+arg_0]
.text$mn:00003CDB                 push    ecx             ; void *
.text$mn:00003CDC                 mov     edx, [ebp+var_4]
.text$mn:00003CDF                 push    edx             ; int
.text$mn:00003CE0                 call    ??$construct@PAVDockingSplitter@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAXAAV?$allocator@PAVDockingSplitter@@@1@PAPAVDockingSplitter@@ABQAV3@@Z ; std::allocator_traits<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * const &>(std::allocator<DockingSplitter *> &,DockingSplitter * *,DockingSplitter * const &)
.text$mn:00003CE5                 add     esp, 0Ch
.text$mn:00003CE8                 mov     esp, ebp
.text$mn:00003CEA                 pop     ebp
.text$mn:00003CEB                 retn    8
.text$mn:00003CEB ??$construct@PAVDockingSplitter@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@ABQAV2@@Z endp
.text$mn:00003CEB
.text$mn:00003CEB ; ---------------------------------------------------------------------------
.text$mn:00003CEE                 align 10h
.text$mn:00003CEE _text$mn        ends
.text$mn:00003CEE
.text$mn:00003CF0 ; ===========================================================================
.text$mn:00003CF0
.text$mn:00003CF0 ; Segment type: Pure code
.text$mn:00003CF0 ; Segment permissions: Read/Execute
.text$mn:00003CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00003CF0                 assume cs:_text$mn
.text$mn:00003CF0                 ;org 3CF0h
.text$mn:00003CF0 ; COMDAT (pick any)
.text$mn:00003CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CF0
.text$mn:00003CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CF0
.text$mn:00003CF0 ; Attributes: bp-based frame
.text$mn:00003CF0
.text$mn:00003CF0 ; int __cdecl std::allocator_traits<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * const &>(int, void *, int)
.text$mn:00003CF0                 public ??$construct@PAVDockingSplitter@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAXAAV?$allocator@PAVDockingSplitter@@@1@PAPAVDockingSplitter@@ABQAV3@@Z
.text$mn:00003CF0 ??$construct@PAVDockingSplitter@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAXAAV?$allocator@PAVDockingSplitter@@@1@PAPAVDockingSplitter@@ABQAV3@@Z proc near
.text$mn:00003CF0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * const &>(DockingSplitter * *,DockingSplitter * const &)+1Cp
.text$mn:00003CF0
.text$mn:00003CF0 arg_0           = dword ptr  8
.text$mn:00003CF0 arg_4           = dword ptr  0Ch
.text$mn:00003CF0 arg_8           = dword ptr  10h
.text$mn:00003CF0
.text$mn:00003CF0                 push    ebp
.text$mn:00003CF1                 mov     ebp, esp
.text$mn:00003CF3                 mov     eax, [ebp+arg_8]
.text$mn:00003CF6                 push    eax
.text$mn:00003CF7                 call    ??$forward@ABQAVDockingSplitter@@@std@@YAABQAVDockingSplitter@@ABQAV1@@Z ; std::forward<DockingSplitter * const &>(DockingSplitter * const &)
.text$mn:00003CFC                 add     esp, 4
.text$mn:00003CFF                 push    eax             ; int
.text$mn:00003D00                 mov     ecx, [ebp+arg_4]
.text$mn:00003D03                 push    ecx             ; void *
.text$mn:00003D04                 mov     ecx, [ebp+arg_0]
.text$mn:00003D07                 call    ?construct@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@ABQAV3@@Z ; std::allocator<DockingSplitter *>::construct(DockingSplitter * *,DockingSplitter * const &)
.text$mn:00003D0C                 pop     ebp
.text$mn:00003D0D                 retn
.text$mn:00003D0D ??$construct@PAVDockingSplitter@@ABQAV1@@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAXAAV?$allocator@PAVDockingSplitter@@@1@PAPAVDockingSplitter@@ABQAV3@@Z endp
.text$mn:00003D0D
.text$mn:00003D0D ; ---------------------------------------------------------------------------
.text$mn:00003D0E                 align 10h
.text$mn:00003D0E _text$mn        ends
.text$mn:00003D0E
.text$mn:00003D10 ; ===========================================================================
.text$mn:00003D10
.text$mn:00003D10 ; Segment type: Pure code
.text$mn:00003D10 ; Segment permissions: Read/Execute
.text$mn:00003D10 _text$mn        segment para public 'CODE' use32
.text$mn:00003D10                 assume cs:_text$mn
.text$mn:00003D10                 ;org 3D10h
.text$mn:00003D10 ; COMDAT (pick any)
.text$mn:00003D10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D10
.text$mn:00003D10 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D10
.text$mn:00003D10 ; Attributes: bp-based frame
.text$mn:00003D10
.text$mn:00003D10 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00003D10                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00003D10 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00003D10                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Alloc_proxy(void)+32p
.text$mn:00003D10                                         ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Alloc_proxy(void)+32p ...
.text$mn:00003D10
.text$mn:00003D10 var_4           = dword ptr -4
.text$mn:00003D10 arg_0           = dword ptr  8
.text$mn:00003D10 arg_4           = dword ptr  0Ch
.text$mn:00003D10
.text$mn:00003D10                 push    ebp
.text$mn:00003D11                 mov     ebp, esp
.text$mn:00003D13                 push    ecx
.text$mn:00003D14                 mov     [ebp+var_4], ecx
.text$mn:00003D17                 mov     eax, [ebp+arg_4]
.text$mn:00003D1A                 push    eax
.text$mn:00003D1B                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00003D20                 add     esp, 4
.text$mn:00003D23                 push    eax             ; int
.text$mn:00003D24                 mov     ecx, [ebp+arg_0]
.text$mn:00003D27                 push    ecx             ; void *
.text$mn:00003D28                 mov     edx, [ebp+var_4]
.text$mn:00003D2B                 push    edx             ; int
.text$mn:00003D2C                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003D31                 add     esp, 0Ch
.text$mn:00003D34                 mov     esp, ebp
.text$mn:00003D36                 pop     ebp
.text$mn:00003D37                 retn    8
.text$mn:00003D37 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00003D37
.text$mn:00003D37 ; ---------------------------------------------------------------------------
.text$mn:00003D3A                 align 4
.text$mn:00003D3A _text$mn        ends
.text$mn:00003D3A
.text$mn:00003D3C ; ===========================================================================
.text$mn:00003D3C
.text$mn:00003D3C ; Segment type: Pure code
.text$mn:00003D3C ; Segment permissions: Read/Execute
.text$mn:00003D3C _text$mn        segment para public 'CODE' use32
.text$mn:00003D3C                 assume cs:_text$mn
.text$mn:00003D3C                 ;org 3D3Ch
.text$mn:00003D3C ; COMDAT (pick any)
.text$mn:00003D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D3C
.text$mn:00003D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D3C
.text$mn:00003D3C ; Attributes: bp-based frame
.text$mn:00003D3C
.text$mn:00003D3C ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00003D3C                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00003D3C ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00003D3C                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00003D3C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00003D3C
.text$mn:00003D3C var_1C          = dword ptr -1Ch
.text$mn:00003D3C var_18          = dword ptr -18h
.text$mn:00003D3C var_14          = dword ptr -14h
.text$mn:00003D3C var_10          = dword ptr -10h
.text$mn:00003D3C var_C           = dword ptr -0Ch
.text$mn:00003D3C var_4           = dword ptr -4
.text$mn:00003D3C arg_0           = dword ptr  8
.text$mn:00003D3C arg_4           = dword ptr  0Ch
.text$mn:00003D3C
.text$mn:00003D3C                 push    ebp
.text$mn:00003D3D                 mov     ebp, esp
.text$mn:00003D3F                 push    0FFFFFFFFh
.text$mn:00003D41                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00003D46                 mov     eax, large fs:0
.text$mn:00003D4C                 push    eax
.text$mn:00003D4D                 sub     esp, 10h
.text$mn:00003D50                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003D55                 xor     eax, ebp
.text$mn:00003D57                 push    eax
.text$mn:00003D58                 lea     eax, [ebp+var_C]
.text$mn:00003D5B                 mov     large fs:0, eax
.text$mn:00003D61                 mov     [ebp+var_18], ecx
.text$mn:00003D64                 mov     eax, [ebp+arg_0]
.text$mn:00003D67                 push    eax             ; void *
.text$mn:00003D68                 push    8               ; unsigned int
.text$mn:00003D6A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003D6F                 add     esp, 8
.text$mn:00003D72                 mov     [ebp+var_10], eax
.text$mn:00003D75                 mov     [ebp+var_4], 0
.text$mn:00003D7C                 cmp     [ebp+var_10], 0
.text$mn:00003D80                 jz      short loc_3DA3
.text$mn:00003D82                 mov     ecx, [ebp+arg_4]
.text$mn:00003D85                 push    ecx
.text$mn:00003D86                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00003D8B                 add     esp, 4
.text$mn:00003D8E                 mov     edx, [eax]
.text$mn:00003D90                 mov     eax, [eax+4]
.text$mn:00003D93                 mov     ecx, [ebp+var_10]
.text$mn:00003D96                 mov     [ecx], edx
.text$mn:00003D98                 mov     [ecx+4], eax
.text$mn:00003D9B                 mov     edx, [ebp+var_10]
.text$mn:00003D9E                 mov     [ebp+var_14], edx
.text$mn:00003DA1                 jmp     short loc_3DAA
.text$mn:00003DA3 ; ---------------------------------------------------------------------------
.text$mn:00003DA3
.text$mn:00003DA3 loc_3DA3:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00003DA3                 mov     [ebp+var_14], 0
.text$mn:00003DAA
.text$mn:00003DAA loc_3DAA:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00003DAA                 mov     eax, [ebp+var_14]
.text$mn:00003DAD                 mov     [ebp+var_1C], eax
.text$mn:00003DB0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003DB7                 mov     ecx, [ebp+var_C]
.text$mn:00003DBA                 mov     large fs:0, ecx
.text$mn:00003DC1                 pop     ecx
.text$mn:00003DC2                 mov     esp, ebp
.text$mn:00003DC4                 pop     ebp
.text$mn:00003DC5                 retn    8
.text$mn:00003DC5 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00003DC5
.text$mn:00003DC5 _text$mn        ends
.text$mn:00003DC5
.text$x:00003DC8 ; ===========================================================================
.text$x:00003DC8
.text$x:00003DC8 ; Segment type: Pure code
.text$x:00003DC8 ; Segment permissions: Read/Execute
.text$x:00003DC8 _text$x         segment para public 'CODE' use32
.text$x:00003DC8                 assume cs:_text$x
.text$x:00003DC8                 ;org 3DC8h
.text$x:00003DC8 ; COMDAT (pick associative to section at 3D3C)
.text$x:00003DC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003DC8
.text$x:00003DC8 ; =============== S U B R O U T I N E =======================================
.text$x:00003DC8
.text$x:00003DC8
.text$x:00003DC8 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00003DC8                                         ; DATA XREF: .xdata$x:00009A64o
.text$x:00003DC8                 mov     eax, [ebp+8]
.text$x:00003DCB                 push    eax
.text$x:00003DCC                 mov     eax, [ebp-10h]
.text$x:00003DCF                 push    eax             ; void *
.text$x:00003DD0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003DD5                 add     esp, 8
.text$x:00003DD8                 retn
.text$x:00003DD8 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00003DD8
.text$x:00003DD9
.text$x:00003DD9 ; =============== S U B R O U T I N E =======================================
.text$x:00003DD9
.text$x:00003DD9
.text$x:00003DD9 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00003DD9                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00003DD9
.text$x:00003DD9 arg_4           = dword ptr  8
.text$x:00003DD9
.text$x:00003DD9                 mov     edx, [esp+arg_4]
.text$x:00003DDD                 lea     eax, [edx+0Ch]
.text$x:00003DE0                 mov     ecx, [edx-14h]
.text$x:00003DE3                 xor     ecx, eax
.text$x:00003DE5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003DEA                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00003DEF                 jmp     ___CxxFrameHandler3
.text$x:00003DEF __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00003DEF
.text$x:00003DEF _text$x         ends
.text$x:00003DEF
.text$mn:00003DF4 ; ===========================================================================
.text$mn:00003DF4
.text$mn:00003DF4 ; Segment type: Pure code
.text$mn:00003DF4 ; Segment permissions: Read/Execute
.text$mn:00003DF4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DF4                 assume cs:_text$mn
.text$mn:00003DF4                 ;org 3DF4h
.text$mn:00003DF4 ; COMDAT (pick any)
.text$mn:00003DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DF4
.text$mn:00003DF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DF4
.text$mn:00003DF4 ; Attributes: bp-based frame
.text$mn:00003DF4
.text$mn:00003DF4 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00003DF4                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00003DF4 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00003DF4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00003DF4
.text$mn:00003DF4 arg_0           = dword ptr  8
.text$mn:00003DF4 arg_4           = dword ptr  0Ch
.text$mn:00003DF4 arg_8           = dword ptr  10h
.text$mn:00003DF4
.text$mn:00003DF4                 push    ebp
.text$mn:00003DF5                 mov     ebp, esp
.text$mn:00003DF7                 mov     eax, [ebp+arg_8]
.text$mn:00003DFA                 push    eax
.text$mn:00003DFB                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00003E00                 add     esp, 4
.text$mn:00003E03                 push    eax             ; int
.text$mn:00003E04                 mov     ecx, [ebp+arg_4]
.text$mn:00003E07                 push    ecx             ; void *
.text$mn:00003E08                 mov     ecx, [ebp+arg_0]
.text$mn:00003E0B                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003E10                 pop     ebp
.text$mn:00003E11                 retn
.text$mn:00003E11 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00003E11
.text$mn:00003E11 ; ---------------------------------------------------------------------------
.text$mn:00003E12                 align 4
.text$mn:00003E12 _text$mn        ends
.text$mn:00003E12
.text$mn:00003E14 ; ===========================================================================
.text$mn:00003E14
.text$mn:00003E14 ; Segment type: Pure code
.text$mn:00003E14 ; Segment permissions: Read/Execute
.text$mn:00003E14 _text$mn        segment para public 'CODE' use32
.text$mn:00003E14                 assume cs:_text$mn
.text$mn:00003E14                 ;org 3E14h
.text$mn:00003E14 ; COMDAT (pick any)
.text$mn:00003E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E14
.text$mn:00003E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E14
.text$mn:00003E14 ; Attributes: bp-based frame
.text$mn:00003E14
.text$mn:00003E14 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00003E14                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00003E14 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00003E14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00003E14
.text$mn:00003E14 var_4           = dword ptr -4
.text$mn:00003E14 arg_0           = dword ptr  8
.text$mn:00003E14
.text$mn:00003E14                 push    ebp
.text$mn:00003E15                 mov     ebp, esp
.text$mn:00003E17                 push    ecx
.text$mn:00003E18                 mov     [ebp+var_4], ecx
.text$mn:00003E1B                 mov     eax, [ebp+arg_0]
.text$mn:00003E1E                 push    eax
.text$mn:00003E1F                 mov     ecx, [ebp+var_4]
.text$mn:00003E22                 push    ecx
.text$mn:00003E23                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00003E28                 add     esp, 8
.text$mn:00003E2B                 mov     esp, ebp
.text$mn:00003E2D                 pop     ebp
.text$mn:00003E2E                 retn    4
.text$mn:00003E2E ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00003E2E
.text$mn:00003E2E ; ---------------------------------------------------------------------------
.text$mn:00003E31                 align 4
.text$mn:00003E31 _text$mn        ends
.text$mn:00003E31
.text$mn:00003E34 ; ===========================================================================
.text$mn:00003E34
.text$mn:00003E34 ; Segment type: Pure code
.text$mn:00003E34 ; Segment permissions: Read/Execute
.text$mn:00003E34 _text$mn        segment para public 'CODE' use32
.text$mn:00003E34                 assume cs:_text$mn
.text$mn:00003E34                 ;org 3E34h
.text$mn:00003E34 ; COMDAT (pick any)
.text$mn:00003E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E34
.text$mn:00003E34 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E34
.text$mn:00003E34 ; Attributes: bp-based frame
.text$mn:00003E34
.text$mn:00003E34 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00003E34                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00003E34 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00003E34                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00003E34
.text$mn:00003E34 var_4           = dword ptr -4
.text$mn:00003E34
.text$mn:00003E34                 push    ebp
.text$mn:00003E35                 mov     ebp, esp
.text$mn:00003E37                 push    ecx
.text$mn:00003E38                 mov     [ebp+var_4], ecx
.text$mn:00003E3B                 mov     esp, ebp
.text$mn:00003E3D                 pop     ebp
.text$mn:00003E3E                 retn    4
.text$mn:00003E3E ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00003E3E
.text$mn:00003E3E ; ---------------------------------------------------------------------------
.text$mn:00003E41                 align 4
.text$mn:00003E41 _text$mn        ends
.text$mn:00003E41
.text$mn:00003E44 ; ===========================================================================
.text$mn:00003E44
.text$mn:00003E44 ; Segment type: Pure code
.text$mn:00003E44 ; Segment permissions: Read/Execute
.text$mn:00003E44 _text$mn        segment para public 'CODE' use32
.text$mn:00003E44                 assume cs:_text$mn
.text$mn:00003E44                 ;org 3E44h
.text$mn:00003E44 ; COMDAT (pick any)
.text$mn:00003E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E44
.text$mn:00003E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E44
.text$mn:00003E44 ; Attributes: bp-based frame
.text$mn:00003E44
.text$mn:00003E44 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00003E44                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00003E44 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00003E44                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00003E44
.text$mn:00003E44 arg_0           = dword ptr  8
.text$mn:00003E44 arg_4           = dword ptr  0Ch
.text$mn:00003E44
.text$mn:00003E44                 push    ebp
.text$mn:00003E45                 mov     ebp, esp
.text$mn:00003E47                 mov     eax, [ebp+arg_4]
.text$mn:00003E4A                 push    eax
.text$mn:00003E4B                 mov     ecx, [ebp+arg_0]
.text$mn:00003E4E                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00003E53                 pop     ebp
.text$mn:00003E54                 retn
.text$mn:00003E54 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00003E54
.text$mn:00003E54 ; ---------------------------------------------------------------------------
.text$mn:00003E55                 align 4
.text$mn:00003E55 _text$mn        ends
.text$mn:00003E55
.text$mn:00003E58 ; ===========================================================================
.text$mn:00003E58
.text$mn:00003E58 ; Segment type: Pure code
.text$mn:00003E58 ; Segment permissions: Read/Execute
.text$mn:00003E58 _text$mn        segment para public 'CODE' use32
.text$mn:00003E58                 assume cs:_text$mn
.text$mn:00003E58                 ;org 3E58h
.text$mn:00003E58 ; COMDAT (pick any)
.text$mn:00003E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E58
.text$mn:00003E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E58
.text$mn:00003E58 ; Attributes: bp-based frame
.text$mn:00003E58
.text$mn:00003E58 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00003E58                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00003E58 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00003E58                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Free_proxy(void)+22p
.text$mn:00003E58                                         ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Free_proxy(void)+22p ...
.text$mn:00003E58
.text$mn:00003E58 var_4           = dword ptr -4
.text$mn:00003E58 arg_0           = dword ptr  8
.text$mn:00003E58
.text$mn:00003E58                 push    ebp
.text$mn:00003E59                 mov     ebp, esp
.text$mn:00003E5B                 push    ecx
.text$mn:00003E5C                 mov     [ebp+var_4], ecx
.text$mn:00003E5F                 mov     eax, [ebp+arg_0]
.text$mn:00003E62                 push    eax
.text$mn:00003E63                 mov     ecx, [ebp+var_4]
.text$mn:00003E66                 push    ecx
.text$mn:00003E67                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00003E6C                 add     esp, 8
.text$mn:00003E6F                 mov     esp, ebp
.text$mn:00003E71                 pop     ebp
.text$mn:00003E72                 retn    4
.text$mn:00003E72 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00003E72
.text$mn:00003E72 ; ---------------------------------------------------------------------------
.text$mn:00003E75                 align 4
.text$mn:00003E75 _text$mn        ends
.text$mn:00003E75
.text$mn:00003E78 ; ===========================================================================
.text$mn:00003E78
.text$mn:00003E78 ; Segment type: Pure code
.text$mn:00003E78 ; Segment permissions: Read/Execute
.text$mn:00003E78 _text$mn        segment para public 'CODE' use32
.text$mn:00003E78                 assume cs:_text$mn
.text$mn:00003E78                 ;org 3E78h
.text$mn:00003E78 ; COMDAT (pick any)
.text$mn:00003E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E78
.text$mn:00003E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E78
.text$mn:00003E78 ; Attributes: bp-based frame
.text$mn:00003E78
.text$mn:00003E78 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00003E78                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00003E78 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00003E78                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00003E78                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00003E78
.text$mn:00003E78 var_4           = dword ptr -4
.text$mn:00003E78
.text$mn:00003E78                 push    ebp
.text$mn:00003E79                 mov     ebp, esp
.text$mn:00003E7B                 push    ecx
.text$mn:00003E7C                 mov     [ebp+var_4], ecx
.text$mn:00003E7F                 mov     esp, ebp
.text$mn:00003E81                 pop     ebp
.text$mn:00003E82                 retn    4
.text$mn:00003E82 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00003E82
.text$mn:00003E82 ; ---------------------------------------------------------------------------
.text$mn:00003E85                 align 4
.text$mn:00003E85 _text$mn        ends
.text$mn:00003E85
.text$mn:00003E88 ; ===========================================================================
.text$mn:00003E88
.text$mn:00003E88 ; Segment type: Pure code
.text$mn:00003E88 ; Segment permissions: Read/Execute
.text$mn:00003E88 _text$mn        segment para public 'CODE' use32
.text$mn:00003E88                 assume cs:_text$mn
.text$mn:00003E88                 ;org 3E88h
.text$mn:00003E88 ; COMDAT (pick any)
.text$mn:00003E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E88
.text$mn:00003E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E88
.text$mn:00003E88 ; Attributes: bp-based frame
.text$mn:00003E88
.text$mn:00003E88 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00003E88                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00003E88 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00003E88                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00003E88
.text$mn:00003E88 arg_0           = dword ptr  8
.text$mn:00003E88 arg_4           = dword ptr  0Ch
.text$mn:00003E88
.text$mn:00003E88                 push    ebp
.text$mn:00003E89                 mov     ebp, esp
.text$mn:00003E8B                 mov     eax, [ebp+arg_4]
.text$mn:00003E8E                 push    eax
.text$mn:00003E8F                 mov     ecx, [ebp+arg_0]
.text$mn:00003E92                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00003E97                 pop     ebp
.text$mn:00003E98                 retn
.text$mn:00003E98 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00003E98
.text$mn:00003E98 ; ---------------------------------------------------------------------------
.text$mn:00003E99                 align 4
.text$mn:00003E99 _text$mn        ends
.text$mn:00003E99
.text$mn:00003E9C ; ===========================================================================
.text$mn:00003E9C
.text$mn:00003E9C ; Segment type: Pure code
.text$mn:00003E9C ; Segment permissions: Read/Execute
.text$mn:00003E9C _text$mn        segment para public 'CODE' use32
.text$mn:00003E9C                 assume cs:_text$mn
.text$mn:00003E9C                 ;org 3E9Ch
.text$mn:00003E9C ; COMDAT (pick any)
.text$mn:00003E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E9C
.text$mn:00003E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E9C
.text$mn:00003E9C ; Attributes: bp-based frame
.text$mn:00003E9C
.text$mn:00003E9C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00003E9C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00003E9C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00003E9C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00003E9C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00003E9C
.text$mn:00003E9C arg_0           = dword ptr  8
.text$mn:00003E9C
.text$mn:00003E9C                 push    ebp
.text$mn:00003E9D                 mov     ebp, esp
.text$mn:00003E9F                 mov     eax, [ebp+arg_0]
.text$mn:00003EA2                 pop     ebp
.text$mn:00003EA3                 retn
.text$mn:00003EA3 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00003EA3
.text$mn:00003EA3 _text$mn        ends
.text$mn:00003EA3
.text$mn:00003EA4 ; ===========================================================================
.text$mn:00003EA4
.text$mn:00003EA4 ; Segment type: Pure code
.text$mn:00003EA4 ; Segment permissions: Read/Execute
.text$mn:00003EA4 _text$mn        segment para public 'CODE' use32
.text$mn:00003EA4                 assume cs:_text$mn
.text$mn:00003EA4                 ;org 3EA4h
.text$mn:00003EA4 ; COMDAT (pick any)
.text$mn:00003EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EA4
.text$mn:00003EA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EA4
.text$mn:00003EA4 ; Attributes: bp-based frame
.text$mn:00003EA4
.text$mn:00003EA4 ; struct HWND__ * & __cdecl std::forward<struct HWND__ * &>(struct HWND__ * &)
.text$mn:00003EA4                 public ??$forward@AAPAUHWND__@@@std@@YAAAPAUHWND__@@AAPAU1@@Z
.text$mn:00003EA4 ??$forward@AAPAUHWND__@@@std@@YAAAPAUHWND__@@AAPAU1@@Z proc near
.text$mn:00003EA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * &>(HWND__ * *,HWND__ * &)+Bp
.text$mn:00003EA4                                         ; std::allocator<HWND__ *>::construct<HWND__ *,HWND__ * &>(HWND__ * *,HWND__ * &)+4Ap ...
.text$mn:00003EA4
.text$mn:00003EA4 arg_0           = dword ptr  8
.text$mn:00003EA4
.text$mn:00003EA4                 push    ebp
.text$mn:00003EA5                 mov     ebp, esp
.text$mn:00003EA7                 mov     eax, [ebp+arg_0]
.text$mn:00003EAA                 pop     ebp
.text$mn:00003EAB                 retn
.text$mn:00003EAB ??$forward@AAPAUHWND__@@@std@@YAAAPAUHWND__@@AAPAU1@@Z endp
.text$mn:00003EAB
.text$mn:00003EAB _text$mn        ends
.text$mn:00003EAB
.text$mn:00003EAC ; ===========================================================================
.text$mn:00003EAC
.text$mn:00003EAC ; Segment type: Pure code
.text$mn:00003EAC ; Segment permissions: Read/Execute
.text$mn:00003EAC _text$mn        segment para public 'CODE' use32
.text$mn:00003EAC                 assume cs:_text$mn
.text$mn:00003EAC                 ;org 3EACh
.text$mn:00003EAC ; COMDAT (pick any)
.text$mn:00003EAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EAC
.text$mn:00003EAC ; =============== S U B R O U T I N E =======================================
.text$mn:00003EAC
.text$mn:00003EAC ; Attributes: bp-based frame
.text$mn:00003EAC
.text$mn:00003EAC ; class DockingCont * & __cdecl std::forward<class DockingCont * &>(class DockingCont * &)
.text$mn:00003EAC                 public ??$forward@AAPAVDockingCont@@@std@@YAAAPAVDockingCont@@AAPAV1@@Z
.text$mn:00003EAC ??$forward@AAPAVDockingCont@@@std@@YAAAPAVDockingCont@@AAPAV1@@Z proc near
.text$mn:00003EAC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * &>(DockingCont * *,DockingCont * &)+Bp
.text$mn:00003EAC                                         ; std::allocator<DockingCont *>::construct<DockingCont *,DockingCont * &>(DockingCont * *,DockingCont * &)+4Ap ...
.text$mn:00003EAC
.text$mn:00003EAC arg_0           = dword ptr  8
.text$mn:00003EAC
.text$mn:00003EAC                 push    ebp
.text$mn:00003EAD                 mov     ebp, esp
.text$mn:00003EAF                 mov     eax, [ebp+arg_0]
.text$mn:00003EB2                 pop     ebp
.text$mn:00003EB3                 retn
.text$mn:00003EB3 ??$forward@AAPAVDockingCont@@@std@@YAAAPAVDockingCont@@AAPAV1@@Z endp
.text$mn:00003EB3
.text$mn:00003EB3 _text$mn        ends
.text$mn:00003EB3
.text$mn:00003EB4 ; ===========================================================================
.text$mn:00003EB4
.text$mn:00003EB4 ; Segment type: Pure code
.text$mn:00003EB4 ; Segment permissions: Read/Execute
.text$mn:00003EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00003EB4                 assume cs:_text$mn
.text$mn:00003EB4                 ;org 3EB4h
.text$mn:00003EB4 ; COMDAT (pick any)
.text$mn:00003EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EB4
.text$mn:00003EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EB4
.text$mn:00003EB4 ; Attributes: bp-based frame
.text$mn:00003EB4
.text$mn:00003EB4 ; class DockingSplitter * & __cdecl std::forward<class DockingSplitter * &>(class DockingSplitter * &)
.text$mn:00003EB4                 public ??$forward@AAPAVDockingSplitter@@@std@@YAAAPAVDockingSplitter@@AAPAV1@@Z
.text$mn:00003EB4 ??$forward@AAPAVDockingSplitter@@@std@@YAAAPAVDockingSplitter@@AAPAV1@@Z proc near
.text$mn:00003EB4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * &>(DockingSplitter * *,DockingSplitter * &)+Bp
.text$mn:00003EB4                                         ; std::allocator<DockingSplitter *>::construct<DockingSplitter *,DockingSplitter * &>(DockingSplitter * *,DockingSplitter * &)+4Ap ...
.text$mn:00003EB4
.text$mn:00003EB4 arg_0           = dword ptr  8
.text$mn:00003EB4
.text$mn:00003EB4                 push    ebp
.text$mn:00003EB5                 mov     ebp, esp
.text$mn:00003EB7                 mov     eax, [ebp+arg_0]
.text$mn:00003EBA                 pop     ebp
.text$mn:00003EBB                 retn
.text$mn:00003EBB ??$forward@AAPAVDockingSplitter@@@std@@YAAAPAVDockingSplitter@@AAPAV1@@Z endp
.text$mn:00003EBB
.text$mn:00003EBB _text$mn        ends
.text$mn:00003EBB
.text$mn:00003EBC ; ===========================================================================
.text$mn:00003EBC
.text$mn:00003EBC ; Segment type: Pure code
.text$mn:00003EBC ; Segment permissions: Read/Execute
.text$mn:00003EBC _text$mn        segment para public 'CODE' use32
.text$mn:00003EBC                 assume cs:_text$mn
.text$mn:00003EBC                 ;org 3EBCh
.text$mn:00003EBC ; COMDAT (pick any)
.text$mn:00003EBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EBC
.text$mn:00003EBC ; =============== S U B R O U T I N E =======================================
.text$mn:00003EBC
.text$mn:00003EBC ; Attributes: bp-based frame
.text$mn:00003EBC
.text$mn:00003EBC ; struct HWND__ * const & __cdecl std::forward<struct HWND__ * const &>(struct HWND__ * const &)
.text$mn:00003EBC                 public ??$forward@ABQAUHWND__@@@std@@YAABQAUHWND__@@ABQAU1@@Z
.text$mn:00003EBC ??$forward@ABQAUHWND__@@@std@@YAABQAUHWND__@@ABQAU1@@Z proc near
.text$mn:00003EBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * const &>(HWND__ * *,HWND__ * const &)+Bp
.text$mn:00003EBC                                         ; std::allocator_traits<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * const &>(std::allocator<HWND__ *> &,HWND__ * *,HWND__ * const &)+7p
.text$mn:00003EBC
.text$mn:00003EBC arg_0           = dword ptr  8
.text$mn:00003EBC
.text$mn:00003EBC                 push    ebp
.text$mn:00003EBD                 mov     ebp, esp
.text$mn:00003EBF                 mov     eax, [ebp+arg_0]
.text$mn:00003EC2                 pop     ebp
.text$mn:00003EC3                 retn
.text$mn:00003EC3 ??$forward@ABQAUHWND__@@@std@@YAABQAUHWND__@@ABQAU1@@Z endp
.text$mn:00003EC3
.text$mn:00003EC3 _text$mn        ends
.text$mn:00003EC3
.text$mn:00003EC4 ; ===========================================================================
.text$mn:00003EC4
.text$mn:00003EC4 ; Segment type: Pure code
.text$mn:00003EC4 ; Segment permissions: Read/Execute
.text$mn:00003EC4 _text$mn        segment para public 'CODE' use32
.text$mn:00003EC4                 assume cs:_text$mn
.text$mn:00003EC4                 ;org 3EC4h
.text$mn:00003EC4 ; COMDAT (pick any)
.text$mn:00003EC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EC4
.text$mn:00003EC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EC4
.text$mn:00003EC4 ; Attributes: bp-based frame
.text$mn:00003EC4
.text$mn:00003EC4 ; class DockingCont * const & __cdecl std::forward<class DockingCont * const &>(class DockingCont * const &)
.text$mn:00003EC4                 public ??$forward@ABQAVDockingCont@@@std@@YAABQAVDockingCont@@ABQAV1@@Z
.text$mn:00003EC4 ??$forward@ABQAVDockingCont@@@std@@YAABQAVDockingCont@@ABQAV1@@Z proc near
.text$mn:00003EC4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * const &>(DockingCont * *,DockingCont * const &)+Bp
.text$mn:00003EC4                                         ; std::allocator_traits<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * const &>(std::allocator<DockingCont *> &,DockingCont * *,DockingCont * const &)+7p
.text$mn:00003EC4
.text$mn:00003EC4 arg_0           = dword ptr  8
.text$mn:00003EC4
.text$mn:00003EC4                 push    ebp
.text$mn:00003EC5                 mov     ebp, esp
.text$mn:00003EC7                 mov     eax, [ebp+arg_0]
.text$mn:00003ECA                 pop     ebp
.text$mn:00003ECB                 retn
.text$mn:00003ECB ??$forward@ABQAVDockingCont@@@std@@YAABQAVDockingCont@@ABQAV1@@Z endp
.text$mn:00003ECB
.text$mn:00003ECB _text$mn        ends
.text$mn:00003ECB
.text$mn:00003ECC ; ===========================================================================
.text$mn:00003ECC
.text$mn:00003ECC ; Segment type: Pure code
.text$mn:00003ECC ; Segment permissions: Read/Execute
.text$mn:00003ECC _text$mn        segment para public 'CODE' use32
.text$mn:00003ECC                 assume cs:_text$mn
.text$mn:00003ECC                 ;org 3ECCh
.text$mn:00003ECC ; COMDAT (pick any)
.text$mn:00003ECC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003ECC
.text$mn:00003ECC ; =============== S U B R O U T I N E =======================================
.text$mn:00003ECC
.text$mn:00003ECC ; Attributes: bp-based frame
.text$mn:00003ECC
.text$mn:00003ECC ; class DockingSplitter * const & __cdecl std::forward<class DockingSplitter * const &>(class DockingSplitter * const &)
.text$mn:00003ECC                 public ??$forward@ABQAVDockingSplitter@@@std@@YAABQAVDockingSplitter@@ABQAV1@@Z
.text$mn:00003ECC ??$forward@ABQAVDockingSplitter@@@std@@YAABQAVDockingSplitter@@ABQAV1@@Z proc near
.text$mn:00003ECC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * const &>(DockingSplitter * *,DockingSplitter * const &)+Bp
.text$mn:00003ECC                                         ; std::allocator_traits<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * const &>(std::allocator<DockingSplitter *> &,DockingSplitter * *,DockingSplitter * const &)+7p
.text$mn:00003ECC
.text$mn:00003ECC arg_0           = dword ptr  8
.text$mn:00003ECC
.text$mn:00003ECC                 push    ebp
.text$mn:00003ECD                 mov     ebp, esp
.text$mn:00003ECF                 mov     eax, [ebp+arg_0]
.text$mn:00003ED2                 pop     ebp
.text$mn:00003ED3                 retn
.text$mn:00003ED3 ??$forward@ABQAVDockingSplitter@@@std@@YAABQAVDockingSplitter@@ABQAV1@@Z endp
.text$mn:00003ED3
.text$mn:00003ED3 _text$mn        ends
.text$mn:00003ED3
.text$mn:00003ED4 ; ===========================================================================
.text$mn:00003ED4
.text$mn:00003ED4 ; Segment type: Pure code
.text$mn:00003ED4 ; Segment permissions: Read/Execute
.text$mn:00003ED4 _text$mn        segment para public 'CODE' use32
.text$mn:00003ED4                 assume cs:_text$mn
.text$mn:00003ED4                 ;org 3ED4h
.text$mn:00003ED4 ; COMDAT (pick any)
.text$mn:00003ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003ED4
.text$mn:00003ED4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003ED4
.text$mn:00003ED4 ; Attributes: bp-based frame
.text$mn:00003ED4
.text$mn:00003ED4 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00003ED4                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00003ED4 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00003ED4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00003ED4                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00003ED4
.text$mn:00003ED4 arg_0           = dword ptr  8
.text$mn:00003ED4
.text$mn:00003ED4                 push    ebp
.text$mn:00003ED5                 mov     ebp, esp
.text$mn:00003ED7                 mov     eax, [ebp+arg_0]
.text$mn:00003EDA                 pop     ebp
.text$mn:00003EDB                 retn
.text$mn:00003EDB ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00003EDB
.text$mn:00003EDB _text$mn        ends
.text$mn:00003EDB
.text$mn:00003EDC ; ===========================================================================
.text$mn:00003EDC
.text$mn:00003EDC ; Segment type: Pure code
.text$mn:00003EDC ; Segment permissions: Read/Execute
.text$mn:00003EDC _text$mn        segment para public 'CODE' use32
.text$mn:00003EDC                 assume cs:_text$mn
.text$mn:00003EDC                 ;org 3EDCh
.text$mn:00003EDC ; COMDAT (pick any)
.text$mn:00003EDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EDC
.text$mn:00003EDC ; =============== S U B R O U T I N E =======================================
.text$mn:00003EDC
.text$mn:00003EDC ; Attributes: bp-based frame
.text$mn:00003EDC
.text$mn:00003EDC ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00003EDC                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00003EDC ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00003EDC                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>> const &)+2Dp
.text$mn:00003EDC
.text$mn:00003EDC var_10          = dword ptr -10h
.text$mn:00003EDC var_C           = dword ptr -0Ch
.text$mn:00003EDC var_4           = dword ptr -4
.text$mn:00003EDC arg_0           = dword ptr  8
.text$mn:00003EDC
.text$mn:00003EDC                 push    ebp
.text$mn:00003EDD                 mov     ebp, esp
.text$mn:00003EDF                 push    0FFFFFFFFh
.text$mn:00003EE1                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00003EE6                 mov     eax, large fs:0
.text$mn:00003EEC                 push    eax
.text$mn:00003EED                 push    ecx
.text$mn:00003EEE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003EF3                 xor     eax, ebp
.text$mn:00003EF5                 push    eax
.text$mn:00003EF6                 lea     eax, [ebp+var_C]
.text$mn:00003EF9                 mov     large fs:0, eax
.text$mn:00003EFF                 mov     [ebp+var_10], ecx
.text$mn:00003F02                 mov     eax, [ebp+arg_0]
.text$mn:00003F05                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00003F06                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003F09                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00003F0E                 mov     [ebp+var_4], 0
.text$mn:00003F15                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F1C                 mov     eax, [ebp+var_10]
.text$mn:00003F1F                 mov     ecx, [ebp+var_C]
.text$mn:00003F22                 mov     large fs:0, ecx
.text$mn:00003F29                 pop     ecx
.text$mn:00003F2A                 mov     esp, ebp
.text$mn:00003F2C                 pop     ebp
.text$mn:00003F2D                 retn    4
.text$mn:00003F2D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00003F2D
.text$mn:00003F2D _text$mn        ends
.text$mn:00003F2D
.text$x:00003F30 ; ===========================================================================
.text$x:00003F30
.text$x:00003F30 ; Segment type: Pure code
.text$x:00003F30 ; Segment permissions: Read/Execute
.text$x:00003F30 _text$x         segment para public 'CODE' use32
.text$x:00003F30                 assume cs:_text$x
.text$x:00003F30                 ;org 3F30h
.text$x:00003F30 ; COMDAT (pick associative to section at 3EDC)
.text$x:00003F30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F30
.text$x:00003F30 ; =============== S U B R O U T I N E =======================================
.text$x:00003F30
.text$x:00003F30
.text$x:00003F30 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00003F30                                         ; DATA XREF: .xdata$x:00009970o
.text$x:00003F30                 mov     ecx, [ebp-10h]  ; this
.text$x:00003F33                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003F33 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00003F33
.text$x:00003F38
.text$x:00003F38 ; =============== S U B R O U T I N E =======================================
.text$x:00003F38
.text$x:00003F38
.text$x:00003F38 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00003F38                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12> const &)+5o
.text$x:00003F38
.text$x:00003F38 arg_4           = dword ptr  8
.text$x:00003F38
.text$x:00003F38                 mov     edx, [esp+arg_4]
.text$x:00003F3C                 lea     eax, [edx+0Ch]
.text$x:00003F3F                 mov     ecx, [edx-8]
.text$x:00003F42                 xor     ecx, eax
.text$x:00003F44                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F49                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00003F4E                 jmp     ___CxxFrameHandler3
.text$x:00003F4E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00003F4E
.text$x:00003F4E ; ---------------------------------------------------------------------------
.text$x:00003F53                 align 4
.text$x:00003F53 _text$x         ends
.text$x:00003F53
.text$mn:00003F54 ; ===========================================================================
.text$mn:00003F54
.text$mn:00003F54 ; Segment type: Pure code
.text$mn:00003F54 ; Segment permissions: Read/Execute
.text$mn:00003F54 _text$mn        segment para public 'CODE' use32
.text$mn:00003F54                 assume cs:_text$mn
.text$mn:00003F54                 ;org 3F54h
.text$mn:00003F54 ; COMDAT (pick any)
.text$mn:00003F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F54
.text$mn:00003F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F54
.text$mn:00003F54 ; Attributes: bp-based frame
.text$mn:00003F54
.text$mn:00003F54 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct tTbData *, int, struct tTbData * const *, struct tTbData * const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, struct tTbData *, int, struct tTbData * const *, struct tTbData * const &, struct std::_Iterator_base12>(void)
.text$mn:00003F54                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003F54 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003F54                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(tTbData * *,std::_Container_base12 const *)+29p
.text$mn:00003F54
.text$mn:00003F54 var_10          = dword ptr -10h
.text$mn:00003F54 var_C           = dword ptr -0Ch
.text$mn:00003F54 var_4           = dword ptr -4
.text$mn:00003F54
.text$mn:00003F54                 push    ebp
.text$mn:00003F55                 mov     ebp, esp
.text$mn:00003F57                 push    0FFFFFFFFh
.text$mn:00003F59                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003F5E                 mov     eax, large fs:0
.text$mn:00003F64                 push    eax
.text$mn:00003F65                 push    ecx
.text$mn:00003F66                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003F6B                 xor     eax, ebp
.text$mn:00003F6D                 push    eax
.text$mn:00003F6E                 lea     eax, [ebp+var_C]
.text$mn:00003F71                 mov     large fs:0, eax
.text$mn:00003F77                 mov     [ebp+var_10], ecx
.text$mn:00003F7A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003F7D                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00003F82                 mov     [ebp+var_4], 0
.text$mn:00003F89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F90                 mov     eax, [ebp+var_10]
.text$mn:00003F93                 mov     ecx, [ebp+var_C]
.text$mn:00003F96                 mov     large fs:0, ecx
.text$mn:00003F9D                 pop     ecx
.text$mn:00003F9E                 mov     esp, ebp
.text$mn:00003FA0                 pop     ebp
.text$mn:00003FA1                 retn
.text$mn:00003FA1 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00003FA1
.text$mn:00003FA1 ; ---------------------------------------------------------------------------
.text$mn:00003FA2                 align 4
.text$mn:00003FA2 _text$mn        ends
.text$mn:00003FA2
.text$x:00003FA4 ; ===========================================================================
.text$x:00003FA4
.text$x:00003FA4 ; Segment type: Pure code
.text$x:00003FA4 ; Segment permissions: Read/Execute
.text$x:00003FA4 _text$x         segment para public 'CODE' use32
.text$x:00003FA4                 assume cs:_text$x
.text$x:00003FA4                 ;org 3FA4h
.text$x:00003FA4 ; COMDAT (pick associative to section at 3F54)
.text$x:00003FA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003FA4
.text$x:00003FA4 ; =============== S U B R O U T I N E =======================================
.text$x:00003FA4
.text$x:00003FA4
.text$x:00003FA4 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00003FA4                                         ; DATA XREF: .xdata$x:00009918o
.text$x:00003FA4                 mov     ecx, [ebp-10h]  ; this
.text$x:00003FA7                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003FA7 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00003FA7
.text$x:00003FAC
.text$x:00003FAC ; =============== S U B R O U T I N E =======================================
.text$x:00003FAC
.text$x:00003FAC
.text$x:00003FAC __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00003FAC                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(void)+5o
.text$x:00003FAC
.text$x:00003FAC arg_4           = dword ptr  8
.text$x:00003FAC
.text$x:00003FAC                 mov     edx, [esp+arg_4]
.text$x:00003FB0                 lea     eax, [edx+0Ch]
.text$x:00003FB3                 mov     ecx, [edx-8]
.text$x:00003FB6                 xor     ecx, eax
.text$x:00003FB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003FBD                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00003FC2                 jmp     ___CxxFrameHandler3
.text$x:00003FC2 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00003FC2
.text$x:00003FC2 ; ---------------------------------------------------------------------------
.text$x:00003FC7                 align 4
.text$x:00003FC7 _text$x         ends
.text$x:00003FC7
.text$mn:00003FC8 ; ===========================================================================
.text$mn:00003FC8
.text$mn:00003FC8 ; Segment type: Pure code
.text$mn:00003FC8 ; Segment permissions: Read/Execute
.text$mn:00003FC8 _text$mn        segment para public 'CODE' use32
.text$mn:00003FC8                 assume cs:_text$mn
.text$mn:00003FC8                 ;org 3FC8h
.text$mn:00003FC8 ; COMDAT (pick any)
.text$mn:00003FC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FC8
.text$mn:00003FC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FC8
.text$mn:00003FC8 ; Attributes: bp-based frame
.text$mn:00003FC8
.text$mn:00003FC8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00003FC8                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00003FC8 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00003FC8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00003FC8
.text$mn:00003FC8 var_10          = dword ptr -10h
.text$mn:00003FC8 var_C           = dword ptr -0Ch
.text$mn:00003FC8 var_4           = dword ptr -4
.text$mn:00003FC8
.text$mn:00003FC8                 push    ebp
.text$mn:00003FC9                 mov     ebp, esp
.text$mn:00003FCB                 push    0FFFFFFFFh
.text$mn:00003FCD                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00003FD2                 mov     eax, large fs:0
.text$mn:00003FD8                 push    eax
.text$mn:00003FD9                 push    ecx
.text$mn:00003FDA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FDF                 xor     eax, ebp
.text$mn:00003FE1                 push    eax
.text$mn:00003FE2                 lea     eax, [ebp+var_C]
.text$mn:00003FE5                 mov     large fs:0, eax
.text$mn:00003FEB                 mov     [ebp+var_10], ecx
.text$mn:00003FEE                 mov     ecx, [ebp+var_10]
.text$mn:00003FF1                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00003FF6                 mov     [ebp+var_4], 0
.text$mn:00003FFD                 mov     ecx, [ebp+var_10]
.text$mn:00004000                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00004005                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000400C                 mov     eax, [ebp+var_10]
.text$mn:0000400F                 mov     ecx, [ebp+var_C]
.text$mn:00004012                 mov     large fs:0, ecx
.text$mn:00004019                 pop     ecx
.text$mn:0000401A                 mov     esp, ebp
.text$mn:0000401C                 pop     ebp
.text$mn:0000401D                 retn    4
.text$mn:0000401D ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:0000401D
.text$mn:0000401D _text$mn        ends
.text$mn:0000401D
.text$x:00004020 ; ===========================================================================
.text$x:00004020
.text$x:00004020 ; Segment type: Pure code
.text$x:00004020 ; Segment permissions: Read/Execute
.text$x:00004020 _text$x         segment para public 'CODE' use32
.text$x:00004020                 assume cs:_text$x
.text$x:00004020                 ;org 4020h
.text$x:00004020 ; COMDAT (pick associative to section at 3FC8)
.text$x:00004020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004020
.text$x:00004020 ; =============== S U B R O U T I N E =======================================
.text$x:00004020
.text$x:00004020
.text$x:00004020 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00004020                                         ; DATA XREF: .xdata$x:00008D48o
.text$x:00004020                 mov     ecx, [ebp-10h]
.text$x:00004023                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00004023 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00004023
.text$x:00004028
.text$x:00004028 ; =============== S U B R O U T I N E =======================================
.text$x:00004028
.text$x:00004028
.text$x:00004028 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00004028                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00004028
.text$x:00004028 arg_4           = dword ptr  8
.text$x:00004028
.text$x:00004028                 mov     edx, [esp+arg_4]
.text$x:0000402C                 lea     eax, [edx+0Ch]
.text$x:0000402F                 mov     ecx, [edx-8]
.text$x:00004032                 xor     ecx, eax
.text$x:00004034                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004039                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000403E                 jmp     ___CxxFrameHandler3
.text$x:0000403E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000403E
.text$x:0000403E ; ---------------------------------------------------------------------------
.text$x:00004043                 align 4
.text$x:00004043 _text$x         ends
.text$x:00004043
.text$mn:00004044 ; ===========================================================================
.text$mn:00004044
.text$mn:00004044 ; Segment type: Pure code
.text$mn:00004044 ; Segment permissions: Read/Execute
.text$mn:00004044 _text$mn        segment para public 'CODE' use32
.text$mn:00004044                 assume cs:_text$mn
.text$mn:00004044                 ;org 4044h
.text$mn:00004044 ; COMDAT (pick any)
.text$mn:00004044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004044
.text$mn:00004044 ; =============== S U B R O U T I N E =======================================
.text$mn:00004044
.text$mn:00004044 ; Attributes: bp-based frame
.text$mn:00004044
.text$mn:00004044 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00004044                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00004044 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00004044                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00004044
.text$mn:00004044 var_10          = dword ptr -10h
.text$mn:00004044 var_C           = dword ptr -0Ch
.text$mn:00004044 var_4           = dword ptr -4
.text$mn:00004044
.text$mn:00004044                 push    ebp
.text$mn:00004045                 mov     ebp, esp
.text$mn:00004047                 push    0FFFFFFFFh
.text$mn:00004049                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000404E                 mov     eax, large fs:0
.text$mn:00004054                 push    eax
.text$mn:00004055                 push    ecx
.text$mn:00004056                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000405B                 xor     eax, ebp
.text$mn:0000405D                 push    eax
.text$mn:0000405E                 lea     eax, [ebp+var_C]
.text$mn:00004061                 mov     large fs:0, eax
.text$mn:00004067                 mov     [ebp+var_10], ecx
.text$mn:0000406A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000406D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00004072                 mov     [ebp+var_4], 0
.text$mn:00004079                 mov     eax, [ebp+var_10]
.text$mn:0000407C                 mov     dword ptr [eax+14h], 0
.text$mn:00004083                 mov     ecx, [ebp+var_10]
.text$mn:00004086                 mov     dword ptr [ecx+18h], 0
.text$mn:0000408D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004094                 mov     eax, [ebp+var_10]
.text$mn:00004097                 mov     ecx, [ebp+var_C]
.text$mn:0000409A                 mov     large fs:0, ecx
.text$mn:000040A1                 pop     ecx
.text$mn:000040A2                 mov     esp, ebp
.text$mn:000040A4                 pop     ebp
.text$mn:000040A5                 retn
.text$mn:000040A5 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000040A5
.text$mn:000040A5 ; ---------------------------------------------------------------------------
.text$mn:000040A6                 align 4
.text$mn:000040A6 _text$mn        ends
.text$mn:000040A6
.text$x:000040A8 ; ===========================================================================
.text$x:000040A8
.text$x:000040A8 ; Segment type: Pure code
.text$x:000040A8 ; Segment permissions: Read/Execute
.text$x:000040A8 _text$x         segment para public 'CODE' use32
.text$x:000040A8                 assume cs:_text$x
.text$x:000040A8                 ;org 40A8h
.text$x:000040A8 ; COMDAT (pick associative to section at 4044)
.text$x:000040A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000040A8
.text$x:000040A8 ; =============== S U B R O U T I N E =======================================
.text$x:000040A8
.text$x:000040A8
.text$x:000040A8 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000040A8                                         ; DATA XREF: .xdata$x:00008CF0o
.text$x:000040A8                 mov     ecx, [ebp-10h]  ; this
.text$x:000040AB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000040AB __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000040AB
.text$x:000040B0
.text$x:000040B0 ; =============== S U B R O U T I N E =======================================
.text$x:000040B0
.text$x:000040B0
.text$x:000040B0 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000040B0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000040B0
.text$x:000040B0 arg_4           = dword ptr  8
.text$x:000040B0
.text$x:000040B0                 mov     edx, [esp+arg_4]
.text$x:000040B4                 lea     eax, [edx+0Ch]
.text$x:000040B7                 mov     ecx, [edx-8]
.text$x:000040BA                 xor     ecx, eax
.text$x:000040BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000040C1                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000040C6                 jmp     ___CxxFrameHandler3
.text$x:000040C6 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000040C6
.text$x:000040C6 ; ---------------------------------------------------------------------------
.text$x:000040CB                 align 4
.text$x:000040CB _text$x         ends
.text$x:000040CB
.text$mn:000040CC ; ===========================================================================
.text$mn:000040CC
.text$mn:000040CC ; Segment type: Pure code
.text$mn:000040CC ; Segment permissions: Read/Execute
.text$mn:000040CC _text$mn        segment para public 'CODE' use32
.text$mn:000040CC                 assume cs:_text$mn
.text$mn:000040CC                 ;org 40CCh
.text$mn:000040CC ; COMDAT (pick any)
.text$mn:000040CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040CC
.text$mn:000040CC ; =============== S U B R O U T I N E =======================================
.text$mn:000040CC
.text$mn:000040CC ; Attributes: bp-based frame
.text$mn:000040CC
.text$mn:000040CC ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct HWND__ *, class std::allocator<struct HWND__ *>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct HWND__ *, class std::allocator<struct HWND__ *>>>(class std::allocator<struct HWND__ *> const &)
.text$mn:000040CC                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z
.text$mn:000040CC ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z proc near
.text$mn:000040CC                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::vector<HWND__ *,std::allocator<HWND__ *>>(void)+34p
.text$mn:000040CC
.text$mn:000040CC var_10          = dword ptr -10h
.text$mn:000040CC var_C           = dword ptr -0Ch
.text$mn:000040CC var_4           = dword ptr -4
.text$mn:000040CC
.text$mn:000040CC                 push    ebp
.text$mn:000040CD                 mov     ebp, esp
.text$mn:000040CF                 push    0FFFFFFFFh
.text$mn:000040D1                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z
.text$mn:000040D6                 mov     eax, large fs:0
.text$mn:000040DC                 push    eax
.text$mn:000040DD                 push    ecx
.text$mn:000040DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000040E3                 xor     eax, ebp
.text$mn:000040E5                 push    eax
.text$mn:000040E6                 lea     eax, [ebp+var_C]
.text$mn:000040E9                 mov     large fs:0, eax
.text$mn:000040EF                 mov     [ebp+var_10], ecx
.text$mn:000040F2                 mov     ecx, [ebp+var_10]
.text$mn:000040F5                 call    ??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<HWND__ *>>::_Vector_val<std::_Simple_types<HWND__ *>>(void)
.text$mn:000040FA                 mov     [ebp+var_4], 0
.text$mn:00004101                 mov     ecx, [ebp+var_10]
.text$mn:00004104                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Alloc_proxy(void)
.text$mn:00004109                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004110                 mov     eax, [ebp+var_10]
.text$mn:00004113                 mov     ecx, [ebp+var_C]
.text$mn:00004116                 mov     large fs:0, ecx
.text$mn:0000411D                 pop     ecx
.text$mn:0000411E                 mov     esp, ebp
.text$mn:00004120                 pop     ebp
.text$mn:00004121                 retn    4
.text$mn:00004121 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z endp
.text$mn:00004121
.text$mn:00004121 _text$mn        ends
.text$mn:00004121
.text$x:00004124 ; ===========================================================================
.text$x:00004124
.text$x:00004124 ; Segment type: Pure code
.text$x:00004124 ; Segment permissions: Read/Execute
.text$x:00004124 _text$x         segment para public 'CODE' use32
.text$x:00004124                 assume cs:_text$x
.text$x:00004124                 ;org 4124h
.text$x:00004124 ; COMDAT (pick associative to section at 40CC)
.text$x:00004124                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004124
.text$x:00004124 ; =============== S U B R O U T I N E =======================================
.text$x:00004124
.text$x:00004124
.text$x:00004124 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z$0 proc near
.text$x:00004124                                         ; DATA XREF: .xdata$x:00009474o
.text$x:00004124                 mov     ecx, [ebp-10h]
.text$x:00004127                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<HWND__ *>>::~_Vector_val<std::_Simple_types<HWND__ *>>(void)
.text$x:00004127 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z$0 endp
.text$x:00004127
.text$x:0000412C
.text$x:0000412C ; =============== S U B R O U T I N E =======================================
.text$x:0000412C
.text$x:0000412C
.text$x:0000412C __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z proc near
.text$x:0000412C                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>(std::allocator<HWND__ *> const &)+5o
.text$x:0000412C
.text$x:0000412C arg_4           = dword ptr  8
.text$x:0000412C
.text$x:0000412C                 mov     edx, [esp+arg_4]
.text$x:00004130                 lea     eax, [edx+0Ch]
.text$x:00004133                 mov     ecx, [edx-8]
.text$x:00004136                 xor     ecx, eax
.text$x:00004138                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000413D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z
.text$x:00004142                 jmp     ___CxxFrameHandler3
.text$x:00004142 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z endp
.text$x:00004142
.text$x:00004142 ; ---------------------------------------------------------------------------
.text$x:00004147                 align 4
.text$x:00004147 _text$x         ends
.text$x:00004147
.text$mn:00004148 ; ===========================================================================
.text$mn:00004148
.text$mn:00004148 ; Segment type: Pure code
.text$mn:00004148 ; Segment permissions: Read/Execute
.text$mn:00004148 _text$mn        segment para public 'CODE' use32
.text$mn:00004148                 assume cs:_text$mn
.text$mn:00004148                 ;org 4148h
.text$mn:00004148 ; COMDAT (pick any)
.text$mn:00004148                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004148
.text$mn:00004148 ; =============== S U B R O U T I N E =======================================
.text$mn:00004148
.text$mn:00004148 ; Attributes: bp-based frame
.text$mn:00004148
.text$mn:00004148 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct tTbData *, class std::allocator<struct tTbData *>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct tTbData *, class std::allocator<struct tTbData *>>>(class std::allocator<struct tTbData *> const &)
.text$mn:00004148                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z
.text$mn:00004148 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z proc near
.text$mn:00004148                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+4Ap
.text$mn:00004148
.text$mn:00004148 var_10          = dword ptr -10h
.text$mn:00004148 var_C           = dword ptr -0Ch
.text$mn:00004148 var_4           = dword ptr -4
.text$mn:00004148
.text$mn:00004148                 push    ebp
.text$mn:00004149                 mov     ebp, esp
.text$mn:0000414B                 push    0FFFFFFFFh
.text$mn:0000414D                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z
.text$mn:00004152                 mov     eax, large fs:0
.text$mn:00004158                 push    eax
.text$mn:00004159                 push    ecx
.text$mn:0000415A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000415F                 xor     eax, ebp
.text$mn:00004161                 push    eax
.text$mn:00004162                 lea     eax, [ebp+var_C]
.text$mn:00004165                 mov     large fs:0, eax
.text$mn:0000416B                 mov     [ebp+var_10], ecx
.text$mn:0000416E                 mov     ecx, [ebp+var_10]
.text$mn:00004171                 call    ??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<tTbData *>>::_Vector_val<std::_Simple_types<tTbData *>>(void)
.text$mn:00004176                 mov     [ebp+var_4], 0
.text$mn:0000417D                 mov     ecx, [ebp+var_10]
.text$mn:00004180                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Alloc_proxy(void)
.text$mn:00004185                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000418C                 mov     eax, [ebp+var_10]
.text$mn:0000418F                 mov     ecx, [ebp+var_C]
.text$mn:00004192                 mov     large fs:0, ecx
.text$mn:00004199                 pop     ecx
.text$mn:0000419A                 mov     esp, ebp
.text$mn:0000419C                 pop     ebp
.text$mn:0000419D                 retn    4
.text$mn:0000419D ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z endp
.text$mn:0000419D
.text$mn:0000419D _text$mn        ends
.text$mn:0000419D
.text$x:000041A0 ; ===========================================================================
.text$x:000041A0
.text$x:000041A0 ; Segment type: Pure code
.text$x:000041A0 ; Segment permissions: Read/Execute
.text$x:000041A0 _text$x         segment para public 'CODE' use32
.text$x:000041A0                 assume cs:_text$x
.text$x:000041A0                 ;org 41A0h
.text$x:000041A0 ; COMDAT (pick associative to section at 4148)
.text$x:000041A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000041A0
.text$x:000041A0 ; =============== S U B R O U T I N E =======================================
.text$x:000041A0
.text$x:000041A0
.text$x:000041A0 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z$0 proc near
.text$x:000041A0                                         ; DATA XREF: .xdata$x:00009118o
.text$x:000041A0                 mov     ecx, [ebp-10h]
.text$x:000041A3                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<tTbData *>>::~_Vector_val<std::_Simple_types<tTbData *>>(void)
.text$x:000041A3 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z$0 endp
.text$x:000041A3
.text$x:000041A8
.text$x:000041A8 ; =============== S U B R O U T I N E =======================================
.text$x:000041A8
.text$x:000041A8
.text$x:000041A8 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z proc near
.text$x:000041A8                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>(std::allocator<tTbData *> const &)+5o
.text$x:000041A8
.text$x:000041A8 arg_4           = dword ptr  8
.text$x:000041A8
.text$x:000041A8                 mov     edx, [esp+arg_4]
.text$x:000041AC                 lea     eax, [edx+0Ch]
.text$x:000041AF                 mov     ecx, [edx-8]
.text$x:000041B2                 xor     ecx, eax
.text$x:000041B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000041B9                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z
.text$x:000041BE                 jmp     ___CxxFrameHandler3
.text$x:000041BE __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z endp
.text$x:000041BE
.text$x:000041BE ; ---------------------------------------------------------------------------
.text$x:000041C3                 align 4
.text$x:000041C3 _text$x         ends
.text$x:000041C3
.text$mn:000041C4 ; ===========================================================================
.text$mn:000041C4
.text$mn:000041C4 ; Segment type: Pure code
.text$mn:000041C4 ; Segment permissions: Read/Execute
.text$mn:000041C4 _text$mn        segment para public 'CODE' use32
.text$mn:000041C4                 assume cs:_text$mn
.text$mn:000041C4                 ;org 41C4h
.text$mn:000041C4 ; COMDAT (pick any)
.text$mn:000041C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000041C4
.text$mn:000041C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000041C4
.text$mn:000041C4 ; Attributes: bp-based frame
.text$mn:000041C4
.text$mn:000041C4 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>(class std::allocator<class DockingCont *> const &)
.text$mn:000041C4                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z
.text$mn:000041C4 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z proc near
.text$mn:000041C4                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(void)+34p
.text$mn:000041C4
.text$mn:000041C4 var_10          = dword ptr -10h
.text$mn:000041C4 var_C           = dword ptr -0Ch
.text$mn:000041C4 var_4           = dword ptr -4
.text$mn:000041C4
.text$mn:000041C4                 push    ebp
.text$mn:000041C5                 mov     ebp, esp
.text$mn:000041C7                 push    0FFFFFFFFh
.text$mn:000041C9                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z
.text$mn:000041CE                 mov     eax, large fs:0
.text$mn:000041D4                 push    eax
.text$mn:000041D5                 push    ecx
.text$mn:000041D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000041DB                 xor     eax, ebp
.text$mn:000041DD                 push    eax
.text$mn:000041DE                 lea     eax, [ebp+var_C]
.text$mn:000041E1                 mov     large fs:0, eax
.text$mn:000041E7                 mov     [ebp+var_10], ecx
.text$mn:000041EA                 mov     ecx, [ebp+var_10]
.text$mn:000041ED                 call    ??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingCont *>>::_Vector_val<std::_Simple_types<DockingCont *>>(void)
.text$mn:000041F2                 mov     [ebp+var_4], 0
.text$mn:000041F9                 mov     ecx, [ebp+var_10]
.text$mn:000041FC                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Alloc_proxy(void)
.text$mn:00004201                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004208                 mov     eax, [ebp+var_10]
.text$mn:0000420B                 mov     ecx, [ebp+var_C]
.text$mn:0000420E                 mov     large fs:0, ecx
.text$mn:00004215                 pop     ecx
.text$mn:00004216                 mov     esp, ebp
.text$mn:00004218                 pop     ebp
.text$mn:00004219                 retn    4
.text$mn:00004219 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z endp
.text$mn:00004219
.text$mn:00004219 _text$mn        ends
.text$mn:00004219
.text$x:0000421C ; ===========================================================================
.text$x:0000421C
.text$x:0000421C ; Segment type: Pure code
.text$x:0000421C ; Segment permissions: Read/Execute
.text$x:0000421C _text$x         segment para public 'CODE' use32
.text$x:0000421C                 assume cs:_text$x
.text$x:0000421C                 ;org 421Ch
.text$x:0000421C ; COMDAT (pick associative to section at 41C4)
.text$x:0000421C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000421C
.text$x:0000421C ; =============== S U B R O U T I N E =======================================
.text$x:0000421C
.text$x:0000421C
.text$x:0000421C __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z$0 proc near
.text$x:0000421C                                         ; DATA XREF: .xdata$x:00009600o
.text$x:0000421C                 mov     ecx, [ebp-10h]
.text$x:0000421F                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingCont *>>::~_Vector_val<std::_Simple_types<DockingCont *>>(void)
.text$x:0000421F __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z$0 endp
.text$x:0000421F
.text$x:00004224
.text$x:00004224 ; =============== S U B R O U T I N E =======================================
.text$x:00004224
.text$x:00004224
.text$x:00004224 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z proc near
.text$x:00004224                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(std::allocator<DockingCont *> const &)+5o
.text$x:00004224
.text$x:00004224 arg_4           = dword ptr  8
.text$x:00004224
.text$x:00004224                 mov     edx, [esp+arg_4]
.text$x:00004228                 lea     eax, [edx+0Ch]
.text$x:0000422B                 mov     ecx, [edx-8]
.text$x:0000422E                 xor     ecx, eax
.text$x:00004230                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004235                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z
.text$x:0000423A                 jmp     ___CxxFrameHandler3
.text$x:0000423A __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z endp
.text$x:0000423A
.text$x:0000423A ; ---------------------------------------------------------------------------
.text$x:0000423F                 align 10h
.text$x:0000423F _text$x         ends
.text$x:0000423F
.text$mn:00004240 ; ===========================================================================
.text$mn:00004240
.text$mn:00004240 ; Segment type: Pure code
.text$mn:00004240 ; Segment permissions: Read/Execute
.text$mn:00004240 _text$mn        segment para public 'CODE' use32
.text$mn:00004240                 assume cs:_text$mn
.text$mn:00004240                 ;org 4240h
.text$mn:00004240 ; COMDAT (pick any)
.text$mn:00004240                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004240
.text$mn:00004240 ; =============== S U B R O U T I N E =======================================
.text$mn:00004240
.text$mn:00004240 ; Attributes: bp-based frame
.text$mn:00004240
.text$mn:00004240 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingSplitter *, class std::allocator<class DockingSplitter *>>>::_Vector_alloc<0, struct std::_Vec_base_types<class DockingSplitter *, class std::allocator<class DockingSplitter *>>>(class std::allocator<class DockingSplitter *> const &)
.text$mn:00004240                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z
.text$mn:00004240 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z proc near
.text$mn:00004240                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::vector<DockingSplitter *,std::allocator<DockingSplitter *>>(void)+34p
.text$mn:00004240
.text$mn:00004240 var_10          = dword ptr -10h
.text$mn:00004240 var_C           = dword ptr -0Ch
.text$mn:00004240 var_4           = dword ptr -4
.text$mn:00004240
.text$mn:00004240                 push    ebp
.text$mn:00004241                 mov     ebp, esp
.text$mn:00004243                 push    0FFFFFFFFh
.text$mn:00004245                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z
.text$mn:0000424A                 mov     eax, large fs:0
.text$mn:00004250                 push    eax
.text$mn:00004251                 push    ecx
.text$mn:00004252                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004257                 xor     eax, ebp
.text$mn:00004259                 push    eax
.text$mn:0000425A                 lea     eax, [ebp+var_C]
.text$mn:0000425D                 mov     large fs:0, eax
.text$mn:00004263                 mov     [ebp+var_10], ecx
.text$mn:00004266                 mov     ecx, [ebp+var_10]
.text$mn:00004269                 call    ??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingSplitter *>>::_Vector_val<std::_Simple_types<DockingSplitter *>>(void)
.text$mn:0000426E                 mov     [ebp+var_4], 0
.text$mn:00004275                 mov     ecx, [ebp+var_10]
.text$mn:00004278                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Alloc_proxy(void)
.text$mn:0000427D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004284                 mov     eax, [ebp+var_10]
.text$mn:00004287                 mov     ecx, [ebp+var_C]
.text$mn:0000428A                 mov     large fs:0, ecx
.text$mn:00004291                 pop     ecx
.text$mn:00004292                 mov     esp, ebp
.text$mn:00004294                 pop     ebp
.text$mn:00004295                 retn    4
.text$mn:00004295 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z endp
.text$mn:00004295
.text$mn:00004295 _text$mn        ends
.text$mn:00004295
.text$x:00004298 ; ===========================================================================
.text$x:00004298
.text$x:00004298 ; Segment type: Pure code
.text$x:00004298 ; Segment permissions: Read/Execute
.text$x:00004298 _text$x         segment para public 'CODE' use32
.text$x:00004298                 assume cs:_text$x
.text$x:00004298                 ;org 4298h
.text$x:00004298 ; COMDAT (pick associative to section at 4240)
.text$x:00004298                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004298
.text$x:00004298 ; =============== S U B R O U T I N E =======================================
.text$x:00004298
.text$x:00004298
.text$x:00004298 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z$0 proc near
.text$x:00004298                                         ; DATA XREF: .xdata$x:0000978Co
.text$x:00004298                 mov     ecx, [ebp-10h]
.text$x:0000429B                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingSplitter *>>::~_Vector_val<std::_Simple_types<DockingSplitter *>>(void)
.text$x:0000429B __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z$0 endp
.text$x:0000429B
.text$x:000042A0
.text$x:000042A0 ; =============== S U B R O U T I N E =======================================
.text$x:000042A0
.text$x:000042A0
.text$x:000042A0 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z proc near
.text$x:000042A0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>(std::allocator<DockingSplitter *> const &)+5o
.text$x:000042A0
.text$x:000042A0 arg_4           = dword ptr  8
.text$x:000042A0
.text$x:000042A0                 mov     edx, [esp+arg_4]
.text$x:000042A4                 lea     eax, [edx+0Ch]
.text$x:000042A7                 mov     ecx, [edx-8]
.text$x:000042AA                 xor     ecx, eax
.text$x:000042AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000042B1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z
.text$x:000042B6                 jmp     ___CxxFrameHandler3
.text$x:000042B6 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z endp
.text$x:000042B6
.text$x:000042B6 ; ---------------------------------------------------------------------------
.text$x:000042BB                 align 4
.text$x:000042BB _text$x         ends
.text$x:000042BB
.text$mn:000042BC ; ===========================================================================
.text$mn:000042BC
.text$mn:000042BC ; Segment type: Pure code
.text$mn:000042BC ; Segment permissions: Read/Execute
.text$mn:000042BC _text$mn        segment para public 'CODE' use32
.text$mn:000042BC                 assume cs:_text$mn
.text$mn:000042BC                 ;org 42BCh
.text$mn:000042BC ; COMDAT (pick any)
.text$mn:000042BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000042BC
.text$mn:000042BC ; =============== S U B R O U T I N E =======================================
.text$mn:000042BC
.text$mn:000042BC ; Attributes: bp-based frame
.text$mn:000042BC
.text$mn:000042BC ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(struct std::_Iterator_base12 *)
.text$mn:000042BC                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000042BC ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:000042BC                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *)+4Fp
.text$mn:000042BC                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *)+6Dp ...
.text$mn:000042BC
.text$mn:000042BC var_10          = dword ptr -10h
.text$mn:000042BC var_C           = dword ptr -0Ch
.text$mn:000042BC var_4           = dword ptr -4
.text$mn:000042BC arg_0           = dword ptr  8
.text$mn:000042BC
.text$mn:000042BC                 push    ebp
.text$mn:000042BD                 mov     ebp, esp
.text$mn:000042BF                 push    0FFFFFFFFh
.text$mn:000042C1                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:000042C6                 mov     eax, large fs:0
.text$mn:000042CC                 push    eax
.text$mn:000042CD                 push    ecx
.text$mn:000042CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000042D3                 xor     eax, ebp
.text$mn:000042D5                 push    eax
.text$mn:000042D6                 lea     eax, [ebp+var_C]
.text$mn:000042D9                 mov     large fs:0, eax
.text$mn:000042DF                 mov     [ebp+var_10], ecx
.text$mn:000042E2                 mov     eax, [ebp+arg_0]
.text$mn:000042E5                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000042E6                 mov     ecx, [ebp+var_10]
.text$mn:000042E9                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12> const &)
.text$mn:000042EE                 mov     [ebp+var_4], 0
.text$mn:000042F5                 mov     ecx, [ebp+var_10]
.text$mn:000042F8                 mov     edx, [ebp+arg_0]
.text$mn:000042FB                 mov     eax, [edx+8]
.text$mn:000042FE                 mov     [ecx+8], eax
.text$mn:00004301                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004308                 mov     eax, [ebp+var_10]
.text$mn:0000430B                 mov     ecx, [ebp+var_C]
.text$mn:0000430E                 mov     large fs:0, ecx
.text$mn:00004315                 pop     ecx
.text$mn:00004316                 mov     esp, ebp
.text$mn:00004318                 pop     ebp
.text$mn:00004319                 retn    4
.text$mn:00004319 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004319
.text$mn:00004319 _text$mn        ends
.text$mn:00004319
.text$x:0000431C ; ===========================================================================
.text$x:0000431C
.text$x:0000431C ; Segment type: Pure code
.text$x:0000431C ; Segment permissions: Read/Execute
.text$x:0000431C _text$x         segment para public 'CODE' use32
.text$x:0000431C                 assume cs:_text$x
.text$x:0000431C                 ;org 431Ch
.text$x:0000431C ; COMDAT (pick associative to section at 42BC)
.text$x:0000431C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000431C
.text$x:0000431C ; =============== S U B R O U T I N E =======================================
.text$x:0000431C
.text$x:0000431C
.text$x:0000431C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000431C                                         ; DATA XREF: .xdata$x:000099F4o
.text$x:0000431C                 mov     ecx, [ebp-10h]
.text$x:0000431F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(void)
.text$x:0000431F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000431F
.text$x:00004324
.text$x:00004324 ; =============== S U B R O U T I N E =======================================
.text$x:00004324
.text$x:00004324
.text$x:00004324 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00004324                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>> const &)+5o
.text$x:00004324
.text$x:00004324 arg_4           = dword ptr  8
.text$x:00004324
.text$x:00004324                 mov     edx, [esp+arg_4]
.text$x:00004328                 lea     eax, [edx+0Ch]
.text$x:0000432B                 mov     ecx, [edx-8]
.text$x:0000432E                 xor     ecx, eax
.text$x:00004330                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004335                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000433A                 jmp     ___CxxFrameHandler3
.text$x:0000433A __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000433A
.text$x:0000433A ; ---------------------------------------------------------------------------
.text$x:0000433F                 align 10h
.text$x:0000433F _text$x         ends
.text$x:0000433F
.text$mn:00004340 ; ===========================================================================
.text$mn:00004340
.text$mn:00004340 ; Segment type: Pure code
.text$mn:00004340 ; Segment permissions: Read/Execute
.text$mn:00004340 _text$mn        segment para public 'CODE' use32
.text$mn:00004340                 assume cs:_text$mn
.text$mn:00004340                 ;org 4340h
.text$mn:00004340 ; COMDAT (pick any)
.text$mn:00004340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004340
.text$mn:00004340 ; =============== S U B R O U T I N E =======================================
.text$mn:00004340
.text$mn:00004340 ; Attributes: bp-based frame
.text$mn:00004340
.text$mn:00004340 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(int, struct std::_Container_base12 *)
.text$mn:00004340                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z
.text$mn:00004340 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z proc near
.text$mn:00004340                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::begin(void)+3Dp
.text$mn:00004340                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::end(void)+3Dp
.text$mn:00004340
.text$mn:00004340 var_10          = dword ptr -10h
.text$mn:00004340 var_C           = dword ptr -0Ch
.text$mn:00004340 var_4           = dword ptr -4
.text$mn:00004340 arg_0           = dword ptr  8
.text$mn:00004340 arg_4           = dword ptr  0Ch
.text$mn:00004340
.text$mn:00004340                 push    ebp
.text$mn:00004341                 mov     ebp, esp
.text$mn:00004343                 push    0FFFFFFFFh
.text$mn:00004345                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z
.text$mn:0000434A                 mov     eax, large fs:0
.text$mn:00004350                 push    eax
.text$mn:00004351                 push    ecx
.text$mn:00004352                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004357                 xor     eax, ebp
.text$mn:00004359                 push    eax
.text$mn:0000435A                 lea     eax, [ebp+var_C]
.text$mn:0000435D                 mov     large fs:0, eax
.text$mn:00004363                 mov     [ebp+var_10], ecx
.text$mn:00004366                 mov     ecx, [ebp+var_10]
.text$mn:00004369                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(void)
.text$mn:0000436E                 mov     [ebp+var_4], 0
.text$mn:00004375                 mov     eax, [ebp+var_10]
.text$mn:00004378                 mov     ecx, [ebp+arg_0]
.text$mn:0000437B                 mov     [eax+8], ecx
.text$mn:0000437E                 mov     edx, [ebp+arg_4]
.text$mn:00004381                 push    edx             ; struct std::_Container_base12 *
.text$mn:00004382                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004385                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000438A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004391                 mov     eax, [ebp+var_10]
.text$mn:00004394                 mov     ecx, [ebp+var_C]
.text$mn:00004397                 mov     large fs:0, ecx
.text$mn:0000439E                 pop     ecx
.text$mn:0000439F                 mov     esp, ebp
.text$mn:000043A1                 pop     ebp
.text$mn:000043A2                 retn    8
.text$mn:000043A2 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z endp
.text$mn:000043A2
.text$mn:000043A2 ; ---------------------------------------------------------------------------
.text$mn:000043A5                 align 4
.text$mn:000043A5 _text$mn        ends
.text$mn:000043A5
.text$x:000043A8 ; ===========================================================================
.text$x:000043A8
.text$x:000043A8 ; Segment type: Pure code
.text$x:000043A8 ; Segment permissions: Read/Execute
.text$x:000043A8 _text$x         segment para public 'CODE' use32
.text$x:000043A8                 assume cs:_text$x
.text$x:000043A8                 ;org 43A8h
.text$x:000043A8 ; COMDAT (pick associative to section at 4340)
.text$x:000043A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000043A8
.text$x:000043A8 ; =============== S U B R O U T I N E =======================================
.text$x:000043A8
.text$x:000043A8
.text$x:000043A8 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z$0 proc near
.text$x:000043A8                                         ; DATA XREF: .xdata$x:0000999Co
.text$x:000043A8                 mov     ecx, [ebp-10h]
.text$x:000043AB                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(void)
.text$x:000043AB __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z$0 endp
.text$x:000043AB
.text$x:000043B0
.text$x:000043B0 ; =============== S U B R O U T I N E =======================================
.text$x:000043B0
.text$x:000043B0
.text$x:000043B0 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z proc near
.text$x:000043B0                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(tTbData * *,std::_Container_base12 const *)+5o
.text$x:000043B0
.text$x:000043B0 arg_4           = dword ptr  8
.text$x:000043B0
.text$x:000043B0                 mov     edx, [esp+arg_4]
.text$x:000043B4                 lea     eax, [edx+0Ch]
.text$x:000043B7                 mov     ecx, [edx-8]
.text$x:000043BA                 xor     ecx, eax
.text$x:000043BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000043C1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z
.text$x:000043C6                 jmp     ___CxxFrameHandler3
.text$x:000043C6 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z endp
.text$x:000043C6
.text$x:000043C6 ; ---------------------------------------------------------------------------
.text$x:000043CB                 align 4
.text$x:000043CB _text$x         ends
.text$x:000043CB
.text$mn:000043CC ; ===========================================================================
.text$mn:000043CC
.text$mn:000043CC ; Segment type: Pure code
.text$mn:000043CC ; Segment permissions: Read/Execute
.text$mn:000043CC _text$mn        segment para public 'CODE' use32
.text$mn:000043CC                 assume cs:_text$mn
.text$mn:000043CC                 ;org 43CCh
.text$mn:000043CC ; COMDAT (pick any)
.text$mn:000043CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043CC
.text$mn:000043CC ; =============== S U B R O U T I N E =======================================
.text$mn:000043CC
.text$mn:000043CC ; Attributes: bp-based frame
.text$mn:000043CC
.text$mn:000043CC ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct HWND__ *>>::_Vector_val<struct std::_Simple_types<struct HWND__ *>>(void)
.text$mn:000043CC                 public ??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ
.text$mn:000043CC ??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ proc near
.text$mn:000043CC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>(std::allocator<HWND__ *> const &)+29p
.text$mn:000043CC
.text$mn:000043CC var_10          = dword ptr -10h
.text$mn:000043CC var_C           = dword ptr -0Ch
.text$mn:000043CC var_4           = dword ptr -4
.text$mn:000043CC
.text$mn:000043CC                 push    ebp
.text$mn:000043CD                 mov     ebp, esp
.text$mn:000043CF                 push    0FFFFFFFFh
.text$mn:000043D1                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ
.text$mn:000043D6                 mov     eax, large fs:0
.text$mn:000043DC                 push    eax
.text$mn:000043DD                 push    ecx
.text$mn:000043DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000043E3                 xor     eax, ebp
.text$mn:000043E5                 push    eax
.text$mn:000043E6                 lea     eax, [ebp+var_C]
.text$mn:000043E9                 mov     large fs:0, eax
.text$mn:000043EF                 mov     [ebp+var_10], ecx
.text$mn:000043F2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000043F5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000043FA                 mov     [ebp+var_4], 0
.text$mn:00004401                 mov     eax, [ebp+var_10]
.text$mn:00004404                 mov     dword ptr [eax+4], 0
.text$mn:0000440B                 mov     ecx, [ebp+var_10]
.text$mn:0000440E                 mov     dword ptr [ecx+8], 0
.text$mn:00004415                 mov     edx, [ebp+var_10]
.text$mn:00004418                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000441F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004426                 mov     eax, [ebp+var_10]
.text$mn:00004429                 mov     ecx, [ebp+var_C]
.text$mn:0000442C                 mov     large fs:0, ecx
.text$mn:00004433                 pop     ecx
.text$mn:00004434                 mov     esp, ebp
.text$mn:00004436                 pop     ebp
.text$mn:00004437                 retn
.text$mn:00004437 ??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ endp
.text$mn:00004437
.text$mn:00004437 _text$mn        ends
.text$mn:00004437
.text$x:00004438 ; ===========================================================================
.text$x:00004438
.text$x:00004438 ; Segment type: Pure code
.text$x:00004438 ; Segment permissions: Read/Execute
.text$x:00004438 _text$x         segment para public 'CODE' use32
.text$x:00004438                 assume cs:_text$x
.text$x:00004438                 ;org 4438h
.text$x:00004438 ; COMDAT (pick associative to section at 43CC)
.text$x:00004438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004438
.text$x:00004438 ; =============== S U B R O U T I N E =======================================
.text$x:00004438
.text$x:00004438
.text$x:00004438 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004438                                         ; DATA XREF: .xdata$x:0000941Co
.text$x:00004438                 mov     ecx, [ebp-10h]  ; this
.text$x:0000443B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000443B __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000443B
.text$x:00004440
.text$x:00004440 ; =============== S U B R O U T I N E =======================================
.text$x:00004440
.text$x:00004440
.text$x:00004440 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ proc near
.text$x:00004440                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<HWND__ *>>::_Vector_val<std::_Simple_types<HWND__ *>>(void)+5o
.text$x:00004440
.text$x:00004440 arg_4           = dword ptr  8
.text$x:00004440
.text$x:00004440                 mov     edx, [esp+arg_4]
.text$x:00004444                 lea     eax, [edx+0Ch]
.text$x:00004447                 mov     ecx, [edx-8]
.text$x:0000444A                 xor     ecx, eax
.text$x:0000444C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004451                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ
.text$x:00004456                 jmp     ___CxxFrameHandler3
.text$x:00004456 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ endp
.text$x:00004456
.text$x:00004456 ; ---------------------------------------------------------------------------
.text$x:0000445B                 align 4
.text$x:0000445B _text$x         ends
.text$x:0000445B
.text$mn:0000445C ; ===========================================================================
.text$mn:0000445C
.text$mn:0000445C ; Segment type: Pure code
.text$mn:0000445C ; Segment permissions: Read/Execute
.text$mn:0000445C _text$mn        segment para public 'CODE' use32
.text$mn:0000445C                 assume cs:_text$mn
.text$mn:0000445C                 ;org 445Ch
.text$mn:0000445C ; COMDAT (pick any)
.text$mn:0000445C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000445C
.text$mn:0000445C ; =============== S U B R O U T I N E =======================================
.text$mn:0000445C
.text$mn:0000445C ; Attributes: bp-based frame
.text$mn:0000445C
.text$mn:0000445C ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct tTbData *>>::_Vector_val<struct std::_Simple_types<struct tTbData *>>(void)
.text$mn:0000445C                 public ??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ
.text$mn:0000445C ??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ proc near
.text$mn:0000445C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>(std::allocator<tTbData *> const &)+29p
.text$mn:0000445C
.text$mn:0000445C var_10          = dword ptr -10h
.text$mn:0000445C var_C           = dword ptr -0Ch
.text$mn:0000445C var_4           = dword ptr -4
.text$mn:0000445C
.text$mn:0000445C                 push    ebp
.text$mn:0000445D                 mov     ebp, esp
.text$mn:0000445F                 push    0FFFFFFFFh
.text$mn:00004461                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ
.text$mn:00004466                 mov     eax, large fs:0
.text$mn:0000446C                 push    eax
.text$mn:0000446D                 push    ecx
.text$mn:0000446E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004473                 xor     eax, ebp
.text$mn:00004475                 push    eax
.text$mn:00004476                 lea     eax, [ebp+var_C]
.text$mn:00004479                 mov     large fs:0, eax
.text$mn:0000447F                 mov     [ebp+var_10], ecx
.text$mn:00004482                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004485                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000448A                 mov     [ebp+var_4], 0
.text$mn:00004491                 mov     eax, [ebp+var_10]
.text$mn:00004494                 mov     dword ptr [eax+4], 0
.text$mn:0000449B                 mov     ecx, [ebp+var_10]
.text$mn:0000449E                 mov     dword ptr [ecx+8], 0
.text$mn:000044A5                 mov     edx, [ebp+var_10]
.text$mn:000044A8                 mov     dword ptr [edx+0Ch], 0
.text$mn:000044AF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000044B6                 mov     eax, [ebp+var_10]
.text$mn:000044B9                 mov     ecx, [ebp+var_C]
.text$mn:000044BC                 mov     large fs:0, ecx
.text$mn:000044C3                 pop     ecx
.text$mn:000044C4                 mov     esp, ebp
.text$mn:000044C6                 pop     ebp
.text$mn:000044C7                 retn
.text$mn:000044C7 ??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ endp
.text$mn:000044C7
.text$mn:000044C7 _text$mn        ends
.text$mn:000044C7
.text$x:000044C8 ; ===========================================================================
.text$x:000044C8
.text$x:000044C8 ; Segment type: Pure code
.text$x:000044C8 ; Segment permissions: Read/Execute
.text$x:000044C8 _text$x         segment para public 'CODE' use32
.text$x:000044C8                 assume cs:_text$x
.text$x:000044C8                 ;org 44C8h
.text$x:000044C8 ; COMDAT (pick associative to section at 445C)
.text$x:000044C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000044C8
.text$x:000044C8 ; =============== S U B R O U T I N E =======================================
.text$x:000044C8
.text$x:000044C8
.text$x:000044C8 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000044C8                                         ; DATA XREF: .xdata$x:000090C0o
.text$x:000044C8                 mov     ecx, [ebp-10h]  ; this
.text$x:000044CB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000044CB __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ$0 endp
.text$x:000044CB
.text$x:000044D0
.text$x:000044D0 ; =============== S U B R O U T I N E =======================================
.text$x:000044D0
.text$x:000044D0
.text$x:000044D0 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ proc near
.text$x:000044D0                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<tTbData *>>::_Vector_val<std::_Simple_types<tTbData *>>(void)+5o
.text$x:000044D0
.text$x:000044D0 arg_4           = dword ptr  8
.text$x:000044D0
.text$x:000044D0                 mov     edx, [esp+arg_4]
.text$x:000044D4                 lea     eax, [edx+0Ch]
.text$x:000044D7                 mov     ecx, [edx-8]
.text$x:000044DA                 xor     ecx, eax
.text$x:000044DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000044E1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ
.text$x:000044E6                 jmp     ___CxxFrameHandler3
.text$x:000044E6 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ endp
.text$x:000044E6
.text$x:000044E6 ; ---------------------------------------------------------------------------
.text$x:000044EB                 align 4
.text$x:000044EB _text$x         ends
.text$x:000044EB
.text$mn:000044EC ; ===========================================================================
.text$mn:000044EC
.text$mn:000044EC ; Segment type: Pure code
.text$mn:000044EC ; Segment permissions: Read/Execute
.text$mn:000044EC _text$mn        segment para public 'CODE' use32
.text$mn:000044EC                 assume cs:_text$mn
.text$mn:000044EC                 ;org 44ECh
.text$mn:000044EC ; COMDAT (pick any)
.text$mn:000044EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044EC
.text$mn:000044EC ; =============== S U B R O U T I N E =======================================
.text$mn:000044EC
.text$mn:000044EC ; Attributes: bp-based frame
.text$mn:000044EC
.text$mn:000044EC ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class DockingCont *>>::_Vector_val<struct std::_Simple_types<class DockingCont *>>(void)
.text$mn:000044EC                 public ??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:000044EC ??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$mn:000044EC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(std::allocator<DockingCont *> const &)+29p
.text$mn:000044EC
.text$mn:000044EC var_10          = dword ptr -10h
.text$mn:000044EC var_C           = dword ptr -0Ch
.text$mn:000044EC var_4           = dword ptr -4
.text$mn:000044EC
.text$mn:000044EC                 push    ebp
.text$mn:000044ED                 mov     ebp, esp
.text$mn:000044EF                 push    0FFFFFFFFh
.text$mn:000044F1                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:000044F6                 mov     eax, large fs:0
.text$mn:000044FC                 push    eax
.text$mn:000044FD                 push    ecx
.text$mn:000044FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004503                 xor     eax, ebp
.text$mn:00004505                 push    eax
.text$mn:00004506                 lea     eax, [ebp+var_C]
.text$mn:00004509                 mov     large fs:0, eax
.text$mn:0000450F                 mov     [ebp+var_10], ecx
.text$mn:00004512                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004515                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000451A                 mov     [ebp+var_4], 0
.text$mn:00004521                 mov     eax, [ebp+var_10]
.text$mn:00004524                 mov     dword ptr [eax+4], 0
.text$mn:0000452B                 mov     ecx, [ebp+var_10]
.text$mn:0000452E                 mov     dword ptr [ecx+8], 0
.text$mn:00004535                 mov     edx, [ebp+var_10]
.text$mn:00004538                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000453F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004546                 mov     eax, [ebp+var_10]
.text$mn:00004549                 mov     ecx, [ebp+var_C]
.text$mn:0000454C                 mov     large fs:0, ecx
.text$mn:00004553                 pop     ecx
.text$mn:00004554                 mov     esp, ebp
.text$mn:00004556                 pop     ebp
.text$mn:00004557                 retn
.text$mn:00004557 ??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$mn:00004557
.text$mn:00004557 _text$mn        ends
.text$mn:00004557
.text$x:00004558 ; ===========================================================================
.text$x:00004558
.text$x:00004558 ; Segment type: Pure code
.text$x:00004558 ; Segment permissions: Read/Execute
.text$x:00004558 _text$x         segment para public 'CODE' use32
.text$x:00004558                 assume cs:_text$x
.text$x:00004558                 ;org 4558h
.text$x:00004558 ; COMDAT (pick associative to section at 44EC)
.text$x:00004558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004558
.text$x:00004558 ; =============== S U B R O U T I N E =======================================
.text$x:00004558
.text$x:00004558
.text$x:00004558 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004558                                         ; DATA XREF: .xdata$x:000095A8o
.text$x:00004558                 mov     ecx, [ebp-10h]  ; this
.text$x:0000455B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000455B __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000455B
.text$x:00004560
.text$x:00004560 ; =============== S U B R O U T I N E =======================================
.text$x:00004560
.text$x:00004560
.text$x:00004560 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$x:00004560                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<DockingCont *>>::_Vector_val<std::_Simple_types<DockingCont *>>(void)+5o
.text$x:00004560
.text$x:00004560 arg_4           = dword ptr  8
.text$x:00004560
.text$x:00004560                 mov     edx, [esp+arg_4]
.text$x:00004564                 lea     eax, [edx+0Ch]
.text$x:00004567                 mov     ecx, [edx-8]
.text$x:0000456A                 xor     ecx, eax
.text$x:0000456C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004571                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$x:00004576                 jmp     ___CxxFrameHandler3
.text$x:00004576 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$x:00004576
.text$x:00004576 ; ---------------------------------------------------------------------------
.text$x:0000457B                 align 4
.text$x:0000457B _text$x         ends
.text$x:0000457B
.text$mn:0000457C ; ===========================================================================
.text$mn:0000457C
.text$mn:0000457C ; Segment type: Pure code
.text$mn:0000457C ; Segment permissions: Read/Execute
.text$mn:0000457C _text$mn        segment para public 'CODE' use32
.text$mn:0000457C                 assume cs:_text$mn
.text$mn:0000457C                 ;org 457Ch
.text$mn:0000457C ; COMDAT (pick any)
.text$mn:0000457C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000457C
.text$mn:0000457C ; =============== S U B R O U T I N E =======================================
.text$mn:0000457C
.text$mn:0000457C ; Attributes: bp-based frame
.text$mn:0000457C
.text$mn:0000457C ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class DockingSplitter *>>::_Vector_val<struct std::_Simple_types<class DockingSplitter *>>(void)
.text$mn:0000457C                 public ??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$mn:0000457C ??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ proc near
.text$mn:0000457C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>(std::allocator<DockingSplitter *> const &)+29p
.text$mn:0000457C
.text$mn:0000457C var_10          = dword ptr -10h
.text$mn:0000457C var_C           = dword ptr -0Ch
.text$mn:0000457C var_4           = dword ptr -4
.text$mn:0000457C
.text$mn:0000457C                 push    ebp
.text$mn:0000457D                 mov     ebp, esp
.text$mn:0000457F                 push    0FFFFFFFFh
.text$mn:00004581                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$mn:00004586                 mov     eax, large fs:0
.text$mn:0000458C                 push    eax
.text$mn:0000458D                 push    ecx
.text$mn:0000458E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004593                 xor     eax, ebp
.text$mn:00004595                 push    eax
.text$mn:00004596                 lea     eax, [ebp+var_C]
.text$mn:00004599                 mov     large fs:0, eax
.text$mn:0000459F                 mov     [ebp+var_10], ecx
.text$mn:000045A2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000045A5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000045AA                 mov     [ebp+var_4], 0
.text$mn:000045B1                 mov     eax, [ebp+var_10]
.text$mn:000045B4                 mov     dword ptr [eax+4], 0
.text$mn:000045BB                 mov     ecx, [ebp+var_10]
.text$mn:000045BE                 mov     dword ptr [ecx+8], 0
.text$mn:000045C5                 mov     edx, [ebp+var_10]
.text$mn:000045C8                 mov     dword ptr [edx+0Ch], 0
.text$mn:000045CF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000045D6                 mov     eax, [ebp+var_10]
.text$mn:000045D9                 mov     ecx, [ebp+var_C]
.text$mn:000045DC                 mov     large fs:0, ecx
.text$mn:000045E3                 pop     ecx
.text$mn:000045E4                 mov     esp, ebp
.text$mn:000045E6                 pop     ebp
.text$mn:000045E7                 retn
.text$mn:000045E7 ??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ endp
.text$mn:000045E7
.text$mn:000045E7 _text$mn        ends
.text$mn:000045E7
.text$x:000045E8 ; ===========================================================================
.text$x:000045E8
.text$x:000045E8 ; Segment type: Pure code
.text$x:000045E8 ; Segment permissions: Read/Execute
.text$x:000045E8 _text$x         segment para public 'CODE' use32
.text$x:000045E8                 assume cs:_text$x
.text$x:000045E8                 ;org 45E8h
.text$x:000045E8 ; COMDAT (pick associative to section at 457C)
.text$x:000045E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000045E8
.text$x:000045E8 ; =============== S U B R O U T I N E =======================================
.text$x:000045E8
.text$x:000045E8
.text$x:000045E8 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000045E8                                         ; DATA XREF: .xdata$x:00009734o
.text$x:000045E8                 mov     ecx, [ebp-10h]  ; this
.text$x:000045EB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000045EB __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0 endp
.text$x:000045EB
.text$x:000045F0
.text$x:000045F0 ; =============== S U B R O U T I N E =======================================
.text$x:000045F0
.text$x:000045F0
.text$x:000045F0 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ proc near
.text$x:000045F0                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<DockingSplitter *>>::_Vector_val<std::_Simple_types<DockingSplitter *>>(void)+5o
.text$x:000045F0
.text$x:000045F0 arg_4           = dword ptr  8
.text$x:000045F0
.text$x:000045F0                 mov     edx, [esp+arg_4]
.text$x:000045F4                 lea     eax, [edx+0Ch]
.text$x:000045F7                 mov     ecx, [edx-8]
.text$x:000045FA                 xor     ecx, eax
.text$x:000045FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004601                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$x:00004606                 jmp     ___CxxFrameHandler3
.text$x:00004606 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ endp
.text$x:00004606
.text$x:00004606 ; ---------------------------------------------------------------------------
.text$x:0000460B                 align 4
.text$x:0000460B _text$x         ends
.text$x:0000460B
.text$mn:0000460C ; ===========================================================================
.text$mn:0000460C
.text$mn:0000460C ; Segment type: Pure code
.text$mn:0000460C ; Segment permissions: Read/Execute
.text$mn:0000460C _text$mn        segment para public 'CODE' use32
.text$mn:0000460C                 assume cs:_text$mn
.text$mn:0000460C                 ;org 460Ch
.text$mn:0000460C ; COMDAT (pick any)
.text$mn:0000460C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000460C
.text$mn:0000460C ; =============== S U B R O U T I N E =======================================
.text$mn:0000460C
.text$mn:0000460C ; Attributes: bp-based frame
.text$mn:0000460C
.text$mn:0000460C ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:0000460C                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:0000460C ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:0000460C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:0000460C
.text$mn:0000460C var_4           = dword ptr -4
.text$mn:0000460C
.text$mn:0000460C                 push    ebp
.text$mn:0000460D                 mov     ebp, esp
.text$mn:0000460F                 push    ecx
.text$mn:00004610                 mov     [ebp+var_4], ecx
.text$mn:00004613                 mov     ecx, [ebp+var_4]
.text$mn:00004616                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000461B                 mov     eax, [ebp+var_4]
.text$mn:0000461E                 mov     esp, ebp
.text$mn:00004620                 pop     ebp
.text$mn:00004621                 retn
.text$mn:00004621 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00004621
.text$mn:00004621 ; ---------------------------------------------------------------------------
.text$mn:00004622                 align 4
.text$mn:00004622 _text$mn        ends
.text$mn:00004622
.text$mn:00004624 ; ===========================================================================
.text$mn:00004624
.text$mn:00004624 ; Segment type: Pure code
.text$mn:00004624 ; Segment permissions: Read/Execute
.text$mn:00004624 _text$mn        segment para public 'CODE' use32
.text$mn:00004624                 assume cs:_text$mn
.text$mn:00004624                 ;org 4624h
.text$mn:00004624 ; COMDAT (pick any)
.text$mn:00004624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004624
.text$mn:00004624 ; =============== S U B R O U T I N E =======================================
.text$mn:00004624
.text$mn:00004624 ; Attributes: bp-based frame
.text$mn:00004624
.text$mn:00004624 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct HWND__ *>>::_Wrap_alloc<class std::allocator<struct HWND__ *>>(void)
.text$mn:00004624                 public ??0?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ
.text$mn:00004624 ??0?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ proc near
.text$mn:00004624                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Getal(void)+Ap
.text$mn:00004624
.text$mn:00004624 var_4           = dword ptr -4
.text$mn:00004624
.text$mn:00004624                 push    ebp
.text$mn:00004625                 mov     ebp, esp
.text$mn:00004627                 push    ecx
.text$mn:00004628                 mov     [ebp+var_4], ecx
.text$mn:0000462B                 mov     ecx, [ebp+var_4]
.text$mn:0000462E                 call    ??0?$allocator@PAUHWND__@@@std@@QAE@XZ ; std::allocator<HWND__ *>::allocator<HWND__ *>(void)
.text$mn:00004633                 mov     eax, [ebp+var_4]
.text$mn:00004636                 mov     esp, ebp
.text$mn:00004638                 pop     ebp
.text$mn:00004639                 retn
.text$mn:00004639 ??0?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ endp
.text$mn:00004639
.text$mn:00004639 ; ---------------------------------------------------------------------------
.text$mn:0000463A                 align 4
.text$mn:0000463A _text$mn        ends
.text$mn:0000463A
.text$mn:0000463C ; ===========================================================================
.text$mn:0000463C
.text$mn:0000463C ; Segment type: Pure code
.text$mn:0000463C ; Segment permissions: Read/Execute
.text$mn:0000463C _text$mn        segment para public 'CODE' use32
.text$mn:0000463C                 assume cs:_text$mn
.text$mn:0000463C                 ;org 463Ch
.text$mn:0000463C ; COMDAT (pick any)
.text$mn:0000463C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000463C
.text$mn:0000463C ; =============== S U B R O U T I N E =======================================
.text$mn:0000463C
.text$mn:0000463C ; Attributes: bp-based frame
.text$mn:0000463C
.text$mn:0000463C ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct tTbData *>>::_Wrap_alloc<class std::allocator<struct tTbData *>>(class std::allocator<struct tTbData *> const &)
.text$mn:0000463C                 public ??0?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z
.text$mn:0000463C ??0?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z proc near
.text$mn:0000463C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tTbData *>>::select_on_container_copy_construction(void)+1Dp
.text$mn:0000463C
.text$mn:0000463C var_4           = dword ptr -4
.text$mn:0000463C arg_0           = dword ptr  8
.text$mn:0000463C
.text$mn:0000463C                 push    ebp
.text$mn:0000463D                 mov     ebp, esp
.text$mn:0000463F                 push    ecx
.text$mn:00004640                 mov     [ebp+var_4], ecx
.text$mn:00004643                 mov     eax, [ebp+arg_0]
.text$mn:00004646                 push    eax
.text$mn:00004647                 mov     ecx, [ebp+var_4]
.text$mn:0000464A                 call    ??0?$allocator@PAUtTbData@@@std@@QAE@ABV01@@Z ; std::allocator<tTbData *>::allocator<tTbData *>(std::allocator<tTbData *> const &)
.text$mn:0000464F                 mov     eax, [ebp+var_4]
.text$mn:00004652                 mov     esp, ebp
.text$mn:00004654                 pop     ebp
.text$mn:00004655                 retn    4
.text$mn:00004655 ??0?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z endp
.text$mn:00004655
.text$mn:00004655 _text$mn        ends
.text$mn:00004655
.text$mn:00004658 ; ===========================================================================
.text$mn:00004658
.text$mn:00004658 ; Segment type: Pure code
.text$mn:00004658 ; Segment permissions: Read/Execute
.text$mn:00004658 _text$mn        segment para public 'CODE' use32
.text$mn:00004658                 assume cs:_text$mn
.text$mn:00004658                 ;org 4658h
.text$mn:00004658 ; COMDAT (pick any)
.text$mn:00004658                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004658
.text$mn:00004658 ; =============== S U B R O U T I N E =======================================
.text$mn:00004658
.text$mn:00004658 ; Attributes: bp-based frame
.text$mn:00004658
.text$mn:00004658 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct tTbData *>>::_Wrap_alloc<class std::allocator<struct tTbData *>>(void)
.text$mn:00004658                 public ??0?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ
.text$mn:00004658 ??0?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ proc near
.text$mn:00004658                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Getal(void)+Ap
.text$mn:00004658
.text$mn:00004658 var_4           = dword ptr -4
.text$mn:00004658
.text$mn:00004658                 push    ebp
.text$mn:00004659                 mov     ebp, esp
.text$mn:0000465B                 push    ecx
.text$mn:0000465C                 mov     [ebp+var_4], ecx
.text$mn:0000465F                 mov     ecx, [ebp+var_4]
.text$mn:00004662                 call    ??0?$allocator@PAUtTbData@@@std@@QAE@XZ ; std::allocator<tTbData *>::allocator<tTbData *>(void)
.text$mn:00004667                 mov     eax, [ebp+var_4]
.text$mn:0000466A                 mov     esp, ebp
.text$mn:0000466C                 pop     ebp
.text$mn:0000466D                 retn
.text$mn:0000466D ??0?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ endp
.text$mn:0000466D
.text$mn:0000466D ; ---------------------------------------------------------------------------
.text$mn:0000466E                 align 10h
.text$mn:0000466E _text$mn        ends
.text$mn:0000466E
.text$mn:00004670 ; ===========================================================================
.text$mn:00004670
.text$mn:00004670 ; Segment type: Pure code
.text$mn:00004670 ; Segment permissions: Read/Execute
.text$mn:00004670 _text$mn        segment para public 'CODE' use32
.text$mn:00004670                 assume cs:_text$mn
.text$mn:00004670                 ;org 4670h
.text$mn:00004670 ; COMDAT (pick any)
.text$mn:00004670                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004670
.text$mn:00004670 ; =============== S U B R O U T I N E =======================================
.text$mn:00004670
.text$mn:00004670 ; Attributes: bp-based frame
.text$mn:00004670
.text$mn:00004670 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class DockingCont *>>::_Wrap_alloc<class std::allocator<class DockingCont *>>(void)
.text$mn:00004670                 public ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:00004670 ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$mn:00004670                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)+Ap
.text$mn:00004670
.text$mn:00004670 var_4           = dword ptr -4
.text$mn:00004670
.text$mn:00004670                 push    ebp
.text$mn:00004671                 mov     ebp, esp
.text$mn:00004673                 push    ecx
.text$mn:00004674                 mov     [ebp+var_4], ecx
.text$mn:00004677                 mov     ecx, [ebp+var_4]
.text$mn:0000467A                 call    ??0?$allocator@PAVDockingCont@@@std@@QAE@XZ ; std::allocator<DockingCont *>::allocator<DockingCont *>(void)
.text$mn:0000467F                 mov     eax, [ebp+var_4]
.text$mn:00004682                 mov     esp, ebp
.text$mn:00004684                 pop     ebp
.text$mn:00004685                 retn
.text$mn:00004685 ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$mn:00004685
.text$mn:00004685 ; ---------------------------------------------------------------------------
.text$mn:00004686                 align 4
.text$mn:00004686 _text$mn        ends
.text$mn:00004686
.text$mn:00004688 ; ===========================================================================
.text$mn:00004688
.text$mn:00004688 ; Segment type: Pure code
.text$mn:00004688 ; Segment permissions: Read/Execute
.text$mn:00004688 _text$mn        segment para public 'CODE' use32
.text$mn:00004688                 assume cs:_text$mn
.text$mn:00004688                 ;org 4688h
.text$mn:00004688 ; COMDAT (pick any)
.text$mn:00004688                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004688
.text$mn:00004688 ; =============== S U B R O U T I N E =======================================
.text$mn:00004688
.text$mn:00004688 ; Attributes: bp-based frame
.text$mn:00004688
.text$mn:00004688 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class DockingSplitter *>>::_Wrap_alloc<class std::allocator<class DockingSplitter *>>(void)
.text$mn:00004688                 public ??0?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$mn:00004688 ??0?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ proc near
.text$mn:00004688                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Getal(void)+Ap
.text$mn:00004688
.text$mn:00004688 var_4           = dword ptr -4
.text$mn:00004688
.text$mn:00004688                 push    ebp
.text$mn:00004689                 mov     ebp, esp
.text$mn:0000468B                 push    ecx
.text$mn:0000468C                 mov     [ebp+var_4], ecx
.text$mn:0000468F                 mov     ecx, [ebp+var_4]
.text$mn:00004692                 call    ??0?$allocator@PAVDockingSplitter@@@std@@QAE@XZ ; std::allocator<DockingSplitter *>::allocator<DockingSplitter *>(void)
.text$mn:00004697                 mov     eax, [ebp+var_4]
.text$mn:0000469A                 mov     esp, ebp
.text$mn:0000469C                 pop     ebp
.text$mn:0000469D                 retn
.text$mn:0000469D ??0?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ endp
.text$mn:0000469D
.text$mn:0000469D ; ---------------------------------------------------------------------------
.text$mn:0000469E                 align 10h
.text$mn:0000469E _text$mn        ends
.text$mn:0000469E
.text$mn:000046A0 ; ===========================================================================
.text$mn:000046A0
.text$mn:000046A0 ; Segment type: Pure code
.text$mn:000046A0 ; Segment permissions: Read/Execute
.text$mn:000046A0 _text$mn        segment para public 'CODE' use32
.text$mn:000046A0                 assume cs:_text$mn
.text$mn:000046A0                 ;org 46A0h
.text$mn:000046A0 ; COMDAT (pick any)
.text$mn:000046A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046A0
.text$mn:000046A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000046A0
.text$mn:000046A0 ; Attributes: bp-based frame
.text$mn:000046A0
.text$mn:000046A0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:000046A0                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:000046A0 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000046A0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Alloc_proxy(void)+Cp
.text$mn:000046A0                                         ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Alloc_proxy(void)+Cp ...
.text$mn:000046A0
.text$mn:000046A0 var_4           = dword ptr -4
.text$mn:000046A0
.text$mn:000046A0                 push    ebp
.text$mn:000046A1                 mov     ebp, esp
.text$mn:000046A3                 push    ecx
.text$mn:000046A4                 mov     [ebp+var_4], ecx
.text$mn:000046A7                 mov     ecx, [ebp+var_4]
.text$mn:000046AA                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000046AF                 mov     eax, [ebp+var_4]
.text$mn:000046B2                 mov     esp, ebp
.text$mn:000046B4                 pop     ebp
.text$mn:000046B5                 retn
.text$mn:000046B5 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:000046B5
.text$mn:000046B5 ; ---------------------------------------------------------------------------
.text$mn:000046B6                 align 4
.text$mn:000046B6 _text$mn        ends
.text$mn:000046B6
.text$mn:000046B8 ; ===========================================================================
.text$mn:000046B8
.text$mn:000046B8 ; Segment type: Pure code
.text$mn:000046B8 ; Segment permissions: Read/Execute
.text$mn:000046B8 _text$mn        segment para public 'CODE' use32
.text$mn:000046B8                 assume cs:_text$mn
.text$mn:000046B8                 ;org 46B8h
.text$mn:000046B8 ; COMDAT (pick any)
.text$mn:000046B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046B8
.text$mn:000046B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046B8
.text$mn:000046B8 ; Attributes: bp-based frame
.text$mn:000046B8
.text$mn:000046B8 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:000046B8                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:000046B8 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:000046B8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:000046B8
.text$mn:000046B8 var_4           = dword ptr -4
.text$mn:000046B8
.text$mn:000046B8                 push    ebp
.text$mn:000046B9                 mov     ebp, esp
.text$mn:000046BB                 push    ecx
.text$mn:000046BC                 mov     [ebp+var_4], ecx
.text$mn:000046BF                 mov     eax, [ebp+var_4]
.text$mn:000046C2                 mov     esp, ebp
.text$mn:000046C4                 pop     ebp
.text$mn:000046C5                 retn
.text$mn:000046C5 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000046C5
.text$mn:000046C5 ; ---------------------------------------------------------------------------
.text$mn:000046C6                 align 4
.text$mn:000046C6 _text$mn        ends
.text$mn:000046C6
.text$mn:000046C8 ; ===========================================================================
.text$mn:000046C8
.text$mn:000046C8 ; Segment type: Pure code
.text$mn:000046C8 ; Segment permissions: Read/Execute
.text$mn:000046C8 _text$mn        segment para public 'CODE' use32
.text$mn:000046C8                 assume cs:_text$mn
.text$mn:000046C8                 ;org 46C8h
.text$mn:000046C8 ; COMDAT (pick any)
.text$mn:000046C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046C8
.text$mn:000046C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046C8
.text$mn:000046C8 ; Attributes: bp-based frame
.text$mn:000046C8
.text$mn:000046C8 ; public: __thiscall std::allocator<struct HWND__ *>::allocator<struct HWND__ *>(void)
.text$mn:000046C8                 public ??0?$allocator@PAUHWND__@@@std@@QAE@XZ
.text$mn:000046C8 ??0?$allocator@PAUHWND__@@@std@@QAE@XZ proc near
.text$mn:000046C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HWND__ *>>::_Wrap_alloc<std::allocator<HWND__ *>>(void)+Ap
.text$mn:000046C8                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::vector<HWND__ *,std::allocator<HWND__ *>>(void)+2Bp
.text$mn:000046C8
.text$mn:000046C8 var_4           = dword ptr -4
.text$mn:000046C8
.text$mn:000046C8                 push    ebp
.text$mn:000046C9                 mov     ebp, esp
.text$mn:000046CB                 push    ecx
.text$mn:000046CC                 mov     [ebp+var_4], ecx
.text$mn:000046CF                 mov     eax, [ebp+var_4]
.text$mn:000046D2                 mov     esp, ebp
.text$mn:000046D4                 pop     ebp
.text$mn:000046D5                 retn
.text$mn:000046D5 ??0?$allocator@PAUHWND__@@@std@@QAE@XZ endp
.text$mn:000046D5
.text$mn:000046D5 ; ---------------------------------------------------------------------------
.text$mn:000046D6                 align 4
.text$mn:000046D6 _text$mn        ends
.text$mn:000046D6
.text$mn:000046D8 ; ===========================================================================
.text$mn:000046D8
.text$mn:000046D8 ; Segment type: Pure code
.text$mn:000046D8 ; Segment permissions: Read/Execute
.text$mn:000046D8 _text$mn        segment para public 'CODE' use32
.text$mn:000046D8                 assume cs:_text$mn
.text$mn:000046D8                 ;org 46D8h
.text$mn:000046D8 ; COMDAT (pick any)
.text$mn:000046D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046D8
.text$mn:000046D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046D8
.text$mn:000046D8 ; Attributes: bp-based frame
.text$mn:000046D8
.text$mn:000046D8 ; public: __thiscall std::allocator<struct tTbData *>::allocator<struct tTbData *>(class std::allocator<struct tTbData *> const &)
.text$mn:000046D8                 public ??0?$allocator@PAUtTbData@@@std@@QAE@ABV01@@Z
.text$mn:000046D8 ??0?$allocator@PAUtTbData@@@std@@QAE@ABV01@@Z proc near
.text$mn:000046D8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tTbData *>>::_Wrap_alloc<std::allocator<tTbData *>>(std::allocator<tTbData *> const &)+Ep
.text$mn:000046D8                                         ; std::allocator<tTbData *>::select_on_container_copy_construction(void)+Ep
.text$mn:000046D8
.text$mn:000046D8 var_4           = dword ptr -4
.text$mn:000046D8
.text$mn:000046D8                 push    ebp
.text$mn:000046D9                 mov     ebp, esp
.text$mn:000046DB                 push    ecx
.text$mn:000046DC                 mov     [ebp+var_4], ecx
.text$mn:000046DF                 mov     eax, [ebp+var_4]
.text$mn:000046E2                 mov     esp, ebp
.text$mn:000046E4                 pop     ebp
.text$mn:000046E5                 retn    4
.text$mn:000046E5 ??0?$allocator@PAUtTbData@@@std@@QAE@ABV01@@Z endp
.text$mn:000046E5
.text$mn:000046E5 _text$mn        ends
.text$mn:000046E5
.text$mn:000046E8 ; ===========================================================================
.text$mn:000046E8
.text$mn:000046E8 ; Segment type: Pure code
.text$mn:000046E8 ; Segment permissions: Read/Execute
.text$mn:000046E8 _text$mn        segment para public 'CODE' use32
.text$mn:000046E8                 assume cs:_text$mn
.text$mn:000046E8                 ;org 46E8h
.text$mn:000046E8 ; COMDAT (pick any)
.text$mn:000046E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046E8
.text$mn:000046E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046E8
.text$mn:000046E8 ; Attributes: bp-based frame
.text$mn:000046E8
.text$mn:000046E8 ; public: __thiscall std::allocator<struct tTbData *>::allocator<struct tTbData *>(void)
.text$mn:000046E8                 public ??0?$allocator@PAUtTbData@@@std@@QAE@XZ
.text$mn:000046E8 ??0?$allocator@PAUtTbData@@@std@@QAE@XZ proc near
.text$mn:000046E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tTbData *>>::_Wrap_alloc<std::allocator<tTbData *>>(void)+Ap
.text$mn:000046E8
.text$mn:000046E8 var_4           = dword ptr -4
.text$mn:000046E8
.text$mn:000046E8                 push    ebp
.text$mn:000046E9                 mov     ebp, esp
.text$mn:000046EB                 push    ecx
.text$mn:000046EC                 mov     [ebp+var_4], ecx
.text$mn:000046EF                 mov     eax, [ebp+var_4]
.text$mn:000046F2                 mov     esp, ebp
.text$mn:000046F4                 pop     ebp
.text$mn:000046F5                 retn
.text$mn:000046F5 ??0?$allocator@PAUtTbData@@@std@@QAE@XZ endp
.text$mn:000046F5
.text$mn:000046F5 ; ---------------------------------------------------------------------------
.text$mn:000046F6                 align 4
.text$mn:000046F6 _text$mn        ends
.text$mn:000046F6
.text$mn:000046F8 ; ===========================================================================
.text$mn:000046F8
.text$mn:000046F8 ; Segment type: Pure code
.text$mn:000046F8 ; Segment permissions: Read/Execute
.text$mn:000046F8 _text$mn        segment para public 'CODE' use32
.text$mn:000046F8                 assume cs:_text$mn
.text$mn:000046F8                 ;org 46F8h
.text$mn:000046F8 ; COMDAT (pick any)
.text$mn:000046F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046F8
.text$mn:000046F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046F8
.text$mn:000046F8 ; Attributes: bp-based frame
.text$mn:000046F8
.text$mn:000046F8 ; public: __thiscall std::allocator<class DockingCont *>::allocator<class DockingCont *>(void)
.text$mn:000046F8                 public ??0?$allocator@PAVDockingCont@@@std@@QAE@XZ
.text$mn:000046F8 ??0?$allocator@PAVDockingCont@@@std@@QAE@XZ proc near
.text$mn:000046F8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::_Wrap_alloc<std::allocator<DockingCont *>>(void)+Ap
.text$mn:000046F8                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(void)+2Bp
.text$mn:000046F8
.text$mn:000046F8 var_4           = dword ptr -4
.text$mn:000046F8
.text$mn:000046F8                 push    ebp
.text$mn:000046F9                 mov     ebp, esp
.text$mn:000046FB                 push    ecx
.text$mn:000046FC                 mov     [ebp+var_4], ecx
.text$mn:000046FF                 mov     eax, [ebp+var_4]
.text$mn:00004702                 mov     esp, ebp
.text$mn:00004704                 pop     ebp
.text$mn:00004705                 retn
.text$mn:00004705 ??0?$allocator@PAVDockingCont@@@std@@QAE@XZ endp
.text$mn:00004705
.text$mn:00004705 ; ---------------------------------------------------------------------------
.text$mn:00004706                 align 4
.text$mn:00004706 _text$mn        ends
.text$mn:00004706
.text$mn:00004708 ; ===========================================================================
.text$mn:00004708
.text$mn:00004708 ; Segment type: Pure code
.text$mn:00004708 ; Segment permissions: Read/Execute
.text$mn:00004708 _text$mn        segment para public 'CODE' use32
.text$mn:00004708                 assume cs:_text$mn
.text$mn:00004708                 ;org 4708h
.text$mn:00004708 ; COMDAT (pick any)
.text$mn:00004708                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004708
.text$mn:00004708 ; =============== S U B R O U T I N E =======================================
.text$mn:00004708
.text$mn:00004708 ; Attributes: bp-based frame
.text$mn:00004708
.text$mn:00004708 ; public: __thiscall std::allocator<class DockingSplitter *>::allocator<class DockingSplitter *>(void)
.text$mn:00004708                 public ??0?$allocator@PAVDockingSplitter@@@std@@QAE@XZ
.text$mn:00004708 ??0?$allocator@PAVDockingSplitter@@@std@@QAE@XZ proc near
.text$mn:00004708                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingSplitter *>>::_Wrap_alloc<std::allocator<DockingSplitter *>>(void)+Ap
.text$mn:00004708                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::vector<DockingSplitter *,std::allocator<DockingSplitter *>>(void)+2Bp
.text$mn:00004708
.text$mn:00004708 var_4           = dword ptr -4
.text$mn:00004708
.text$mn:00004708                 push    ebp
.text$mn:00004709                 mov     ebp, esp
.text$mn:0000470B                 push    ecx
.text$mn:0000470C                 mov     [ebp+var_4], ecx
.text$mn:0000470F                 mov     eax, [ebp+var_4]
.text$mn:00004712                 mov     esp, ebp
.text$mn:00004714                 pop     ebp
.text$mn:00004715                 retn
.text$mn:00004715 ??0?$allocator@PAVDockingSplitter@@@std@@QAE@XZ endp
.text$mn:00004715
.text$mn:00004715 ; ---------------------------------------------------------------------------
.text$mn:00004716                 align 4
.text$mn:00004716 _text$mn        ends
.text$mn:00004716
.text$mn:00004718 ; ===========================================================================
.text$mn:00004718
.text$mn:00004718 ; Segment type: Pure code
.text$mn:00004718 ; Segment permissions: Read/Execute
.text$mn:00004718 _text$mn        segment para public 'CODE' use32
.text$mn:00004718                 assume cs:_text$mn
.text$mn:00004718                 ;org 4718h
.text$mn:00004718 ; COMDAT (pick any)
.text$mn:00004718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004718
.text$mn:00004718 ; =============== S U B R O U T I N E =======================================
.text$mn:00004718
.text$mn:00004718 ; Attributes: bp-based frame
.text$mn:00004718
.text$mn:00004718 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00004718                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00004718 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00004718                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00004718                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00004718
.text$mn:00004718 var_4           = dword ptr -4
.text$mn:00004718
.text$mn:00004718                 push    ebp
.text$mn:00004719                 mov     ebp, esp
.text$mn:0000471B                 push    ecx
.text$mn:0000471C                 mov     [ebp+var_4], ecx
.text$mn:0000471F                 mov     eax, [ebp+var_4]
.text$mn:00004722                 mov     esp, ebp
.text$mn:00004724                 pop     ebp
.text$mn:00004725                 retn
.text$mn:00004725 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00004725
.text$mn:00004725 ; ---------------------------------------------------------------------------
.text$mn:00004726                 align 4
.text$mn:00004726 _text$mn        ends
.text$mn:00004726
.text$mn:00004728 ; ===========================================================================
.text$mn:00004728
.text$mn:00004728 ; Segment type: Pure code
.text$mn:00004728 ; Segment permissions: Read/Execute
.text$mn:00004728 _text$mn        segment para public 'CODE' use32
.text$mn:00004728                 assume cs:_text$mn
.text$mn:00004728                 ;org 4728h
.text$mn:00004728 ; COMDAT (pick any)
.text$mn:00004728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004728
.text$mn:00004728 ; =============== S U B R O U T I N E =======================================
.text$mn:00004728
.text$mn:00004728 ; Attributes: bp-based frame
.text$mn:00004728
.text$mn:00004728 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00004728                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00004728 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00004728                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00004728                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00004728
.text$mn:00004728 var_14          = dword ptr -14h
.text$mn:00004728 var_D           = byte ptr -0Dh
.text$mn:00004728 var_C           = dword ptr -0Ch
.text$mn:00004728 var_4           = dword ptr -4
.text$mn:00004728 Str             = dword ptr  8
.text$mn:00004728
.text$mn:00004728                 push    ebp
.text$mn:00004729                 mov     ebp, esp
.text$mn:0000472B                 push    0FFFFFFFFh
.text$mn:0000472D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00004732                 mov     eax, large fs:0
.text$mn:00004738                 push    eax
.text$mn:00004739                 sub     esp, 8
.text$mn:0000473C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004741                 xor     eax, ebp
.text$mn:00004743                 push    eax
.text$mn:00004744                 lea     eax, [ebp+var_C]
.text$mn:00004747                 mov     large fs:0, eax
.text$mn:0000474D                 mov     [ebp+var_14], ecx
.text$mn:00004750                 lea     ecx, [ebp+var_D]
.text$mn:00004753                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00004758                 push    eax
.text$mn:00004759                 mov     ecx, [ebp+var_14]
.text$mn:0000475C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00004761                 mov     [ebp+var_4], 0
.text$mn:00004768                 push    0               ; Size
.text$mn:0000476A                 push    0               ; char
.text$mn:0000476C                 mov     ecx, [ebp+var_14]
.text$mn:0000476F                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004774                 mov     eax, [ebp+Str]
.text$mn:00004777                 push    eax             ; Str
.text$mn:00004778                 mov     ecx, [ebp+var_14]
.text$mn:0000477B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00004780                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004787                 mov     eax, [ebp+var_14]
.text$mn:0000478A                 mov     ecx, [ebp+var_C]
.text$mn:0000478D                 mov     large fs:0, ecx
.text$mn:00004794                 pop     ecx
.text$mn:00004795                 mov     esp, ebp
.text$mn:00004797                 pop     ebp
.text$mn:00004798                 retn    4
.text$mn:00004798 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00004798
.text$mn:00004798 ; ---------------------------------------------------------------------------
.text$mn:0000479B                 align 4
.text$mn:0000479B _text$mn        ends
.text$mn:0000479B
.text$x:0000479C ; ===========================================================================
.text$x:0000479C
.text$x:0000479C ; Segment type: Pure code
.text$x:0000479C ; Segment permissions: Read/Execute
.text$x:0000479C _text$x         segment para public 'CODE' use32
.text$x:0000479C                 assume cs:_text$x
.text$x:0000479C                 ;org 479Ch
.text$x:0000479C ; COMDAT (pick associative to section at 4728)
.text$x:0000479C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000479C
.text$x:0000479C ; =============== S U B R O U T I N E =======================================
.text$x:0000479C
.text$x:0000479C
.text$x:0000479C __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:0000479C                                         ; DATA XREF: .xdata$x:00008DA0o
.text$x:0000479C                 mov     ecx, [ebp-14h]
.text$x:0000479F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000479F __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000479F
.text$x:000047A4
.text$x:000047A4 ; =============== S U B R O U T I N E =======================================
.text$x:000047A4
.text$x:000047A4
.text$x:000047A4 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000047A4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000047A4
.text$x:000047A4 arg_4           = dword ptr  8
.text$x:000047A4
.text$x:000047A4                 mov     edx, [esp+arg_4]
.text$x:000047A8                 lea     eax, [edx+0Ch]
.text$x:000047AB                 mov     ecx, [edx-0Ch]
.text$x:000047AE                 xor     ecx, eax
.text$x:000047B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000047B5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000047BA                 jmp     ___CxxFrameHandler3
.text$x:000047BA __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000047BA
.text$x:000047BA ; ---------------------------------------------------------------------------
.text$x:000047BF                 align 10h
.text$x:000047BF _text$x         ends
.text$x:000047BF
.text$mn:000047C0 ; ===========================================================================
.text$mn:000047C0
.text$mn:000047C0 ; Segment type: Pure code
.text$mn:000047C0 ; Segment permissions: Read/Execute
.text$mn:000047C0 _text$mn        segment para public 'CODE' use32
.text$mn:000047C0                 assume cs:_text$mn
.text$mn:000047C0                 ;org 47C0h
.text$mn:000047C0 ; COMDAT (pick any)
.text$mn:000047C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047C0
.text$mn:000047C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000047C0
.text$mn:000047C0 ; Attributes: bp-based frame
.text$mn:000047C0
.text$mn:000047C0 ; public: __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>(void)
.text$mn:000047C0                 public ??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ
.text$mn:000047C0 ??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ proc near
.text$mn:000047C0                                         ; CODE XREF: DockingManager::DockingManager(void)+46p
.text$mn:000047C0
.text$mn:000047C0 var_14          = dword ptr -14h
.text$mn:000047C0 var_D           = byte ptr -0Dh
.text$mn:000047C0 var_C           = dword ptr -0Ch
.text$mn:000047C0 var_4           = dword ptr -4
.text$mn:000047C0
.text$mn:000047C0                 push    ebp
.text$mn:000047C1                 mov     ebp, esp
.text$mn:000047C3                 push    0FFFFFFFFh
.text$mn:000047C5                 push    offset __ehhandler$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ
.text$mn:000047CA                 mov     eax, large fs:0
.text$mn:000047D0                 push    eax
.text$mn:000047D1                 sub     esp, 8
.text$mn:000047D4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000047D9                 xor     eax, ebp
.text$mn:000047DB                 push    eax
.text$mn:000047DC                 lea     eax, [ebp+var_C]
.text$mn:000047DF                 mov     large fs:0, eax
.text$mn:000047E5                 mov     [ebp+var_14], ecx
.text$mn:000047E8                 lea     ecx, [ebp+var_D]
.text$mn:000047EB                 call    ??0?$allocator@PAUHWND__@@@std@@QAE@XZ ; std::allocator<HWND__ *>::allocator<HWND__ *>(void)
.text$mn:000047F0                 push    eax
.text$mn:000047F1                 mov     ecx, [ebp+var_14]
.text$mn:000047F4                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>(std::allocator<HWND__ *> const &)
.text$mn:000047F9                 mov     [ebp+var_4], 0
.text$mn:00004800                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004807                 mov     eax, [ebp+var_14]
.text$mn:0000480A                 mov     ecx, [ebp+var_C]
.text$mn:0000480D                 mov     large fs:0, ecx
.text$mn:00004814                 pop     ecx
.text$mn:00004815                 mov     esp, ebp
.text$mn:00004817                 pop     ebp
.text$mn:00004818                 retn
.text$mn:00004818 ??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ endp
.text$mn:00004818
.text$mn:00004818 ; ---------------------------------------------------------------------------
.text$mn:00004819                 align 4
.text$mn:00004819 _text$mn        ends
.text$mn:00004819
.text$x:0000481C ; ===========================================================================
.text$x:0000481C
.text$x:0000481C ; Segment type: Pure code
.text$x:0000481C ; Segment permissions: Read/Execute
.text$x:0000481C _text$x         segment para public 'CODE' use32
.text$x:0000481C                 assume cs:_text$x
.text$x:0000481C                 ;org 481Ch
.text$x:0000481C ; COMDAT (pick associative to section at 47C0)
.text$x:0000481C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000481C
.text$x:0000481C ; =============== S U B R O U T I N E =======================================
.text$x:0000481C
.text$x:0000481C
.text$x:0000481C __unwindfunclet$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000481C                                         ; DATA XREF: .xdata$x:000094CCo
.text$x:0000481C                 mov     ecx, [ebp-14h]
.text$x:0000481F                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>(void)
.text$x:0000481F __unwindfunclet$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000481F
.text$x:00004824
.text$x:00004824 ; =============== S U B R O U T I N E =======================================
.text$x:00004824
.text$x:00004824
.text$x:00004824 __ehhandler$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ proc near
.text$x:00004824                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::vector<HWND__ *,std::allocator<HWND__ *>>(void)+5o
.text$x:00004824
.text$x:00004824 arg_4           = dword ptr  8
.text$x:00004824
.text$x:00004824                 mov     edx, [esp+arg_4]
.text$x:00004828                 lea     eax, [edx+0Ch]
.text$x:0000482B                 mov     ecx, [edx-0Ch]
.text$x:0000482E                 xor     ecx, eax
.text$x:00004830                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004835                 mov     eax, offset __ehfuncinfo$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ
.text$x:0000483A                 jmp     ___CxxFrameHandler3
.text$x:0000483A __ehhandler$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ endp
.text$x:0000483A
.text$x:0000483A ; ---------------------------------------------------------------------------
.text$x:0000483F                 align 10h
.text$x:0000483F _text$x         ends
.text$x:0000483F
.text$mn:00004840 ; ===========================================================================
.text$mn:00004840
.text$mn:00004840 ; Segment type: Pure code
.text$mn:00004840 ; Segment permissions: Read/Execute
.text$mn:00004840 _text$mn        segment para public 'CODE' use32
.text$mn:00004840                 assume cs:_text$mn
.text$mn:00004840                 ;org 4840h
.text$mn:00004840 ; COMDAT (pick any)
.text$mn:00004840                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004840
.text$mn:00004840 ; =============== S U B R O U T I N E =======================================
.text$mn:00004840
.text$mn:00004840 ; Attributes: bp-based frame
.text$mn:00004840
.text$mn:00004840 ; public: __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::vector<struct tTbData *, class std::allocator<struct tTbData *>>(class std::vector<struct tTbData *, class std::allocator<struct tTbData *>> const &)
.text$mn:00004840                 public ??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004840 ??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00004840                                         ; CODE XREF: DockingCont::getDataOfAllTb(void)+3Bp
.text$mn:00004840
.text$mn:00004840 var_34          = dword ptr -34h
.text$mn:00004840 var_30          = dword ptr -30h
.text$mn:00004840 var_2C          = dword ptr -2Ch
.text$mn:00004840 var_28          = dword ptr -28h
.text$mn:00004840 var_24          = dword ptr -24h
.text$mn:00004840 var_20          = dword ptr -20h
.text$mn:00004840 var_1C          = dword ptr -1Ch
.text$mn:00004840 var_18          = dword ptr -18h
.text$mn:00004840 var_12          = byte ptr -12h
.text$mn:00004840 var_11          = byte ptr -11h
.text$mn:00004840 var_10          = dword ptr -10h
.text$mn:00004840 var_C           = dword ptr -0Ch
.text$mn:00004840 var_4           = dword ptr -4
.text$mn:00004840 arg_0           = dword ptr  8
.text$mn:00004840
.text$mn:00004840 ; FUNCTION CHUNK AT .text$mn:0000492A SIZE 00000009 BYTES
.text$mn:00004840 ; FUNCTION CHUNK AT .text$mn:0000493A SIZE 0000001E BYTES
.text$mn:00004840
.text$mn:00004840                 push    ebp
.text$mn:00004841                 mov     ebp, esp
.text$mn:00004843                 push    0FFFFFFFFh
.text$mn:00004845                 push    offset __ehhandler$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000484A                 mov     eax, large fs:0
.text$mn:00004850                 push    eax
.text$mn:00004851                 push    ecx
.text$mn:00004852                 sub     esp, 24h
.text$mn:00004855                 push    ebx
.text$mn:00004856                 push    esi
.text$mn:00004857                 push    edi
.text$mn:00004858                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000485D                 xor     eax, ebp
.text$mn:0000485F                 push    eax
.text$mn:00004860                 lea     eax, [ebp+var_C]
.text$mn:00004863                 mov     large fs:0, eax
.text$mn:00004869                 mov     [ebp+var_10], esp
.text$mn:0000486C                 mov     [ebp+var_18], ecx
.text$mn:0000486F                 lea     eax, [ebp+var_11]
.text$mn:00004872                 push    eax
.text$mn:00004873                 lea     ecx, [ebp+var_12]
.text$mn:00004876                 push    ecx
.text$mn:00004877                 mov     ecx, [ebp+arg_0]
.text$mn:0000487A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Getal(void)
.text$mn:0000487F                 mov     ecx, eax
.text$mn:00004881                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<tTbData *>>::select_on_container_copy_construction(void)
.text$mn:00004886                 push    eax
.text$mn:00004887                 mov     ecx, [ebp+var_18]
.text$mn:0000488A                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>(std::allocator<tTbData *> const &)
.text$mn:0000488F                 mov     [ebp+var_4], 0
.text$mn:00004896                 mov     ecx, [ebp+arg_0]
.text$mn:00004899                 call    ?size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ ; std::vector<tTbData *,std::allocator<tTbData *>>::size(void)
.text$mn:0000489E                 push    eax
.text$mn:0000489F                 mov     ecx, [ebp+var_18]
.text$mn:000048A2                 call    ?_Buy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAE_NI@Z ; std::vector<tTbData *,std::allocator<tTbData *>>::_Buy(uint)
.text$mn:000048A7                 movzx   edx, al
.text$mn:000048AA                 test    edx, edx
.text$mn:000048AC                 jz      loc_493A
.text$mn:000048B2                 mov     byte ptr [ebp+var_4], 1
.text$mn:000048B6                 mov     eax, [ebp+var_18]
.text$mn:000048B9                 mov     ecx, [eax+4]
.text$mn:000048BC                 push    ecx
.text$mn:000048BD                 sub     esp, 0Ch
.text$mn:000048C0                 mov     edx, esp
.text$mn:000048C2                 mov     [ebp+var_28], esp
.text$mn:000048C5                 push    edx
.text$mn:000048C6                 mov     ecx, [ebp+arg_0]
.text$mn:000048C9                 call    ?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ ; std::vector<tTbData *,std::allocator<tTbData *>>::end(void)
.text$mn:000048CE                 mov     [ebp+var_1C], eax
.text$mn:000048D1                 mov     eax, [ebp+var_1C]
.text$mn:000048D4                 mov     [ebp+var_2C], eax
.text$mn:000048D7                 mov     byte ptr [ebp+var_4], 2
.text$mn:000048DB                 sub     esp, 0Ch
.text$mn:000048DE                 mov     ecx, esp
.text$mn:000048E0                 mov     [ebp+var_30], esp
.text$mn:000048E3                 push    ecx
.text$mn:000048E4                 mov     ecx, [ebp+arg_0]
.text$mn:000048E7                 call    ?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ ; std::vector<tTbData *,std::allocator<tTbData *>>::begin(void)
.text$mn:000048EC                 mov     [ebp+var_20], eax
.text$mn:000048EF                 mov     edx, [ebp+var_20]
.text$mn:000048F2                 mov     [ebp+var_34], edx
.text$mn:000048F5                 mov     byte ptr [ebp+var_4], 3
.text$mn:000048F9                 mov     byte ptr [ebp+var_4], 1
.text$mn:000048FD                 mov     ecx, [ebp+var_18]
.text$mn:00004900                 call    ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z ; std::vector<tTbData *,std::allocator<tTbData *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *)
.text$mn:00004905                 mov     [ebp+var_24], eax
.text$mn:00004908                 mov     eax, [ebp+var_18]
.text$mn:0000490B                 mov     ecx, [ebp+var_24]
.text$mn:0000490E                 mov     [eax+8], ecx
.text$mn:00004911                 jmp     short loc_492A
.text$mn:00004911 ??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004911
.text$mn:00004913
.text$mn:00004913 ; =============== S U B R O U T I N E =======================================
.text$mn:00004913
.text$mn:00004913 ; Attributes: noreturn
.text$mn:00004913
.text$mn:00004913 __catch$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$mn:00004913                                         ; DATA XREF: .xdata$x:00009178o
.text$mn:00004913                 mov     ecx, [ebp-18h]
.text$mn:00004916                 call    ?_Tidy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEXXZ ; std::vector<tTbData *,std::allocator<tTbData *>>::_Tidy(void)
.text$mn:0000491B                 push    0
.text$mn:0000491D                 push    0
.text$mn:0000491F                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000491F __catch$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$mn:0000491F
.text$mn:00004924 ; ---------------------------------------------------------------------------
.text$mn:00004924                 mov     eax, offset $LN11
.text$mn:00004929                 retn
.text$mn:0000492A ; ---------------------------------------------------------------------------
.text$mn:0000492A ; START OF FUNCTION CHUNK FOR ??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000492A
.text$mn:0000492A loc_492A:                               ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+D1j
.text$mn:0000492A                 mov     [ebp+var_4], 0
.text$mn:00004931                 jmp     short loc_493A
.text$mn:00004931 ; END OF FUNCTION CHUNK FOR ??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004933
.text$mn:00004933 ; =============== S U B R O U T I N E =======================================
.text$mn:00004933
.text$mn:00004933
.text$mn:00004933 $LN11           proc near               ; DATA XREF: .text$mn:00004924o
.text$mn:00004933                 mov     dword ptr [ebp-4], 0
.text$mn:00004933 $LN11           endp ; sp-analysis failed
.text$mn:00004933
.text$mn:0000493A ; START OF FUNCTION CHUNK FOR ??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000493A
.text$mn:0000493A loc_493A:                               ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+6Cj
.text$mn:0000493A                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+F1j
.text$mn:0000493A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004941                 mov     eax, [ebp+var_18]
.text$mn:00004944                 mov     ecx, [ebp+var_C]
.text$mn:00004947                 mov     large fs:0, ecx
.text$mn:0000494E                 pop     ecx
.text$mn:0000494F                 pop     edi
.text$mn:00004950                 pop     esi
.text$mn:00004951                 pop     ebx
.text$mn:00004952                 mov     esp, ebp
.text$mn:00004954                 pop     ebp
.text$mn:00004955                 retn    4
.text$mn:00004955 ; END OF FUNCTION CHUNK FOR ??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004955 _text$mn        ends
.text$mn:00004955
.text$x:00004958 ; ===========================================================================
.text$x:00004958
.text$x:00004958 ; Segment type: Pure code
.text$x:00004958 ; Segment permissions: Read/Execute
.text$x:00004958 _text$x         segment para public 'CODE' use32
.text$x:00004958                 assume cs:_text$x
.text$x:00004958                 ;org 4958h
.text$x:00004958 ; COMDAT (pick associative to section at 4840)
.text$x:00004958                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004958
.text$x:00004958 ; =============== S U B R O U T I N E =======================================
.text$x:00004958
.text$x:00004958
.text$x:00004958 __unwindfunclet$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$2 proc near
.text$x:00004958                                         ; DATA XREF: .xdata$x:000091B8o
.text$x:00004958                 mov     ecx, [ebp-18h]
.text$x:0000495B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::~_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>(void)
.text$x:0000495B __unwindfunclet$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$2 endp
.text$x:0000495B
.text$x:00004960
.text$x:00004960 ; =============== S U B R O U T I N E =======================================
.text$x:00004960
.text$x:00004960
.text$x:00004960 __unwindfunclet$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$3 proc near
.text$x:00004960                                         ; DATA XREF: .xdata$x:000091C8o
.text$x:00004960                 mov     ecx, [ebp-28h]
.text$x:00004963                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:00004963 __unwindfunclet$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$3 endp
.text$x:00004963
.text$x:00004968
.text$x:00004968 ; =============== S U B R O U T I N E =======================================
.text$x:00004968
.text$x:00004968
.text$x:00004968 __unwindfunclet$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$4 proc near
.text$x:00004968                                         ; DATA XREF: .xdata$x:000091D0o
.text$x:00004968                 mov     ecx, [ebp-30h]
.text$x:0000496B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:0000496B __unwindfunclet$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$4 endp
.text$x:0000496B
.text$x:00004970
.text$x:00004970 ; =============== S U B R O U T I N E =======================================
.text$x:00004970
.text$x:00004970
.text$x:00004970 __ehhandler$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00004970                                         ; DATA XREF: std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+5o
.text$x:00004970
.text$x:00004970 arg_4           = dword ptr  8
.text$x:00004970
.text$x:00004970                 mov     edx, [esp+arg_4]
.text$x:00004974                 lea     eax, [edx+0Ch]
.text$x:00004977                 mov     ecx, [edx-38h]
.text$x:0000497A                 xor     ecx, eax
.text$x:0000497C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004981                 mov     eax, offset __ehfuncinfo$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z
.text$x:00004986                 jmp     ___CxxFrameHandler3
.text$x:00004986 __ehhandler$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00004986
.text$x:00004986 ; ---------------------------------------------------------------------------
.text$x:0000498B                 align 4
.text$x:0000498B _text$x         ends
.text$x:0000498B
.text$mn:0000498C ; ===========================================================================
.text$mn:0000498C
.text$mn:0000498C ; Segment type: Pure code
.text$mn:0000498C ; Segment permissions: Read/Execute
.text$mn:0000498C _text$mn        segment para public 'CODE' use32
.text$mn:0000498C                 assume cs:_text$mn
.text$mn:0000498C                 ;org 498Ch
.text$mn:0000498C ; COMDAT (pick any)
.text$mn:0000498C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000498C
.text$mn:0000498C ; =============== S U B R O U T I N E =======================================
.text$mn:0000498C
.text$mn:0000498C ; Attributes: bp-based frame
.text$mn:0000498C
.text$mn:0000498C ; public: __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::vector<class DockingCont *, class std::allocator<class DockingCont *>>(void)
.text$mn:0000498C                 public ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:0000498C ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$mn:0000498C                                         ; CODE XREF: DockingManager::DockingManager(void)+55p
.text$mn:0000498C
.text$mn:0000498C var_14          = dword ptr -14h
.text$mn:0000498C var_D           = byte ptr -0Dh
.text$mn:0000498C var_C           = dword ptr -0Ch
.text$mn:0000498C var_4           = dword ptr -4
.text$mn:0000498C
.text$mn:0000498C                 push    ebp
.text$mn:0000498D                 mov     ebp, esp
.text$mn:0000498F                 push    0FFFFFFFFh
.text$mn:00004991                 push    offset __ehhandler$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:00004996                 mov     eax, large fs:0
.text$mn:0000499C                 push    eax
.text$mn:0000499D                 sub     esp, 8
.text$mn:000049A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000049A5                 xor     eax, ebp
.text$mn:000049A7                 push    eax
.text$mn:000049A8                 lea     eax, [ebp+var_C]
.text$mn:000049AB                 mov     large fs:0, eax
.text$mn:000049B1                 mov     [ebp+var_14], ecx
.text$mn:000049B4                 lea     ecx, [ebp+var_D]
.text$mn:000049B7                 call    ??0?$allocator@PAVDockingCont@@@std@@QAE@XZ ; std::allocator<DockingCont *>::allocator<DockingCont *>(void)
.text$mn:000049BC                 push    eax
.text$mn:000049BD                 mov     ecx, [ebp+var_14]
.text$mn:000049C0                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(std::allocator<DockingCont *> const &)
.text$mn:000049C5                 mov     [ebp+var_4], 0
.text$mn:000049CC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000049D3                 mov     eax, [ebp+var_14]
.text$mn:000049D6                 mov     ecx, [ebp+var_C]
.text$mn:000049D9                 mov     large fs:0, ecx
.text$mn:000049E0                 pop     ecx
.text$mn:000049E1                 mov     esp, ebp
.text$mn:000049E3                 pop     ebp
.text$mn:000049E4                 retn
.text$mn:000049E4 ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$mn:000049E4
.text$mn:000049E4 ; ---------------------------------------------------------------------------
.text$mn:000049E5                 align 4
.text$mn:000049E5 _text$mn        ends
.text$mn:000049E5
.text$x:000049E8 ; ===========================================================================
.text$x:000049E8
.text$x:000049E8 ; Segment type: Pure code
.text$x:000049E8 ; Segment permissions: Read/Execute
.text$x:000049E8 _text$x         segment para public 'CODE' use32
.text$x:000049E8                 assume cs:_text$x
.text$x:000049E8                 ;org 49E8h
.text$x:000049E8 ; COMDAT (pick associative to section at 498C)
.text$x:000049E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000049E8
.text$x:000049E8 ; =============== S U B R O U T I N E =======================================
.text$x:000049E8
.text$x:000049E8
.text$x:000049E8 __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000049E8                                         ; DATA XREF: .xdata$x:00009658o
.text$x:000049E8                 mov     ecx, [ebp-14h]
.text$x:000049EB                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)
.text$x:000049EB __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ$0 endp
.text$x:000049EB
.text$x:000049F0
.text$x:000049F0 ; =============== S U B R O U T I N E =======================================
.text$x:000049F0
.text$x:000049F0
.text$x:000049F0 __ehhandler$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$x:000049F0                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(void)+5o
.text$x:000049F0
.text$x:000049F0 arg_4           = dword ptr  8
.text$x:000049F0
.text$x:000049F0                 mov     edx, [esp+arg_4]
.text$x:000049F4                 lea     eax, [edx+0Ch]
.text$x:000049F7                 mov     ecx, [edx-0Ch]
.text$x:000049FA                 xor     ecx, eax
.text$x:000049FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A01                 mov     eax, offset __ehfuncinfo$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$x:00004A06                 jmp     ___CxxFrameHandler3
.text$x:00004A06 __ehhandler$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$x:00004A06
.text$x:00004A06 ; ---------------------------------------------------------------------------
.text$x:00004A0B                 align 4
.text$x:00004A0B _text$x         ends
.text$x:00004A0B
.text$mn:00004A0C ; ===========================================================================
.text$mn:00004A0C
.text$mn:00004A0C ; Segment type: Pure code
.text$mn:00004A0C ; Segment permissions: Read/Execute
.text$mn:00004A0C _text$mn        segment para public 'CODE' use32
.text$mn:00004A0C                 assume cs:_text$mn
.text$mn:00004A0C                 ;org 4A0Ch
.text$mn:00004A0C ; COMDAT (pick any)
.text$mn:00004A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A0C
.text$mn:00004A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00004A0C
.text$mn:00004A0C ; Attributes: bp-based frame
.text$mn:00004A0C
.text$mn:00004A0C ; public: __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>(void)
.text$mn:00004A0C                 public ??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$mn:00004A0C ??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ proc near
.text$mn:00004A0C                                         ; CODE XREF: DockingManager::DockingManager(void)+67p
.text$mn:00004A0C
.text$mn:00004A0C var_14          = dword ptr -14h
.text$mn:00004A0C var_D           = byte ptr -0Dh
.text$mn:00004A0C var_C           = dword ptr -0Ch
.text$mn:00004A0C var_4           = dword ptr -4
.text$mn:00004A0C
.text$mn:00004A0C                 push    ebp
.text$mn:00004A0D                 mov     ebp, esp
.text$mn:00004A0F                 push    0FFFFFFFFh
.text$mn:00004A11                 push    offset __ehhandler$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$mn:00004A16                 mov     eax, large fs:0
.text$mn:00004A1C                 push    eax
.text$mn:00004A1D                 sub     esp, 8
.text$mn:00004A20                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004A25                 xor     eax, ebp
.text$mn:00004A27                 push    eax
.text$mn:00004A28                 lea     eax, [ebp+var_C]
.text$mn:00004A2B                 mov     large fs:0, eax
.text$mn:00004A31                 mov     [ebp+var_14], ecx
.text$mn:00004A34                 lea     ecx, [ebp+var_D]
.text$mn:00004A37                 call    ??0?$allocator@PAVDockingSplitter@@@std@@QAE@XZ ; std::allocator<DockingSplitter *>::allocator<DockingSplitter *>(void)
.text$mn:00004A3C                 push    eax
.text$mn:00004A3D                 mov     ecx, [ebp+var_14]
.text$mn:00004A40                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>(std::allocator<DockingSplitter *> const &)
.text$mn:00004A45                 mov     [ebp+var_4], 0
.text$mn:00004A4C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004A53                 mov     eax, [ebp+var_14]
.text$mn:00004A56                 mov     ecx, [ebp+var_C]
.text$mn:00004A59                 mov     large fs:0, ecx
.text$mn:00004A60                 pop     ecx
.text$mn:00004A61                 mov     esp, ebp
.text$mn:00004A63                 pop     ebp
.text$mn:00004A64                 retn
.text$mn:00004A64 ??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ endp
.text$mn:00004A64
.text$mn:00004A64 ; ---------------------------------------------------------------------------
.text$mn:00004A65                 align 4
.text$mn:00004A65 _text$mn        ends
.text$mn:00004A65
.text$x:00004A68 ; ===========================================================================
.text$x:00004A68
.text$x:00004A68 ; Segment type: Pure code
.text$x:00004A68 ; Segment permissions: Read/Execute
.text$x:00004A68 _text$x         segment para public 'CODE' use32
.text$x:00004A68                 assume cs:_text$x
.text$x:00004A68                 ;org 4A68h
.text$x:00004A68 ; COMDAT (pick associative to section at 4A0C)
.text$x:00004A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004A68
.text$x:00004A68 ; =============== S U B R O U T I N E =======================================
.text$x:00004A68
.text$x:00004A68
.text$x:00004A68 __unwindfunclet$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004A68                                         ; DATA XREF: .xdata$x:000097E4o
.text$x:00004A68                 mov     ecx, [ebp-14h]
.text$x:00004A6B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>(void)
.text$x:00004A6B __unwindfunclet$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0 endp
.text$x:00004A6B
.text$x:00004A70
.text$x:00004A70 ; =============== S U B R O U T I N E =======================================
.text$x:00004A70
.text$x:00004A70
.text$x:00004A70 __ehhandler$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ proc near
.text$x:00004A70                                         ; DATA XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::vector<DockingSplitter *,std::allocator<DockingSplitter *>>(void)+5o
.text$x:00004A70
.text$x:00004A70 arg_4           = dword ptr  8
.text$x:00004A70
.text$x:00004A70                 mov     edx, [esp+arg_4]
.text$x:00004A74                 lea     eax, [edx+0Ch]
.text$x:00004A77                 mov     ecx, [edx-0Ch]
.text$x:00004A7A                 xor     ecx, eax
.text$x:00004A7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A81                 mov     eax, offset __ehfuncinfo$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$x:00004A86                 jmp     ___CxxFrameHandler3
.text$x:00004A86 __ehhandler$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ endp
.text$x:00004A86
.text$x:00004A86 ; ---------------------------------------------------------------------------
.text$x:00004A8B                 align 4
.text$x:00004A8B _text$x         ends
.text$x:00004A8B
.text$mn:00004A8C ; ===========================================================================
.text$mn:00004A8C
.text$mn:00004A8C ; Segment type: Pure code
.text$mn:00004A8C ; Segment permissions: Read/Execute
.text$mn:00004A8C _text$mn        segment para public 'CODE' use32
.text$mn:00004A8C                 assume cs:_text$mn
.text$mn:00004A8C                 ;org 4A8Ch
.text$mn:00004A8C ; COMDAT (pick any)
.text$mn:00004A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A8C
.text$mn:00004A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00004A8C
.text$mn:00004A8C ; Attributes: bp-based frame
.text$mn:00004A8C
.text$mn:00004A8C ; public: __thiscall DockingSplitter::DockingSplitter(void)
.text$mn:00004A8C                 public ??0DockingSplitter@@QAE@XZ
.text$mn:00004A8C ??0DockingSplitter@@QAE@XZ proc near    ; CODE XREF: DockingManager::DockingManager(void)+179p
.text$mn:00004A8C
.text$mn:00004A8C var_10          = dword ptr -10h
.text$mn:00004A8C var_C           = dword ptr -0Ch
.text$mn:00004A8C var_4           = dword ptr -4
.text$mn:00004A8C
.text$mn:00004A8C                 push    ebp
.text$mn:00004A8D                 mov     ebp, esp
.text$mn:00004A8F                 push    0FFFFFFFFh
.text$mn:00004A91                 push    offset __ehhandler$??0DockingSplitter@@QAE@XZ
.text$mn:00004A96                 mov     eax, large fs:0
.text$mn:00004A9C                 push    eax
.text$mn:00004A9D                 push    ecx
.text$mn:00004A9E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004AA3                 xor     eax, ebp
.text$mn:00004AA5                 push    eax
.text$mn:00004AA6                 lea     eax, [ebp+var_C]
.text$mn:00004AA9                 mov     large fs:0, eax
.text$mn:00004AAF                 mov     [ebp+var_10], ecx
.text$mn:00004AB2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004AB5                 call    ??0Window@@QAE@XZ ; Window::Window(void)
.text$mn:00004ABA                 mov     [ebp+var_4], 0
.text$mn:00004AC1                 mov     eax, [ebp+var_10]
.text$mn:00004AC4                 mov     dword ptr [eax], offset ??_7DockingSplitter@@6B@ ; const DockingSplitter::`vftable'
.text$mn:00004ACA                 mov     ecx, [ebp+var_10]
.text$mn:00004ACD                 mov     dword ptr [ecx+10h], 0
.text$mn:00004AD4                 mov     edx, [ebp+var_10]
.text$mn:00004AD7                 mov     dword ptr [edx+14h], 0
.text$mn:00004ADE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004AE5                 mov     eax, [ebp+var_10]
.text$mn:00004AE8                 mov     ecx, [ebp+var_C]
.text$mn:00004AEB                 mov     large fs:0, ecx
.text$mn:00004AF2                 pop     ecx
.text$mn:00004AF3                 mov     esp, ebp
.text$mn:00004AF5                 pop     ebp
.text$mn:00004AF6                 retn
.text$mn:00004AF6 ??0DockingSplitter@@QAE@XZ endp
.text$mn:00004AF6
.text$mn:00004AF6 ; ---------------------------------------------------------------------------
.text$mn:00004AF7                 align 4
.text$mn:00004AF7 _text$mn        ends
.text$mn:00004AF7
.text$x:00004AF8 ; ===========================================================================
.text$x:00004AF8
.text$x:00004AF8 ; Segment type: Pure code
.text$x:00004AF8 ; Segment permissions: Read/Execute
.text$x:00004AF8 _text$x         segment para public 'CODE' use32
.text$x:00004AF8                 assume cs:_text$x
.text$x:00004AF8                 ;org 4AF8h
.text$x:00004AF8 ; COMDAT (pick associative to section at 4A8C)
.text$x:00004AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004AF8
.text$x:00004AF8 ; =============== S U B R O U T I N E =======================================
.text$x:00004AF8
.text$x:00004AF8
.text$x:00004AF8 __unwindfunclet$??0DockingSplitter@@QAE@XZ$0 proc near
.text$x:00004AF8                                         ; DATA XREF: .xdata$x:000098C0o
.text$x:00004AF8                 mov     ecx, [ebp-10h]  ; this
.text$x:00004AFB                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:00004AFB __unwindfunclet$??0DockingSplitter@@QAE@XZ$0 endp
.text$x:00004AFB
.text$x:00004B00
.text$x:00004B00 ; =============== S U B R O U T I N E =======================================
.text$x:00004B00
.text$x:00004B00
.text$x:00004B00 __ehhandler$??0DockingSplitter@@QAE@XZ proc near
.text$x:00004B00                                         ; DATA XREF: DockingSplitter::DockingSplitter(void)+5o
.text$x:00004B00
.text$x:00004B00 arg_4           = dword ptr  8
.text$x:00004B00
.text$x:00004B00                 mov     edx, [esp+arg_4]
.text$x:00004B04                 lea     eax, [edx+0Ch]
.text$x:00004B07                 mov     ecx, [edx-8]
.text$x:00004B0A                 xor     ecx, eax
.text$x:00004B0C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004B11                 mov     eax, offset __ehfuncinfo$??0DockingSplitter@@QAE@XZ
.text$x:00004B16                 jmp     ___CxxFrameHandler3
.text$x:00004B16 __ehhandler$??0DockingSplitter@@QAE@XZ endp
.text$x:00004B16
.text$x:00004B16 ; ---------------------------------------------------------------------------
.text$x:00004B1B                 align 4
.text$x:00004B1B _text$x         ends
.text$x:00004B1B
.text$mn:00004B1C ; ===========================================================================
.text$mn:00004B1C
.text$mn:00004B1C ; Segment type: Pure code
.text$mn:00004B1C ; Segment permissions: Read/Execute
.text$mn:00004B1C _text$mn        segment para public 'CODE' use32
.text$mn:00004B1C                 assume cs:_text$mn
.text$mn:00004B1C                 ;org 4B1Ch
.text$mn:00004B1C ; COMDAT (pick any)
.text$mn:00004B1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B1C
.text$mn:00004B1C ; =============== S U B R O U T I N E =======================================
.text$mn:00004B1C
.text$mn:00004B1C ; Attributes: bp-based frame
.text$mn:00004B1C
.text$mn:00004B1C ; _DWORD __thiscall Window::Window(Window *__hidden this)
.text$mn:00004B1C                 public ??0Window@@QAE@XZ
.text$mn:00004B1C ??0Window@@QAE@XZ proc near             ; CODE XREF: DockingManager::DockingManager(void)+2Bp
.text$mn:00004B1C                                         ; DockingSplitter::DockingSplitter(void)+29p
.text$mn:00004B1C
.text$mn:00004B1C var_4           = dword ptr -4
.text$mn:00004B1C
.text$mn:00004B1C                 push    ebp
.text$mn:00004B1D                 mov     ebp, esp
.text$mn:00004B1F                 push    ecx
.text$mn:00004B20                 mov     [ebp+var_4], ecx
.text$mn:00004B23                 mov     eax, [ebp+var_4]
.text$mn:00004B26                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00004B2C                 mov     ecx, [ebp+var_4]
.text$mn:00004B2F                 mov     dword ptr [ecx+4], 0
.text$mn:00004B36                 mov     edx, [ebp+var_4]
.text$mn:00004B39                 mov     dword ptr [edx+8], 0
.text$mn:00004B40                 mov     eax, [ebp+var_4]
.text$mn:00004B43                 mov     dword ptr [eax+0Ch], 0
.text$mn:00004B4A                 mov     eax, [ebp+var_4]
.text$mn:00004B4D                 mov     esp, ebp
.text$mn:00004B4F                 pop     ebp
.text$mn:00004B50                 retn
.text$mn:00004B50 ??0Window@@QAE@XZ endp
.text$mn:00004B50
.text$mn:00004B50 ; ---------------------------------------------------------------------------
.text$mn:00004B51                 align 4
.text$mn:00004B51 _text$mn        ends
.text$mn:00004B51
.text$mn:00004B54 ; ===========================================================================
.text$mn:00004B54
.text$mn:00004B54 ; Segment type: Pure code
.text$mn:00004B54 ; Segment permissions: Read/Execute
.text$mn:00004B54 _text$mn        segment para public 'CODE' use32
.text$mn:00004B54                 assume cs:_text$mn
.text$mn:00004B54                 ;org 4B54h
.text$mn:00004B54 ; COMDAT (pick any)
.text$mn:00004B54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B54
.text$mn:00004B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B54
.text$mn:00004B54 ; Attributes: bp-based frame
.text$mn:00004B54
.text$mn:00004B54 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00004B54                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00004B54 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00004B54                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00004B54                                         ; std::_Vector_val<std::_Simple_types<HWND__ *>>::_Vector_val<std::_Simple_types<HWND__ *>>(void)+29p ...
.text$mn:00004B54
.text$mn:00004B54 var_4           = dword ptr -4
.text$mn:00004B54
.text$mn:00004B54                 push    ebp
.text$mn:00004B55                 mov     ebp, esp
.text$mn:00004B57                 push    ecx
.text$mn:00004B58                 mov     [ebp+var_4], ecx
.text$mn:00004B5B                 mov     eax, [ebp+var_4]
.text$mn:00004B5E                 mov     dword ptr [eax], 0
.text$mn:00004B64                 mov     eax, [ebp+var_4]
.text$mn:00004B67                 mov     esp, ebp
.text$mn:00004B69                 pop     ebp
.text$mn:00004B6A                 retn
.text$mn:00004B6A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00004B6A
.text$mn:00004B6A ; ---------------------------------------------------------------------------
.text$mn:00004B6B                 align 4
.text$mn:00004B6B _text$mn        ends
.text$mn:00004B6B
.text$mn:00004B6C ; ===========================================================================
.text$mn:00004B6C
.text$mn:00004B6C ; Segment type: Pure code
.text$mn:00004B6C ; Segment permissions: Read/Execute
.text$mn:00004B6C _text$mn        segment para public 'CODE' use32
.text$mn:00004B6C                 assume cs:_text$mn
.text$mn:00004B6C                 ;org 4B6Ch
.text$mn:00004B6C ; COMDAT (pick any)
.text$mn:00004B6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B6C
.text$mn:00004B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00004B6C
.text$mn:00004B6C ; Attributes: bp-based frame
.text$mn:00004B6C
.text$mn:00004B6C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00004B6C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00004B6C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00004B6C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00004B6C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Alloc_proxy(void)+23p ...
.text$mn:00004B6C
.text$mn:00004B6C var_4           = dword ptr -4
.text$mn:00004B6C
.text$mn:00004B6C                 push    ebp
.text$mn:00004B6D                 mov     ebp, esp
.text$mn:00004B6F                 push    ecx
.text$mn:00004B70                 mov     [ebp+var_4], ecx
.text$mn:00004B73                 mov     eax, [ebp+var_4]
.text$mn:00004B76                 mov     dword ptr [eax], 0
.text$mn:00004B7C                 mov     ecx, [ebp+var_4]
.text$mn:00004B7F                 mov     dword ptr [ecx+4], 0
.text$mn:00004B86                 mov     eax, [ebp+var_4]
.text$mn:00004B89                 mov     esp, ebp
.text$mn:00004B8B                 pop     ebp
.text$mn:00004B8C                 retn
.text$mn:00004B8C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00004B8C
.text$mn:00004B8C ; ---------------------------------------------------------------------------
.text$mn:00004B8D                 align 10h
.text$mn:00004B8D _text$mn        ends
.text$mn:00004B8D
.text$mn:00004B90 ; ===========================================================================
.text$mn:00004B90
.text$mn:00004B90 ; Segment type: Pure code
.text$mn:00004B90 ; Segment permissions: Read/Execute
.text$mn:00004B90 _text$mn        segment para public 'CODE' use32
.text$mn:00004B90                 assume cs:_text$mn
.text$mn:00004B90                 ;org 4B90h
.text$mn:00004B90 ; COMDAT (pick any)
.text$mn:00004B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B90
.text$mn:00004B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B90
.text$mn:00004B90 ; Attributes: bp-based frame
.text$mn:00004B90
.text$mn:00004B90 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00004B90                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00004B90 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00004B90                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00004B90                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00004B90
.text$mn:00004B90 var_10          = dword ptr -10h
.text$mn:00004B90 var_C           = dword ptr -0Ch
.text$mn:00004B90 var_4           = dword ptr -4
.text$mn:00004B90
.text$mn:00004B90                 push    ebp
.text$mn:00004B91                 mov     ebp, esp
.text$mn:00004B93                 push    0FFFFFFFFh
.text$mn:00004B95                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00004B9A                 mov     eax, large fs:0
.text$mn:00004BA0                 push    eax
.text$mn:00004BA1                 push    ecx
.text$mn:00004BA2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004BA7                 xor     eax, ebp
.text$mn:00004BA9                 push    eax
.text$mn:00004BAA                 lea     eax, [ebp+var_C]
.text$mn:00004BAD                 mov     large fs:0, eax
.text$mn:00004BB3                 mov     [ebp+var_10], ecx
.text$mn:00004BB6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004BB9                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00004BBE                 mov     [ebp+var_4], 0
.text$mn:00004BC5                 mov     eax, [ebp+var_10]
.text$mn:00004BC8                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00004BCE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004BD5                 mov     eax, [ebp+var_10]
.text$mn:00004BD8                 mov     ecx, [ebp+var_C]
.text$mn:00004BDB                 mov     large fs:0, ecx
.text$mn:00004BE2                 pop     ecx
.text$mn:00004BE3                 mov     esp, ebp
.text$mn:00004BE5                 pop     ebp
.text$mn:00004BE6                 retn
.text$mn:00004BE6 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00004BE6
.text$mn:00004BE6 ; ---------------------------------------------------------------------------
.text$mn:00004BE7                 align 4
.text$mn:00004BE7 _text$mn        ends
.text$mn:00004BE7
.text$x:00004BE8 ; ===========================================================================
.text$x:00004BE8
.text$x:00004BE8 ; Segment type: Pure code
.text$x:00004BE8 ; Segment permissions: Read/Execute
.text$x:00004BE8 _text$x         segment para public 'CODE' use32
.text$x:00004BE8                 assume cs:_text$x
.text$x:00004BE8                 ;org 4BE8h
.text$x:00004BE8 ; COMDAT (pick associative to section at 4B90)
.text$x:00004BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004BE8
.text$x:00004BE8 ; =============== S U B R O U T I N E =======================================
.text$x:00004BE8
.text$x:00004BE8
.text$x:00004BE8 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00004BE8                                         ; DATA XREF: .xdata$x:00008F08o
.text$x:00004BE8                 mov     ecx, [ebp-10h]  ; this
.text$x:00004BEB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00004BEB __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00004BEB
.text$x:00004BF0
.text$x:00004BF0 ; =============== S U B R O U T I N E =======================================
.text$x:00004BF0
.text$x:00004BF0
.text$x:00004BF0 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00004BF0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00004BF0
.text$x:00004BF0 arg_4           = dword ptr  8
.text$x:00004BF0
.text$x:00004BF0                 mov     edx, [esp+arg_4]
.text$x:00004BF4                 lea     eax, [edx+0Ch]
.text$x:00004BF7                 mov     ecx, [edx-8]
.text$x:00004BFA                 xor     ecx, eax
.text$x:00004BFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004C01                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00004C06                 jmp     ___CxxFrameHandler3
.text$x:00004C06 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00004C06
.text$x:00004C06 ; ---------------------------------------------------------------------------
.text$x:00004C0B                 align 4
.text$x:00004C0B _text$x         ends
.text$x:00004C0B
.text$mn:00004C0C ; ===========================================================================
.text$mn:00004C0C
.text$mn:00004C0C ; Segment type: Pure code
.text$mn:00004C0C ; Segment permissions: Read/Execute
.text$mn:00004C0C _text$mn        segment para public 'CODE' use32
.text$mn:00004C0C                 assume cs:_text$mn
.text$mn:00004C0C                 ;org 4C0Ch
.text$mn:00004C0C ; COMDAT (pick any)
.text$mn:00004C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C0C
.text$mn:00004C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00004C0C
.text$mn:00004C0C ; Attributes: bp-based frame
.text$mn:00004C0C
.text$mn:00004C0C ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00004C0C                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00004C0C ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00004C0C                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00004C0C
.text$mn:00004C0C var_10          = dword ptr -10h
.text$mn:00004C0C var_C           = dword ptr -0Ch
.text$mn:00004C0C var_4           = dword ptr -4
.text$mn:00004C0C
.text$mn:00004C0C                 push    ebp
.text$mn:00004C0D                 mov     ebp, esp
.text$mn:00004C0F                 push    0FFFFFFFFh
.text$mn:00004C11                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00004C16                 mov     eax, large fs:0
.text$mn:00004C1C                 push    eax
.text$mn:00004C1D                 push    ecx
.text$mn:00004C1E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004C23                 xor     eax, ebp
.text$mn:00004C25                 push    eax
.text$mn:00004C26                 lea     eax, [ebp+var_C]
.text$mn:00004C29                 mov     large fs:0, eax
.text$mn:00004C2F                 mov     [ebp+var_10], ecx
.text$mn:00004C32                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004C35                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00004C3A                 mov     [ebp+var_4], 0
.text$mn:00004C41                 mov     eax, [ebp+var_10]
.text$mn:00004C44                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00004C4A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004C51                 mov     eax, [ebp+var_10]
.text$mn:00004C54                 mov     ecx, [ebp+var_C]
.text$mn:00004C57                 mov     large fs:0, ecx
.text$mn:00004C5E                 pop     ecx
.text$mn:00004C5F                 mov     esp, ebp
.text$mn:00004C61                 pop     ebp
.text$mn:00004C62                 retn
.text$mn:00004C62 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00004C62
.text$mn:00004C62 ; ---------------------------------------------------------------------------
.text$mn:00004C63                 align 4
.text$mn:00004C63 _text$mn        ends
.text$mn:00004C63
.text$x:00004C64 ; ===========================================================================
.text$x:00004C64
.text$x:00004C64 ; Segment type: Pure code
.text$x:00004C64 ; Segment permissions: Read/Execute
.text$x:00004C64 _text$x         segment para public 'CODE' use32
.text$x:00004C64                 assume cs:_text$x
.text$x:00004C64                 ;org 4C64h
.text$x:00004C64 ; COMDAT (pick associative to section at 4C0C)
.text$x:00004C64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004C64
.text$x:00004C64 ; =============== S U B R O U T I N E =======================================
.text$x:00004C64
.text$x:00004C64
.text$x:00004C64 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00004C64                                         ; DATA XREF: .xdata$x:00008F8Co
.text$x:00004C64                 mov     ecx, [ebp-10h]  ; this
.text$x:00004C67                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00004C67 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00004C67
.text$x:00004C6C
.text$x:00004C6C ; =============== S U B R O U T I N E =======================================
.text$x:00004C6C
.text$x:00004C6C
.text$x:00004C6C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00004C6C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00004C6C
.text$x:00004C6C arg_4           = dword ptr  8
.text$x:00004C6C
.text$x:00004C6C                 mov     edx, [esp+arg_4]
.text$x:00004C70                 lea     eax, [edx+0Ch]
.text$x:00004C73                 mov     ecx, [edx-8]
.text$x:00004C76                 xor     ecx, eax
.text$x:00004C78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004C7D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00004C82                 jmp     ___CxxFrameHandler3
.text$x:00004C82 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00004C82
.text$x:00004C82 ; ---------------------------------------------------------------------------
.text$x:00004C87                 align 4
.text$x:00004C87 _text$x         ends
.text$x:00004C87
.text$mn:00004C88 ; ===========================================================================
.text$mn:00004C88
.text$mn:00004C88 ; Segment type: Pure code
.text$mn:00004C88 ; Segment permissions: Read/Execute
.text$mn:00004C88 _text$mn        segment para public 'CODE' use32
.text$mn:00004C88                 assume cs:_text$mn
.text$mn:00004C88                 ;org 4C88h
.text$mn:00004C88 ; COMDAT (pick any)
.text$mn:00004C88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C88
.text$mn:00004C88 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C88
.text$mn:00004C88 ; Attributes: bp-based frame
.text$mn:00004C88
.text$mn:00004C88 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00004C88                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00004C88 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00004C88                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00004C88
.text$mn:00004C88 var_4           = dword ptr -4
.text$mn:00004C88 arg_0           = dword ptr  8
.text$mn:00004C88
.text$mn:00004C88                 push    ebp
.text$mn:00004C89                 mov     ebp, esp
.text$mn:00004C8B                 push    ecx
.text$mn:00004C8C                 mov     [ebp+var_4], ecx
.text$mn:00004C8F                 mov     eax, [ebp+var_4]
.text$mn:00004C92                 mov     dword ptr [eax], 0
.text$mn:00004C98                 mov     ecx, [ebp+var_4]
.text$mn:00004C9B                 mov     dword ptr [ecx+4], 0
.text$mn:00004CA2                 mov     edx, [ebp+arg_0]
.text$mn:00004CA5                 push    edx
.text$mn:00004CA6                 mov     ecx, [ebp+var_4]
.text$mn:00004CA9                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00004CAE                 mov     eax, [ebp+var_4]
.text$mn:00004CB1                 mov     esp, ebp
.text$mn:00004CB3                 pop     ebp
.text$mn:00004CB4                 retn    4
.text$mn:00004CB4 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00004CB4
.text$mn:00004CB4 ; ---------------------------------------------------------------------------
.text$mn:00004CB7                 align 4
.text$mn:00004CB7 _text$mn        ends
.text$mn:00004CB7
.text$mn:00004CB8 ; ===========================================================================
.text$mn:00004CB8
.text$mn:00004CB8 ; Segment type: Pure code
.text$mn:00004CB8 ; Segment permissions: Read/Execute
.text$mn:00004CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00004CB8                 assume cs:_text$mn
.text$mn:00004CB8                 ;org 4CB8h
.text$mn:00004CB8 ; COMDAT (pick any)
.text$mn:00004CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CB8
.text$mn:00004CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CB8
.text$mn:00004CB8 ; Attributes: bp-based frame
.text$mn:00004CB8
.text$mn:00004CB8 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00004CB8                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00004CB8 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00004CB8                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(void)+29p
.text$mn:00004CB8
.text$mn:00004CB8 var_4           = dword ptr -4
.text$mn:00004CB8
.text$mn:00004CB8                 push    ebp
.text$mn:00004CB9                 mov     ebp, esp
.text$mn:00004CBB                 push    ecx
.text$mn:00004CBC                 mov     [ebp+var_4], ecx
.text$mn:00004CBF                 mov     eax, [ebp+var_4]
.text$mn:00004CC2                 mov     dword ptr [eax], 0
.text$mn:00004CC8                 mov     ecx, [ebp+var_4]
.text$mn:00004CCB                 mov     dword ptr [ecx+4], 0
.text$mn:00004CD2                 mov     eax, [ebp+var_4]
.text$mn:00004CD5                 mov     esp, ebp
.text$mn:00004CD7                 pop     ebp
.text$mn:00004CD8                 retn
.text$mn:00004CD8 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00004CD8
.text$mn:00004CD8 ; ---------------------------------------------------------------------------
.text$mn:00004CD9                 align 4
.text$mn:00004CD9 _text$mn        ends
.text$mn:00004CD9
.text$mn:00004CDC ; ===========================================================================
.text$mn:00004CDC
.text$mn:00004CDC ; Segment type: Pure code
.text$mn:00004CDC ; Segment permissions: Read/Execute
.text$mn:00004CDC _text$mn        segment para public 'CODE' use32
.text$mn:00004CDC                 assume cs:_text$mn
.text$mn:00004CDC                 ;org 4CDCh
.text$mn:00004CDC ; COMDAT (pick any)
.text$mn:00004CDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CDC
.text$mn:00004CDC ; =============== S U B R O U T I N E =======================================
.text$mn:00004CDC
.text$mn:00004CDC ; Attributes: bp-based frame
.text$mn:00004CDC
.text$mn:00004CDC ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00004CDC                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00004CDC ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00004CDC                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00004CDC
.text$mn:00004CDC var_10          = dword ptr -10h
.text$mn:00004CDC var_C           = dword ptr -0Ch
.text$mn:00004CDC var_4           = dword ptr -4
.text$mn:00004CDC
.text$mn:00004CDC                 push    ebp
.text$mn:00004CDD                 mov     ebp, esp
.text$mn:00004CDF                 push    0FFFFFFFFh
.text$mn:00004CE1                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00004CE6                 mov     eax, large fs:0
.text$mn:00004CEC                 push    eax
.text$mn:00004CED                 push    ecx
.text$mn:00004CEE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004CF3                 xor     eax, ebp
.text$mn:00004CF5                 push    eax
.text$mn:00004CF6                 lea     eax, [ebp+var_C]
.text$mn:00004CF9                 mov     large fs:0, eax
.text$mn:00004CFF                 mov     [ebp+var_10], ecx
.text$mn:00004D02                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004D05                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00004D0A                 mov     [ebp+var_4], 0
.text$mn:00004D11                 mov     eax, [ebp+var_10]
.text$mn:00004D14                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00004D1A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D21                 mov     eax, [ebp+var_10]
.text$mn:00004D24                 mov     ecx, [ebp+var_C]
.text$mn:00004D27                 mov     large fs:0, ecx
.text$mn:00004D2E                 pop     ecx
.text$mn:00004D2F                 mov     esp, ebp
.text$mn:00004D31                 pop     ebp
.text$mn:00004D32                 retn
.text$mn:00004D32 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00004D32
.text$mn:00004D32 ; ---------------------------------------------------------------------------
.text$mn:00004D33                 align 4
.text$mn:00004D33 _text$mn        ends
.text$mn:00004D33
.text$x:00004D34 ; ===========================================================================
.text$x:00004D34
.text$x:00004D34 ; Segment type: Pure code
.text$x:00004D34 ; Segment permissions: Read/Execute
.text$x:00004D34 _text$x         segment para public 'CODE' use32
.text$x:00004D34                 assume cs:_text$x
.text$x:00004D34                 ;org 4D34h
.text$x:00004D34 ; COMDAT (pick associative to section at 4CDC)
.text$x:00004D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004D34
.text$x:00004D34 ; =============== S U B R O U T I N E =======================================
.text$x:00004D34
.text$x:00004D34
.text$x:00004D34 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00004D34                                         ; DATA XREF: .xdata$x:00009010o
.text$x:00004D34                 mov     ecx, [ebp-10h]  ; this
.text$x:00004D37                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00004D37 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00004D37
.text$x:00004D3C
.text$x:00004D3C ; =============== S U B R O U T I N E =======================================
.text$x:00004D3C
.text$x:00004D3C
.text$x:00004D3C __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00004D3C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00004D3C
.text$x:00004D3C arg_4           = dword ptr  8
.text$x:00004D3C
.text$x:00004D3C                 mov     edx, [esp+arg_4]
.text$x:00004D40                 lea     eax, [edx+0Ch]
.text$x:00004D43                 mov     ecx, [edx-8]
.text$x:00004D46                 xor     ecx, eax
.text$x:00004D48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004D4D                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00004D52                 jmp     ___CxxFrameHandler3
.text$x:00004D52 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00004D52
.text$x:00004D52 ; ---------------------------------------------------------------------------
.text$x:00004D57                 align 4
.text$x:00004D57 _text$x         ends
.text$x:00004D57
.text$mn:00004D58 ; ===========================================================================
.text$mn:00004D58
.text$mn:00004D58 ; Segment type: Pure code
.text$mn:00004D58 ; Segment permissions: Read/Execute
.text$mn:00004D58 _text$mn        segment para public 'CODE' use32
.text$mn:00004D58                 assume cs:_text$mn
.text$mn:00004D58                 ;org 4D58h
.text$mn:00004D58 ; COMDAT (pick any)
.text$mn:00004D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D58
.text$mn:00004D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D58
.text$mn:00004D58 ; Attributes: bp-based frame
.text$mn:00004D58
.text$mn:00004D58 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00004D58                 public ??0error_category@std@@QAE@XZ
.text$mn:00004D58 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00004D58
.text$mn:00004D58 var_4           = dword ptr -4
.text$mn:00004D58
.text$mn:00004D58                 push    ebp
.text$mn:00004D59                 mov     ebp, esp
.text$mn:00004D5B                 push    ecx
.text$mn:00004D5C                 mov     [ebp+var_4], ecx
.text$mn:00004D5F                 mov     eax, [ebp+var_4]
.text$mn:00004D62                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00004D68                 mov     eax, [ebp+var_4]
.text$mn:00004D6B                 mov     esp, ebp
.text$mn:00004D6D                 pop     ebp
.text$mn:00004D6E                 retn
.text$mn:00004D6E ??0error_category@std@@QAE@XZ endp
.text$mn:00004D6E
.text$mn:00004D6E ; ---------------------------------------------------------------------------
.text$mn:00004D6F                 align 10h
.text$mn:00004D6F _text$mn        ends
.text$mn:00004D6F
.text$mn:00004D70 ; ===========================================================================
.text$mn:00004D70
.text$mn:00004D70 ; Segment type: Pure code
.text$mn:00004D70 ; Segment permissions: Read/Execute
.text$mn:00004D70 _text$mn        segment para public 'CODE' use32
.text$mn:00004D70                 assume cs:_text$mn
.text$mn:00004D70                 ;org 4D70h
.text$mn:00004D70 ; COMDAT (pick any)
.text$mn:00004D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D70
.text$mn:00004D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D70
.text$mn:00004D70 ; Attributes: bp-based frame
.text$mn:00004D70
.text$mn:00004D70 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00004D70                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00004D70 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00004D70                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00004D70                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00004D70
.text$mn:00004D70 var_4           = dword ptr -4
.text$mn:00004D70 arg_0           = dword ptr  8
.text$mn:00004D70 arg_4           = dword ptr  0Ch
.text$mn:00004D70
.text$mn:00004D70                 push    ebp
.text$mn:00004D71                 mov     ebp, esp
.text$mn:00004D73                 push    ecx
.text$mn:00004D74                 mov     [ebp+var_4], ecx
.text$mn:00004D77                 mov     eax, [ebp+var_4]
.text$mn:00004D7A                 mov     ecx, [ebp+arg_0]
.text$mn:00004D7D                 mov     [eax], ecx
.text$mn:00004D7F                 mov     edx, [ebp+var_4]
.text$mn:00004D82                 mov     eax, [ebp+arg_4]
.text$mn:00004D85                 mov     [edx+4], eax
.text$mn:00004D88                 mov     eax, [ebp+var_4]
.text$mn:00004D8B                 mov     esp, ebp
.text$mn:00004D8D                 pop     ebp
.text$mn:00004D8E                 retn    8
.text$mn:00004D8E ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00004D8E
.text$mn:00004D8E ; ---------------------------------------------------------------------------
.text$mn:00004D91                 align 4
.text$mn:00004D91 _text$mn        ends
.text$mn:00004D91
.text$mn:00004D94 ; ===========================================================================
.text$mn:00004D94
.text$mn:00004D94 ; Segment type: Pure code
.text$mn:00004D94 ; Segment permissions: Read/Execute
.text$mn:00004D94 _text$mn        segment para public 'CODE' use32
.text$mn:00004D94                 assume cs:_text$mn
.text$mn:00004D94                 ;org 4D94h
.text$mn:00004D94 ; COMDAT (pick any)
.text$mn:00004D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D94
.text$mn:00004D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D94
.text$mn:00004D94 ; Attributes: bp-based frame
.text$mn:00004D94
.text$mn:00004D94 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00004D94                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00004D94 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00004D94                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00004D94
.text$mn:00004D94 var_4           = dword ptr -4
.text$mn:00004D94 arg_0           = dword ptr  8
.text$mn:00004D94
.text$mn:00004D94                 push    ebp
.text$mn:00004D95                 mov     ebp, esp
.text$mn:00004D97                 push    ecx
.text$mn:00004D98                 mov     [ebp+var_4], ecx
.text$mn:00004D9B                 mov     eax, [ebp+var_4]
.text$mn:00004D9E                 mov     ecx, [ebp+arg_0]
.text$mn:00004DA1                 mov     [eax], ecx
.text$mn:00004DA3                 mov     eax, [ebp+var_4]
.text$mn:00004DA6                 mov     esp, ebp
.text$mn:00004DA8                 pop     ebp
.text$mn:00004DA9                 retn    4
.text$mn:00004DA9 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00004DA9
.text$mn:00004DA9 _text$mn        ends
.text$mn:00004DA9
.text$mn:00004DAC ; ===========================================================================
.text$mn:00004DAC
.text$mn:00004DAC ; Segment type: Pure code
.text$mn:00004DAC ; Segment permissions: Read/Execute
.text$mn:00004DAC _text$mn        segment para public 'CODE' use32
.text$mn:00004DAC                 assume cs:_text$mn
.text$mn:00004DAC                 ;org 4DACh
.text$mn:00004DAC ; COMDAT (pick any)
.text$mn:00004DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DAC
.text$mn:00004DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00004DAC
.text$mn:00004DAC ; Attributes: bp-based frame
.text$mn:00004DAC
.text$mn:00004DAC ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00004DAC                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00004DAC ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00004DAC                                         ; DATA XREF: .xdata$x:00009D04o
.text$mn:00004DAC
.text$mn:00004DAC var_10          = dword ptr -10h
.text$mn:00004DAC var_C           = dword ptr -0Ch
.text$mn:00004DAC var_4           = dword ptr -4
.text$mn:00004DAC arg_0           = dword ptr  8
.text$mn:00004DAC
.text$mn:00004DAC                 push    ebp
.text$mn:00004DAD                 mov     ebp, esp
.text$mn:00004DAF                 push    0FFFFFFFFh
.text$mn:00004DB1                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00004DB6                 mov     eax, large fs:0
.text$mn:00004DBC                 push    eax
.text$mn:00004DBD                 push    ecx
.text$mn:00004DBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004DC3                 xor     eax, ebp
.text$mn:00004DC5                 push    eax
.text$mn:00004DC6                 lea     eax, [ebp+var_C]
.text$mn:00004DC9                 mov     large fs:0, eax
.text$mn:00004DCF                 mov     [ebp+var_10], ecx
.text$mn:00004DD2                 mov     eax, [ebp+arg_0]
.text$mn:00004DD5                 push    eax             ; struct std::exception *
.text$mn:00004DD6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004DD9                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:00004DDE                 mov     [ebp+var_4], 0
.text$mn:00004DE5                 mov     ecx, [ebp+var_10]
.text$mn:00004DE8                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00004DEE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004DF5                 mov     eax, [ebp+var_10]
.text$mn:00004DF8                 mov     ecx, [ebp+var_C]
.text$mn:00004DFB                 mov     large fs:0, ecx
.text$mn:00004E02                 pop     ecx
.text$mn:00004E03                 mov     esp, ebp
.text$mn:00004E05                 pop     ebp
.text$mn:00004E06                 retn    4
.text$mn:00004E06 ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00004E06
.text$mn:00004E06 ; ---------------------------------------------------------------------------
.text$mn:00004E09                 align 4
.text$mn:00004E09 _text$mn        ends
.text$mn:00004E09
.text$x:00004E0C ; ===========================================================================
.text$x:00004E0C
.text$x:00004E0C ; Segment type: Pure code
.text$x:00004E0C ; Segment permissions: Read/Execute
.text$x:00004E0C _text$x         segment para public 'CODE' use32
.text$x:00004E0C                 assume cs:_text$x
.text$x:00004E0C                 ;org 4E0Ch
.text$x:00004E0C ; COMDAT (pick associative to section at 4DAC)
.text$x:00004E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004E0C
.text$x:00004E0C ; =============== S U B R O U T I N E =======================================
.text$x:00004E0C
.text$x:00004E0C
.text$x:00004E0C __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00004E0C                                         ; DATA XREF: .xdata$x:00008EDCo
.text$x:00004E0C                 mov     ecx, [ebp-10h]  ; this
.text$x:00004E0F                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00004E0F __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00004E0F
.text$x:00004E14
.text$x:00004E14 ; =============== S U B R O U T I N E =======================================
.text$x:00004E14
.text$x:00004E14
.text$x:00004E14 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00004E14                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00004E14
.text$x:00004E14 arg_4           = dword ptr  8
.text$x:00004E14
.text$x:00004E14                 mov     edx, [esp+arg_4]
.text$x:00004E18                 lea     eax, [edx+0Ch]
.text$x:00004E1B                 mov     ecx, [edx-8]
.text$x:00004E1E                 xor     ecx, eax
.text$x:00004E20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004E25                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:00004E2A                 jmp     ___CxxFrameHandler3
.text$x:00004E2A __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:00004E2A
.text$x:00004E2A ; ---------------------------------------------------------------------------
.text$x:00004E2F                 align 10h
.text$x:00004E2F _text$x         ends
.text$x:00004E2F
.text$mn:00004E30 ; ===========================================================================
.text$mn:00004E30
.text$mn:00004E30 ; Segment type: Pure code
.text$mn:00004E30 ; Segment permissions: Read/Execute
.text$mn:00004E30 _text$mn        segment para public 'CODE' use32
.text$mn:00004E30                 assume cs:_text$mn
.text$mn:00004E30                 ;org 4E30h
.text$mn:00004E30 ; COMDAT (pick any)
.text$mn:00004E30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E30
.text$mn:00004E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E30
.text$mn:00004E30 ; Attributes: bp-based frame
.text$mn:00004E30
.text$mn:00004E30 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:00004E30                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:00004E30 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:00004E30                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+90p
.text$mn:00004E30                                         ; DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+103p ...
.text$mn:00004E30
.text$mn:00004E30 var_10          = dword ptr -10h
.text$mn:00004E30 var_C           = dword ptr -0Ch
.text$mn:00004E30 var_4           = dword ptr -4
.text$mn:00004E30 arg_0           = dword ptr  8
.text$mn:00004E30
.text$mn:00004E30                 push    ebp
.text$mn:00004E31                 mov     ebp, esp
.text$mn:00004E33                 push    0FFFFFFFFh
.text$mn:00004E35                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:00004E3A                 mov     eax, large fs:0
.text$mn:00004E40                 push    eax
.text$mn:00004E41                 push    ecx
.text$mn:00004E42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004E47                 xor     eax, ebp
.text$mn:00004E49                 push    eax
.text$mn:00004E4A                 lea     eax, [ebp+var_C]
.text$mn:00004E4D                 mov     large fs:0, eax
.text$mn:00004E53                 mov     [ebp+var_10], ecx
.text$mn:00004E56                 lea     eax, [ebp+arg_0]
.text$mn:00004E59                 push    eax             ; char **
.text$mn:00004E5A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004E5D                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00004E62                 mov     [ebp+var_4], 0
.text$mn:00004E69                 mov     ecx, [ebp+var_10]
.text$mn:00004E6C                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00004E72                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004E79                 mov     eax, [ebp+var_10]
.text$mn:00004E7C                 mov     ecx, [ebp+var_C]
.text$mn:00004E7F                 mov     large fs:0, ecx
.text$mn:00004E86                 pop     ecx
.text$mn:00004E87                 mov     esp, ebp
.text$mn:00004E89                 pop     ebp
.text$mn:00004E8A                 retn    4
.text$mn:00004E8A ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:00004E8A
.text$mn:00004E8A ; ---------------------------------------------------------------------------
.text$mn:00004E8D                 align 10h
.text$mn:00004E8D _text$mn        ends
.text$mn:00004E8D
.text$x:00004E90 ; ===========================================================================
.text$x:00004E90
.text$x:00004E90 ; Segment type: Pure code
.text$x:00004E90 ; Segment permissions: Read/Execute
.text$x:00004E90 _text$x         segment para public 'CODE' use32
.text$x:00004E90                 assume cs:_text$x
.text$x:00004E90                 ;org 4E90h
.text$x:00004E90 ; COMDAT (pick associative to section at 4E30)
.text$x:00004E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004E90
.text$x:00004E90 ; =============== S U B R O U T I N E =======================================
.text$x:00004E90
.text$x:00004E90
.text$x:00004E90 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00004E90                                         ; DATA XREF: .xdata$x:00008E84o
.text$x:00004E90                 mov     ecx, [ebp-10h]  ; this
.text$x:00004E93                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00004E93 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00004E93
.text$x:00004E98
.text$x:00004E98 ; =============== S U B R O U T I N E =======================================
.text$x:00004E98
.text$x:00004E98
.text$x:00004E98 __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00004E98                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00004E98
.text$x:00004E98 arg_4           = dword ptr  8
.text$x:00004E98
.text$x:00004E98                 mov     edx, [esp+arg_4]
.text$x:00004E9C                 lea     eax, [edx+0Ch]
.text$x:00004E9F                 mov     ecx, [edx-8]
.text$x:00004EA2                 xor     ecx, eax
.text$x:00004EA4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004EA9                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00004EAE                 jmp     ___CxxFrameHandler3
.text$x:00004EAE __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00004EAE
.text$x:00004EAE ; ---------------------------------------------------------------------------
.text$x:00004EB3                 align 4
.text$x:00004EB3 _text$x         ends
.text$x:00004EB3
.text$mn:00004EB4 ; ===========================================================================
.text$mn:00004EB4
.text$mn:00004EB4 ; Segment type: Pure code
.text$mn:00004EB4 ; Segment permissions: Read/Execute
.text$mn:00004EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00004EB4                 assume cs:_text$mn
.text$mn:00004EB4                 ;org 4EB4h
.text$mn:00004EB4 ; COMDAT (pick any)
.text$mn:00004EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EB4
.text$mn:00004EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EB4
.text$mn:00004EB4 ; Attributes: bp-based frame
.text$mn:00004EB4
.text$mn:00004EB4 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, struct tTbData *, int, struct tTbData * const *, struct tTbData * const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, struct tTbData *, int, struct tTbData * const *, struct tTbData * const &, struct std::_Iterator_base12>(void)
.text$mn:00004EB4                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004EB4 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00004EB4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00004EB4                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00004EB4
.text$mn:00004EB4 var_10          = dword ptr -10h
.text$mn:00004EB4 var_C           = dword ptr -0Ch
.text$mn:00004EB4 var_4           = dword ptr -4
.text$mn:00004EB4
.text$mn:00004EB4                 push    ebp
.text$mn:00004EB5                 mov     ebp, esp
.text$mn:00004EB7                 push    0FFFFFFFFh
.text$mn:00004EB9                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004EBE                 mov     eax, large fs:0
.text$mn:00004EC4                 push    eax
.text$mn:00004EC5                 push    ecx
.text$mn:00004EC6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004ECB                 xor     eax, ebp
.text$mn:00004ECD                 push    eax
.text$mn:00004ECE                 lea     eax, [ebp+var_C]
.text$mn:00004ED1                 mov     large fs:0, eax
.text$mn:00004ED7                 mov     [ebp+var_10], ecx
.text$mn:00004EDA                 mov     [ebp+var_4], 0
.text$mn:00004EE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004EE8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004EEB                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00004EF0                 mov     ecx, [ebp+var_C]
.text$mn:00004EF3                 mov     large fs:0, ecx
.text$mn:00004EFA                 pop     ecx
.text$mn:00004EFB                 mov     esp, ebp
.text$mn:00004EFD                 pop     ebp
.text$mn:00004EFE                 retn
.text$mn:00004EFE ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00004EFE
.text$mn:00004EFE ; ---------------------------------------------------------------------------
.text$mn:00004EFF                 align 10h
.text$mn:00004EFF _text$mn        ends
.text$mn:00004EFF
.text$x:00004F00 ; ===========================================================================
.text$x:00004F00
.text$x:00004F00 ; Segment type: Pure code
.text$x:00004F00 ; Segment permissions: Read/Execute
.text$x:00004F00 _text$x         segment para public 'CODE' use32
.text$x:00004F00                 assume cs:_text$x
.text$x:00004F00                 ;org 4F00h
.text$x:00004F00 ; COMDAT (pick associative to section at 4EB4)
.text$x:00004F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004F00
.text$x:00004F00 ; =============== S U B R O U T I N E =======================================
.text$x:00004F00
.text$x:00004F00
.text$x:00004F00 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00004F00                                         ; DATA XREF: .xdata$x:00009944o
.text$x:00004F00                 mov     ecx, [ebp-10h]  ; this
.text$x:00004F03                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004F03 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00004F03
.text$x:00004F08
.text$x:00004F08 ; =============== S U B R O U T I N E =======================================
.text$x:00004F08
.text$x:00004F08
.text$x:00004F08 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00004F08                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(void)+5o
.text$x:00004F08
.text$x:00004F08 arg_4           = dword ptr  8
.text$x:00004F08
.text$x:00004F08                 mov     edx, [esp+arg_4]
.text$x:00004F0C                 lea     eax, [edx+0Ch]
.text$x:00004F0F                 mov     ecx, [edx-8]
.text$x:00004F12                 xor     ecx, eax
.text$x:00004F14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004F19                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00004F1E                 jmp     ___CxxFrameHandler3
.text$x:00004F1E __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00004F1E
.text$x:00004F1E ; ---------------------------------------------------------------------------
.text$x:00004F23                 align 4
.text$x:00004F23 _text$x         ends
.text$x:00004F23
.text$mn:00004F24 ; ===========================================================================
.text$mn:00004F24
.text$mn:00004F24 ; Segment type: Pure code
.text$mn:00004F24 ; Segment permissions: Read/Execute
.text$mn:00004F24 _text$mn        segment para public 'CODE' use32
.text$mn:00004F24                 assume cs:_text$mn
.text$mn:00004F24                 ;org 4F24h
.text$mn:00004F24 ; COMDAT (pick any)
.text$mn:00004F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F24
.text$mn:00004F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F24
.text$mn:00004F24 ; Attributes: bp-based frame
.text$mn:00004F24
.text$mn:00004F24 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00004F24                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00004F24 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00004F24                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00004F24                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00004F24
.text$mn:00004F24 var_10          = dword ptr -10h
.text$mn:00004F24 var_C           = dword ptr -0Ch
.text$mn:00004F24 var_4           = dword ptr -4
.text$mn:00004F24
.text$mn:00004F24                 push    ebp
.text$mn:00004F25                 mov     ebp, esp
.text$mn:00004F27                 push    0FFFFFFFFh
.text$mn:00004F29                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00004F2E                 mov     eax, large fs:0
.text$mn:00004F34                 push    eax
.text$mn:00004F35                 push    ecx
.text$mn:00004F36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004F3B                 xor     eax, ebp
.text$mn:00004F3D                 push    eax
.text$mn:00004F3E                 lea     eax, [ebp+var_C]
.text$mn:00004F41                 mov     large fs:0, eax
.text$mn:00004F47                 mov     [ebp+var_10], ecx
.text$mn:00004F4A                 mov     [ebp+var_4], 0
.text$mn:00004F51                 mov     ecx, [ebp+var_10]
.text$mn:00004F54                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00004F59                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004F60                 mov     ecx, [ebp+var_10]
.text$mn:00004F63                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00004F68                 mov     ecx, [ebp+var_C]
.text$mn:00004F6B                 mov     large fs:0, ecx
.text$mn:00004F72                 pop     ecx
.text$mn:00004F73                 mov     esp, ebp
.text$mn:00004F75                 pop     ebp
.text$mn:00004F76                 retn
.text$mn:00004F76 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004F76
.text$mn:00004F76 ; ---------------------------------------------------------------------------
.text$mn:00004F77                 align 4
.text$mn:00004F77 _text$mn        ends
.text$mn:00004F77
.text$x:00004F78 ; ===========================================================================
.text$x:00004F78
.text$x:00004F78 ; Segment type: Pure code
.text$x:00004F78 ; Segment permissions: Read/Execute
.text$x:00004F78 _text$x         segment para public 'CODE' use32
.text$x:00004F78                 assume cs:_text$x
.text$x:00004F78                 ;org 4F78h
.text$x:00004F78 ; COMDAT (pick associative to section at 4F24)
.text$x:00004F78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004F78
.text$x:00004F78 ; =============== S U B R O U T I N E =======================================
.text$x:00004F78
.text$x:00004F78
.text$x:00004F78 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00004F78                                         ; DATA XREF: .xdata$x:00008D74o
.text$x:00004F78                 mov     ecx, [ebp-10h]
.text$x:00004F7B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00004F7B __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00004F7B
.text$x:00004F80
.text$x:00004F80 ; =============== S U B R O U T I N E =======================================
.text$x:00004F80
.text$x:00004F80
.text$x:00004F80 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00004F80                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00004F80
.text$x:00004F80 arg_4           = dword ptr  8
.text$x:00004F80
.text$x:00004F80                 mov     edx, [esp+arg_4]
.text$x:00004F84                 lea     eax, [edx+0Ch]
.text$x:00004F87                 mov     ecx, [edx-8]
.text$x:00004F8A                 xor     ecx, eax
.text$x:00004F8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004F91                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00004F96                 jmp     ___CxxFrameHandler3
.text$x:00004F96 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00004F96
.text$x:00004F96 ; ---------------------------------------------------------------------------
.text$x:00004F9B                 align 4
.text$x:00004F9B _text$x         ends
.text$x:00004F9B
.text$mn:00004F9C ; ===========================================================================
.text$mn:00004F9C
.text$mn:00004F9C ; Segment type: Pure code
.text$mn:00004F9C ; Segment permissions: Read/Execute
.text$mn:00004F9C _text$mn        segment para public 'CODE' use32
.text$mn:00004F9C                 assume cs:_text$mn
.text$mn:00004F9C                 ;org 4F9Ch
.text$mn:00004F9C ; COMDAT (pick any)
.text$mn:00004F9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F9C
.text$mn:00004F9C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F9C
.text$mn:00004F9C ; Attributes: bp-based frame
.text$mn:00004F9C
.text$mn:00004F9C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00004F9C                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00004F9C ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00004F9C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00004F9C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00004F9C
.text$mn:00004F9C var_10          = dword ptr -10h
.text$mn:00004F9C var_C           = dword ptr -0Ch
.text$mn:00004F9C var_4           = dword ptr -4
.text$mn:00004F9C
.text$mn:00004F9C                 push    ebp
.text$mn:00004F9D                 mov     ebp, esp
.text$mn:00004F9F                 push    0FFFFFFFFh
.text$mn:00004FA1                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00004FA6                 mov     eax, large fs:0
.text$mn:00004FAC                 push    eax
.text$mn:00004FAD                 push    ecx
.text$mn:00004FAE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004FB3                 xor     eax, ebp
.text$mn:00004FB5                 push    eax
.text$mn:00004FB6                 lea     eax, [ebp+var_C]
.text$mn:00004FB9                 mov     large fs:0, eax
.text$mn:00004FBF                 mov     [ebp+var_10], ecx
.text$mn:00004FC2                 mov     [ebp+var_4], 0
.text$mn:00004FC9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004FD0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004FD3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00004FD8                 mov     ecx, [ebp+var_C]
.text$mn:00004FDB                 mov     large fs:0, ecx
.text$mn:00004FE2                 pop     ecx
.text$mn:00004FE3                 mov     esp, ebp
.text$mn:00004FE5                 pop     ebp
.text$mn:00004FE6                 retn
.text$mn:00004FE6 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00004FE6
.text$mn:00004FE6 ; ---------------------------------------------------------------------------
.text$mn:00004FE7                 align 4
.text$mn:00004FE7 _text$mn        ends
.text$mn:00004FE7
.text$x:00004FE8 ; ===========================================================================
.text$x:00004FE8
.text$x:00004FE8 ; Segment type: Pure code
.text$x:00004FE8 ; Segment permissions: Read/Execute
.text$x:00004FE8 _text$x         segment para public 'CODE' use32
.text$x:00004FE8                 assume cs:_text$x
.text$x:00004FE8                 ;org 4FE8h
.text$x:00004FE8 ; COMDAT (pick associative to section at 4F9C)
.text$x:00004FE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004FE8
.text$x:00004FE8 ; =============== S U B R O U T I N E =======================================
.text$x:00004FE8
.text$x:00004FE8
.text$x:00004FE8 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00004FE8                                         ; DATA XREF: .xdata$x:00008D1Co
.text$x:00004FE8                 mov     ecx, [ebp-10h]  ; this
.text$x:00004FEB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00004FEB __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00004FEB
.text$x:00004FF0
.text$x:00004FF0 ; =============== S U B R O U T I N E =======================================
.text$x:00004FF0
.text$x:00004FF0
.text$x:00004FF0 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00004FF0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00004FF0
.text$x:00004FF0 arg_4           = dword ptr  8
.text$x:00004FF0
.text$x:00004FF0                 mov     edx, [esp+arg_4]
.text$x:00004FF4                 lea     eax, [edx+0Ch]
.text$x:00004FF7                 mov     ecx, [edx-8]
.text$x:00004FFA                 xor     ecx, eax
.text$x:00004FFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005001                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00005006                 jmp     ___CxxFrameHandler3
.text$x:00005006 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00005006
.text$x:00005006 ; ---------------------------------------------------------------------------
.text$x:0000500B                 align 4
.text$x:0000500B _text$x         ends
.text$x:0000500B
.text$mn:0000500C ; ===========================================================================
.text$mn:0000500C
.text$mn:0000500C ; Segment type: Pure code
.text$mn:0000500C ; Segment permissions: Read/Execute
.text$mn:0000500C _text$mn        segment para public 'CODE' use32
.text$mn:0000500C                 assume cs:_text$mn
.text$mn:0000500C                 ;org 500Ch
.text$mn:0000500C ; COMDAT (pick any)
.text$mn:0000500C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000500C
.text$mn:0000500C ; =============== S U B R O U T I N E =======================================
.text$mn:0000500C
.text$mn:0000500C ; Attributes: bp-based frame
.text$mn:0000500C
.text$mn:0000500C ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct HWND__ *, class std::allocator<struct HWND__ *>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct HWND__ *, class std::allocator<struct HWND__ *>>>(void)
.text$mn:0000500C                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000500C ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000500C                                         ; CODE XREF: __unwindfunclet$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ$0+3j
.text$mn:0000500C                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::~vector<HWND__ *,std::allocator<HWND__ *>>(void)+3Fp ...
.text$mn:0000500C
.text$mn:0000500C var_10          = dword ptr -10h
.text$mn:0000500C var_C           = dword ptr -0Ch
.text$mn:0000500C var_4           = dword ptr -4
.text$mn:0000500C
.text$mn:0000500C                 push    ebp
.text$mn:0000500D                 mov     ebp, esp
.text$mn:0000500F                 push    0FFFFFFFFh
.text$mn:00005011                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ
.text$mn:00005016                 mov     eax, large fs:0
.text$mn:0000501C                 push    eax
.text$mn:0000501D                 push    ecx
.text$mn:0000501E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005023                 xor     eax, ebp
.text$mn:00005025                 push    eax
.text$mn:00005026                 lea     eax, [ebp+var_C]
.text$mn:00005029                 mov     large fs:0, eax
.text$mn:0000502F                 mov     [ebp+var_10], ecx
.text$mn:00005032                 mov     [ebp+var_4], 0
.text$mn:00005039                 mov     ecx, [ebp+var_10]
.text$mn:0000503C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Free_proxy(void)
.text$mn:00005041                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005048                 mov     ecx, [ebp+var_10]
.text$mn:0000504B                 call    ??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<HWND__ *>>::~_Vector_val<std::_Simple_types<HWND__ *>>(void)
.text$mn:00005050                 mov     ecx, [ebp+var_C]
.text$mn:00005053                 mov     large fs:0, ecx
.text$mn:0000505A                 pop     ecx
.text$mn:0000505B                 mov     esp, ebp
.text$mn:0000505D                 pop     ebp
.text$mn:0000505E                 retn
.text$mn:0000505E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000505E
.text$mn:0000505E ; ---------------------------------------------------------------------------
.text$mn:0000505F                 align 10h
.text$mn:0000505F _text$mn        ends
.text$mn:0000505F
.text$x:00005060 ; ===========================================================================
.text$x:00005060
.text$x:00005060 ; Segment type: Pure code
.text$x:00005060 ; Segment permissions: Read/Execute
.text$x:00005060 _text$x         segment para public 'CODE' use32
.text$x:00005060                 assume cs:_text$x
.text$x:00005060                 ;org 5060h
.text$x:00005060 ; COMDAT (pick associative to section at 500C)
.text$x:00005060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005060
.text$x:00005060 ; =============== S U B R O U T I N E =======================================
.text$x:00005060
.text$x:00005060
.text$x:00005060 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005060                                         ; DATA XREF: .xdata$x:000094A0o
.text$x:00005060                 mov     ecx, [ebp-10h]
.text$x:00005063                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<HWND__ *>>::~_Vector_val<std::_Simple_types<HWND__ *>>(void)
.text$x:00005063 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005063
.text$x:00005068
.text$x:00005068 ; =============== S U B R O U T I N E =======================================
.text$x:00005068
.text$x:00005068
.text$x:00005068 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005068                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>(void)+5o
.text$x:00005068
.text$x:00005068 arg_4           = dword ptr  8
.text$x:00005068
.text$x:00005068                 mov     edx, [esp+arg_4]
.text$x:0000506C                 lea     eax, [edx+0Ch]
.text$x:0000506F                 mov     ecx, [edx-8]
.text$x:00005072                 xor     ecx, eax
.text$x:00005074                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005079                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ
.text$x:0000507E                 jmp     ___CxxFrameHandler3
.text$x:0000507E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000507E
.text$x:0000507E ; ---------------------------------------------------------------------------
.text$x:00005083                 align 4
.text$x:00005083 _text$x         ends
.text$x:00005083
.text$mn:00005084 ; ===========================================================================
.text$mn:00005084
.text$mn:00005084 ; Segment type: Pure code
.text$mn:00005084 ; Segment permissions: Read/Execute
.text$mn:00005084 _text$mn        segment para public 'CODE' use32
.text$mn:00005084                 assume cs:_text$mn
.text$mn:00005084                 ;org 5084h
.text$mn:00005084 ; COMDAT (pick any)
.text$mn:00005084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005084
.text$mn:00005084 ; =============== S U B R O U T I N E =======================================
.text$mn:00005084
.text$mn:00005084 ; Attributes: bp-based frame
.text$mn:00005084
.text$mn:00005084 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct tTbData *, class std::allocator<struct tTbData *>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct tTbData *, class std::allocator<struct tTbData *>>>(void)
.text$mn:00005084                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ
.text$mn:00005084 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005084                                         ; CODE XREF: __unwindfunclet$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$2+3j
.text$mn:00005084                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::~vector<tTbData *,std::allocator<tTbData *>>(void)+3Fp ...
.text$mn:00005084
.text$mn:00005084 var_10          = dword ptr -10h
.text$mn:00005084 var_C           = dword ptr -0Ch
.text$mn:00005084 var_4           = dword ptr -4
.text$mn:00005084
.text$mn:00005084                 push    ebp
.text$mn:00005085                 mov     ebp, esp
.text$mn:00005087                 push    0FFFFFFFFh
.text$mn:00005089                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000508E                 mov     eax, large fs:0
.text$mn:00005094                 push    eax
.text$mn:00005095                 push    ecx
.text$mn:00005096                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000509B                 xor     eax, ebp
.text$mn:0000509D                 push    eax
.text$mn:0000509E                 lea     eax, [ebp+var_C]
.text$mn:000050A1                 mov     large fs:0, eax
.text$mn:000050A7                 mov     [ebp+var_10], ecx
.text$mn:000050AA                 mov     [ebp+var_4], 0
.text$mn:000050B1                 mov     ecx, [ebp+var_10]
.text$mn:000050B4                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Free_proxy(void)
.text$mn:000050B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000050C0                 mov     ecx, [ebp+var_10]
.text$mn:000050C3                 call    ??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<tTbData *>>::~_Vector_val<std::_Simple_types<tTbData *>>(void)
.text$mn:000050C8                 mov     ecx, [ebp+var_C]
.text$mn:000050CB                 mov     large fs:0, ecx
.text$mn:000050D2                 pop     ecx
.text$mn:000050D3                 mov     esp, ebp
.text$mn:000050D5                 pop     ebp
.text$mn:000050D6                 retn
.text$mn:000050D6 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000050D6
.text$mn:000050D6 ; ---------------------------------------------------------------------------
.text$mn:000050D7                 align 4
.text$mn:000050D7 _text$mn        ends
.text$mn:000050D7
.text$x:000050D8 ; ===========================================================================
.text$x:000050D8
.text$x:000050D8 ; Segment type: Pure code
.text$x:000050D8 ; Segment permissions: Read/Execute
.text$x:000050D8 _text$x         segment para public 'CODE' use32
.text$x:000050D8                 assume cs:_text$x
.text$x:000050D8                 ;org 50D8h
.text$x:000050D8 ; COMDAT (pick associative to section at 5084)
.text$x:000050D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000050D8
.text$x:000050D8 ; =============== S U B R O U T I N E =======================================
.text$x:000050D8
.text$x:000050D8
.text$x:000050D8 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000050D8                                         ; DATA XREF: .xdata$x:00009144o
.text$x:000050D8                 mov     ecx, [ebp-10h]
.text$x:000050DB                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<tTbData *>>::~_Vector_val<std::_Simple_types<tTbData *>>(void)
.text$x:000050DB __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000050DB
.text$x:000050E0
.text$x:000050E0 ; =============== S U B R O U T I N E =======================================
.text$x:000050E0
.text$x:000050E0
.text$x:000050E0 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000050E0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::~_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>(void)+5o
.text$x:000050E0
.text$x:000050E0 arg_4           = dword ptr  8
.text$x:000050E0
.text$x:000050E0                 mov     edx, [esp+arg_4]
.text$x:000050E4                 lea     eax, [edx+0Ch]
.text$x:000050E7                 mov     ecx, [edx-8]
.text$x:000050EA                 xor     ecx, eax
.text$x:000050EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000050F1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ
.text$x:000050F6                 jmp     ___CxxFrameHandler3
.text$x:000050F6 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000050F6
.text$x:000050F6 ; ---------------------------------------------------------------------------
.text$x:000050FB                 align 4
.text$x:000050FB _text$x         ends
.text$x:000050FB
.text$mn:000050FC ; ===========================================================================
.text$mn:000050FC
.text$mn:000050FC ; Segment type: Pure code
.text$mn:000050FC ; Segment permissions: Read/Execute
.text$mn:000050FC _text$mn        segment para public 'CODE' use32
.text$mn:000050FC                 assume cs:_text$mn
.text$mn:000050FC                 ;org 50FCh
.text$mn:000050FC ; COMDAT (pick any)
.text$mn:000050FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050FC
.text$mn:000050FC ; =============== S U B R O U T I N E =======================================
.text$mn:000050FC
.text$mn:000050FC ; Attributes: bp-based frame
.text$mn:000050FC
.text$mn:000050FC ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>::~_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>(void)
.text$mn:000050FC                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.text$mn:000050FC ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000050FC                                         ; CODE XREF: __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ$0+3j
.text$mn:000050FC                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)+3Fp ...
.text$mn:000050FC
.text$mn:000050FC var_10          = dword ptr -10h
.text$mn:000050FC var_C           = dword ptr -0Ch
.text$mn:000050FC var_4           = dword ptr -4
.text$mn:000050FC
.text$mn:000050FC                 push    ebp
.text$mn:000050FD                 mov     ebp, esp
.text$mn:000050FF                 push    0FFFFFFFFh
.text$mn:00005101                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.text$mn:00005106                 mov     eax, large fs:0
.text$mn:0000510C                 push    eax
.text$mn:0000510D                 push    ecx
.text$mn:0000510E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005113                 xor     eax, ebp
.text$mn:00005115                 push    eax
.text$mn:00005116                 lea     eax, [ebp+var_C]
.text$mn:00005119                 mov     large fs:0, eax
.text$mn:0000511F                 mov     [ebp+var_10], ecx
.text$mn:00005122                 mov     [ebp+var_4], 0
.text$mn:00005129                 mov     ecx, [ebp+var_10]
.text$mn:0000512C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Free_proxy(void)
.text$mn:00005131                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005138                 mov     ecx, [ebp+var_10]
.text$mn:0000513B                 call    ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingCont *>>::~_Vector_val<std::_Simple_types<DockingCont *>>(void)
.text$mn:00005140                 mov     ecx, [ebp+var_C]
.text$mn:00005143                 mov     large fs:0, ecx
.text$mn:0000514A                 pop     ecx
.text$mn:0000514B                 mov     esp, ebp
.text$mn:0000514D                 pop     ebp
.text$mn:0000514E                 retn
.text$mn:0000514E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000514E
.text$mn:0000514E ; ---------------------------------------------------------------------------
.text$mn:0000514F                 align 10h
.text$mn:0000514F _text$mn        ends
.text$mn:0000514F
.text$x:00005150 ; ===========================================================================
.text$x:00005150
.text$x:00005150 ; Segment type: Pure code
.text$x:00005150 ; Segment permissions: Read/Execute
.text$x:00005150 _text$x         segment para public 'CODE' use32
.text$x:00005150                 assume cs:_text$x
.text$x:00005150                 ;org 5150h
.text$x:00005150 ; COMDAT (pick associative to section at 50FC)
.text$x:00005150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005150
.text$x:00005150 ; =============== S U B R O U T I N E =======================================
.text$x:00005150
.text$x:00005150
.text$x:00005150 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005150                                         ; DATA XREF: .xdata$x:0000962Co
.text$x:00005150                 mov     ecx, [ebp-10h]
.text$x:00005153                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingCont *>>::~_Vector_val<std::_Simple_types<DockingCont *>>(void)
.text$x:00005153 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005153
.text$x:00005158
.text$x:00005158 ; =============== S U B R O U T I N E =======================================
.text$x:00005158
.text$x:00005158
.text$x:00005158 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005158                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)+5o
.text$x:00005158
.text$x:00005158 arg_4           = dword ptr  8
.text$x:00005158
.text$x:00005158                 mov     edx, [esp+arg_4]
.text$x:0000515C                 lea     eax, [edx+0Ch]
.text$x:0000515F                 mov     ecx, [edx-8]
.text$x:00005162                 xor     ecx, eax
.text$x:00005164                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005169                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.text$x:0000516E                 jmp     ___CxxFrameHandler3
.text$x:0000516E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000516E
.text$x:0000516E ; ---------------------------------------------------------------------------
.text$x:00005173                 align 4
.text$x:00005173 _text$x         ends
.text$x:00005173
.text$mn:00005174 ; ===========================================================================
.text$mn:00005174
.text$mn:00005174 ; Segment type: Pure code
.text$mn:00005174 ; Segment permissions: Read/Execute
.text$mn:00005174 _text$mn        segment para public 'CODE' use32
.text$mn:00005174                 assume cs:_text$mn
.text$mn:00005174                 ;org 5174h
.text$mn:00005174 ; COMDAT (pick any)
.text$mn:00005174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005174
.text$mn:00005174 ; =============== S U B R O U T I N E =======================================
.text$mn:00005174
.text$mn:00005174 ; Attributes: bp-based frame
.text$mn:00005174
.text$mn:00005174 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingSplitter *, class std::allocator<class DockingSplitter *>>>::~_Vector_alloc<0, struct std::_Vec_base_types<class DockingSplitter *, class std::allocator<class DockingSplitter *>>>(void)
.text$mn:00005174                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ
.text$mn:00005174 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005174                                         ; CODE XREF: __unwindfunclet$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0+3j
.text$mn:00005174                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::~vector<DockingSplitter *,std::allocator<DockingSplitter *>>(void)+3Fp ...
.text$mn:00005174
.text$mn:00005174 var_10          = dword ptr -10h
.text$mn:00005174 var_C           = dword ptr -0Ch
.text$mn:00005174 var_4           = dword ptr -4
.text$mn:00005174
.text$mn:00005174                 push    ebp
.text$mn:00005175                 mov     ebp, esp
.text$mn:00005177                 push    0FFFFFFFFh
.text$mn:00005179                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000517E                 mov     eax, large fs:0
.text$mn:00005184                 push    eax
.text$mn:00005185                 push    ecx
.text$mn:00005186                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000518B                 xor     eax, ebp
.text$mn:0000518D                 push    eax
.text$mn:0000518E                 lea     eax, [ebp+var_C]
.text$mn:00005191                 mov     large fs:0, eax
.text$mn:00005197                 mov     [ebp+var_10], ecx
.text$mn:0000519A                 mov     [ebp+var_4], 0
.text$mn:000051A1                 mov     ecx, [ebp+var_10]
.text$mn:000051A4                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Free_proxy(void)
.text$mn:000051A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000051B0                 mov     ecx, [ebp+var_10]
.text$mn:000051B3                 call    ??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingSplitter *>>::~_Vector_val<std::_Simple_types<DockingSplitter *>>(void)
.text$mn:000051B8                 mov     ecx, [ebp+var_C]
.text$mn:000051BB                 mov     large fs:0, ecx
.text$mn:000051C2                 pop     ecx
.text$mn:000051C3                 mov     esp, ebp
.text$mn:000051C5                 pop     ebp
.text$mn:000051C6                 retn
.text$mn:000051C6 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000051C6
.text$mn:000051C6 ; ---------------------------------------------------------------------------
.text$mn:000051C7                 align 4
.text$mn:000051C7 _text$mn        ends
.text$mn:000051C7
.text$x:000051C8 ; ===========================================================================
.text$x:000051C8
.text$x:000051C8 ; Segment type: Pure code
.text$x:000051C8 ; Segment permissions: Read/Execute
.text$x:000051C8 _text$x         segment para public 'CODE' use32
.text$x:000051C8                 assume cs:_text$x
.text$x:000051C8                 ;org 51C8h
.text$x:000051C8 ; COMDAT (pick associative to section at 5174)
.text$x:000051C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000051C8
.text$x:000051C8 ; =============== S U B R O U T I N E =======================================
.text$x:000051C8
.text$x:000051C8
.text$x:000051C8 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000051C8                                         ; DATA XREF: .xdata$x:000097B8o
.text$x:000051C8                 mov     ecx, [ebp-10h]
.text$x:000051CB                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingSplitter *>>::~_Vector_val<std::_Simple_types<DockingSplitter *>>(void)
.text$x:000051CB __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000051CB
.text$x:000051D0
.text$x:000051D0 ; =============== S U B R O U T I N E =======================================
.text$x:000051D0
.text$x:000051D0
.text$x:000051D0 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000051D0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>(void)+5o
.text$x:000051D0
.text$x:000051D0 arg_4           = dword ptr  8
.text$x:000051D0
.text$x:000051D0                 mov     edx, [esp+arg_4]
.text$x:000051D4                 lea     eax, [edx+0Ch]
.text$x:000051D7                 mov     ecx, [edx-8]
.text$x:000051DA                 xor     ecx, eax
.text$x:000051DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000051E1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ
.text$x:000051E6                 jmp     ___CxxFrameHandler3
.text$x:000051E6 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000051E6
.text$x:000051E6 ; ---------------------------------------------------------------------------
.text$x:000051EB                 align 4
.text$x:000051EB _text$x         ends
.text$x:000051EB
.text$mn:000051EC ; ===========================================================================
.text$mn:000051EC
.text$mn:000051EC ; Segment type: Pure code
.text$mn:000051EC ; Segment permissions: Read/Execute
.text$mn:000051EC _text$mn        segment para public 'CODE' use32
.text$mn:000051EC                 assume cs:_text$mn
.text$mn:000051EC                 ;org 51ECh
.text$mn:000051EC ; COMDAT (pick any)
.text$mn:000051EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000051EC
.text$mn:000051EC ; =============== S U B R O U T I N E =======================================
.text$mn:000051EC
.text$mn:000051EC ; Attributes: bp-based frame
.text$mn:000051EC
.text$mn:000051EC ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>(void)
.text$mn:000051EC                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ
.text$mn:000051EC ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000051EC                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *)+9Bp
.text$mn:000051EC                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *)+AAp ...
.text$mn:000051EC
.text$mn:000051EC var_10          = dword ptr -10h
.text$mn:000051EC var_C           = dword ptr -0Ch
.text$mn:000051EC var_4           = dword ptr -4
.text$mn:000051EC
.text$mn:000051EC                 push    ebp
.text$mn:000051ED                 mov     ebp, esp
.text$mn:000051EF                 push    0FFFFFFFFh
.text$mn:000051F1                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ
.text$mn:000051F6                 mov     eax, large fs:0
.text$mn:000051FC                 push    eax
.text$mn:000051FD                 push    ecx
.text$mn:000051FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005203                 xor     eax, ebp
.text$mn:00005205                 push    eax
.text$mn:00005206                 lea     eax, [ebp+var_C]
.text$mn:00005209                 mov     large fs:0, eax
.text$mn:0000520F                 mov     [ebp+var_10], ecx
.text$mn:00005212                 mov     [ebp+var_4], 0
.text$mn:00005219                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005220                 mov     ecx, [ebp+var_10]
.text$mn:00005223                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(void)
.text$mn:00005228                 mov     ecx, [ebp+var_C]
.text$mn:0000522B                 mov     large fs:0, ecx
.text$mn:00005232                 pop     ecx
.text$mn:00005233                 mov     esp, ebp
.text$mn:00005235                 pop     ebp
.text$mn:00005236                 retn
.text$mn:00005236 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00005236
.text$mn:00005236 ; ---------------------------------------------------------------------------
.text$mn:00005237                 align 4
.text$mn:00005237 _text$mn        ends
.text$mn:00005237
.text$x:00005238 ; ===========================================================================
.text$x:00005238
.text$x:00005238 ; Segment type: Pure code
.text$x:00005238 ; Segment permissions: Read/Execute
.text$x:00005238 _text$x         segment para public 'CODE' use32
.text$x:00005238                 assume cs:_text$x
.text$x:00005238                 ;org 5238h
.text$x:00005238 ; COMDAT (pick associative to section at 51EC)
.text$x:00005238                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005238
.text$x:00005238 ; =============== S U B R O U T I N E =======================================
.text$x:00005238
.text$x:00005238
.text$x:00005238 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005238                                         ; DATA XREF: .xdata$x:000099C8o
.text$x:00005238                 mov     ecx, [ebp-10h]
.text$x:0000523B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,tTbData *,int,tTbData * const *,tTbData * const &,std::_Iterator_base12>(void)
.text$x:0000523B __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000523B
.text$x:00005240
.text$x:00005240 ; =============== S U B R O U T I N E =======================================
.text$x:00005240
.text$x:00005240
.text$x:00005240 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005240                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)+5o
.text$x:00005240
.text$x:00005240 arg_4           = dword ptr  8
.text$x:00005240
.text$x:00005240                 mov     edx, [esp+arg_4]
.text$x:00005244                 lea     eax, [edx+0Ch]
.text$x:00005247                 mov     ecx, [edx-8]
.text$x:0000524A                 xor     ecx, eax
.text$x:0000524C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005251                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ
.text$x:00005256                 jmp     ___CxxFrameHandler3
.text$x:00005256 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00005256
.text$x:00005256 ; ---------------------------------------------------------------------------
.text$x:0000525B                 align 4
.text$x:0000525B _text$x         ends
.text$x:0000525B
.text$mn:0000525C ; ===========================================================================
.text$mn:0000525C
.text$mn:0000525C ; Segment type: Pure code
.text$mn:0000525C ; Segment permissions: Read/Execute
.text$mn:0000525C _text$mn        segment para public 'CODE' use32
.text$mn:0000525C                 assume cs:_text$mn
.text$mn:0000525C                 ;org 525Ch
.text$mn:0000525C ; COMDAT (pick any)
.text$mn:0000525C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000525C
.text$mn:0000525C ; =============== S U B R O U T I N E =======================================
.text$mn:0000525C
.text$mn:0000525C ; Attributes: bp-based frame
.text$mn:0000525C
.text$mn:0000525C ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct HWND__ *>>::~_Vector_val<struct std::_Simple_types<struct HWND__ *>>(void)
.text$mn:0000525C                 public ??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ
.text$mn:0000525C ??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ proc near
.text$mn:0000525C                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z$0+3j
.text$mn:0000525C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>(void)+3Fp ...
.text$mn:0000525C
.text$mn:0000525C var_10          = dword ptr -10h
.text$mn:0000525C var_C           = dword ptr -0Ch
.text$mn:0000525C var_4           = dword ptr -4
.text$mn:0000525C
.text$mn:0000525C                 push    ebp
.text$mn:0000525D                 mov     ebp, esp
.text$mn:0000525F                 push    0FFFFFFFFh
.text$mn:00005261                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ
.text$mn:00005266                 mov     eax, large fs:0
.text$mn:0000526C                 push    eax
.text$mn:0000526D                 push    ecx
.text$mn:0000526E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005273                 xor     eax, ebp
.text$mn:00005275                 push    eax
.text$mn:00005276                 lea     eax, [ebp+var_C]
.text$mn:00005279                 mov     large fs:0, eax
.text$mn:0000527F                 mov     [ebp+var_10], ecx
.text$mn:00005282                 mov     [ebp+var_4], 0
.text$mn:00005289                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005290                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005293                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00005298                 mov     ecx, [ebp+var_C]
.text$mn:0000529B                 mov     large fs:0, ecx
.text$mn:000052A2                 pop     ecx
.text$mn:000052A3                 mov     esp, ebp
.text$mn:000052A5                 pop     ebp
.text$mn:000052A6                 retn
.text$mn:000052A6 ??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ endp
.text$mn:000052A6
.text$mn:000052A6 ; ---------------------------------------------------------------------------
.text$mn:000052A7                 align 4
.text$mn:000052A7 _text$mn        ends
.text$mn:000052A7
.text$x:000052A8 ; ===========================================================================
.text$x:000052A8
.text$x:000052A8 ; Segment type: Pure code
.text$x:000052A8 ; Segment permissions: Read/Execute
.text$x:000052A8 _text$x         segment para public 'CODE' use32
.text$x:000052A8                 assume cs:_text$x
.text$x:000052A8                 ;org 52A8h
.text$x:000052A8 ; COMDAT (pick associative to section at 525C)
.text$x:000052A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000052A8
.text$x:000052A8 ; =============== S U B R O U T I N E =======================================
.text$x:000052A8
.text$x:000052A8
.text$x:000052A8 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000052A8                                         ; DATA XREF: .xdata$x:00009448o
.text$x:000052A8                 mov     ecx, [ebp-10h]  ; this
.text$x:000052AB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000052AB __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ$0 endp
.text$x:000052AB
.text$x:000052B0
.text$x:000052B0 ; =============== S U B R O U T I N E =======================================
.text$x:000052B0
.text$x:000052B0
.text$x:000052B0 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ proc near
.text$x:000052B0                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<HWND__ *>>::~_Vector_val<std::_Simple_types<HWND__ *>>(void)+5o
.text$x:000052B0
.text$x:000052B0 arg_4           = dword ptr  8
.text$x:000052B0
.text$x:000052B0                 mov     edx, [esp+arg_4]
.text$x:000052B4                 lea     eax, [edx+0Ch]
.text$x:000052B7                 mov     ecx, [edx-8]
.text$x:000052BA                 xor     ecx, eax
.text$x:000052BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000052C1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ
.text$x:000052C6                 jmp     ___CxxFrameHandler3
.text$x:000052C6 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ endp
.text$x:000052C6
.text$x:000052C6 ; ---------------------------------------------------------------------------
.text$x:000052CB                 align 4
.text$x:000052CB _text$x         ends
.text$x:000052CB
.text$mn:000052CC ; ===========================================================================
.text$mn:000052CC
.text$mn:000052CC ; Segment type: Pure code
.text$mn:000052CC ; Segment permissions: Read/Execute
.text$mn:000052CC _text$mn        segment para public 'CODE' use32
.text$mn:000052CC                 assume cs:_text$mn
.text$mn:000052CC                 ;org 52CCh
.text$mn:000052CC ; COMDAT (pick any)
.text$mn:000052CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000052CC
.text$mn:000052CC ; =============== S U B R O U T I N E =======================================
.text$mn:000052CC
.text$mn:000052CC ; Attributes: bp-based frame
.text$mn:000052CC
.text$mn:000052CC ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct tTbData *>>::~_Vector_val<struct std::_Simple_types<struct tTbData *>>(void)
.text$mn:000052CC                 public ??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ
.text$mn:000052CC ??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ proc near
.text$mn:000052CC                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z$0+3j
.text$mn:000052CC                                         ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::~_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>(void)+3Fp ...
.text$mn:000052CC
.text$mn:000052CC var_10          = dword ptr -10h
.text$mn:000052CC var_C           = dword ptr -0Ch
.text$mn:000052CC var_4           = dword ptr -4
.text$mn:000052CC
.text$mn:000052CC                 push    ebp
.text$mn:000052CD                 mov     ebp, esp
.text$mn:000052CF                 push    0FFFFFFFFh
.text$mn:000052D1                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ
.text$mn:000052D6                 mov     eax, large fs:0
.text$mn:000052DC                 push    eax
.text$mn:000052DD                 push    ecx
.text$mn:000052DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000052E3                 xor     eax, ebp
.text$mn:000052E5                 push    eax
.text$mn:000052E6                 lea     eax, [ebp+var_C]
.text$mn:000052E9                 mov     large fs:0, eax
.text$mn:000052EF                 mov     [ebp+var_10], ecx
.text$mn:000052F2                 mov     [ebp+var_4], 0
.text$mn:000052F9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005300                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005303                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00005308                 mov     ecx, [ebp+var_C]
.text$mn:0000530B                 mov     large fs:0, ecx
.text$mn:00005312                 pop     ecx
.text$mn:00005313                 mov     esp, ebp
.text$mn:00005315                 pop     ebp
.text$mn:00005316                 retn
.text$mn:00005316 ??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ endp
.text$mn:00005316
.text$mn:00005316 ; ---------------------------------------------------------------------------
.text$mn:00005317                 align 4
.text$mn:00005317 _text$mn        ends
.text$mn:00005317
.text$x:00005318 ; ===========================================================================
.text$x:00005318
.text$x:00005318 ; Segment type: Pure code
.text$x:00005318 ; Segment permissions: Read/Execute
.text$x:00005318 _text$x         segment para public 'CODE' use32
.text$x:00005318                 assume cs:_text$x
.text$x:00005318                 ;org 5318h
.text$x:00005318 ; COMDAT (pick associative to section at 52CC)
.text$x:00005318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005318
.text$x:00005318 ; =============== S U B R O U T I N E =======================================
.text$x:00005318
.text$x:00005318
.text$x:00005318 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005318                                         ; DATA XREF: .xdata$x:000090ECo
.text$x:00005318                 mov     ecx, [ebp-10h]  ; this
.text$x:0000531B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000531B __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000531B
.text$x:00005320
.text$x:00005320 ; =============== S U B R O U T I N E =======================================
.text$x:00005320
.text$x:00005320
.text$x:00005320 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ proc near
.text$x:00005320                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<tTbData *>>::~_Vector_val<std::_Simple_types<tTbData *>>(void)+5o
.text$x:00005320
.text$x:00005320 arg_4           = dword ptr  8
.text$x:00005320
.text$x:00005320                 mov     edx, [esp+arg_4]
.text$x:00005324                 lea     eax, [edx+0Ch]
.text$x:00005327                 mov     ecx, [edx-8]
.text$x:0000532A                 xor     ecx, eax
.text$x:0000532C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005331                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ
.text$x:00005336                 jmp     ___CxxFrameHandler3
.text$x:00005336 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ endp
.text$x:00005336
.text$x:00005336 ; ---------------------------------------------------------------------------
.text$x:0000533B                 align 4
.text$x:0000533B _text$x         ends
.text$x:0000533B
.text$mn:0000533C ; ===========================================================================
.text$mn:0000533C
.text$mn:0000533C ; Segment type: Pure code
.text$mn:0000533C ; Segment permissions: Read/Execute
.text$mn:0000533C _text$mn        segment para public 'CODE' use32
.text$mn:0000533C                 assume cs:_text$mn
.text$mn:0000533C                 ;org 533Ch
.text$mn:0000533C ; COMDAT (pick any)
.text$mn:0000533C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000533C
.text$mn:0000533C ; =============== S U B R O U T I N E =======================================
.text$mn:0000533C
.text$mn:0000533C ; Attributes: bp-based frame
.text$mn:0000533C
.text$mn:0000533C ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class DockingCont *>>::~_Vector_val<struct std::_Simple_types<class DockingCont *>>(void)
.text$mn:0000533C                 public ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:0000533C ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$mn:0000533C                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z$0+3j
.text$mn:0000533C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)+3Fp ...
.text$mn:0000533C
.text$mn:0000533C var_10          = dword ptr -10h
.text$mn:0000533C var_C           = dword ptr -0Ch
.text$mn:0000533C var_4           = dword ptr -4
.text$mn:0000533C
.text$mn:0000533C                 push    ebp
.text$mn:0000533D                 mov     ebp, esp
.text$mn:0000533F                 push    0FFFFFFFFh
.text$mn:00005341                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:00005346                 mov     eax, large fs:0
.text$mn:0000534C                 push    eax
.text$mn:0000534D                 push    ecx
.text$mn:0000534E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005353                 xor     eax, ebp
.text$mn:00005355                 push    eax
.text$mn:00005356                 lea     eax, [ebp+var_C]
.text$mn:00005359                 mov     large fs:0, eax
.text$mn:0000535F                 mov     [ebp+var_10], ecx
.text$mn:00005362                 mov     [ebp+var_4], 0
.text$mn:00005369                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005370                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005373                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00005378                 mov     ecx, [ebp+var_C]
.text$mn:0000537B                 mov     large fs:0, ecx
.text$mn:00005382                 pop     ecx
.text$mn:00005383                 mov     esp, ebp
.text$mn:00005385                 pop     ebp
.text$mn:00005386                 retn
.text$mn:00005386 ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$mn:00005386
.text$mn:00005386 ; ---------------------------------------------------------------------------
.text$mn:00005387                 align 4
.text$mn:00005387 _text$mn        ends
.text$mn:00005387
.text$x:00005388 ; ===========================================================================
.text$x:00005388
.text$x:00005388 ; Segment type: Pure code
.text$x:00005388 ; Segment permissions: Read/Execute
.text$x:00005388 _text$x         segment para public 'CODE' use32
.text$x:00005388                 assume cs:_text$x
.text$x:00005388                 ;org 5388h
.text$x:00005388 ; COMDAT (pick associative to section at 533C)
.text$x:00005388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005388
.text$x:00005388 ; =============== S U B R O U T I N E =======================================
.text$x:00005388
.text$x:00005388
.text$x:00005388 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005388                                         ; DATA XREF: .xdata$x:000095D4o
.text$x:00005388                 mov     ecx, [ebp-10h]  ; this
.text$x:0000538B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000538B __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000538B
.text$x:00005390
.text$x:00005390 ; =============== S U B R O U T I N E =======================================
.text$x:00005390
.text$x:00005390
.text$x:00005390 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$x:00005390                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<DockingCont *>>::~_Vector_val<std::_Simple_types<DockingCont *>>(void)+5o
.text$x:00005390
.text$x:00005390 arg_4           = dword ptr  8
.text$x:00005390
.text$x:00005390                 mov     edx, [esp+arg_4]
.text$x:00005394                 lea     eax, [edx+0Ch]
.text$x:00005397                 mov     ecx, [edx-8]
.text$x:0000539A                 xor     ecx, eax
.text$x:0000539C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000053A1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$x:000053A6                 jmp     ___CxxFrameHandler3
.text$x:000053A6 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$x:000053A6
.text$x:000053A6 ; ---------------------------------------------------------------------------
.text$x:000053AB                 align 4
.text$x:000053AB _text$x         ends
.text$x:000053AB
.text$mn:000053AC ; ===========================================================================
.text$mn:000053AC
.text$mn:000053AC ; Segment type: Pure code
.text$mn:000053AC ; Segment permissions: Read/Execute
.text$mn:000053AC _text$mn        segment para public 'CODE' use32
.text$mn:000053AC                 assume cs:_text$mn
.text$mn:000053AC                 ;org 53ACh
.text$mn:000053AC ; COMDAT (pick any)
.text$mn:000053AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000053AC
.text$mn:000053AC ; =============== S U B R O U T I N E =======================================
.text$mn:000053AC
.text$mn:000053AC ; Attributes: bp-based frame
.text$mn:000053AC
.text$mn:000053AC ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class DockingSplitter *>>::~_Vector_val<struct std::_Simple_types<class DockingSplitter *>>(void)
.text$mn:000053AC                 public ??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$mn:000053AC ??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ proc near
.text$mn:000053AC                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z$0+3j
.text$mn:000053AC                                         ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>(void)+3Fp ...
.text$mn:000053AC
.text$mn:000053AC var_10          = dword ptr -10h
.text$mn:000053AC var_C           = dword ptr -0Ch
.text$mn:000053AC var_4           = dword ptr -4
.text$mn:000053AC
.text$mn:000053AC                 push    ebp
.text$mn:000053AD                 mov     ebp, esp
.text$mn:000053AF                 push    0FFFFFFFFh
.text$mn:000053B1                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$mn:000053B6                 mov     eax, large fs:0
.text$mn:000053BC                 push    eax
.text$mn:000053BD                 push    ecx
.text$mn:000053BE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000053C3                 xor     eax, ebp
.text$mn:000053C5                 push    eax
.text$mn:000053C6                 lea     eax, [ebp+var_C]
.text$mn:000053C9                 mov     large fs:0, eax
.text$mn:000053CF                 mov     [ebp+var_10], ecx
.text$mn:000053D2                 mov     [ebp+var_4], 0
.text$mn:000053D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000053E0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000053E3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000053E8                 mov     ecx, [ebp+var_C]
.text$mn:000053EB                 mov     large fs:0, ecx
.text$mn:000053F2                 pop     ecx
.text$mn:000053F3                 mov     esp, ebp
.text$mn:000053F5                 pop     ebp
.text$mn:000053F6                 retn
.text$mn:000053F6 ??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ endp
.text$mn:000053F6
.text$mn:000053F6 ; ---------------------------------------------------------------------------
.text$mn:000053F7                 align 4
.text$mn:000053F7 _text$mn        ends
.text$mn:000053F7
.text$x:000053F8 ; ===========================================================================
.text$x:000053F8
.text$x:000053F8 ; Segment type: Pure code
.text$x:000053F8 ; Segment permissions: Read/Execute
.text$x:000053F8 _text$x         segment para public 'CODE' use32
.text$x:000053F8                 assume cs:_text$x
.text$x:000053F8                 ;org 53F8h
.text$x:000053F8 ; COMDAT (pick associative to section at 53AC)
.text$x:000053F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000053F8
.text$x:000053F8 ; =============== S U B R O U T I N E =======================================
.text$x:000053F8
.text$x:000053F8
.text$x:000053F8 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000053F8                                         ; DATA XREF: .xdata$x:00009760o
.text$x:000053F8                 mov     ecx, [ebp-10h]  ; this
.text$x:000053FB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000053FB __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0 endp
.text$x:000053FB
.text$x:00005400
.text$x:00005400 ; =============== S U B R O U T I N E =======================================
.text$x:00005400
.text$x:00005400
.text$x:00005400 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ proc near
.text$x:00005400                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<DockingSplitter *>>::~_Vector_val<std::_Simple_types<DockingSplitter *>>(void)+5o
.text$x:00005400
.text$x:00005400 arg_4           = dword ptr  8
.text$x:00005400
.text$x:00005400                 mov     edx, [esp+arg_4]
.text$x:00005404                 lea     eax, [edx+0Ch]
.text$x:00005407                 mov     ecx, [edx-8]
.text$x:0000540A                 xor     ecx, eax
.text$x:0000540C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005411                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$x:00005416                 jmp     ___CxxFrameHandler3
.text$x:00005416 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ endp
.text$x:00005416
.text$x:00005416 ; ---------------------------------------------------------------------------
.text$x:0000541B                 align 4
.text$x:0000541B _text$x         ends
.text$x:0000541B
.text$mn:0000541C ; ===========================================================================
.text$mn:0000541C
.text$mn:0000541C ; Segment type: Pure code
.text$mn:0000541C ; Segment permissions: Read/Execute
.text$mn:0000541C _text$mn        segment para public 'CODE' use32
.text$mn:0000541C                 assume cs:_text$mn
.text$mn:0000541C                 ;org 541Ch
.text$mn:0000541C ; COMDAT (pick any)
.text$mn:0000541C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000541C
.text$mn:0000541C ; =============== S U B R O U T I N E =======================================
.text$mn:0000541C
.text$mn:0000541C ; Attributes: bp-based frame
.text$mn:0000541C
.text$mn:0000541C ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:0000541C                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000541C ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:0000541C                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:0000541C                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:0000541C
.text$mn:0000541C var_10          = dword ptr -10h
.text$mn:0000541C var_C           = dword ptr -0Ch
.text$mn:0000541C var_4           = dword ptr -4
.text$mn:0000541C
.text$mn:0000541C                 push    ebp
.text$mn:0000541D                 mov     ebp, esp
.text$mn:0000541F                 push    0FFFFFFFFh
.text$mn:00005421                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00005426                 mov     eax, large fs:0
.text$mn:0000542C                 push    eax
.text$mn:0000542D                 push    ecx
.text$mn:0000542E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005433                 xor     eax, ebp
.text$mn:00005435                 push    eax
.text$mn:00005436                 lea     eax, [ebp+var_C]
.text$mn:00005439                 mov     large fs:0, eax
.text$mn:0000543F                 mov     [ebp+var_10], ecx
.text$mn:00005442                 mov     [ebp+var_4], 0
.text$mn:00005449                 push    0               ; Size
.text$mn:0000544B                 push    1               ; char
.text$mn:0000544D                 mov     ecx, [ebp+var_10]
.text$mn:00005450                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00005455                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000545C                 mov     ecx, [ebp+var_10]
.text$mn:0000545F                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00005464                 mov     ecx, [ebp+var_C]
.text$mn:00005467                 mov     large fs:0, ecx
.text$mn:0000546E                 pop     ecx
.text$mn:0000546F                 mov     esp, ebp
.text$mn:00005471                 pop     ebp
.text$mn:00005472                 retn
.text$mn:00005472 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00005472
.text$mn:00005472 ; ---------------------------------------------------------------------------
.text$mn:00005473                 align 4
.text$mn:00005473 _text$mn        ends
.text$mn:00005473
.text$x:00005474 ; ===========================================================================
.text$x:00005474
.text$x:00005474 ; Segment type: Pure code
.text$x:00005474 ; Segment permissions: Read/Execute
.text$x:00005474 _text$x         segment para public 'CODE' use32
.text$x:00005474                 assume cs:_text$x
.text$x:00005474                 ;org 5474h
.text$x:00005474 ; COMDAT (pick associative to section at 541C)
.text$x:00005474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005474
.text$x:00005474 ; =============== S U B R O U T I N E =======================================
.text$x:00005474
.text$x:00005474
.text$x:00005474 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00005474                                         ; DATA XREF: .xdata$x:00008DCCo
.text$x:00005474                 mov     ecx, [ebp-10h]
.text$x:00005477                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00005477 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00005477
.text$x:0000547C
.text$x:0000547C ; =============== S U B R O U T I N E =======================================
.text$x:0000547C
.text$x:0000547C
.text$x:0000547C __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:0000547C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:0000547C
.text$x:0000547C arg_4           = dword ptr  8
.text$x:0000547C
.text$x:0000547C                 mov     edx, [esp+arg_4]
.text$x:00005480                 lea     eax, [edx+0Ch]
.text$x:00005483                 mov     ecx, [edx-8]
.text$x:00005486                 xor     ecx, eax
.text$x:00005488                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000548D                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00005492                 jmp     ___CxxFrameHandler3
.text$x:00005492 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00005492
.text$x:00005492 ; ---------------------------------------------------------------------------
.text$x:00005497                 align 4
.text$x:00005497 _text$x         ends
.text$x:00005497
.text$mn:00005498 ; ===========================================================================
.text$mn:00005498
.text$mn:00005498 ; Segment type: Pure code
.text$mn:00005498 ; Segment permissions: Read/Execute
.text$mn:00005498 _text$mn        segment para public 'CODE' use32
.text$mn:00005498                 assume cs:_text$mn
.text$mn:00005498                 ;org 5498h
.text$mn:00005498 ; COMDAT (pick any)
.text$mn:00005498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005498
.text$mn:00005498 ; =============== S U B R O U T I N E =======================================
.text$mn:00005498
.text$mn:00005498 ; Attributes: bp-based frame
.text$mn:00005498
.text$mn:00005498 ; public: __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::~vector<struct HWND__ *, class std::allocator<struct HWND__ *>>(void)
.text$mn:00005498                 public ??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ
.text$mn:00005498 ??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ proc near
.text$mn:00005498                                         ; CODE XREF: DockingManager::~DockingManager(void)+BAp
.text$mn:00005498                                         ; __unwindfunclet$??0DockingManager@@QAE@XZ$1+6j ...
.text$mn:00005498
.text$mn:00005498 var_10          = dword ptr -10h
.text$mn:00005498 var_C           = dword ptr -0Ch
.text$mn:00005498 var_4           = dword ptr -4
.text$mn:00005498
.text$mn:00005498                 push    ebp
.text$mn:00005499                 mov     ebp, esp
.text$mn:0000549B                 push    0FFFFFFFFh
.text$mn:0000549D                 push    offset __ehhandler$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ
.text$mn:000054A2                 mov     eax, large fs:0
.text$mn:000054A8                 push    eax
.text$mn:000054A9                 push    ecx
.text$mn:000054AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000054AF                 xor     eax, ebp
.text$mn:000054B1                 push    eax
.text$mn:000054B2                 lea     eax, [ebp+var_C]
.text$mn:000054B5                 mov     large fs:0, eax
.text$mn:000054BB                 mov     [ebp+var_10], ecx
.text$mn:000054BE                 mov     [ebp+var_4], 0
.text$mn:000054C5                 mov     ecx, [ebp+var_10]
.text$mn:000054C8                 call    ?_Tidy@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Tidy(void)
.text$mn:000054CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000054D4                 mov     ecx, [ebp+var_10]
.text$mn:000054D7                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>(void)
.text$mn:000054DC                 mov     ecx, [ebp+var_C]
.text$mn:000054DF                 mov     large fs:0, ecx
.text$mn:000054E6                 pop     ecx
.text$mn:000054E7                 mov     esp, ebp
.text$mn:000054E9                 pop     ebp
.text$mn:000054EA                 retn
.text$mn:000054EA ??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ endp
.text$mn:000054EA
.text$mn:000054EA ; ---------------------------------------------------------------------------
.text$mn:000054EB                 align 4
.text$mn:000054EB _text$mn        ends
.text$mn:000054EB
.text$x:000054EC ; ===========================================================================
.text$x:000054EC
.text$x:000054EC ; Segment type: Pure code
.text$x:000054EC ; Segment permissions: Read/Execute
.text$x:000054EC _text$x         segment para public 'CODE' use32
.text$x:000054EC                 assume cs:_text$x
.text$x:000054EC                 ;org 54ECh
.text$x:000054EC ; COMDAT (pick associative to section at 5498)
.text$x:000054EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000054EC
.text$x:000054EC ; =============== S U B R O U T I N E =======================================
.text$x:000054EC
.text$x:000054EC
.text$x:000054EC __unwindfunclet$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000054EC                                         ; DATA XREF: .xdata$x:000094F8o
.text$x:000054EC                 mov     ecx, [ebp-10h]
.text$x:000054EF                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>(void)
.text$x:000054EF __unwindfunclet$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ$0 endp
.text$x:000054EF
.text$x:000054F4
.text$x:000054F4 ; =============== S U B R O U T I N E =======================================
.text$x:000054F4
.text$x:000054F4
.text$x:000054F4 __ehhandler$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ proc near
.text$x:000054F4                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::~vector<HWND__ *,std::allocator<HWND__ *>>(void)+5o
.text$x:000054F4
.text$x:000054F4 arg_4           = dword ptr  8
.text$x:000054F4
.text$x:000054F4                 mov     edx, [esp+arg_4]
.text$x:000054F8                 lea     eax, [edx+0Ch]
.text$x:000054FB                 mov     ecx, [edx-8]
.text$x:000054FE                 xor     ecx, eax
.text$x:00005500                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005505                 mov     eax, offset __ehfuncinfo$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ
.text$x:0000550A                 jmp     ___CxxFrameHandler3
.text$x:0000550A __ehhandler$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ endp
.text$x:0000550A
.text$x:0000550A ; ---------------------------------------------------------------------------
.text$x:0000550F                 align 10h
.text$x:0000550F _text$x         ends
.text$x:0000550F
.text$mn:00005510 ; ===========================================================================
.text$mn:00005510
.text$mn:00005510 ; Segment type: Pure code
.text$mn:00005510 ; Segment permissions: Read/Execute
.text$mn:00005510 _text$mn        segment para public 'CODE' use32
.text$mn:00005510                 assume cs:_text$mn
.text$mn:00005510                 ;org 5510h
.text$mn:00005510 ; COMDAT (pick any)
.text$mn:00005510                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005510
.text$mn:00005510 ; =============== S U B R O U T I N E =======================================
.text$mn:00005510
.text$mn:00005510 ; Attributes: bp-based frame
.text$mn:00005510
.text$mn:00005510 ; public: __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::~vector<struct tTbData *, class std::allocator<struct tTbData *>>(void)
.text$mn:00005510                 public ??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ
.text$mn:00005510 ??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ proc near
.text$mn:00005510                                         ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+27Cp
.text$mn:00005510                                         ; DockingManager::toggleVisTb(DockingCont *,DockingCont *)+D3p ...
.text$mn:00005510
.text$mn:00005510 var_10          = dword ptr -10h
.text$mn:00005510 var_C           = dword ptr -0Ch
.text$mn:00005510 var_4           = dword ptr -4
.text$mn:00005510
.text$mn:00005510                 push    ebp
.text$mn:00005511                 mov     ebp, esp
.text$mn:00005513                 push    0FFFFFFFFh
.text$mn:00005515                 push    offset __ehhandler$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ
.text$mn:0000551A                 mov     eax, large fs:0
.text$mn:00005520                 push    eax
.text$mn:00005521                 push    ecx
.text$mn:00005522                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005527                 xor     eax, ebp
.text$mn:00005529                 push    eax
.text$mn:0000552A                 lea     eax, [ebp+var_C]
.text$mn:0000552D                 mov     large fs:0, eax
.text$mn:00005533                 mov     [ebp+var_10], ecx
.text$mn:00005536                 mov     [ebp+var_4], 0
.text$mn:0000553D                 mov     ecx, [ebp+var_10]
.text$mn:00005540                 call    ?_Tidy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEXXZ ; std::vector<tTbData *,std::allocator<tTbData *>>::_Tidy(void)
.text$mn:00005545                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000554C                 mov     ecx, [ebp+var_10]
.text$mn:0000554F                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::~_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>(void)
.text$mn:00005554                 mov     ecx, [ebp+var_C]
.text$mn:00005557                 mov     large fs:0, ecx
.text$mn:0000555E                 pop     ecx
.text$mn:0000555F                 mov     esp, ebp
.text$mn:00005561                 pop     ebp
.text$mn:00005562                 retn
.text$mn:00005562 ??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ endp
.text$mn:00005562
.text$mn:00005562 ; ---------------------------------------------------------------------------
.text$mn:00005563                 align 4
.text$mn:00005563 _text$mn        ends
.text$mn:00005563
.text$x:00005564 ; ===========================================================================
.text$x:00005564
.text$x:00005564 ; Segment type: Pure code
.text$x:00005564 ; Segment permissions: Read/Execute
.text$x:00005564 _text$x         segment para public 'CODE' use32
.text$x:00005564                 assume cs:_text$x
.text$x:00005564                 ;org 5564h
.text$x:00005564 ; COMDAT (pick associative to section at 5510)
.text$x:00005564                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005564
.text$x:00005564 ; =============== S U B R O U T I N E =======================================
.text$x:00005564
.text$x:00005564
.text$x:00005564 __unwindfunclet$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005564                                         ; DATA XREF: .xdata$x:000091E0o
.text$x:00005564                 mov     ecx, [ebp-10h]
.text$x:00005567                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::~_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>(void)
.text$x:00005567 __unwindfunclet$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005567
.text$x:0000556C
.text$x:0000556C ; =============== S U B R O U T I N E =======================================
.text$x:0000556C
.text$x:0000556C
.text$x:0000556C __ehhandler$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ proc near
.text$x:0000556C                                         ; DATA XREF: std::vector<tTbData *,std::allocator<tTbData *>>::~vector<tTbData *,std::allocator<tTbData *>>(void)+5o
.text$x:0000556C
.text$x:0000556C arg_4           = dword ptr  8
.text$x:0000556C
.text$x:0000556C                 mov     edx, [esp+arg_4]
.text$x:00005570                 lea     eax, [edx+0Ch]
.text$x:00005573                 mov     ecx, [edx-8]
.text$x:00005576                 xor     ecx, eax
.text$x:00005578                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000557D                 mov     eax, offset __ehfuncinfo$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ
.text$x:00005582                 jmp     ___CxxFrameHandler3
.text$x:00005582 __ehhandler$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ endp
.text$x:00005582
.text$x:00005582 ; ---------------------------------------------------------------------------
.text$x:00005587                 align 4
.text$x:00005587 _text$x         ends
.text$x:00005587
.text$mn:00005588 ; ===========================================================================
.text$mn:00005588
.text$mn:00005588 ; Segment type: Pure code
.text$mn:00005588 ; Segment permissions: Read/Execute
.text$mn:00005588 _text$mn        segment para public 'CODE' use32
.text$mn:00005588                 assume cs:_text$mn
.text$mn:00005588                 ;org 5588h
.text$mn:00005588 ; COMDAT (pick any)
.text$mn:00005588                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005588
.text$mn:00005588 ; =============== S U B R O U T I N E =======================================
.text$mn:00005588
.text$mn:00005588 ; Attributes: bp-based frame
.text$mn:00005588
.text$mn:00005588 ; public: __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::~vector<class DockingCont *, class std::allocator<class DockingCont *>>(void)
.text$mn:00005588                 public ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:00005588 ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$mn:00005588                                         ; CODE XREF: DockingManager::~DockingManager(void)+ABp
.text$mn:00005588                                         ; __unwindfunclet$??0DockingManager@@QAE@XZ$2+6j ...
.text$mn:00005588
.text$mn:00005588 var_10          = dword ptr -10h
.text$mn:00005588 var_C           = dword ptr -0Ch
.text$mn:00005588 var_4           = dword ptr -4
.text$mn:00005588
.text$mn:00005588                 push    ebp
.text$mn:00005589                 mov     ebp, esp
.text$mn:0000558B                 push    0FFFFFFFFh
.text$mn:0000558D                 push    offset __ehhandler$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:00005592                 mov     eax, large fs:0
.text$mn:00005598                 push    eax
.text$mn:00005599                 push    ecx
.text$mn:0000559A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000559F                 xor     eax, ebp
.text$mn:000055A1                 push    eax
.text$mn:000055A2                 lea     eax, [ebp+var_C]
.text$mn:000055A5                 mov     large fs:0, eax
.text$mn:000055AB                 mov     [ebp+var_10], ecx
.text$mn:000055AE                 mov     [ebp+var_4], 0
.text$mn:000055B5                 mov     ecx, [ebp+var_10]
.text$mn:000055B8                 call    ?_Tidy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Tidy(void)
.text$mn:000055BD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000055C4                 mov     ecx, [ebp+var_10]
.text$mn:000055C7                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)
.text$mn:000055CC                 mov     ecx, [ebp+var_C]
.text$mn:000055CF                 mov     large fs:0, ecx
.text$mn:000055D6                 pop     ecx
.text$mn:000055D7                 mov     esp, ebp
.text$mn:000055D9                 pop     ebp
.text$mn:000055DA                 retn
.text$mn:000055DA ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$mn:000055DA
.text$mn:000055DA ; ---------------------------------------------------------------------------
.text$mn:000055DB                 align 4
.text$mn:000055DB _text$mn        ends
.text$mn:000055DB
.text$x:000055DC ; ===========================================================================
.text$x:000055DC
.text$x:000055DC ; Segment type: Pure code
.text$x:000055DC ; Segment permissions: Read/Execute
.text$x:000055DC _text$x         segment para public 'CODE' use32
.text$x:000055DC                 assume cs:_text$x
.text$x:000055DC                 ;org 55DCh
.text$x:000055DC ; COMDAT (pick associative to section at 5588)
.text$x:000055DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000055DC
.text$x:000055DC ; =============== S U B R O U T I N E =======================================
.text$x:000055DC
.text$x:000055DC
.text$x:000055DC __unwindfunclet$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000055DC                                         ; DATA XREF: .xdata$x:00009684o
.text$x:000055DC                 mov     ecx, [ebp-10h]
.text$x:000055DF                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)
.text$x:000055DF __unwindfunclet$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ$0 endp
.text$x:000055DF
.text$x:000055E4
.text$x:000055E4 ; =============== S U B R O U T I N E =======================================
.text$x:000055E4
.text$x:000055E4
.text$x:000055E4 __ehhandler$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$x:000055E4                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)+5o
.text$x:000055E4
.text$x:000055E4 arg_4           = dword ptr  8
.text$x:000055E4
.text$x:000055E4                 mov     edx, [esp+arg_4]
.text$x:000055E8                 lea     eax, [edx+0Ch]
.text$x:000055EB                 mov     ecx, [edx-8]
.text$x:000055EE                 xor     ecx, eax
.text$x:000055F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000055F5                 mov     eax, offset __ehfuncinfo$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$x:000055FA                 jmp     ___CxxFrameHandler3
.text$x:000055FA __ehhandler$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$x:000055FA
.text$x:000055FA ; ---------------------------------------------------------------------------
.text$x:000055FF                 align 10h
.text$x:000055FF _text$x         ends
.text$x:000055FF
.text$mn:00005600 ; ===========================================================================
.text$mn:00005600
.text$mn:00005600 ; Segment type: Pure code
.text$mn:00005600 ; Segment permissions: Read/Execute
.text$mn:00005600 _text$mn        segment para public 'CODE' use32
.text$mn:00005600                 assume cs:_text$mn
.text$mn:00005600                 ;org 5600h
.text$mn:00005600 ; COMDAT (pick any)
.text$mn:00005600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005600
.text$mn:00005600 ; =============== S U B R O U T I N E =======================================
.text$mn:00005600
.text$mn:00005600 ; Attributes: bp-based frame
.text$mn:00005600
.text$mn:00005600 ; public: __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::~vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>(void)
.text$mn:00005600                 public ??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$mn:00005600 ??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ proc near
.text$mn:00005600                                         ; CODE XREF: DockingManager::~DockingManager(void)+9Cp
.text$mn:00005600                                         ; __unwindfunclet$??0DockingManager@@QAE@XZ$3+9j ...
.text$mn:00005600
.text$mn:00005600 var_10          = dword ptr -10h
.text$mn:00005600 var_C           = dword ptr -0Ch
.text$mn:00005600 var_4           = dword ptr -4
.text$mn:00005600
.text$mn:00005600                 push    ebp
.text$mn:00005601                 mov     ebp, esp
.text$mn:00005603                 push    0FFFFFFFFh
.text$mn:00005605                 push    offset __ehhandler$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$mn:0000560A                 mov     eax, large fs:0
.text$mn:00005610                 push    eax
.text$mn:00005611                 push    ecx
.text$mn:00005612                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005617                 xor     eax, ebp
.text$mn:00005619                 push    eax
.text$mn:0000561A                 lea     eax, [ebp+var_C]
.text$mn:0000561D                 mov     large fs:0, eax
.text$mn:00005623                 mov     [ebp+var_10], ecx
.text$mn:00005626                 mov     [ebp+var_4], 0
.text$mn:0000562D                 mov     ecx, [ebp+var_10]
.text$mn:00005630                 call    ?_Tidy@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXXZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Tidy(void)
.text$mn:00005635                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000563C                 mov     ecx, [ebp+var_10]
.text$mn:0000563F                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>(void)
.text$mn:00005644                 mov     ecx, [ebp+var_C]
.text$mn:00005647                 mov     large fs:0, ecx
.text$mn:0000564E                 pop     ecx
.text$mn:0000564F                 mov     esp, ebp
.text$mn:00005651                 pop     ebp
.text$mn:00005652                 retn
.text$mn:00005652 ??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ endp
.text$mn:00005652
.text$mn:00005652 ; ---------------------------------------------------------------------------
.text$mn:00005653                 align 4
.text$mn:00005653 _text$mn        ends
.text$mn:00005653
.text$x:00005654 ; ===========================================================================
.text$x:00005654
.text$x:00005654 ; Segment type: Pure code
.text$x:00005654 ; Segment permissions: Read/Execute
.text$x:00005654 _text$x         segment para public 'CODE' use32
.text$x:00005654                 assume cs:_text$x
.text$x:00005654                 ;org 5654h
.text$x:00005654 ; COMDAT (pick associative to section at 5600)
.text$x:00005654                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005654
.text$x:00005654 ; =============== S U B R O U T I N E =======================================
.text$x:00005654
.text$x:00005654
.text$x:00005654 __unwindfunclet$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005654                                         ; DATA XREF: .xdata$x:00009810o
.text$x:00005654                 mov     ecx, [ebp-10h]
.text$x:00005657                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>(void)
.text$x:00005657 __unwindfunclet$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005657
.text$x:0000565C
.text$x:0000565C ; =============== S U B R O U T I N E =======================================
.text$x:0000565C
.text$x:0000565C
.text$x:0000565C __ehhandler$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ proc near
.text$x:0000565C                                         ; DATA XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::~vector<DockingSplitter *,std::allocator<DockingSplitter *>>(void)+5o
.text$x:0000565C
.text$x:0000565C arg_4           = dword ptr  8
.text$x:0000565C
.text$x:0000565C                 mov     edx, [esp+arg_4]
.text$x:00005660                 lea     eax, [edx+0Ch]
.text$x:00005663                 mov     ecx, [edx-8]
.text$x:00005666                 xor     ecx, eax
.text$x:00005668                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000566D                 mov     eax, offset __ehfuncinfo$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.text$x:00005672                 jmp     ___CxxFrameHandler3
.text$x:00005672 __ehhandler$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ endp
.text$x:00005672
.text$x:00005672 ; ---------------------------------------------------------------------------
.text$x:00005677                 align 4
.text$x:00005677 _text$x         ends
.text$x:00005677
.text$mn:00005678 ; ===========================================================================
.text$mn:00005678
.text$mn:00005678 ; Segment type: Pure code
.text$mn:00005678 ; Segment permissions: Read/Execute
.text$mn:00005678 _text$mn        segment para public 'CODE' use32
.text$mn:00005678                 assume cs:_text$mn
.text$mn:00005678                 ;org 5678h
.text$mn:00005678 ; COMDAT (pick any)
.text$mn:00005678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005678
.text$mn:00005678 ; =============== S U B R O U T I N E =======================================
.text$mn:00005678
.text$mn:00005678 ; Attributes: bp-based frame
.text$mn:00005678
.text$mn:00005678 ; _DWORD __thiscall DockingSplitter::~DockingSplitter(DockingSplitter *__hidden this)
.text$mn:00005678                 public ??1DockingSplitter@@UAE@XZ
.text$mn:00005678 ??1DockingSplitter@@UAE@XZ proc near    ; CODE XREF: DockingSplitter::`scalar deleting destructor'(uint)+Ap
.text$mn:00005678
.text$mn:00005678 var_10          = dword ptr -10h
.text$mn:00005678 var_C           = dword ptr -0Ch
.text$mn:00005678 var_4           = dword ptr -4
.text$mn:00005678
.text$mn:00005678                 push    ebp
.text$mn:00005679                 mov     ebp, esp
.text$mn:0000567B                 push    0FFFFFFFFh
.text$mn:0000567D                 push    offset __ehhandler$??1DockingSplitter@@UAE@XZ
.text$mn:00005682                 mov     eax, large fs:0
.text$mn:00005688                 push    eax
.text$mn:00005689                 push    ecx
.text$mn:0000568A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000568F                 xor     eax, ebp
.text$mn:00005691                 push    eax
.text$mn:00005692                 lea     eax, [ebp+var_C]
.text$mn:00005695                 mov     large fs:0, eax
.text$mn:0000569B                 mov     [ebp+var_10], ecx
.text$mn:0000569E                 mov     eax, [ebp+var_10]
.text$mn:000056A1                 mov     dword ptr [eax], offset ??_7DockingSplitter@@6B@ ; const DockingSplitter::`vftable'
.text$mn:000056A7                 mov     [ebp+var_4], 0
.text$mn:000056AE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000056B5                 mov     ecx, [ebp+var_10] ; this
.text$mn:000056B8                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:000056BD                 mov     ecx, [ebp+var_C]
.text$mn:000056C0                 mov     large fs:0, ecx
.text$mn:000056C7                 pop     ecx
.text$mn:000056C8                 mov     esp, ebp
.text$mn:000056CA                 pop     ebp
.text$mn:000056CB                 retn
.text$mn:000056CB ??1DockingSplitter@@UAE@XZ endp
.text$mn:000056CB
.text$mn:000056CB _text$mn        ends
.text$mn:000056CB
.text$x:000056CC ; ===========================================================================
.text$x:000056CC
.text$x:000056CC ; Segment type: Pure code
.text$x:000056CC ; Segment permissions: Read/Execute
.text$x:000056CC _text$x         segment para public 'CODE' use32
.text$x:000056CC                 assume cs:_text$x
.text$x:000056CC                 ;org 56CCh
.text$x:000056CC ; COMDAT (pick associative to section at 5678)
.text$x:000056CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000056CC
.text$x:000056CC ; =============== S U B R O U T I N E =======================================
.text$x:000056CC
.text$x:000056CC
.text$x:000056CC __unwindfunclet$??1DockingSplitter@@UAE@XZ$0 proc near
.text$x:000056CC                                         ; DATA XREF: .xdata$x:000098ECo
.text$x:000056CC                 mov     ecx, [ebp-10h]  ; this
.text$x:000056CF                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:000056CF __unwindfunclet$??1DockingSplitter@@UAE@XZ$0 endp
.text$x:000056CF
.text$x:000056D4
.text$x:000056D4 ; =============== S U B R O U T I N E =======================================
.text$x:000056D4
.text$x:000056D4
.text$x:000056D4 __ehhandler$??1DockingSplitter@@UAE@XZ proc near
.text$x:000056D4                                         ; DATA XREF: DockingSplitter::~DockingSplitter(void)+5o
.text$x:000056D4
.text$x:000056D4 arg_4           = dword ptr  8
.text$x:000056D4
.text$x:000056D4                 mov     edx, [esp+arg_4]
.text$x:000056D8                 lea     eax, [edx+0Ch]
.text$x:000056DB                 mov     ecx, [edx-8]
.text$x:000056DE                 xor     ecx, eax
.text$x:000056E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000056E5                 mov     eax, offset __ehfuncinfo$??1DockingSplitter@@UAE@XZ
.text$x:000056EA                 jmp     ___CxxFrameHandler3
.text$x:000056EA __ehhandler$??1DockingSplitter@@UAE@XZ endp
.text$x:000056EA
.text$x:000056EA ; ---------------------------------------------------------------------------
.text$x:000056EF                 align 10h
.text$x:000056EF _text$x         ends
.text$x:000056EF
.text$mn:000056F0 ; ===========================================================================
.text$mn:000056F0
.text$mn:000056F0 ; Segment type: Pure code
.text$mn:000056F0 ; Segment permissions: Read/Execute
.text$mn:000056F0 _text$mn        segment para public 'CODE' use32
.text$mn:000056F0                 assume cs:_text$mn
.text$mn:000056F0                 ;org 56F0h
.text$mn:000056F0 ; COMDAT (pick any)
.text$mn:000056F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056F0
.text$mn:000056F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000056F0
.text$mn:000056F0 ; Attributes: bp-based frame
.text$mn:000056F0
.text$mn:000056F0 ; _DWORD __thiscall Window::~Window(Window *__hidden this)
.text$mn:000056F0                 public ??1Window@@UAE@XZ
.text$mn:000056F0 ??1Window@@UAE@XZ proc near             ; CODE XREF: DockingManager::~DockingManager(void)+C9p
.text$mn:000056F0                                         ; __unwindfunclet$??0DockingManager@@QAE@XZ$0+3j ...
.text$mn:000056F0
.text$mn:000056F0 var_4           = dword ptr -4
.text$mn:000056F0
.text$mn:000056F0                 push    ebp
.text$mn:000056F1                 mov     ebp, esp
.text$mn:000056F3                 push    ecx
.text$mn:000056F4                 mov     [ebp+var_4], ecx
.text$mn:000056F7                 mov     eax, [ebp+var_4]
.text$mn:000056FA                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00005700                 mov     esp, ebp
.text$mn:00005702                 pop     ebp
.text$mn:00005703                 retn
.text$mn:00005703 ??1Window@@UAE@XZ endp
.text$mn:00005703
.text$mn:00005703 _text$mn        ends
.text$mn:00005703
.text$mn:00005704 ; ===========================================================================
.text$mn:00005704
.text$mn:00005704 ; Segment type: Pure code
.text$mn:00005704 ; Segment permissions: Read/Execute
.text$mn:00005704 _text$mn        segment para public 'CODE' use32
.text$mn:00005704                 assume cs:_text$mn
.text$mn:00005704                 ;org 5704h
.text$mn:00005704 ; COMDAT (pick any)
.text$mn:00005704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005704
.text$mn:00005704 ; =============== S U B R O U T I N E =======================================
.text$mn:00005704
.text$mn:00005704 ; Attributes: bp-based frame
.text$mn:00005704
.text$mn:00005704 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00005704                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00005704 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00005704                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00005704                                         ; __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00005704
.text$mn:00005704 var_4           = dword ptr -4
.text$mn:00005704
.text$mn:00005704                 push    ebp
.text$mn:00005705                 mov     ebp, esp
.text$mn:00005707                 push    ecx
.text$mn:00005708                 mov     [ebp+var_4], ecx
.text$mn:0000570B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000570E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00005713                 mov     esp, ebp
.text$mn:00005715                 pop     ebp
.text$mn:00005716                 retn
.text$mn:00005716 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00005716
.text$mn:00005716 ; ---------------------------------------------------------------------------
.text$mn:00005717                 align 4
.text$mn:00005717 _text$mn        ends
.text$mn:00005717
.text$mn:00005718 ; ===========================================================================
.text$mn:00005718
.text$mn:00005718 ; Segment type: Pure code
.text$mn:00005718 ; Segment permissions: Read/Execute
.text$mn:00005718 _text$mn        segment para public 'CODE' use32
.text$mn:00005718                 assume cs:_text$mn
.text$mn:00005718                 ;org 5718h
.text$mn:00005718 ; COMDAT (pick any)
.text$mn:00005718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005718
.text$mn:00005718 ; =============== S U B R O U T I N E =======================================
.text$mn:00005718
.text$mn:00005718 ; Attributes: bp-based frame
.text$mn:00005718
.text$mn:00005718 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00005718                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00005718 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00005718                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00005718                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00005718
.text$mn:00005718 var_10          = dword ptr -10h
.text$mn:00005718 var_C           = dword ptr -0Ch
.text$mn:00005718 var_4           = dword ptr -4
.text$mn:00005718
.text$mn:00005718                 push    ebp
.text$mn:00005719                 mov     ebp, esp
.text$mn:0000571B                 push    0FFFFFFFFh
.text$mn:0000571D                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00005722                 mov     eax, large fs:0
.text$mn:00005728                 push    eax
.text$mn:00005729                 push    ecx
.text$mn:0000572A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000572F                 xor     eax, ebp
.text$mn:00005731                 push    eax
.text$mn:00005732                 lea     eax, [ebp+var_C]
.text$mn:00005735                 mov     large fs:0, eax
.text$mn:0000573B                 mov     [ebp+var_10], ecx
.text$mn:0000573E                 mov     [ebp+var_4], 0
.text$mn:00005745                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000574C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000574F                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00005754                 mov     ecx, [ebp+var_C]
.text$mn:00005757                 mov     large fs:0, ecx
.text$mn:0000575E                 pop     ecx
.text$mn:0000575F                 mov     esp, ebp
.text$mn:00005761                 pop     ebp
.text$mn:00005762                 retn
.text$mn:00005762 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00005762
.text$mn:00005762 ; ---------------------------------------------------------------------------
.text$mn:00005763                 align 4
.text$mn:00005763 _text$mn        ends
.text$mn:00005763
.text$x:00005764 ; ===========================================================================
.text$x:00005764
.text$x:00005764 ; Segment type: Pure code
.text$x:00005764 ; Segment permissions: Read/Execute
.text$x:00005764 _text$x         segment para public 'CODE' use32
.text$x:00005764                 assume cs:_text$x
.text$x:00005764                 ;org 5764h
.text$x:00005764 ; COMDAT (pick associative to section at 5718)
.text$x:00005764                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005764
.text$x:00005764 ; =============== S U B R O U T I N E =======================================
.text$x:00005764
.text$x:00005764
.text$x:00005764 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00005764                                         ; DATA XREF: .xdata$x:00008F60o
.text$x:00005764                 mov     ecx, [ebp-10h]  ; this
.text$x:00005767                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00005767 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00005767
.text$x:0000576C
.text$x:0000576C ; =============== S U B R O U T I N E =======================================
.text$x:0000576C
.text$x:0000576C
.text$x:0000576C __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:0000576C                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:0000576C
.text$x:0000576C arg_4           = dword ptr  8
.text$x:0000576C
.text$x:0000576C                 mov     edx, [esp+arg_4]
.text$x:00005770                 lea     eax, [edx+0Ch]
.text$x:00005773                 mov     ecx, [edx-8]
.text$x:00005776                 xor     ecx, eax
.text$x:00005778                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000577D                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00005782                 jmp     ___CxxFrameHandler3
.text$x:00005782 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00005782
.text$x:00005782 ; ---------------------------------------------------------------------------
.text$x:00005787                 align 4
.text$x:00005787 _text$x         ends
.text$x:00005787
.text$mn:00005788 ; ===========================================================================
.text$mn:00005788
.text$mn:00005788 ; Segment type: Pure code
.text$mn:00005788 ; Segment permissions: Read/Execute
.text$mn:00005788 _text$mn        segment para public 'CODE' use32
.text$mn:00005788                 assume cs:_text$mn
.text$mn:00005788                 ;org 5788h
.text$mn:00005788 ; COMDAT (pick any)
.text$mn:00005788                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005788
.text$mn:00005788 ; =============== S U B R O U T I N E =======================================
.text$mn:00005788
.text$mn:00005788 ; Attributes: bp-based frame
.text$mn:00005788
.text$mn:00005788 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00005788                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00005788 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00005788                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00005788                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00005788
.text$mn:00005788 var_10          = dword ptr -10h
.text$mn:00005788 var_C           = dword ptr -0Ch
.text$mn:00005788 var_4           = dword ptr -4
.text$mn:00005788
.text$mn:00005788                 push    ebp
.text$mn:00005789                 mov     ebp, esp
.text$mn:0000578B                 push    0FFFFFFFFh
.text$mn:0000578D                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00005792                 mov     eax, large fs:0
.text$mn:00005798                 push    eax
.text$mn:00005799                 push    ecx
.text$mn:0000579A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000579F                 xor     eax, ebp
.text$mn:000057A1                 push    eax
.text$mn:000057A2                 lea     eax, [ebp+var_C]
.text$mn:000057A5                 mov     large fs:0, eax
.text$mn:000057AB                 mov     [ebp+var_10], ecx
.text$mn:000057AE                 mov     [ebp+var_4], 0
.text$mn:000057B5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000057BC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000057BF                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000057C4                 mov     ecx, [ebp+var_C]
.text$mn:000057C7                 mov     large fs:0, ecx
.text$mn:000057CE                 pop     ecx
.text$mn:000057CF                 mov     esp, ebp
.text$mn:000057D1                 pop     ebp
.text$mn:000057D2                 retn
.text$mn:000057D2 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:000057D2
.text$mn:000057D2 ; ---------------------------------------------------------------------------
.text$mn:000057D3                 align 4
.text$mn:000057D3 _text$mn        ends
.text$mn:000057D3
.text$x:000057D4 ; ===========================================================================
.text$x:000057D4
.text$x:000057D4 ; Segment type: Pure code
.text$x:000057D4 ; Segment permissions: Read/Execute
.text$x:000057D4 _text$x         segment para public 'CODE' use32
.text$x:000057D4                 assume cs:_text$x
.text$x:000057D4                 ;org 57D4h
.text$x:000057D4 ; COMDAT (pick associative to section at 5788)
.text$x:000057D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000057D4
.text$x:000057D4 ; =============== S U B R O U T I N E =======================================
.text$x:000057D4
.text$x:000057D4
.text$x:000057D4 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:000057D4                                         ; DATA XREF: .xdata$x:00008FE4o
.text$x:000057D4                 mov     ecx, [ebp-10h]  ; this
.text$x:000057D7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000057D7 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:000057D7
.text$x:000057DC
.text$x:000057DC ; =============== S U B R O U T I N E =======================================
.text$x:000057DC
.text$x:000057DC
.text$x:000057DC __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:000057DC                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:000057DC
.text$x:000057DC arg_4           = dword ptr  8
.text$x:000057DC
.text$x:000057DC                 mov     edx, [esp+arg_4]
.text$x:000057E0                 lea     eax, [edx+0Ch]
.text$x:000057E3                 mov     ecx, [edx-8]
.text$x:000057E6                 xor     ecx, eax
.text$x:000057E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000057ED                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:000057F2                 jmp     ___CxxFrameHandler3
.text$x:000057F2 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:000057F2
.text$x:000057F2 ; ---------------------------------------------------------------------------
.text$x:000057F7                 align 4
.text$x:000057F7 _text$x         ends
.text$x:000057F7
.text$mn:000057F8 ; ===========================================================================
.text$mn:000057F8
.text$mn:000057F8 ; Segment type: Pure code
.text$mn:000057F8 ; Segment permissions: Read/Execute
.text$mn:000057F8 _text$mn        segment para public 'CODE' use32
.text$mn:000057F8                 assume cs:_text$mn
.text$mn:000057F8                 ;org 57F8h
.text$mn:000057F8 ; COMDAT (pick any)
.text$mn:000057F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057F8
.text$mn:000057F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000057F8
.text$mn:000057F8 ; Attributes: bp-based frame
.text$mn:000057F8
.text$mn:000057F8 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:000057F8                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:000057F8 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:000057F8                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:000057F8                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:000057F8
.text$mn:000057F8 var_14          = byte ptr -14h
.text$mn:000057F8 var_10          = dword ptr -10h
.text$mn:000057F8 var_C           = dword ptr -0Ch
.text$mn:000057F8 var_4           = dword ptr -4
.text$mn:000057F8
.text$mn:000057F8                 push    ebp
.text$mn:000057F9                 mov     ebp, esp
.text$mn:000057FB                 push    0FFFFFFFFh
.text$mn:000057FD                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00005802                 mov     eax, large fs:0
.text$mn:00005808                 push    eax
.text$mn:00005809                 sub     esp, 8
.text$mn:0000580C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005811                 xor     eax, ebp
.text$mn:00005813                 push    eax
.text$mn:00005814                 lea     eax, [ebp+var_C]
.text$mn:00005817                 mov     large fs:0, eax
.text$mn:0000581D                 mov     [ebp+var_10], ecx
.text$mn:00005820                 push    3               ; int
.text$mn:00005822                 lea     ecx, [ebp+var_14] ; this
.text$mn:00005825                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000582A                 mov     [ebp+var_4], 0
.text$mn:00005831                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005834                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00005839                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005840                 lea     ecx, [ebp+var_14] ; this
.text$mn:00005843                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00005848                 mov     ecx, [ebp+var_C]
.text$mn:0000584B                 mov     large fs:0, ecx
.text$mn:00005852                 pop     ecx
.text$mn:00005853                 mov     esp, ebp
.text$mn:00005855                 pop     ebp
.text$mn:00005856                 retn
.text$mn:00005856 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:00005856
.text$mn:00005856 ; ---------------------------------------------------------------------------
.text$mn:00005857                 align 4
.text$mn:00005857 _text$mn        ends
.text$mn:00005857
.text$x:00005858 ; ===========================================================================
.text$x:00005858
.text$x:00005858 ; Segment type: Pure code
.text$x:00005858 ; Segment permissions: Read/Execute
.text$x:00005858 _text$x         segment para public 'CODE' use32
.text$x:00005858                 assume cs:_text$x
.text$x:00005858                 ;org 5858h
.text$x:00005858 ; COMDAT (pick associative to section at 57F8)
.text$x:00005858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005858
.text$x:00005858 ; =============== S U B R O U T I N E =======================================
.text$x:00005858
.text$x:00005858
.text$x:00005858 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:00005858                                         ; DATA XREF: .xdata$x:00008C90o
.text$x:00005858                 lea     ecx, [ebp-14h]  ; this
.text$x:0000585B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000585B __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:0000585B
.text$x:00005860
.text$x:00005860 ; =============== S U B R O U T I N E =======================================
.text$x:00005860
.text$x:00005860
.text$x:00005860 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:00005860                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:00005860
.text$x:00005860 arg_4           = dword ptr  8
.text$x:00005860
.text$x:00005860                 mov     edx, [esp+arg_4]
.text$x:00005864                 lea     eax, [edx+0Ch]
.text$x:00005867                 mov     ecx, [edx-0Ch]
.text$x:0000586A                 xor     ecx, eax
.text$x:0000586C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005871                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00005876                 jmp     ___CxxFrameHandler3
.text$x:00005876 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00005876
.text$x:00005876 ; ---------------------------------------------------------------------------
.text$x:0000587B                 align 4
.text$x:0000587B _text$x         ends
.text$x:0000587B
.text$mn:0000587C ; ===========================================================================
.text$mn:0000587C
.text$mn:0000587C ; Segment type: Pure code
.text$mn:0000587C ; Segment permissions: Read/Execute
.text$mn:0000587C _text$mn        segment para public 'CODE' use32
.text$mn:0000587C                 assume cs:_text$mn
.text$mn:0000587C                 ;org 587Ch
.text$mn:0000587C ; COMDAT (pick any)
.text$mn:0000587C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000587C
.text$mn:0000587C ; =============== S U B R O U T I N E =======================================
.text$mn:0000587C
.text$mn:0000587C ; Attributes: bp-based frame
.text$mn:0000587C
.text$mn:0000587C ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:0000587C                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:0000587C ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:0000587C                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:0000587C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:0000587C
.text$mn:0000587C var_10          = dword ptr -10h
.text$mn:0000587C var_C           = dword ptr -0Ch
.text$mn:0000587C var_4           = dword ptr -4
.text$mn:0000587C
.text$mn:0000587C                 push    ebp
.text$mn:0000587D                 mov     ebp, esp
.text$mn:0000587F                 push    0FFFFFFFFh
.text$mn:00005881                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00005886                 mov     eax, large fs:0
.text$mn:0000588C                 push    eax
.text$mn:0000588D                 push    ecx
.text$mn:0000588E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005893                 xor     eax, ebp
.text$mn:00005895                 push    eax
.text$mn:00005896                 lea     eax, [ebp+var_C]
.text$mn:00005899                 mov     large fs:0, eax
.text$mn:0000589F                 mov     [ebp+var_10], ecx
.text$mn:000058A2                 mov     [ebp+var_4], 0
.text$mn:000058A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000058B0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000058B3                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000058B8                 mov     ecx, [ebp+var_C]
.text$mn:000058BB                 mov     large fs:0, ecx
.text$mn:000058C2                 pop     ecx
.text$mn:000058C3                 mov     esp, ebp
.text$mn:000058C5                 pop     ebp
.text$mn:000058C6                 retn
.text$mn:000058C6 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:000058C6
.text$mn:000058C6 ; ---------------------------------------------------------------------------
.text$mn:000058C7                 align 4
.text$mn:000058C7 _text$mn        ends
.text$mn:000058C7
.text$x:000058C8 ; ===========================================================================
.text$x:000058C8
.text$x:000058C8 ; Segment type: Pure code
.text$x:000058C8 ; Segment permissions: Read/Execute
.text$x:000058C8 _text$x         segment para public 'CODE' use32
.text$x:000058C8                 assume cs:_text$x
.text$x:000058C8                 ;org 58C8h
.text$x:000058C8 ; COMDAT (pick associative to section at 587C)
.text$x:000058C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000058C8
.text$x:000058C8 ; =============== S U B R O U T I N E =======================================
.text$x:000058C8
.text$x:000058C8
.text$x:000058C8 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:000058C8                                         ; DATA XREF: .xdata$x:00009068o
.text$x:000058C8                 mov     ecx, [ebp-10h]  ; this
.text$x:000058CB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000058CB __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:000058CB
.text$x:000058D0
.text$x:000058D0 ; =============== S U B R O U T I N E =======================================
.text$x:000058D0
.text$x:000058D0
.text$x:000058D0 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:000058D0                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:000058D0
.text$x:000058D0 arg_4           = dword ptr  8
.text$x:000058D0
.text$x:000058D0                 mov     edx, [esp+arg_4]
.text$x:000058D4                 lea     eax, [edx+0Ch]
.text$x:000058D7                 mov     ecx, [edx-8]
.text$x:000058DA                 xor     ecx, eax
.text$x:000058DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000058E1                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:000058E6                 jmp     ___CxxFrameHandler3
.text$x:000058E6 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:000058E6
.text$x:000058E6 ; ---------------------------------------------------------------------------
.text$x:000058EB                 align 4
.text$x:000058EB _text$x         ends
.text$x:000058EB
.text$mn:000058EC ; ===========================================================================
.text$mn:000058EC
.text$mn:000058EC ; Segment type: Pure code
.text$mn:000058EC ; Segment permissions: Read/Execute
.text$mn:000058EC _text$mn        segment para public 'CODE' use32
.text$mn:000058EC                 assume cs:_text$mn
.text$mn:000058EC                 ;org 58ECh
.text$mn:000058EC ; COMDAT (pick any)
.text$mn:000058EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000058EC
.text$mn:000058EC ; =============== S U B R O U T I N E =======================================
.text$mn:000058EC
.text$mn:000058EC ; Attributes: bp-based frame
.text$mn:000058EC
.text$mn:000058EC ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:000058EC                 public ??1error_category@std@@UAE@XZ
.text$mn:000058EC ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:000058EC                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:000058EC
.text$mn:000058EC var_4           = dword ptr -4
.text$mn:000058EC
.text$mn:000058EC                 push    ebp
.text$mn:000058ED                 mov     ebp, esp
.text$mn:000058EF                 push    ecx
.text$mn:000058F0                 mov     [ebp+var_4], ecx
.text$mn:000058F3                 mov     eax, [ebp+var_4]
.text$mn:000058F6                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000058FC                 mov     esp, ebp
.text$mn:000058FE                 pop     ebp
.text$mn:000058FF                 retn
.text$mn:000058FF ??1error_category@std@@UAE@XZ endp
.text$mn:000058FF
.text$mn:000058FF _text$mn        ends
.text$mn:000058FF
.text$mn:00005900 ; ===========================================================================
.text$mn:00005900
.text$mn:00005900 ; Segment type: Pure code
.text$mn:00005900 ; Segment permissions: Read/Execute
.text$mn:00005900 _text$mn        segment para public 'CODE' use32
.text$mn:00005900                 assume cs:_text$mn
.text$mn:00005900                 ;org 5900h
.text$mn:00005900 ; COMDAT (pick any)
.text$mn:00005900                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005900
.text$mn:00005900 ; =============== S U B R O U T I N E =======================================
.text$mn:00005900
.text$mn:00005900 ; Attributes: bp-based frame
.text$mn:00005900
.text$mn:00005900 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:00005900                 public ??1runtime_error@std@@UAE@XZ
.text$mn:00005900 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:00005900                                         ; DATA XREF: .xdata$x:00009CB4o
.text$mn:00005900
.text$mn:00005900 var_10          = dword ptr -10h
.text$mn:00005900 var_C           = dword ptr -0Ch
.text$mn:00005900 var_4           = dword ptr -4
.text$mn:00005900
.text$mn:00005900                 push    ebp
.text$mn:00005901                 mov     ebp, esp
.text$mn:00005903                 push    0FFFFFFFFh
.text$mn:00005905                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:0000590A                 mov     eax, large fs:0
.text$mn:00005910                 push    eax
.text$mn:00005911                 push    ecx
.text$mn:00005912                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005917                 xor     eax, ebp
.text$mn:00005919                 push    eax
.text$mn:0000591A                 lea     eax, [ebp+var_C]
.text$mn:0000591D                 mov     large fs:0, eax
.text$mn:00005923                 mov     [ebp+var_10], ecx
.text$mn:00005926                 mov     [ebp+var_4], 0
.text$mn:0000592D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005934                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005937                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:0000593C                 mov     ecx, [ebp+var_C]
.text$mn:0000593F                 mov     large fs:0, ecx
.text$mn:00005946                 pop     ecx
.text$mn:00005947                 mov     esp, ebp
.text$mn:00005949                 pop     ebp
.text$mn:0000594A                 retn
.text$mn:0000594A ??1runtime_error@std@@UAE@XZ endp
.text$mn:0000594A
.text$mn:0000594A ; ---------------------------------------------------------------------------
.text$mn:0000594B                 align 4
.text$mn:0000594B _text$mn        ends
.text$mn:0000594B
.text$x:0000594C ; ===========================================================================
.text$x:0000594C
.text$x:0000594C ; Segment type: Pure code
.text$x:0000594C ; Segment permissions: Read/Execute
.text$x:0000594C _text$x         segment para public 'CODE' use32
.text$x:0000594C                 assume cs:_text$x
.text$x:0000594C                 ;org 594Ch
.text$x:0000594C ; COMDAT (pick associative to section at 5900)
.text$x:0000594C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000594C
.text$x:0000594C ; =============== S U B R O U T I N E =======================================
.text$x:0000594C
.text$x:0000594C
.text$x:0000594C __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:0000594C                                         ; DATA XREF: .xdata$x:00008EB0o
.text$x:0000594C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000594F                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:0000594F __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:0000594F
.text$x:00005954
.text$x:00005954 ; =============== S U B R O U T I N E =======================================
.text$x:00005954
.text$x:00005954
.text$x:00005954 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:00005954                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:00005954
.text$x:00005954 arg_4           = dword ptr  8
.text$x:00005954
.text$x:00005954                 mov     edx, [esp+arg_4]
.text$x:00005958                 lea     eax, [edx+0Ch]
.text$x:0000595B                 mov     ecx, [edx-8]
.text$x:0000595E                 xor     ecx, eax
.text$x:00005960                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005965                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:0000596A                 jmp     ___CxxFrameHandler3
.text$x:0000596A __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:0000596A
.text$x:0000596A ; ---------------------------------------------------------------------------
.text$x:0000596F                 align 10h
.text$x:0000596F _text$x         ends
.text$x:0000596F
.text$mn:00005970 ; ===========================================================================
.text$mn:00005970
.text$mn:00005970 ; Segment type: Pure code
.text$mn:00005970 ; Segment permissions: Read/Execute
.text$mn:00005970 _text$mn        segment para public 'CODE' use32
.text$mn:00005970                 assume cs:_text$mn
.text$mn:00005970                 ;org 5970h
.text$mn:00005970 ; COMDAT (pick any)
.text$mn:00005970                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005970
.text$mn:00005970 ; =============== S U B R O U T I N E =======================================
.text$mn:00005970
.text$mn:00005970 ; Attributes: bp-based frame
.text$mn:00005970
.text$mn:00005970 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00005970                 public ??2@YAPAXIPAX@Z
.text$mn:00005970 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00005970                                         ; std::allocator<HWND__ *>::construct<HWND__ *,HWND__ * &>(HWND__ * *,HWND__ * &)+2Ep ...
.text$mn:00005970
.text$mn:00005970 arg_4           = dword ptr  0Ch
.text$mn:00005970
.text$mn:00005970                 push    ebp
.text$mn:00005971                 mov     ebp, esp
.text$mn:00005973                 mov     eax, [ebp+arg_4]
.text$mn:00005976                 pop     ebp
.text$mn:00005977                 retn
.text$mn:00005977 ??2@YAPAXIPAX@Z endp
.text$mn:00005977
.text$mn:00005977 _text$mn        ends
.text$mn:00005977
.text$mn:00005978 ; ===========================================================================
.text$mn:00005978
.text$mn:00005978 ; Segment type: Pure code
.text$mn:00005978 ; Segment permissions: Read/Execute
.text$mn:00005978 _text$mn        segment para public 'CODE' use32
.text$mn:00005978                 assume cs:_text$mn
.text$mn:00005978                 ;org 5978h
.text$mn:00005978 ; COMDAT (pick any)
.text$mn:00005978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005978
.text$mn:00005978 ; =============== S U B R O U T I N E =======================================
.text$mn:00005978
.text$mn:00005978 ; Attributes: bp-based frame
.text$mn:00005978
.text$mn:00005978 ; void __cdecl operator delete(void *)
.text$mn:00005978                 public ??3@YAXPAX0@Z
.text$mn:00005978 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00005978                                         ; __unwindfunclet$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z$0+8p ...
.text$mn:00005978                 push    ebp
.text$mn:00005979                 mov     ebp, esp
.text$mn:0000597B                 pop     ebp
.text$mn:0000597C                 retn
.text$mn:0000597C ??3@YAXPAX0@Z   endp
.text$mn:0000597C
.text$mn:0000597C ; ---------------------------------------------------------------------------
.text$mn:0000597D                 align 10h
.text$mn:0000597D _text$mn        ends
.text$mn:0000597D
.text$mn:00005980 ; ===========================================================================
.text$mn:00005980
.text$mn:00005980 ; Segment type: Pure code
.text$mn:00005980 ; Segment permissions: Read/Execute
.text$mn:00005980 _text$mn        segment para public 'CODE' use32
.text$mn:00005980                 assume cs:_text$mn
.text$mn:00005980                 ;org 5980h
.text$mn:00005980 ; COMDAT (pick any)
.text$mn:00005980                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005980
.text$mn:00005980 ; =============== S U B R O U T I N E =======================================
.text$mn:00005980
.text$mn:00005980 ; Attributes: bp-based frame
.text$mn:00005980
.text$mn:00005980 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00005980                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00005980 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00005980                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00005980
.text$mn:00005980 var_14          = byte ptr -14h
.text$mn:00005980 var_10          = dword ptr -10h
.text$mn:00005980 var_C           = dword ptr -0Ch
.text$mn:00005980 var_4           = dword ptr -4
.text$mn:00005980 arg_0           = dword ptr  8
.text$mn:00005980
.text$mn:00005980                 push    ebp
.text$mn:00005981                 mov     ebp, esp
.text$mn:00005983                 push    0FFFFFFFFh
.text$mn:00005985                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:0000598A                 mov     eax, large fs:0
.text$mn:00005990                 push    eax
.text$mn:00005991                 sub     esp, 8
.text$mn:00005994                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005999                 xor     eax, ebp
.text$mn:0000599B                 push    eax
.text$mn:0000599C                 lea     eax, [ebp+var_C]
.text$mn:0000599F                 mov     large fs:0, eax
.text$mn:000059A5                 mov     [ebp+var_10], ecx
.text$mn:000059A8                 mov     eax, [ebp+var_10]
.text$mn:000059AB                 mov     ecx, [ebp+arg_0]
.text$mn:000059AE                 mov     edx, [eax]
.text$mn:000059B0                 cmp     edx, [ecx]
.text$mn:000059B2                 jnz     short loc_59B6
.text$mn:000059B4                 jmp     short loc_59F8
.text$mn:000059B6 ; ---------------------------------------------------------------------------
.text$mn:000059B6
.text$mn:000059B6 loc_59B6:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:000059B6                 mov     eax, [ebp+arg_0]
.text$mn:000059B9                 cmp     dword ptr [eax], 0
.text$mn:000059BC                 jz      short loc_59D0
.text$mn:000059BE                 mov     ecx, [ebp+arg_0]
.text$mn:000059C1                 mov     edx, [ecx]
.text$mn:000059C3                 mov     eax, [edx]
.text$mn:000059C5                 push    eax             ; struct std::_Container_base12 *
.text$mn:000059C6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000059C9                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000059CE                 jmp     short loc_59F8
.text$mn:000059D0 ; ---------------------------------------------------------------------------
.text$mn:000059D0
.text$mn:000059D0 loc_59D0:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:000059D0                 push    3               ; int
.text$mn:000059D2                 lea     ecx, [ebp+var_14] ; this
.text$mn:000059D5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000059DA                 mov     [ebp+var_4], 0
.text$mn:000059E1                 mov     ecx, [ebp+var_10] ; this
.text$mn:000059E4                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000059E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000059F0                 lea     ecx, [ebp+var_14] ; this
.text$mn:000059F3                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000059F8
.text$mn:000059F8 loc_59F8:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:000059F8                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:000059F8                 mov     eax, [ebp+var_10]
.text$mn:000059FB                 mov     ecx, [ebp+var_C]
.text$mn:000059FE                 mov     large fs:0, ecx
.text$mn:00005A05                 pop     ecx
.text$mn:00005A06                 mov     esp, ebp
.text$mn:00005A08                 pop     ebp
.text$mn:00005A09                 retn    4
.text$mn:00005A09 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00005A09
.text$mn:00005A09 _text$mn        ends
.text$mn:00005A09
.text$x:00005A0C ; ===========================================================================
.text$x:00005A0C
.text$x:00005A0C ; Segment type: Pure code
.text$x:00005A0C ; Segment permissions: Read/Execute
.text$x:00005A0C _text$x         segment para public 'CODE' use32
.text$x:00005A0C                 assume cs:_text$x
.text$x:00005A0C                 ;org 5A0Ch
.text$x:00005A0C ; COMDAT (pick associative to section at 5980)
.text$x:00005A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005A0C
.text$x:00005A0C ; =============== S U B R O U T I N E =======================================
.text$x:00005A0C
.text$x:00005A0C
.text$x:00005A0C __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:00005A0C                                         ; DATA XREF: .xdata$x:00008C64o
.text$x:00005A0C                 lea     ecx, [ebp-14h]  ; this
.text$x:00005A0F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00005A0F __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:00005A0F
.text$x:00005A14
.text$x:00005A14 ; =============== S U B R O U T I N E =======================================
.text$x:00005A14
.text$x:00005A14
.text$x:00005A14 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:00005A14                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:00005A14
.text$x:00005A14 arg_4           = dword ptr  8
.text$x:00005A14
.text$x:00005A14                 mov     edx, [esp+arg_4]
.text$x:00005A18                 lea     eax, [edx+0Ch]
.text$x:00005A1B                 mov     ecx, [edx-0Ch]
.text$x:00005A1E                 xor     ecx, eax
.text$x:00005A20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005A25                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:00005A2A                 jmp     ___CxxFrameHandler3
.text$x:00005A2A __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:00005A2A
.text$x:00005A2A ; ---------------------------------------------------------------------------
.text$x:00005A2F                 align 10h
.text$x:00005A2F _text$x         ends
.text$x:00005A2F
.text$mn:00005A30 ; ===========================================================================
.text$mn:00005A30
.text$mn:00005A30 ; Segment type: Pure code
.text$mn:00005A30 ; Segment permissions: Read/Execute
.text$mn:00005A30 _text$mn        segment para public 'CODE' use32
.text$mn:00005A30                 assume cs:_text$mn
.text$mn:00005A30                 ;org 5A30h
.text$mn:00005A30 ; COMDAT (pick any)
.text$mn:00005A30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A30
.text$mn:00005A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A30
.text$mn:00005A30 ; Attributes: bp-based frame
.text$mn:00005A30
.text$mn:00005A30 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00005A30                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00005A30 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00005A30                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00005A30                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00005A30
.text$mn:00005A30 var_8           = dword ptr -8
.text$mn:00005A30 var_4           = dword ptr -4
.text$mn:00005A30 arg_0           = dword ptr  8
.text$mn:00005A30
.text$mn:00005A30                 push    ebp
.text$mn:00005A31                 mov     ebp, esp
.text$mn:00005A33                 sub     esp, 8
.text$mn:00005A36                 mov     [ebp+var_8], ecx
.text$mn:00005A39                 mov     eax, [ebp+var_8]
.text$mn:00005A3C                 cmp     eax, [ebp+arg_0]
.text$mn:00005A3F                 jnz     short loc_5A4A
.text$mn:00005A41                 mov     [ebp+var_4], 1
.text$mn:00005A48                 jmp     short loc_5A51
.text$mn:00005A4A ; ---------------------------------------------------------------------------
.text$mn:00005A4A
.text$mn:00005A4A loc_5A4A:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00005A4A                 mov     [ebp+var_4], 0
.text$mn:00005A51
.text$mn:00005A51 loc_5A51:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00005A51                 mov     al, byte ptr [ebp+var_4]
.text$mn:00005A54                 mov     esp, ebp
.text$mn:00005A56                 pop     ebp
.text$mn:00005A57                 retn    4
.text$mn:00005A57 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00005A57
.text$mn:00005A57 ; ---------------------------------------------------------------------------
.text$mn:00005A5A                 align 4
.text$mn:00005A5A _text$mn        ends
.text$mn:00005A5A
.text$mn:00005A5C ; ===========================================================================
.text$mn:00005A5C
.text$mn:00005A5C ; Segment type: Pure code
.text$mn:00005A5C ; Segment permissions: Read/Execute
.text$mn:00005A5C _text$mn        segment para public 'CODE' use32
.text$mn:00005A5C                 assume cs:_text$mn
.text$mn:00005A5C                 ;org 5A5Ch
.text$mn:00005A5C ; COMDAT (pick any)
.text$mn:00005A5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A5C
.text$mn:00005A5C ; =============== S U B R O U T I N E =======================================
.text$mn:00005A5C
.text$mn:00005A5C ; Attributes: bp-based frame
.text$mn:00005A5C
.text$mn:00005A5C ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00005A5C                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00005A5C ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00005A5C                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00005A5C
.text$mn:00005A5C var_8           = dword ptr -8
.text$mn:00005A5C var_4           = dword ptr -4
.text$mn:00005A5C arg_0           = dword ptr  8
.text$mn:00005A5C
.text$mn:00005A5C                 push    ebp
.text$mn:00005A5D                 mov     ebp, esp
.text$mn:00005A5F                 sub     esp, 8
.text$mn:00005A62                 push    esi
.text$mn:00005A63                 mov     [ebp+var_4], ecx
.text$mn:00005A66                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005A69                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00005A6E                 push    eax
.text$mn:00005A6F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005A72                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00005A77                 mov     ecx, eax
.text$mn:00005A79                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00005A7E                 movzx   eax, al
.text$mn:00005A81                 test    eax, eax
.text$mn:00005A83                 jz      short loc_5AA4
.text$mn:00005A85                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005A88                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00005A8D                 mov     esi, eax
.text$mn:00005A8F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005A92                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00005A97                 cmp     esi, eax
.text$mn:00005A99                 jnz     short loc_5AA4
.text$mn:00005A9B                 mov     [ebp+var_8], 1
.text$mn:00005AA2                 jmp     short loc_5AAB
.text$mn:00005AA4 ; ---------------------------------------------------------------------------
.text$mn:00005AA4
.text$mn:00005AA4 loc_5AA4:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00005AA4                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00005AA4                 mov     [ebp+var_8], 0
.text$mn:00005AAB
.text$mn:00005AAB loc_5AAB:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00005AAB                 mov     al, byte ptr [ebp+var_8]
.text$mn:00005AAE                 pop     esi
.text$mn:00005AAF                 mov     esp, ebp
.text$mn:00005AB1                 pop     ebp
.text$mn:00005AB2                 retn    4
.text$mn:00005AB2 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00005AB2
.text$mn:00005AB2 ; ---------------------------------------------------------------------------
.text$mn:00005AB5                 align 4
.text$mn:00005AB5 _text$mn        ends
.text$mn:00005AB5
.text$mn:00005AB8 ; ===========================================================================
.text$mn:00005AB8
.text$mn:00005AB8 ; Segment type: Pure code
.text$mn:00005AB8 ; Segment permissions: Read/Execute
.text$mn:00005AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00005AB8                 assume cs:_text$mn
.text$mn:00005AB8                 ;org 5AB8h
.text$mn:00005AB8 ; COMDAT (pick any)
.text$mn:00005AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005AB8
.text$mn:00005AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AB8
.text$mn:00005AB8 ; Attributes: bp-based frame
.text$mn:00005AB8
.text$mn:00005AB8 ; public: struct HWND__ * & __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::operator[](unsigned int)
.text$mn:00005AB8                 public ??A?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAEAAPAUHWND__@@I@Z
.text$mn:00005AB8 ??A?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAEAAPAUHWND__@@I@Z proc near
.text$mn:00005AB8                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+5D2p
.text$mn:00005AB8
.text$mn:00005AB8 var_4           = dword ptr -4
.text$mn:00005AB8 arg_0           = dword ptr  8
.text$mn:00005AB8
.text$mn:00005AB8                 push    ebp
.text$mn:00005AB9                 mov     ebp, esp
.text$mn:00005ABB                 push    ecx
.text$mn:00005ABC                 mov     [ebp+var_4], ecx
.text$mn:00005ABF                 mov     ecx, [ebp+var_4]
.text$mn:00005AC2                 call    ?size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::size(void)
.text$mn:00005AC7                 cmp     eax, [ebp+arg_0]
.text$mn:00005ACA                 ja      short loc_5B34
.text$mn:00005ACC                 push    4B1h            ; unsigned int
.text$mn:00005AD1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005AD6                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00005ADB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005AE0                 add     esp, 0Ch
.text$mn:00005AE3                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005AE8                 test    eax, eax
.text$mn:00005AEA                 jz      short loc_5AF0
.text$mn:00005AEC                 xor     ecx, ecx
.text$mn:00005AEE                 jnz     short loc_5B16
.text$mn:00005AF0
.text$mn:00005AF0 loc_5AF0:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+32j
.text$mn:00005AF0                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005AF5                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005AFA                 push    0
.text$mn:00005AFC                 push    4B2h
.text$mn:00005B01                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005B06                 push    2
.text$mn:00005B08                 call    __CrtDbgReportW
.text$mn:00005B0D                 add     esp, 18h
.text$mn:00005B10                 cmp     eax, 1
.text$mn:00005B13                 jnz     short loc_5B16
.text$mn:00005B15                 int     3               ; Trap to Debugger
.text$mn:00005B16
.text$mn:00005B16 loc_5B16:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+36j
.text$mn:00005B16                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+5Bj
.text$mn:00005B16                 push    0
.text$mn:00005B18                 push    4B2h
.text$mn:00005B1D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005B22                 push    offset ??_C@_1KC@CCKJJADN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAH?$AAW?$AAN?$AAD?$AA_?$AA_?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs@ ; "std::vector<struct HWND__ *,class std::"...
.text$mn:00005B27                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005B2C                 call    __invalid_parameter
.text$mn:00005B31                 add     esp, 14h
.text$mn:00005B34
.text$mn:00005B34 loc_5B34:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+12j
.text$mn:00005B34                 mov     eax, [ebp+var_4]
.text$mn:00005B37                 mov     ecx, [eax+4]
.text$mn:00005B3A                 mov     edx, [ebp+arg_0]
.text$mn:00005B3D                 lea     eax, [ecx+edx*4]
.text$mn:00005B40                 mov     esp, ebp
.text$mn:00005B42                 pop     ebp
.text$mn:00005B43                 retn    4
.text$mn:00005B43 ??A?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAEAAPAUHWND__@@I@Z endp
.text$mn:00005B43
.text$mn:00005B43 ; ---------------------------------------------------------------------------
.text$mn:00005B46                 align 4
.text$mn:00005B46 _text$mn        ends
.text$mn:00005B46
.text$mn:00005B48 ; ===========================================================================
.text$mn:00005B48
.text$mn:00005B48 ; Segment type: Pure code
.text$mn:00005B48 ; Segment permissions: Read/Execute
.text$mn:00005B48 _text$mn        segment para public 'CODE' use32
.text$mn:00005B48                 assume cs:_text$mn
.text$mn:00005B48                 ;org 5B48h
.text$mn:00005B48 ; COMDAT (pick any)
.text$mn:00005B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B48
.text$mn:00005B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B48
.text$mn:00005B48 ; Attributes: bp-based frame
.text$mn:00005B48
.text$mn:00005B48 ; public: struct tTbData * & __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::operator[](unsigned int)
.text$mn:00005B48                 public ??A?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAEAAPAUtTbData@@I@Z
.text$mn:00005B48 ??A?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAEAAPAUtTbData@@I@Z proc near
.text$mn:00005B48                                         ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+C6p
.text$mn:00005B48                                         ; DockingManager::toggleVisTb(DockingCont *,DockingCont *)+8Bp ...
.text$mn:00005B48
.text$mn:00005B48 var_4           = dword ptr -4
.text$mn:00005B48 arg_0           = dword ptr  8
.text$mn:00005B48
.text$mn:00005B48                 push    ebp
.text$mn:00005B49                 mov     ebp, esp
.text$mn:00005B4B                 push    ecx
.text$mn:00005B4C                 mov     [ebp+var_4], ecx
.text$mn:00005B4F                 mov     ecx, [ebp+var_4]
.text$mn:00005B52                 call    ?size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ ; std::vector<tTbData *,std::allocator<tTbData *>>::size(void)
.text$mn:00005B57                 cmp     eax, [ebp+arg_0]
.text$mn:00005B5A                 ja      short loc_5BC4
.text$mn:00005B5C                 push    4B1h            ; unsigned int
.text$mn:00005B61                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005B66                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00005B6B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005B70                 add     esp, 0Ch
.text$mn:00005B73                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005B78                 test    eax, eax
.text$mn:00005B7A                 jz      short loc_5B80
.text$mn:00005B7C                 xor     ecx, ecx
.text$mn:00005B7E                 jnz     short loc_5BA6
.text$mn:00005B80
.text$mn:00005B80 loc_5B80:                               ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+32j
.text$mn:00005B80                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005B85                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005B8A                 push    0
.text$mn:00005B8C                 push    4B2h
.text$mn:00005B91                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005B96                 push    2
.text$mn:00005B98                 call    __CrtDbgReportW
.text$mn:00005B9D                 add     esp, 18h
.text$mn:00005BA0                 cmp     eax, 1
.text$mn:00005BA3                 jnz     short loc_5BA6
.text$mn:00005BA5                 int     3               ; Trap to Debugger
.text$mn:00005BA6
.text$mn:00005BA6 loc_5BA6:                               ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+36j
.text$mn:00005BA6                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+5Bj
.text$mn:00005BA6                 push    0
.text$mn:00005BA8                 push    4B2h
.text$mn:00005BAD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005BB2                 push    offset ??_C@_1KG@EEBFNKPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAt?$AAT?$AAb?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa@ ; "std::vector<struct tTbData *,class std:"...
.text$mn:00005BB7                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005BBC                 call    __invalid_parameter
.text$mn:00005BC1                 add     esp, 14h
.text$mn:00005BC4
.text$mn:00005BC4 loc_5BC4:                               ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+12j
.text$mn:00005BC4                 mov     eax, [ebp+var_4]
.text$mn:00005BC7                 mov     ecx, [eax+4]
.text$mn:00005BCA                 mov     edx, [ebp+arg_0]
.text$mn:00005BCD                 lea     eax, [ecx+edx*4]
.text$mn:00005BD0                 mov     esp, ebp
.text$mn:00005BD2                 pop     ebp
.text$mn:00005BD3                 retn    4
.text$mn:00005BD3 ??A?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAEAAPAUtTbData@@I@Z endp
.text$mn:00005BD3
.text$mn:00005BD3 ; ---------------------------------------------------------------------------
.text$mn:00005BD6                 align 4
.text$mn:00005BD6 _text$mn        ends
.text$mn:00005BD6
.text$mn:00005BD8 ; ===========================================================================
.text$mn:00005BD8
.text$mn:00005BD8 ; Segment type: Pure code
.text$mn:00005BD8 ; Segment permissions: Read/Execute
.text$mn:00005BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00005BD8                 assume cs:_text$mn
.text$mn:00005BD8                 ;org 5BD8h
.text$mn:00005BD8 ; COMDAT (pick any)
.text$mn:00005BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005BD8
.text$mn:00005BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BD8
.text$mn:00005BD8 ; Attributes: bp-based frame
.text$mn:00005BD8
.text$mn:00005BD8 ; public: class DockingCont * & __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::operator[](unsigned int)
.text$mn:00005BD8                 public ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z
.text$mn:00005BD8 ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z proc near
.text$mn:00005BD8                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+148p
.text$mn:00005BD8                                         ; DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+17Bp ...
.text$mn:00005BD8
.text$mn:00005BD8 var_4           = dword ptr -4
.text$mn:00005BD8 arg_0           = dword ptr  8
.text$mn:00005BD8
.text$mn:00005BD8                 push    ebp
.text$mn:00005BD9                 mov     ebp, esp
.text$mn:00005BDB                 push    ecx
.text$mn:00005BDC                 mov     [ebp+var_4], ecx
.text$mn:00005BDF                 mov     ecx, [ebp+var_4]
.text$mn:00005BE2                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00005BE7                 cmp     eax, [ebp+arg_0]
.text$mn:00005BEA                 ja      short loc_5C54
.text$mn:00005BEC                 push    4B1h            ; unsigned int
.text$mn:00005BF1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005BF6                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00005BFB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005C00                 add     esp, 0Ch
.text$mn:00005C03                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005C08                 test    eax, eax
.text$mn:00005C0A                 jz      short loc_5C10
.text$mn:00005C0C                 xor     ecx, ecx
.text$mn:00005C0E                 jnz     short loc_5C36
.text$mn:00005C10
.text$mn:00005C10 loc_5C10:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+32j
.text$mn:00005C10                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005C15                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005C1A                 push    0
.text$mn:00005C1C                 push    4B2h
.text$mn:00005C21                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005C26                 push    2
.text$mn:00005C28                 call    __CrtDbgReportW
.text$mn:00005C2D                 add     esp, 18h
.text$mn:00005C30                 cmp     eax, 1
.text$mn:00005C33                 jnz     short loc_5C36
.text$mn:00005C35                 int     3               ; Trap to Debugger
.text$mn:00005C36
.text$mn:00005C36 loc_5C36:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+36j
.text$mn:00005C36                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+5Bj
.text$mn:00005C36                 push    0
.text$mn:00005C38                 push    4B2h
.text$mn:00005C3D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005C42                 push    offset ??_C@_1LC@HLAKEHED@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAo?$AAc?$AAk?$AAi?$AAn?$AAg?$AAC?$AAo?$AAn?$AAt?$AA?5?$AA?$CK?$AA?0@ ; "std::vector<class DockingCont *,class s"...
.text$mn:00005C47                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005C4C                 call    __invalid_parameter
.text$mn:00005C51                 add     esp, 14h
.text$mn:00005C54
.text$mn:00005C54 loc_5C54:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+12j
.text$mn:00005C54                 mov     eax, [ebp+var_4]
.text$mn:00005C57                 mov     ecx, [eax+4]
.text$mn:00005C5A                 mov     edx, [ebp+arg_0]
.text$mn:00005C5D                 lea     eax, [ecx+edx*4]
.text$mn:00005C60                 mov     esp, ebp
.text$mn:00005C62                 pop     ebp
.text$mn:00005C63                 retn    4
.text$mn:00005C63 ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z endp
.text$mn:00005C63
.text$mn:00005C63 ; ---------------------------------------------------------------------------
.text$mn:00005C66                 align 4
.text$mn:00005C66 _text$mn        ends
.text$mn:00005C66
.text$mn:00005C68 ; ===========================================================================
.text$mn:00005C68
.text$mn:00005C68 ; Segment type: Pure code
.text$mn:00005C68 ; Segment permissions: Read/Execute
.text$mn:00005C68 _text$mn        segment para public 'CODE' use32
.text$mn:00005C68                 assume cs:_text$mn
.text$mn:00005C68                 ;org 5C68h
.text$mn:00005C68 ; COMDAT (pick any)
.text$mn:00005C68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C68
.text$mn:00005C68 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C68
.text$mn:00005C68 ; Attributes: bp-based frame
.text$mn:00005C68
.text$mn:00005C68 ; public: class DockingSplitter * & __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::operator[](unsigned int)
.text$mn:00005C68                 public ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z
.text$mn:00005C68 ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z proc near
.text$mn:00005C68                                         ; CODE XREF: DockingManager::~DockingManager(void)+5Dp
.text$mn:00005C68                                         ; DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+1DBp ...
.text$mn:00005C68
.text$mn:00005C68 var_4           = dword ptr -4
.text$mn:00005C68 arg_0           = dword ptr  8
.text$mn:00005C68
.text$mn:00005C68                 push    ebp
.text$mn:00005C69                 mov     ebp, esp
.text$mn:00005C6B                 push    ecx
.text$mn:00005C6C                 mov     [ebp+var_4], ecx
.text$mn:00005C6F                 mov     ecx, [ebp+var_4]
.text$mn:00005C72                 call    ?size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::size(void)
.text$mn:00005C77                 cmp     eax, [ebp+arg_0]
.text$mn:00005C7A                 ja      short loc_5CE4
.text$mn:00005C7C                 push    4B1h            ; unsigned int
.text$mn:00005C81                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005C86                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00005C8B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005C90                 add     esp, 0Ch
.text$mn:00005C93                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005C98                 test    eax, eax
.text$mn:00005C9A                 jz      short loc_5CA0
.text$mn:00005C9C                 xor     ecx, ecx
.text$mn:00005C9E                 jnz     short loc_5CC6
.text$mn:00005CA0
.text$mn:00005CA0 loc_5CA0:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)+32j
.text$mn:00005CA0                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005CA5                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005CAA                 push    0
.text$mn:00005CAC                 push    4B2h
.text$mn:00005CB1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005CB6                 push    2
.text$mn:00005CB8                 call    __CrtDbgReportW
.text$mn:00005CBD                 add     esp, 18h
.text$mn:00005CC0                 cmp     eax, 1
.text$mn:00005CC3                 jnz     short loc_5CC6
.text$mn:00005CC5                 int     3               ; Trap to Debugger
.text$mn:00005CC6
.text$mn:00005CC6 loc_5CC6:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)+36j
.text$mn:00005CC6                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)+5Bj
.text$mn:00005CC6                 push    0
.text$mn:00005CC8                 push    4B2h
.text$mn:00005CCD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005CD2                 push    offset ??_C@_1MC@HLIHCBPD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAo?$AAc?$AAk?$AAi?$AAn?$AAg?$AAS?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe@ ; "std::vector<class DockingSplitter *,cla"...
.text$mn:00005CD7                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005CDC                 call    __invalid_parameter
.text$mn:00005CE1                 add     esp, 14h
.text$mn:00005CE4
.text$mn:00005CE4 loc_5CE4:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)+12j
.text$mn:00005CE4                 mov     eax, [ebp+var_4]
.text$mn:00005CE7                 mov     ecx, [eax+4]
.text$mn:00005CEA                 mov     edx, [ebp+arg_0]
.text$mn:00005CED                 lea     eax, [ecx+edx*4]
.text$mn:00005CF0                 mov     esp, ebp
.text$mn:00005CF2                 pop     ebp
.text$mn:00005CF3                 retn    4
.text$mn:00005CF3 ??A?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEAAPAVDockingSplitter@@I@Z endp
.text$mn:00005CF3
.text$mn:00005CF3 ; ---------------------------------------------------------------------------
.text$mn:00005CF6                 align 4
.text$mn:00005CF6 _text$mn        ends
.text$mn:00005CF6
.text$mn:00005CF8 ; ===========================================================================
.text$mn:00005CF8
.text$mn:00005CF8 ; Segment type: Pure code
.text$mn:00005CF8 ; Segment permissions: Read/Execute
.text$mn:00005CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00005CF8                 assume cs:_text$mn
.text$mn:00005CF8                 ;org 5CF8h
.text$mn:00005CF8 ; COMDAT (pick any)
.text$mn:00005CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CF8
.text$mn:00005CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CF8
.text$mn:00005CF8 ; Attributes: bp-based frame
.text$mn:00005CF8
.text$mn:00005CF8 ; public: virtual void * __thiscall DockingManager::`scalar deleting destructor'(unsigned int)
.text$mn:00005CF8                 public ??_GDockingManager@@UAEPAXI@Z
.text$mn:00005CF8 ??_GDockingManager@@UAEPAXI@Z proc near
.text$mn:00005CF8
.text$mn:00005CF8 var_4           = dword ptr -4
.text$mn:00005CF8 arg_0           = dword ptr  8
.text$mn:00005CF8
.text$mn:00005CF8                 push    ebp
.text$mn:00005CF9                 mov     ebp, esp
.text$mn:00005CFB                 push    ecx
.text$mn:00005CFC                 mov     [ebp+var_4], ecx
.text$mn:00005CFF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005D02                 call    ??1DockingManager@@UAE@XZ ; DockingManager::~DockingManager(void)
.text$mn:00005D07                 mov     eax, [ebp+arg_0]
.text$mn:00005D0A                 and     eax, 1
.text$mn:00005D0D                 jz      short loc_5D1B
.text$mn:00005D0F                 mov     ecx, [ebp+var_4]
.text$mn:00005D12                 push    ecx             ; void *
.text$mn:00005D13                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005D18                 add     esp, 4
.text$mn:00005D1B
.text$mn:00005D1B loc_5D1B:                               ; CODE XREF: DockingManager::`scalar deleting destructor'(uint)+15j
.text$mn:00005D1B                 mov     eax, [ebp+var_4]
.text$mn:00005D1E                 mov     esp, ebp
.text$mn:00005D20                 pop     ebp
.text$mn:00005D21                 retn    4
.text$mn:00005D21 ??_GDockingManager@@UAEPAXI@Z endp
.text$mn:00005D21
.text$mn:00005D21 _text$mn        ends
.text$mn:00005D21
.text$mn:00005D24 ; ===========================================================================
.text$mn:00005D24
.text$mn:00005D24 ; Segment type: Pure code
.text$mn:00005D24 ; Segment permissions: Read/Execute
.text$mn:00005D24 _text$mn        segment para public 'CODE' use32
.text$mn:00005D24                 assume cs:_text$mn
.text$mn:00005D24                 ;org 5D24h
.text$mn:00005D24 ; COMDAT (pick any)
.text$mn:00005D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D24
.text$mn:00005D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D24
.text$mn:00005D24 ; Attributes: bp-based frame
.text$mn:00005D24
.text$mn:00005D24 ; public: virtual void * __thiscall DockingSplitter::`scalar deleting destructor'(unsigned int)
.text$mn:00005D24                 public ??_GDockingSplitter@@UAEPAXI@Z
.text$mn:00005D24 ??_GDockingSplitter@@UAEPAXI@Z proc near
.text$mn:00005D24
.text$mn:00005D24 var_4           = dword ptr -4
.text$mn:00005D24 arg_0           = dword ptr  8
.text$mn:00005D24
.text$mn:00005D24                 push    ebp
.text$mn:00005D25                 mov     ebp, esp
.text$mn:00005D27                 push    ecx
.text$mn:00005D28                 mov     [ebp+var_4], ecx
.text$mn:00005D2B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005D2E                 call    ??1DockingSplitter@@UAE@XZ ; DockingSplitter::~DockingSplitter(void)
.text$mn:00005D33                 mov     eax, [ebp+arg_0]
.text$mn:00005D36                 and     eax, 1
.text$mn:00005D39                 jz      short loc_5D47
.text$mn:00005D3B                 mov     ecx, [ebp+var_4]
.text$mn:00005D3E                 push    ecx             ; void *
.text$mn:00005D3F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005D44                 add     esp, 4
.text$mn:00005D47
.text$mn:00005D47 loc_5D47:                               ; CODE XREF: DockingSplitter::`scalar deleting destructor'(uint)+15j
.text$mn:00005D47                 mov     eax, [ebp+var_4]
.text$mn:00005D4A                 mov     esp, ebp
.text$mn:00005D4C                 pop     ebp
.text$mn:00005D4D                 retn    4
.text$mn:00005D4D ??_GDockingSplitter@@UAEPAXI@Z endp
.text$mn:00005D4D
.text$mn:00005D4D _text$mn        ends
.text$mn:00005D4D
.text$mn:00005D50 ; ===========================================================================
.text$mn:00005D50
.text$mn:00005D50 ; Segment type: Pure code
.text$mn:00005D50 ; Segment permissions: Read/Execute
.text$mn:00005D50 _text$mn        segment para public 'CODE' use32
.text$mn:00005D50                 assume cs:_text$mn
.text$mn:00005D50                 ;org 5D50h
.text$mn:00005D50 ; COMDAT (pick any)
.text$mn:00005D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D50
.text$mn:00005D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D50
.text$mn:00005D50 ; Attributes: bp-based frame
.text$mn:00005D50
.text$mn:00005D50 ; public: virtual void * __thiscall Window::`scalar deleting destructor'(unsigned int)
.text$mn:00005D50                 public ??_GWindow@@UAEPAXI@Z
.text$mn:00005D50 ??_GWindow@@UAEPAXI@Z proc near
.text$mn:00005D50
.text$mn:00005D50 var_4           = dword ptr -4
.text$mn:00005D50 arg_0           = dword ptr  8
.text$mn:00005D50
.text$mn:00005D50                 push    ebp
.text$mn:00005D51                 mov     ebp, esp
.text$mn:00005D53                 push    ecx
.text$mn:00005D54                 mov     [ebp+var_4], ecx
.text$mn:00005D57                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005D5A                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:00005D5F                 mov     eax, [ebp+arg_0]
.text$mn:00005D62                 and     eax, 1
.text$mn:00005D65                 jz      short loc_5D73
.text$mn:00005D67                 mov     ecx, [ebp+var_4]
.text$mn:00005D6A                 push    ecx             ; void *
.text$mn:00005D6B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005D70                 add     esp, 4
.text$mn:00005D73
.text$mn:00005D73 loc_5D73:                               ; CODE XREF: Window::`scalar deleting destructor'(uint)+15j
.text$mn:00005D73                 mov     eax, [ebp+var_4]
.text$mn:00005D76                 mov     esp, ebp
.text$mn:00005D78                 pop     ebp
.text$mn:00005D79                 retn    4
.text$mn:00005D79 ??_GWindow@@UAEPAXI@Z endp
.text$mn:00005D79
.text$mn:00005D79 _text$mn        ends
.text$mn:00005D79
.text$mn:00005D7C ; ===========================================================================
.text$mn:00005D7C
.text$mn:00005D7C ; Segment type: Pure code
.text$mn:00005D7C ; Segment permissions: Read/Execute
.text$mn:00005D7C _text$mn        segment para public 'CODE' use32
.text$mn:00005D7C                 assume cs:_text$mn
.text$mn:00005D7C                 ;org 5D7Ch
.text$mn:00005D7C ; COMDAT (pick any)
.text$mn:00005D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D7C
.text$mn:00005D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00005D7C
.text$mn:00005D7C ; Attributes: bp-based frame
.text$mn:00005D7C
.text$mn:00005D7C ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005D7C                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00005D7C ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005D7C
.text$mn:00005D7C var_4           = dword ptr -4
.text$mn:00005D7C arg_0           = dword ptr  8
.text$mn:00005D7C
.text$mn:00005D7C                 push    ebp
.text$mn:00005D7D                 mov     ebp, esp
.text$mn:00005D7F                 push    ecx
.text$mn:00005D80                 mov     [ebp+var_4], ecx
.text$mn:00005D83                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005D86                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00005D8B                 mov     eax, [ebp+arg_0]
.text$mn:00005D8E                 and     eax, 1
.text$mn:00005D91                 jz      short loc_5D9F
.text$mn:00005D93                 mov     ecx, [ebp+var_4]
.text$mn:00005D96                 push    ecx             ; void *
.text$mn:00005D97                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005D9C                 add     esp, 4
.text$mn:00005D9F
.text$mn:00005D9F loc_5D9F:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005D9F                 mov     eax, [ebp+var_4]
.text$mn:00005DA2                 mov     esp, ebp
.text$mn:00005DA4                 pop     ebp
.text$mn:00005DA5                 retn    4
.text$mn:00005DA5 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00005DA5
.text$mn:00005DA5 _text$mn        ends
.text$mn:00005DA5
.text$mn:00005DA8 ; ===========================================================================
.text$mn:00005DA8
.text$mn:00005DA8 ; Segment type: Pure code
.text$mn:00005DA8 ; Segment permissions: Read/Execute
.text$mn:00005DA8 _text$mn        segment para public 'CODE' use32
.text$mn:00005DA8                 assume cs:_text$mn
.text$mn:00005DA8                 ;org 5DA8h
.text$mn:00005DA8 ; COMDAT (pick any)
.text$mn:00005DA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DA8
.text$mn:00005DA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DA8
.text$mn:00005DA8 ; Attributes: bp-based frame
.text$mn:00005DA8
.text$mn:00005DA8 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005DA8                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00005DA8 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005DA8
.text$mn:00005DA8 var_4           = dword ptr -4
.text$mn:00005DA8 arg_0           = dword ptr  8
.text$mn:00005DA8
.text$mn:00005DA8                 push    ebp
.text$mn:00005DA9                 mov     ebp, esp
.text$mn:00005DAB                 push    ecx
.text$mn:00005DAC                 mov     [ebp+var_4], ecx
.text$mn:00005DAF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005DB2                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00005DB7                 mov     eax, [ebp+arg_0]
.text$mn:00005DBA                 and     eax, 1
.text$mn:00005DBD                 jz      short loc_5DCB
.text$mn:00005DBF                 mov     ecx, [ebp+var_4]
.text$mn:00005DC2                 push    ecx             ; void *
.text$mn:00005DC3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005DC8                 add     esp, 4
.text$mn:00005DCB
.text$mn:00005DCB loc_5DCB:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005DCB                 mov     eax, [ebp+var_4]
.text$mn:00005DCE                 mov     esp, ebp
.text$mn:00005DD0                 pop     ebp
.text$mn:00005DD1                 retn    4
.text$mn:00005DD1 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00005DD1
.text$mn:00005DD1 _text$mn        ends
.text$mn:00005DD1
.text$mn:00005DD4 ; ===========================================================================
.text$mn:00005DD4
.text$mn:00005DD4 ; Segment type: Pure code
.text$mn:00005DD4 ; Segment permissions: Read/Execute
.text$mn:00005DD4 _text$mn        segment para public 'CODE' use32
.text$mn:00005DD4                 assume cs:_text$mn
.text$mn:00005DD4                 ;org 5DD4h
.text$mn:00005DD4 ; COMDAT (pick any)
.text$mn:00005DD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DD4
.text$mn:00005DD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DD4
.text$mn:00005DD4 ; Attributes: bp-based frame
.text$mn:00005DD4
.text$mn:00005DD4 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005DD4                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00005DD4 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00005DD4
.text$mn:00005DD4 var_4           = dword ptr -4
.text$mn:00005DD4 arg_0           = dword ptr  8
.text$mn:00005DD4
.text$mn:00005DD4                 push    ebp
.text$mn:00005DD5                 mov     ebp, esp
.text$mn:00005DD7                 push    ecx
.text$mn:00005DD8                 mov     [ebp+var_4], ecx
.text$mn:00005DDB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005DDE                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00005DE3                 mov     eax, [ebp+arg_0]
.text$mn:00005DE6                 and     eax, 1
.text$mn:00005DE9                 jz      short loc_5DF7
.text$mn:00005DEB                 mov     ecx, [ebp+var_4]
.text$mn:00005DEE                 push    ecx             ; void *
.text$mn:00005DEF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005DF4                 add     esp, 4
.text$mn:00005DF7
.text$mn:00005DF7 loc_5DF7:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005DF7                 mov     eax, [ebp+var_4]
.text$mn:00005DFA                 mov     esp, ebp
.text$mn:00005DFC                 pop     ebp
.text$mn:00005DFD                 retn    4
.text$mn:00005DFD ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00005DFD
.text$mn:00005DFD _text$mn        ends
.text$mn:00005DFD
.text$mn:00005E00 ; ===========================================================================
.text$mn:00005E00
.text$mn:00005E00 ; Segment type: Pure code
.text$mn:00005E00 ; Segment permissions: Read/Execute
.text$mn:00005E00 _text$mn        segment para public 'CODE' use32
.text$mn:00005E00                 assume cs:_text$mn
.text$mn:00005E00                 ;org 5E00h
.text$mn:00005E00 ; COMDAT (pick any)
.text$mn:00005E00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E00
.text$mn:00005E00 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E00
.text$mn:00005E00 ; Attributes: bp-based frame
.text$mn:00005E00
.text$mn:00005E00 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00005E00                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00005E00 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00005E00
.text$mn:00005E00 var_4           = dword ptr -4
.text$mn:00005E00 arg_0           = dword ptr  8
.text$mn:00005E00
.text$mn:00005E00                 push    ebp
.text$mn:00005E01                 mov     ebp, esp
.text$mn:00005E03                 push    ecx
.text$mn:00005E04                 mov     [ebp+var_4], ecx
.text$mn:00005E07                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005E0A                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00005E0F                 mov     eax, [ebp+arg_0]
.text$mn:00005E12                 and     eax, 1
.text$mn:00005E15                 jz      short loc_5E23
.text$mn:00005E17                 mov     ecx, [ebp+var_4]
.text$mn:00005E1A                 push    ecx             ; void *
.text$mn:00005E1B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005E20                 add     esp, 4
.text$mn:00005E23
.text$mn:00005E23 loc_5E23:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00005E23                 mov     eax, [ebp+var_4]
.text$mn:00005E26                 mov     esp, ebp
.text$mn:00005E28                 pop     ebp
.text$mn:00005E29                 retn    4
.text$mn:00005E29 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00005E29
.text$mn:00005E29 _text$mn        ends
.text$mn:00005E29
.text$mn:00005E2C ; ===========================================================================
.text$mn:00005E2C
.text$mn:00005E2C ; Segment type: Pure code
.text$mn:00005E2C ; Segment permissions: Read/Execute
.text$mn:00005E2C _text$mn        segment para public 'CODE' use32
.text$mn:00005E2C                 assume cs:_text$mn
.text$mn:00005E2C                 ;org 5E2Ch
.text$mn:00005E2C ; COMDAT (pick any)
.text$mn:00005E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E2C
.text$mn:00005E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00005E2C
.text$mn:00005E2C ; Attributes: bp-based frame
.text$mn:00005E2C
.text$mn:00005E2C ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:00005E2C                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:00005E2C ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:00005E2C
.text$mn:00005E2C var_4           = dword ptr -4
.text$mn:00005E2C arg_0           = dword ptr  8
.text$mn:00005E2C
.text$mn:00005E2C                 push    ebp
.text$mn:00005E2D                 mov     ebp, esp
.text$mn:00005E2F                 push    ecx
.text$mn:00005E30                 mov     [ebp+var_4], ecx
.text$mn:00005E33                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005E36                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:00005E3B                 mov     eax, [ebp+arg_0]
.text$mn:00005E3E                 and     eax, 1
.text$mn:00005E41                 jz      short loc_5E4F
.text$mn:00005E43                 mov     ecx, [ebp+var_4]
.text$mn:00005E46                 push    ecx             ; void *
.text$mn:00005E47                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005E4C                 add     esp, 4
.text$mn:00005E4F
.text$mn:00005E4F loc_5E4F:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:00005E4F                 mov     eax, [ebp+var_4]
.text$mn:00005E52                 mov     esp, ebp
.text$mn:00005E54                 pop     ebp
.text$mn:00005E55                 retn    4
.text$mn:00005E55 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:00005E55
.text$mn:00005E55 _text$mn        ends
.text$mn:00005E55
.text$di:00005E58 ; ===========================================================================
.text$di:00005E58
.text$di:00005E58 ; Segment type: Pure code
.text$di:00005E58 ; Segment permissions: Read/Execute
.text$di:00005E58 _text$di        segment para public 'CODE' use32
.text$di:00005E58                 assume cs:_text$di
.text$di:00005E58                 ;org 5E58h
.text$di:00005E58 ; COMDAT (pick any)
.text$di:00005E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005E58
.text$di:00005E58 ; =============== S U B R O U T I N E =======================================
.text$di:00005E58
.text$di:00005E58 ; Attributes: bp-based frame
.text$di:00005E58
.text$di:00005E58 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00005E58 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00005E58                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00005E58                 push    ebp
.text$di:00005E59                 mov     ebp, esp
.text$di:00005E5B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00005E60                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00005E65                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00005E6A                 call    _atexit
.text$di:00005E6F                 add     esp, 4
.text$di:00005E72                 pop     ebp
.text$di:00005E73                 retn
.text$di:00005E73 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00005E73
.text$di:00005E73 _text$di        ends
.text$di:00005E73
.text$di:00005E74 ; ===========================================================================
.text$di:00005E74
.text$di:00005E74 ; Segment type: Pure code
.text$di:00005E74 ; Segment permissions: Read/Execute
.text$di:00005E74 _text$di        segment para public 'CODE' use32
.text$di:00005E74                 assume cs:_text$di
.text$di:00005E74                 ;org 5E74h
.text$di:00005E74 ; COMDAT (pick any)
.text$di:00005E74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005E74
.text$di:00005E74 ; =============== S U B R O U T I N E =======================================
.text$di:00005E74
.text$di:00005E74 ; Attributes: bp-based frame
.text$di:00005E74
.text$di:00005E74 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00005E74 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00005E74                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00005E74                 push    ebp
.text$di:00005E75                 mov     ebp, esp
.text$di:00005E77                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00005E7C                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00005E81                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00005E86                 call    _atexit
.text$di:00005E8B                 add     esp, 4
.text$di:00005E8E                 pop     ebp
.text$di:00005E8F                 retn
.text$di:00005E8F ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00005E8F
.text$di:00005E8F _text$di        ends
.text$di:00005E8F
.text$di:00005E90 ; ===========================================================================
.text$di:00005E90
.text$di:00005E90 ; Segment type: Pure code
.text$di:00005E90 ; Segment permissions: Read/Execute
.text$di:00005E90 _text$di        segment para public 'CODE' use32
.text$di:00005E90                 assume cs:_text$di
.text$di:00005E90                 ;org 5E90h
.text$di:00005E90 ; COMDAT (pick any)
.text$di:00005E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005E90
.text$di:00005E90 ; =============== S U B R O U T I N E =======================================
.text$di:00005E90
.text$di:00005E90 ; Attributes: bp-based frame
.text$di:00005E90
.text$di:00005E90 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00005E90 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00005E90                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00005E90                 push    ebp
.text$di:00005E91                 mov     ebp, esp
.text$di:00005E93                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00005E98                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00005E9D                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00005EA2                 call    _atexit
.text$di:00005EA7                 add     esp, 4
.text$di:00005EAA                 pop     ebp
.text$di:00005EAB                 retn
.text$di:00005EAB ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00005EAB
.text$di:00005EAB _text$di        ends
.text$di:00005EAB
.text$di:00005EAC ; ===========================================================================
.text$di:00005EAC
.text$di:00005EAC ; Segment type: Pure code
.text$di:00005EAC ; Segment permissions: Read/Execute
.text$di:00005EAC _text$di        segment para public 'CODE' use32
.text$di:00005EAC                 assume cs:_text$di
.text$di:00005EAC                 ;org 5EACh
.text$di:00005EAC ; COMDAT (pick any)
.text$di:00005EAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005EAC
.text$di:00005EAC ; =============== S U B R O U T I N E =======================================
.text$di:00005EAC
.text$di:00005EAC ; Attributes: bp-based frame
.text$di:00005EAC
.text$di:00005EAC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00005EAC ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005EAC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00005EAC                 push    ebp
.text$di:00005EAD                 mov     ebp, esp
.text$di:00005EAF                 push    0               ; unsigned int
.text$di:00005EB1                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00005EB6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005EBB                 pop     ebp
.text$di:00005EBC                 retn
.text$di:00005EBC ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005EBC
.text$di:00005EBC ; ---------------------------------------------------------------------------
.text$di:00005EBD                 align 10h
.text$di:00005EBD _text$di        ends
.text$di:00005EBD
.text$di:00005EC0 ; ===========================================================================
.text$di:00005EC0
.text$di:00005EC0 ; Segment type: Pure code
.text$di:00005EC0 ; Segment permissions: Read/Execute
.text$di:00005EC0 _text$di        segment para public 'CODE' use32
.text$di:00005EC0                 assume cs:_text$di
.text$di:00005EC0                 ;org 5EC0h
.text$di:00005EC0 ; COMDAT (pick any)
.text$di:00005EC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005EC0
.text$di:00005EC0 ; =============== S U B R O U T I N E =======================================
.text$di:00005EC0
.text$di:00005EC0 ; Attributes: bp-based frame
.text$di:00005EC0
.text$di:00005EC0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00005EC0 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005EC0                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00005EC0                 push    ebp
.text$di:00005EC1                 mov     ebp, esp
.text$di:00005EC3                 push    0               ; unsigned int
.text$di:00005EC5                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00005ECA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005ECF                 pop     ebp
.text$di:00005ED0                 retn
.text$di:00005ED0 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005ED0
.text$di:00005ED0 ; ---------------------------------------------------------------------------
.text$di:00005ED1                 align 4
.text$di:00005ED1 _text$di        ends
.text$di:00005ED1
.text$di:00005ED4 ; ===========================================================================
.text$di:00005ED4
.text$di:00005ED4 ; Segment type: Pure code
.text$di:00005ED4 ; Segment permissions: Read/Execute
.text$di:00005ED4 _text$di        segment para public 'CODE' use32
.text$di:00005ED4                 assume cs:_text$di
.text$di:00005ED4                 ;org 5ED4h
.text$di:00005ED4 ; COMDAT (pick any)
.text$di:00005ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005ED4
.text$di:00005ED4 ; =============== S U B R O U T I N E =======================================
.text$di:00005ED4
.text$di:00005ED4 ; Attributes: bp-based frame
.text$di:00005ED4
.text$di:00005ED4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00005ED4 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005ED4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00005ED4                 push    ebp
.text$di:00005ED5                 mov     ebp, esp
.text$di:00005ED7                 push    0               ; unsigned int
.text$di:00005ED9                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00005EDE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005EE3                 pop     ebp
.text$di:00005EE4                 retn
.text$di:00005EE4 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005EE4
.text$di:00005EE4 ; ---------------------------------------------------------------------------
.text$di:00005EE5                 align 4
.text$di:00005EE5 _text$di        ends
.text$di:00005EE5
.text$di:00005EE8 ; ===========================================================================
.text$di:00005EE8
.text$di:00005EE8 ; Segment type: Pure code
.text$di:00005EE8 ; Segment permissions: Read/Execute
.text$di:00005EE8 _text$di        segment para public 'CODE' use32
.text$di:00005EE8                 assume cs:_text$di
.text$di:00005EE8                 ;org 5EE8h
.text$di:00005EE8 ; COMDAT (pick any)
.text$di:00005EE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005EE8
.text$di:00005EE8 ; =============== S U B R O U T I N E =======================================
.text$di:00005EE8
.text$di:00005EE8 ; Attributes: bp-based frame
.text$di:00005EE8
.text$di:00005EE8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00005EE8 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00005EE8                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00005EE8                 push    ebp
.text$di:00005EE9                 mov     ebp, esp
.text$di:00005EEB                 push    0               ; unsigned int
.text$di:00005EED                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00005EF2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00005EF7                 pop     ebp
.text$di:00005EF8                 retn
.text$di:00005EF8 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00005EF8
.text$di:00005EF8 ; ---------------------------------------------------------------------------
.text$di:00005EF9                 align 4
.text$di:00005EF9 _text$di        ends
.text$di:00005EF9
.text$di:00005EFC ; ===========================================================================
.text$di:00005EFC
.text$di:00005EFC ; Segment type: Pure code
.text$di:00005EFC ; Segment permissions: Read/Execute
.text$di:00005EFC _text$di        segment para public 'CODE' use32
.text$di:00005EFC                 assume cs:_text$di
.text$di:00005EFC                 ;org 5EFCh
.text$di:00005EFC ; COMDAT (pick any)
.text$di:00005EFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005EFC
.text$di:00005EFC ; =============== S U B R O U T I N E =======================================
.text$di:00005EFC
.text$di:00005EFC ; Attributes: bp-based frame
.text$di:00005EFC
.text$di:00005EFC ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00005EFC ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00005EFC
.text$di:00005EFC var_1           = byte ptr -1
.text$di:00005EFC
.text$di:00005EFC                 push    ebp
.text$di:00005EFD                 mov     ebp, esp
.text$di:00005EFF                 push    ecx
.text$di:00005F00                 xor     eax, eax
.text$di:00005F02                 mov     [ebp+var_1], al
.text$di:00005F05                 mov     esp, ebp
.text$di:00005F07                 pop     ebp
.text$di:00005F08                 retn
.text$di:00005F08 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00005F08
.text$di:00005F08 ; ---------------------------------------------------------------------------
.text$di:00005F09                 align 4
.text$di:00005F09 _text$di        ends
.text$di:00005F09
.text$di:00005F0C ; ===========================================================================
.text$di:00005F0C
.text$di:00005F0C ; Segment type: Pure code
.text$di:00005F0C ; Segment permissions: Read/Execute
.text$di:00005F0C _text$di        segment para public 'CODE' use32
.text$di:00005F0C                 assume cs:_text$di
.text$di:00005F0C                 ;org 5F0Ch
.text$di:00005F0C ; COMDAT (pick any)
.text$di:00005F0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00005F0C
.text$di:00005F0C ; =============== S U B R O U T I N E =======================================
.text$di:00005F0C
.text$di:00005F0C ; Attributes: bp-based frame
.text$di:00005F0C
.text$di:00005F0C ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00005F0C ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00005F0C                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00005F0C
.text$di:00005F0C var_1           = byte ptr -1
.text$di:00005F0C
.text$di:00005F0C                 push    ebp
.text$di:00005F0D                 mov     ebp, esp
.text$di:00005F0F                 push    ecx
.text$di:00005F10                 xor     eax, eax
.text$di:00005F12                 mov     [ebp+var_1], al
.text$di:00005F15                 mov     esp, ebp
.text$di:00005F17                 pop     ebp
.text$di:00005F18                 retn
.text$di:00005F18 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00005F18
.text$di:00005F18 ; ---------------------------------------------------------------------------
.text$di:00005F19                 align 4
.text$di:00005F19 _text$di        ends
.text$di:00005F19
.text$yd:00005F1C ; ===========================================================================
.text$yd:00005F1C
.text$yd:00005F1C ; Segment type: Pure code
.text$yd:00005F1C ; Segment permissions: Read/Execute
.text$yd:00005F1C _text$yd        segment para public 'CODE' use32
.text$yd:00005F1C                 assume cs:_text$yd
.text$yd:00005F1C                 ;org 5F1Ch
.text$yd:00005F1C ; COMDAT (pick any)
.text$yd:00005F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00005F1C
.text$yd:00005F1C ; =============== S U B R O U T I N E =======================================
.text$yd:00005F1C
.text$yd:00005F1C ; Attributes: bp-based frame
.text$yd:00005F1C
.text$yd:00005F1C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00005F1C ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00005F1C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00005F1C                 push    ebp
.text$yd:00005F1D                 mov     ebp, esp
.text$yd:00005F1F                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00005F24                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00005F29                 pop     ebp
.text$yd:00005F2A                 retn
.text$yd:00005F2A ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00005F2A
.text$yd:00005F2A ; ---------------------------------------------------------------------------
.text$yd:00005F2B                 align 4
.text$yd:00005F2B _text$yd        ends
.text$yd:00005F2B
.text$yd:00005F2C ; ===========================================================================
.text$yd:00005F2C
.text$yd:00005F2C ; Segment type: Pure code
.text$yd:00005F2C ; Segment permissions: Read/Execute
.text$yd:00005F2C _text$yd        segment para public 'CODE' use32
.text$yd:00005F2C                 assume cs:_text$yd
.text$yd:00005F2C                 ;org 5F2Ch
.text$yd:00005F2C ; COMDAT (pick any)
.text$yd:00005F2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00005F2C
.text$yd:00005F2C ; =============== S U B R O U T I N E =======================================
.text$yd:00005F2C
.text$yd:00005F2C ; Attributes: bp-based frame
.text$yd:00005F2C
.text$yd:00005F2C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00005F2C ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00005F2C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00005F2C                 push    ebp
.text$yd:00005F2D                 mov     ebp, esp
.text$yd:00005F2F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00005F34                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00005F39                 pop     ebp
.text$yd:00005F3A                 retn
.text$yd:00005F3A ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00005F3A
.text$yd:00005F3A ; ---------------------------------------------------------------------------
.text$yd:00005F3B                 align 4
.text$yd:00005F3B _text$yd        ends
.text$yd:00005F3B
.text$yd:00005F3C ; ===========================================================================
.text$yd:00005F3C
.text$yd:00005F3C ; Segment type: Pure code
.text$yd:00005F3C ; Segment permissions: Read/Execute
.text$yd:00005F3C _text$yd        segment para public 'CODE' use32
.text$yd:00005F3C                 assume cs:_text$yd
.text$yd:00005F3C                 ;org 5F3Ch
.text$yd:00005F3C ; COMDAT (pick any)
.text$yd:00005F3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00005F3C
.text$yd:00005F3C ; =============== S U B R O U T I N E =======================================
.text$yd:00005F3C
.text$yd:00005F3C ; Attributes: bp-based frame
.text$yd:00005F3C
.text$yd:00005F3C ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00005F3C ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00005F3C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00005F3C                 push    ebp
.text$yd:00005F3D                 mov     ebp, esp
.text$yd:00005F3F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00005F44                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00005F49                 pop     ebp
.text$yd:00005F4A                 retn
.text$yd:00005F4A ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00005F4A
.text$yd:00005F4A ; ---------------------------------------------------------------------------
.text$yd:00005F4B                 align 4
.text$yd:00005F4B _text$yd        ends
.text$yd:00005F4B
.text$mn:00005F4C ; ===========================================================================
.text$mn:00005F4C
.text$mn:00005F4C ; Segment type: Pure code
.text$mn:00005F4C ; Segment permissions: Read/Execute
.text$mn:00005F4C _text$mn        segment para public 'CODE' use32
.text$mn:00005F4C                 assume cs:_text$mn
.text$mn:00005F4C                 ;org 5F4Ch
.text$mn:00005F4C ; COMDAT (pick any)
.text$mn:00005F4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F4C
.text$mn:00005F4C ; =============== S U B R O U T I N E =======================================
.text$mn:00005F4C
.text$mn:00005F4C ; Attributes: bp-based frame
.text$mn:00005F4C
.text$mn:00005F4C ; void __thiscall DockingCont::SetActive(DockingCont *this, int)
.text$mn:00005F4C                 public ?SetActive@DockingCont@@QAEXH@Z
.text$mn:00005F4C ?SetActive@DockingCont@@QAEXH@Z proc near
.text$mn:00005F4C                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+251p
.text$mn:00005F4C                                         ; FocusWndProc(int,uint,long)+7Ap ...
.text$mn:00005F4C
.text$mn:00005F4C var_4           = dword ptr -4
.text$mn:00005F4C arg_0           = dword ptr  8
.text$mn:00005F4C
.text$mn:00005F4C                 push    ebp
.text$mn:00005F4D                 mov     ebp, esp
.text$mn:00005F4F                 push    ecx
.text$mn:00005F50                 mov     [ebp+var_4], ecx
.text$mn:00005F53                 mov     eax, [ebp+var_4]
.text$mn:00005F56                 mov     ecx, [ebp+arg_0]
.text$mn:00005F59                 mov     [eax+20h], ecx
.text$mn:00005F5C                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005F5F                 call    ?updateCaption@DockingCont@@IAE_NXZ ; DockingCont::updateCaption(void)
.text$mn:00005F64                 mov     esp, ebp
.text$mn:00005F66                 pop     ebp
.text$mn:00005F67                 retn    4
.text$mn:00005F67 ?SetActive@DockingCont@@QAEXH@Z endp
.text$mn:00005F67
.text$mn:00005F67 ; ---------------------------------------------------------------------------
.text$mn:00005F6A                 align 4
.text$mn:00005F6A _text$mn        ends
.text$mn:00005F6A
.text$mn:00005F6C ; ===========================================================================
.text$mn:00005F6C
.text$mn:00005F6C ; Segment type: Pure code
.text$mn:00005F6C ; Segment permissions: Read/Execute
.text$mn:00005F6C _text$mn        segment para public 'CODE' use32
.text$mn:00005F6C                 assume cs:_text$mn
.text$mn:00005F6C                 ;org 5F6Ch
.text$mn:00005F6C ; COMDAT (pick any)
.text$mn:00005F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F6C
.text$mn:00005F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00005F6C
.text$mn:00005F6C ; Attributes: bp-based frame
.text$mn:00005F6C
.text$mn:00005F6C ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00005F6C                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00005F6C ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00005F6C                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(tTbData * *,std::_Container_base12 const *)+45p
.text$mn:00005F6C                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+49p
.text$mn:00005F6C
.text$mn:00005F6C var_1C          = byte ptr -1Ch
.text$mn:00005F6C var_18          = byte ptr -18h
.text$mn:00005F6C var_14          = dword ptr -14h
.text$mn:00005F6C var_10          = dword ptr -10h
.text$mn:00005F6C var_C           = dword ptr -0Ch
.text$mn:00005F6C var_4           = dword ptr -4
.text$mn:00005F6C arg_0           = dword ptr  8
.text$mn:00005F6C
.text$mn:00005F6C                 push    ebp
.text$mn:00005F6D                 mov     ebp, esp
.text$mn:00005F6F                 push    0FFFFFFFFh
.text$mn:00005F71                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00005F76                 mov     eax, large fs:0
.text$mn:00005F7C                 push    eax
.text$mn:00005F7D                 sub     esp, 10h
.text$mn:00005F80                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005F85                 xor     eax, ebp
.text$mn:00005F87                 push    eax
.text$mn:00005F88                 lea     eax, [ebp+var_C]
.text$mn:00005F8B                 mov     large fs:0, eax
.text$mn:00005F91                 mov     [ebp+var_10], ecx
.text$mn:00005F94                 cmp     [ebp+arg_0], 0
.text$mn:00005F98                 jnz     short loc_5FC4
.text$mn:00005F9A                 push    3               ; int
.text$mn:00005F9C                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005F9F                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005FA4                 mov     [ebp+var_4], 0
.text$mn:00005FAB                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005FAE                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00005FB3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005FBA                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005FBD                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00005FC2                 jmp     short loc_601B
.text$mn:00005FC4 ; ---------------------------------------------------------------------------
.text$mn:00005FC4
.text$mn:00005FC4 loc_5FC4:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:00005FC4                 mov     eax, [ebp+arg_0]
.text$mn:00005FC7                 mov     ecx, [eax]
.text$mn:00005FC9                 mov     [ebp+var_14], ecx
.text$mn:00005FCC                 mov     edx, [ebp+var_10]
.text$mn:00005FCF                 mov     eax, [edx]
.text$mn:00005FD1                 cmp     eax, [ebp+var_14]
.text$mn:00005FD4                 jz      short loc_601B
.text$mn:00005FD6                 push    3               ; int
.text$mn:00005FD8                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00005FDB                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005FE0                 mov     [ebp+var_4], 1
.text$mn:00005FE7                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005FEA                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00005FEF                 mov     ecx, [ebp+var_10]
.text$mn:00005FF2                 mov     edx, [ebp+var_14]
.text$mn:00005FF5                 mov     eax, [edx+4]
.text$mn:00005FF8                 mov     [ecx+4], eax
.text$mn:00005FFB                 mov     ecx, [ebp+var_14]
.text$mn:00005FFE                 mov     edx, [ebp+var_10]
.text$mn:00006001                 mov     [ecx+4], edx
.text$mn:00006004                 mov     eax, [ebp+var_10]
.text$mn:00006007                 mov     ecx, [ebp+var_14]
.text$mn:0000600A                 mov     [eax], ecx
.text$mn:0000600C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006013                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00006016                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000601B
.text$mn:0000601B loc_601B:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:0000601B                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:0000601B                 mov     ecx, [ebp+var_C]
.text$mn:0000601E                 mov     large fs:0, ecx
.text$mn:00006025                 pop     ecx
.text$mn:00006026                 mov     esp, ebp
.text$mn:00006028                 pop     ebp
.text$mn:00006029                 retn    4
.text$mn:00006029 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00006029
.text$mn:00006029 _text$mn        ends
.text$mn:00006029
.text$x:0000602C ; ===========================================================================
.text$x:0000602C
.text$x:0000602C ; Segment type: Pure code
.text$x:0000602C ; Segment permissions: Read/Execute
.text$x:0000602C _text$x         segment para public 'CODE' use32
.text$x:0000602C                 assume cs:_text$x
.text$x:0000602C                 ;org 602Ch
.text$x:0000602C ; COMDAT (pick associative to section at 5F6C)
.text$x:0000602C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000602C
.text$x:0000602C ; =============== S U B R O U T I N E =======================================
.text$x:0000602C
.text$x:0000602C
.text$x:0000602C __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:0000602C                                         ; DATA XREF: .xdata$x:00008CBCo
.text$x:0000602C                 lea     ecx, [ebp-18h]  ; this
.text$x:0000602F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000602F __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:0000602F
.text$x:00006034
.text$x:00006034 ; =============== S U B R O U T I N E =======================================
.text$x:00006034
.text$x:00006034
.text$x:00006034 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00006034                                         ; DATA XREF: .xdata$x:00008CC4o
.text$x:00006034                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00006037                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006037 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00006037
.text$x:0000603C
.text$x:0000603C ; =============== S U B R O U T I N E =======================================
.text$x:0000603C
.text$x:0000603C
.text$x:0000603C __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:0000603C                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:0000603C
.text$x:0000603C arg_4           = dword ptr  8
.text$x:0000603C
.text$x:0000603C                 mov     edx, [esp+arg_4]
.text$x:00006040                 lea     eax, [edx+0Ch]
.text$x:00006043                 mov     ecx, [edx-14h]
.text$x:00006046                 xor     ecx, eax
.text$x:00006048                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000604D                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:00006052                 jmp     ___CxxFrameHandler3
.text$x:00006052 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:00006052
.text$x:00006052 ; ---------------------------------------------------------------------------
.text$x:00006057                 align 4
.text$x:00006057 _text$x         ends
.text$x:00006057
.text$mn:00006058 ; ===========================================================================
.text$mn:00006058
.text$mn:00006058 ; Segment type: Pure code
.text$mn:00006058 ; Segment permissions: Read/Execute
.text$mn:00006058 _text$mn        segment para public 'CODE' use32
.text$mn:00006058                 assume cs:_text$mn
.text$mn:00006058                 ;org 6058h
.text$mn:00006058 ; COMDAT (pick any)
.text$mn:00006058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006058
.text$mn:00006058 ; =============== S U B R O U T I N E =======================================
.text$mn:00006058
.text$mn:00006058 ; Attributes: bp-based frame
.text$mn:00006058
.text$mn:00006058 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00006058                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00006058 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006058                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00006058
.text$mn:00006058 var_10          = byte ptr -10h
.text$mn:00006058 var_8           = dword ptr -8
.text$mn:00006058 var_1           = byte ptr -1
.text$mn:00006058
.text$mn:00006058                 push    ebp
.text$mn:00006059                 mov     ebp, esp
.text$mn:0000605B                 sub     esp, 10h
.text$mn:0000605E                 mov     [ebp+var_8], ecx
.text$mn:00006061                 lea     ecx, [ebp+var_1]
.text$mn:00006064                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00006069                 push    1
.text$mn:0000606B                 lea     ecx, [ebp+var_1]
.text$mn:0000606E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00006073                 mov     ecx, [ebp+var_8]
.text$mn:00006076                 mov     [ecx], eax
.text$mn:00006078                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000607B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00006080                 push    eax             ; int
.text$mn:00006081                 mov     edx, [ebp+var_8]
.text$mn:00006084                 mov     eax, [edx]
.text$mn:00006086                 push    eax             ; void *
.text$mn:00006087                 lea     ecx, [ebp+var_1]
.text$mn:0000608A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000608F                 mov     ecx, [ebp+var_8]
.text$mn:00006092                 mov     edx, [ecx]
.text$mn:00006094                 mov     eax, [ebp+var_8]
.text$mn:00006097                 mov     [edx], eax
.text$mn:00006099                 mov     esp, ebp
.text$mn:0000609B                 pop     ebp
.text$mn:0000609C                 retn
.text$mn:0000609C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000609C
.text$mn:0000609C ; ---------------------------------------------------------------------------
.text$mn:0000609D                 align 10h
.text$mn:0000609D _text$mn        ends
.text$mn:0000609D
.text$mn:000060A0 ; ===========================================================================
.text$mn:000060A0
.text$mn:000060A0 ; Segment type: Pure code
.text$mn:000060A0 ; Segment permissions: Read/Execute
.text$mn:000060A0 _text$mn        segment para public 'CODE' use32
.text$mn:000060A0                 assume cs:_text$mn
.text$mn:000060A0                 ;org 60A0h
.text$mn:000060A0 ; COMDAT (pick any)
.text$mn:000060A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060A0
.text$mn:000060A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060A0
.text$mn:000060A0 ; Attributes: bp-based frame
.text$mn:000060A0
.text$mn:000060A0 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct HWND__ *, class std::allocator<struct HWND__ *>>>::_Alloc_proxy(void)
.text$mn:000060A0                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAEXXZ
.text$mn:000060A0 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000060A0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>(std::allocator<HWND__ *> const &)+38p
.text$mn:000060A0
.text$mn:000060A0 var_10          = byte ptr -10h
.text$mn:000060A0 var_8           = dword ptr -8
.text$mn:000060A0 var_1           = byte ptr -1
.text$mn:000060A0
.text$mn:000060A0                 push    ebp
.text$mn:000060A1                 mov     ebp, esp
.text$mn:000060A3                 sub     esp, 10h
.text$mn:000060A6                 mov     [ebp+var_8], ecx
.text$mn:000060A9                 lea     ecx, [ebp+var_1]
.text$mn:000060AC                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000060B1                 push    1
.text$mn:000060B3                 lea     ecx, [ebp+var_1]
.text$mn:000060B6                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:000060BB                 mov     ecx, [ebp+var_8]
.text$mn:000060BE                 mov     [ecx], eax
.text$mn:000060C0                 lea     ecx, [ebp+var_10] ; this
.text$mn:000060C3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000060C8                 push    eax             ; int
.text$mn:000060C9                 mov     edx, [ebp+var_8]
.text$mn:000060CC                 mov     eax, [edx]
.text$mn:000060CE                 push    eax             ; void *
.text$mn:000060CF                 lea     ecx, [ebp+var_1]
.text$mn:000060D2                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000060D7                 mov     ecx, [ebp+var_8]
.text$mn:000060DA                 mov     edx, [ecx]
.text$mn:000060DC                 mov     eax, [ebp+var_8]
.text$mn:000060DF                 mov     [edx], eax
.text$mn:000060E1                 mov     esp, ebp
.text$mn:000060E3                 pop     ebp
.text$mn:000060E4                 retn
.text$mn:000060E4 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:000060E4
.text$mn:000060E4 ; ---------------------------------------------------------------------------
.text$mn:000060E5                 align 4
.text$mn:000060E5 _text$mn        ends
.text$mn:000060E5
.text$mn:000060E8 ; ===========================================================================
.text$mn:000060E8
.text$mn:000060E8 ; Segment type: Pure code
.text$mn:000060E8 ; Segment permissions: Read/Execute
.text$mn:000060E8 _text$mn        segment para public 'CODE' use32
.text$mn:000060E8                 assume cs:_text$mn
.text$mn:000060E8                 ;org 60E8h
.text$mn:000060E8 ; COMDAT (pick any)
.text$mn:000060E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060E8
.text$mn:000060E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000060E8
.text$mn:000060E8 ; Attributes: bp-based frame
.text$mn:000060E8
.text$mn:000060E8 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct tTbData *, class std::allocator<struct tTbData *>>>::_Alloc_proxy(void)
.text$mn:000060E8                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAEXXZ
.text$mn:000060E8 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000060E8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>(std::allocator<tTbData *> const &)+38p
.text$mn:000060E8
.text$mn:000060E8 var_10          = byte ptr -10h
.text$mn:000060E8 var_8           = dword ptr -8
.text$mn:000060E8 var_1           = byte ptr -1
.text$mn:000060E8
.text$mn:000060E8                 push    ebp
.text$mn:000060E9                 mov     ebp, esp
.text$mn:000060EB                 sub     esp, 10h
.text$mn:000060EE                 mov     [ebp+var_8], ecx
.text$mn:000060F1                 lea     ecx, [ebp+var_1]
.text$mn:000060F4                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000060F9                 push    1
.text$mn:000060FB                 lea     ecx, [ebp+var_1]
.text$mn:000060FE                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00006103                 mov     ecx, [ebp+var_8]
.text$mn:00006106                 mov     [ecx], eax
.text$mn:00006108                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000610B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00006110                 push    eax             ; int
.text$mn:00006111                 mov     edx, [ebp+var_8]
.text$mn:00006114                 mov     eax, [edx]
.text$mn:00006116                 push    eax             ; void *
.text$mn:00006117                 lea     ecx, [ebp+var_1]
.text$mn:0000611A                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000611F                 mov     ecx, [ebp+var_8]
.text$mn:00006122                 mov     edx, [ecx]
.text$mn:00006124                 mov     eax, [ebp+var_8]
.text$mn:00006127                 mov     [edx], eax
.text$mn:00006129                 mov     esp, ebp
.text$mn:0000612B                 pop     ebp
.text$mn:0000612C                 retn
.text$mn:0000612C ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000612C
.text$mn:0000612C ; ---------------------------------------------------------------------------
.text$mn:0000612D                 align 10h
.text$mn:0000612D _text$mn        ends
.text$mn:0000612D
.text$mn:00006130 ; ===========================================================================
.text$mn:00006130
.text$mn:00006130 ; Segment type: Pure code
.text$mn:00006130 ; Segment permissions: Read/Execute
.text$mn:00006130 _text$mn        segment para public 'CODE' use32
.text$mn:00006130                 assume cs:_text$mn
.text$mn:00006130                 ;org 6130h
.text$mn:00006130 ; COMDAT (pick any)
.text$mn:00006130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006130
.text$mn:00006130 ; =============== S U B R O U T I N E =======================================
.text$mn:00006130
.text$mn:00006130 ; Attributes: bp-based frame
.text$mn:00006130
.text$mn:00006130 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>::_Alloc_proxy(void)
.text$mn:00006130                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ
.text$mn:00006130 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006130                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(std::allocator<DockingCont *> const &)+38p
.text$mn:00006130
.text$mn:00006130 var_10          = byte ptr -10h
.text$mn:00006130 var_8           = dword ptr -8
.text$mn:00006130 var_1           = byte ptr -1
.text$mn:00006130
.text$mn:00006130                 push    ebp
.text$mn:00006131                 mov     ebp, esp
.text$mn:00006133                 sub     esp, 10h
.text$mn:00006136                 mov     [ebp+var_8], ecx
.text$mn:00006139                 lea     ecx, [ebp+var_1]
.text$mn:0000613C                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00006141                 push    1
.text$mn:00006143                 lea     ecx, [ebp+var_1]
.text$mn:00006146                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:0000614B                 mov     ecx, [ebp+var_8]
.text$mn:0000614E                 mov     [ecx], eax
.text$mn:00006150                 lea     ecx, [ebp+var_10] ; this
.text$mn:00006153                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00006158                 push    eax             ; int
.text$mn:00006159                 mov     edx, [ebp+var_8]
.text$mn:0000615C                 mov     eax, [edx]
.text$mn:0000615E                 push    eax             ; void *
.text$mn:0000615F                 lea     ecx, [ebp+var_1]
.text$mn:00006162                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00006167                 mov     ecx, [ebp+var_8]
.text$mn:0000616A                 mov     edx, [ecx]
.text$mn:0000616C                 mov     eax, [ebp+var_8]
.text$mn:0000616F                 mov     [edx], eax
.text$mn:00006171                 mov     esp, ebp
.text$mn:00006173                 pop     ebp
.text$mn:00006174                 retn
.text$mn:00006174 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00006174
.text$mn:00006174 ; ---------------------------------------------------------------------------
.text$mn:00006175                 align 4
.text$mn:00006175 _text$mn        ends
.text$mn:00006175
.text$mn:00006178 ; ===========================================================================
.text$mn:00006178
.text$mn:00006178 ; Segment type: Pure code
.text$mn:00006178 ; Segment permissions: Read/Execute
.text$mn:00006178 _text$mn        segment para public 'CODE' use32
.text$mn:00006178                 assume cs:_text$mn
.text$mn:00006178                 ;org 6178h
.text$mn:00006178 ; COMDAT (pick any)
.text$mn:00006178                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006178
.text$mn:00006178 ; =============== S U B R O U T I N E =======================================
.text$mn:00006178
.text$mn:00006178 ; Attributes: bp-based frame
.text$mn:00006178
.text$mn:00006178 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingSplitter *, class std::allocator<class DockingSplitter *>>>::_Alloc_proxy(void)
.text$mn:00006178                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAEXXZ
.text$mn:00006178 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006178                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>(std::allocator<DockingSplitter *> const &)+38p
.text$mn:00006178
.text$mn:00006178 var_10          = byte ptr -10h
.text$mn:00006178 var_8           = dword ptr -8
.text$mn:00006178 var_1           = byte ptr -1
.text$mn:00006178
.text$mn:00006178                 push    ebp
.text$mn:00006179                 mov     ebp, esp
.text$mn:0000617B                 sub     esp, 10h
.text$mn:0000617E                 mov     [ebp+var_8], ecx
.text$mn:00006181                 lea     ecx, [ebp+var_1]
.text$mn:00006184                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00006189                 push    1
.text$mn:0000618B                 lea     ecx, [ebp+var_1]
.text$mn:0000618E                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00006193                 mov     ecx, [ebp+var_8]
.text$mn:00006196                 mov     [ecx], eax
.text$mn:00006198                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000619B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000061A0                 push    eax             ; int
.text$mn:000061A1                 mov     edx, [ebp+var_8]
.text$mn:000061A4                 mov     eax, [edx]
.text$mn:000061A6                 push    eax             ; void *
.text$mn:000061A7                 lea     ecx, [ebp+var_1]
.text$mn:000061AA                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000061AF                 mov     ecx, [ebp+var_8]
.text$mn:000061B2                 mov     edx, [ecx]
.text$mn:000061B4                 mov     eax, [ebp+var_8]
.text$mn:000061B7                 mov     [edx], eax
.text$mn:000061B9                 mov     esp, ebp
.text$mn:000061BB                 pop     ebp
.text$mn:000061BC                 retn
.text$mn:000061BC ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:000061BC
.text$mn:000061BC ; ---------------------------------------------------------------------------
.text$mn:000061BD                 align 10h
.text$mn:000061BD _text$mn        ends
.text$mn:000061BD
.text$mn:000061C0 ; ===========================================================================
.text$mn:000061C0
.text$mn:000061C0 ; Segment type: Pure code
.text$mn:000061C0 ; Segment permissions: Read/Execute
.text$mn:000061C0 _text$mn        segment para public 'CODE' use32
.text$mn:000061C0                 assume cs:_text$mn
.text$mn:000061C0                 ;org 61C0h
.text$mn:000061C0 ; COMDAT (pick any)
.text$mn:000061C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000061C0
.text$mn:000061C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000061C0
.text$mn:000061C0 ; Attributes: bp-based frame
.text$mn:000061C0
.text$mn:000061C0 ; protected: bool __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::_Buy(unsigned int)
.text$mn:000061C0                 public ?_Buy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAE_NI@Z
.text$mn:000061C0 ?_Buy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAE_NI@Z proc near
.text$mn:000061C0                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+62p
.text$mn:000061C0
.text$mn:000061C0 var_8           = dword ptr -8
.text$mn:000061C0 var_1           = byte ptr -1
.text$mn:000061C0 arg_0           = dword ptr  8
.text$mn:000061C0
.text$mn:000061C0                 push    ebp
.text$mn:000061C1                 mov     ebp, esp
.text$mn:000061C3                 sub     esp, 8
.text$mn:000061C6                 mov     [ebp+var_8], ecx
.text$mn:000061C9                 mov     eax, [ebp+var_8]
.text$mn:000061CC                 mov     dword ptr [eax+4], 0
.text$mn:000061D3                 mov     ecx, [ebp+var_8]
.text$mn:000061D6                 mov     dword ptr [ecx+8], 0
.text$mn:000061DD                 mov     edx, [ebp+var_8]
.text$mn:000061E0                 mov     dword ptr [edx+0Ch], 0
.text$mn:000061E7                 cmp     [ebp+arg_0], 0
.text$mn:000061EB                 jnz     short loc_61F3
.text$mn:000061ED                 xor     al, al
.text$mn:000061EF                 jmp     short loc_6247
.text$mn:000061F1 ; ---------------------------------------------------------------------------
.text$mn:000061F1                 jmp     short loc_6245
.text$mn:000061F3 ; ---------------------------------------------------------------------------
.text$mn:000061F3
.text$mn:000061F3 loc_61F3:                               ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Buy(uint)+2Bj
.text$mn:000061F3                 mov     ecx, [ebp+var_8]
.text$mn:000061F6                 call    ?max_size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ ; std::vector<tTbData *,std::allocator<tTbData *>>::max_size(void)
.text$mn:000061FB                 cmp     eax, [ebp+arg_0]
.text$mn:000061FE                 jnb     short loc_620A
.text$mn:00006200                 mov     ecx, [ebp+var_8]
.text$mn:00006203                 call    ?_Xlen@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IBEXXZ ; std::vector<tTbData *,std::allocator<tTbData *>>::_Xlen(void)
.text$mn:00006208                 jmp     short loc_6245
.text$mn:0000620A ; ---------------------------------------------------------------------------
.text$mn:0000620A
.text$mn:0000620A loc_620A:                               ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Buy(uint)+3Ej
.text$mn:0000620A                 mov     eax, [ebp+arg_0]
.text$mn:0000620D                 push    eax
.text$mn:0000620E                 lea     ecx, [ebp+var_1]
.text$mn:00006211                 push    ecx
.text$mn:00006212                 mov     ecx, [ebp+var_8]
.text$mn:00006215                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Getal(void)
.text$mn:0000621A                 mov     ecx, eax
.text$mn:0000621C                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAEPAPAUtTbData@@I@Z ; std::_Wrap_alloc<std::allocator<tTbData *>>::allocate(uint)
.text$mn:00006221                 mov     edx, [ebp+var_8]
.text$mn:00006224                 mov     [edx+4], eax
.text$mn:00006227                 mov     eax, [ebp+var_8]
.text$mn:0000622A                 mov     ecx, [ebp+var_8]
.text$mn:0000622D                 mov     edx, [ecx+4]
.text$mn:00006230                 mov     [eax+8], edx
.text$mn:00006233                 mov     eax, [ebp+var_8]
.text$mn:00006236                 mov     ecx, [eax+4]
.text$mn:00006239                 mov     edx, [ebp+arg_0]
.text$mn:0000623C                 lea     eax, [ecx+edx*4]
.text$mn:0000623F                 mov     ecx, [ebp+var_8]
.text$mn:00006242                 mov     [ecx+0Ch], eax
.text$mn:00006245
.text$mn:00006245 loc_6245:                               ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Buy(uint)+31j
.text$mn:00006245                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::_Buy(uint)+48j
.text$mn:00006245                 mov     al, 1
.text$mn:00006247
.text$mn:00006247 loc_6247:                               ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Buy(uint)+2Fj
.text$mn:00006247                 mov     esp, ebp
.text$mn:00006249                 pop     ebp
.text$mn:0000624A                 retn    4
.text$mn:0000624A ?_Buy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAE_NI@Z endp
.text$mn:0000624A
.text$mn:0000624A ; ---------------------------------------------------------------------------
.text$mn:0000624D                 align 10h
.text$mn:0000624D _text$mn        ends
.text$mn:0000624D
.text$mn:00006250 ; ===========================================================================
.text$mn:00006250
.text$mn:00006250 ; Segment type: Pure code
.text$mn:00006250 ; Segment permissions: Read/Execute
.text$mn:00006250 _text$mn        segment para public 'CODE' use32
.text$mn:00006250                 assume cs:_text$mn
.text$mn:00006250                 ;org 6250h
.text$mn:00006250 ; COMDAT (pick any)
.text$mn:00006250                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006250
.text$mn:00006250 ; =============== S U B R O U T I N E =======================================
.text$mn:00006250
.text$mn:00006250 ; Attributes: bp-based frame
.text$mn:00006250
.text$mn:00006250 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00006250                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00006250 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00006250                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)+80p
.text$mn:00006250                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *)+80p ...
.text$mn:00006250
.text$mn:00006250 var_4           = dword ptr -4
.text$mn:00006250
.text$mn:00006250                 push    ebp
.text$mn:00006251                 mov     ebp, esp
.text$mn:00006253                 push    ecx
.text$mn:00006254                 mov     [ebp+var_4], ecx
.text$mn:00006257                 mov     eax, [ebp+var_4]
.text$mn:0000625A                 mov     dword ptr [eax], 0
.text$mn:00006260                 mov     esp, ebp
.text$mn:00006262                 pop     ebp
.text$mn:00006263                 retn
.text$mn:00006263 ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00006263
.text$mn:00006263 _text$mn        ends
.text$mn:00006263
.text$mn:00006264 ; ===========================================================================
.text$mn:00006264
.text$mn:00006264 ; Segment type: Pure code
.text$mn:00006264 ; Segment permissions: Read/Execute
.text$mn:00006264 _text$mn        segment para public 'CODE' use32
.text$mn:00006264                 assume cs:_text$mn
.text$mn:00006264                 ;org 6264h
.text$mn:00006264 ; COMDAT (pick any)
.text$mn:00006264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006264
.text$mn:00006264 ; =============== S U B R O U T I N E =======================================
.text$mn:00006264
.text$mn:00006264 ; Attributes: bp-based frame
.text$mn:00006264
.text$mn:00006264 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00006264                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00006264 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00006264                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00006264
.text$mn:00006264 var_20          = dword ptr -20h
.text$mn:00006264 var_1C          = dword ptr -1Ch
.text$mn:00006264 var_18          = dword ptr -18h
.text$mn:00006264 var_11          = byte ptr -11h
.text$mn:00006264 var_10          = dword ptr -10h
.text$mn:00006264 var_C           = byte ptr -0Ch
.text$mn:00006264 var_4           = dword ptr -4
.text$mn:00006264 arg_0           = dword ptr  8
.text$mn:00006264
.text$mn:00006264 ; FUNCTION CHUNK AT .text$mn:00006386 SIZE 00000009 BYTES
.text$mn:00006264
.text$mn:00006264                 push    ebp
.text$mn:00006265                 mov     ebp, esp
.text$mn:00006267                 push    0FFFFFFFFh
.text$mn:00006269                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000626E                 mov     eax, large fs:0
.text$mn:00006274                 push    eax
.text$mn:00006275                 push    ecx
.text$mn:00006276                 sub     esp, 10h
.text$mn:00006279                 push    ebx
.text$mn:0000627A                 push    esi
.text$mn:0000627B                 push    edi
.text$mn:0000627C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006281                 xor     eax, ebp
.text$mn:00006283                 push    eax
.text$mn:00006284                 lea     eax, [ebp+var_C]
.text$mn:00006287                 mov     large fs:0, eax
.text$mn:0000628D                 mov     [ebp+var_10], esp
.text$mn:00006290                 mov     [ebp+var_18], ecx
.text$mn:00006293                 mov     eax, [ebp+arg_0]
.text$mn:00006296                 or      eax, 0Fh
.text$mn:00006299                 mov     [ebp+var_1C], eax
.text$mn:0000629C                 mov     ecx, [ebp+var_18]
.text$mn:0000629F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000062A4                 cmp     eax, [ebp+var_1C]
.text$mn:000062A7                 jnb     short loc_62B1
.text$mn:000062A9                 mov     ecx, [ebp+arg_0]
.text$mn:000062AC                 mov     [ebp+var_1C], ecx
.text$mn:000062AF                 jmp     short loc_6303
.text$mn:000062B1 ; ---------------------------------------------------------------------------
.text$mn:000062B1
.text$mn:000062B1 loc_62B1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:000062B1                 mov     edx, [ebp+var_18]
.text$mn:000062B4                 mov     ecx, [edx+18h]
.text$mn:000062B7                 shr     ecx, 1
.text$mn:000062B9                 mov     eax, [ebp+var_1C]
.text$mn:000062BC                 xor     edx, edx
.text$mn:000062BE                 mov     esi, 3
.text$mn:000062C3                 div     esi
.text$mn:000062C5                 cmp     ecx, eax
.text$mn:000062C7                 ja      short loc_62CB
.text$mn:000062C9                 jmp     short loc_6303
.text$mn:000062CB ; ---------------------------------------------------------------------------
.text$mn:000062CB
.text$mn:000062CB loc_62CB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000062CB                 mov     ecx, [ebp+var_18]
.text$mn:000062CE                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000062D3                 mov     edx, [ebp+var_18]
.text$mn:000062D6                 mov     ecx, [edx+18h]
.text$mn:000062D9                 shr     ecx, 1
.text$mn:000062DB                 sub     eax, ecx
.text$mn:000062DD                 mov     edx, [ebp+var_18]
.text$mn:000062E0                 cmp     [edx+18h], eax
.text$mn:000062E3                 ja      short loc_62F8
.text$mn:000062E5                 mov     eax, [ebp+var_18]
.text$mn:000062E8                 mov     ecx, [eax+18h]
.text$mn:000062EB                 shr     ecx, 1
.text$mn:000062ED                 mov     edx, [ebp+var_18]
.text$mn:000062F0                 add     ecx, [edx+18h]
.text$mn:000062F3                 mov     [ebp+var_1C], ecx
.text$mn:000062F6                 jmp     short loc_6303
.text$mn:000062F8 ; ---------------------------------------------------------------------------
.text$mn:000062F8
.text$mn:000062F8 loc_62F8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000062F8                 mov     ecx, [ebp+var_18]
.text$mn:000062FB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00006300                 mov     [ebp+var_1C], eax
.text$mn:00006303
.text$mn:00006303 loc_6303:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00006303                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00006303                 mov     [ebp+var_4], 0
.text$mn:0000630A                 mov     eax, [ebp+var_1C]
.text$mn:0000630D                 add     eax, 1
.text$mn:00006310                 push    eax
.text$mn:00006311                 lea     ecx, [ebp+var_11]
.text$mn:00006314                 push    ecx
.text$mn:00006315                 mov     ecx, [ebp+var_18]
.text$mn:00006318                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000631D                 mov     ecx, eax
.text$mn:0000631F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00006324                 mov     [ebp+var_20], eax
.text$mn:00006327                 jmp     short loc_6386
.text$mn:00006327 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00006327
.text$mn:00006329
.text$mn:00006329 ; =============== S U B R O U T I N E =======================================
.text$mn:00006329
.text$mn:00006329
.text$mn:00006329 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00006329                                         ; DATA XREF: .xdata$x:00008E00o
.text$mn:00006329
.text$mn:00006329 ; FUNCTION CHUNK AT .text$mn:00006370 SIZE 00000009 BYTES
.text$mn:00006329 ; FUNCTION CHUNK AT .text$mn:00006380 SIZE 00000006 BYTES
.text$mn:00006329
.text$mn:00006329                 mov     [ebp-10h], esp
.text$mn:0000632C                 mov     edx, [ebp+8]
.text$mn:0000632F                 mov     [ebp-1Ch], edx
.text$mn:00006332                 mov     byte ptr [ebp-4], 2
.text$mn:00006336                 mov     eax, [ebp-1Ch]
.text$mn:00006339                 add     eax, 1
.text$mn:0000633C                 push    eax
.text$mn:0000633D                 lea     ecx, [ebp-12h]
.text$mn:00006340                 push    ecx
.text$mn:00006341                 mov     ecx, [ebp-18h]
.text$mn:00006344                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00006349                 mov     ecx, eax
.text$mn:0000634B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00006350                 mov     [ebp-20h], eax
.text$mn:00006353                 jmp     short loc_6370
.text$mn:00006353 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00006353
.text$mn:00006355
.text$mn:00006355 ; =============== S U B R O U T I N E =======================================
.text$mn:00006355
.text$mn:00006355 ; Attributes: noreturn
.text$mn:00006355
.text$mn:00006355 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00006355                                         ; DATA XREF: .xdata$x:00008E10o
.text$mn:00006355                 push    0               ; Size
.text$mn:00006357                 push    1               ; char
.text$mn:00006359                 mov     ecx, [ebp-18h]
.text$mn:0000635C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006361                 push    0
.text$mn:00006363                 push    0
.text$mn:00006365                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006365 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00006365
.text$mn:0000636A ; ---------------------------------------------------------------------------
.text$mn:0000636A                 mov     eax, offset $LN17
.text$mn:0000636F                 retn
.text$mn:00006370 ; ---------------------------------------------------------------------------
.text$mn:00006370 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006370
.text$mn:00006370 loc_6370:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00006370                 mov     dword ptr [ebp-4], 1
.text$mn:00006377                 jmp     short loc_6380
.text$mn:00006377 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006379
.text$mn:00006379 ; =============== S U B R O U T I N E =======================================
.text$mn:00006379
.text$mn:00006379
.text$mn:00006379 $LN17           proc near               ; DATA XREF: .text$mn:0000636Ao
.text$mn:00006379                 mov     dword ptr [ebp-4], 1
.text$mn:00006379 $LN17           endp ; sp-analysis failed
.text$mn:00006379
.text$mn:00006380 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006380
.text$mn:00006380 loc_6380:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00006380                 mov     eax, offset $LN19
.text$mn:00006385                 retn
.text$mn:00006385 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006386 ; ---------------------------------------------------------------------------
.text$mn:00006386 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00006386
.text$mn:00006386 loc_6386:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00006386                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000638D                 jmp     short loc_6396
.text$mn:0000638D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000638F
.text$mn:0000638F ; =============== S U B R O U T I N E =======================================
.text$mn:0000638F
.text$mn:0000638F
.text$mn:0000638F $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_6380o
.text$mn:0000638F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00006396
.text$mn:00006396 loc_6396:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00006396                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000639A                 jbe     short loc_63B5
.text$mn:0000639C                 mov     edx, [ebp+0Ch]
.text$mn:0000639F                 push    edx             ; Size
.text$mn:000063A0                 mov     ecx, [ebp-18h]
.text$mn:000063A3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000063A8                 push    eax             ; Src
.text$mn:000063A9                 mov     eax, [ebp-20h]
.text$mn:000063AC                 push    eax             ; Dst
.text$mn:000063AD                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000063B2                 add     esp, 0Ch
.text$mn:000063B5
.text$mn:000063B5 loc_63B5:                               ; CODE XREF: $LN19+Bj
.text$mn:000063B5                 push    0               ; Size
.text$mn:000063B7                 push    1               ; char
.text$mn:000063B9                 mov     ecx, [ebp-18h]
.text$mn:000063BC                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000063C1                 lea     ecx, [ebp-20h]
.text$mn:000063C4                 push    ecx             ; int
.text$mn:000063C5                 mov     edx, [ebp-18h]
.text$mn:000063C8                 add     edx, 4
.text$mn:000063CB                 push    edx             ; void *
.text$mn:000063CC                 lea     eax, [ebp-13h]
.text$mn:000063CF                 push    eax
.text$mn:000063D0                 mov     ecx, [ebp-18h]
.text$mn:000063D3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000063D8                 mov     ecx, eax
.text$mn:000063DA                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000063DF                 mov     ecx, [ebp-18h]
.text$mn:000063E2                 mov     edx, [ebp-1Ch]
.text$mn:000063E5                 mov     [ecx+18h], edx
.text$mn:000063E8                 mov     eax, [ebp+0Ch]
.text$mn:000063EB                 push    eax
.text$mn:000063EC                 mov     ecx, [ebp-18h]
.text$mn:000063EF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000063F4                 mov     ecx, [ebp-0Ch]
.text$mn:000063F7                 mov     large fs:0, ecx
.text$mn:000063FE                 pop     ecx
.text$mn:000063FF                 pop     edi
.text$mn:00006400                 pop     esi
.text$mn:00006401                 pop     ebx
.text$mn:00006402                 mov     esp, ebp
.text$mn:00006404                 pop     ebp
.text$mn:00006405                 retn    8
.text$mn:00006405 $LN19           endp ; sp-analysis failed
.text$mn:00006405
.text$mn:00006405 _text$mn        ends
.text$mn:00006405
.text$x:00006408 ; ===========================================================================
.text$x:00006408
.text$x:00006408 ; Segment type: Pure code
.text$x:00006408 ; Segment permissions: Read/Execute
.text$x:00006408 _text$x         segment para public 'CODE' use32
.text$x:00006408                 assume cs:_text$x
.text$x:00006408                 ;org 6408h
.text$x:00006408 ; COMDAT (pick associative to section at 6264)
.text$x:00006408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006408
.text$x:00006408 ; =============== S U B R O U T I N E =======================================
.text$x:00006408
.text$x:00006408
.text$x:00006408 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00006408                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00006408
.text$x:00006408 arg_4           = dword ptr  8
.text$x:00006408
.text$x:00006408                 mov     edx, [esp+arg_4]
.text$x:0000640C                 lea     eax, [edx+0Ch]
.text$x:0000640F                 mov     ecx, [edx-24h]
.text$x:00006412                 xor     ecx, eax
.text$x:00006414                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006419                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:0000641E                 jmp     ___CxxFrameHandler3
.text$x:0000641E __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:0000641E
.text$x:0000641E ; ---------------------------------------------------------------------------
.text$x:00006423                 align 4
.text$x:00006423 _text$x         ends
.text$x:00006423
.text$mn:00006424 ; ===========================================================================
.text$mn:00006424
.text$mn:00006424 ; Segment type: Pure code
.text$mn:00006424 ; Segment permissions: Read/Execute
.text$mn:00006424 _text$mn        segment para public 'CODE' use32
.text$mn:00006424                 assume cs:_text$mn
.text$mn:00006424                 ;org 6424h
.text$mn:00006424 ; COMDAT (pick any)
.text$mn:00006424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006424
.text$mn:00006424 ; =============== S U B R O U T I N E =======================================
.text$mn:00006424
.text$mn:00006424 ; Attributes: bp-based frame
.text$mn:00006424
.text$mn:00006424 ; protected: void __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::_Destroy(struct HWND__ * *, struct HWND__ * *)
.text$mn:00006424                 public ?_Destroy@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXPAPAUHWND__@@0@Z
.text$mn:00006424 ?_Destroy@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXPAPAUHWND__@@0@Z proc near
.text$mn:00006424                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reallocate(uint)+CBp
.text$mn:00006424                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Tidy(void)+2Bp
.text$mn:00006424
.text$mn:00006424 var_8           = dword ptr -8
.text$mn:00006424 var_1           = byte ptr -1
.text$mn:00006424 arg_0           = dword ptr  8
.text$mn:00006424 arg_4           = dword ptr  0Ch
.text$mn:00006424
.text$mn:00006424                 push    ebp
.text$mn:00006425                 mov     ebp, esp
.text$mn:00006427                 sub     esp, 8
.text$mn:0000642A                 mov     [ebp+var_8], ecx
.text$mn:0000642D                 lea     eax, [ebp+var_1]
.text$mn:00006430                 push    eax
.text$mn:00006431                 mov     ecx, [ebp+var_8]
.text$mn:00006434                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Getal(void)
.text$mn:00006439                 lea     ecx, [ebp+var_1]
.text$mn:0000643C                 push    ecx
.text$mn:0000643D                 mov     edx, [ebp+arg_4]
.text$mn:00006440                 push    edx
.text$mn:00006441                 mov     eax, [ebp+arg_0]
.text$mn:00006444                 push    eax
.text$mn:00006445                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@@std@@YAXPAPAUHWND__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HWND__ *>>>(HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &)
.text$mn:0000644A                 add     esp, 0Ch
.text$mn:0000644D                 mov     esp, ebp
.text$mn:0000644F                 pop     ebp
.text$mn:00006450                 retn    8
.text$mn:00006450 ?_Destroy@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXPAPAUHWND__@@0@Z endp
.text$mn:00006450
.text$mn:00006450 ; ---------------------------------------------------------------------------
.text$mn:00006453                 align 4
.text$mn:00006453 _text$mn        ends
.text$mn:00006453
.text$mn:00006454 ; ===========================================================================
.text$mn:00006454
.text$mn:00006454 ; Segment type: Pure code
.text$mn:00006454 ; Segment permissions: Read/Execute
.text$mn:00006454 _text$mn        segment para public 'CODE' use32
.text$mn:00006454                 assume cs:_text$mn
.text$mn:00006454                 ;org 6454h
.text$mn:00006454 ; COMDAT (pick any)
.text$mn:00006454                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006454
.text$mn:00006454 ; =============== S U B R O U T I N E =======================================
.text$mn:00006454
.text$mn:00006454 ; Attributes: bp-based frame
.text$mn:00006454
.text$mn:00006454 ; protected: void __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::_Destroy(struct tTbData * *, struct tTbData * *)
.text$mn:00006454                 public ?_Destroy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEXPAPAUtTbData@@0@Z
.text$mn:00006454 ?_Destroy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEXPAPAUtTbData@@0@Z proc near
.text$mn:00006454                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Tidy(void)+2Bp
.text$mn:00006454
.text$mn:00006454 var_8           = dword ptr -8
.text$mn:00006454 var_1           = byte ptr -1
.text$mn:00006454 arg_0           = dword ptr  8
.text$mn:00006454 arg_4           = dword ptr  0Ch
.text$mn:00006454
.text$mn:00006454                 push    ebp
.text$mn:00006455                 mov     ebp, esp
.text$mn:00006457                 sub     esp, 8
.text$mn:0000645A                 mov     [ebp+var_8], ecx
.text$mn:0000645D                 lea     eax, [ebp+var_1]
.text$mn:00006460                 push    eax
.text$mn:00006461                 mov     ecx, [ebp+var_8]
.text$mn:00006464                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Getal(void)
.text$mn:00006469                 lea     ecx, [ebp+var_1]
.text$mn:0000646C                 push    ecx
.text$mn:0000646D                 mov     edx, [ebp+arg_4]
.text$mn:00006470                 push    edx
.text$mn:00006471                 mov     eax, [ebp+arg_0]
.text$mn:00006474                 push    eax
.text$mn:00006475                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@@std@@YAXPAPAUtTbData@@0AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<tTbData *>>>(tTbData * *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &)
.text$mn:0000647A                 add     esp, 0Ch
.text$mn:0000647D                 mov     esp, ebp
.text$mn:0000647F                 pop     ebp
.text$mn:00006480                 retn    8
.text$mn:00006480 ?_Destroy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEXPAPAUtTbData@@0@Z endp
.text$mn:00006480
.text$mn:00006480 ; ---------------------------------------------------------------------------
.text$mn:00006483                 align 4
.text$mn:00006483 _text$mn        ends
.text$mn:00006483
.text$mn:00006484 ; ===========================================================================
.text$mn:00006484
.text$mn:00006484 ; Segment type: Pure code
.text$mn:00006484 ; Segment permissions: Read/Execute
.text$mn:00006484 _text$mn        segment para public 'CODE' use32
.text$mn:00006484                 assume cs:_text$mn
.text$mn:00006484                 ;org 6484h
.text$mn:00006484 ; COMDAT (pick any)
.text$mn:00006484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006484
.text$mn:00006484 ; =============== S U B R O U T I N E =======================================
.text$mn:00006484
.text$mn:00006484 ; Attributes: bp-based frame
.text$mn:00006484
.text$mn:00006484 ; protected: void __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Destroy(class DockingCont * *, class DockingCont * *)
.text$mn:00006484                 public ?_Destroy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXPAPAVDockingCont@@0@Z
.text$mn:00006484 ?_Destroy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXPAPAVDockingCont@@0@Z proc near
.text$mn:00006484                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reallocate(uint)+CBp
.text$mn:00006484                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Tidy(void)+2Bp
.text$mn:00006484
.text$mn:00006484 var_8           = dword ptr -8
.text$mn:00006484 var_1           = byte ptr -1
.text$mn:00006484 arg_0           = dword ptr  8
.text$mn:00006484 arg_4           = dword ptr  0Ch
.text$mn:00006484
.text$mn:00006484                 push    ebp
.text$mn:00006485                 mov     ebp, esp
.text$mn:00006487                 sub     esp, 8
.text$mn:0000648A                 mov     [ebp+var_8], ecx
.text$mn:0000648D                 lea     eax, [ebp+var_1]
.text$mn:00006490                 push    eax
.text$mn:00006491                 mov     ecx, [ebp+var_8]
.text$mn:00006494                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:00006499                 lea     ecx, [ebp+var_1]
.text$mn:0000649C                 push    ecx
.text$mn:0000649D                 mov     edx, [ebp+arg_4]
.text$mn:000064A0                 push    edx
.text$mn:000064A1                 mov     eax, [ebp+arg_0]
.text$mn:000064A4                 push    eax
.text$mn:000064A5                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)
.text$mn:000064AA                 add     esp, 0Ch
.text$mn:000064AD                 mov     esp, ebp
.text$mn:000064AF                 pop     ebp
.text$mn:000064B0                 retn    8
.text$mn:000064B0 ?_Destroy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXPAPAVDockingCont@@0@Z endp
.text$mn:000064B0
.text$mn:000064B0 ; ---------------------------------------------------------------------------
.text$mn:000064B3                 align 4
.text$mn:000064B3 _text$mn        ends
.text$mn:000064B3
.text$mn:000064B4 ; ===========================================================================
.text$mn:000064B4
.text$mn:000064B4 ; Segment type: Pure code
.text$mn:000064B4 ; Segment permissions: Read/Execute
.text$mn:000064B4 _text$mn        segment para public 'CODE' use32
.text$mn:000064B4                 assume cs:_text$mn
.text$mn:000064B4                 ;org 64B4h
.text$mn:000064B4 ; COMDAT (pick any)
.text$mn:000064B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000064B4
.text$mn:000064B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000064B4
.text$mn:000064B4 ; Attributes: bp-based frame
.text$mn:000064B4
.text$mn:000064B4 ; protected: void __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::_Destroy(class DockingSplitter * *, class DockingSplitter * *)
.text$mn:000064B4                 public ?_Destroy@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXPAPAVDockingSplitter@@0@Z
.text$mn:000064B4 ?_Destroy@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXPAPAVDockingSplitter@@0@Z proc near
.text$mn:000064B4                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reallocate(uint)+CBp
.text$mn:000064B4                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Tidy(void)+2Bp
.text$mn:000064B4
.text$mn:000064B4 var_8           = dword ptr -8
.text$mn:000064B4 var_1           = byte ptr -1
.text$mn:000064B4 arg_0           = dword ptr  8
.text$mn:000064B4 arg_4           = dword ptr  0Ch
.text$mn:000064B4
.text$mn:000064B4                 push    ebp
.text$mn:000064B5                 mov     ebp, esp
.text$mn:000064B7                 sub     esp, 8
.text$mn:000064BA                 mov     [ebp+var_8], ecx
.text$mn:000064BD                 lea     eax, [ebp+var_1]
.text$mn:000064C0                 push    eax
.text$mn:000064C1                 mov     ecx, [ebp+var_8]
.text$mn:000064C4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Getal(void)
.text$mn:000064C9                 lea     ecx, [ebp+var_1]
.text$mn:000064CC                 push    ecx
.text$mn:000064CD                 mov     edx, [ebp+arg_4]
.text$mn:000064D0                 push    edx
.text$mn:000064D1                 mov     eax, [ebp+arg_0]
.text$mn:000064D4                 push    eax
.text$mn:000064D5                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@YAXPAPAVDockingSplitter@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingSplitter *>>>(DockingSplitter * *,DockingSplitter * *,std::_Wrap_alloc<std::allocator<DockingSplitter *>> &)
.text$mn:000064DA                 add     esp, 0Ch
.text$mn:000064DD                 mov     esp, ebp
.text$mn:000064DF                 pop     ebp
.text$mn:000064E0                 retn    8
.text$mn:000064E0 ?_Destroy@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXPAPAVDockingSplitter@@0@Z endp
.text$mn:000064E0
.text$mn:000064E0 ; ---------------------------------------------------------------------------
.text$mn:000064E3                 align 4
.text$mn:000064E3 _text$mn        ends
.text$mn:000064E3
.text$mn:000064E4 ; ===========================================================================
.text$mn:000064E4
.text$mn:000064E4 ; Segment type: Pure code
.text$mn:000064E4 ; Segment permissions: Read/Execute
.text$mn:000064E4 _text$mn        segment para public 'CODE' use32
.text$mn:000064E4                 assume cs:_text$mn
.text$mn:000064E4                 ;org 64E4h
.text$mn:000064E4 ; COMDAT (pick any)
.text$mn:000064E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000064E4
.text$mn:000064E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000064E4
.text$mn:000064E4 ; Attributes: bp-based frame
.text$mn:000064E4
.text$mn:000064E4 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:000064E4                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:000064E4 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:000064E4                                         ; CODE XREF: $LN19+60p
.text$mn:000064E4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:000064E4
.text$mn:000064E4 var_8           = dword ptr -8
.text$mn:000064E4 var_1           = byte ptr -1
.text$mn:000064E4 arg_0           = dword ptr  8
.text$mn:000064E4
.text$mn:000064E4                 push    ebp
.text$mn:000064E5                 mov     ebp, esp
.text$mn:000064E7                 sub     esp, 8
.text$mn:000064EA                 mov     [ebp+var_8], ecx
.text$mn:000064ED                 mov     [ebp+var_1], 0
.text$mn:000064F1                 mov     eax, [ebp+var_8]
.text$mn:000064F4                 mov     ecx, [ebp+arg_0]
.text$mn:000064F7                 mov     [eax+14h], ecx
.text$mn:000064FA                 lea     edx, [ebp+var_1]
.text$mn:000064FD                 push    edx
.text$mn:000064FE                 mov     ecx, [ebp+var_8]
.text$mn:00006501                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006506                 add     eax, [ebp+arg_0]
.text$mn:00006509                 push    eax
.text$mn:0000650A                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000650F                 add     esp, 8
.text$mn:00006512                 mov     esp, ebp
.text$mn:00006514                 pop     ebp
.text$mn:00006515                 retn    4
.text$mn:00006515 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00006515
.text$mn:00006515 _text$mn        ends
.text$mn:00006515
.text$mn:00006518 ; ===========================================================================
.text$mn:00006518
.text$mn:00006518 ; Segment type: Pure code
.text$mn:00006518 ; Segment permissions: Read/Execute
.text$mn:00006518 _text$mn        segment para public 'CODE' use32
.text$mn:00006518                 assume cs:_text$mn
.text$mn:00006518                 ;org 6518h
.text$mn:00006518 ; COMDAT (pick any)
.text$mn:00006518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006518
.text$mn:00006518 ; =============== S U B R O U T I N E =======================================
.text$mn:00006518
.text$mn:00006518 ; Attributes: bp-based frame
.text$mn:00006518
.text$mn:00006518 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00006518                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00006518 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006518                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00006518
.text$mn:00006518 var_8           = dword ptr -8
.text$mn:00006518 var_1           = byte ptr -1
.text$mn:00006518
.text$mn:00006518                 push    ebp
.text$mn:00006519                 mov     ebp, esp
.text$mn:0000651B                 sub     esp, 8
.text$mn:0000651E                 mov     [ebp+var_8], ecx
.text$mn:00006521                 lea     ecx, [ebp+var_1]
.text$mn:00006524                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00006529                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000652C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006531                 mov     eax, [ebp+var_8]
.text$mn:00006534                 mov     ecx, [eax]
.text$mn:00006536                 push    ecx
.text$mn:00006537                 lea     ecx, [ebp+var_1]
.text$mn:0000653A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000653F                 push    1               ; int
.text$mn:00006541                 mov     edx, [ebp+var_8]
.text$mn:00006544                 mov     eax, [edx]
.text$mn:00006546                 push    eax             ; void *
.text$mn:00006547                 lea     ecx, [ebp+var_1]
.text$mn:0000654A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000654F                 mov     ecx, [ebp+var_8]
.text$mn:00006552                 mov     dword ptr [ecx], 0
.text$mn:00006558                 mov     esp, ebp
.text$mn:0000655A                 pop     ebp
.text$mn:0000655B                 retn
.text$mn:0000655B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000655B
.text$mn:0000655B _text$mn        ends
.text$mn:0000655B
.text$mn:0000655C ; ===========================================================================
.text$mn:0000655C
.text$mn:0000655C ; Segment type: Pure code
.text$mn:0000655C ; Segment permissions: Read/Execute
.text$mn:0000655C _text$mn        segment para public 'CODE' use32
.text$mn:0000655C                 assume cs:_text$mn
.text$mn:0000655C                 ;org 655Ch
.text$mn:0000655C ; COMDAT (pick any)
.text$mn:0000655C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000655C
.text$mn:0000655C ; =============== S U B R O U T I N E =======================================
.text$mn:0000655C
.text$mn:0000655C ; Attributes: bp-based frame
.text$mn:0000655C
.text$mn:0000655C ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct HWND__ *, class std::allocator<struct HWND__ *>>>::_Free_proxy(void)
.text$mn:0000655C                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAEXXZ
.text$mn:0000655C ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000655C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::~_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>(void)+30p
.text$mn:0000655C
.text$mn:0000655C var_8           = dword ptr -8
.text$mn:0000655C var_1           = byte ptr -1
.text$mn:0000655C
.text$mn:0000655C                 push    ebp
.text$mn:0000655D                 mov     ebp, esp
.text$mn:0000655F                 sub     esp, 8
.text$mn:00006562                 mov     [ebp+var_8], ecx
.text$mn:00006565                 lea     ecx, [ebp+var_1]
.text$mn:00006568                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:0000656D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006570                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006575                 mov     eax, [ebp+var_8]
.text$mn:00006578                 mov     ecx, [eax]
.text$mn:0000657A                 push    ecx
.text$mn:0000657B                 lea     ecx, [ebp+var_1]
.text$mn:0000657E                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00006583                 push    1               ; int
.text$mn:00006585                 mov     edx, [ebp+var_8]
.text$mn:00006588                 mov     eax, [edx]
.text$mn:0000658A                 push    eax             ; void *
.text$mn:0000658B                 lea     ecx, [ebp+var_1]
.text$mn:0000658E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00006593                 mov     ecx, [ebp+var_8]
.text$mn:00006596                 mov     dword ptr [ecx], 0
.text$mn:0000659C                 mov     esp, ebp
.text$mn:0000659E                 pop     ebp
.text$mn:0000659F                 retn
.text$mn:0000659F ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000659F
.text$mn:0000659F _text$mn        ends
.text$mn:0000659F
.text$mn:000065A0 ; ===========================================================================
.text$mn:000065A0
.text$mn:000065A0 ; Segment type: Pure code
.text$mn:000065A0 ; Segment permissions: Read/Execute
.text$mn:000065A0 _text$mn        segment para public 'CODE' use32
.text$mn:000065A0                 assume cs:_text$mn
.text$mn:000065A0                 ;org 65A0h
.text$mn:000065A0 ; COMDAT (pick any)
.text$mn:000065A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065A0
.text$mn:000065A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000065A0
.text$mn:000065A0 ; Attributes: bp-based frame
.text$mn:000065A0
.text$mn:000065A0 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct tTbData *, class std::allocator<struct tTbData *>>>::_Free_proxy(void)
.text$mn:000065A0                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAEXXZ
.text$mn:000065A0 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000065A0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::~_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>(void)+30p
.text$mn:000065A0
.text$mn:000065A0 var_8           = dword ptr -8
.text$mn:000065A0 var_1           = byte ptr -1
.text$mn:000065A0
.text$mn:000065A0                 push    ebp
.text$mn:000065A1                 mov     ebp, esp
.text$mn:000065A3                 sub     esp, 8
.text$mn:000065A6                 mov     [ebp+var_8], ecx
.text$mn:000065A9                 lea     ecx, [ebp+var_1]
.text$mn:000065AC                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000065B1                 mov     ecx, [ebp+var_8] ; this
.text$mn:000065B4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000065B9                 mov     eax, [ebp+var_8]
.text$mn:000065BC                 mov     ecx, [eax]
.text$mn:000065BE                 push    ecx
.text$mn:000065BF                 lea     ecx, [ebp+var_1]
.text$mn:000065C2                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000065C7                 push    1               ; int
.text$mn:000065C9                 mov     edx, [ebp+var_8]
.text$mn:000065CC                 mov     eax, [edx]
.text$mn:000065CE                 push    eax             ; void *
.text$mn:000065CF                 lea     ecx, [ebp+var_1]
.text$mn:000065D2                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:000065D7                 mov     ecx, [ebp+var_8]
.text$mn:000065DA                 mov     dword ptr [ecx], 0
.text$mn:000065E0                 mov     esp, ebp
.text$mn:000065E2                 pop     ebp
.text$mn:000065E3                 retn
.text$mn:000065E3 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:000065E3
.text$mn:000065E3 _text$mn        ends
.text$mn:000065E3
.text$mn:000065E4 ; ===========================================================================
.text$mn:000065E4
.text$mn:000065E4 ; Segment type: Pure code
.text$mn:000065E4 ; Segment permissions: Read/Execute
.text$mn:000065E4 _text$mn        segment para public 'CODE' use32
.text$mn:000065E4                 assume cs:_text$mn
.text$mn:000065E4                 ;org 65E4h
.text$mn:000065E4 ; COMDAT (pick any)
.text$mn:000065E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065E4
.text$mn:000065E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000065E4
.text$mn:000065E4 ; Attributes: bp-based frame
.text$mn:000065E4
.text$mn:000065E4 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>::_Free_proxy(void)
.text$mn:000065E4                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ
.text$mn:000065E4 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000065E4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)+30p
.text$mn:000065E4
.text$mn:000065E4 var_8           = dword ptr -8
.text$mn:000065E4 var_1           = byte ptr -1
.text$mn:000065E4
.text$mn:000065E4                 push    ebp
.text$mn:000065E5                 mov     ebp, esp
.text$mn:000065E7                 sub     esp, 8
.text$mn:000065EA                 mov     [ebp+var_8], ecx
.text$mn:000065ED                 lea     ecx, [ebp+var_1]
.text$mn:000065F0                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000065F5                 mov     ecx, [ebp+var_8] ; this
.text$mn:000065F8                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000065FD                 mov     eax, [ebp+var_8]
.text$mn:00006600                 mov     ecx, [eax]
.text$mn:00006602                 push    ecx
.text$mn:00006603                 lea     ecx, [ebp+var_1]
.text$mn:00006606                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000660B                 push    1               ; int
.text$mn:0000660D                 mov     edx, [ebp+var_8]
.text$mn:00006610                 mov     eax, [edx]
.text$mn:00006612                 push    eax             ; void *
.text$mn:00006613                 lea     ecx, [ebp+var_1]
.text$mn:00006616                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000661B                 mov     ecx, [ebp+var_8]
.text$mn:0000661E                 mov     dword ptr [ecx], 0
.text$mn:00006624                 mov     esp, ebp
.text$mn:00006626                 pop     ebp
.text$mn:00006627                 retn
.text$mn:00006627 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00006627
.text$mn:00006627 _text$mn        ends
.text$mn:00006627
.text$mn:00006628 ; ===========================================================================
.text$mn:00006628
.text$mn:00006628 ; Segment type: Pure code
.text$mn:00006628 ; Segment permissions: Read/Execute
.text$mn:00006628 _text$mn        segment para public 'CODE' use32
.text$mn:00006628                 assume cs:_text$mn
.text$mn:00006628                 ;org 6628h
.text$mn:00006628 ; COMDAT (pick any)
.text$mn:00006628                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006628
.text$mn:00006628 ; =============== S U B R O U T I N E =======================================
.text$mn:00006628
.text$mn:00006628 ; Attributes: bp-based frame
.text$mn:00006628
.text$mn:00006628 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingSplitter *, class std::allocator<class DockingSplitter *>>>::_Free_proxy(void)
.text$mn:00006628                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAEXXZ
.text$mn:00006628 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006628                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>(void)+30p
.text$mn:00006628
.text$mn:00006628 var_8           = dword ptr -8
.text$mn:00006628 var_1           = byte ptr -1
.text$mn:00006628
.text$mn:00006628                 push    ebp
.text$mn:00006629                 mov     ebp, esp
.text$mn:0000662B                 sub     esp, 8
.text$mn:0000662E                 mov     [ebp+var_8], ecx
.text$mn:00006631                 lea     ecx, [ebp+var_1]
.text$mn:00006634                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00006639                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000663C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006641                 mov     eax, [ebp+var_8]
.text$mn:00006644                 mov     ecx, [eax]
.text$mn:00006646                 push    ecx
.text$mn:00006647                 lea     ecx, [ebp+var_1]
.text$mn:0000664A                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000664F                 push    1               ; int
.text$mn:00006651                 mov     edx, [ebp+var_8]
.text$mn:00006654                 mov     eax, [edx]
.text$mn:00006656                 push    eax             ; void *
.text$mn:00006657                 lea     ecx, [ebp+var_1]
.text$mn:0000665A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000665F                 mov     ecx, [ebp+var_8]
.text$mn:00006662                 mov     dword ptr [ecx], 0
.text$mn:00006668                 mov     esp, ebp
.text$mn:0000666A                 pop     ebp
.text$mn:0000666B                 retn
.text$mn:0000666B ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000666B
.text$mn:0000666B _text$mn        ends
.text$mn:0000666B
.text$mn:0000666C ; ===========================================================================
.text$mn:0000666C
.text$mn:0000666C ; Segment type: Pure code
.text$mn:0000666C ; Segment permissions: Read/Execute
.text$mn:0000666C _text$mn        segment para public 'CODE' use32
.text$mn:0000666C                 assume cs:_text$mn
.text$mn:0000666C                 ;org 666Ch
.text$mn:0000666C ; COMDAT (pick any)
.text$mn:0000666C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000666C
.text$mn:0000666C ; =============== S U B R O U T I N E =======================================
.text$mn:0000666C
.text$mn:0000666C ; Attributes: bp-based frame
.text$mn:0000666C
.text$mn:0000666C ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:0000666C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:0000666C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:0000666C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:0000666C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:0000666C
.text$mn:0000666C var_4           = dword ptr -4
.text$mn:0000666C arg_0           = dword ptr  8
.text$mn:0000666C
.text$mn:0000666C                 push    ebp
.text$mn:0000666D                 mov     ebp, esp
.text$mn:0000666F                 push    ecx
.text$mn:00006670                 mov     [ebp+var_4], ecx
.text$mn:00006673                 mov     ecx, [ebp+arg_0]
.text$mn:00006676                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:0000667B                 mov     eax, [ebp+arg_0]
.text$mn:0000667E                 mov     esp, ebp
.text$mn:00006680                 pop     ebp
.text$mn:00006681                 retn    4
.text$mn:00006681 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00006681
.text$mn:00006681 _text$mn        ends
.text$mn:00006681
.text$mn:00006684 ; ===========================================================================
.text$mn:00006684
.text$mn:00006684 ; Segment type: Pure code
.text$mn:00006684 ; Segment permissions: Read/Execute
.text$mn:00006684 _text$mn        segment para public 'CODE' use32
.text$mn:00006684                 assume cs:_text$mn
.text$mn:00006684                 ;org 6684h
.text$mn:00006684 ; COMDAT (pick any)
.text$mn:00006684                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006684
.text$mn:00006684 ; =============== S U B R O U T I N E =======================================
.text$mn:00006684
.text$mn:00006684 ; Attributes: bp-based frame
.text$mn:00006684
.text$mn:00006684 ; public: struct std::_Wrap_alloc<class std::allocator<struct HWND__ *>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct HWND__ *, class std::allocator<struct HWND__ *>>>::_Getal(void)const
.text$mn:00006684                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ
.text$mn:00006684 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ proc near
.text$mn:00006684                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Umove<HWND__ * *>(HWND__ * *,HWND__ * *,HWND__ * *)+10p
.text$mn:00006684                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Destroy(HWND__ * *,HWND__ * *)+10p ...
.text$mn:00006684
.text$mn:00006684 var_4           = dword ptr -4
.text$mn:00006684 arg_0           = dword ptr  8
.text$mn:00006684
.text$mn:00006684                 push    ebp
.text$mn:00006685                 mov     ebp, esp
.text$mn:00006687                 push    ecx
.text$mn:00006688                 mov     [ebp+var_4], ecx
.text$mn:0000668B                 mov     ecx, [ebp+arg_0]
.text$mn:0000668E                 call    ??0?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<HWND__ *>>::_Wrap_alloc<std::allocator<HWND__ *>>(void)
.text$mn:00006693                 mov     eax, [ebp+arg_0]
.text$mn:00006696                 mov     esp, ebp
.text$mn:00006698                 pop     ebp
.text$mn:00006699                 retn    4
.text$mn:00006699 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ endp
.text$mn:00006699
.text$mn:00006699 _text$mn        ends
.text$mn:00006699
.text$mn:0000669C ; ===========================================================================
.text$mn:0000669C
.text$mn:0000669C ; Segment type: Pure code
.text$mn:0000669C ; Segment permissions: Read/Execute
.text$mn:0000669C _text$mn        segment para public 'CODE' use32
.text$mn:0000669C                 assume cs:_text$mn
.text$mn:0000669C                 ;org 669Ch
.text$mn:0000669C ; COMDAT (pick any)
.text$mn:0000669C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000669C
.text$mn:0000669C ; =============== S U B R O U T I N E =======================================
.text$mn:0000669C
.text$mn:0000669C ; Attributes: bp-based frame
.text$mn:0000669C
.text$mn:0000669C ; public: struct std::_Wrap_alloc<class std::allocator<struct tTbData *>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct tTbData *, class std::allocator<struct tTbData *>>>::_Getal(void)const
.text$mn:0000669C                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@XZ
.text$mn:0000669C ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@XZ proc near
.text$mn:0000669C                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>,tTbData * *)+36p
.text$mn:0000669C                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+3Ap ...
.text$mn:0000669C
.text$mn:0000669C var_4           = dword ptr -4
.text$mn:0000669C arg_0           = dword ptr  8
.text$mn:0000669C
.text$mn:0000669C                 push    ebp
.text$mn:0000669D                 mov     ebp, esp
.text$mn:0000669F                 push    ecx
.text$mn:000066A0                 mov     [ebp+var_4], ecx
.text$mn:000066A3                 mov     ecx, [ebp+arg_0]
.text$mn:000066A6                 call    ??0?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<tTbData *>>::_Wrap_alloc<std::allocator<tTbData *>>(void)
.text$mn:000066AB                 mov     eax, [ebp+arg_0]
.text$mn:000066AE                 mov     esp, ebp
.text$mn:000066B0                 pop     ebp
.text$mn:000066B1                 retn    4
.text$mn:000066B1 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@XZ endp
.text$mn:000066B1
.text$mn:000066B1 _text$mn        ends
.text$mn:000066B1
.text$mn:000066B4 ; ===========================================================================
.text$mn:000066B4
.text$mn:000066B4 ; Segment type: Pure code
.text$mn:000066B4 ; Segment permissions: Read/Execute
.text$mn:000066B4 _text$mn        segment para public 'CODE' use32
.text$mn:000066B4                 assume cs:_text$mn
.text$mn:000066B4                 ;org 66B4h
.text$mn:000066B4 ; COMDAT (pick any)
.text$mn:000066B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066B4
.text$mn:000066B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000066B4
.text$mn:000066B4 ; Attributes: bp-based frame
.text$mn:000066B4
.text$mn:000066B4 ; public: struct std::_Wrap_alloc<class std::allocator<class DockingCont *>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>::_Getal(void)const
.text$mn:000066B4                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ
.text$mn:000066B4 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ proc near
.text$mn:000066B4                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Umove<DockingCont * *>(DockingCont * *,DockingCont * *,DockingCont * *)+10p
.text$mn:000066B4                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Destroy(DockingCont * *,DockingCont * *)+10p ...
.text$mn:000066B4
.text$mn:000066B4 var_4           = dword ptr -4
.text$mn:000066B4 arg_0           = dword ptr  8
.text$mn:000066B4
.text$mn:000066B4                 push    ebp
.text$mn:000066B5                 mov     ebp, esp
.text$mn:000066B7                 push    ecx
.text$mn:000066B8                 mov     [ebp+var_4], ecx
.text$mn:000066BB                 mov     ecx, [ebp+arg_0]
.text$mn:000066BE                 call    ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<DockingCont *>>::_Wrap_alloc<std::allocator<DockingCont *>>(void)
.text$mn:000066C3                 mov     eax, [ebp+arg_0]
.text$mn:000066C6                 mov     esp, ebp
.text$mn:000066C8                 pop     ebp
.text$mn:000066C9                 retn    4
.text$mn:000066C9 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ endp
.text$mn:000066C9
.text$mn:000066C9 _text$mn        ends
.text$mn:000066C9
.text$mn:000066CC ; ===========================================================================
.text$mn:000066CC
.text$mn:000066CC ; Segment type: Pure code
.text$mn:000066CC ; Segment permissions: Read/Execute
.text$mn:000066CC _text$mn        segment para public 'CODE' use32
.text$mn:000066CC                 assume cs:_text$mn
.text$mn:000066CC                 ;org 66CCh
.text$mn:000066CC ; COMDAT (pick any)
.text$mn:000066CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066CC
.text$mn:000066CC ; =============== S U B R O U T I N E =======================================
.text$mn:000066CC
.text$mn:000066CC ; Attributes: bp-based frame
.text$mn:000066CC
.text$mn:000066CC ; public: struct std::_Wrap_alloc<class std::allocator<class DockingSplitter *>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingSplitter *, class std::allocator<class DockingSplitter *>>>::_Getal(void)const
.text$mn:000066CC                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ
.text$mn:000066CC ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ proc near
.text$mn:000066CC                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Umove<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *)+10p
.text$mn:000066CC                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Destroy(DockingSplitter * *,DockingSplitter * *)+10p ...
.text$mn:000066CC
.text$mn:000066CC var_4           = dword ptr -4
.text$mn:000066CC arg_0           = dword ptr  8
.text$mn:000066CC
.text$mn:000066CC                 push    ebp
.text$mn:000066CD                 mov     ebp, esp
.text$mn:000066CF                 push    ecx
.text$mn:000066D0                 mov     [ebp+var_4], ecx
.text$mn:000066D3                 mov     ecx, [ebp+arg_0]
.text$mn:000066D6                 call    ??0?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<DockingSplitter *>>::_Wrap_alloc<std::allocator<DockingSplitter *>>(void)
.text$mn:000066DB                 mov     eax, [ebp+arg_0]
.text$mn:000066DE                 mov     esp, ebp
.text$mn:000066E0                 pop     ebp
.text$mn:000066E1                 retn    4
.text$mn:000066E1 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ endp
.text$mn:000066E1
.text$mn:000066E1 _text$mn        ends
.text$mn:000066E1
.text$mn:000066E4 ; ===========================================================================
.text$mn:000066E4
.text$mn:000066E4 ; Segment type: Pure code
.text$mn:000066E4 ; Segment permissions: Read/Execute
.text$mn:000066E4 _text$mn        segment para public 'CODE' use32
.text$mn:000066E4                 assume cs:_text$mn
.text$mn:000066E4                 ;org 66E4h
.text$mn:000066E4 ; COMDAT (pick any)
.text$mn:000066E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066E4
.text$mn:000066E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000066E4
.text$mn:000066E4 ; Attributes: bp-based frame
.text$mn:000066E4
.text$mn:000066E4 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:000066E4                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:000066E4 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:000066E4                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)+3Cp
.text$mn:000066E4                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *)+3Cp ...
.text$mn:000066E4
.text$mn:000066E4 var_8           = dword ptr -8
.text$mn:000066E4 var_4           = dword ptr -4
.text$mn:000066E4
.text$mn:000066E4                 push    ebp
.text$mn:000066E5                 mov     ebp, esp
.text$mn:000066E7                 sub     esp, 8
.text$mn:000066EA                 mov     [ebp+var_4], ecx
.text$mn:000066ED                 mov     eax, [ebp+var_4]
.text$mn:000066F0                 cmp     dword ptr [eax], 0
.text$mn:000066F3                 jnz     short loc_66FE
.text$mn:000066F5                 mov     [ebp+var_8], 0
.text$mn:000066FC                 jmp     short loc_6709
.text$mn:000066FE ; ---------------------------------------------------------------------------
.text$mn:000066FE
.text$mn:000066FE loc_66FE:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:000066FE                 mov     ecx, [ebp+var_4]
.text$mn:00006701                 mov     edx, [ecx]
.text$mn:00006703                 add     edx, 4
.text$mn:00006706                 mov     [ebp+var_8], edx
.text$mn:00006709
.text$mn:00006709 loc_6709:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:00006709                 mov     eax, [ebp+var_8]
.text$mn:0000670C                 mov     esp, ebp
.text$mn:0000670E                 pop     ebp
.text$mn:0000670F                 retn
.text$mn:0000670F ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:0000670F
.text$mn:0000670F _text$mn        ends
.text$mn:0000670F
.text$mn:00006710 ; ===========================================================================
.text$mn:00006710
.text$mn:00006710 ; Segment type: Pure code
.text$mn:00006710 ; Segment permissions: Read/Execute
.text$mn:00006710 _text$mn        segment para public 'CODE' use32
.text$mn:00006710                 assume cs:_text$mn
.text$mn:00006710                 ;org 6710h
.text$mn:00006710 ; COMDAT (pick any)
.text$mn:00006710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006710
.text$mn:00006710 ; =============== S U B R O U T I N E =======================================
.text$mn:00006710
.text$mn:00006710 ; Attributes: bp-based frame
.text$mn:00006710
.text$mn:00006710 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:00006710                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:00006710 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:00006710                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)+71p
.text$mn:00006710                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)+8Ap ...
.text$mn:00006710
.text$mn:00006710 var_4           = dword ptr -4
.text$mn:00006710
.text$mn:00006710                 push    ebp
.text$mn:00006711                 mov     ebp, esp
.text$mn:00006713                 push    ecx
.text$mn:00006714                 mov     [ebp+var_4], ecx
.text$mn:00006717                 mov     eax, [ebp+var_4]
.text$mn:0000671A                 add     eax, 4
.text$mn:0000671D                 mov     esp, ebp
.text$mn:0000671F                 pop     ebp
.text$mn:00006720                 retn
.text$mn:00006720 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:00006720
.text$mn:00006720 ; ---------------------------------------------------------------------------
.text$mn:00006721                 align 4
.text$mn:00006721 _text$mn        ends
.text$mn:00006721
.text$mn:00006724 ; ===========================================================================
.text$mn:00006724
.text$mn:00006724 ; Segment type: Pure code
.text$mn:00006724 ; Segment permissions: Read/Execute
.text$mn:00006724 _text$mn        segment para public 'CODE' use32
.text$mn:00006724                 assume cs:_text$mn
.text$mn:00006724                 ;org 6724h
.text$mn:00006724 ; COMDAT (pick any)
.text$mn:00006724                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006724
.text$mn:00006724 ; =============== S U B R O U T I N E =======================================
.text$mn:00006724
.text$mn:00006724 ; Attributes: bp-based frame
.text$mn:00006724
.text$mn:00006724 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00006724                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00006724 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00006724                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00006724                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00006724
.text$mn:00006724 var_C           = dword ptr -0Ch
.text$mn:00006724 Size            = dword ptr -8
.text$mn:00006724 var_4           = dword ptr -4
.text$mn:00006724 arg_0           = dword ptr  8
.text$mn:00006724 arg_4           = byte ptr  0Ch
.text$mn:00006724
.text$mn:00006724                 push    ebp
.text$mn:00006725                 mov     ebp, esp
.text$mn:00006727                 sub     esp, 0Ch
.text$mn:0000672A                 mov     [ebp+var_4], ecx
.text$mn:0000672D                 mov     ecx, [ebp+var_4]
.text$mn:00006730                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00006735                 cmp     eax, [ebp+arg_0]
.text$mn:00006738                 jnb     short loc_6742
.text$mn:0000673A                 mov     ecx, [ebp+var_4]
.text$mn:0000673D                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00006742
.text$mn:00006742 loc_6742:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00006742                 mov     eax, [ebp+var_4]
.text$mn:00006745                 mov     ecx, [eax+18h]
.text$mn:00006748                 cmp     ecx, [ebp+arg_0]
.text$mn:0000674B                 jnb     short loc_6762
.text$mn:0000674D                 mov     edx, [ebp+var_4]
.text$mn:00006750                 mov     eax, [edx+14h]
.text$mn:00006753                 push    eax
.text$mn:00006754                 mov     ecx, [ebp+arg_0]
.text$mn:00006757                 push    ecx
.text$mn:00006758                 mov     ecx, [ebp+var_4]
.text$mn:0000675B                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00006760                 jmp     short loc_67AC
.text$mn:00006762 ; ---------------------------------------------------------------------------
.text$mn:00006762
.text$mn:00006762 loc_6762:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00006762                 movzx   edx, [ebp+arg_4]
.text$mn:00006766                 test    edx, edx
.text$mn:00006768                 jz      short loc_679C
.text$mn:0000676A                 cmp     [ebp+arg_0], 10h
.text$mn:0000676E                 jnb     short loc_679C
.text$mn:00006770                 mov     eax, [ebp+var_4]
.text$mn:00006773                 mov     ecx, [ebp+arg_0]
.text$mn:00006776                 cmp     ecx, [eax+14h]
.text$mn:00006779                 jnb     short loc_6783
.text$mn:0000677B                 mov     edx, [ebp+arg_0]
.text$mn:0000677E                 mov     [ebp+Size], edx
.text$mn:00006781                 jmp     short loc_678C
.text$mn:00006783 ; ---------------------------------------------------------------------------
.text$mn:00006783
.text$mn:00006783 loc_6783:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00006783                 mov     eax, [ebp+var_4]
.text$mn:00006786                 mov     ecx, [eax+14h]
.text$mn:00006789                 mov     [ebp+Size], ecx
.text$mn:0000678C
.text$mn:0000678C loc_678C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:0000678C                 mov     edx, [ebp+Size]
.text$mn:0000678F                 push    edx             ; Size
.text$mn:00006790                 push    1               ; char
.text$mn:00006792                 mov     ecx, [ebp+var_4]
.text$mn:00006795                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000679A                 jmp     short loc_67AC
.text$mn:0000679C ; ---------------------------------------------------------------------------
.text$mn:0000679C
.text$mn:0000679C loc_679C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:0000679C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:0000679C                 cmp     [ebp+arg_0], 0
.text$mn:000067A0                 jnz     short loc_67AC
.text$mn:000067A2                 push    0
.text$mn:000067A4                 mov     ecx, [ebp+var_4]
.text$mn:000067A7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000067AC
.text$mn:000067AC loc_67AC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:000067AC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:000067AC                 cmp     [ebp+arg_0], 0
.text$mn:000067B0                 jbe     short loc_67BB
.text$mn:000067B2                 mov     [ebp+var_C], 1
.text$mn:000067B9                 jmp     short loc_67C2
.text$mn:000067BB ; ---------------------------------------------------------------------------
.text$mn:000067BB
.text$mn:000067BB loc_67BB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:000067BB                 mov     [ebp+var_C], 0
.text$mn:000067C2
.text$mn:000067C2 loc_67C2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000067C2                 mov     al, byte ptr [ebp+var_C]
.text$mn:000067C5                 mov     esp, ebp
.text$mn:000067C7                 pop     ebp
.text$mn:000067C8                 retn    8
.text$mn:000067C8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000067C8
.text$mn:000067C8 ; ---------------------------------------------------------------------------
.text$mn:000067CB                 align 4
.text$mn:000067CB _text$mn        ends
.text$mn:000067CB
.text$mn:000067CC ; ===========================================================================
.text$mn:000067CC
.text$mn:000067CC ; Segment type: Pure code
.text$mn:000067CC ; Segment permissions: Read/Execute
.text$mn:000067CC _text$mn        segment para public 'CODE' use32
.text$mn:000067CC                 assume cs:_text$mn
.text$mn:000067CC                 ;org 67CCh
.text$mn:000067CC ; COMDAT (pick any)
.text$mn:000067CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067CC
.text$mn:000067CC ; =============== S U B R O U T I N E =======================================
.text$mn:000067CC
.text$mn:000067CC ; Attributes: bp-based frame
.text$mn:000067CC
.text$mn:000067CC ; protected: unsigned int __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::_Grow_to(unsigned int)const
.text$mn:000067CC                 public ?_Grow_to@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEII@Z
.text$mn:000067CC ?_Grow_to@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEII@Z proc near
.text$mn:000067CC                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reserve(uint)+45p
.text$mn:000067CC
.text$mn:000067CC var_C           = dword ptr -0Ch
.text$mn:000067CC var_8           = dword ptr -8
.text$mn:000067CC var_4           = dword ptr -4
.text$mn:000067CC arg_0           = dword ptr  8
.text$mn:000067CC
.text$mn:000067CC                 push    ebp
.text$mn:000067CD                 mov     ebp, esp
.text$mn:000067CF                 sub     esp, 0Ch
.text$mn:000067D2                 mov     [ebp+var_8], ecx
.text$mn:000067D5                 mov     ecx, [ebp+var_8]
.text$mn:000067D8                 call    ?capacity@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::capacity(void)
.text$mn:000067DD                 mov     [ebp+var_4], eax
.text$mn:000067E0                 mov     ecx, [ebp+var_8]
.text$mn:000067E3                 call    ?max_size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::max_size(void)
.text$mn:000067E8                 mov     ecx, [ebp+var_4]
.text$mn:000067EB                 shr     ecx, 1
.text$mn:000067ED                 sub     eax, ecx
.text$mn:000067EF                 cmp     eax, [ebp+var_4]
.text$mn:000067F2                 jnb     short loc_67FD
.text$mn:000067F4                 mov     [ebp+var_C], 0
.text$mn:000067FB                 jmp     short loc_6808
.text$mn:000067FD ; ---------------------------------------------------------------------------
.text$mn:000067FD
.text$mn:000067FD loc_67FD:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Grow_to(uint)+26j
.text$mn:000067FD                 mov     edx, [ebp+var_4]
.text$mn:00006800                 shr     edx, 1
.text$mn:00006802                 add     edx, [ebp+var_4]
.text$mn:00006805                 mov     [ebp+var_C], edx
.text$mn:00006808
.text$mn:00006808 loc_6808:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Grow_to(uint)+2Fj
.text$mn:00006808                 mov     eax, [ebp+var_C]
.text$mn:0000680B                 mov     [ebp+var_4], eax
.text$mn:0000680E                 mov     ecx, [ebp+var_4]
.text$mn:00006811                 cmp     ecx, [ebp+arg_0]
.text$mn:00006814                 jnb     short loc_681C
.text$mn:00006816                 mov     edx, [ebp+arg_0]
.text$mn:00006819                 mov     [ebp+var_4], edx
.text$mn:0000681C
.text$mn:0000681C loc_681C:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Grow_to(uint)+48j
.text$mn:0000681C                 mov     eax, [ebp+var_4]
.text$mn:0000681F                 mov     esp, ebp
.text$mn:00006821                 pop     ebp
.text$mn:00006822                 retn    4
.text$mn:00006822 ?_Grow_to@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEII@Z endp
.text$mn:00006822
.text$mn:00006822 ; ---------------------------------------------------------------------------
.text$mn:00006825                 align 4
.text$mn:00006825 _text$mn        ends
.text$mn:00006825
.text$mn:00006828 ; ===========================================================================
.text$mn:00006828
.text$mn:00006828 ; Segment type: Pure code
.text$mn:00006828 ; Segment permissions: Read/Execute
.text$mn:00006828 _text$mn        segment para public 'CODE' use32
.text$mn:00006828                 assume cs:_text$mn
.text$mn:00006828                 ;org 6828h
.text$mn:00006828 ; COMDAT (pick any)
.text$mn:00006828                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006828
.text$mn:00006828 ; =============== S U B R O U T I N E =======================================
.text$mn:00006828
.text$mn:00006828 ; Attributes: bp-based frame
.text$mn:00006828
.text$mn:00006828 ; protected: unsigned int __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Grow_to(unsigned int)const
.text$mn:00006828                 public ?_Grow_to@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEII@Z
.text$mn:00006828 ?_Grow_to@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEII@Z proc near
.text$mn:00006828                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reserve(uint)+45p
.text$mn:00006828
.text$mn:00006828 var_C           = dword ptr -0Ch
.text$mn:00006828 var_8           = dword ptr -8
.text$mn:00006828 var_4           = dword ptr -4
.text$mn:00006828 arg_0           = dword ptr  8
.text$mn:00006828
.text$mn:00006828                 push    ebp
.text$mn:00006829                 mov     ebp, esp
.text$mn:0000682B                 sub     esp, 0Ch
.text$mn:0000682E                 mov     [ebp+var_8], ecx
.text$mn:00006831                 mov     ecx, [ebp+var_8]
.text$mn:00006834                 call    ?capacity@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::capacity(void)
.text$mn:00006839                 mov     [ebp+var_4], eax
.text$mn:0000683C                 mov     ecx, [ebp+var_8]
.text$mn:0000683F                 call    ?max_size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::max_size(void)
.text$mn:00006844                 mov     ecx, [ebp+var_4]
.text$mn:00006847                 shr     ecx, 1
.text$mn:00006849                 sub     eax, ecx
.text$mn:0000684B                 cmp     eax, [ebp+var_4]
.text$mn:0000684E                 jnb     short loc_6859
.text$mn:00006850                 mov     [ebp+var_C], 0
.text$mn:00006857                 jmp     short loc_6864
.text$mn:00006859 ; ---------------------------------------------------------------------------
.text$mn:00006859
.text$mn:00006859 loc_6859:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Grow_to(uint)+26j
.text$mn:00006859                 mov     edx, [ebp+var_4]
.text$mn:0000685C                 shr     edx, 1
.text$mn:0000685E                 add     edx, [ebp+var_4]
.text$mn:00006861                 mov     [ebp+var_C], edx
.text$mn:00006864
.text$mn:00006864 loc_6864:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Grow_to(uint)+2Fj
.text$mn:00006864                 mov     eax, [ebp+var_C]
.text$mn:00006867                 mov     [ebp+var_4], eax
.text$mn:0000686A                 mov     ecx, [ebp+var_4]
.text$mn:0000686D                 cmp     ecx, [ebp+arg_0]
.text$mn:00006870                 jnb     short loc_6878
.text$mn:00006872                 mov     edx, [ebp+arg_0]
.text$mn:00006875                 mov     [ebp+var_4], edx
.text$mn:00006878
.text$mn:00006878 loc_6878:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Grow_to(uint)+48j
.text$mn:00006878                 mov     eax, [ebp+var_4]
.text$mn:0000687B                 mov     esp, ebp
.text$mn:0000687D                 pop     ebp
.text$mn:0000687E                 retn    4
.text$mn:0000687E ?_Grow_to@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEII@Z endp
.text$mn:0000687E
.text$mn:0000687E ; ---------------------------------------------------------------------------
.text$mn:00006881                 align 4
.text$mn:00006881 _text$mn        ends
.text$mn:00006881
.text$mn:00006884 ; ===========================================================================
.text$mn:00006884
.text$mn:00006884 ; Segment type: Pure code
.text$mn:00006884 ; Segment permissions: Read/Execute
.text$mn:00006884 _text$mn        segment para public 'CODE' use32
.text$mn:00006884                 assume cs:_text$mn
.text$mn:00006884                 ;org 6884h
.text$mn:00006884 ; COMDAT (pick any)
.text$mn:00006884                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006884
.text$mn:00006884 ; =============== S U B R O U T I N E =======================================
.text$mn:00006884
.text$mn:00006884 ; Attributes: bp-based frame
.text$mn:00006884
.text$mn:00006884 ; protected: unsigned int __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::_Grow_to(unsigned int)const
.text$mn:00006884                 public ?_Grow_to@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEII@Z
.text$mn:00006884 ?_Grow_to@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEII@Z proc near
.text$mn:00006884                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reserve(uint)+45p
.text$mn:00006884
.text$mn:00006884 var_C           = dword ptr -0Ch
.text$mn:00006884 var_8           = dword ptr -8
.text$mn:00006884 var_4           = dword ptr -4
.text$mn:00006884 arg_0           = dword ptr  8
.text$mn:00006884
.text$mn:00006884                 push    ebp
.text$mn:00006885                 mov     ebp, esp
.text$mn:00006887                 sub     esp, 0Ch
.text$mn:0000688A                 mov     [ebp+var_8], ecx
.text$mn:0000688D                 mov     ecx, [ebp+var_8]
.text$mn:00006890                 call    ?capacity@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::capacity(void)
.text$mn:00006895                 mov     [ebp+var_4], eax
.text$mn:00006898                 mov     ecx, [ebp+var_8]
.text$mn:0000689B                 call    ?max_size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::max_size(void)
.text$mn:000068A0                 mov     ecx, [ebp+var_4]
.text$mn:000068A3                 shr     ecx, 1
.text$mn:000068A5                 sub     eax, ecx
.text$mn:000068A7                 cmp     eax, [ebp+var_4]
.text$mn:000068AA                 jnb     short loc_68B5
.text$mn:000068AC                 mov     [ebp+var_C], 0
.text$mn:000068B3                 jmp     short loc_68C0
.text$mn:000068B5 ; ---------------------------------------------------------------------------
.text$mn:000068B5
.text$mn:000068B5 loc_68B5:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Grow_to(uint)+26j
.text$mn:000068B5                 mov     edx, [ebp+var_4]
.text$mn:000068B8                 shr     edx, 1
.text$mn:000068BA                 add     edx, [ebp+var_4]
.text$mn:000068BD                 mov     [ebp+var_C], edx
.text$mn:000068C0
.text$mn:000068C0 loc_68C0:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Grow_to(uint)+2Fj
.text$mn:000068C0                 mov     eax, [ebp+var_C]
.text$mn:000068C3                 mov     [ebp+var_4], eax
.text$mn:000068C6                 mov     ecx, [ebp+var_4]
.text$mn:000068C9                 cmp     ecx, [ebp+arg_0]
.text$mn:000068CC                 jnb     short loc_68D4
.text$mn:000068CE                 mov     edx, [ebp+arg_0]
.text$mn:000068D1                 mov     [ebp+var_4], edx
.text$mn:000068D4
.text$mn:000068D4 loc_68D4:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Grow_to(uint)+48j
.text$mn:000068D4                 mov     eax, [ebp+var_4]
.text$mn:000068D7                 mov     esp, ebp
.text$mn:000068D9                 pop     ebp
.text$mn:000068DA                 retn    4
.text$mn:000068DA ?_Grow_to@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEII@Z endp
.text$mn:000068DA
.text$mn:000068DA ; ---------------------------------------------------------------------------
.text$mn:000068DD                 align 10h
.text$mn:000068DD _text$mn        ends
.text$mn:000068DD
.text$mn:000068E0 ; ===========================================================================
.text$mn:000068E0
.text$mn:000068E0 ; Segment type: Pure code
.text$mn:000068E0 ; Segment permissions: Read/Execute
.text$mn:000068E0 _text$mn        segment para public 'CODE' use32
.text$mn:000068E0                 assume cs:_text$mn
.text$mn:000068E0                 ;org 68E0h
.text$mn:000068E0 ; COMDAT (pick any)
.text$mn:000068E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000068E0
.text$mn:000068E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000068E0
.text$mn:000068E0 ; Attributes: bp-based frame
.text$mn:000068E0
.text$mn:000068E0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000068E0                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000068E0 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000068E0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000068E0
.text$mn:000068E0 var_4           = dword ptr -4
.text$mn:000068E0 arg_0           = dword ptr  8
.text$mn:000068E0
.text$mn:000068E0                 push    ebp
.text$mn:000068E1                 mov     ebp, esp
.text$mn:000068E3                 push    ecx
.text$mn:000068E4                 mov     [ebp+var_4], ecx
.text$mn:000068E7                 cmp     [ebp+arg_0], 0
.text$mn:000068EB                 jz      short loc_690D
.text$mn:000068ED                 mov     ecx, [ebp+var_4]
.text$mn:000068F0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000068F5                 cmp     [ebp+arg_0], eax
.text$mn:000068F8                 jb      short loc_690D
.text$mn:000068FA                 mov     ecx, [ebp+var_4]
.text$mn:000068FD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006902                 mov     ecx, [ebp+var_4]
.text$mn:00006905                 add     eax, [ecx+14h]
.text$mn:00006908                 cmp     eax, [ebp+arg_0]
.text$mn:0000690B                 ja      short loc_6913
.text$mn:0000690D
.text$mn:0000690D loc_690D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:0000690D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:0000690D                 xor     al, al
.text$mn:0000690F                 jmp     short loc_6915
.text$mn:00006911 ; ---------------------------------------------------------------------------
.text$mn:00006911                 jmp     short loc_6915
.text$mn:00006913 ; ---------------------------------------------------------------------------
.text$mn:00006913
.text$mn:00006913 loc_6913:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00006913                 mov     al, 1
.text$mn:00006915
.text$mn:00006915 loc_6915:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00006915                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00006915                 mov     esp, ebp
.text$mn:00006917                 pop     ebp
.text$mn:00006918                 retn    4
.text$mn:00006918 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00006918
.text$mn:00006918 ; ---------------------------------------------------------------------------
.text$mn:0000691B                 align 4
.text$mn:0000691B _text$mn        ends
.text$mn:0000691B
.text$mn:0000691C ; ===========================================================================
.text$mn:0000691C
.text$mn:0000691C ; Segment type: Pure code
.text$mn:0000691C ; Segment permissions: Read/Execute
.text$mn:0000691C _text$mn        segment para public 'CODE' use32
.text$mn:0000691C                 assume cs:_text$mn
.text$mn:0000691C                 ;org 691Ch
.text$mn:0000691C ; COMDAT (pick any)
.text$mn:0000691C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000691C
.text$mn:0000691C ; =============== S U B R O U T I N E =======================================
.text$mn:0000691C
.text$mn:0000691C ; Attributes: bp-based frame
.text$mn:0000691C
.text$mn:0000691C ; protected: bool __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::_Inside(struct HWND__ * const *)const
.text$mn:0000691C                 public ?_Inside@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBE_NPBQAUHWND__@@@Z
.text$mn:0000691C ?_Inside@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBE_NPBQAUHWND__@@@Z proc near
.text$mn:0000691C                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+19p
.text$mn:0000691C
.text$mn:0000691C var_8           = dword ptr -8
.text$mn:0000691C var_4           = dword ptr -4
.text$mn:0000691C arg_0           = dword ptr  8
.text$mn:0000691C
.text$mn:0000691C                 push    ebp
.text$mn:0000691D                 mov     ebp, esp
.text$mn:0000691F                 sub     esp, 8
.text$mn:00006922                 mov     [ebp+var_4], ecx
.text$mn:00006925                 mov     eax, [ebp+var_4]
.text$mn:00006928                 mov     ecx, [ebp+arg_0]
.text$mn:0000692B                 cmp     ecx, [eax+8]
.text$mn:0000692E                 jnb     short loc_6944
.text$mn:00006930                 mov     edx, [ebp+var_4]
.text$mn:00006933                 mov     eax, [edx+4]
.text$mn:00006936                 cmp     eax, [ebp+arg_0]
.text$mn:00006939                 ja      short loc_6944
.text$mn:0000693B                 mov     [ebp+var_8], 1
.text$mn:00006942                 jmp     short loc_694B
.text$mn:00006944 ; ---------------------------------------------------------------------------
.text$mn:00006944
.text$mn:00006944 loc_6944:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Inside(HWND__ * const *)+12j
.text$mn:00006944                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Inside(HWND__ * const *)+1Dj
.text$mn:00006944                 mov     [ebp+var_8], 0
.text$mn:0000694B
.text$mn:0000694B loc_694B:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Inside(HWND__ * const *)+26j
.text$mn:0000694B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000694E                 mov     esp, ebp
.text$mn:00006950                 pop     ebp
.text$mn:00006951                 retn    4
.text$mn:00006951 ?_Inside@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBE_NPBQAUHWND__@@@Z endp
.text$mn:00006951
.text$mn:00006951 _text$mn        ends
.text$mn:00006951
.text$mn:00006954 ; ===========================================================================
.text$mn:00006954
.text$mn:00006954 ; Segment type: Pure code
.text$mn:00006954 ; Segment permissions: Read/Execute
.text$mn:00006954 _text$mn        segment para public 'CODE' use32
.text$mn:00006954                 assume cs:_text$mn
.text$mn:00006954                 ;org 6954h
.text$mn:00006954 ; COMDAT (pick any)
.text$mn:00006954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006954
.text$mn:00006954 ; =============== S U B R O U T I N E =======================================
.text$mn:00006954
.text$mn:00006954 ; Attributes: bp-based frame
.text$mn:00006954
.text$mn:00006954 ; protected: bool __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Inside(class DockingCont * const *)const
.text$mn:00006954                 public ?_Inside@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBE_NPBQAVDockingCont@@@Z
.text$mn:00006954 ?_Inside@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBE_NPBQAVDockingCont@@@Z proc near
.text$mn:00006954                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+19p
.text$mn:00006954
.text$mn:00006954 var_8           = dword ptr -8
.text$mn:00006954 var_4           = dword ptr -4
.text$mn:00006954 arg_0           = dword ptr  8
.text$mn:00006954
.text$mn:00006954                 push    ebp
.text$mn:00006955                 mov     ebp, esp
.text$mn:00006957                 sub     esp, 8
.text$mn:0000695A                 mov     [ebp+var_4], ecx
.text$mn:0000695D                 mov     eax, [ebp+var_4]
.text$mn:00006960                 mov     ecx, [ebp+arg_0]
.text$mn:00006963                 cmp     ecx, [eax+8]
.text$mn:00006966                 jnb     short loc_697C
.text$mn:00006968                 mov     edx, [ebp+var_4]
.text$mn:0000696B                 mov     eax, [edx+4]
.text$mn:0000696E                 cmp     eax, [ebp+arg_0]
.text$mn:00006971                 ja      short loc_697C
.text$mn:00006973                 mov     [ebp+var_8], 1
.text$mn:0000697A                 jmp     short loc_6983
.text$mn:0000697C ; ---------------------------------------------------------------------------
.text$mn:0000697C
.text$mn:0000697C loc_697C:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Inside(DockingCont * const *)+12j
.text$mn:0000697C                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Inside(DockingCont * const *)+1Dj
.text$mn:0000697C                 mov     [ebp+var_8], 0
.text$mn:00006983
.text$mn:00006983 loc_6983:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Inside(DockingCont * const *)+26j
.text$mn:00006983                 mov     al, byte ptr [ebp+var_8]
.text$mn:00006986                 mov     esp, ebp
.text$mn:00006988                 pop     ebp
.text$mn:00006989                 retn    4
.text$mn:00006989 ?_Inside@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBE_NPBQAVDockingCont@@@Z endp
.text$mn:00006989
.text$mn:00006989 _text$mn        ends
.text$mn:00006989
.text$mn:0000698C ; ===========================================================================
.text$mn:0000698C
.text$mn:0000698C ; Segment type: Pure code
.text$mn:0000698C ; Segment permissions: Read/Execute
.text$mn:0000698C _text$mn        segment para public 'CODE' use32
.text$mn:0000698C                 assume cs:_text$mn
.text$mn:0000698C                 ;org 698Ch
.text$mn:0000698C ; COMDAT (pick any)
.text$mn:0000698C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000698C
.text$mn:0000698C ; =============== S U B R O U T I N E =======================================
.text$mn:0000698C
.text$mn:0000698C ; Attributes: bp-based frame
.text$mn:0000698C
.text$mn:0000698C ; protected: bool __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::_Inside(class DockingSplitter * const *)const
.text$mn:0000698C                 public ?_Inside@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBE_NPBQAVDockingSplitter@@@Z
.text$mn:0000698C ?_Inside@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBE_NPBQAVDockingSplitter@@@Z proc near
.text$mn:0000698C                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+19p
.text$mn:0000698C
.text$mn:0000698C var_8           = dword ptr -8
.text$mn:0000698C var_4           = dword ptr -4
.text$mn:0000698C arg_0           = dword ptr  8
.text$mn:0000698C
.text$mn:0000698C                 push    ebp
.text$mn:0000698D                 mov     ebp, esp
.text$mn:0000698F                 sub     esp, 8
.text$mn:00006992                 mov     [ebp+var_4], ecx
.text$mn:00006995                 mov     eax, [ebp+var_4]
.text$mn:00006998                 mov     ecx, [ebp+arg_0]
.text$mn:0000699B                 cmp     ecx, [eax+8]
.text$mn:0000699E                 jnb     short loc_69B4
.text$mn:000069A0                 mov     edx, [ebp+var_4]
.text$mn:000069A3                 mov     eax, [edx+4]
.text$mn:000069A6                 cmp     eax, [ebp+arg_0]
.text$mn:000069A9                 ja      short loc_69B4
.text$mn:000069AB                 mov     [ebp+var_8], 1
.text$mn:000069B2                 jmp     short loc_69BB
.text$mn:000069B4 ; ---------------------------------------------------------------------------
.text$mn:000069B4
.text$mn:000069B4 loc_69B4:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Inside(DockingSplitter * const *)+12j
.text$mn:000069B4                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Inside(DockingSplitter * const *)+1Dj
.text$mn:000069B4                 mov     [ebp+var_8], 0
.text$mn:000069BB
.text$mn:000069BB loc_69BB:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Inside(DockingSplitter * const *)+26j
.text$mn:000069BB                 mov     al, byte ptr [ebp+var_8]
.text$mn:000069BE                 mov     esp, ebp
.text$mn:000069C0                 pop     ebp
.text$mn:000069C1                 retn    4
.text$mn:000069C1 ?_Inside@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBE_NPBQAVDockingSplitter@@@Z endp
.text$mn:000069C1
.text$mn:000069C1 _text$mn        ends
.text$mn:000069C1
.text$mn:000069C4 ; ===========================================================================
.text$mn:000069C4
.text$mn:000069C4 ; Segment type: Pure code
.text$mn:000069C4 ; Segment permissions: Read/Execute
.text$mn:000069C4 _text$mn        segment para public 'CODE' use32
.text$mn:000069C4                 assume cs:_text$mn
.text$mn:000069C4                 ;org 69C4h
.text$mn:000069C4 ; COMDAT (pick any)
.text$mn:000069C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000069C4
.text$mn:000069C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000069C4
.text$mn:000069C4 ; Attributes: bp-based frame
.text$mn:000069C4
.text$mn:000069C4 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000069C4                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000069C4 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000069C4                                         ; CODE XREF: $LN19+14p
.text$mn:000069C4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000069C4
.text$mn:000069C4 var_8           = dword ptr -8
.text$mn:000069C4 var_4           = dword ptr -4
.text$mn:000069C4
.text$mn:000069C4                 push    ebp
.text$mn:000069C5                 mov     ebp, esp
.text$mn:000069C7                 sub     esp, 8
.text$mn:000069CA                 mov     [ebp+var_4], ecx
.text$mn:000069CD                 mov     eax, [ebp+var_4]
.text$mn:000069D0                 cmp     dword ptr [eax+18h], 10h
.text$mn:000069D4                 jb      short loc_69EA
.text$mn:000069D6                 mov     ecx, [ebp+var_4]
.text$mn:000069D9                 mov     edx, [ecx+4]
.text$mn:000069DC                 push    edx
.text$mn:000069DD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000069E2                 add     esp, 4
.text$mn:000069E5                 mov     [ebp+var_8], eax
.text$mn:000069E8                 jmp     short loc_69F3
.text$mn:000069EA ; ---------------------------------------------------------------------------
.text$mn:000069EA
.text$mn:000069EA loc_69EA:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000069EA                 mov     eax, [ebp+var_4]
.text$mn:000069ED                 add     eax, 4
.text$mn:000069F0                 mov     [ebp+var_8], eax
.text$mn:000069F3
.text$mn:000069F3 loc_69F3:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000069F3                 mov     eax, [ebp+var_8]
.text$mn:000069F6                 mov     esp, ebp
.text$mn:000069F8                 pop     ebp
.text$mn:000069F9                 retn
.text$mn:000069F9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000069F9
.text$mn:000069F9 ; ---------------------------------------------------------------------------
.text$mn:000069FA                 align 4
.text$mn:000069FA _text$mn        ends
.text$mn:000069FA
.text$mn:000069FC ; ===========================================================================
.text$mn:000069FC
.text$mn:000069FC ; Segment type: Pure code
.text$mn:000069FC ; Segment permissions: Read/Execute
.text$mn:000069FC _text$mn        segment para public 'CODE' use32
.text$mn:000069FC                 assume cs:_text$mn
.text$mn:000069FC                 ;org 69FCh
.text$mn:000069FC ; COMDAT (pick any)
.text$mn:000069FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000069FC
.text$mn:000069FC ; =============== S U B R O U T I N E =======================================
.text$mn:000069FC
.text$mn:000069FC ; Attributes: bp-based frame
.text$mn:000069FC
.text$mn:000069FC ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000069FC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000069FC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000069FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000069FC
.text$mn:000069FC var_8           = dword ptr -8
.text$mn:000069FC var_4           = dword ptr -4
.text$mn:000069FC
.text$mn:000069FC                 push    ebp
.text$mn:000069FD                 mov     ebp, esp
.text$mn:000069FF                 sub     esp, 8
.text$mn:00006A02                 mov     [ebp+var_4], ecx
.text$mn:00006A05                 mov     eax, [ebp+var_4]
.text$mn:00006A08                 cmp     dword ptr [eax+18h], 10h
.text$mn:00006A0C                 jb      short loc_6A22
.text$mn:00006A0E                 mov     ecx, [ebp+var_4]
.text$mn:00006A11                 mov     edx, [ecx+4]
.text$mn:00006A14                 push    edx
.text$mn:00006A15                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00006A1A                 add     esp, 4
.text$mn:00006A1D                 mov     [ebp+var_8], eax
.text$mn:00006A20                 jmp     short loc_6A2B
.text$mn:00006A22 ; ---------------------------------------------------------------------------
.text$mn:00006A22
.text$mn:00006A22 loc_6A22:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00006A22                 mov     eax, [ebp+var_4]
.text$mn:00006A25                 add     eax, 4
.text$mn:00006A28                 mov     [ebp+var_8], eax
.text$mn:00006A2B
.text$mn:00006A2B loc_6A2B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00006A2B                 mov     eax, [ebp+var_8]
.text$mn:00006A2E                 mov     esp, ebp
.text$mn:00006A30                 pop     ebp
.text$mn:00006A31                 retn
.text$mn:00006A31 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00006A31
.text$mn:00006A31 ; ---------------------------------------------------------------------------
.text$mn:00006A32                 align 4
.text$mn:00006A32 _text$mn        ends
.text$mn:00006A32
.text$mn:00006A34 ; ===========================================================================
.text$mn:00006A34
.text$mn:00006A34 ; Segment type: Pure code
.text$mn:00006A34 ; Segment permissions: Read/Execute
.text$mn:00006A34 _text$mn        segment para public 'CODE' use32
.text$mn:00006A34                 assume cs:_text$mn
.text$mn:00006A34                 ;org 6A34h
.text$mn:00006A34 ; COMDAT (pick any)
.text$mn:00006A34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A34
.text$mn:00006A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A34
.text$mn:00006A34 ; Attributes: bp-based frame
.text$mn:00006A34
.text$mn:00006A34 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00006A34                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00006A34 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00006A34                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00006A34                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00006A34
.text$mn:00006A34 var_18          = byte ptr -18h
.text$mn:00006A34 var_14          = dword ptr -14h
.text$mn:00006A34 var_10          = dword ptr -10h
.text$mn:00006A34 var_C           = dword ptr -0Ch
.text$mn:00006A34 var_4           = dword ptr -4
.text$mn:00006A34
.text$mn:00006A34                 push    ebp
.text$mn:00006A35                 mov     ebp, esp
.text$mn:00006A37                 push    0FFFFFFFFh
.text$mn:00006A39                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00006A3E                 mov     eax, large fs:0
.text$mn:00006A44                 push    eax
.text$mn:00006A45                 sub     esp, 0Ch
.text$mn:00006A48                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006A4D                 xor     eax, ebp
.text$mn:00006A4F                 push    eax
.text$mn:00006A50                 lea     eax, [ebp+var_C]
.text$mn:00006A53                 mov     large fs:0, eax
.text$mn:00006A59                 mov     [ebp+var_14], ecx
.text$mn:00006A5C                 mov     eax, [ebp+var_14]
.text$mn:00006A5F                 cmp     dword ptr [eax], 0
.text$mn:00006A62                 jz      short loc_6ABF
.text$mn:00006A64                 push    3               ; int
.text$mn:00006A66                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006A69                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006A6E                 mov     [ebp+var_4], 0
.text$mn:00006A75                 mov     ecx, [ebp+var_14]
.text$mn:00006A78                 mov     edx, [ecx]
.text$mn:00006A7A                 add     edx, 4
.text$mn:00006A7D                 mov     [ebp+var_10], edx
.text$mn:00006A80                 jmp     short loc_6A8F
.text$mn:00006A82 ; ---------------------------------------------------------------------------
.text$mn:00006A82
.text$mn:00006A82 loc_6A82:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00006A82                 mov     eax, [ebp+var_10]
.text$mn:00006A85                 mov     ecx, [eax]
.text$mn:00006A87                 mov     edx, [ebp+var_10]
.text$mn:00006A8A                 mov     eax, [ecx+4]
.text$mn:00006A8D                 mov     [edx], eax
.text$mn:00006A8F
.text$mn:00006A8F loc_6A8F:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00006A8F                 mov     ecx, [ebp+var_10]
.text$mn:00006A92                 cmp     dword ptr [ecx], 0
.text$mn:00006A95                 jz      short loc_6AA4
.text$mn:00006A97                 mov     edx, [ebp+var_10]
.text$mn:00006A9A                 mov     eax, [edx]
.text$mn:00006A9C                 mov     dword ptr [eax], 0
.text$mn:00006AA2                 jmp     short loc_6A82
.text$mn:00006AA4 ; ---------------------------------------------------------------------------
.text$mn:00006AA4
.text$mn:00006AA4 loc_6AA4:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00006AA4                 mov     ecx, [ebp+var_14]
.text$mn:00006AA7                 mov     edx, [ecx]
.text$mn:00006AA9                 mov     dword ptr [edx+4], 0
.text$mn:00006AB0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006AB7                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006ABA                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006ABF
.text$mn:00006ABF loc_6ABF:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00006ABF                 mov     ecx, [ebp+var_C]
.text$mn:00006AC2                 mov     large fs:0, ecx
.text$mn:00006AC9                 pop     ecx
.text$mn:00006ACA                 mov     esp, ebp
.text$mn:00006ACC                 pop     ebp
.text$mn:00006ACD                 retn
.text$mn:00006ACD ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00006ACD
.text$mn:00006ACD ; ---------------------------------------------------------------------------
.text$mn:00006ACE                 align 10h
.text$mn:00006ACE _text$mn        ends
.text$mn:00006ACE
.text$x:00006AD0 ; ===========================================================================
.text$x:00006AD0
.text$x:00006AD0 ; Segment type: Pure code
.text$x:00006AD0 ; Segment permissions: Read/Execute
.text$x:00006AD0 _text$x         segment para public 'CODE' use32
.text$x:00006AD0                 assume cs:_text$x
.text$x:00006AD0                 ;org 6AD0h
.text$x:00006AD0 ; COMDAT (pick associative to section at 6A34)
.text$x:00006AD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006AD0
.text$x:00006AD0 ; =============== S U B R O U T I N E =======================================
.text$x:00006AD0
.text$x:00006AD0
.text$x:00006AD0 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00006AD0                                         ; DATA XREF: .xdata$x:00008C38o
.text$x:00006AD0                 lea     ecx, [ebp-18h]  ; this
.text$x:00006AD3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006AD3 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00006AD3
.text$x:00006AD8
.text$x:00006AD8 ; =============== S U B R O U T I N E =======================================
.text$x:00006AD8
.text$x:00006AD8
.text$x:00006AD8 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00006AD8                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00006AD8
.text$x:00006AD8 arg_4           = dword ptr  8
.text$x:00006AD8
.text$x:00006AD8                 mov     edx, [esp+arg_4]
.text$x:00006ADC                 lea     eax, [edx+0Ch]
.text$x:00006ADF                 mov     ecx, [edx-10h]
.text$x:00006AE2                 xor     ecx, eax
.text$x:00006AE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006AE9                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00006AEE                 jmp     ___CxxFrameHandler3
.text$x:00006AEE __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00006AEE
.text$x:00006AEE ; ---------------------------------------------------------------------------
.text$x:00006AF3                 align 4
.text$x:00006AF3 _text$x         ends
.text$x:00006AF3
.text$mn:00006AF4 ; ===========================================================================
.text$mn:00006AF4
.text$mn:00006AF4 ; Segment type: Pure code
.text$mn:00006AF4 ; Segment permissions: Read/Execute
.text$mn:00006AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00006AF4                 assume cs:_text$mn
.text$mn:00006AF4                 ;org 6AF4h
.text$mn:00006AF4 ; COMDAT (pick any)
.text$mn:00006AF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006AF4
.text$mn:00006AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AF4
.text$mn:00006AF4 ; Attributes: bp-based frame
.text$mn:00006AF4
.text$mn:00006AF4 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:00006AF4                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:00006AF4 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00006AF4                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:00006AF4                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:00006AF4
.text$mn:00006AF4 var_8           = dword ptr -8
.text$mn:00006AF4 var_4           = dword ptr -4
.text$mn:00006AF4
.text$mn:00006AF4                 push    ebp
.text$mn:00006AF5                 mov     ebp, esp
.text$mn:00006AF7                 sub     esp, 8
.text$mn:00006AFA                 mov     [ebp+var_8], ecx
.text$mn:00006AFD                 mov     eax, [ebp+var_8]
.text$mn:00006B00                 cmp     dword ptr [eax], 0
.text$mn:00006B03                 jz      short loc_6B62
.text$mn:00006B05                 mov     ecx, [ebp+var_8]
.text$mn:00006B08                 mov     edx, [ecx]
.text$mn:00006B0A                 add     edx, 4
.text$mn:00006B0D                 mov     [ebp+var_4], edx
.text$mn:00006B10
.text$mn:00006B10 loc_6B10:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:00006B10                 mov     eax, [ebp+var_4]
.text$mn:00006B13                 cmp     dword ptr [eax], 0
.text$mn:00006B16                 jz      short loc_6B2F
.text$mn:00006B18                 mov     ecx, [ebp+var_4]
.text$mn:00006B1B                 mov     edx, [ecx]
.text$mn:00006B1D                 cmp     edx, [ebp+var_8]
.text$mn:00006B20                 jz      short loc_6B2F
.text$mn:00006B22                 mov     eax, [ebp+var_4]
.text$mn:00006B25                 mov     ecx, [eax]
.text$mn:00006B27                 add     ecx, 4
.text$mn:00006B2A                 mov     [ebp+var_4], ecx
.text$mn:00006B2D                 jmp     short loc_6B10
.text$mn:00006B2F ; ---------------------------------------------------------------------------
.text$mn:00006B2F
.text$mn:00006B2F loc_6B2F:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:00006B2F                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:00006B2F                 mov     edx, [ebp+var_4]
.text$mn:00006B32                 cmp     dword ptr [edx], 0
.text$mn:00006B35                 jnz     short loc_6B4E
.text$mn:00006B37                 push    0C9h ; '+'      ; unsigned int
.text$mn:00006B3C                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006B41                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:00006B46                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00006B4B                 add     esp, 0Ch
.text$mn:00006B4E
.text$mn:00006B4E loc_6B4E:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:00006B4E                 mov     eax, [ebp+var_4]
.text$mn:00006B51                 mov     ecx, [ebp+var_8]
.text$mn:00006B54                 mov     edx, [ecx+4]
.text$mn:00006B57                 mov     [eax], edx
.text$mn:00006B59                 mov     eax, [ebp+var_8]
.text$mn:00006B5C                 mov     dword ptr [eax], 0
.text$mn:00006B62
.text$mn:00006B62 loc_6B62:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:00006B62                 mov     esp, ebp
.text$mn:00006B64                 pop     ebp
.text$mn:00006B65                 retn
.text$mn:00006B65 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00006B65
.text$mn:00006B65 ; ---------------------------------------------------------------------------
.text$mn:00006B66                 align 4
.text$mn:00006B66 _text$mn        ends
.text$mn:00006B66
.text$mn:00006B68 ; ===========================================================================
.text$mn:00006B68
.text$mn:00006B68 ; Segment type: Pure code
.text$mn:00006B68 ; Segment permissions: Read/Execute
.text$mn:00006B68 _text$mn        segment para public 'CODE' use32
.text$mn:00006B68                 assume cs:_text$mn
.text$mn:00006B68                 ;org 6B68h
.text$mn:00006B68 ; COMDAT (pick any)
.text$mn:00006B68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B68
.text$mn:00006B68 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B68
.text$mn:00006B68 ; Attributes: bp-based frame
.text$mn:00006B68
.text$mn:00006B68 ; protected: void __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::_Orphan_range(struct HWND__ * *, struct HWND__ * *)const
.text$mn:00006B68                 public ?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z
.text$mn:00006B68 ?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z proc near
.text$mn:00006B68                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+66p
.text$mn:00006B68                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+CCp
.text$mn:00006B68
.text$mn:00006B68 var_18          = byte ptr -18h
.text$mn:00006B68 var_14          = dword ptr -14h
.text$mn:00006B68 var_10          = dword ptr -10h
.text$mn:00006B68 var_C           = dword ptr -0Ch
.text$mn:00006B68 var_4           = dword ptr -4
.text$mn:00006B68 arg_0           = dword ptr  8
.text$mn:00006B68 arg_4           = dword ptr  0Ch
.text$mn:00006B68
.text$mn:00006B68                 push    ebp
.text$mn:00006B69                 mov     ebp, esp
.text$mn:00006B6B                 push    0FFFFFFFFh
.text$mn:00006B6D                 push    offset __ehhandler$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z
.text$mn:00006B72                 mov     eax, large fs:0
.text$mn:00006B78                 push    eax
.text$mn:00006B79                 sub     esp, 0Ch
.text$mn:00006B7C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006B81                 xor     eax, ebp
.text$mn:00006B83                 push    eax
.text$mn:00006B84                 lea     eax, [ebp+var_C]
.text$mn:00006B87                 mov     large fs:0, eax
.text$mn:00006B8D                 mov     [ebp+var_14], ecx
.text$mn:00006B90                 push    3               ; int
.text$mn:00006B92                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006B95                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006B9A                 mov     [ebp+var_4], 0
.text$mn:00006BA1                 mov     ecx, [ebp+var_14] ; this
.text$mn:00006BA4                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00006BA9                 mov     [ebp+var_10], eax
.text$mn:00006BAC                 cmp     [ebp+var_10], 0
.text$mn:00006BB0                 jz      short loc_6C00
.text$mn:00006BB2
.text$mn:00006BB2 loc_6BB2:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *):loc_6BFEj
.text$mn:00006BB2                 mov     eax, [ebp+var_10]
.text$mn:00006BB5                 cmp     dword ptr [eax], 0
.text$mn:00006BB8                 jz      short loc_6C00
.text$mn:00006BBA                 mov     ecx, [ebp+var_10]
.text$mn:00006BBD                 mov     edx, [ecx]
.text$mn:00006BBF                 mov     eax, [edx+8]
.text$mn:00006BC2                 cmp     eax, [ebp+arg_0]
.text$mn:00006BC5                 jb      short loc_6BD4
.text$mn:00006BC7                 mov     ecx, [ebp+var_10]
.text$mn:00006BCA                 mov     edx, [ecx]
.text$mn:00006BCC                 mov     eax, [ebp+arg_4]
.text$mn:00006BCF                 cmp     eax, [edx+8]
.text$mn:00006BD2                 jnb     short loc_6BE3
.text$mn:00006BD4
.text$mn:00006BD4 loc_6BD4:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)+5Dj
.text$mn:00006BD4                 mov     ecx, [ebp+var_10]
.text$mn:00006BD7                 mov     ecx, [ecx]      ; this
.text$mn:00006BD9                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006BDE                 mov     [ebp+var_10], eax
.text$mn:00006BE1                 jmp     short loc_6BFE
.text$mn:00006BE3 ; ---------------------------------------------------------------------------
.text$mn:00006BE3
.text$mn:00006BE3 loc_6BE3:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)+6Aj
.text$mn:00006BE3                 mov     edx, [ebp+var_10]
.text$mn:00006BE6                 mov     ecx, [edx]      ; this
.text$mn:00006BE8                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00006BED                 mov     eax, [ebp+var_10]
.text$mn:00006BF0                 mov     ecx, [eax]      ; this
.text$mn:00006BF2                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006BF7                 mov     ecx, [ebp+var_10]
.text$mn:00006BFA                 mov     edx, [eax]
.text$mn:00006BFC                 mov     [ecx], edx
.text$mn:00006BFE
.text$mn:00006BFE loc_6BFE:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)+79j
.text$mn:00006BFE                 jmp     short loc_6BB2
.text$mn:00006C00 ; ---------------------------------------------------------------------------
.text$mn:00006C00
.text$mn:00006C00 loc_6C00:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)+48j
.text$mn:00006C00                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)+50j
.text$mn:00006C00                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006C07                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006C0A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006C0F                 mov     ecx, [ebp+var_C]
.text$mn:00006C12                 mov     large fs:0, ecx
.text$mn:00006C19                 pop     ecx
.text$mn:00006C1A                 mov     esp, ebp
.text$mn:00006C1C                 pop     ebp
.text$mn:00006C1D                 retn    8
.text$mn:00006C1D ?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z endp
.text$mn:00006C1D
.text$mn:00006C1D _text$mn        ends
.text$mn:00006C1D
.text$x:00006C20 ; ===========================================================================
.text$x:00006C20
.text$x:00006C20 ; Segment type: Pure code
.text$x:00006C20 ; Segment permissions: Read/Execute
.text$x:00006C20 _text$x         segment para public 'CODE' use32
.text$x:00006C20                 assume cs:_text$x
.text$x:00006C20                 ;org 6C20h
.text$x:00006C20 ; COMDAT (pick associative to section at 6B68)
.text$x:00006C20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006C20
.text$x:00006C20 ; =============== S U B R O U T I N E =======================================
.text$x:00006C20
.text$x:00006C20
.text$x:00006C20 __unwindfunclet$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z$0 proc near
.text$x:00006C20                                         ; DATA XREF: .xdata$x:0000957Co
.text$x:00006C20                 lea     ecx, [ebp-18h]  ; this
.text$x:00006C23                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006C23 __unwindfunclet$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z$0 endp
.text$x:00006C23
.text$x:00006C28
.text$x:00006C28 ; =============== S U B R O U T I N E =======================================
.text$x:00006C28
.text$x:00006C28
.text$x:00006C28 __ehhandler$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z proc near
.text$x:00006C28                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)+5o
.text$x:00006C28
.text$x:00006C28 arg_4           = dword ptr  8
.text$x:00006C28
.text$x:00006C28                 mov     edx, [esp+arg_4]
.text$x:00006C2C                 lea     eax, [edx+0Ch]
.text$x:00006C2F                 mov     ecx, [edx-10h]
.text$x:00006C32                 xor     ecx, eax
.text$x:00006C34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C39                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z
.text$x:00006C3E                 jmp     ___CxxFrameHandler3
.text$x:00006C3E __ehhandler$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z endp
.text$x:00006C3E
.text$x:00006C3E ; ---------------------------------------------------------------------------
.text$x:00006C43                 align 4
.text$x:00006C43 _text$x         ends
.text$x:00006C43
.text$mn:00006C44 ; ===========================================================================
.text$mn:00006C44
.text$mn:00006C44 ; Segment type: Pure code
.text$mn:00006C44 ; Segment permissions: Read/Execute
.text$mn:00006C44 _text$mn        segment para public 'CODE' use32
.text$mn:00006C44                 assume cs:_text$mn
.text$mn:00006C44                 ;org 6C44h
.text$mn:00006C44 ; COMDAT (pick any)
.text$mn:00006C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C44
.text$mn:00006C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C44
.text$mn:00006C44 ; Attributes: bp-based frame
.text$mn:00006C44
.text$mn:00006C44 ; protected: void __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Orphan_range(class DockingCont * *, class DockingCont * *)const
.text$mn:00006C44                 public ?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z
.text$mn:00006C44 ?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z proc near
.text$mn:00006C44                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+66p
.text$mn:00006C44                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+CCp
.text$mn:00006C44
.text$mn:00006C44 var_18          = byte ptr -18h
.text$mn:00006C44 var_14          = dword ptr -14h
.text$mn:00006C44 var_10          = dword ptr -10h
.text$mn:00006C44 var_C           = dword ptr -0Ch
.text$mn:00006C44 var_4           = dword ptr -4
.text$mn:00006C44 arg_0           = dword ptr  8
.text$mn:00006C44 arg_4           = dword ptr  0Ch
.text$mn:00006C44
.text$mn:00006C44                 push    ebp
.text$mn:00006C45                 mov     ebp, esp
.text$mn:00006C47                 push    0FFFFFFFFh
.text$mn:00006C49                 push    offset __ehhandler$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z
.text$mn:00006C4E                 mov     eax, large fs:0
.text$mn:00006C54                 push    eax
.text$mn:00006C55                 sub     esp, 0Ch
.text$mn:00006C58                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006C5D                 xor     eax, ebp
.text$mn:00006C5F                 push    eax
.text$mn:00006C60                 lea     eax, [ebp+var_C]
.text$mn:00006C63                 mov     large fs:0, eax
.text$mn:00006C69                 mov     [ebp+var_14], ecx
.text$mn:00006C6C                 push    3               ; int
.text$mn:00006C6E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006C71                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006C76                 mov     [ebp+var_4], 0
.text$mn:00006C7D                 mov     ecx, [ebp+var_14] ; this
.text$mn:00006C80                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00006C85                 mov     [ebp+var_10], eax
.text$mn:00006C88                 cmp     [ebp+var_10], 0
.text$mn:00006C8C                 jz      short loc_6CDC
.text$mn:00006C8E
.text$mn:00006C8E loc_6C8E:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *):loc_6CDAj
.text$mn:00006C8E                 mov     eax, [ebp+var_10]
.text$mn:00006C91                 cmp     dword ptr [eax], 0
.text$mn:00006C94                 jz      short loc_6CDC
.text$mn:00006C96                 mov     ecx, [ebp+var_10]
.text$mn:00006C99                 mov     edx, [ecx]
.text$mn:00006C9B                 mov     eax, [edx+8]
.text$mn:00006C9E                 cmp     eax, [ebp+arg_0]
.text$mn:00006CA1                 jb      short loc_6CB0
.text$mn:00006CA3                 mov     ecx, [ebp+var_10]
.text$mn:00006CA6                 mov     edx, [ecx]
.text$mn:00006CA8                 mov     eax, [ebp+arg_4]
.text$mn:00006CAB                 cmp     eax, [edx+8]
.text$mn:00006CAE                 jnb     short loc_6CBF
.text$mn:00006CB0
.text$mn:00006CB0 loc_6CB0:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *)+5Dj
.text$mn:00006CB0                 mov     ecx, [ebp+var_10]
.text$mn:00006CB3                 mov     ecx, [ecx]      ; this
.text$mn:00006CB5                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006CBA                 mov     [ebp+var_10], eax
.text$mn:00006CBD                 jmp     short loc_6CDA
.text$mn:00006CBF ; ---------------------------------------------------------------------------
.text$mn:00006CBF
.text$mn:00006CBF loc_6CBF:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *)+6Aj
.text$mn:00006CBF                 mov     edx, [ebp+var_10]
.text$mn:00006CC2                 mov     ecx, [edx]      ; this
.text$mn:00006CC4                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00006CC9                 mov     eax, [ebp+var_10]
.text$mn:00006CCC                 mov     ecx, [eax]      ; this
.text$mn:00006CCE                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006CD3                 mov     ecx, [ebp+var_10]
.text$mn:00006CD6                 mov     edx, [eax]
.text$mn:00006CD8                 mov     [ecx], edx
.text$mn:00006CDA
.text$mn:00006CDA loc_6CDA:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *)+79j
.text$mn:00006CDA                 jmp     short loc_6C8E
.text$mn:00006CDC ; ---------------------------------------------------------------------------
.text$mn:00006CDC
.text$mn:00006CDC loc_6CDC:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *)+48j
.text$mn:00006CDC                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *)+50j
.text$mn:00006CDC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006CE3                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006CE6                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006CEB                 mov     ecx, [ebp+var_C]
.text$mn:00006CEE                 mov     large fs:0, ecx
.text$mn:00006CF5                 pop     ecx
.text$mn:00006CF6                 mov     esp, ebp
.text$mn:00006CF8                 pop     ebp
.text$mn:00006CF9                 retn    8
.text$mn:00006CF9 ?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z endp
.text$mn:00006CF9
.text$mn:00006CF9 _text$mn        ends
.text$mn:00006CF9
.text$x:00006CFC ; ===========================================================================
.text$x:00006CFC
.text$x:00006CFC ; Segment type: Pure code
.text$x:00006CFC ; Segment permissions: Read/Execute
.text$x:00006CFC _text$x         segment para public 'CODE' use32
.text$x:00006CFC                 assume cs:_text$x
.text$x:00006CFC                 ;org 6CFCh
.text$x:00006CFC ; COMDAT (pick associative to section at 6C44)
.text$x:00006CFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006CFC
.text$x:00006CFC ; =============== S U B R O U T I N E =======================================
.text$x:00006CFC
.text$x:00006CFC
.text$x:00006CFC __unwindfunclet$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z$0 proc near
.text$x:00006CFC                                         ; DATA XREF: .xdata$x:00009708o
.text$x:00006CFC                 lea     ecx, [ebp-18h]  ; this
.text$x:00006CFF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006CFF __unwindfunclet$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z$0 endp
.text$x:00006CFF
.text$x:00006D04
.text$x:00006D04 ; =============== S U B R O U T I N E =======================================
.text$x:00006D04
.text$x:00006D04
.text$x:00006D04 __ehhandler$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z proc near
.text$x:00006D04                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *)+5o
.text$x:00006D04
.text$x:00006D04 arg_4           = dword ptr  8
.text$x:00006D04
.text$x:00006D04                 mov     edx, [esp+arg_4]
.text$x:00006D08                 lea     eax, [edx+0Ch]
.text$x:00006D0B                 mov     ecx, [edx-10h]
.text$x:00006D0E                 xor     ecx, eax
.text$x:00006D10                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D15                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z
.text$x:00006D1A                 jmp     ___CxxFrameHandler3
.text$x:00006D1A __ehhandler$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z endp
.text$x:00006D1A
.text$x:00006D1A ; ---------------------------------------------------------------------------
.text$x:00006D1F                 align 10h
.text$x:00006D1F _text$x         ends
.text$x:00006D1F
.text$mn:00006D20 ; ===========================================================================
.text$mn:00006D20
.text$mn:00006D20 ; Segment type: Pure code
.text$mn:00006D20 ; Segment permissions: Read/Execute
.text$mn:00006D20 _text$mn        segment para public 'CODE' use32
.text$mn:00006D20                 assume cs:_text$mn
.text$mn:00006D20                 ;org 6D20h
.text$mn:00006D20 ; COMDAT (pick any)
.text$mn:00006D20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D20
.text$mn:00006D20 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D20
.text$mn:00006D20 ; Attributes: bp-based frame
.text$mn:00006D20
.text$mn:00006D20 ; protected: void __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::_Orphan_range(class DockingSplitter * *, class DockingSplitter * *)const
.text$mn:00006D20                 public ?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z
.text$mn:00006D20 ?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z proc near
.text$mn:00006D20                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+66p
.text$mn:00006D20                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+CCp
.text$mn:00006D20
.text$mn:00006D20 var_18          = byte ptr -18h
.text$mn:00006D20 var_14          = dword ptr -14h
.text$mn:00006D20 var_10          = dword ptr -10h
.text$mn:00006D20 var_C           = dword ptr -0Ch
.text$mn:00006D20 var_4           = dword ptr -4
.text$mn:00006D20 arg_0           = dword ptr  8
.text$mn:00006D20 arg_4           = dword ptr  0Ch
.text$mn:00006D20
.text$mn:00006D20                 push    ebp
.text$mn:00006D21                 mov     ebp, esp
.text$mn:00006D23                 push    0FFFFFFFFh
.text$mn:00006D25                 push    offset __ehhandler$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z
.text$mn:00006D2A                 mov     eax, large fs:0
.text$mn:00006D30                 push    eax
.text$mn:00006D31                 sub     esp, 0Ch
.text$mn:00006D34                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006D39                 xor     eax, ebp
.text$mn:00006D3B                 push    eax
.text$mn:00006D3C                 lea     eax, [ebp+var_C]
.text$mn:00006D3F                 mov     large fs:0, eax
.text$mn:00006D45                 mov     [ebp+var_14], ecx
.text$mn:00006D48                 push    3               ; int
.text$mn:00006D4A                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006D4D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00006D52                 mov     [ebp+var_4], 0
.text$mn:00006D59                 mov     ecx, [ebp+var_14] ; this
.text$mn:00006D5C                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00006D61                 mov     [ebp+var_10], eax
.text$mn:00006D64                 cmp     [ebp+var_10], 0
.text$mn:00006D68                 jz      short loc_6DB8
.text$mn:00006D6A
.text$mn:00006D6A loc_6D6A:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Orphan_range(DockingSplitter * *,DockingSplitter * *):loc_6DB6j
.text$mn:00006D6A                 mov     eax, [ebp+var_10]
.text$mn:00006D6D                 cmp     dword ptr [eax], 0
.text$mn:00006D70                 jz      short loc_6DB8
.text$mn:00006D72                 mov     ecx, [ebp+var_10]
.text$mn:00006D75                 mov     edx, [ecx]
.text$mn:00006D77                 mov     eax, [edx+8]
.text$mn:00006D7A                 cmp     eax, [ebp+arg_0]
.text$mn:00006D7D                 jb      short loc_6D8C
.text$mn:00006D7F                 mov     ecx, [ebp+var_10]
.text$mn:00006D82                 mov     edx, [ecx]
.text$mn:00006D84                 mov     eax, [ebp+arg_4]
.text$mn:00006D87                 cmp     eax, [edx+8]
.text$mn:00006D8A                 jnb     short loc_6D9B
.text$mn:00006D8C
.text$mn:00006D8C loc_6D8C:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Orphan_range(DockingSplitter * *,DockingSplitter * *)+5Dj
.text$mn:00006D8C                 mov     ecx, [ebp+var_10]
.text$mn:00006D8F                 mov     ecx, [ecx]      ; this
.text$mn:00006D91                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006D96                 mov     [ebp+var_10], eax
.text$mn:00006D99                 jmp     short loc_6DB6
.text$mn:00006D9B ; ---------------------------------------------------------------------------
.text$mn:00006D9B
.text$mn:00006D9B loc_6D9B:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Orphan_range(DockingSplitter * *,DockingSplitter * *)+6Aj
.text$mn:00006D9B                 mov     edx, [ebp+var_10]
.text$mn:00006D9E                 mov     ecx, [edx]      ; this
.text$mn:00006DA0                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00006DA5                 mov     eax, [ebp+var_10]
.text$mn:00006DA8                 mov     ecx, [eax]      ; this
.text$mn:00006DAA                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00006DAF                 mov     ecx, [ebp+var_10]
.text$mn:00006DB2                 mov     edx, [eax]
.text$mn:00006DB4                 mov     [ecx], edx
.text$mn:00006DB6
.text$mn:00006DB6 loc_6DB6:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Orphan_range(DockingSplitter * *,DockingSplitter * *)+79j
.text$mn:00006DB6                 jmp     short loc_6D6A
.text$mn:00006DB8 ; ---------------------------------------------------------------------------
.text$mn:00006DB8
.text$mn:00006DB8 loc_6DB8:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Orphan_range(DockingSplitter * *,DockingSplitter * *)+48j
.text$mn:00006DB8                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Orphan_range(DockingSplitter * *,DockingSplitter * *)+50j
.text$mn:00006DB8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006DBF                 lea     ecx, [ebp+var_18] ; this
.text$mn:00006DC2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006DC7                 mov     ecx, [ebp+var_C]
.text$mn:00006DCA                 mov     large fs:0, ecx
.text$mn:00006DD1                 pop     ecx
.text$mn:00006DD2                 mov     esp, ebp
.text$mn:00006DD4                 pop     ebp
.text$mn:00006DD5                 retn    8
.text$mn:00006DD5 ?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z endp
.text$mn:00006DD5
.text$mn:00006DD5 _text$mn        ends
.text$mn:00006DD5
.text$x:00006DD8 ; ===========================================================================
.text$x:00006DD8
.text$x:00006DD8 ; Segment type: Pure code
.text$x:00006DD8 ; Segment permissions: Read/Execute
.text$x:00006DD8 _text$x         segment para public 'CODE' use32
.text$x:00006DD8                 assume cs:_text$x
.text$x:00006DD8                 ;org 6DD8h
.text$x:00006DD8 ; COMDAT (pick associative to section at 6D20)
.text$x:00006DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006DD8
.text$x:00006DD8 ; =============== S U B R O U T I N E =======================================
.text$x:00006DD8
.text$x:00006DD8
.text$x:00006DD8 __unwindfunclet$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z$0 proc near
.text$x:00006DD8                                         ; DATA XREF: .xdata$x:00009894o
.text$x:00006DD8                 lea     ecx, [ebp-18h]  ; this
.text$x:00006DDB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006DDB __unwindfunclet$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z$0 endp
.text$x:00006DDB
.text$x:00006DE0
.text$x:00006DE0 ; =============== S U B R O U T I N E =======================================
.text$x:00006DE0
.text$x:00006DE0
.text$x:00006DE0 __ehhandler$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z proc near
.text$x:00006DE0                                         ; DATA XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Orphan_range(DockingSplitter * *,DockingSplitter * *)+5o
.text$x:00006DE0
.text$x:00006DE0 arg_4           = dword ptr  8
.text$x:00006DE0
.text$x:00006DE0                 mov     edx, [esp+arg_4]
.text$x:00006DE4                 lea     eax, [edx+0Ch]
.text$x:00006DE7                 mov     ecx, [edx-10h]
.text$x:00006DEA                 xor     ecx, eax
.text$x:00006DEC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006DF1                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z
.text$x:00006DF6                 jmp     ___CxxFrameHandler3
.text$x:00006DF6 __ehhandler$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z endp
.text$x:00006DF6
.text$x:00006DF6 ; ---------------------------------------------------------------------------
.text$x:00006DFB                 align 4
.text$x:00006DFB _text$x         ends
.text$x:00006DFB
.text$mn:00006DFC ; ===========================================================================
.text$mn:00006DFC
.text$mn:00006DFC ; Segment type: Pure code
.text$mn:00006DFC ; Segment permissions: Read/Execute
.text$mn:00006DFC _text$mn        segment para public 'CODE' use32
.text$mn:00006DFC                 assume cs:_text$mn
.text$mn:00006DFC                 ;org 6DFCh
.text$mn:00006DFC ; COMDAT (pick any)
.text$mn:00006DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006DFC
.text$mn:00006DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00006DFC
.text$mn:00006DFC ; Attributes: bp-based frame
.text$mn:00006DFC
.text$mn:00006DFC ; protected: void __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::_Reallocate(unsigned int)
.text$mn:00006DFC                 public ?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z
.text$mn:00006DFC ?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z proc near
.text$mn:00006DFC                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reserve(uint)+4Ep
.text$mn:00006DFC
.text$mn:00006DFC var_20          = dword ptr -20h
.text$mn:00006DFC var_1C          = dword ptr -1Ch
.text$mn:00006DFC var_18          = dword ptr -18h
.text$mn:00006DFC var_13          = byte ptr -13h
.text$mn:00006DFC var_11          = byte ptr -11h
.text$mn:00006DFC var_10          = dword ptr -10h
.text$mn:00006DFC var_C           = dword ptr -0Ch
.text$mn:00006DFC var_4           = dword ptr -4
.text$mn:00006DFC arg_0           = dword ptr  8
.text$mn:00006DFC
.text$mn:00006DFC ; FUNCTION CHUNK AT .text$mn:00006E92 SIZE 00000009 BYTES
.text$mn:00006DFC ; FUNCTION CHUNK AT .text$mn:00006EA2 SIZE 00000097 BYTES
.text$mn:00006DFC
.text$mn:00006DFC                 push    ebp
.text$mn:00006DFD                 mov     ebp, esp
.text$mn:00006DFF                 push    0FFFFFFFFh
.text$mn:00006E01                 push    offset __ehhandler$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z
.text$mn:00006E06                 mov     eax, large fs:0
.text$mn:00006E0C                 push    eax
.text$mn:00006E0D                 push    ecx
.text$mn:00006E0E                 sub     esp, 10h
.text$mn:00006E11                 push    ebx
.text$mn:00006E12                 push    esi
.text$mn:00006E13                 push    edi
.text$mn:00006E14                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006E19                 xor     eax, ebp
.text$mn:00006E1B                 push    eax
.text$mn:00006E1C                 lea     eax, [ebp+var_C]
.text$mn:00006E1F                 mov     large fs:0, eax
.text$mn:00006E25                 mov     [ebp+var_10], esp
.text$mn:00006E28                 mov     [ebp+var_18], ecx
.text$mn:00006E2B                 mov     eax, [ebp+arg_0]
.text$mn:00006E2E                 push    eax
.text$mn:00006E2F                 lea     ecx, [ebp+var_11]
.text$mn:00006E32                 push    ecx
.text$mn:00006E33                 mov     ecx, [ebp+var_18]
.text$mn:00006E36                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Getal(void)
.text$mn:00006E3B                 mov     ecx, eax
.text$mn:00006E3D                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEPAPAUHWND__@@I@Z ; std::_Wrap_alloc<std::allocator<HWND__ *>>::allocate(uint)
.text$mn:00006E42                 mov     [ebp+var_1C], eax
.text$mn:00006E45                 mov     [ebp+var_4], 0
.text$mn:00006E4C                 mov     edx, [ebp+var_1C]
.text$mn:00006E4F                 push    edx
.text$mn:00006E50                 mov     eax, [ebp+var_18]
.text$mn:00006E53                 mov     ecx, [eax+8]
.text$mn:00006E56                 push    ecx
.text$mn:00006E57                 mov     edx, [ebp+var_18]
.text$mn:00006E5A                 mov     eax, [edx+4]
.text$mn:00006E5D                 push    eax
.text$mn:00006E5E                 mov     ecx, [ebp+var_18]
.text$mn:00006E61                 call    ??$_Umove@PAPAUHWND__@@@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEPAPAUHWND__@@PAPAU2@00@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Umove<HWND__ * *>(HWND__ * *,HWND__ * *,HWND__ * *)
.text$mn:00006E66                 jmp     short loc_6E92
.text$mn:00006E66 ?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z endp
.text$mn:00006E66
.text$mn:00006E68
.text$mn:00006E68 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E68
.text$mn:00006E68 ; Attributes: noreturn
.text$mn:00006E68
.text$mn:00006E68 __catch$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00006E68                                         ; DATA XREF: .xdata$x:0000952Co
.text$mn:00006E68                 mov     ecx, [ebp+8]
.text$mn:00006E6B                 push    ecx             ; int
.text$mn:00006E6C                 mov     edx, [ebp-1Ch]
.text$mn:00006E6F                 push    edx             ; void *
.text$mn:00006E70                 lea     eax, [ebp-12h]
.text$mn:00006E73                 push    eax
.text$mn:00006E74                 mov     ecx, [ebp-18h]
.text$mn:00006E77                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Getal(void)
.text$mn:00006E7C                 mov     ecx, eax
.text$mn:00006E7E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@I@Z ; std::_Wrap_alloc<std::allocator<HWND__ *>>::deallocate(HWND__ * *,uint)
.text$mn:00006E83                 push    0
.text$mn:00006E85                 push    0
.text$mn:00006E87                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006E87 __catch$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00006E87
.text$mn:00006E8C ; ---------------------------------------------------------------------------
.text$mn:00006E8C                 mov     eax, offset $LN8_0
.text$mn:00006E91                 retn
.text$mn:00006E92 ; ---------------------------------------------------------------------------
.text$mn:00006E92 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z
.text$mn:00006E92
.text$mn:00006E92 loc_6E92:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reallocate(uint)+6Aj
.text$mn:00006E92                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006E99                 jmp     short loc_6EA2
.text$mn:00006E99 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z
.text$mn:00006E9B
.text$mn:00006E9B ; =============== S U B R O U T I N E =======================================
.text$mn:00006E9B
.text$mn:00006E9B
.text$mn:00006E9B $LN8_0          proc near               ; DATA XREF: .text$mn:00006E8Co
.text$mn:00006E9B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00006E9B $LN8_0          endp ; sp-analysis failed
.text$mn:00006E9B
.text$mn:00006EA2 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z
.text$mn:00006EA2
.text$mn:00006EA2 loc_6EA2:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reallocate(uint)+9Dj
.text$mn:00006EA2                 mov     ecx, [ebp+var_18]
.text$mn:00006EA5                 call    ?size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::size(void)
.text$mn:00006EAA                 mov     [ebp+var_20], eax
.text$mn:00006EAD                 mov     ecx, [ebp+var_18]
.text$mn:00006EB0                 cmp     dword ptr [ecx+4], 0
.text$mn:00006EB4                 jz      short loc_6EF6
.text$mn:00006EB6                 mov     edx, [ebp+var_18]
.text$mn:00006EB9                 mov     eax, [edx+8]
.text$mn:00006EBC                 push    eax
.text$mn:00006EBD                 mov     ecx, [ebp+var_18]
.text$mn:00006EC0                 mov     edx, [ecx+4]
.text$mn:00006EC3                 push    edx
.text$mn:00006EC4                 mov     ecx, [ebp+var_18]
.text$mn:00006EC7                 call    ?_Destroy@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXPAPAUHWND__@@0@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Destroy(HWND__ * *,HWND__ * *)
.text$mn:00006ECC                 mov     eax, [ebp+var_18]
.text$mn:00006ECF                 mov     ecx, [ebp+var_18]
.text$mn:00006ED2                 mov     edx, [eax+0Ch]
.text$mn:00006ED5                 sub     edx, [ecx+4]
.text$mn:00006ED8                 sar     edx, 2
.text$mn:00006EDB                 push    edx             ; int
.text$mn:00006EDC                 mov     eax, [ebp+var_18]
.text$mn:00006EDF                 mov     ecx, [eax+4]
.text$mn:00006EE2                 push    ecx             ; void *
.text$mn:00006EE3                 lea     edx, [ebp+var_13]
.text$mn:00006EE6                 push    edx
.text$mn:00006EE7                 mov     ecx, [ebp+var_18]
.text$mn:00006EEA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Getal(void)
.text$mn:00006EEF                 mov     ecx, eax
.text$mn:00006EF1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@I@Z ; std::_Wrap_alloc<std::allocator<HWND__ *>>::deallocate(HWND__ * *,uint)
.text$mn:00006EF6
.text$mn:00006EF6 loc_6EF6:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reallocate(uint)+B8j
.text$mn:00006EF6                 mov     ecx, [ebp+var_18] ; this
.text$mn:00006EF9                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006EFE                 mov     eax, [ebp+arg_0]
.text$mn:00006F01                 mov     ecx, [ebp+var_1C]
.text$mn:00006F04                 lea     edx, [ecx+eax*4]
.text$mn:00006F07                 mov     eax, [ebp+var_18]
.text$mn:00006F0A                 mov     [eax+0Ch], edx
.text$mn:00006F0D                 mov     ecx, [ebp+var_20]
.text$mn:00006F10                 mov     edx, [ebp+var_1C]
.text$mn:00006F13                 lea     eax, [edx+ecx*4]
.text$mn:00006F16                 mov     ecx, [ebp+var_18]
.text$mn:00006F19                 mov     [ecx+8], eax
.text$mn:00006F1C                 mov     edx, [ebp+var_18]
.text$mn:00006F1F                 mov     eax, [ebp+var_1C]
.text$mn:00006F22                 mov     [edx+4], eax
.text$mn:00006F25                 mov     ecx, [ebp+var_C]
.text$mn:00006F28                 mov     large fs:0, ecx
.text$mn:00006F2F                 pop     ecx
.text$mn:00006F30                 pop     edi
.text$mn:00006F31                 pop     esi
.text$mn:00006F32                 pop     ebx
.text$mn:00006F33                 mov     esp, ebp
.text$mn:00006F35                 pop     ebp
.text$mn:00006F36                 retn    4
.text$mn:00006F36 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z
.text$mn:00006F36 ; ---------------------------------------------------------------------------
.text$mn:00006F39                 align 4
.text$mn:00006F39 _text$mn        ends
.text$mn:00006F39
.text$x:00006F3C ; ===========================================================================
.text$x:00006F3C
.text$x:00006F3C ; Segment type: Pure code
.text$x:00006F3C ; Segment permissions: Read/Execute
.text$x:00006F3C _text$x         segment para public 'CODE' use32
.text$x:00006F3C                 assume cs:_text$x
.text$x:00006F3C                 ;org 6F3Ch
.text$x:00006F3C ; COMDAT (pick associative to section at 6DFC)
.text$x:00006F3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006F3C
.text$x:00006F3C ; =============== S U B R O U T I N E =======================================
.text$x:00006F3C
.text$x:00006F3C
.text$x:00006F3C __ehhandler$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z proc near
.text$x:00006F3C                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reallocate(uint)+5o
.text$x:00006F3C
.text$x:00006F3C arg_4           = dword ptr  8
.text$x:00006F3C
.text$x:00006F3C                 mov     edx, [esp+arg_4]
.text$x:00006F40                 lea     eax, [edx+0Ch]
.text$x:00006F43                 mov     ecx, [edx-24h]
.text$x:00006F46                 xor     ecx, eax
.text$x:00006F48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F4D                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z
.text$x:00006F52                 jmp     ___CxxFrameHandler3
.text$x:00006F52 __ehhandler$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z endp
.text$x:00006F52
.text$x:00006F52 ; ---------------------------------------------------------------------------
.text$x:00006F57                 align 4
.text$x:00006F57 _text$x         ends
.text$x:00006F57
.text$mn:00006F58 ; ===========================================================================
.text$mn:00006F58
.text$mn:00006F58 ; Segment type: Pure code
.text$mn:00006F58 ; Segment permissions: Read/Execute
.text$mn:00006F58 _text$mn        segment para public 'CODE' use32
.text$mn:00006F58                 assume cs:_text$mn
.text$mn:00006F58                 ;org 6F58h
.text$mn:00006F58 ; COMDAT (pick any)
.text$mn:00006F58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F58
.text$mn:00006F58 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F58
.text$mn:00006F58 ; Attributes: bp-based frame
.text$mn:00006F58
.text$mn:00006F58 ; protected: void __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Reallocate(unsigned int)
.text$mn:00006F58                 public ?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z
.text$mn:00006F58 ?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z proc near
.text$mn:00006F58                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reserve(uint)+4Ep
.text$mn:00006F58
.text$mn:00006F58 var_20          = dword ptr -20h
.text$mn:00006F58 var_1C          = dword ptr -1Ch
.text$mn:00006F58 var_18          = dword ptr -18h
.text$mn:00006F58 var_13          = byte ptr -13h
.text$mn:00006F58 var_11          = byte ptr -11h
.text$mn:00006F58 var_10          = dword ptr -10h
.text$mn:00006F58 var_C           = dword ptr -0Ch
.text$mn:00006F58 var_4           = dword ptr -4
.text$mn:00006F58 arg_0           = dword ptr  8
.text$mn:00006F58
.text$mn:00006F58 ; FUNCTION CHUNK AT .text$mn:00006FEE SIZE 00000009 BYTES
.text$mn:00006F58 ; FUNCTION CHUNK AT .text$mn:00006FFE SIZE 00000097 BYTES
.text$mn:00006F58
.text$mn:00006F58                 push    ebp
.text$mn:00006F59                 mov     ebp, esp
.text$mn:00006F5B                 push    0FFFFFFFFh
.text$mn:00006F5D                 push    offset __ehhandler$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z
.text$mn:00006F62                 mov     eax, large fs:0
.text$mn:00006F68                 push    eax
.text$mn:00006F69                 push    ecx
.text$mn:00006F6A                 sub     esp, 10h
.text$mn:00006F6D                 push    ebx
.text$mn:00006F6E                 push    esi
.text$mn:00006F6F                 push    edi
.text$mn:00006F70                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006F75                 xor     eax, ebp
.text$mn:00006F77                 push    eax
.text$mn:00006F78                 lea     eax, [ebp+var_C]
.text$mn:00006F7B                 mov     large fs:0, eax
.text$mn:00006F81                 mov     [ebp+var_10], esp
.text$mn:00006F84                 mov     [ebp+var_18], ecx
.text$mn:00006F87                 mov     eax, [ebp+arg_0]
.text$mn:00006F8A                 push    eax
.text$mn:00006F8B                 lea     ecx, [ebp+var_11]
.text$mn:00006F8E                 push    ecx
.text$mn:00006F8F                 mov     ecx, [ebp+var_18]
.text$mn:00006F92                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:00006F97                 mov     ecx, eax
.text$mn:00006F99                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEPAPAVDockingCont@@I@Z ; std::_Wrap_alloc<std::allocator<DockingCont *>>::allocate(uint)
.text$mn:00006F9E                 mov     [ebp+var_1C], eax
.text$mn:00006FA1                 mov     [ebp+var_4], 0
.text$mn:00006FA8                 mov     edx, [ebp+var_1C]
.text$mn:00006FAB                 push    edx
.text$mn:00006FAC                 mov     eax, [ebp+var_18]
.text$mn:00006FAF                 mov     ecx, [eax+8]
.text$mn:00006FB2                 push    ecx
.text$mn:00006FB3                 mov     edx, [ebp+var_18]
.text$mn:00006FB6                 mov     eax, [edx+4]
.text$mn:00006FB9                 push    eax
.text$mn:00006FBA                 mov     ecx, [ebp+var_18]
.text$mn:00006FBD                 call    ??$_Umove@PAPAVDockingCont@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@PAPAV2@00@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Umove<DockingCont * *>(DockingCont * *,DockingCont * *,DockingCont * *)
.text$mn:00006FC2                 jmp     short loc_6FEE
.text$mn:00006FC2 ?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z endp
.text$mn:00006FC2
.text$mn:00006FC4
.text$mn:00006FC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FC4
.text$mn:00006FC4 ; Attributes: noreturn
.text$mn:00006FC4
.text$mn:00006FC4 __catch$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00006FC4                                         ; DATA XREF: .xdata$x:000096B8o
.text$mn:00006FC4                 mov     ecx, [ebp+8]
.text$mn:00006FC7                 push    ecx             ; int
.text$mn:00006FC8                 mov     edx, [ebp-1Ch]
.text$mn:00006FCB                 push    edx             ; void *
.text$mn:00006FCC                 lea     eax, [ebp-12h]
.text$mn:00006FCF                 push    eax
.text$mn:00006FD0                 mov     ecx, [ebp-18h]
.text$mn:00006FD3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:00006FD8                 mov     ecx, eax
.text$mn:00006FDA                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@I@Z ; std::_Wrap_alloc<std::allocator<DockingCont *>>::deallocate(DockingCont * *,uint)
.text$mn:00006FDF                 push    0
.text$mn:00006FE1                 push    0
.text$mn:00006FE3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006FE3 __catch$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00006FE3
.text$mn:00006FE8 ; ---------------------------------------------------------------------------
.text$mn:00006FE8                 mov     eax, offset $LN8_1
.text$mn:00006FED                 retn
.text$mn:00006FEE ; ---------------------------------------------------------------------------
.text$mn:00006FEE ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z
.text$mn:00006FEE
.text$mn:00006FEE loc_6FEE:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reallocate(uint)+6Aj
.text$mn:00006FEE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006FF5                 jmp     short loc_6FFE
.text$mn:00006FF5 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z
.text$mn:00006FF7
.text$mn:00006FF7 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FF7
.text$mn:00006FF7
.text$mn:00006FF7 $LN8_1          proc near               ; DATA XREF: .text$mn:00006FE8o
.text$mn:00006FF7                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00006FF7 $LN8_1          endp ; sp-analysis failed
.text$mn:00006FF7
.text$mn:00006FFE ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z
.text$mn:00006FFE
.text$mn:00006FFE loc_6FFE:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reallocate(uint)+9Dj
.text$mn:00006FFE                 mov     ecx, [ebp+var_18]
.text$mn:00007001                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00007006                 mov     [ebp+var_20], eax
.text$mn:00007009                 mov     ecx, [ebp+var_18]
.text$mn:0000700C                 cmp     dword ptr [ecx+4], 0
.text$mn:00007010                 jz      short loc_7052
.text$mn:00007012                 mov     edx, [ebp+var_18]
.text$mn:00007015                 mov     eax, [edx+8]
.text$mn:00007018                 push    eax
.text$mn:00007019                 mov     ecx, [ebp+var_18]
.text$mn:0000701C                 mov     edx, [ecx+4]
.text$mn:0000701F                 push    edx
.text$mn:00007020                 mov     ecx, [ebp+var_18]
.text$mn:00007023                 call    ?_Destroy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXPAPAVDockingCont@@0@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Destroy(DockingCont * *,DockingCont * *)
.text$mn:00007028                 mov     eax, [ebp+var_18]
.text$mn:0000702B                 mov     ecx, [ebp+var_18]
.text$mn:0000702E                 mov     edx, [eax+0Ch]
.text$mn:00007031                 sub     edx, [ecx+4]
.text$mn:00007034                 sar     edx, 2
.text$mn:00007037                 push    edx             ; int
.text$mn:00007038                 mov     eax, [ebp+var_18]
.text$mn:0000703B                 mov     ecx, [eax+4]
.text$mn:0000703E                 push    ecx             ; void *
.text$mn:0000703F                 lea     edx, [ebp+var_13]
.text$mn:00007042                 push    edx
.text$mn:00007043                 mov     ecx, [ebp+var_18]
.text$mn:00007046                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:0000704B                 mov     ecx, eax
.text$mn:0000704D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@I@Z ; std::_Wrap_alloc<std::allocator<DockingCont *>>::deallocate(DockingCont * *,uint)
.text$mn:00007052
.text$mn:00007052 loc_7052:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reallocate(uint)+B8j
.text$mn:00007052                 mov     ecx, [ebp+var_18] ; this
.text$mn:00007055                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000705A                 mov     eax, [ebp+arg_0]
.text$mn:0000705D                 mov     ecx, [ebp+var_1C]
.text$mn:00007060                 lea     edx, [ecx+eax*4]
.text$mn:00007063                 mov     eax, [ebp+var_18]
.text$mn:00007066                 mov     [eax+0Ch], edx
.text$mn:00007069                 mov     ecx, [ebp+var_20]
.text$mn:0000706C                 mov     edx, [ebp+var_1C]
.text$mn:0000706F                 lea     eax, [edx+ecx*4]
.text$mn:00007072                 mov     ecx, [ebp+var_18]
.text$mn:00007075                 mov     [ecx+8], eax
.text$mn:00007078                 mov     edx, [ebp+var_18]
.text$mn:0000707B                 mov     eax, [ebp+var_1C]
.text$mn:0000707E                 mov     [edx+4], eax
.text$mn:00007081                 mov     ecx, [ebp+var_C]
.text$mn:00007084                 mov     large fs:0, ecx
.text$mn:0000708B                 pop     ecx
.text$mn:0000708C                 pop     edi
.text$mn:0000708D                 pop     esi
.text$mn:0000708E                 pop     ebx
.text$mn:0000708F                 mov     esp, ebp
.text$mn:00007091                 pop     ebp
.text$mn:00007092                 retn    4
.text$mn:00007092 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z
.text$mn:00007092 ; ---------------------------------------------------------------------------
.text$mn:00007095                 align 4
.text$mn:00007095 _text$mn        ends
.text$mn:00007095
.text$x:00007098 ; ===========================================================================
.text$x:00007098
.text$x:00007098 ; Segment type: Pure code
.text$x:00007098 ; Segment permissions: Read/Execute
.text$x:00007098 _text$x         segment para public 'CODE' use32
.text$x:00007098                 assume cs:_text$x
.text$x:00007098                 ;org 7098h
.text$x:00007098 ; COMDAT (pick associative to section at 6F58)
.text$x:00007098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007098
.text$x:00007098 ; =============== S U B R O U T I N E =======================================
.text$x:00007098
.text$x:00007098
.text$x:00007098 __ehhandler$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z proc near
.text$x:00007098                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reallocate(uint)+5o
.text$x:00007098
.text$x:00007098 arg_4           = dword ptr  8
.text$x:00007098
.text$x:00007098                 mov     edx, [esp+arg_4]
.text$x:0000709C                 lea     eax, [edx+0Ch]
.text$x:0000709F                 mov     ecx, [edx-24h]
.text$x:000070A2                 xor     ecx, eax
.text$x:000070A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000070A9                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z
.text$x:000070AE                 jmp     ___CxxFrameHandler3
.text$x:000070AE __ehhandler$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z endp
.text$x:000070AE
.text$x:000070AE ; ---------------------------------------------------------------------------
.text$x:000070B3                 align 4
.text$x:000070B3 _text$x         ends
.text$x:000070B3
.text$mn:000070B4 ; ===========================================================================
.text$mn:000070B4
.text$mn:000070B4 ; Segment type: Pure code
.text$mn:000070B4 ; Segment permissions: Read/Execute
.text$mn:000070B4 _text$mn        segment para public 'CODE' use32
.text$mn:000070B4                 assume cs:_text$mn
.text$mn:000070B4                 ;org 70B4h
.text$mn:000070B4 ; COMDAT (pick any)
.text$mn:000070B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070B4
.text$mn:000070B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000070B4
.text$mn:000070B4 ; Attributes: bp-based frame
.text$mn:000070B4
.text$mn:000070B4 ; protected: void __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::_Reallocate(unsigned int)
.text$mn:000070B4                 public ?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z
.text$mn:000070B4 ?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z proc near
.text$mn:000070B4                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reserve(uint)+4Ep
.text$mn:000070B4
.text$mn:000070B4 var_20          = dword ptr -20h
.text$mn:000070B4 var_1C          = dword ptr -1Ch
.text$mn:000070B4 var_18          = dword ptr -18h
.text$mn:000070B4 var_13          = byte ptr -13h
.text$mn:000070B4 var_11          = byte ptr -11h
.text$mn:000070B4 var_10          = dword ptr -10h
.text$mn:000070B4 var_C           = dword ptr -0Ch
.text$mn:000070B4 var_4           = dword ptr -4
.text$mn:000070B4 arg_0           = dword ptr  8
.text$mn:000070B4
.text$mn:000070B4 ; FUNCTION CHUNK AT .text$mn:0000714A SIZE 00000009 BYTES
.text$mn:000070B4 ; FUNCTION CHUNK AT .text$mn:0000715A SIZE 00000097 BYTES
.text$mn:000070B4
.text$mn:000070B4                 push    ebp
.text$mn:000070B5                 mov     ebp, esp
.text$mn:000070B7                 push    0FFFFFFFFh
.text$mn:000070B9                 push    offset __ehhandler$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z
.text$mn:000070BE                 mov     eax, large fs:0
.text$mn:000070C4                 push    eax
.text$mn:000070C5                 push    ecx
.text$mn:000070C6                 sub     esp, 10h
.text$mn:000070C9                 push    ebx
.text$mn:000070CA                 push    esi
.text$mn:000070CB                 push    edi
.text$mn:000070CC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000070D1                 xor     eax, ebp
.text$mn:000070D3                 push    eax
.text$mn:000070D4                 lea     eax, [ebp+var_C]
.text$mn:000070D7                 mov     large fs:0, eax
.text$mn:000070DD                 mov     [ebp+var_10], esp
.text$mn:000070E0                 mov     [ebp+var_18], ecx
.text$mn:000070E3                 mov     eax, [ebp+arg_0]
.text$mn:000070E6                 push    eax
.text$mn:000070E7                 lea     ecx, [ebp+var_11]
.text$mn:000070EA                 push    ecx
.text$mn:000070EB                 mov     ecx, [ebp+var_18]
.text$mn:000070EE                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Getal(void)
.text$mn:000070F3                 mov     ecx, eax
.text$mn:000070F5                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEPAPAVDockingSplitter@@I@Z ; std::_Wrap_alloc<std::allocator<DockingSplitter *>>::allocate(uint)
.text$mn:000070FA                 mov     [ebp+var_1C], eax
.text$mn:000070FD                 mov     [ebp+var_4], 0
.text$mn:00007104                 mov     edx, [ebp+var_1C]
.text$mn:00007107                 push    edx
.text$mn:00007108                 mov     eax, [ebp+var_18]
.text$mn:0000710B                 mov     ecx, [eax+8]
.text$mn:0000710E                 push    ecx
.text$mn:0000710F                 mov     edx, [ebp+var_18]
.text$mn:00007112                 mov     eax, [edx+4]
.text$mn:00007115                 push    eax
.text$mn:00007116                 mov     ecx, [ebp+var_18]
.text$mn:00007119                 call    ??$_Umove@PAPAVDockingSplitter@@@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEPAPAVDockingSplitter@@PAPAV2@00@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Umove<DockingSplitter * *>(DockingSplitter * *,DockingSplitter * *,DockingSplitter * *)
.text$mn:0000711E                 jmp     short loc_714A
.text$mn:0000711E ?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z endp
.text$mn:0000711E
.text$mn:00007120
.text$mn:00007120 ; =============== S U B R O U T I N E =======================================
.text$mn:00007120
.text$mn:00007120 ; Attributes: noreturn
.text$mn:00007120
.text$mn:00007120 __catch$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00007120                                         ; DATA XREF: .xdata$x:00009844o
.text$mn:00007120                 mov     ecx, [ebp+8]
.text$mn:00007123                 push    ecx             ; int
.text$mn:00007124                 mov     edx, [ebp-1Ch]
.text$mn:00007127                 push    edx             ; void *
.text$mn:00007128                 lea     eax, [ebp-12h]
.text$mn:0000712B                 push    eax
.text$mn:0000712C                 mov     ecx, [ebp-18h]
.text$mn:0000712F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Getal(void)
.text$mn:00007134                 mov     ecx, eax
.text$mn:00007136                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@I@Z ; std::_Wrap_alloc<std::allocator<DockingSplitter *>>::deallocate(DockingSplitter * *,uint)
.text$mn:0000713B                 push    0
.text$mn:0000713D                 push    0
.text$mn:0000713F                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000713F __catch$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:0000713F
.text$mn:00007144 ; ---------------------------------------------------------------------------
.text$mn:00007144                 mov     eax, offset $LN8_2
.text$mn:00007149                 retn
.text$mn:0000714A ; ---------------------------------------------------------------------------
.text$mn:0000714A ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z
.text$mn:0000714A
.text$mn:0000714A loc_714A:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reallocate(uint)+6Aj
.text$mn:0000714A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007151                 jmp     short loc_715A
.text$mn:00007151 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z
.text$mn:00007153
.text$mn:00007153 ; =============== S U B R O U T I N E =======================================
.text$mn:00007153
.text$mn:00007153
.text$mn:00007153 $LN8_2          proc near               ; DATA XREF: .text$mn:00007144o
.text$mn:00007153                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00007153 $LN8_2          endp ; sp-analysis failed
.text$mn:00007153
.text$mn:0000715A ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z
.text$mn:0000715A
.text$mn:0000715A loc_715A:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reallocate(uint)+9Dj
.text$mn:0000715A                 mov     ecx, [ebp+var_18]
.text$mn:0000715D                 call    ?size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::size(void)
.text$mn:00007162                 mov     [ebp+var_20], eax
.text$mn:00007165                 mov     ecx, [ebp+var_18]
.text$mn:00007168                 cmp     dword ptr [ecx+4], 0
.text$mn:0000716C                 jz      short loc_71AE
.text$mn:0000716E                 mov     edx, [ebp+var_18]
.text$mn:00007171                 mov     eax, [edx+8]
.text$mn:00007174                 push    eax
.text$mn:00007175                 mov     ecx, [ebp+var_18]
.text$mn:00007178                 mov     edx, [ecx+4]
.text$mn:0000717B                 push    edx
.text$mn:0000717C                 mov     ecx, [ebp+var_18]
.text$mn:0000717F                 call    ?_Destroy@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXPAPAVDockingSplitter@@0@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Destroy(DockingSplitter * *,DockingSplitter * *)
.text$mn:00007184                 mov     eax, [ebp+var_18]
.text$mn:00007187                 mov     ecx, [ebp+var_18]
.text$mn:0000718A                 mov     edx, [eax+0Ch]
.text$mn:0000718D                 sub     edx, [ecx+4]
.text$mn:00007190                 sar     edx, 2
.text$mn:00007193                 push    edx             ; int
.text$mn:00007194                 mov     eax, [ebp+var_18]
.text$mn:00007197                 mov     ecx, [eax+4]
.text$mn:0000719A                 push    ecx             ; void *
.text$mn:0000719B                 lea     edx, [ebp+var_13]
.text$mn:0000719E                 push    edx
.text$mn:0000719F                 mov     ecx, [ebp+var_18]
.text$mn:000071A2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Getal(void)
.text$mn:000071A7                 mov     ecx, eax
.text$mn:000071A9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@I@Z ; std::_Wrap_alloc<std::allocator<DockingSplitter *>>::deallocate(DockingSplitter * *,uint)
.text$mn:000071AE
.text$mn:000071AE loc_71AE:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reallocate(uint)+B8j
.text$mn:000071AE                 mov     ecx, [ebp+var_18] ; this
.text$mn:000071B1                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000071B6                 mov     eax, [ebp+arg_0]
.text$mn:000071B9                 mov     ecx, [ebp+var_1C]
.text$mn:000071BC                 lea     edx, [ecx+eax*4]
.text$mn:000071BF                 mov     eax, [ebp+var_18]
.text$mn:000071C2                 mov     [eax+0Ch], edx
.text$mn:000071C5                 mov     ecx, [ebp+var_20]
.text$mn:000071C8                 mov     edx, [ebp+var_1C]
.text$mn:000071CB                 lea     eax, [edx+ecx*4]
.text$mn:000071CE                 mov     ecx, [ebp+var_18]
.text$mn:000071D1                 mov     [ecx+8], eax
.text$mn:000071D4                 mov     edx, [ebp+var_18]
.text$mn:000071D7                 mov     eax, [ebp+var_1C]
.text$mn:000071DA                 mov     [edx+4], eax
.text$mn:000071DD                 mov     ecx, [ebp+var_C]
.text$mn:000071E0                 mov     large fs:0, ecx
.text$mn:000071E7                 pop     ecx
.text$mn:000071E8                 pop     edi
.text$mn:000071E9                 pop     esi
.text$mn:000071EA                 pop     ebx
.text$mn:000071EB                 mov     esp, ebp
.text$mn:000071ED                 pop     ebp
.text$mn:000071EE                 retn    4
.text$mn:000071EE ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z
.text$mn:000071EE ; ---------------------------------------------------------------------------
.text$mn:000071F1                 align 4
.text$mn:000071F1 _text$mn        ends
.text$mn:000071F1
.text$x:000071F4 ; ===========================================================================
.text$x:000071F4
.text$x:000071F4 ; Segment type: Pure code
.text$x:000071F4 ; Segment permissions: Read/Execute
.text$x:000071F4 _text$x         segment para public 'CODE' use32
.text$x:000071F4                 assume cs:_text$x
.text$x:000071F4                 ;org 71F4h
.text$x:000071F4 ; COMDAT (pick associative to section at 70B4)
.text$x:000071F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000071F4
.text$x:000071F4 ; =============== S U B R O U T I N E =======================================
.text$x:000071F4
.text$x:000071F4
.text$x:000071F4 __ehhandler$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z proc near
.text$x:000071F4                                         ; DATA XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reallocate(uint)+5o
.text$x:000071F4
.text$x:000071F4 arg_4           = dword ptr  8
.text$x:000071F4
.text$x:000071F4                 mov     edx, [esp+arg_4]
.text$x:000071F8                 lea     eax, [edx+0Ch]
.text$x:000071FB                 mov     ecx, [edx-24h]
.text$x:000071FE                 xor     ecx, eax
.text$x:00007200                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007205                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z
.text$x:0000720A                 jmp     ___CxxFrameHandler3
.text$x:0000720A __ehhandler$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z endp
.text$x:0000720A
.text$x:0000720A ; ---------------------------------------------------------------------------
.text$x:0000720F                 align 10h
.text$x:0000720F _text$x         ends
.text$x:0000720F
.text$mn:00007210 ; ===========================================================================
.text$mn:00007210
.text$mn:00007210 ; Segment type: Pure code
.text$mn:00007210 ; Segment permissions: Read/Execute
.text$mn:00007210 _text$mn        segment para public 'CODE' use32
.text$mn:00007210                 assume cs:_text$mn
.text$mn:00007210                 ;org 7210h
.text$mn:00007210 ; COMDAT (pick any)
.text$mn:00007210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007210
.text$mn:00007210 ; =============== S U B R O U T I N E =======================================
.text$mn:00007210
.text$mn:00007210 ; Attributes: bp-based frame
.text$mn:00007210
.text$mn:00007210 ; protected: void __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::_Reserve(unsigned int)
.text$mn:00007210                 public ?_Reserve@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z
.text$mn:00007210 ?_Reserve@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z proc near
.text$mn:00007210                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+50p
.text$mn:00007210                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+B6p
.text$mn:00007210
.text$mn:00007210 var_4           = dword ptr -4
.text$mn:00007210 arg_0           = dword ptr  8
.text$mn:00007210
.text$mn:00007210                 push    ebp
.text$mn:00007211                 mov     ebp, esp
.text$mn:00007213                 push    ecx
.text$mn:00007214                 push    esi
.text$mn:00007215                 mov     [ebp+var_4], ecx
.text$mn:00007218                 mov     ecx, [ebp+var_4]
.text$mn:0000721B                 call    ?_Unused_capacity@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Unused_capacity(void)
.text$mn:00007220                 cmp     eax, [ebp+arg_0]
.text$mn:00007223                 jnb     short loc_7263
.text$mn:00007225                 mov     ecx, [ebp+var_4]
.text$mn:00007228                 call    ?max_size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::max_size(void)
.text$mn:0000722D                 mov     esi, eax
.text$mn:0000722F                 mov     ecx, [ebp+var_4]
.text$mn:00007232                 call    ?size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::size(void)
.text$mn:00007237                 sub     esi, eax
.text$mn:00007239                 cmp     esi, [ebp+arg_0]
.text$mn:0000723C                 jnb     short loc_7246
.text$mn:0000723E                 mov     ecx, [ebp+var_4]
.text$mn:00007241                 call    ?_Xlen@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Xlen(void)
.text$mn:00007246
.text$mn:00007246 loc_7246:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reserve(uint)+2Cj
.text$mn:00007246                 mov     ecx, [ebp+var_4]
.text$mn:00007249                 call    ?size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ ; std::vector<HWND__ *,std::allocator<HWND__ *>>::size(void)
.text$mn:0000724E                 add     eax, [ebp+arg_0]
.text$mn:00007251                 push    eax
.text$mn:00007252                 mov     ecx, [ebp+var_4]
.text$mn:00007255                 call    ?_Grow_to@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEII@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Grow_to(uint)
.text$mn:0000725A                 push    eax
.text$mn:0000725B                 mov     ecx, [ebp+var_4]
.text$mn:0000725E                 call    ?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reallocate(uint)
.text$mn:00007263
.text$mn:00007263 loc_7263:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reserve(uint)+13j
.text$mn:00007263                 pop     esi
.text$mn:00007264                 mov     esp, ebp
.text$mn:00007266                 pop     ebp
.text$mn:00007267                 retn    4
.text$mn:00007267 ?_Reserve@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z endp
.text$mn:00007267
.text$mn:00007267 ; ---------------------------------------------------------------------------
.text$mn:0000726A                 align 4
.text$mn:0000726A _text$mn        ends
.text$mn:0000726A
.text$mn:0000726C ; ===========================================================================
.text$mn:0000726C
.text$mn:0000726C ; Segment type: Pure code
.text$mn:0000726C ; Segment permissions: Read/Execute
.text$mn:0000726C _text$mn        segment para public 'CODE' use32
.text$mn:0000726C                 assume cs:_text$mn
.text$mn:0000726C                 ;org 726Ch
.text$mn:0000726C ; COMDAT (pick any)
.text$mn:0000726C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000726C
.text$mn:0000726C ; =============== S U B R O U T I N E =======================================
.text$mn:0000726C
.text$mn:0000726C ; Attributes: bp-based frame
.text$mn:0000726C
.text$mn:0000726C ; protected: void __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Reserve(unsigned int)
.text$mn:0000726C                 public ?_Reserve@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z
.text$mn:0000726C ?_Reserve@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z proc near
.text$mn:0000726C                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+50p
.text$mn:0000726C                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+B6p
.text$mn:0000726C
.text$mn:0000726C var_4           = dword ptr -4
.text$mn:0000726C arg_0           = dword ptr  8
.text$mn:0000726C
.text$mn:0000726C                 push    ebp
.text$mn:0000726D                 mov     ebp, esp
.text$mn:0000726F                 push    ecx
.text$mn:00007270                 push    esi
.text$mn:00007271                 mov     [ebp+var_4], ecx
.text$mn:00007274                 mov     ecx, [ebp+var_4]
.text$mn:00007277                 call    ?_Unused_capacity@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Unused_capacity(void)
.text$mn:0000727C                 cmp     eax, [ebp+arg_0]
.text$mn:0000727F                 jnb     short loc_72BF
.text$mn:00007281                 mov     ecx, [ebp+var_4]
.text$mn:00007284                 call    ?max_size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::max_size(void)
.text$mn:00007289                 mov     esi, eax
.text$mn:0000728B                 mov     ecx, [ebp+var_4]
.text$mn:0000728E                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00007293                 sub     esi, eax
.text$mn:00007295                 cmp     esi, [ebp+arg_0]
.text$mn:00007298                 jnb     short loc_72A2
.text$mn:0000729A                 mov     ecx, [ebp+var_4]
.text$mn:0000729D                 call    ?_Xlen@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Xlen(void)
.text$mn:000072A2
.text$mn:000072A2 loc_72A2:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reserve(uint)+2Cj
.text$mn:000072A2                 mov     ecx, [ebp+var_4]
.text$mn:000072A5                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:000072AA                 add     eax, [ebp+arg_0]
.text$mn:000072AD                 push    eax
.text$mn:000072AE                 mov     ecx, [ebp+var_4]
.text$mn:000072B1                 call    ?_Grow_to@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEII@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Grow_to(uint)
.text$mn:000072B6                 push    eax
.text$mn:000072B7                 mov     ecx, [ebp+var_4]
.text$mn:000072BA                 call    ?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reallocate(uint)
.text$mn:000072BF
.text$mn:000072BF loc_72BF:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reserve(uint)+13j
.text$mn:000072BF                 pop     esi
.text$mn:000072C0                 mov     esp, ebp
.text$mn:000072C2                 pop     ebp
.text$mn:000072C3                 retn    4
.text$mn:000072C3 ?_Reserve@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z endp
.text$mn:000072C3
.text$mn:000072C3 ; ---------------------------------------------------------------------------
.text$mn:000072C6                 align 4
.text$mn:000072C6 _text$mn        ends
.text$mn:000072C6
.text$mn:000072C8 ; ===========================================================================
.text$mn:000072C8
.text$mn:000072C8 ; Segment type: Pure code
.text$mn:000072C8 ; Segment permissions: Read/Execute
.text$mn:000072C8 _text$mn        segment para public 'CODE' use32
.text$mn:000072C8                 assume cs:_text$mn
.text$mn:000072C8                 ;org 72C8h
.text$mn:000072C8 ; COMDAT (pick any)
.text$mn:000072C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000072C8
.text$mn:000072C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000072C8
.text$mn:000072C8 ; Attributes: bp-based frame
.text$mn:000072C8
.text$mn:000072C8 ; protected: void __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::_Reserve(unsigned int)
.text$mn:000072C8                 public ?_Reserve@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z
.text$mn:000072C8 ?_Reserve@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z proc near
.text$mn:000072C8                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+50p
.text$mn:000072C8                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+B6p
.text$mn:000072C8
.text$mn:000072C8 var_4           = dword ptr -4
.text$mn:000072C8 arg_0           = dword ptr  8
.text$mn:000072C8
.text$mn:000072C8                 push    ebp
.text$mn:000072C9                 mov     ebp, esp
.text$mn:000072CB                 push    ecx
.text$mn:000072CC                 push    esi
.text$mn:000072CD                 mov     [ebp+var_4], ecx
.text$mn:000072D0                 mov     ecx, [ebp+var_4]
.text$mn:000072D3                 call    ?_Unused_capacity@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Unused_capacity(void)
.text$mn:000072D8                 cmp     eax, [ebp+arg_0]
.text$mn:000072DB                 jnb     short loc_731B
.text$mn:000072DD                 mov     ecx, [ebp+var_4]
.text$mn:000072E0                 call    ?max_size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::max_size(void)
.text$mn:000072E5                 mov     esi, eax
.text$mn:000072E7                 mov     ecx, [ebp+var_4]
.text$mn:000072EA                 call    ?size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::size(void)
.text$mn:000072EF                 sub     esi, eax
.text$mn:000072F1                 cmp     esi, [ebp+arg_0]
.text$mn:000072F4                 jnb     short loc_72FE
.text$mn:000072F6                 mov     ecx, [ebp+var_4]
.text$mn:000072F9                 call    ?_Xlen@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXXZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Xlen(void)
.text$mn:000072FE
.text$mn:000072FE loc_72FE:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reserve(uint)+2Cj
.text$mn:000072FE                 mov     ecx, [ebp+var_4]
.text$mn:00007301                 call    ?size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::size(void)
.text$mn:00007306                 add     eax, [ebp+arg_0]
.text$mn:00007309                 push    eax
.text$mn:0000730A                 mov     ecx, [ebp+var_4]
.text$mn:0000730D                 call    ?_Grow_to@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEII@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Grow_to(uint)
.text$mn:00007312                 push    eax
.text$mn:00007313                 mov     ecx, [ebp+var_4]
.text$mn:00007316                 call    ?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reallocate(uint)
.text$mn:0000731B
.text$mn:0000731B loc_731B:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reserve(uint)+13j
.text$mn:0000731B                 pop     esi
.text$mn:0000731C                 mov     esp, ebp
.text$mn:0000731E                 pop     ebp
.text$mn:0000731F                 retn    4
.text$mn:0000731F ?_Reserve@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z endp
.text$mn:0000731F
.text$mn:0000731F ; ---------------------------------------------------------------------------
.text$mn:00007322                 align 4
.text$mn:00007322 _text$mn        ends
.text$mn:00007322
.text$mn:00007324 ; ===========================================================================
.text$mn:00007324
.text$mn:00007324 ; Segment type: Pure code
.text$mn:00007324 ; Segment permissions: Read/Execute
.text$mn:00007324 _text$mn        segment para public 'CODE' use32
.text$mn:00007324                 assume cs:_text$mn
.text$mn:00007324                 ;org 7324h
.text$mn:00007324 ; COMDAT (pick any)
.text$mn:00007324                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007324
.text$mn:00007324 ; =============== S U B R O U T I N E =======================================
.text$mn:00007324
.text$mn:00007324 ; Attributes: bp-based frame
.text$mn:00007324
.text$mn:00007324 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00007324                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00007324 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00007324                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00007324                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00007324
.text$mn:00007324 var_C           = dword ptr -0Ch
.text$mn:00007324 var_8           = dword ptr -8
.text$mn:00007324 var_2           = byte ptr -2
.text$mn:00007324 var_1           = byte ptr -1
.text$mn:00007324 arg_0           = byte ptr  8
.text$mn:00007324 Size            = dword ptr  0Ch
.text$mn:00007324
.text$mn:00007324                 push    ebp
.text$mn:00007325                 mov     ebp, esp
.text$mn:00007327                 sub     esp, 0Ch
.text$mn:0000732A                 mov     [ebp+var_8], ecx
.text$mn:0000732D                 movzx   eax, [ebp+arg_0]
.text$mn:00007331                 test    eax, eax
.text$mn:00007333                 jnz     short loc_7337
.text$mn:00007335                 jmp     short loc_73AA
.text$mn:00007337 ; ---------------------------------------------------------------------------
.text$mn:00007337
.text$mn:00007337 loc_7337:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00007337                 mov     ecx, [ebp+var_8]
.text$mn:0000733A                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000733E                 jb      short loc_73AA
.text$mn:00007340                 mov     edx, [ebp+var_8]
.text$mn:00007343                 mov     eax, [edx+4]
.text$mn:00007346                 mov     [ebp+var_C], eax
.text$mn:00007349                 mov     ecx, [ebp+var_8]
.text$mn:0000734C                 add     ecx, 4
.text$mn:0000734F                 push    ecx
.text$mn:00007350                 lea     edx, [ebp+var_1]
.text$mn:00007353                 push    edx
.text$mn:00007354                 mov     ecx, [ebp+var_8]
.text$mn:00007357                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000735C                 mov     ecx, eax
.text$mn:0000735E                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00007363                 cmp     [ebp+Size], 0
.text$mn:00007367                 jbe     short loc_7389
.text$mn:00007369                 mov     eax, [ebp+Size]
.text$mn:0000736C                 push    eax             ; Size
.text$mn:0000736D                 mov     ecx, [ebp+var_C]
.text$mn:00007370                 push    ecx
.text$mn:00007371                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00007376                 add     esp, 4
.text$mn:00007379                 push    eax             ; Src
.text$mn:0000737A                 mov     edx, [ebp+var_8]
.text$mn:0000737D                 add     edx, 4
.text$mn:00007380                 push    edx             ; Dst
.text$mn:00007381                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007386                 add     esp, 0Ch
.text$mn:00007389
.text$mn:00007389 loc_7389:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00007389                 mov     eax, [ebp+var_8]
.text$mn:0000738C                 mov     ecx, [eax+18h]
.text$mn:0000738F                 add     ecx, 1
.text$mn:00007392                 push    ecx             ; int
.text$mn:00007393                 mov     edx, [ebp+var_C]
.text$mn:00007396                 push    edx             ; void *
.text$mn:00007397                 lea     eax, [ebp+var_2]
.text$mn:0000739A                 push    eax
.text$mn:0000739B                 mov     ecx, [ebp+var_8]
.text$mn:0000739E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000073A3                 mov     ecx, eax
.text$mn:000073A5                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000073AA
.text$mn:000073AA loc_73AA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000073AA                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000073AA                 mov     ecx, [ebp+var_8]
.text$mn:000073AD                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000073B4                 mov     edx, [ebp+Size]
.text$mn:000073B7                 push    edx
.text$mn:000073B8                 mov     ecx, [ebp+var_8]
.text$mn:000073BB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000073C0                 mov     esp, ebp
.text$mn:000073C2                 pop     ebp
.text$mn:000073C3                 retn    8
.text$mn:000073C3 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000073C3
.text$mn:000073C3 ; ---------------------------------------------------------------------------
.text$mn:000073C6                 align 4
.text$mn:000073C6 _text$mn        ends
.text$mn:000073C6
.text$mn:000073C8 ; ===========================================================================
.text$mn:000073C8
.text$mn:000073C8 ; Segment type: Pure code
.text$mn:000073C8 ; Segment permissions: Read/Execute
.text$mn:000073C8 _text$mn        segment para public 'CODE' use32
.text$mn:000073C8                 assume cs:_text$mn
.text$mn:000073C8                 ;org 73C8h
.text$mn:000073C8 ; COMDAT (pick any)
.text$mn:000073C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000073C8
.text$mn:000073C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000073C8
.text$mn:000073C8 ; Attributes: bp-based frame
.text$mn:000073C8
.text$mn:000073C8 ; protected: void __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::_Tidy(void)
.text$mn:000073C8                 public ?_Tidy@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXXZ
.text$mn:000073C8 ?_Tidy@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXXZ proc near
.text$mn:000073C8                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::~vector<HWND__ *,std::allocator<HWND__ *>>(void)+30p
.text$mn:000073C8
.text$mn:000073C8 var_8           = dword ptr -8
.text$mn:000073C8 var_1           = byte ptr -1
.text$mn:000073C8
.text$mn:000073C8                 push    ebp
.text$mn:000073C9                 mov     ebp, esp
.text$mn:000073CB                 sub     esp, 8
.text$mn:000073CE                 mov     [ebp+var_8], ecx
.text$mn:000073D1                 mov     eax, [ebp+var_8]
.text$mn:000073D4                 cmp     dword ptr [eax+4], 0
.text$mn:000073D8                 jz      short loc_7440
.text$mn:000073DA                 mov     ecx, [ebp+var_8] ; this
.text$mn:000073DD                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000073E2                 mov     ecx, [ebp+var_8]
.text$mn:000073E5                 mov     edx, [ecx+8]
.text$mn:000073E8                 push    edx
.text$mn:000073E9                 mov     eax, [ebp+var_8]
.text$mn:000073EC                 mov     ecx, [eax+4]
.text$mn:000073EF                 push    ecx
.text$mn:000073F0                 mov     ecx, [ebp+var_8]
.text$mn:000073F3                 call    ?_Destroy@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXPAPAUHWND__@@0@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Destroy(HWND__ * *,HWND__ * *)
.text$mn:000073F8                 mov     edx, [ebp+var_8]
.text$mn:000073FB                 mov     eax, [ebp+var_8]
.text$mn:000073FE                 mov     ecx, [edx+0Ch]
.text$mn:00007401                 sub     ecx, [eax+4]
.text$mn:00007404                 sar     ecx, 2
.text$mn:00007407                 push    ecx             ; int
.text$mn:00007408                 mov     edx, [ebp+var_8]
.text$mn:0000740B                 mov     eax, [edx+4]
.text$mn:0000740E                 push    eax             ; void *
.text$mn:0000740F                 lea     ecx, [ebp+var_1]
.text$mn:00007412                 push    ecx
.text$mn:00007413                 mov     ecx, [ebp+var_8]
.text$mn:00007416                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Getal(void)
.text$mn:0000741B                 mov     ecx, eax
.text$mn:0000741D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@I@Z ; std::_Wrap_alloc<std::allocator<HWND__ *>>::deallocate(HWND__ * *,uint)
.text$mn:00007422                 mov     edx, [ebp+var_8]
.text$mn:00007425                 mov     dword ptr [edx+4], 0
.text$mn:0000742C                 mov     eax, [ebp+var_8]
.text$mn:0000742F                 mov     dword ptr [eax+8], 0
.text$mn:00007436                 mov     ecx, [ebp+var_8]
.text$mn:00007439                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00007440
.text$mn:00007440 loc_7440:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Tidy(void)+10j
.text$mn:00007440                 mov     esp, ebp
.text$mn:00007442                 pop     ebp
.text$mn:00007443                 retn
.text$mn:00007443 ?_Tidy@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXXZ endp
.text$mn:00007443
.text$mn:00007443 _text$mn        ends
.text$mn:00007443
.text$mn:00007444 ; ===========================================================================
.text$mn:00007444
.text$mn:00007444 ; Segment type: Pure code
.text$mn:00007444 ; Segment permissions: Read/Execute
.text$mn:00007444 _text$mn        segment para public 'CODE' use32
.text$mn:00007444                 assume cs:_text$mn
.text$mn:00007444                 ;org 7444h
.text$mn:00007444 ; COMDAT (pick any)
.text$mn:00007444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007444
.text$mn:00007444 ; =============== S U B R O U T I N E =======================================
.text$mn:00007444
.text$mn:00007444 ; Attributes: bp-based frame
.text$mn:00007444
.text$mn:00007444 ; protected: void __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::_Tidy(void)
.text$mn:00007444                 public ?_Tidy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEXXZ
.text$mn:00007444 ?_Tidy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEXXZ proc near
.text$mn:00007444                                         ; CODE XREF: __catch$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$0+3p
.text$mn:00007444                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::~vector<tTbData *,std::allocator<tTbData *>>(void)+30p
.text$mn:00007444
.text$mn:00007444 var_8           = dword ptr -8
.text$mn:00007444 var_1           = byte ptr -1
.text$mn:00007444
.text$mn:00007444                 push    ebp
.text$mn:00007445                 mov     ebp, esp
.text$mn:00007447                 sub     esp, 8
.text$mn:0000744A                 mov     [ebp+var_8], ecx
.text$mn:0000744D                 mov     eax, [ebp+var_8]
.text$mn:00007450                 cmp     dword ptr [eax+4], 0
.text$mn:00007454                 jz      short loc_74BC
.text$mn:00007456                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007459                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000745E                 mov     ecx, [ebp+var_8]
.text$mn:00007461                 mov     edx, [ecx+8]
.text$mn:00007464                 push    edx
.text$mn:00007465                 mov     eax, [ebp+var_8]
.text$mn:00007468                 mov     ecx, [eax+4]
.text$mn:0000746B                 push    ecx
.text$mn:0000746C                 mov     ecx, [ebp+var_8]
.text$mn:0000746F                 call    ?_Destroy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEXPAPAUtTbData@@0@Z ; std::vector<tTbData *,std::allocator<tTbData *>>::_Destroy(tTbData * *,tTbData * *)
.text$mn:00007474                 mov     edx, [ebp+var_8]
.text$mn:00007477                 mov     eax, [ebp+var_8]
.text$mn:0000747A                 mov     ecx, [edx+0Ch]
.text$mn:0000747D                 sub     ecx, [eax+4]
.text$mn:00007480                 sar     ecx, 2
.text$mn:00007483                 push    ecx             ; int
.text$mn:00007484                 mov     edx, [ebp+var_8]
.text$mn:00007487                 mov     eax, [edx+4]
.text$mn:0000748A                 push    eax             ; void *
.text$mn:0000748B                 lea     ecx, [ebp+var_1]
.text$mn:0000748E                 push    ecx
.text$mn:0000748F                 mov     ecx, [ebp+var_8]
.text$mn:00007492                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Getal(void)
.text$mn:00007497                 mov     ecx, eax
.text$mn:00007499                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAEXPAPAUtTbData@@I@Z ; std::_Wrap_alloc<std::allocator<tTbData *>>::deallocate(tTbData * *,uint)
.text$mn:0000749E                 mov     edx, [ebp+var_8]
.text$mn:000074A1                 mov     dword ptr [edx+4], 0
.text$mn:000074A8                 mov     eax, [ebp+var_8]
.text$mn:000074AB                 mov     dword ptr [eax+8], 0
.text$mn:000074B2                 mov     ecx, [ebp+var_8]
.text$mn:000074B5                 mov     dword ptr [ecx+0Ch], 0
.text$mn:000074BC
.text$mn:000074BC loc_74BC:                               ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Tidy(void)+10j
.text$mn:000074BC                 mov     esp, ebp
.text$mn:000074BE                 pop     ebp
.text$mn:000074BF                 retn
.text$mn:000074BF ?_Tidy@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEXXZ endp
.text$mn:000074BF
.text$mn:000074BF _text$mn        ends
.text$mn:000074BF
.text$mn:000074C0 ; ===========================================================================
.text$mn:000074C0
.text$mn:000074C0 ; Segment type: Pure code
.text$mn:000074C0 ; Segment permissions: Read/Execute
.text$mn:000074C0 _text$mn        segment para public 'CODE' use32
.text$mn:000074C0                 assume cs:_text$mn
.text$mn:000074C0                 ;org 74C0h
.text$mn:000074C0 ; COMDAT (pick any)
.text$mn:000074C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074C0
.text$mn:000074C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000074C0
.text$mn:000074C0 ; Attributes: bp-based frame
.text$mn:000074C0
.text$mn:000074C0 ; protected: void __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Tidy(void)
.text$mn:000074C0                 public ?_Tidy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXXZ
.text$mn:000074C0 ?_Tidy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXXZ proc near
.text$mn:000074C0                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)+30p
.text$mn:000074C0
.text$mn:000074C0 var_8           = dword ptr -8
.text$mn:000074C0 var_1           = byte ptr -1
.text$mn:000074C0
.text$mn:000074C0                 push    ebp
.text$mn:000074C1                 mov     ebp, esp
.text$mn:000074C3                 sub     esp, 8
.text$mn:000074C6                 mov     [ebp+var_8], ecx
.text$mn:000074C9                 mov     eax, [ebp+var_8]
.text$mn:000074CC                 cmp     dword ptr [eax+4], 0
.text$mn:000074D0                 jz      short loc_7538
.text$mn:000074D2                 mov     ecx, [ebp+var_8] ; this
.text$mn:000074D5                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000074DA                 mov     ecx, [ebp+var_8]
.text$mn:000074DD                 mov     edx, [ecx+8]
.text$mn:000074E0                 push    edx
.text$mn:000074E1                 mov     eax, [ebp+var_8]
.text$mn:000074E4                 mov     ecx, [eax+4]
.text$mn:000074E7                 push    ecx
.text$mn:000074E8                 mov     ecx, [ebp+var_8]
.text$mn:000074EB                 call    ?_Destroy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXPAPAVDockingCont@@0@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Destroy(DockingCont * *,DockingCont * *)
.text$mn:000074F0                 mov     edx, [ebp+var_8]
.text$mn:000074F3                 mov     eax, [ebp+var_8]
.text$mn:000074F6                 mov     ecx, [edx+0Ch]
.text$mn:000074F9                 sub     ecx, [eax+4]
.text$mn:000074FC                 sar     ecx, 2
.text$mn:000074FF                 push    ecx             ; int
.text$mn:00007500                 mov     edx, [ebp+var_8]
.text$mn:00007503                 mov     eax, [edx+4]
.text$mn:00007506                 push    eax             ; void *
.text$mn:00007507                 lea     ecx, [ebp+var_1]
.text$mn:0000750A                 push    ecx
.text$mn:0000750B                 mov     ecx, [ebp+var_8]
.text$mn:0000750E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:00007513                 mov     ecx, eax
.text$mn:00007515                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@I@Z ; std::_Wrap_alloc<std::allocator<DockingCont *>>::deallocate(DockingCont * *,uint)
.text$mn:0000751A                 mov     edx, [ebp+var_8]
.text$mn:0000751D                 mov     dword ptr [edx+4], 0
.text$mn:00007524                 mov     eax, [ebp+var_8]
.text$mn:00007527                 mov     dword ptr [eax+8], 0
.text$mn:0000752E                 mov     ecx, [ebp+var_8]
.text$mn:00007531                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00007538
.text$mn:00007538 loc_7538:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Tidy(void)+10j
.text$mn:00007538                 mov     esp, ebp
.text$mn:0000753A                 pop     ebp
.text$mn:0000753B                 retn
.text$mn:0000753B ?_Tidy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXXZ endp
.text$mn:0000753B
.text$mn:0000753B _text$mn        ends
.text$mn:0000753B
.text$mn:0000753C ; ===========================================================================
.text$mn:0000753C
.text$mn:0000753C ; Segment type: Pure code
.text$mn:0000753C ; Segment permissions: Read/Execute
.text$mn:0000753C _text$mn        segment para public 'CODE' use32
.text$mn:0000753C                 assume cs:_text$mn
.text$mn:0000753C                 ;org 753Ch
.text$mn:0000753C ; COMDAT (pick any)
.text$mn:0000753C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000753C
.text$mn:0000753C ; =============== S U B R O U T I N E =======================================
.text$mn:0000753C
.text$mn:0000753C ; Attributes: bp-based frame
.text$mn:0000753C
.text$mn:0000753C ; protected: void __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::_Tidy(void)
.text$mn:0000753C                 public ?_Tidy@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXXZ
.text$mn:0000753C ?_Tidy@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXXZ proc near
.text$mn:0000753C                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::~vector<DockingSplitter *,std::allocator<DockingSplitter *>>(void)+30p
.text$mn:0000753C
.text$mn:0000753C var_8           = dword ptr -8
.text$mn:0000753C var_1           = byte ptr -1
.text$mn:0000753C
.text$mn:0000753C                 push    ebp
.text$mn:0000753D                 mov     ebp, esp
.text$mn:0000753F                 sub     esp, 8
.text$mn:00007542                 mov     [ebp+var_8], ecx
.text$mn:00007545                 mov     eax, [ebp+var_8]
.text$mn:00007548                 cmp     dword ptr [eax+4], 0
.text$mn:0000754C                 jz      short loc_75B4
.text$mn:0000754E                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007551                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00007556                 mov     ecx, [ebp+var_8]
.text$mn:00007559                 mov     edx, [ecx+8]
.text$mn:0000755C                 push    edx
.text$mn:0000755D                 mov     eax, [ebp+var_8]
.text$mn:00007560                 mov     ecx, [eax+4]
.text$mn:00007563                 push    ecx
.text$mn:00007564                 mov     ecx, [ebp+var_8]
.text$mn:00007567                 call    ?_Destroy@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXPAPAVDockingSplitter@@0@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Destroy(DockingSplitter * *,DockingSplitter * *)
.text$mn:0000756C                 mov     edx, [ebp+var_8]
.text$mn:0000756F                 mov     eax, [ebp+var_8]
.text$mn:00007572                 mov     ecx, [edx+0Ch]
.text$mn:00007575                 sub     ecx, [eax+4]
.text$mn:00007578                 sar     ecx, 2
.text$mn:0000757B                 push    ecx             ; int
.text$mn:0000757C                 mov     edx, [ebp+var_8]
.text$mn:0000757F                 mov     eax, [edx+4]
.text$mn:00007582                 push    eax             ; void *
.text$mn:00007583                 lea     ecx, [ebp+var_1]
.text$mn:00007586                 push    ecx
.text$mn:00007587                 mov     ecx, [ebp+var_8]
.text$mn:0000758A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Getal(void)
.text$mn:0000758F                 mov     ecx, eax
.text$mn:00007591                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@I@Z ; std::_Wrap_alloc<std::allocator<DockingSplitter *>>::deallocate(DockingSplitter * *,uint)
.text$mn:00007596                 mov     edx, [ebp+var_8]
.text$mn:00007599                 mov     dword ptr [edx+4], 0
.text$mn:000075A0                 mov     eax, [ebp+var_8]
.text$mn:000075A3                 mov     dword ptr [eax+8], 0
.text$mn:000075AA                 mov     ecx, [ebp+var_8]
.text$mn:000075AD                 mov     dword ptr [ecx+0Ch], 0
.text$mn:000075B4
.text$mn:000075B4 loc_75B4:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Tidy(void)+10j
.text$mn:000075B4                 mov     esp, ebp
.text$mn:000075B6                 pop     ebp
.text$mn:000075B7                 retn
.text$mn:000075B7 ?_Tidy@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXXZ endp
.text$mn:000075B7
.text$mn:000075B7 _text$mn        ends
.text$mn:000075B7
.text$mn:000075B8 ; ===========================================================================
.text$mn:000075B8
.text$mn:000075B8 ; Segment type: Pure code
.text$mn:000075B8 ; Segment permissions: Read/Execute
.text$mn:000075B8 _text$mn        segment para public 'CODE' use32
.text$mn:000075B8                 assume cs:_text$mn
.text$mn:000075B8                 ;org 75B8h
.text$mn:000075B8 ; COMDAT (pick any)
.text$mn:000075B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075B8
.text$mn:000075B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000075B8
.text$mn:000075B8 ; Attributes: bp-based frame
.text$mn:000075B8
.text$mn:000075B8 ; public: struct tTbData * const * __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>>::_Unchecked(void)const
.text$mn:000075B8                 public ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QBEPBQAUtTbData@@XZ
.text$mn:000075B8 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QBEPBQAUtTbData@@XZ proc near
.text$mn:000075B8                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<tTbData *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>)+2Dp
.text$mn:000075B8
.text$mn:000075B8 var_4           = dword ptr -4
.text$mn:000075B8
.text$mn:000075B8                 push    ebp
.text$mn:000075B9                 mov     ebp, esp
.text$mn:000075BB                 push    ecx
.text$mn:000075BC                 mov     [ebp+var_4], ecx
.text$mn:000075BF                 mov     eax, [ebp+var_4]
.text$mn:000075C2                 mov     eax, [eax+8]
.text$mn:000075C5                 mov     esp, ebp
.text$mn:000075C7                 pop     ebp
.text$mn:000075C8                 retn
.text$mn:000075C8 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QBEPBQAUtTbData@@XZ endp
.text$mn:000075C8
.text$mn:000075C8 ; ---------------------------------------------------------------------------
.text$mn:000075C9                 align 4
.text$mn:000075C9 _text$mn        ends
.text$mn:000075C9
.text$mn:000075CC ; ===========================================================================
.text$mn:000075CC
.text$mn:000075CC ; Segment type: Pure code
.text$mn:000075CC ; Segment permissions: Read/Execute
.text$mn:000075CC _text$mn        segment para public 'CODE' use32
.text$mn:000075CC                 assume cs:_text$mn
.text$mn:000075CC                 ;org 75CCh
.text$mn:000075CC ; COMDAT (pick any)
.text$mn:000075CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075CC
.text$mn:000075CC ; =============== S U B R O U T I N E =======================================
.text$mn:000075CC
.text$mn:000075CC ; Attributes: bp-based frame
.text$mn:000075CC
.text$mn:000075CC ; public: unsigned int __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::_Unused_capacity(void)const
.text$mn:000075CC                 public ?_Unused_capacity@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ
.text$mn:000075CC ?_Unused_capacity@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ proc near
.text$mn:000075CC                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reserve(uint)+Bp
.text$mn:000075CC
.text$mn:000075CC var_4           = dword ptr -4
.text$mn:000075CC
.text$mn:000075CC                 push    ebp
.text$mn:000075CD                 mov     ebp, esp
.text$mn:000075CF                 push    ecx
.text$mn:000075D0                 mov     [ebp+var_4], ecx
.text$mn:000075D3                 mov     eax, [ebp+var_4]
.text$mn:000075D6                 mov     ecx, [ebp+var_4]
.text$mn:000075D9                 mov     eax, [eax+0Ch]
.text$mn:000075DC                 sub     eax, [ecx+8]
.text$mn:000075DF                 sar     eax, 2
.text$mn:000075E2                 mov     esp, ebp
.text$mn:000075E4                 pop     ebp
.text$mn:000075E5                 retn
.text$mn:000075E5 ?_Unused_capacity@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ endp
.text$mn:000075E5
.text$mn:000075E5 ; ---------------------------------------------------------------------------
.text$mn:000075E6                 align 4
.text$mn:000075E6 _text$mn        ends
.text$mn:000075E6
.text$mn:000075E8 ; ===========================================================================
.text$mn:000075E8
.text$mn:000075E8 ; Segment type: Pure code
.text$mn:000075E8 ; Segment permissions: Read/Execute
.text$mn:000075E8 _text$mn        segment para public 'CODE' use32
.text$mn:000075E8                 assume cs:_text$mn
.text$mn:000075E8                 ;org 75E8h
.text$mn:000075E8 ; COMDAT (pick any)
.text$mn:000075E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075E8
.text$mn:000075E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000075E8
.text$mn:000075E8 ; Attributes: bp-based frame
.text$mn:000075E8
.text$mn:000075E8 ; public: unsigned int __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Unused_capacity(void)const
.text$mn:000075E8                 public ?_Unused_capacity@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ
.text$mn:000075E8 ?_Unused_capacity@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ proc near
.text$mn:000075E8                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reserve(uint)+Bp
.text$mn:000075E8
.text$mn:000075E8 var_4           = dword ptr -4
.text$mn:000075E8
.text$mn:000075E8                 push    ebp
.text$mn:000075E9                 mov     ebp, esp
.text$mn:000075EB                 push    ecx
.text$mn:000075EC                 mov     [ebp+var_4], ecx
.text$mn:000075EF                 mov     eax, [ebp+var_4]
.text$mn:000075F2                 mov     ecx, [ebp+var_4]
.text$mn:000075F5                 mov     eax, [eax+0Ch]
.text$mn:000075F8                 sub     eax, [ecx+8]
.text$mn:000075FB                 sar     eax, 2
.text$mn:000075FE                 mov     esp, ebp
.text$mn:00007600                 pop     ebp
.text$mn:00007601                 retn
.text$mn:00007601 ?_Unused_capacity@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ endp
.text$mn:00007601
.text$mn:00007601 ; ---------------------------------------------------------------------------
.text$mn:00007602                 align 4
.text$mn:00007602 _text$mn        ends
.text$mn:00007602
.text$mn:00007604 ; ===========================================================================
.text$mn:00007604
.text$mn:00007604 ; Segment type: Pure code
.text$mn:00007604 ; Segment permissions: Read/Execute
.text$mn:00007604 _text$mn        segment para public 'CODE' use32
.text$mn:00007604                 assume cs:_text$mn
.text$mn:00007604                 ;org 7604h
.text$mn:00007604 ; COMDAT (pick any)
.text$mn:00007604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007604
.text$mn:00007604 ; =============== S U B R O U T I N E =======================================
.text$mn:00007604
.text$mn:00007604 ; Attributes: bp-based frame
.text$mn:00007604
.text$mn:00007604 ; public: unsigned int __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::_Unused_capacity(void)const
.text$mn:00007604                 public ?_Unused_capacity@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ
.text$mn:00007604 ?_Unused_capacity@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ proc near
.text$mn:00007604                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reserve(uint)+Bp
.text$mn:00007604
.text$mn:00007604 var_4           = dword ptr -4
.text$mn:00007604
.text$mn:00007604                 push    ebp
.text$mn:00007605                 mov     ebp, esp
.text$mn:00007607                 push    ecx
.text$mn:00007608                 mov     [ebp+var_4], ecx
.text$mn:0000760B                 mov     eax, [ebp+var_4]
.text$mn:0000760E                 mov     ecx, [ebp+var_4]
.text$mn:00007611                 mov     eax, [eax+0Ch]
.text$mn:00007614                 sub     eax, [ecx+8]
.text$mn:00007617                 sar     eax, 2
.text$mn:0000761A                 mov     esp, ebp
.text$mn:0000761C                 pop     ebp
.text$mn:0000761D                 retn
.text$mn:0000761D ?_Unused_capacity@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ endp
.text$mn:0000761D
.text$mn:0000761D ; ---------------------------------------------------------------------------
.text$mn:0000761E                 align 10h
.text$mn:0000761E _text$mn        ends
.text$mn:0000761E
.text$mn:00007620 ; ===========================================================================
.text$mn:00007620
.text$mn:00007620 ; Segment type: Pure code
.text$mn:00007620 ; Segment permissions: Read/Execute
.text$mn:00007620 _text$mn        segment para public 'CODE' use32
.text$mn:00007620                 assume cs:_text$mn
.text$mn:00007620                 ;org 7620h
.text$mn:00007620 ; COMDAT (pick any)
.text$mn:00007620                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007620
.text$mn:00007620 ; =============== S U B R O U T I N E =======================================
.text$mn:00007620
.text$mn:00007620 ; Attributes: bp-based frame
.text$mn:00007620
.text$mn:00007620 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00007620                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00007620 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00007620                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00007620
.text$mn:00007620 var_4           = dword ptr -4
.text$mn:00007620
.text$mn:00007620                 push    ebp
.text$mn:00007621                 mov     ebp, esp
.text$mn:00007623                 push    ecx
.text$mn:00007624                 mov     [ebp+var_4], ecx
.text$mn:00007627                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000762C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007631                 mov     esp, ebp
.text$mn:00007633                 pop     ebp
.text$mn:00007634                 retn
.text$mn:00007634 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00007634
.text$mn:00007634 ; ---------------------------------------------------------------------------
.text$mn:00007635                 align 4
.text$mn:00007635 _text$mn        ends
.text$mn:00007635
.text$mn:00007638 ; ===========================================================================
.text$mn:00007638
.text$mn:00007638 ; Segment type: Pure code
.text$mn:00007638 ; Segment permissions: Read/Execute
.text$mn:00007638 _text$mn        segment para public 'CODE' use32
.text$mn:00007638                 assume cs:_text$mn
.text$mn:00007638                 ;org 7638h
.text$mn:00007638 ; COMDAT (pick any)
.text$mn:00007638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007638
.text$mn:00007638 ; =============== S U B R O U T I N E =======================================
.text$mn:00007638
.text$mn:00007638 ; Attributes: bp-based frame
.text$mn:00007638
.text$mn:00007638 ; protected: void __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::_Xlen(void)const
.text$mn:00007638                 public ?_Xlen@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXXZ
.text$mn:00007638 ?_Xlen@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXXZ proc near
.text$mn:00007638                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reserve(uint)+31p
.text$mn:00007638
.text$mn:00007638 var_4           = dword ptr -4
.text$mn:00007638
.text$mn:00007638                 push    ebp
.text$mn:00007639                 mov     ebp, esp
.text$mn:0000763B                 push    ecx
.text$mn:0000763C                 mov     [ebp+var_4], ecx
.text$mn:0000763F                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00007644                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007649                 mov     esp, ebp
.text$mn:0000764B                 pop     ebp
.text$mn:0000764C                 retn
.text$mn:0000764C ?_Xlen@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXXZ endp
.text$mn:0000764C
.text$mn:0000764C ; ---------------------------------------------------------------------------
.text$mn:0000764D                 align 10h
.text$mn:0000764D _text$mn        ends
.text$mn:0000764D
.text$mn:00007650 ; ===========================================================================
.text$mn:00007650
.text$mn:00007650 ; Segment type: Pure code
.text$mn:00007650 ; Segment permissions: Read/Execute
.text$mn:00007650 _text$mn        segment para public 'CODE' use32
.text$mn:00007650                 assume cs:_text$mn
.text$mn:00007650                 ;org 7650h
.text$mn:00007650 ; COMDAT (pick any)
.text$mn:00007650                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007650
.text$mn:00007650 ; =============== S U B R O U T I N E =======================================
.text$mn:00007650
.text$mn:00007650 ; Attributes: bp-based frame
.text$mn:00007650
.text$mn:00007650 ; protected: void __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::_Xlen(void)const
.text$mn:00007650                 public ?_Xlen@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IBEXXZ
.text$mn:00007650 ?_Xlen@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IBEXXZ proc near
.text$mn:00007650                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Buy(uint)+43p
.text$mn:00007650
.text$mn:00007650 var_4           = dword ptr -4
.text$mn:00007650
.text$mn:00007650                 push    ebp
.text$mn:00007651                 mov     ebp, esp
.text$mn:00007653                 push    ecx
.text$mn:00007654                 mov     [ebp+var_4], ecx
.text$mn:00007657                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000765C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007661                 mov     esp, ebp
.text$mn:00007663                 pop     ebp
.text$mn:00007664                 retn
.text$mn:00007664 ?_Xlen@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IBEXXZ endp
.text$mn:00007664
.text$mn:00007664 ; ---------------------------------------------------------------------------
.text$mn:00007665                 align 4
.text$mn:00007665 _text$mn        ends
.text$mn:00007665
.text$mn:00007668 ; ===========================================================================
.text$mn:00007668
.text$mn:00007668 ; Segment type: Pure code
.text$mn:00007668 ; Segment permissions: Read/Execute
.text$mn:00007668 _text$mn        segment para public 'CODE' use32
.text$mn:00007668                 assume cs:_text$mn
.text$mn:00007668                 ;org 7668h
.text$mn:00007668 ; COMDAT (pick any)
.text$mn:00007668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007668
.text$mn:00007668 ; =============== S U B R O U T I N E =======================================
.text$mn:00007668
.text$mn:00007668 ; Attributes: bp-based frame
.text$mn:00007668
.text$mn:00007668 ; protected: void __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Xlen(void)const
.text$mn:00007668                 public ?_Xlen@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXXZ
.text$mn:00007668 ?_Xlen@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXXZ proc near
.text$mn:00007668                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reserve(uint)+31p
.text$mn:00007668
.text$mn:00007668 var_4           = dword ptr -4
.text$mn:00007668
.text$mn:00007668                 push    ebp
.text$mn:00007669                 mov     ebp, esp
.text$mn:0000766B                 push    ecx
.text$mn:0000766C                 mov     [ebp+var_4], ecx
.text$mn:0000766F                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00007674                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007679                 mov     esp, ebp
.text$mn:0000767B                 pop     ebp
.text$mn:0000767C                 retn
.text$mn:0000767C ?_Xlen@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXXZ endp
.text$mn:0000767C
.text$mn:0000767C ; ---------------------------------------------------------------------------
.text$mn:0000767D                 align 10h
.text$mn:0000767D _text$mn        ends
.text$mn:0000767D
.text$mn:00007680 ; ===========================================================================
.text$mn:00007680
.text$mn:00007680 ; Segment type: Pure code
.text$mn:00007680 ; Segment permissions: Read/Execute
.text$mn:00007680 _text$mn        segment para public 'CODE' use32
.text$mn:00007680                 assume cs:_text$mn
.text$mn:00007680                 ;org 7680h
.text$mn:00007680 ; COMDAT (pick any)
.text$mn:00007680                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007680
.text$mn:00007680 ; =============== S U B R O U T I N E =======================================
.text$mn:00007680
.text$mn:00007680 ; Attributes: bp-based frame
.text$mn:00007680
.text$mn:00007680 ; protected: void __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::_Xlen(void)const
.text$mn:00007680                 public ?_Xlen@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXXZ
.text$mn:00007680 ?_Xlen@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXXZ proc near
.text$mn:00007680                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reserve(uint)+31p
.text$mn:00007680
.text$mn:00007680 var_4           = dword ptr -4
.text$mn:00007680
.text$mn:00007680                 push    ebp
.text$mn:00007681                 mov     ebp, esp
.text$mn:00007683                 push    ecx
.text$mn:00007684                 mov     [ebp+var_4], ecx
.text$mn:00007687                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000768C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007691                 mov     esp, ebp
.text$mn:00007693                 pop     ebp
.text$mn:00007694                 retn
.text$mn:00007694 ?_Xlen@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXXZ endp
.text$mn:00007694
.text$mn:00007694 ; ---------------------------------------------------------------------------
.text$mn:00007695                 align 4
.text$mn:00007695 _text$mn        ends
.text$mn:00007695
.text$mn:00007698 ; ===========================================================================
.text$mn:00007698
.text$mn:00007698 ; Segment type: Pure code
.text$mn:00007698 ; Segment permissions: Read/Execute
.text$mn:00007698 _text$mn        segment para public 'CODE' use32
.text$mn:00007698                 assume cs:_text$mn
.text$mn:00007698                 ;org 7698h
.text$mn:00007698 ; COMDAT (pick any)
.text$mn:00007698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007698
.text$mn:00007698 ; =============== S U B R O U T I N E =======================================
.text$mn:00007698
.text$mn:00007698 ; Attributes: bp-based frame
.text$mn:00007698
.text$mn:00007698 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00007698                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00007698 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00007698                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00007698                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00007698
.text$mn:00007698 var_4           = dword ptr -4
.text$mn:00007698
.text$mn:00007698                 push    ebp
.text$mn:00007699                 mov     ebp, esp
.text$mn:0000769B                 push    ecx
.text$mn:0000769C                 mov     [ebp+var_4], ecx
.text$mn:0000769F                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000076A4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000076A9                 mov     esp, ebp
.text$mn:000076AB                 pop     ebp
.text$mn:000076AC                 retn
.text$mn:000076AC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000076AC
.text$mn:000076AC ; ---------------------------------------------------------------------------
.text$mn:000076AD                 align 10h
.text$mn:000076AD _text$mn        ends
.text$mn:000076AD
.text$mn:000076B0 ; ===========================================================================
.text$mn:000076B0
.text$mn:000076B0 ; Segment type: Pure code
.text$mn:000076B0 ; Segment permissions: Read/Execute
.text$mn:000076B0 _text$mn        segment para public 'CODE' use32
.text$mn:000076B0                 assume cs:_text$mn
.text$mn:000076B0                 ;org 76B0h
.text$mn:000076B0 ; COMDAT (pick any)
.text$mn:000076B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000076B0
.text$mn:000076B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000076B0
.text$mn:000076B0 ; Attributes: bp-based frame
.text$mn:000076B0
.text$mn:000076B0 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000076B0                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000076B0 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000076B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000076B0                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000076B0
.text$mn:000076B0 var_4           = dword ptr -4
.text$mn:000076B0 arg_0           = dword ptr  8
.text$mn:000076B0
.text$mn:000076B0                 push    ebp
.text$mn:000076B1                 mov     ebp, esp
.text$mn:000076B3                 push    ecx
.text$mn:000076B4                 mov     [ebp+var_4], ecx
.text$mn:000076B7                 mov     eax, [ebp+arg_0]
.text$mn:000076BA                 push    eax
.text$mn:000076BB                 mov     ecx, [ebp+var_4]
.text$mn:000076BE                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000076C3                 mov     esp, ebp
.text$mn:000076C5                 pop     ebp
.text$mn:000076C6                 retn    4
.text$mn:000076C6 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000076C6
.text$mn:000076C6 ; ---------------------------------------------------------------------------
.text$mn:000076C9                 align 4
.text$mn:000076C9 _text$mn        ends
.text$mn:000076C9
.text$mn:000076CC ; ===========================================================================
.text$mn:000076CC
.text$mn:000076CC ; Segment type: Pure code
.text$mn:000076CC ; Segment permissions: Read/Execute
.text$mn:000076CC _text$mn        segment para public 'CODE' use32
.text$mn:000076CC                 assume cs:_text$mn
.text$mn:000076CC                 ;org 76CCh
.text$mn:000076CC ; COMDAT (pick any)
.text$mn:000076CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000076CC
.text$mn:000076CC ; =============== S U B R O U T I N E =======================================
.text$mn:000076CC
.text$mn:000076CC ; Attributes: bp-based frame
.text$mn:000076CC
.text$mn:000076CC ; public: struct HWND__ * * __thiscall std::_Wrap_alloc<class std::allocator<struct HWND__ *>>::allocate(unsigned int)
.text$mn:000076CC                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEPAPAUHWND__@@I@Z
.text$mn:000076CC ?allocate@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEPAPAUHWND__@@I@Z proc near
.text$mn:000076CC                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reallocate(uint)+41p
.text$mn:000076CC
.text$mn:000076CC var_4           = dword ptr -4
.text$mn:000076CC arg_0           = dword ptr  8
.text$mn:000076CC
.text$mn:000076CC                 push    ebp
.text$mn:000076CD                 mov     ebp, esp
.text$mn:000076CF                 push    ecx
.text$mn:000076D0                 mov     [ebp+var_4], ecx
.text$mn:000076D3                 mov     eax, [ebp+arg_0]
.text$mn:000076D6                 push    eax
.text$mn:000076D7                 mov     ecx, [ebp+var_4]
.text$mn:000076DA                 call    ?allocate@?$allocator@PAUHWND__@@@std@@QAEPAPAUHWND__@@I@Z ; std::allocator<HWND__ *>::allocate(uint)
.text$mn:000076DF                 mov     esp, ebp
.text$mn:000076E1                 pop     ebp
.text$mn:000076E2                 retn    4
.text$mn:000076E2 ?allocate@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEPAPAUHWND__@@I@Z endp
.text$mn:000076E2
.text$mn:000076E2 ; ---------------------------------------------------------------------------
.text$mn:000076E5                 align 4
.text$mn:000076E5 _text$mn        ends
.text$mn:000076E5
.text$mn:000076E8 ; ===========================================================================
.text$mn:000076E8
.text$mn:000076E8 ; Segment type: Pure code
.text$mn:000076E8 ; Segment permissions: Read/Execute
.text$mn:000076E8 _text$mn        segment para public 'CODE' use32
.text$mn:000076E8                 assume cs:_text$mn
.text$mn:000076E8                 ;org 76E8h
.text$mn:000076E8 ; COMDAT (pick any)
.text$mn:000076E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000076E8
.text$mn:000076E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000076E8
.text$mn:000076E8 ; Attributes: bp-based frame
.text$mn:000076E8
.text$mn:000076E8 ; public: struct tTbData * * __thiscall std::_Wrap_alloc<class std::allocator<struct tTbData *>>::allocate(unsigned int)
.text$mn:000076E8                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAEPAPAUtTbData@@I@Z
.text$mn:000076E8 ?allocate@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAEPAPAUtTbData@@I@Z proc near
.text$mn:000076E8                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Buy(uint)+5Cp
.text$mn:000076E8
.text$mn:000076E8 var_4           = dword ptr -4
.text$mn:000076E8 arg_0           = dword ptr  8
.text$mn:000076E8
.text$mn:000076E8                 push    ebp
.text$mn:000076E9                 mov     ebp, esp
.text$mn:000076EB                 push    ecx
.text$mn:000076EC                 mov     [ebp+var_4], ecx
.text$mn:000076EF                 mov     eax, [ebp+arg_0]
.text$mn:000076F2                 push    eax
.text$mn:000076F3                 mov     ecx, [ebp+var_4]
.text$mn:000076F6                 call    ?allocate@?$allocator@PAUtTbData@@@std@@QAEPAPAUtTbData@@I@Z ; std::allocator<tTbData *>::allocate(uint)
.text$mn:000076FB                 mov     esp, ebp
.text$mn:000076FD                 pop     ebp
.text$mn:000076FE                 retn    4
.text$mn:000076FE ?allocate@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAEPAPAUtTbData@@I@Z endp
.text$mn:000076FE
.text$mn:000076FE ; ---------------------------------------------------------------------------
.text$mn:00007701                 align 4
.text$mn:00007701 _text$mn        ends
.text$mn:00007701
.text$mn:00007704 ; ===========================================================================
.text$mn:00007704
.text$mn:00007704 ; Segment type: Pure code
.text$mn:00007704 ; Segment permissions: Read/Execute
.text$mn:00007704 _text$mn        segment para public 'CODE' use32
.text$mn:00007704                 assume cs:_text$mn
.text$mn:00007704                 ;org 7704h
.text$mn:00007704 ; COMDAT (pick any)
.text$mn:00007704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007704
.text$mn:00007704 ; =============== S U B R O U T I N E =======================================
.text$mn:00007704
.text$mn:00007704 ; Attributes: bp-based frame
.text$mn:00007704
.text$mn:00007704 ; public: class DockingCont * * __thiscall std::_Wrap_alloc<class std::allocator<class DockingCont *>>::allocate(unsigned int)
.text$mn:00007704                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEPAPAVDockingCont@@I@Z
.text$mn:00007704 ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEPAPAVDockingCont@@I@Z proc near
.text$mn:00007704                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reallocate(uint)+41p
.text$mn:00007704
.text$mn:00007704 var_4           = dword ptr -4
.text$mn:00007704 arg_0           = dword ptr  8
.text$mn:00007704
.text$mn:00007704                 push    ebp
.text$mn:00007705                 mov     ebp, esp
.text$mn:00007707                 push    ecx
.text$mn:00007708                 mov     [ebp+var_4], ecx
.text$mn:0000770B                 mov     eax, [ebp+arg_0]
.text$mn:0000770E                 push    eax
.text$mn:0000770F                 mov     ecx, [ebp+var_4]
.text$mn:00007712                 call    ?allocate@?$allocator@PAVDockingCont@@@std@@QAEPAPAVDockingCont@@I@Z ; std::allocator<DockingCont *>::allocate(uint)
.text$mn:00007717                 mov     esp, ebp
.text$mn:00007719                 pop     ebp
.text$mn:0000771A                 retn    4
.text$mn:0000771A ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEPAPAVDockingCont@@I@Z endp
.text$mn:0000771A
.text$mn:0000771A ; ---------------------------------------------------------------------------
.text$mn:0000771D                 align 10h
.text$mn:0000771D _text$mn        ends
.text$mn:0000771D
.text$mn:00007720 ; ===========================================================================
.text$mn:00007720
.text$mn:00007720 ; Segment type: Pure code
.text$mn:00007720 ; Segment permissions: Read/Execute
.text$mn:00007720 _text$mn        segment para public 'CODE' use32
.text$mn:00007720                 assume cs:_text$mn
.text$mn:00007720                 ;org 7720h
.text$mn:00007720 ; COMDAT (pick any)
.text$mn:00007720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007720
.text$mn:00007720 ; =============== S U B R O U T I N E =======================================
.text$mn:00007720
.text$mn:00007720 ; Attributes: bp-based frame
.text$mn:00007720
.text$mn:00007720 ; public: class DockingSplitter * * __thiscall std::_Wrap_alloc<class std::allocator<class DockingSplitter *>>::allocate(unsigned int)
.text$mn:00007720                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEPAPAVDockingSplitter@@I@Z
.text$mn:00007720 ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEPAPAVDockingSplitter@@I@Z proc near
.text$mn:00007720                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reallocate(uint)+41p
.text$mn:00007720
.text$mn:00007720 var_4           = dword ptr -4
.text$mn:00007720 arg_0           = dword ptr  8
.text$mn:00007720
.text$mn:00007720                 push    ebp
.text$mn:00007721                 mov     ebp, esp
.text$mn:00007723                 push    ecx
.text$mn:00007724                 mov     [ebp+var_4], ecx
.text$mn:00007727                 mov     eax, [ebp+arg_0]
.text$mn:0000772A                 push    eax
.text$mn:0000772B                 mov     ecx, [ebp+var_4]
.text$mn:0000772E                 call    ?allocate@?$allocator@PAVDockingSplitter@@@std@@QAEPAPAVDockingSplitter@@I@Z ; std::allocator<DockingSplitter *>::allocate(uint)
.text$mn:00007733                 mov     esp, ebp
.text$mn:00007735                 pop     ebp
.text$mn:00007736                 retn    4
.text$mn:00007736 ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEPAPAVDockingSplitter@@I@Z endp
.text$mn:00007736
.text$mn:00007736 ; ---------------------------------------------------------------------------
.text$mn:00007739                 align 4
.text$mn:00007739 _text$mn        ends
.text$mn:00007739
.text$mn:0000773C ; ===========================================================================
.text$mn:0000773C
.text$mn:0000773C ; Segment type: Pure code
.text$mn:0000773C ; Segment permissions: Read/Execute
.text$mn:0000773C _text$mn        segment para public 'CODE' use32
.text$mn:0000773C                 assume cs:_text$mn
.text$mn:0000773C                 ;org 773Ch
.text$mn:0000773C ; COMDAT (pick any)
.text$mn:0000773C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000773C
.text$mn:0000773C ; =============== S U B R O U T I N E =======================================
.text$mn:0000773C
.text$mn:0000773C ; Attributes: bp-based frame
.text$mn:0000773C
.text$mn:0000773C ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:0000773C                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000773C ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000773C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Alloc_proxy(void)+16p
.text$mn:0000773C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Alloc_proxy(void)+16p ...
.text$mn:0000773C
.text$mn:0000773C var_4           = dword ptr -4
.text$mn:0000773C arg_0           = dword ptr  8
.text$mn:0000773C
.text$mn:0000773C                 push    ebp
.text$mn:0000773D                 mov     ebp, esp
.text$mn:0000773F                 push    ecx
.text$mn:00007740                 mov     [ebp+var_4], ecx
.text$mn:00007743                 mov     eax, [ebp+arg_0]
.text$mn:00007746                 push    eax
.text$mn:00007747                 mov     ecx, [ebp+var_4]
.text$mn:0000774A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000774F                 mov     esp, ebp
.text$mn:00007751                 pop     ebp
.text$mn:00007752                 retn    4
.text$mn:00007752 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00007752
.text$mn:00007752 ; ---------------------------------------------------------------------------
.text$mn:00007755                 align 4
.text$mn:00007755 _text$mn        ends
.text$mn:00007755
.text$mn:00007758 ; ===========================================================================
.text$mn:00007758
.text$mn:00007758 ; Segment type: Pure code
.text$mn:00007758 ; Segment permissions: Read/Execute
.text$mn:00007758 _text$mn        segment para public 'CODE' use32
.text$mn:00007758                 assume cs:_text$mn
.text$mn:00007758                 ;org 7758h
.text$mn:00007758 ; COMDAT (pick any)
.text$mn:00007758                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007758
.text$mn:00007758 ; =============== S U B R O U T I N E =======================================
.text$mn:00007758
.text$mn:00007758 ; Attributes: bp-based frame
.text$mn:00007758
.text$mn:00007758 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00007758                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00007758 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00007758                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00007758
.text$mn:00007758 var_4           = dword ptr -4
.text$mn:00007758 arg_0           = dword ptr  8
.text$mn:00007758
.text$mn:00007758                 push    ebp
.text$mn:00007759                 mov     ebp, esp
.text$mn:0000775B                 push    ecx
.text$mn:0000775C                 mov     [ebp+var_4], ecx
.text$mn:0000775F                 push    0
.text$mn:00007761                 mov     eax, [ebp+arg_0]
.text$mn:00007764                 push    eax
.text$mn:00007765                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000776A                 add     esp, 8
.text$mn:0000776D                 mov     esp, ebp
.text$mn:0000776F                 pop     ebp
.text$mn:00007770                 retn    4
.text$mn:00007770 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00007770
.text$mn:00007770 ; ---------------------------------------------------------------------------
.text$mn:00007773                 align 4
.text$mn:00007773 _text$mn        ends
.text$mn:00007773
.text$mn:00007774 ; ===========================================================================
.text$mn:00007774
.text$mn:00007774 ; Segment type: Pure code
.text$mn:00007774 ; Segment permissions: Read/Execute
.text$mn:00007774 _text$mn        segment para public 'CODE' use32
.text$mn:00007774                 assume cs:_text$mn
.text$mn:00007774                 ;org 7774h
.text$mn:00007774 ; COMDAT (pick any)
.text$mn:00007774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007774
.text$mn:00007774 ; =============== S U B R O U T I N E =======================================
.text$mn:00007774
.text$mn:00007774 ; Attributes: bp-based frame
.text$mn:00007774
.text$mn:00007774 ; public: struct HWND__ * * __thiscall std::allocator<struct HWND__ *>::allocate(unsigned int)
.text$mn:00007774                 public ?allocate@?$allocator@PAUHWND__@@@std@@QAEPAPAUHWND__@@I@Z
.text$mn:00007774 ?allocate@?$allocator@PAUHWND__@@@std@@QAEPAPAUHWND__@@I@Z proc near
.text$mn:00007774                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HWND__ *>>::allocate(uint)+Ep
.text$mn:00007774
.text$mn:00007774 var_4           = dword ptr -4
.text$mn:00007774 arg_0           = dword ptr  8
.text$mn:00007774
.text$mn:00007774                 push    ebp
.text$mn:00007775                 mov     ebp, esp
.text$mn:00007777                 push    ecx
.text$mn:00007778                 mov     [ebp+var_4], ecx
.text$mn:0000777B                 push    0
.text$mn:0000777D                 mov     eax, [ebp+arg_0]
.text$mn:00007780                 push    eax
.text$mn:00007781                 call    ??$_Allocate@PAUHWND__@@@std@@YAPAPAUHWND__@@IPAPAU1@@Z ; std::_Allocate<HWND__ *>(uint,HWND__ * *)
.text$mn:00007786                 add     esp, 8
.text$mn:00007789                 mov     esp, ebp
.text$mn:0000778B                 pop     ebp
.text$mn:0000778C                 retn    4
.text$mn:0000778C ?allocate@?$allocator@PAUHWND__@@@std@@QAEPAPAUHWND__@@I@Z endp
.text$mn:0000778C
.text$mn:0000778C ; ---------------------------------------------------------------------------
.text$mn:0000778F                 align 10h
.text$mn:0000778F _text$mn        ends
.text$mn:0000778F
.text$mn:00007790 ; ===========================================================================
.text$mn:00007790
.text$mn:00007790 ; Segment type: Pure code
.text$mn:00007790 ; Segment permissions: Read/Execute
.text$mn:00007790 _text$mn        segment para public 'CODE' use32
.text$mn:00007790                 assume cs:_text$mn
.text$mn:00007790                 ;org 7790h
.text$mn:00007790 ; COMDAT (pick any)
.text$mn:00007790                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007790
.text$mn:00007790 ; =============== S U B R O U T I N E =======================================
.text$mn:00007790
.text$mn:00007790 ; Attributes: bp-based frame
.text$mn:00007790
.text$mn:00007790 ; public: struct tTbData * * __thiscall std::allocator<struct tTbData *>::allocate(unsigned int)
.text$mn:00007790                 public ?allocate@?$allocator@PAUtTbData@@@std@@QAEPAPAUtTbData@@I@Z
.text$mn:00007790 ?allocate@?$allocator@PAUtTbData@@@std@@QAEPAPAUtTbData@@I@Z proc near
.text$mn:00007790                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tTbData *>>::allocate(uint)+Ep
.text$mn:00007790
.text$mn:00007790 var_4           = dword ptr -4
.text$mn:00007790 arg_0           = dword ptr  8
.text$mn:00007790
.text$mn:00007790                 push    ebp
.text$mn:00007791                 mov     ebp, esp
.text$mn:00007793                 push    ecx
.text$mn:00007794                 mov     [ebp+var_4], ecx
.text$mn:00007797                 push    0
.text$mn:00007799                 mov     eax, [ebp+arg_0]
.text$mn:0000779C                 push    eax
.text$mn:0000779D                 call    ??$_Allocate@PAUtTbData@@@std@@YAPAPAUtTbData@@IPAPAU1@@Z ; std::_Allocate<tTbData *>(uint,tTbData * *)
.text$mn:000077A2                 add     esp, 8
.text$mn:000077A5                 mov     esp, ebp
.text$mn:000077A7                 pop     ebp
.text$mn:000077A8                 retn    4
.text$mn:000077A8 ?allocate@?$allocator@PAUtTbData@@@std@@QAEPAPAUtTbData@@I@Z endp
.text$mn:000077A8
.text$mn:000077A8 ; ---------------------------------------------------------------------------
.text$mn:000077AB                 align 4
.text$mn:000077AB _text$mn        ends
.text$mn:000077AB
.text$mn:000077AC ; ===========================================================================
.text$mn:000077AC
.text$mn:000077AC ; Segment type: Pure code
.text$mn:000077AC ; Segment permissions: Read/Execute
.text$mn:000077AC _text$mn        segment para public 'CODE' use32
.text$mn:000077AC                 assume cs:_text$mn
.text$mn:000077AC                 ;org 77ACh
.text$mn:000077AC ; COMDAT (pick any)
.text$mn:000077AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077AC
.text$mn:000077AC ; =============== S U B R O U T I N E =======================================
.text$mn:000077AC
.text$mn:000077AC ; Attributes: bp-based frame
.text$mn:000077AC
.text$mn:000077AC ; public: class DockingCont * * __thiscall std::allocator<class DockingCont *>::allocate(unsigned int)
.text$mn:000077AC                 public ?allocate@?$allocator@PAVDockingCont@@@std@@QAEPAPAVDockingCont@@I@Z
.text$mn:000077AC ?allocate@?$allocator@PAVDockingCont@@@std@@QAEPAPAVDockingCont@@I@Z proc near
.text$mn:000077AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::allocate(uint)+Ep
.text$mn:000077AC
.text$mn:000077AC var_4           = dword ptr -4
.text$mn:000077AC arg_0           = dword ptr  8
.text$mn:000077AC
.text$mn:000077AC                 push    ebp
.text$mn:000077AD                 mov     ebp, esp
.text$mn:000077AF                 push    ecx
.text$mn:000077B0                 mov     [ebp+var_4], ecx
.text$mn:000077B3                 push    0
.text$mn:000077B5                 mov     eax, [ebp+arg_0]
.text$mn:000077B8                 push    eax
.text$mn:000077B9                 call    ??$_Allocate@PAVDockingCont@@@std@@YAPAPAVDockingCont@@IPAPAV1@@Z ; std::_Allocate<DockingCont *>(uint,DockingCont * *)
.text$mn:000077BE                 add     esp, 8
.text$mn:000077C1                 mov     esp, ebp
.text$mn:000077C3                 pop     ebp
.text$mn:000077C4                 retn    4
.text$mn:000077C4 ?allocate@?$allocator@PAVDockingCont@@@std@@QAEPAPAVDockingCont@@I@Z endp
.text$mn:000077C4
.text$mn:000077C4 ; ---------------------------------------------------------------------------
.text$mn:000077C7                 align 4
.text$mn:000077C7 _text$mn        ends
.text$mn:000077C7
.text$mn:000077C8 ; ===========================================================================
.text$mn:000077C8
.text$mn:000077C8 ; Segment type: Pure code
.text$mn:000077C8 ; Segment permissions: Read/Execute
.text$mn:000077C8 _text$mn        segment para public 'CODE' use32
.text$mn:000077C8                 assume cs:_text$mn
.text$mn:000077C8                 ;org 77C8h
.text$mn:000077C8 ; COMDAT (pick any)
.text$mn:000077C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077C8
.text$mn:000077C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000077C8
.text$mn:000077C8 ; Attributes: bp-based frame
.text$mn:000077C8
.text$mn:000077C8 ; public: class DockingSplitter * * __thiscall std::allocator<class DockingSplitter *>::allocate(unsigned int)
.text$mn:000077C8                 public ?allocate@?$allocator@PAVDockingSplitter@@@std@@QAEPAPAVDockingSplitter@@I@Z
.text$mn:000077C8 ?allocate@?$allocator@PAVDockingSplitter@@@std@@QAEPAPAVDockingSplitter@@I@Z proc near
.text$mn:000077C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingSplitter *>>::allocate(uint)+Ep
.text$mn:000077C8
.text$mn:000077C8 var_4           = dword ptr -4
.text$mn:000077C8 arg_0           = dword ptr  8
.text$mn:000077C8
.text$mn:000077C8                 push    ebp
.text$mn:000077C9                 mov     ebp, esp
.text$mn:000077CB                 push    ecx
.text$mn:000077CC                 mov     [ebp+var_4], ecx
.text$mn:000077CF                 push    0
.text$mn:000077D1                 mov     eax, [ebp+arg_0]
.text$mn:000077D4                 push    eax
.text$mn:000077D5                 call    ??$_Allocate@PAVDockingSplitter@@@std@@YAPAPAVDockingSplitter@@IPAPAV1@@Z ; std::_Allocate<DockingSplitter *>(uint,DockingSplitter * *)
.text$mn:000077DA                 add     esp, 8
.text$mn:000077DD                 mov     esp, ebp
.text$mn:000077DF                 pop     ebp
.text$mn:000077E0                 retn    4
.text$mn:000077E0 ?allocate@?$allocator@PAVDockingSplitter@@@std@@QAEPAPAVDockingSplitter@@I@Z endp
.text$mn:000077E0
.text$mn:000077E0 ; ---------------------------------------------------------------------------
.text$mn:000077E3                 align 4
.text$mn:000077E3 _text$mn        ends
.text$mn:000077E3
.text$mn:000077E4 ; ===========================================================================
.text$mn:000077E4
.text$mn:000077E4 ; Segment type: Pure code
.text$mn:000077E4 ; Segment permissions: Read/Execute
.text$mn:000077E4 _text$mn        segment para public 'CODE' use32
.text$mn:000077E4                 assume cs:_text$mn
.text$mn:000077E4                 ;org 77E4h
.text$mn:000077E4 ; COMDAT (pick any)
.text$mn:000077E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077E4
.text$mn:000077E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000077E4
.text$mn:000077E4 ; Attributes: bp-based frame
.text$mn:000077E4
.text$mn:000077E4 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000077E4                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000077E4 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000077E4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000077E4                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)+Ep
.text$mn:000077E4
.text$mn:000077E4 var_4           = dword ptr -4
.text$mn:000077E4 arg_0           = dword ptr  8
.text$mn:000077E4
.text$mn:000077E4                 push    ebp
.text$mn:000077E5                 mov     ebp, esp
.text$mn:000077E7                 push    ecx
.text$mn:000077E8                 mov     [ebp+var_4], ecx
.text$mn:000077EB                 push    0
.text$mn:000077ED                 mov     eax, [ebp+arg_0]
.text$mn:000077F0                 push    eax
.text$mn:000077F1                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:000077F6                 add     esp, 8
.text$mn:000077F9                 mov     esp, ebp
.text$mn:000077FB                 pop     ebp
.text$mn:000077FC                 retn    4
.text$mn:000077FC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000077FC
.text$mn:000077FC ; ---------------------------------------------------------------------------
.text$mn:000077FF                 align 10h
.text$mn:000077FF _text$mn        ends
.text$mn:000077FF
.text$mn:00007800 ; ===========================================================================
.text$mn:00007800
.text$mn:00007800 ; Segment type: Pure code
.text$mn:00007800 ; Segment permissions: Read/Execute
.text$mn:00007800 _text$mn        segment para public 'CODE' use32
.text$mn:00007800                 assume cs:_text$mn
.text$mn:00007800                 ;org 7800h
.text$mn:00007800 ; COMDAT (pick any)
.text$mn:00007800                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007800
.text$mn:00007800 ; =============== S U B R O U T I N E =======================================
.text$mn:00007800
.text$mn:00007800 ; Attributes: bp-based frame
.text$mn:00007800
.text$mn:00007800 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00007800                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00007800 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00007800                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00007800
.text$mn:00007800 Size            = dword ptr -8
.text$mn:00007800 var_4           = dword ptr -4
.text$mn:00007800 arg_0           = dword ptr  8
.text$mn:00007800 arg_4           = dword ptr  0Ch
.text$mn:00007800 arg_8           = dword ptr  10h
.text$mn:00007800
.text$mn:00007800                 push    ebp
.text$mn:00007801                 mov     ebp, esp
.text$mn:00007803                 sub     esp, 8
.text$mn:00007806                 mov     [ebp+var_4], ecx
.text$mn:00007809                 mov     ecx, [ebp+arg_0]
.text$mn:0000780C                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00007811                 cmp     eax, [ebp+arg_4]
.text$mn:00007814                 jnb     short loc_781E
.text$mn:00007816                 mov     ecx, [ebp+var_4]
.text$mn:00007819                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000781E
.text$mn:0000781E loc_781E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000781E                 mov     ecx, [ebp+arg_0]
.text$mn:00007821                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00007826                 sub     eax, [ebp+arg_4]
.text$mn:00007829                 mov     [ebp+Size], eax
.text$mn:0000782C                 mov     eax, [ebp+arg_8]
.text$mn:0000782F                 cmp     eax, [ebp+Size]
.text$mn:00007832                 jnb     short loc_783A
.text$mn:00007834                 mov     ecx, [ebp+arg_8]
.text$mn:00007837                 mov     [ebp+Size], ecx
.text$mn:0000783A
.text$mn:0000783A loc_783A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000783A                 mov     edx, [ebp+var_4]
.text$mn:0000783D                 cmp     edx, [ebp+arg_0]
.text$mn:00007840                 jnz     short loc_7861
.text$mn:00007842                 mov     eax, [ebp+arg_4]
.text$mn:00007845                 add     eax, [ebp+Size]
.text$mn:00007848                 push    eax
.text$mn:00007849                 mov     ecx, [ebp+var_4]
.text$mn:0000784C                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00007851                 mov     ecx, [ebp+arg_4]
.text$mn:00007854                 push    ecx
.text$mn:00007855                 push    0
.text$mn:00007857                 mov     ecx, [ebp+var_4]
.text$mn:0000785A                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000785F                 jmp     short loc_78A3
.text$mn:00007861 ; ---------------------------------------------------------------------------
.text$mn:00007861
.text$mn:00007861 loc_7861:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00007861                 push    0
.text$mn:00007863                 mov     edx, [ebp+Size]
.text$mn:00007866                 push    edx
.text$mn:00007867                 mov     ecx, [ebp+var_4]
.text$mn:0000786A                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000786F                 movzx   eax, al
.text$mn:00007872                 test    eax, eax
.text$mn:00007874                 jz      short loc_78A3
.text$mn:00007876                 mov     ecx, [ebp+Size]
.text$mn:00007879                 push    ecx             ; Size
.text$mn:0000787A                 mov     ecx, [ebp+arg_0]
.text$mn:0000787D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007882                 add     eax, [ebp+arg_4]
.text$mn:00007885                 push    eax             ; Src
.text$mn:00007886                 mov     ecx, [ebp+var_4]
.text$mn:00007889                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000788E                 push    eax             ; Dst
.text$mn:0000788F                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007894                 add     esp, 0Ch
.text$mn:00007897                 mov     edx, [ebp+Size]
.text$mn:0000789A                 push    edx
.text$mn:0000789B                 mov     ecx, [ebp+var_4]
.text$mn:0000789E                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000078A3
.text$mn:000078A3 loc_78A3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000078A3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000078A3                 mov     eax, [ebp+var_4]
.text$mn:000078A6                 mov     esp, ebp
.text$mn:000078A8                 pop     ebp
.text$mn:000078A9                 retn    0Ch
.text$mn:000078A9 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000078A9
.text$mn:000078A9 _text$mn        ends
.text$mn:000078A9
.text$mn:000078AC ; ===========================================================================
.text$mn:000078AC
.text$mn:000078AC ; Segment type: Pure code
.text$mn:000078AC ; Segment permissions: Read/Execute
.text$mn:000078AC _text$mn        segment para public 'CODE' use32
.text$mn:000078AC                 assume cs:_text$mn
.text$mn:000078AC                 ;org 78ACh
.text$mn:000078AC ; COMDAT (pick any)
.text$mn:000078AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078AC
.text$mn:000078AC ; =============== S U B R O U T I N E =======================================
.text$mn:000078AC
.text$mn:000078AC ; Attributes: bp-based frame
.text$mn:000078AC
.text$mn:000078AC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000078AC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000078AC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000078AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000078AC
.text$mn:000078AC var_4           = dword ptr -4
.text$mn:000078AC Str             = dword ptr  8
.text$mn:000078AC
.text$mn:000078AC                 push    ebp
.text$mn:000078AD                 mov     ebp, esp
.text$mn:000078AF                 push    ecx
.text$mn:000078B0                 mov     [ebp+var_4], ecx
.text$mn:000078B3                 push    490h            ; unsigned int
.text$mn:000078B8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000078BD                 mov     eax, [ebp+Str]
.text$mn:000078C0                 push    eax             ; int
.text$mn:000078C1                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000078C6                 add     esp, 0Ch
.text$mn:000078C9                 mov     ecx, [ebp+Str]
.text$mn:000078CC                 push    ecx             ; Str
.text$mn:000078CD                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000078D2                 add     esp, 4
.text$mn:000078D5                 push    eax             ; Size
.text$mn:000078D6                 mov     edx, [ebp+Str]
.text$mn:000078D9                 push    edx             ; Src
.text$mn:000078DA                 mov     ecx, [ebp+var_4]
.text$mn:000078DD                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:000078E2                 mov     esp, ebp
.text$mn:000078E4                 pop     ebp
.text$mn:000078E5                 retn    4
.text$mn:000078E5 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000078E5
.text$mn:000078E5 _text$mn        ends
.text$mn:000078E5
.text$mn:000078E8 ; ===========================================================================
.text$mn:000078E8
.text$mn:000078E8 ; Segment type: Pure code
.text$mn:000078E8 ; Segment permissions: Read/Execute
.text$mn:000078E8 _text$mn        segment para public 'CODE' use32
.text$mn:000078E8                 assume cs:_text$mn
.text$mn:000078E8                 ;org 78E8h
.text$mn:000078E8 ; COMDAT (pick any)
.text$mn:000078E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078E8
.text$mn:000078E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000078E8
.text$mn:000078E8 ; Attributes: bp-based frame
.text$mn:000078E8
.text$mn:000078E8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:000078E8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:000078E8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:000078E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:000078E8
.text$mn:000078E8 var_4           = dword ptr -4
.text$mn:000078E8 Src             = dword ptr  8
.text$mn:000078E8 Size            = dword ptr  0Ch
.text$mn:000078E8
.text$mn:000078E8                 push    ebp
.text$mn:000078E9                 mov     ebp, esp
.text$mn:000078EB                 push    ecx
.text$mn:000078EC                 mov     [ebp+var_4], ecx
.text$mn:000078EF                 cmp     [ebp+Size], 0
.text$mn:000078F3                 jz      short loc_790B
.text$mn:000078F5                 push    47Fh            ; unsigned int
.text$mn:000078FA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000078FF                 mov     eax, [ebp+Src]
.text$mn:00007902                 push    eax             ; int
.text$mn:00007903                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00007908                 add     esp, 0Ch
.text$mn:0000790B
.text$mn:0000790B loc_790B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000790B                 mov     ecx, [ebp+Src]
.text$mn:0000790E                 push    ecx
.text$mn:0000790F                 mov     ecx, [ebp+var_4]
.text$mn:00007912                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00007917                 movzx   edx, al
.text$mn:0000791A                 test    edx, edx
.text$mn:0000791C                 jz      short loc_793E
.text$mn:0000791E                 mov     eax, [ebp+Size]
.text$mn:00007921                 push    eax
.text$mn:00007922                 mov     ecx, [ebp+var_4]
.text$mn:00007925                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000792A                 mov     ecx, [ebp+Src]
.text$mn:0000792D                 sub     ecx, eax
.text$mn:0000792F                 push    ecx
.text$mn:00007930                 mov     edx, [ebp+var_4]
.text$mn:00007933                 push    edx
.text$mn:00007934                 mov     ecx, [ebp+var_4]
.text$mn:00007937                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:0000793C                 jmp     short loc_797B
.text$mn:0000793E ; ---------------------------------------------------------------------------
.text$mn:0000793E
.text$mn:0000793E loc_793E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000793E                 push    0
.text$mn:00007940                 mov     eax, [ebp+Size]
.text$mn:00007943                 push    eax
.text$mn:00007944                 mov     ecx, [ebp+var_4]
.text$mn:00007947                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000794C                 movzx   ecx, al
.text$mn:0000794F                 test    ecx, ecx
.text$mn:00007951                 jz      short loc_7978
.text$mn:00007953                 mov     edx, [ebp+Size]
.text$mn:00007956                 push    edx             ; Size
.text$mn:00007957                 mov     eax, [ebp+Src]
.text$mn:0000795A                 push    eax             ; Src
.text$mn:0000795B                 mov     ecx, [ebp+var_4]
.text$mn:0000795E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007963                 push    eax             ; Dst
.text$mn:00007964                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007969                 add     esp, 0Ch
.text$mn:0000796C                 mov     ecx, [ebp+Size]
.text$mn:0000796F                 push    ecx
.text$mn:00007970                 mov     ecx, [ebp+var_4]
.text$mn:00007973                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007978
.text$mn:00007978 loc_7978:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00007978                 mov     eax, [ebp+var_4]
.text$mn:0000797B
.text$mn:0000797B loc_797B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000797B                 mov     esp, ebp
.text$mn:0000797D                 pop     ebp
.text$mn:0000797E                 retn    8
.text$mn:0000797E ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000797E
.text$mn:0000797E ; ---------------------------------------------------------------------------
.text$mn:00007981                 align 4
.text$mn:00007981 _text$mn        ends
.text$mn:00007981
.text$mn:00007984 ; ===========================================================================
.text$mn:00007984
.text$mn:00007984 ; Segment type: Pure code
.text$mn:00007984 ; Segment permissions: Read/Execute
.text$mn:00007984 _text$mn        segment para public 'CODE' use32
.text$mn:00007984                 assume cs:_text$mn
.text$mn:00007984                 ;org 7984h
.text$mn:00007984 ; COMDAT (pick any)
.text$mn:00007984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007984
.text$mn:00007984 ; =============== S U B R O U T I N E =======================================
.text$mn:00007984
.text$mn:00007984 ; Attributes: bp-based frame
.text$mn:00007984
.text$mn:00007984 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00007984                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00007984 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00007984                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00007984
.text$mn:00007984 arg_0           = dword ptr  8
.text$mn:00007984 arg_4           = dword ptr  0Ch
.text$mn:00007984
.text$mn:00007984                 push    ebp
.text$mn:00007985                 mov     ebp, esp
.text$mn:00007987                 mov     eax, [ebp+arg_0]
.text$mn:0000798A                 mov     ecx, [ebp+arg_4]
.text$mn:0000798D                 mov     dl, [ecx]
.text$mn:0000798F                 mov     [eax], dl
.text$mn:00007991                 pop     ebp
.text$mn:00007992                 retn
.text$mn:00007992 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00007992
.text$mn:00007992 ; ---------------------------------------------------------------------------
.text$mn:00007993                 align 4
.text$mn:00007993 _text$mn        ends
.text$mn:00007993
.text$mn:00007994 ; ===========================================================================
.text$mn:00007994
.text$mn:00007994 ; Segment type: Pure code
.text$mn:00007994 ; Segment permissions: Read/Execute
.text$mn:00007994 _text$mn        segment para public 'CODE' use32
.text$mn:00007994                 assume cs:_text$mn
.text$mn:00007994                 ;org 7994h
.text$mn:00007994 ; COMDAT (pick any)
.text$mn:00007994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007994
.text$mn:00007994 ; =============== S U B R O U T I N E =======================================
.text$mn:00007994
.text$mn:00007994 ; Attributes: bp-based frame
.text$mn:00007994
.text$mn:00007994 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>> __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::begin(void)const
.text$mn:00007994                 public ?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ
.text$mn:00007994 ?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ proc near
.text$mn:00007994                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+A7p
.text$mn:00007994
.text$mn:00007994 var_14          = dword ptr -14h
.text$mn:00007994 var_10          = dword ptr -10h
.text$mn:00007994 var_C           = dword ptr -0Ch
.text$mn:00007994 var_4           = dword ptr -4
.text$mn:00007994 arg_0           = dword ptr  8
.text$mn:00007994
.text$mn:00007994                 push    ebp
.text$mn:00007995                 mov     ebp, esp
.text$mn:00007997                 push    0FFFFFFFFh
.text$mn:00007999                 push    offset __ehhandler$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ
.text$mn:0000799E                 mov     eax, large fs:0
.text$mn:000079A4                 push    eax
.text$mn:000079A5                 sub     esp, 8
.text$mn:000079A8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000079AD                 xor     eax, ebp
.text$mn:000079AF                 push    eax
.text$mn:000079B0                 lea     eax, [ebp+var_C]
.text$mn:000079B3                 mov     large fs:0, eax
.text$mn:000079B9                 mov     [ebp+var_10], ecx
.text$mn:000079BC                 mov     [ebp+var_14], 0
.text$mn:000079C3                 mov     eax, [ebp+var_10]
.text$mn:000079C6                 push    eax             ; struct std::_Container_base12 *
.text$mn:000079C7                 mov     ecx, [ebp+var_10]
.text$mn:000079CA                 mov     edx, [ecx+4]
.text$mn:000079CD                 push    edx             ; int
.text$mn:000079CE                 mov     ecx, [ebp+arg_0]
.text$mn:000079D1                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(tTbData * *,std::_Container_base12 const *)
.text$mn:000079D6                 mov     [ebp+var_4], 0
.text$mn:000079DD                 mov     eax, [ebp+var_14]
.text$mn:000079E0                 or      eax, 1
.text$mn:000079E3                 mov     [ebp+var_14], eax
.text$mn:000079E6                 mov     eax, [ebp+arg_0]
.text$mn:000079E9                 mov     ecx, [ebp+var_C]
.text$mn:000079EC                 mov     large fs:0, ecx
.text$mn:000079F3                 pop     ecx
.text$mn:000079F4                 mov     esp, ebp
.text$mn:000079F6                 pop     ebp
.text$mn:000079F7                 retn    4
.text$mn:000079F7 ?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ endp
.text$mn:000079F7
.text$mn:000079F7 ; ---------------------------------------------------------------------------
.text$mn:000079FA                 align 4
.text$mn:000079FA _text$mn        ends
.text$mn:000079FA
.text$x:000079FC ; ===========================================================================
.text$x:000079FC
.text$x:000079FC ; Segment type: Pure code
.text$x:000079FC ; Segment permissions: Read/Execute
.text$x:000079FC _text$x         segment para public 'CODE' use32
.text$x:000079FC                 assume cs:_text$x
.text$x:000079FC                 ;org 79FCh
.text$x:000079FC ; COMDAT (pick associative to section at 7994)
.text$x:000079FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000079FC
.text$x:000079FC ; =============== S U B R O U T I N E =======================================
.text$x:000079FC
.text$x:000079FC
.text$x:000079FC __unwindfunclet$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ$0 proc near
.text$x:000079FC                                         ; DATA XREF: .xdata$x:0000920Co
.text$x:000079FC                 mov     eax, [ebp-14h]
.text$x:000079FF                 and     eax, 1
.text$x:00007A02                 jz      $LN4_0
.text$x:00007A08                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00007A0C                 mov     ecx, [ebp+8]
.text$x:00007A0F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:00007A14 ; ---------------------------------------------------------------------------
.text$x:00007A14
.text$x:00007A14 $LN4_0:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ$0+6j
.text$x:00007A14                 retn
.text$x:00007A14 __unwindfunclet$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ$0 endp
.text$x:00007A14
.text$x:00007A15
.text$x:00007A15 ; =============== S U B R O U T I N E =======================================
.text$x:00007A15
.text$x:00007A15
.text$x:00007A15 __ehhandler$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ proc near
.text$x:00007A15                                         ; DATA XREF: std::vector<tTbData *,std::allocator<tTbData *>>::begin(void)+5o
.text$x:00007A15
.text$x:00007A15 arg_4           = dword ptr  8
.text$x:00007A15
.text$x:00007A15                 mov     edx, [esp+arg_4]
.text$x:00007A19                 lea     eax, [edx+0Ch]
.text$x:00007A1C                 mov     ecx, [edx-0Ch]
.text$x:00007A1F                 xor     ecx, eax
.text$x:00007A21                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007A26                 mov     eax, offset __ehfuncinfo$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ
.text$x:00007A2B                 jmp     ___CxxFrameHandler3
.text$x:00007A2B __ehhandler$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ endp
.text$x:00007A2B
.text$x:00007A2B _text$x         ends
.text$x:00007A2B
.text$mn:00007A30 ; ===========================================================================
.text$mn:00007A30
.text$mn:00007A30 ; Segment type: Pure code
.text$mn:00007A30 ; Segment permissions: Read/Execute
.text$mn:00007A30 _text$mn        segment para public 'CODE' use32
.text$mn:00007A30                 assume cs:_text$mn
.text$mn:00007A30                 ;org 7A30h
.text$mn:00007A30 ; COMDAT (pick any)
.text$mn:00007A30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A30
.text$mn:00007A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A30
.text$mn:00007A30 ; Attributes: bp-based frame
.text$mn:00007A30
.text$mn:00007A30 ; public: unsigned int __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::capacity(void)const
.text$mn:00007A30                 public ?capacity@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ
.text$mn:00007A30 ?capacity@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ proc near
.text$mn:00007A30                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Grow_to(uint)+Cp
.text$mn:00007A30
.text$mn:00007A30 var_4           = dword ptr -4
.text$mn:00007A30
.text$mn:00007A30                 push    ebp
.text$mn:00007A31                 mov     ebp, esp
.text$mn:00007A33                 push    ecx
.text$mn:00007A34                 mov     [ebp+var_4], ecx
.text$mn:00007A37                 mov     eax, [ebp+var_4]
.text$mn:00007A3A                 mov     ecx, [ebp+var_4]
.text$mn:00007A3D                 mov     eax, [eax+0Ch]
.text$mn:00007A40                 sub     eax, [ecx+4]
.text$mn:00007A43                 sar     eax, 2
.text$mn:00007A46                 mov     esp, ebp
.text$mn:00007A48                 pop     ebp
.text$mn:00007A49                 retn
.text$mn:00007A49 ?capacity@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ endp
.text$mn:00007A49
.text$mn:00007A49 ; ---------------------------------------------------------------------------
.text$mn:00007A4A                 align 4
.text$mn:00007A4A _text$mn        ends
.text$mn:00007A4A
.text$mn:00007A4C ; ===========================================================================
.text$mn:00007A4C
.text$mn:00007A4C ; Segment type: Pure code
.text$mn:00007A4C ; Segment permissions: Read/Execute
.text$mn:00007A4C _text$mn        segment para public 'CODE' use32
.text$mn:00007A4C                 assume cs:_text$mn
.text$mn:00007A4C                 ;org 7A4Ch
.text$mn:00007A4C ; COMDAT (pick any)
.text$mn:00007A4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A4C
.text$mn:00007A4C ; =============== S U B R O U T I N E =======================================
.text$mn:00007A4C
.text$mn:00007A4C ; Attributes: bp-based frame
.text$mn:00007A4C
.text$mn:00007A4C ; public: unsigned int __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::capacity(void)const
.text$mn:00007A4C                 public ?capacity@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ
.text$mn:00007A4C ?capacity@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ proc near
.text$mn:00007A4C                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Grow_to(uint)+Cp
.text$mn:00007A4C
.text$mn:00007A4C var_4           = dword ptr -4
.text$mn:00007A4C
.text$mn:00007A4C                 push    ebp
.text$mn:00007A4D                 mov     ebp, esp
.text$mn:00007A4F                 push    ecx
.text$mn:00007A50                 mov     [ebp+var_4], ecx
.text$mn:00007A53                 mov     eax, [ebp+var_4]
.text$mn:00007A56                 mov     ecx, [ebp+var_4]
.text$mn:00007A59                 mov     eax, [eax+0Ch]
.text$mn:00007A5C                 sub     eax, [ecx+4]
.text$mn:00007A5F                 sar     eax, 2
.text$mn:00007A62                 mov     esp, ebp
.text$mn:00007A64                 pop     ebp
.text$mn:00007A65                 retn
.text$mn:00007A65 ?capacity@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ endp
.text$mn:00007A65
.text$mn:00007A65 ; ---------------------------------------------------------------------------
.text$mn:00007A66                 align 4
.text$mn:00007A66 _text$mn        ends
.text$mn:00007A66
.text$mn:00007A68 ; ===========================================================================
.text$mn:00007A68
.text$mn:00007A68 ; Segment type: Pure code
.text$mn:00007A68 ; Segment permissions: Read/Execute
.text$mn:00007A68 _text$mn        segment para public 'CODE' use32
.text$mn:00007A68                 assume cs:_text$mn
.text$mn:00007A68                 ;org 7A68h
.text$mn:00007A68 ; COMDAT (pick any)
.text$mn:00007A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A68
.text$mn:00007A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A68
.text$mn:00007A68 ; Attributes: bp-based frame
.text$mn:00007A68
.text$mn:00007A68 ; public: unsigned int __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::capacity(void)const
.text$mn:00007A68                 public ?capacity@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ
.text$mn:00007A68 ?capacity@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ proc near
.text$mn:00007A68                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Grow_to(uint)+Cp
.text$mn:00007A68
.text$mn:00007A68 var_4           = dword ptr -4
.text$mn:00007A68
.text$mn:00007A68                 push    ebp
.text$mn:00007A69                 mov     ebp, esp
.text$mn:00007A6B                 push    ecx
.text$mn:00007A6C                 mov     [ebp+var_4], ecx
.text$mn:00007A6F                 mov     eax, [ebp+var_4]
.text$mn:00007A72                 mov     ecx, [ebp+var_4]
.text$mn:00007A75                 mov     eax, [eax+0Ch]
.text$mn:00007A78                 sub     eax, [ecx+4]
.text$mn:00007A7B                 sar     eax, 2
.text$mn:00007A7E                 mov     esp, ebp
.text$mn:00007A80                 pop     ebp
.text$mn:00007A81                 retn
.text$mn:00007A81 ?capacity@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ endp
.text$mn:00007A81
.text$mn:00007A81 ; ---------------------------------------------------------------------------
.text$mn:00007A82                 align 4
.text$mn:00007A82 _text$mn        ends
.text$mn:00007A82
.text$mn:00007A84 ; ===========================================================================
.text$mn:00007A84
.text$mn:00007A84 ; Segment type: Pure code
.text$mn:00007A84 ; Segment permissions: Read/Execute
.text$mn:00007A84 _text$mn        segment para public 'CODE' use32
.text$mn:00007A84                 assume cs:_text$mn
.text$mn:00007A84                 ;org 7A84h
.text$mn:00007A84 ; COMDAT (pick any)
.text$mn:00007A84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A84
.text$mn:00007A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A84
.text$mn:00007A84 ; Attributes: bp-based frame
.text$mn:00007A84
.text$mn:00007A84 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00007A84                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00007A84 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00007A84                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00007A84
.text$mn:00007A84 var_4           = dword ptr -4
.text$mn:00007A84
.text$mn:00007A84                 push    ebp
.text$mn:00007A85                 mov     ebp, esp
.text$mn:00007A87                 push    ecx
.text$mn:00007A88                 mov     [ebp+var_4], ecx
.text$mn:00007A8B                 mov     eax, [ebp+var_4]
.text$mn:00007A8E                 mov     eax, [eax+4]
.text$mn:00007A91                 mov     esp, ebp
.text$mn:00007A93                 pop     ebp
.text$mn:00007A94                 retn
.text$mn:00007A94 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00007A94
.text$mn:00007A94 ; ---------------------------------------------------------------------------
.text$mn:00007A95                 align 4
.text$mn:00007A95 _text$mn        ends
.text$mn:00007A95
.text$mn:00007A98 ; ===========================================================================
.text$mn:00007A98
.text$mn:00007A98 ; Segment type: Pure code
.text$mn:00007A98 ; Segment permissions: Read/Execute
.text$mn:00007A98 _text$mn        segment para public 'CODE' use32
.text$mn:00007A98                 assume cs:_text$mn
.text$mn:00007A98                 ;org 7A98h
.text$mn:00007A98 ; COMDAT (pick any)
.text$mn:00007A98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A98
.text$mn:00007A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A98
.text$mn:00007A98 ; Attributes: bp-based frame
.text$mn:00007A98
.text$mn:00007A98 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00007A98                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00007A98 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00007A98                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00007A98                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00007A98
.text$mn:00007A98 var_4           = dword ptr -4
.text$mn:00007A98
.text$mn:00007A98                 push    ebp
.text$mn:00007A99                 mov     ebp, esp
.text$mn:00007A9B                 push    ecx
.text$mn:00007A9C                 mov     [ebp+var_4], ecx
.text$mn:00007A9F                 mov     eax, [ebp+var_4]
.text$mn:00007AA2                 mov     eax, [eax+4]
.text$mn:00007AA5                 mov     esp, ebp
.text$mn:00007AA7                 pop     ebp
.text$mn:00007AA8                 retn
.text$mn:00007AA8 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00007AA8
.text$mn:00007AA8 ; ---------------------------------------------------------------------------
.text$mn:00007AA9                 align 4
.text$mn:00007AA9 _text$mn        ends
.text$mn:00007AA9
.text$mn:00007AAC ; ===========================================================================
.text$mn:00007AAC
.text$mn:00007AAC ; Segment type: Pure code
.text$mn:00007AAC ; Segment permissions: Read/Execute
.text$mn:00007AAC _text$mn        segment para public 'CODE' use32
.text$mn:00007AAC                 assume cs:_text$mn
.text$mn:00007AAC                 ;org 7AACh
.text$mn:00007AAC ; COMDAT (pick any)
.text$mn:00007AAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AAC
.text$mn:00007AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00007AAC
.text$mn:00007AAC ; Attributes: bp-based frame
.text$mn:00007AAC
.text$mn:00007AAC ; int __stdcall std::allocator<HWND__ *>::construct(void *, int)
.text$mn:00007AAC                 public ?construct@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@ABQAU3@@Z
.text$mn:00007AAC ?construct@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@ABQAU3@@Z proc near
.text$mn:00007AAC                                         ; CODE XREF: std::allocator_traits<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * const &>(std::allocator<HWND__ *> &,HWND__ * *,HWND__ * const &)+17p
.text$mn:00007AAC
.text$mn:00007AAC var_C           = dword ptr -0Ch
.text$mn:00007AAC var_8           = dword ptr -8
.text$mn:00007AAC var_4           = dword ptr -4
.text$mn:00007AAC arg_0           = dword ptr  8
.text$mn:00007AAC arg_4           = dword ptr  0Ch
.text$mn:00007AAC
.text$mn:00007AAC                 push    ebp
.text$mn:00007AAD                 mov     ebp, esp
.text$mn:00007AAF                 sub     esp, 0Ch
.text$mn:00007AB2                 mov     [ebp+var_C], ecx
.text$mn:00007AB5                 mov     eax, [ebp+arg_0]
.text$mn:00007AB8                 push    eax             ; void *
.text$mn:00007AB9                 push    4               ; unsigned int
.text$mn:00007ABB                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00007AC0                 add     esp, 8
.text$mn:00007AC3                 mov     [ebp+var_4], eax
.text$mn:00007AC6                 cmp     [ebp+var_4], 0
.text$mn:00007ACA                 jz      short loc_7ADE
.text$mn:00007ACC                 mov     ecx, [ebp+var_4]
.text$mn:00007ACF                 mov     edx, [ebp+arg_4]
.text$mn:00007AD2                 mov     eax, [edx]
.text$mn:00007AD4                 mov     [ecx], eax
.text$mn:00007AD6                 mov     ecx, [ebp+var_4]
.text$mn:00007AD9                 mov     [ebp+var_8], ecx
.text$mn:00007ADC                 jmp     short loc_7AE5
.text$mn:00007ADE ; ---------------------------------------------------------------------------
.text$mn:00007ADE
.text$mn:00007ADE loc_7ADE:                               ; CODE XREF: std::allocator<HWND__ *>::construct(HWND__ * *,HWND__ * const &)+1Ej
.text$mn:00007ADE                 mov     [ebp+var_8], 0
.text$mn:00007AE5
.text$mn:00007AE5 loc_7AE5:                               ; CODE XREF: std::allocator<HWND__ *>::construct(HWND__ * *,HWND__ * const &)+30j
.text$mn:00007AE5                 mov     esp, ebp
.text$mn:00007AE7                 pop     ebp
.text$mn:00007AE8                 retn    8
.text$mn:00007AE8 ?construct@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@ABQAU3@@Z endp
.text$mn:00007AE8
.text$mn:00007AE8 ; ---------------------------------------------------------------------------
.text$mn:00007AEB                 align 4
.text$mn:00007AEB _text$mn        ends
.text$mn:00007AEB
.text$mn:00007AEC ; ===========================================================================
.text$mn:00007AEC
.text$mn:00007AEC ; Segment type: Pure code
.text$mn:00007AEC ; Segment permissions: Read/Execute
.text$mn:00007AEC _text$mn        segment para public 'CODE' use32
.text$mn:00007AEC                 assume cs:_text$mn
.text$mn:00007AEC                 ;org 7AECh
.text$mn:00007AEC ; COMDAT (pick any)
.text$mn:00007AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AEC
.text$mn:00007AEC ; =============== S U B R O U T I N E =======================================
.text$mn:00007AEC
.text$mn:00007AEC ; Attributes: bp-based frame
.text$mn:00007AEC
.text$mn:00007AEC ; int __stdcall std::allocator<DockingCont *>::construct(void *, int)
.text$mn:00007AEC                 public ?construct@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@ABQAV3@@Z
.text$mn:00007AEC ?construct@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@ABQAV3@@Z proc near
.text$mn:00007AEC                                         ; CODE XREF: std::allocator_traits<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * const &>(std::allocator<DockingCont *> &,DockingCont * *,DockingCont * const &)+17p
.text$mn:00007AEC
.text$mn:00007AEC var_C           = dword ptr -0Ch
.text$mn:00007AEC var_8           = dword ptr -8
.text$mn:00007AEC var_4           = dword ptr -4
.text$mn:00007AEC arg_0           = dword ptr  8
.text$mn:00007AEC arg_4           = dword ptr  0Ch
.text$mn:00007AEC
.text$mn:00007AEC                 push    ebp
.text$mn:00007AED                 mov     ebp, esp
.text$mn:00007AEF                 sub     esp, 0Ch
.text$mn:00007AF2                 mov     [ebp+var_C], ecx
.text$mn:00007AF5                 mov     eax, [ebp+arg_0]
.text$mn:00007AF8                 push    eax             ; void *
.text$mn:00007AF9                 push    4               ; unsigned int
.text$mn:00007AFB                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00007B00                 add     esp, 8
.text$mn:00007B03                 mov     [ebp+var_4], eax
.text$mn:00007B06                 cmp     [ebp+var_4], 0
.text$mn:00007B0A                 jz      short loc_7B1E
.text$mn:00007B0C                 mov     ecx, [ebp+var_4]
.text$mn:00007B0F                 mov     edx, [ebp+arg_4]
.text$mn:00007B12                 mov     eax, [edx]
.text$mn:00007B14                 mov     [ecx], eax
.text$mn:00007B16                 mov     ecx, [ebp+var_4]
.text$mn:00007B19                 mov     [ebp+var_8], ecx
.text$mn:00007B1C                 jmp     short loc_7B25
.text$mn:00007B1E ; ---------------------------------------------------------------------------
.text$mn:00007B1E
.text$mn:00007B1E loc_7B1E:                               ; CODE XREF: std::allocator<DockingCont *>::construct(DockingCont * *,DockingCont * const &)+1Ej
.text$mn:00007B1E                 mov     [ebp+var_8], 0
.text$mn:00007B25
.text$mn:00007B25 loc_7B25:                               ; CODE XREF: std::allocator<DockingCont *>::construct(DockingCont * *,DockingCont * const &)+30j
.text$mn:00007B25                 mov     esp, ebp
.text$mn:00007B27                 pop     ebp
.text$mn:00007B28                 retn    8
.text$mn:00007B28 ?construct@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@ABQAV3@@Z endp
.text$mn:00007B28
.text$mn:00007B28 ; ---------------------------------------------------------------------------
.text$mn:00007B2B                 align 4
.text$mn:00007B2B _text$mn        ends
.text$mn:00007B2B
.text$mn:00007B2C ; ===========================================================================
.text$mn:00007B2C
.text$mn:00007B2C ; Segment type: Pure code
.text$mn:00007B2C ; Segment permissions: Read/Execute
.text$mn:00007B2C _text$mn        segment para public 'CODE' use32
.text$mn:00007B2C                 assume cs:_text$mn
.text$mn:00007B2C                 ;org 7B2Ch
.text$mn:00007B2C ; COMDAT (pick any)
.text$mn:00007B2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B2C
.text$mn:00007B2C ; =============== S U B R O U T I N E =======================================
.text$mn:00007B2C
.text$mn:00007B2C ; Attributes: bp-based frame
.text$mn:00007B2C
.text$mn:00007B2C ; int __stdcall std::allocator<DockingSplitter *>::construct(void *, int)
.text$mn:00007B2C                 public ?construct@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@ABQAV3@@Z
.text$mn:00007B2C ?construct@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@ABQAV3@@Z proc near
.text$mn:00007B2C                                         ; CODE XREF: std::allocator_traits<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * const &>(std::allocator<DockingSplitter *> &,DockingSplitter * *,DockingSplitter * const &)+17p
.text$mn:00007B2C
.text$mn:00007B2C var_C           = dword ptr -0Ch
.text$mn:00007B2C var_8           = dword ptr -8
.text$mn:00007B2C var_4           = dword ptr -4
.text$mn:00007B2C arg_0           = dword ptr  8
.text$mn:00007B2C arg_4           = dword ptr  0Ch
.text$mn:00007B2C
.text$mn:00007B2C                 push    ebp
.text$mn:00007B2D                 mov     ebp, esp
.text$mn:00007B2F                 sub     esp, 0Ch
.text$mn:00007B32                 mov     [ebp+var_C], ecx
.text$mn:00007B35                 mov     eax, [ebp+arg_0]
.text$mn:00007B38                 push    eax             ; void *
.text$mn:00007B39                 push    4               ; unsigned int
.text$mn:00007B3B                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00007B40                 add     esp, 8
.text$mn:00007B43                 mov     [ebp+var_4], eax
.text$mn:00007B46                 cmp     [ebp+var_4], 0
.text$mn:00007B4A                 jz      short loc_7B5E
.text$mn:00007B4C                 mov     ecx, [ebp+var_4]
.text$mn:00007B4F                 mov     edx, [ebp+arg_4]
.text$mn:00007B52                 mov     eax, [edx]
.text$mn:00007B54                 mov     [ecx], eax
.text$mn:00007B56                 mov     ecx, [ebp+var_4]
.text$mn:00007B59                 mov     [ebp+var_8], ecx
.text$mn:00007B5C                 jmp     short loc_7B65
.text$mn:00007B5E ; ---------------------------------------------------------------------------
.text$mn:00007B5E
.text$mn:00007B5E loc_7B5E:                               ; CODE XREF: std::allocator<DockingSplitter *>::construct(DockingSplitter * *,DockingSplitter * const &)+1Ej
.text$mn:00007B5E                 mov     [ebp+var_8], 0
.text$mn:00007B65
.text$mn:00007B65 loc_7B65:                               ; CODE XREF: std::allocator<DockingSplitter *>::construct(DockingSplitter * *,DockingSplitter * const &)+30j
.text$mn:00007B65                 mov     esp, ebp
.text$mn:00007B67                 pop     ebp
.text$mn:00007B68                 retn    8
.text$mn:00007B68 ?construct@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@ABQAV3@@Z endp
.text$mn:00007B68
.text$mn:00007B68 ; ---------------------------------------------------------------------------
.text$mn:00007B6B                 align 4
.text$mn:00007B6B _text$mn        ends
.text$mn:00007B6B
.text$mn:00007B6C ; ===========================================================================
.text$mn:00007B6C
.text$mn:00007B6C ; Segment type: Pure code
.text$mn:00007B6C ; Segment permissions: Read/Execute
.text$mn:00007B6C _text$mn        segment para public 'CODE' use32
.text$mn:00007B6C                 assume cs:_text$mn
.text$mn:00007B6C                 ;org 7B6Ch
.text$mn:00007B6C ; COMDAT (pick any)
.text$mn:00007B6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B6C
.text$mn:00007B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00007B6C
.text$mn:00007B6C ; Attributes: bp-based frame
.text$mn:00007B6C
.text$mn:00007B6C ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00007B6C                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00007B6C ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00007B6C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00007B6C
.text$mn:00007B6C var_4           = dword ptr -4
.text$mn:00007B6C Dst             = dword ptr  8
.text$mn:00007B6C Src             = dword ptr  0Ch
.text$mn:00007B6C Size            = dword ptr  10h
.text$mn:00007B6C
.text$mn:00007B6C                 push    ebp
.text$mn:00007B6D                 mov     ebp, esp
.text$mn:00007B6F                 push    ecx
.text$mn:00007B70                 cmp     [ebp+Size], 0
.text$mn:00007B74                 jnz     short loc_7B7E
.text$mn:00007B76                 mov     eax, [ebp+Dst]
.text$mn:00007B79                 mov     [ebp+var_4], eax
.text$mn:00007B7C                 jmp     short loc_7B95
.text$mn:00007B7E ; ---------------------------------------------------------------------------
.text$mn:00007B7E
.text$mn:00007B7E loc_7B7E:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00007B7E                 mov     ecx, [ebp+Size]
.text$mn:00007B81                 push    ecx             ; Size
.text$mn:00007B82                 mov     edx, [ebp+Src]
.text$mn:00007B85                 push    edx             ; Src
.text$mn:00007B86                 mov     eax, [ebp+Dst]
.text$mn:00007B89                 push    eax             ; Dst
.text$mn:00007B8A                 call    _memcpy
.text$mn:00007B8F                 add     esp, 0Ch
.text$mn:00007B92                 mov     [ebp+var_4], eax
.text$mn:00007B95
.text$mn:00007B95 loc_7B95:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00007B95                 mov     eax, [ebp+var_4]
.text$mn:00007B98                 mov     esp, ebp
.text$mn:00007B9A                 pop     ebp
.text$mn:00007B9B                 retn
.text$mn:00007B9B ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00007B9B
.text$mn:00007B9B _text$mn        ends
.text$mn:00007B9B
.text$mn:00007B9C ; ===========================================================================
.text$mn:00007B9C
.text$mn:00007B9C ; Segment type: Pure code
.text$mn:00007B9C ; Segment permissions: Read/Execute
.text$mn:00007B9C _text$mn        segment para public 'CODE' use32
.text$mn:00007B9C                 assume cs:_text$mn
.text$mn:00007B9C                 ;org 7B9Ch
.text$mn:00007B9C ; COMDAT (pick any)
.text$mn:00007B9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B9C
.text$mn:00007B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00007B9C
.text$mn:00007B9C ; Attributes: bp-based frame
.text$mn:00007B9C
.text$mn:00007B9C ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00007B9C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00007B9C ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00007B9C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00007B9C
.text$mn:00007B9C var_4           = dword ptr -4
.text$mn:00007B9C arg_0           = dword ptr  8
.text$mn:00007B9C arg_4           = dword ptr  0Ch
.text$mn:00007B9C
.text$mn:00007B9C                 push    ebp
.text$mn:00007B9D                 mov     ebp, esp
.text$mn:00007B9F                 push    ecx
.text$mn:00007BA0                 mov     [ebp+var_4], ecx
.text$mn:00007BA3                 mov     eax, [ebp+arg_4]
.text$mn:00007BA6                 push    eax             ; int
.text$mn:00007BA7                 mov     ecx, [ebp+arg_0]
.text$mn:00007BAA                 push    ecx             ; void *
.text$mn:00007BAB                 mov     ecx, [ebp+var_4]
.text$mn:00007BAE                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00007BB3                 mov     esp, ebp
.text$mn:00007BB5                 pop     ebp
.text$mn:00007BB6                 retn    8
.text$mn:00007BB6 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00007BB6
.text$mn:00007BB6 ; ---------------------------------------------------------------------------
.text$mn:00007BB9                 align 4
.text$mn:00007BB9 _text$mn        ends
.text$mn:00007BB9
.text$mn:00007BBC ; ===========================================================================
.text$mn:00007BBC
.text$mn:00007BBC ; Segment type: Pure code
.text$mn:00007BBC ; Segment permissions: Read/Execute
.text$mn:00007BBC _text$mn        segment para public 'CODE' use32
.text$mn:00007BBC                 assume cs:_text$mn
.text$mn:00007BBC                 ;org 7BBCh
.text$mn:00007BBC ; COMDAT (pick any)
.text$mn:00007BBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BBC
.text$mn:00007BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00007BBC
.text$mn:00007BBC ; Attributes: bp-based frame
.text$mn:00007BBC
.text$mn:00007BBC ; int __stdcall std::_Wrap_alloc<std::allocator<HWND__ *>>::deallocate(void *, int)
.text$mn:00007BBC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@I@Z
.text$mn:00007BBC ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@I@Z proc near
.text$mn:00007BBC                                         ; CODE XREF: __catch$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:00007BBC                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reallocate(uint)+F5p ...
.text$mn:00007BBC
.text$mn:00007BBC var_4           = dword ptr -4
.text$mn:00007BBC arg_0           = dword ptr  8
.text$mn:00007BBC arg_4           = dword ptr  0Ch
.text$mn:00007BBC
.text$mn:00007BBC                 push    ebp
.text$mn:00007BBD                 mov     ebp, esp
.text$mn:00007BBF                 push    ecx
.text$mn:00007BC0                 mov     [ebp+var_4], ecx
.text$mn:00007BC3                 mov     eax, [ebp+arg_4]
.text$mn:00007BC6                 push    eax             ; int
.text$mn:00007BC7                 mov     ecx, [ebp+arg_0]
.text$mn:00007BCA                 push    ecx             ; void *
.text$mn:00007BCB                 mov     ecx, [ebp+var_4]
.text$mn:00007BCE                 call    ?deallocate@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@I@Z ; std::allocator<HWND__ *>::deallocate(HWND__ * *,uint)
.text$mn:00007BD3                 mov     esp, ebp
.text$mn:00007BD5                 pop     ebp
.text$mn:00007BD6                 retn    8
.text$mn:00007BD6 ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@I@Z endp
.text$mn:00007BD6
.text$mn:00007BD6 ; ---------------------------------------------------------------------------
.text$mn:00007BD9                 align 4
.text$mn:00007BD9 _text$mn        ends
.text$mn:00007BD9
.text$mn:00007BDC ; ===========================================================================
.text$mn:00007BDC
.text$mn:00007BDC ; Segment type: Pure code
.text$mn:00007BDC ; Segment permissions: Read/Execute
.text$mn:00007BDC _text$mn        segment para public 'CODE' use32
.text$mn:00007BDC                 assume cs:_text$mn
.text$mn:00007BDC                 ;org 7BDCh
.text$mn:00007BDC ; COMDAT (pick any)
.text$mn:00007BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BDC
.text$mn:00007BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00007BDC
.text$mn:00007BDC ; Attributes: bp-based frame
.text$mn:00007BDC
.text$mn:00007BDC ; int __stdcall std::_Wrap_alloc<std::allocator<tTbData *>>::deallocate(void *, int)
.text$mn:00007BDC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAEXPAPAUtTbData@@I@Z
.text$mn:00007BDC ?deallocate@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAEXPAPAUtTbData@@I@Z proc near
.text$mn:00007BDC                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Tidy(void)+55p
.text$mn:00007BDC
.text$mn:00007BDC var_4           = dword ptr -4
.text$mn:00007BDC arg_0           = dword ptr  8
.text$mn:00007BDC arg_4           = dword ptr  0Ch
.text$mn:00007BDC
.text$mn:00007BDC                 push    ebp
.text$mn:00007BDD                 mov     ebp, esp
.text$mn:00007BDF                 push    ecx
.text$mn:00007BE0                 mov     [ebp+var_4], ecx
.text$mn:00007BE3                 mov     eax, [ebp+arg_4]
.text$mn:00007BE6                 push    eax             ; int
.text$mn:00007BE7                 mov     ecx, [ebp+arg_0]
.text$mn:00007BEA                 push    ecx             ; void *
.text$mn:00007BEB                 mov     ecx, [ebp+var_4]
.text$mn:00007BEE                 call    ?deallocate@?$allocator@PAUtTbData@@@std@@QAEXPAPAUtTbData@@I@Z ; std::allocator<tTbData *>::deallocate(tTbData * *,uint)
.text$mn:00007BF3                 mov     esp, ebp
.text$mn:00007BF5                 pop     ebp
.text$mn:00007BF6                 retn    8
.text$mn:00007BF6 ?deallocate@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAEXPAPAUtTbData@@I@Z endp
.text$mn:00007BF6
.text$mn:00007BF6 ; ---------------------------------------------------------------------------
.text$mn:00007BF9                 align 4
.text$mn:00007BF9 _text$mn        ends
.text$mn:00007BF9
.text$mn:00007BFC ; ===========================================================================
.text$mn:00007BFC
.text$mn:00007BFC ; Segment type: Pure code
.text$mn:00007BFC ; Segment permissions: Read/Execute
.text$mn:00007BFC _text$mn        segment para public 'CODE' use32
.text$mn:00007BFC                 assume cs:_text$mn
.text$mn:00007BFC                 ;org 7BFCh
.text$mn:00007BFC ; COMDAT (pick any)
.text$mn:00007BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BFC
.text$mn:00007BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00007BFC
.text$mn:00007BFC ; Attributes: bp-based frame
.text$mn:00007BFC
.text$mn:00007BFC ; int __stdcall std::_Wrap_alloc<std::allocator<DockingCont *>>::deallocate(void *, int)
.text$mn:00007BFC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@I@Z
.text$mn:00007BFC ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@I@Z proc near
.text$mn:00007BFC                                         ; CODE XREF: __catch$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:00007BFC                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reallocate(uint)+F5p ...
.text$mn:00007BFC
.text$mn:00007BFC var_4           = dword ptr -4
.text$mn:00007BFC arg_0           = dword ptr  8
.text$mn:00007BFC arg_4           = dword ptr  0Ch
.text$mn:00007BFC
.text$mn:00007BFC                 push    ebp
.text$mn:00007BFD                 mov     ebp, esp
.text$mn:00007BFF                 push    ecx
.text$mn:00007C00                 mov     [ebp+var_4], ecx
.text$mn:00007C03                 mov     eax, [ebp+arg_4]
.text$mn:00007C06                 push    eax             ; int
.text$mn:00007C07                 mov     ecx, [ebp+arg_0]
.text$mn:00007C0A                 push    ecx             ; void *
.text$mn:00007C0B                 mov     ecx, [ebp+var_4]
.text$mn:00007C0E                 call    ?deallocate@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@I@Z ; std::allocator<DockingCont *>::deallocate(DockingCont * *,uint)
.text$mn:00007C13                 mov     esp, ebp
.text$mn:00007C15                 pop     ebp
.text$mn:00007C16                 retn    8
.text$mn:00007C16 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@I@Z endp
.text$mn:00007C16
.text$mn:00007C16 ; ---------------------------------------------------------------------------
.text$mn:00007C19                 align 4
.text$mn:00007C19 _text$mn        ends
.text$mn:00007C19
.text$mn:00007C1C ; ===========================================================================
.text$mn:00007C1C
.text$mn:00007C1C ; Segment type: Pure code
.text$mn:00007C1C ; Segment permissions: Read/Execute
.text$mn:00007C1C _text$mn        segment para public 'CODE' use32
.text$mn:00007C1C                 assume cs:_text$mn
.text$mn:00007C1C                 ;org 7C1Ch
.text$mn:00007C1C ; COMDAT (pick any)
.text$mn:00007C1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C1C
.text$mn:00007C1C ; =============== S U B R O U T I N E =======================================
.text$mn:00007C1C
.text$mn:00007C1C ; Attributes: bp-based frame
.text$mn:00007C1C
.text$mn:00007C1C ; int __stdcall std::_Wrap_alloc<std::allocator<DockingSplitter *>>::deallocate(void *, int)
.text$mn:00007C1C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@I@Z
.text$mn:00007C1C ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@I@Z proc near
.text$mn:00007C1C                                         ; CODE XREF: __catch$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:00007C1C                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reallocate(uint)+F5p ...
.text$mn:00007C1C
.text$mn:00007C1C var_4           = dword ptr -4
.text$mn:00007C1C arg_0           = dword ptr  8
.text$mn:00007C1C arg_4           = dword ptr  0Ch
.text$mn:00007C1C
.text$mn:00007C1C                 push    ebp
.text$mn:00007C1D                 mov     ebp, esp
.text$mn:00007C1F                 push    ecx
.text$mn:00007C20                 mov     [ebp+var_4], ecx
.text$mn:00007C23                 mov     eax, [ebp+arg_4]
.text$mn:00007C26                 push    eax             ; int
.text$mn:00007C27                 mov     ecx, [ebp+arg_0]
.text$mn:00007C2A                 push    ecx             ; void *
.text$mn:00007C2B                 mov     ecx, [ebp+var_4]
.text$mn:00007C2E                 call    ?deallocate@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@I@Z ; std::allocator<DockingSplitter *>::deallocate(DockingSplitter * *,uint)
.text$mn:00007C33                 mov     esp, ebp
.text$mn:00007C35                 pop     ebp
.text$mn:00007C36                 retn    8
.text$mn:00007C36 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@I@Z endp
.text$mn:00007C36
.text$mn:00007C36 ; ---------------------------------------------------------------------------
.text$mn:00007C39                 align 4
.text$mn:00007C39 _text$mn        ends
.text$mn:00007C39
.text$mn:00007C3C ; ===========================================================================
.text$mn:00007C3C
.text$mn:00007C3C ; Segment type: Pure code
.text$mn:00007C3C ; Segment permissions: Read/Execute
.text$mn:00007C3C _text$mn        segment para public 'CODE' use32
.text$mn:00007C3C                 assume cs:_text$mn
.text$mn:00007C3C                 ;org 7C3Ch
.text$mn:00007C3C ; COMDAT (pick any)
.text$mn:00007C3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C3C
.text$mn:00007C3C ; =============== S U B R O U T I N E =======================================
.text$mn:00007C3C
.text$mn:00007C3C ; Attributes: bp-based frame
.text$mn:00007C3C
.text$mn:00007C3C ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:00007C3C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00007C3C ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00007C3C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Free_proxy(void)+32p
.text$mn:00007C3C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Free_proxy(void)+32p ...
.text$mn:00007C3C
.text$mn:00007C3C var_4           = dword ptr -4
.text$mn:00007C3C arg_0           = dword ptr  8
.text$mn:00007C3C arg_4           = dword ptr  0Ch
.text$mn:00007C3C
.text$mn:00007C3C                 push    ebp
.text$mn:00007C3D                 mov     ebp, esp
.text$mn:00007C3F                 push    ecx
.text$mn:00007C40                 mov     [ebp+var_4], ecx
.text$mn:00007C43                 mov     eax, [ebp+arg_4]
.text$mn:00007C46                 push    eax             ; int
.text$mn:00007C47                 mov     ecx, [ebp+arg_0]
.text$mn:00007C4A                 push    ecx             ; void *
.text$mn:00007C4B                 mov     ecx, [ebp+var_4]
.text$mn:00007C4E                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00007C53                 mov     esp, ebp
.text$mn:00007C55                 pop     ebp
.text$mn:00007C56                 retn    8
.text$mn:00007C56 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00007C56
.text$mn:00007C56 ; ---------------------------------------------------------------------------
.text$mn:00007C59                 align 4
.text$mn:00007C59 _text$mn        ends
.text$mn:00007C59
.text$mn:00007C5C ; ===========================================================================
.text$mn:00007C5C
.text$mn:00007C5C ; Segment type: Pure code
.text$mn:00007C5C ; Segment permissions: Read/Execute
.text$mn:00007C5C _text$mn        segment para public 'CODE' use32
.text$mn:00007C5C                 assume cs:_text$mn
.text$mn:00007C5C                 ;org 7C5Ch
.text$mn:00007C5C ; COMDAT (pick any)
.text$mn:00007C5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C5C
.text$mn:00007C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00007C5C
.text$mn:00007C5C ; Attributes: bp-based frame
.text$mn:00007C5C
.text$mn:00007C5C ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00007C5C                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00007C5C ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00007C5C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00007C5C
.text$mn:00007C5C var_4           = dword ptr -4
.text$mn:00007C5C arg_0           = dword ptr  8
.text$mn:00007C5C
.text$mn:00007C5C                 push    ebp
.text$mn:00007C5D                 mov     ebp, esp
.text$mn:00007C5F                 push    ecx
.text$mn:00007C60                 mov     [ebp+var_4], ecx
.text$mn:00007C63                 mov     eax, [ebp+arg_0]
.text$mn:00007C66                 push    eax             ; void *
.text$mn:00007C67                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007C6C                 add     esp, 4
.text$mn:00007C6F                 mov     esp, ebp
.text$mn:00007C71                 pop     ebp
.text$mn:00007C72                 retn    8
.text$mn:00007C72 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00007C72
.text$mn:00007C72 ; ---------------------------------------------------------------------------
.text$mn:00007C75                 align 4
.text$mn:00007C75 _text$mn        ends
.text$mn:00007C75
.text$mn:00007C78 ; ===========================================================================
.text$mn:00007C78
.text$mn:00007C78 ; Segment type: Pure code
.text$mn:00007C78 ; Segment permissions: Read/Execute
.text$mn:00007C78 _text$mn        segment para public 'CODE' use32
.text$mn:00007C78                 assume cs:_text$mn
.text$mn:00007C78                 ;org 7C78h
.text$mn:00007C78 ; COMDAT (pick any)
.text$mn:00007C78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C78
.text$mn:00007C78 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C78
.text$mn:00007C78 ; Attributes: bp-based frame
.text$mn:00007C78
.text$mn:00007C78 ; int __stdcall std::allocator<HWND__ *>::deallocate(void *, int)
.text$mn:00007C78                 public ?deallocate@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@I@Z
.text$mn:00007C78 ?deallocate@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@I@Z proc near
.text$mn:00007C78                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HWND__ *>>::deallocate(HWND__ * *,uint)+12p
.text$mn:00007C78
.text$mn:00007C78 var_4           = dword ptr -4
.text$mn:00007C78 arg_0           = dword ptr  8
.text$mn:00007C78
.text$mn:00007C78                 push    ebp
.text$mn:00007C79                 mov     ebp, esp
.text$mn:00007C7B                 push    ecx
.text$mn:00007C7C                 mov     [ebp+var_4], ecx
.text$mn:00007C7F                 mov     eax, [ebp+arg_0]
.text$mn:00007C82                 push    eax             ; void *
.text$mn:00007C83                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007C88                 add     esp, 4
.text$mn:00007C8B                 mov     esp, ebp
.text$mn:00007C8D                 pop     ebp
.text$mn:00007C8E                 retn    8
.text$mn:00007C8E ?deallocate@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@I@Z endp
.text$mn:00007C8E
.text$mn:00007C8E ; ---------------------------------------------------------------------------
.text$mn:00007C91                 align 4
.text$mn:00007C91 _text$mn        ends
.text$mn:00007C91
.text$mn:00007C94 ; ===========================================================================
.text$mn:00007C94
.text$mn:00007C94 ; Segment type: Pure code
.text$mn:00007C94 ; Segment permissions: Read/Execute
.text$mn:00007C94 _text$mn        segment para public 'CODE' use32
.text$mn:00007C94                 assume cs:_text$mn
.text$mn:00007C94                 ;org 7C94h
.text$mn:00007C94 ; COMDAT (pick any)
.text$mn:00007C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C94
.text$mn:00007C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C94
.text$mn:00007C94 ; Attributes: bp-based frame
.text$mn:00007C94
.text$mn:00007C94 ; int __stdcall std::allocator<tTbData *>::deallocate(void *, int)
.text$mn:00007C94                 public ?deallocate@?$allocator@PAUtTbData@@@std@@QAEXPAPAUtTbData@@I@Z
.text$mn:00007C94 ?deallocate@?$allocator@PAUtTbData@@@std@@QAEXPAPAUtTbData@@I@Z proc near
.text$mn:00007C94                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tTbData *>>::deallocate(tTbData * *,uint)+12p
.text$mn:00007C94
.text$mn:00007C94 var_4           = dword ptr -4
.text$mn:00007C94 arg_0           = dword ptr  8
.text$mn:00007C94
.text$mn:00007C94                 push    ebp
.text$mn:00007C95                 mov     ebp, esp
.text$mn:00007C97                 push    ecx
.text$mn:00007C98                 mov     [ebp+var_4], ecx
.text$mn:00007C9B                 mov     eax, [ebp+arg_0]
.text$mn:00007C9E                 push    eax             ; void *
.text$mn:00007C9F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007CA4                 add     esp, 4
.text$mn:00007CA7                 mov     esp, ebp
.text$mn:00007CA9                 pop     ebp
.text$mn:00007CAA                 retn    8
.text$mn:00007CAA ?deallocate@?$allocator@PAUtTbData@@@std@@QAEXPAPAUtTbData@@I@Z endp
.text$mn:00007CAA
.text$mn:00007CAA ; ---------------------------------------------------------------------------
.text$mn:00007CAD                 align 10h
.text$mn:00007CAD _text$mn        ends
.text$mn:00007CAD
.text$mn:00007CB0 ; ===========================================================================
.text$mn:00007CB0
.text$mn:00007CB0 ; Segment type: Pure code
.text$mn:00007CB0 ; Segment permissions: Read/Execute
.text$mn:00007CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00007CB0                 assume cs:_text$mn
.text$mn:00007CB0                 ;org 7CB0h
.text$mn:00007CB0 ; COMDAT (pick any)
.text$mn:00007CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CB0
.text$mn:00007CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CB0
.text$mn:00007CB0 ; Attributes: bp-based frame
.text$mn:00007CB0
.text$mn:00007CB0 ; int __stdcall std::allocator<DockingCont *>::deallocate(void *, int)
.text$mn:00007CB0                 public ?deallocate@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@I@Z
.text$mn:00007CB0 ?deallocate@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@I@Z proc near
.text$mn:00007CB0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::deallocate(DockingCont * *,uint)+12p
.text$mn:00007CB0
.text$mn:00007CB0 var_4           = dword ptr -4
.text$mn:00007CB0 arg_0           = dword ptr  8
.text$mn:00007CB0
.text$mn:00007CB0                 push    ebp
.text$mn:00007CB1                 mov     ebp, esp
.text$mn:00007CB3                 push    ecx
.text$mn:00007CB4                 mov     [ebp+var_4], ecx
.text$mn:00007CB7                 mov     eax, [ebp+arg_0]
.text$mn:00007CBA                 push    eax             ; void *
.text$mn:00007CBB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007CC0                 add     esp, 4
.text$mn:00007CC3                 mov     esp, ebp
.text$mn:00007CC5                 pop     ebp
.text$mn:00007CC6                 retn    8
.text$mn:00007CC6 ?deallocate@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@I@Z endp
.text$mn:00007CC6
.text$mn:00007CC6 ; ---------------------------------------------------------------------------
.text$mn:00007CC9                 align 4
.text$mn:00007CC9 _text$mn        ends
.text$mn:00007CC9
.text$mn:00007CCC ; ===========================================================================
.text$mn:00007CCC
.text$mn:00007CCC ; Segment type: Pure code
.text$mn:00007CCC ; Segment permissions: Read/Execute
.text$mn:00007CCC _text$mn        segment para public 'CODE' use32
.text$mn:00007CCC                 assume cs:_text$mn
.text$mn:00007CCC                 ;org 7CCCh
.text$mn:00007CCC ; COMDAT (pick any)
.text$mn:00007CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CCC
.text$mn:00007CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00007CCC
.text$mn:00007CCC ; Attributes: bp-based frame
.text$mn:00007CCC
.text$mn:00007CCC ; int __stdcall std::allocator<DockingSplitter *>::deallocate(void *, int)
.text$mn:00007CCC                 public ?deallocate@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@I@Z
.text$mn:00007CCC ?deallocate@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@I@Z proc near
.text$mn:00007CCC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingSplitter *>>::deallocate(DockingSplitter * *,uint)+12p
.text$mn:00007CCC
.text$mn:00007CCC var_4           = dword ptr -4
.text$mn:00007CCC arg_0           = dword ptr  8
.text$mn:00007CCC
.text$mn:00007CCC                 push    ebp
.text$mn:00007CCD                 mov     ebp, esp
.text$mn:00007CCF                 push    ecx
.text$mn:00007CD0                 mov     [ebp+var_4], ecx
.text$mn:00007CD3                 mov     eax, [ebp+arg_0]
.text$mn:00007CD6                 push    eax             ; void *
.text$mn:00007CD7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007CDC                 add     esp, 4
.text$mn:00007CDF                 mov     esp, ebp
.text$mn:00007CE1                 pop     ebp
.text$mn:00007CE2                 retn    8
.text$mn:00007CE2 ?deallocate@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@I@Z endp
.text$mn:00007CE2
.text$mn:00007CE2 ; ---------------------------------------------------------------------------
.text$mn:00007CE5                 align 4
.text$mn:00007CE5 _text$mn        ends
.text$mn:00007CE5
.text$mn:00007CE8 ; ===========================================================================
.text$mn:00007CE8
.text$mn:00007CE8 ; Segment type: Pure code
.text$mn:00007CE8 ; Segment permissions: Read/Execute
.text$mn:00007CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00007CE8                 assume cs:_text$mn
.text$mn:00007CE8                 ;org 7CE8h
.text$mn:00007CE8 ; COMDAT (pick any)
.text$mn:00007CE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CE8
.text$mn:00007CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CE8
.text$mn:00007CE8 ; Attributes: bp-based frame
.text$mn:00007CE8
.text$mn:00007CE8 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00007CE8                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00007CE8 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00007CE8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00007CE8                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)+12p
.text$mn:00007CE8
.text$mn:00007CE8 var_4           = dword ptr -4
.text$mn:00007CE8 arg_0           = dword ptr  8
.text$mn:00007CE8
.text$mn:00007CE8                 push    ebp
.text$mn:00007CE9                 mov     ebp, esp
.text$mn:00007CEB                 push    ecx
.text$mn:00007CEC                 mov     [ebp+var_4], ecx
.text$mn:00007CEF                 mov     eax, [ebp+arg_0]
.text$mn:00007CF2                 push    eax             ; void *
.text$mn:00007CF3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007CF8                 add     esp, 4
.text$mn:00007CFB                 mov     esp, ebp
.text$mn:00007CFD                 pop     ebp
.text$mn:00007CFE                 retn    8
.text$mn:00007CFE ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00007CFE
.text$mn:00007CFE ; ---------------------------------------------------------------------------
.text$mn:00007D01                 align 4
.text$mn:00007D01 _text$mn        ends
.text$mn:00007D01
.text$mn:00007D04 ; ===========================================================================
.text$mn:00007D04
.text$mn:00007D04 ; Segment type: Pure code
.text$mn:00007D04 ; Segment permissions: Read/Execute
.text$mn:00007D04 _text$mn        segment para public 'CODE' use32
.text$mn:00007D04                 assume cs:_text$mn
.text$mn:00007D04                 ;org 7D04h
.text$mn:00007D04 ; COMDAT (pick any)
.text$mn:00007D04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D04
.text$mn:00007D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D04
.text$mn:00007D04 ; Attributes: bp-based frame
.text$mn:00007D04
.text$mn:00007D04 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00007D04                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00007D04 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00007D04                                         ; DATA XREF: .rdata:00009DE0o
.text$mn:00007D04
.text$mn:00007D04 var_4           = dword ptr -4
.text$mn:00007D04 arg_0           = dword ptr  8
.text$mn:00007D04 arg_4           = dword ptr  0Ch
.text$mn:00007D04
.text$mn:00007D04                 push    ebp
.text$mn:00007D05                 mov     ebp, esp
.text$mn:00007D07                 push    ecx
.text$mn:00007D08                 mov     [ebp+var_4], ecx
.text$mn:00007D0B                 mov     eax, [ebp+arg_4]
.text$mn:00007D0E                 push    eax             ; int
.text$mn:00007D0F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00007D14                 add     esp, 4
.text$mn:00007D17                 test    eax, eax
.text$mn:00007D19                 jz      short loc_7D34
.text$mn:00007D1B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00007D20                 push    eax             ; struct std::error_category *
.text$mn:00007D21                 mov     ecx, [ebp+arg_4]
.text$mn:00007D24                 push    ecx             ; int
.text$mn:00007D25                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007D28                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00007D2D                 mov     eax, [ebp+arg_0]
.text$mn:00007D30                 jmp     short loc_7D49
.text$mn:00007D32 ; ---------------------------------------------------------------------------
.text$mn:00007D32                 jmp     short loc_7D49
.text$mn:00007D34 ; ---------------------------------------------------------------------------
.text$mn:00007D34
.text$mn:00007D34 loc_7D34:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00007D34                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00007D39                 push    eax             ; struct std::error_category *
.text$mn:00007D3A                 mov     edx, [ebp+arg_4]
.text$mn:00007D3D                 push    edx             ; int
.text$mn:00007D3E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007D41                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00007D46                 mov     eax, [ebp+arg_0]
.text$mn:00007D49
.text$mn:00007D49 loc_7D49:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00007D49                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00007D49                 mov     esp, ebp
.text$mn:00007D4B                 pop     ebp
.text$mn:00007D4C                 retn    8
.text$mn:00007D4C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00007D4C
.text$mn:00007D4C ; ---------------------------------------------------------------------------
.text$mn:00007D4F                 align 10h
.text$mn:00007D4F _text$mn        ends
.text$mn:00007D4F
.text$mn:00007D50 ; ===========================================================================
.text$mn:00007D50
.text$mn:00007D50 ; Segment type: Pure code
.text$mn:00007D50 ; Segment permissions: Read/Execute
.text$mn:00007D50 _text$mn        segment para public 'CODE' use32
.text$mn:00007D50                 assume cs:_text$mn
.text$mn:00007D50                 ;org 7D50h
.text$mn:00007D50 ; COMDAT (pick any)
.text$mn:00007D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D50
.text$mn:00007D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D50
.text$mn:00007D50 ; Attributes: bp-based frame
.text$mn:00007D50
.text$mn:00007D50 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00007D50                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00007D50 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00007D50                                         ; DATA XREF: .rdata:00009D50o
.text$mn:00007D50                                         ; .rdata:00009D6Co ...
.text$mn:00007D50
.text$mn:00007D50 var_4           = dword ptr -4
.text$mn:00007D50 arg_0           = dword ptr  8
.text$mn:00007D50 arg_4           = dword ptr  0Ch
.text$mn:00007D50
.text$mn:00007D50                 push    ebp
.text$mn:00007D51                 mov     ebp, esp
.text$mn:00007D53                 push    ecx
.text$mn:00007D54                 mov     [ebp+var_4], ecx
.text$mn:00007D57                 mov     eax, [ebp+var_4]
.text$mn:00007D5A                 push    eax             ; struct std::error_category *
.text$mn:00007D5B                 mov     ecx, [ebp+arg_4]
.text$mn:00007D5E                 push    ecx             ; int
.text$mn:00007D5F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007D62                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00007D67                 mov     eax, [ebp+arg_0]
.text$mn:00007D6A                 mov     esp, ebp
.text$mn:00007D6C                 pop     ebp
.text$mn:00007D6D                 retn    8
.text$mn:00007D6D ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00007D6D
.text$mn:00007D6D _text$mn        ends
.text$mn:00007D6D
.text$mn:00007D70 ; ===========================================================================
.text$mn:00007D70
.text$mn:00007D70 ; Segment type: Pure code
.text$mn:00007D70 ; Segment permissions: Read/Execute
.text$mn:00007D70 _text$mn        segment para public 'CODE' use32
.text$mn:00007D70                 assume cs:_text$mn
.text$mn:00007D70                 ;org 7D70h
.text$mn:00007D70 ; COMDAT (pick any)
.text$mn:00007D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D70
.text$mn:00007D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D70
.text$mn:00007D70 ; Attributes: bp-based frame
.text$mn:00007D70
.text$mn:00007D70 ; void __thiscall DockingSplitter::destroy(DockingSplitter *__hidden this)
.text$mn:00007D70                 public ?destroy@DockingSplitter@@UAEXXZ
.text$mn:00007D70 ?destroy@DockingSplitter@@UAEXXZ proc near ; DATA XREF: .rdata:00009E48o
.text$mn:00007D70
.text$mn:00007D70 var_4           = dword ptr -4
.text$mn:00007D70
.text$mn:00007D70                 push    ebp
.text$mn:00007D71                 mov     ebp, esp
.text$mn:00007D73                 push    ecx
.text$mn:00007D74                 mov     [ebp+var_4], ecx
.text$mn:00007D77                 mov     esp, ebp
.text$mn:00007D79                 pop     ebp
.text$mn:00007D7A                 retn
.text$mn:00007D7A ?destroy@DockingSplitter@@UAEXXZ endp
.text$mn:00007D7A
.text$mn:00007D7A ; ---------------------------------------------------------------------------
.text$mn:00007D7B                 align 4
.text$mn:00007D7B _text$mn        ends
.text$mn:00007D7B
.text$mn:00007D7C ; ===========================================================================
.text$mn:00007D7C
.text$mn:00007D7C ; Segment type: Pure code
.text$mn:00007D7C ; Segment permissions: Read/Execute
.text$mn:00007D7C _text$mn        segment para public 'CODE' use32
.text$mn:00007D7C                 assume cs:_text$mn
.text$mn:00007D7C                 ;org 7D7Ch
.text$mn:00007D7C ; COMDAT (pick any)
.text$mn:00007D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D7C
.text$mn:00007D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00007D7C
.text$mn:00007D7C ; Attributes: bp-based frame
.text$mn:00007D7C
.text$mn:00007D7C ; void __thiscall Window::display(Window *this, bool)
.text$mn:00007D7C                 public ?display@Window@@UBEX_N@Z
.text$mn:00007D7C ?display@Window@@UBEX_N@Z proc near     ; DATA XREF: .rdata:00009C8Co
.text$mn:00007D7C                                         ; .rdata:00009E18o ...
.text$mn:00007D7C
.text$mn:00007D7C var_8           = dword ptr -8
.text$mn:00007D7C nCmdShow        = dword ptr -4
.text$mn:00007D7C arg_0           = byte ptr  8
.text$mn:00007D7C
.text$mn:00007D7C                 push    ebp
.text$mn:00007D7D                 mov     ebp, esp
.text$mn:00007D7F                 sub     esp, 8
.text$mn:00007D82                 mov     [ebp+var_8], ecx
.text$mn:00007D85                 movzx   eax, [ebp+arg_0]
.text$mn:00007D89                 test    eax, eax
.text$mn:00007D8B                 jz      short loc_7D96
.text$mn:00007D8D                 mov     [ebp+nCmdShow], 5
.text$mn:00007D94                 jmp     short loc_7D9D
.text$mn:00007D96 ; ---------------------------------------------------------------------------
.text$mn:00007D96
.text$mn:00007D96 loc_7D96:                               ; CODE XREF: Window::display(bool)+Fj
.text$mn:00007D96                 mov     [ebp+nCmdShow], 0
.text$mn:00007D9D
.text$mn:00007D9D loc_7D9D:                               ; CODE XREF: Window::display(bool)+18j
.text$mn:00007D9D                 mov     ecx, [ebp+nCmdShow]
.text$mn:00007DA0                 push    ecx             ; nCmdShow
.text$mn:00007DA1                 mov     edx, [ebp+var_8]
.text$mn:00007DA4                 mov     eax, [edx+0Ch]
.text$mn:00007DA7                 push    eax             ; hWnd
.text$mn:00007DA8                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:00007DAE                 mov     esp, ebp
.text$mn:00007DB0                 pop     ebp
.text$mn:00007DB1                 retn    4
.text$mn:00007DB1 ?display@Window@@UBEX_N@Z endp
.text$mn:00007DB1
.text$mn:00007DB1 _text$mn        ends
.text$mn:00007DB1
.text$mn:00007DB4 ; ===========================================================================
.text$mn:00007DB4
.text$mn:00007DB4 ; Segment type: Pure code
.text$mn:00007DB4 ; Segment permissions: Read/Execute
.text$mn:00007DB4 _text$mn        segment para public 'CODE' use32
.text$mn:00007DB4                 assume cs:_text$mn
.text$mn:00007DB4                 ;org 7DB4h
.text$mn:00007DB4 ; COMDAT (pick any)
.text$mn:00007DB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007DB4
.text$mn:00007DB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007DB4
.text$mn:00007DB4 ; Attributes: bp-based frame
.text$mn:00007DB4
.text$mn:00007DB4 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<struct tTbData *>>> __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::end(void)const
.text$mn:00007DB4                 public ?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ
.text$mn:00007DB4 ?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ proc near
.text$mn:00007DB4                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+89p
.text$mn:00007DB4
.text$mn:00007DB4 var_14          = dword ptr -14h
.text$mn:00007DB4 var_10          = dword ptr -10h
.text$mn:00007DB4 var_C           = dword ptr -0Ch
.text$mn:00007DB4 var_4           = dword ptr -4
.text$mn:00007DB4 arg_0           = dword ptr  8
.text$mn:00007DB4
.text$mn:00007DB4                 push    ebp
.text$mn:00007DB5                 mov     ebp, esp
.text$mn:00007DB7                 push    0FFFFFFFFh
.text$mn:00007DB9                 push    offset __ehhandler$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ
.text$mn:00007DBE                 mov     eax, large fs:0
.text$mn:00007DC4                 push    eax
.text$mn:00007DC5                 sub     esp, 8
.text$mn:00007DC8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007DCD                 xor     eax, ebp
.text$mn:00007DCF                 push    eax
.text$mn:00007DD0                 lea     eax, [ebp+var_C]
.text$mn:00007DD3                 mov     large fs:0, eax
.text$mn:00007DD9                 mov     [ebp+var_10], ecx
.text$mn:00007DDC                 mov     [ebp+var_14], 0
.text$mn:00007DE3                 mov     eax, [ebp+var_10]
.text$mn:00007DE6                 push    eax             ; struct std::_Container_base12 *
.text$mn:00007DE7                 mov     ecx, [ebp+var_10]
.text$mn:00007DEA                 mov     edx, [ecx+8]
.text$mn:00007DED                 push    edx             ; int
.text$mn:00007DEE                 mov     ecx, [ebp+arg_0]
.text$mn:00007DF1                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(tTbData * *,std::_Container_base12 const *)
.text$mn:00007DF6                 mov     [ebp+var_4], 0
.text$mn:00007DFD                 mov     eax, [ebp+var_14]
.text$mn:00007E00                 or      eax, 1
.text$mn:00007E03                 mov     [ebp+var_14], eax
.text$mn:00007E06                 mov     eax, [ebp+arg_0]
.text$mn:00007E09                 mov     ecx, [ebp+var_C]
.text$mn:00007E0C                 mov     large fs:0, ecx
.text$mn:00007E13                 pop     ecx
.text$mn:00007E14                 mov     esp, ebp
.text$mn:00007E16                 pop     ebp
.text$mn:00007E17                 retn    4
.text$mn:00007E17 ?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ endp
.text$mn:00007E17
.text$mn:00007E17 ; ---------------------------------------------------------------------------
.text$mn:00007E1A                 align 4
.text$mn:00007E1A _text$mn        ends
.text$mn:00007E1A
.text$x:00007E1C ; ===========================================================================
.text$x:00007E1C
.text$x:00007E1C ; Segment type: Pure code
.text$x:00007E1C ; Segment permissions: Read/Execute
.text$x:00007E1C _text$x         segment para public 'CODE' use32
.text$x:00007E1C                 assume cs:_text$x
.text$x:00007E1C                 ;org 7E1Ch
.text$x:00007E1C ; COMDAT (pick associative to section at 7DB4)
.text$x:00007E1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007E1C
.text$x:00007E1C ; =============== S U B R O U T I N E =======================================
.text$x:00007E1C
.text$x:00007E1C
.text$x:00007E1C __unwindfunclet$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ$0 proc near
.text$x:00007E1C                                         ; DATA XREF: .xdata$x:00009238o
.text$x:00007E1C                 mov     eax, [ebp-14h]
.text$x:00007E1F                 and     eax, 1
.text$x:00007E22                 jz      $LN4_1
.text$x:00007E28                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00007E2C                 mov     ecx, [ebp+8]
.text$x:00007E2F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<tTbData *>>>(void)
.text$x:00007E34 ; ---------------------------------------------------------------------------
.text$x:00007E34
.text$x:00007E34 $LN4_1:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ$0+6j
.text$x:00007E34                 retn
.text$x:00007E34 __unwindfunclet$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ$0 endp
.text$x:00007E34
.text$x:00007E35
.text$x:00007E35 ; =============== S U B R O U T I N E =======================================
.text$x:00007E35
.text$x:00007E35
.text$x:00007E35 __ehhandler$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ proc near
.text$x:00007E35                                         ; DATA XREF: std::vector<tTbData *,std::allocator<tTbData *>>::end(void)+5o
.text$x:00007E35
.text$x:00007E35 arg_4           = dword ptr  8
.text$x:00007E35
.text$x:00007E35                 mov     edx, [esp+arg_4]
.text$x:00007E39                 lea     eax, [edx+0Ch]
.text$x:00007E3C                 mov     ecx, [edx-0Ch]
.text$x:00007E3F                 xor     ecx, eax
.text$x:00007E41                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007E46                 mov     eax, offset __ehfuncinfo$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ
.text$x:00007E4B                 jmp     ___CxxFrameHandler3
.text$x:00007E4B __ehhandler$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ endp
.text$x:00007E4B
.text$x:00007E4B _text$x         ends
.text$x:00007E4B
.text$mn:00007E50 ; ===========================================================================
.text$mn:00007E50
.text$mn:00007E50 ; Segment type: Pure code
.text$mn:00007E50 ; Segment permissions: Read/Execute
.text$mn:00007E50 _text$mn        segment para public 'CODE' use32
.text$mn:00007E50                 assume cs:_text$mn
.text$mn:00007E50                 ;org 7E50h
.text$mn:00007E50 ; COMDAT (pick any)
.text$mn:00007E50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E50
.text$mn:00007E50 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E50
.text$mn:00007E50 ; Attributes: bp-based frame
.text$mn:00007E50
.text$mn:00007E50 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00007E50                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00007E50 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00007E50                                         ; DATA XREF: .rdata:00009D54o
.text$mn:00007E50                                         ; .rdata:00009D70o ...
.text$mn:00007E50
.text$mn:00007E50 var_8           = dword ptr -8
.text$mn:00007E50 var_4           = dword ptr -4
.text$mn:00007E50 arg_0           = dword ptr  8
.text$mn:00007E50 arg_4           = dword ptr  0Ch
.text$mn:00007E50
.text$mn:00007E50                 push    ebp
.text$mn:00007E51                 mov     ebp, esp
.text$mn:00007E53                 sub     esp, 8
.text$mn:00007E56                 mov     [ebp+var_8], ecx
.text$mn:00007E59                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007E5C                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00007E61                 push    eax
.text$mn:00007E62                 mov     ecx, [ebp+var_8]
.text$mn:00007E65                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00007E6A                 movzx   eax, al
.text$mn:00007E6D                 test    eax, eax
.text$mn:00007E6F                 jz      short loc_7E87
.text$mn:00007E71                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00007E74                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00007E79                 cmp     eax, [ebp+arg_4]
.text$mn:00007E7C                 jnz     short loc_7E87
.text$mn:00007E7E                 mov     [ebp+var_4], 1
.text$mn:00007E85                 jmp     short loc_7E8E
.text$mn:00007E87 ; ---------------------------------------------------------------------------
.text$mn:00007E87
.text$mn:00007E87 loc_7E87:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00007E87                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00007E87                 mov     [ebp+var_4], 0
.text$mn:00007E8E
.text$mn:00007E8E loc_7E8E:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00007E8E                 mov     al, byte ptr [ebp+var_4]
.text$mn:00007E91                 mov     esp, ebp
.text$mn:00007E93                 pop     ebp
.text$mn:00007E94                 retn    8
.text$mn:00007E94 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00007E94
.text$mn:00007E94 ; ---------------------------------------------------------------------------
.text$mn:00007E97                 align 4
.text$mn:00007E97 _text$mn        ends
.text$mn:00007E97
.text$mn:00007E98 ; ===========================================================================
.text$mn:00007E98
.text$mn:00007E98 ; Segment type: Pure code
.text$mn:00007E98 ; Segment permissions: Read/Execute
.text$mn:00007E98 _text$mn        segment para public 'CODE' use32
.text$mn:00007E98                 assume cs:_text$mn
.text$mn:00007E98                 ;org 7E98h
.text$mn:00007E98 ; COMDAT (pick any)
.text$mn:00007E98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E98
.text$mn:00007E98 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E98
.text$mn:00007E98 ; Attributes: bp-based frame
.text$mn:00007E98
.text$mn:00007E98 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00007E98                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00007E98 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00007E98                                         ; DATA XREF: .rdata:00009D58o
.text$mn:00007E98                                         ; .rdata:00009D74o ...
.text$mn:00007E98
.text$mn:00007E98 var_C           = byte ptr -0Ch
.text$mn:00007E98 var_4           = dword ptr -4
.text$mn:00007E98 arg_0           = dword ptr  8
.text$mn:00007E98 arg_4           = dword ptr  0Ch
.text$mn:00007E98
.text$mn:00007E98                 push    ebp
.text$mn:00007E99                 mov     ebp, esp
.text$mn:00007E9B                 sub     esp, 0Ch
.text$mn:00007E9E                 mov     [ebp+var_4], ecx
.text$mn:00007EA1                 mov     eax, [ebp+arg_4]
.text$mn:00007EA4                 push    eax             ; std::error_condition *
.text$mn:00007EA5                 mov     ecx, [ebp+arg_0]
.text$mn:00007EA8                 push    ecx
.text$mn:00007EA9                 lea     edx, [ebp+var_C]
.text$mn:00007EAC                 push    edx
.text$mn:00007EAD                 mov     eax, [ebp+var_4]
.text$mn:00007EB0                 mov     edx, [eax]
.text$mn:00007EB2                 mov     ecx, [ebp+var_4]
.text$mn:00007EB5                 mov     eax, [edx+0Ch]
.text$mn:00007EB8                 call    eax
.text$mn:00007EBA                 mov     ecx, eax
.text$mn:00007EBC                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00007EC1                 mov     esp, ebp
.text$mn:00007EC3                 pop     ebp
.text$mn:00007EC4                 retn    8
.text$mn:00007EC4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00007EC4
.text$mn:00007EC4 ; ---------------------------------------------------------------------------
.text$mn:00007EC7                 align 4
.text$mn:00007EC7 _text$mn        ends
.text$mn:00007EC7
.text$mn:00007EC8 ; ===========================================================================
.text$mn:00007EC8
.text$mn:00007EC8 ; Segment type: Pure code
.text$mn:00007EC8 ; Segment permissions: Read/Execute
.text$mn:00007EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00007EC8                 assume cs:_text$mn
.text$mn:00007EC8                 ;org 7EC8h
.text$mn:00007EC8 ; COMDAT (pick any)
.text$mn:00007EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007EC8
.text$mn:00007EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EC8
.text$mn:00007EC8 ; Attributes: bp-based frame
.text$mn:00007EC8
.text$mn:00007EC8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00007EC8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00007EC8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00007EC8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00007EC8
.text$mn:00007EC8 var_4           = dword ptr -4
.text$mn:00007EC8 arg_0           = dword ptr  8
.text$mn:00007EC8
.text$mn:00007EC8                 push    ebp
.text$mn:00007EC9                 mov     ebp, esp
.text$mn:00007ECB                 push    ecx
.text$mn:00007ECC                 mov     [ebp+var_4], ecx
.text$mn:00007ECF                 mov     eax, [ebp+var_4]
.text$mn:00007ED2                 mov     ecx, [eax+14h]
.text$mn:00007ED5                 cmp     ecx, [ebp+arg_0]
.text$mn:00007ED8                 jnb     short loc_7EE2
.text$mn:00007EDA                 mov     ecx, [ebp+var_4]
.text$mn:00007EDD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00007EE2
.text$mn:00007EE2 loc_7EE2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00007EE2                 mov     edx, [ebp+arg_0]
.text$mn:00007EE5                 push    edx
.text$mn:00007EE6                 mov     ecx, [ebp+var_4]
.text$mn:00007EE9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007EEE                 mov     eax, [ebp+var_4]
.text$mn:00007EF1                 mov     esp, ebp
.text$mn:00007EF3                 pop     ebp
.text$mn:00007EF4                 retn    4
.text$mn:00007EF4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00007EF4
.text$mn:00007EF4 ; ---------------------------------------------------------------------------
.text$mn:00007EF7                 align 4
.text$mn:00007EF7 _text$mn        ends
.text$mn:00007EF7
.text$mn:00007EF8 ; ===========================================================================
.text$mn:00007EF8
.text$mn:00007EF8 ; Segment type: Pure code
.text$mn:00007EF8 ; Segment permissions: Read/Execute
.text$mn:00007EF8 _text$mn        segment para public 'CODE' use32
.text$mn:00007EF8                 assume cs:_text$mn
.text$mn:00007EF8                 ;org 7EF8h
.text$mn:00007EF8 ; COMDAT (pick any)
.text$mn:00007EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007EF8
.text$mn:00007EF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EF8
.text$mn:00007EF8 ; Attributes: bp-based frame
.text$mn:00007EF8
.text$mn:00007EF8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00007EF8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00007EF8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00007EF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00007EF8
.text$mn:00007EF8 var_C           = dword ptr -0Ch
.text$mn:00007EF8 Dst             = dword ptr -8
.text$mn:00007EF8 var_4           = dword ptr -4
.text$mn:00007EF8 arg_0           = dword ptr  8
.text$mn:00007EF8 arg_4           = dword ptr  0Ch
.text$mn:00007EF8
.text$mn:00007EF8                 push    ebp
.text$mn:00007EF9                 mov     ebp, esp
.text$mn:00007EFB                 sub     esp, 0Ch
.text$mn:00007EFE
.text$mn:00007EFE loc_7EFE:                               ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+52o
.text$mn:00007EFE                 mov     [ebp+var_4], ecx
.text$mn:00007F01                 mov     eax, [ebp+var_4]
.text$mn:00007F04                 mov     ecx, [eax+14h]
.text$mn:00007F07                 cmp     ecx, [ebp+arg_0]
.text$mn:00007F0A                 jnb     short loc_7F14
.text$mn:00007F0C                 mov     ecx, [ebp+var_4]
.text$mn:00007F0F                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00007F14
.text$mn:00007F14 loc_7F14:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00007F14                 mov     edx, [ebp+var_4]
.text$mn:00007F17                 mov     eax, [edx+14h]
.text$mn:00007F1A                 sub     eax, [ebp+arg_0]
.text$mn:00007F1D                 cmp     eax, [ebp+arg_4]
.text$mn:00007F20                 ja      short loc_7F30
.text$mn:00007F22                 mov     ecx, [ebp+arg_0]
.text$mn:00007F25                 push    ecx
.text$mn:00007F26                 mov     ecx, [ebp+var_4]
.text$mn:00007F29                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007F2E                 jmp     short loc_7F76
.text$mn:00007F30 ; ---------------------------------------------------------------------------
.text$mn:00007F30
.text$mn:00007F30 loc_7F30:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00007F30                 cmp     [ebp+arg_4], 0
.text$mn:00007F34                 jbe     short loc_7F76
.text$mn:00007F36                 mov     ecx, [ebp+var_4]
.text$mn:00007F39                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007F3E                 add     eax, [ebp+arg_0]
.text$mn:00007F41                 mov     [ebp+Dst], eax
.text$mn:00007F44                 mov     edx, [ebp+var_4]
.text$mn:00007F47                 mov     eax, [edx+14h]
.text$mn:00007F4A                 sub     eax, [ebp+arg_4]
.text$mn:00007F4D                 mov     [ebp+var_C], eax
.text$mn:00007F50                 mov     ecx, [ebp+var_C]
.text$mn:00007F53                 sub     ecx, [ebp+arg_0]
.text$mn:00007F56                 push    ecx             ; Size
.text$mn:00007F57                 mov     edx, [ebp+Dst]
.text$mn:00007F5A                 add     edx, [ebp+arg_4]
.text$mn:00007F5D                 push    edx             ; Src
.text$mn:00007F5E                 mov     eax, [ebp+Dst]
.text$mn:00007F61                 push    eax             ; Dst
.text$mn:00007F62                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00007F67                 add     esp, 0Ch
.text$mn:00007F6A                 mov     ecx, [ebp+var_C]
.text$mn:00007F6D                 push    ecx
.text$mn:00007F6E                 mov     ecx, [ebp+var_4]
.text$mn:00007F71                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007F76
.text$mn:00007F76 loc_7F76:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00007F76                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00007F76                 mov     eax, [ebp+var_4]
.text$mn:00007F79                 mov     esp, ebp
.text$mn:00007F7B                 pop     ebp
.text$mn:00007F7C                 retn    8
.text$mn:00007F7C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00007F7C
.text$mn:00007F7C ; ---------------------------------------------------------------------------
.text$mn:00007F7F                 align 10h
.text$mn:00007F7F _text$mn        ends
.text$mn:00007F7F
.text$mn:00007F80 ; ===========================================================================
.text$mn:00007F80
.text$mn:00007F80 ; Segment type: Pure code
.text$mn:00007F80 ; Segment permissions: Read/Execute
.text$mn:00007F80 _text$mn        segment para public 'CODE' use32
.text$mn:00007F80                 assume cs:_text$mn
.text$mn:00007F80                 ;org 7F80h
.text$mn:00007F80 ; COMDAT (pick any)
.text$mn:00007F80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F80
.text$mn:00007F80 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F80
.text$mn:00007F80 ; Attributes: bp-based frame
.text$mn:00007F80
.text$mn:00007F80 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00007F80                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00007F80 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00007F80                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00007F80                 push    ebp
.text$mn:00007F81                 mov     ebp, esp
.text$mn:00007F83                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00007F88                 pop     ebp
.text$mn:00007F89                 retn
.text$mn:00007F89 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00007F89
.text$mn:00007F89 ; ---------------------------------------------------------------------------
.text$mn:00007F8A                 align 4
.text$mn:00007F8A _text$mn        ends
.text$mn:00007F8A
.text$mn:00007F8C ; ===========================================================================
.text$mn:00007F8C
.text$mn:00007F8C ; Segment type: Pure code
.text$mn:00007F8C ; Segment permissions: Read/Execute
.text$mn:00007F8C _text$mn        segment para public 'CODE' use32
.text$mn:00007F8C                 assume cs:_text$mn
.text$mn:00007F8C                 ;org 7F8Ch
.text$mn:00007F8C ; COMDAT (pick any)
.text$mn:00007F8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F8C
.text$mn:00007F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00007F8C
.text$mn:00007F8C ; Attributes: bp-based frame
.text$mn:00007F8C
.text$mn:00007F8C ; void __thiscall Window::getClientRect(Window *this, struct tagRECT *)
.text$mn:00007F8C                 public ?getClientRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00007F8C ?getClientRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00007F8C                                         ; DATA XREF: .rdata:00009C9Co
.text$mn:00007F8C                                         ; .rdata:00009E28o ...
.text$mn:00007F8C
.text$mn:00007F8C var_4           = dword ptr -4
.text$mn:00007F8C lpRect          = dword ptr  8
.text$mn:00007F8C
.text$mn:00007F8C                 push    ebp
.text$mn:00007F8D                 mov     ebp, esp
.text$mn:00007F8F                 push    ecx
.text$mn:00007F90                 mov     [ebp+var_4], ecx
.text$mn:00007F93                 mov     eax, [ebp+lpRect]
.text$mn:00007F96                 push    eax             ; lpRect
.text$mn:00007F97                 mov     ecx, [ebp+var_4]
.text$mn:00007F9A                 mov     edx, [ecx+0Ch]
.text$mn:00007F9D                 push    edx             ; hWnd
.text$mn:00007F9E                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00007FA4                 mov     esp, ebp
.text$mn:00007FA6                 pop     ebp
.text$mn:00007FA7                 retn    4
.text$mn:00007FA7 ?getClientRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:00007FA7
.text$mn:00007FA7 ; ---------------------------------------------------------------------------
.text$mn:00007FAA                 align 4
.text$mn:00007FAA _text$mn        ends
.text$mn:00007FAA
.text$mn:00007FAC ; ===========================================================================
.text$mn:00007FAC
.text$mn:00007FAC ; Segment type: Pure code
.text$mn:00007FAC ; Segment permissions: Read/Execute
.text$mn:00007FAC _text$mn        segment para public 'CODE' use32
.text$mn:00007FAC                 assume cs:_text$mn
.text$mn:00007FAC                 ;org 7FACh
.text$mn:00007FAC ; COMDAT (pick any)
.text$mn:00007FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007FAC
.text$mn:00007FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00007FAC
.text$mn:00007FAC ; Attributes: bp-based frame
.text$mn:00007FAC
.text$mn:00007FAC ; public: class std::vector<class DockingCont *, class std::allocator<class DockingCont *>> & __thiscall DockingManager::getContainerInfo(void)
.text$mn:00007FAC                 public ?getContainerInfo@DockingManager@@QAEAAV?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@XZ
.text$mn:00007FAC ?getContainerInfo@DockingManager@@QAEAAV?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@XZ proc near
.text$mn:00007FAC                                         ; CODE XREF: FocusWndProc(int,uint,long)+3Bp
.text$mn:00007FAC
.text$mn:00007FAC var_4           = dword ptr -4
.text$mn:00007FAC
.text$mn:00007FAC                 push    ebp
.text$mn:00007FAD                 mov     ebp, esp
.text$mn:00007FAF                 push    ecx
.text$mn:00007FB0                 mov     [ebp+var_4], ecx
.text$mn:00007FB3                 mov     eax, [ebp+var_4]
.text$mn:00007FB6                 add     eax, 4Ch ; 'L'
.text$mn:00007FB9                 mov     esp, ebp
.text$mn:00007FBB                 pop     ebp
.text$mn:00007FBC                 retn
.text$mn:00007FBC ?getContainerInfo@DockingManager@@QAEAAV?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@XZ endp
.text$mn:00007FBC
.text$mn:00007FBC ; ---------------------------------------------------------------------------
.text$mn:00007FBD                 align 10h
.text$mn:00007FBD _text$mn        ends
.text$mn:00007FBD
.text$mn:00007FC0 ; ===========================================================================
.text$mn:00007FC0
.text$mn:00007FC0 ; Segment type: Pure code
.text$mn:00007FC0 ; Segment permissions: Read/Execute
.text$mn:00007FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00007FC0                 assume cs:_text$mn
.text$mn:00007FC0                 ;org 7FC0h
.text$mn:00007FC0 ; COMDAT (pick any)
.text$mn:00007FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007FC0
.text$mn:00007FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FC0
.text$mn:00007FC0 ; Attributes: bp-based frame
.text$mn:00007FC0
.text$mn:00007FC0 ; public: class std::vector<struct tTbData *, class std::allocator<struct tTbData *>> __thiscall DockingCont::getDataOfAllTb(void)
.text$mn:00007FC0                 public ?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ
.text$mn:00007FC0 ?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ proc near
.text$mn:00007FC0                                         ; CODE XREF: DockingManager::FindEmptyContainer(void)+D4p
.text$mn:00007FC0
.text$mn:00007FC0 var_14          = dword ptr -14h
.text$mn:00007FC0 var_10          = dword ptr -10h
.text$mn:00007FC0 var_C           = dword ptr -0Ch
.text$mn:00007FC0 var_4           = dword ptr -4
.text$mn:00007FC0 arg_0           = dword ptr  8
.text$mn:00007FC0
.text$mn:00007FC0                 push    ebp
.text$mn:00007FC1                 mov     ebp, esp
.text$mn:00007FC3                 push    0FFFFFFFFh
.text$mn:00007FC5                 push    offset __ehhandler$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ
.text$mn:00007FCA                 mov     eax, large fs:0
.text$mn:00007FD0                 push    eax
.text$mn:00007FD1                 sub     esp, 8
.text$mn:00007FD4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007FD9                 xor     eax, ebp
.text$mn:00007FDB                 push    eax
.text$mn:00007FDC                 lea     eax, [ebp+var_C]
.text$mn:00007FDF                 mov     large fs:0, eax
.text$mn:00007FE5                 mov     [ebp+var_14], ecx
.text$mn:00007FE8                 mov     [ebp+var_10], 0
.text$mn:00007FEF                 mov     eax, [ebp+var_14]
.text$mn:00007FF2                 add     eax, 9Ch ; '£'
.text$mn:00007FF7                 push    eax
.text$mn:00007FF8                 mov     ecx, [ebp+arg_0]
.text$mn:00007FFB                 call    ??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z ; std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)
.text$mn:00008000                 mov     [ebp+var_4], 0
.text$mn:00008007                 mov     ecx, [ebp+var_10]
.text$mn:0000800A                 or      ecx, 1
.text$mn:0000800D                 mov     [ebp+var_10], ecx
.text$mn:00008010                 mov     eax, [ebp+arg_0]
.text$mn:00008013                 mov     ecx, [ebp+var_C]
.text$mn:00008016                 mov     large fs:0, ecx
.text$mn:0000801D                 pop     ecx
.text$mn:0000801E                 mov     esp, ebp
.text$mn:00008020                 pop     ebp
.text$mn:00008021                 retn    4
.text$mn:00008021 ?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ endp
.text$mn:00008021
.text$mn:00008021 _text$mn        ends
.text$mn:00008021
.text$x:00008024 ; ===========================================================================
.text$x:00008024
.text$x:00008024 ; Segment type: Pure code
.text$x:00008024 ; Segment permissions: Read/Execute
.text$x:00008024 _text$x         segment para public 'CODE' use32
.text$x:00008024                 assume cs:_text$x
.text$x:00008024                 ;org 8024h
.text$x:00008024 ; COMDAT (pick associative to section at 7FC0)
.text$x:00008024                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008024
.text$x:00008024 ; =============== S U B R O U T I N E =======================================
.text$x:00008024
.text$x:00008024
.text$x:00008024 __unwindfunclet$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ$0 proc near
.text$x:00008024                                         ; DATA XREF: .xdata$x:00009094o
.text$x:00008024                 mov     eax, [ebp-10h]
.text$x:00008027                 and     eax, 1
.text$x:0000802A                 jz      $LN4
.text$x:00008030                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008034                 mov     ecx, [ebp+8]
.text$x:00008037                 jmp     ??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ ; std::vector<tTbData *,std::allocator<tTbData *>>::~vector<tTbData *,std::allocator<tTbData *>>(void)
.text$x:0000803C ; ---------------------------------------------------------------------------
.text$x:0000803C
.text$x:0000803C $LN4:                                   ; CODE XREF: __unwindfunclet$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ$0+6j
.text$x:0000803C                 retn
.text$x:0000803C __unwindfunclet$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ$0 endp
.text$x:0000803C
.text$x:0000803D
.text$x:0000803D ; =============== S U B R O U T I N E =======================================
.text$x:0000803D
.text$x:0000803D
.text$x:0000803D __ehhandler$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ proc near
.text$x:0000803D                                         ; DATA XREF: DockingCont::getDataOfAllTb(void)+5o
.text$x:0000803D
.text$x:0000803D arg_4           = dword ptr  8
.text$x:0000803D
.text$x:0000803D                 mov     edx, [esp+arg_4]
.text$x:00008041                 lea     eax, [edx+0Ch]
.text$x:00008044                 mov     ecx, [edx-0Ch]
.text$x:00008047                 xor     ecx, eax
.text$x:00008049                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000804E                 mov     eax, offset __ehfuncinfo$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ
.text$x:00008053                 jmp     ___CxxFrameHandler3
.text$x:00008053 __ehhandler$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ endp
.text$x:00008053
.text$x:00008053 _text$x         ends
.text$x:00008053
.text$mn:00008058 ; ===========================================================================
.text$mn:00008058
.text$mn:00008058 ; Segment type: Pure code
.text$mn:00008058 ; Segment permissions: Read/Execute
.text$mn:00008058 _text$mn        segment para public 'CODE' use32
.text$mn:00008058                 assume cs:_text$mn
.text$mn:00008058                 ;org 8058h
.text$mn:00008058 ; COMDAT (pick any)
.text$mn:00008058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008058
.text$mn:00008058 ; =============== S U B R O U T I N E =======================================
.text$mn:00008058
.text$mn:00008058 ; Attributes: bp-based frame
.text$mn:00008058
.text$mn:00008058 ; HWND __thiscall Window::getHSelf(Window *__hidden this)
.text$mn:00008058                 public ?getHSelf@Window@@QBEPAUHWND__@@XZ
.text$mn:00008058 ?getHSelf@Window@@QBEPAUHWND__@@XZ proc near
.text$mn:00008058                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+19Fp
.text$mn:00008058                                         ; DockingManager::reSizeTo(tagRECT &)+651p ...
.text$mn:00008058
.text$mn:00008058 var_4           = dword ptr -4
.text$mn:00008058
.text$mn:00008058                 push    ebp
.text$mn:00008059                 mov     ebp, esp
.text$mn:0000805B                 push    ecx
.text$mn:0000805C                 mov     [ebp+var_4], ecx
.text$mn:0000805F                 mov     eax, [ebp+var_4]
.text$mn:00008062                 mov     eax, [eax+0Ch]
.text$mn:00008065                 mov     esp, ebp
.text$mn:00008067                 pop     ebp
.text$mn:00008068                 retn
.text$mn:00008068 ?getHSelf@Window@@QBEPAUHWND__@@XZ endp
.text$mn:00008068
.text$mn:00008068 ; ---------------------------------------------------------------------------
.text$mn:00008069                 align 4
.text$mn:00008069 _text$mn        ends
.text$mn:00008069
.text$mn:0000806C ; ===========================================================================
.text$mn:0000806C
.text$mn:0000806C ; Segment type: Pure code
.text$mn:0000806C ; Segment permissions: Read/Execute
.text$mn:0000806C _text$mn        segment para public 'CODE' use32
.text$mn:0000806C                 assume cs:_text$mn
.text$mn:0000806C                 ;org 806Ch
.text$mn:0000806C ; COMDAT (pick any)
.text$mn:0000806C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000806C
.text$mn:0000806C ; =============== S U B R O U T I N E =======================================
.text$mn:0000806C
.text$mn:0000806C ; Attributes: bp-based frame
.text$mn:0000806C
.text$mn:0000806C ; int __thiscall Window::getHeight(Window *__hidden this)
.text$mn:0000806C                 public ?getHeight@Window@@UBEHXZ
.text$mn:0000806C ?getHeight@Window@@UBEHXZ proc near     ; DATA XREF: .rdata:00009CA8o
.text$mn:0000806C                                         ; .rdata:00009E34o ...
.text$mn:0000806C
.text$mn:0000806C var_18          = dword ptr -18h
.text$mn:0000806C Rect            = tagRECT ptr -14h
.text$mn:0000806C var_4           = dword ptr -4
.text$mn:0000806C
.text$mn:0000806C                 push    ebp
.text$mn:0000806D                 mov     ebp, esp
.text$mn:0000806F                 sub     esp, 18h
.text$mn:00008072                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008077                 xor     eax, ebp
.text$mn:00008079                 mov     [ebp+var_4], eax
.text$mn:0000807C                 mov     [ebp+var_18], ecx
.text$mn:0000807F                 lea     eax, [ebp+Rect]
.text$mn:00008082                 push    eax             ; lpRect
.text$mn:00008083                 mov     ecx, [ebp+var_18]
.text$mn:00008086                 mov     edx, [ecx+0Ch]
.text$mn:00008089                 push    edx             ; hWnd
.text$mn:0000808A                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00008090                 mov     eax, [ebp+var_18]
.text$mn:00008093                 mov     ecx, [eax+0Ch]
.text$mn:00008096                 push    ecx             ; hWnd
.text$mn:00008097                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:0000809D                 cmp     eax, 1
.text$mn:000080A0                 jnz     short loc_80AA
.text$mn:000080A2                 mov     eax, [ebp+Rect.bottom]
.text$mn:000080A5                 sub     eax, [ebp+Rect.top]
.text$mn:000080A8                 jmp     short loc_80AC
.text$mn:000080AA ; ---------------------------------------------------------------------------
.text$mn:000080AA
.text$mn:000080AA loc_80AA:                               ; CODE XREF: Window::getHeight(void)+34j
.text$mn:000080AA                 xor     eax, eax
.text$mn:000080AC
.text$mn:000080AC loc_80AC:                               ; CODE XREF: Window::getHeight(void)+3Cj
.text$mn:000080AC                 mov     ecx, [ebp+var_4]
.text$mn:000080AF                 xor     ecx, ebp
.text$mn:000080B1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000080B6                 mov     esp, ebp
.text$mn:000080B8                 pop     ebp
.text$mn:000080B9                 retn
.text$mn:000080B9 ?getHeight@Window@@UBEHXZ endp
.text$mn:000080B9
.text$mn:000080B9 ; ---------------------------------------------------------------------------
.text$mn:000080BA                 align 4
.text$mn:000080BA _text$mn        ends
.text$mn:000080BA
.text$mn:000080BC ; ===========================================================================
.text$mn:000080BC
.text$mn:000080BC ; Segment type: Pure code
.text$mn:000080BC ; Segment permissions: Read/Execute
.text$mn:000080BC _text$mn        segment para public 'CODE' use32
.text$mn:000080BC                 assume cs:_text$mn
.text$mn:000080BC                 ;org 80BCh
.text$mn:000080BC ; COMDAT (pick any)
.text$mn:000080BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000080BC
.text$mn:000080BC ; =============== S U B R O U T I N E =======================================
.text$mn:000080BC
.text$mn:000080BC ; Attributes: bp-based frame
.text$mn:000080BC
.text$mn:000080BC ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:000080BC                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:000080BC ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:000080BC                                         ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+46p
.text$mn:000080BC                 push    ebp
.text$mn:000080BD                 mov     ebp, esp
.text$mn:000080BF                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:000080C4                 pop     ebp
.text$mn:000080C5                 retn
.text$mn:000080C5 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:000080C5
.text$mn:000080C5 ; ---------------------------------------------------------------------------
.text$mn:000080C6                 align 4
.text$mn:000080C6 _text$mn        ends
.text$mn:000080C6
.text$mn:000080C8 ; ===========================================================================
.text$mn:000080C8
.text$mn:000080C8 ; Segment type: Pure code
.text$mn:000080C8 ; Segment permissions: Read/Execute
.text$mn:000080C8 _text$mn        segment para public 'CODE' use32
.text$mn:000080C8                 assume cs:_text$mn
.text$mn:000080C8                 ;org 80C8h
.text$mn:000080C8 ; COMDAT (pick any)
.text$mn:000080C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000080C8
.text$mn:000080C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000080C8
.text$mn:000080C8 ; Attributes: bp-based frame
.text$mn:000080C8
.text$mn:000080C8 ; int __thiscall Window::getWidth(Window *__hidden this)
.text$mn:000080C8                 public ?getWidth@Window@@UBEHXZ
.text$mn:000080C8 ?getWidth@Window@@UBEHXZ proc near      ; DATA XREF: .rdata:00009CA4o
.text$mn:000080C8                                         ; .rdata:00009E30o ...
.text$mn:000080C8
.text$mn:000080C8 var_18          = dword ptr -18h
.text$mn:000080C8 Rect            = tagRECT ptr -14h
.text$mn:000080C8 var_4           = dword ptr -4
.text$mn:000080C8
.text$mn:000080C8                 push    ebp
.text$mn:000080C9                 mov     ebp, esp
.text$mn:000080CB                 sub     esp, 18h
.text$mn:000080CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000080D3                 xor     eax, ebp
.text$mn:000080D5                 mov     [ebp+var_4], eax
.text$mn:000080D8                 mov     [ebp+var_18], ecx
.text$mn:000080DB                 lea     eax, [ebp+Rect]
.text$mn:000080DE                 push    eax             ; lpRect
.text$mn:000080DF                 mov     ecx, [ebp+var_18]
.text$mn:000080E2                 mov     edx, [ecx+0Ch]
.text$mn:000080E5                 push    edx             ; hWnd
.text$mn:000080E6                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:000080EC                 mov     eax, [ebp+Rect.right]
.text$mn:000080EF                 sub     eax, [ebp+Rect.left]
.text$mn:000080F2                 mov     ecx, [ebp+var_4]
.text$mn:000080F5                 xor     ecx, ebp
.text$mn:000080F7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000080FC                 mov     esp, ebp
.text$mn:000080FE                 pop     ebp
.text$mn:000080FF                 retn
.text$mn:000080FF ?getWidth@Window@@UBEHXZ endp
.text$mn:000080FF
.text$mn:000080FF _text$mn        ends
.text$mn:000080FF
.text$mn:00008100 ; ===========================================================================
.text$mn:00008100
.text$mn:00008100 ; Segment type: Pure code
.text$mn:00008100 ; Segment permissions: Read/Execute
.text$mn:00008100 _text$mn        segment para public 'CODE' use32
.text$mn:00008100                 assume cs:_text$mn
.text$mn:00008100                 ;org 8100h
.text$mn:00008100 ; COMDAT (pick any)
.text$mn:00008100                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008100
.text$mn:00008100 ; =============== S U B R O U T I N E =======================================
.text$mn:00008100
.text$mn:00008100 ; Attributes: bp-based frame
.text$mn:00008100
.text$mn:00008100 ; void __thiscall Window::getWindowRect(Window *this, struct tagRECT *)
.text$mn:00008100                 public ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00008100 ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00008100                                         ; DATA XREF: .rdata:00009CA0o
.text$mn:00008100                                         ; .rdata:00009E2Co ...
.text$mn:00008100
.text$mn:00008100 var_4           = dword ptr -4
.text$mn:00008100 lpRect          = dword ptr  8
.text$mn:00008100
.text$mn:00008100                 push    ebp
.text$mn:00008101                 mov     ebp, esp
.text$mn:00008103                 push    ecx
.text$mn:00008104                 mov     [ebp+var_4], ecx
.text$mn:00008107                 mov     eax, [ebp+lpRect]
.text$mn:0000810A                 push    eax             ; lpRect
.text$mn:0000810B                 mov     ecx, [ebp+var_4]
.text$mn:0000810E                 mov     edx, [ecx+0Ch]
.text$mn:00008111                 push    edx             ; hWnd
.text$mn:00008112                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00008118                 mov     esp, ebp
.text$mn:0000811A                 pop     ebp
.text$mn:0000811B                 retn    4
.text$mn:0000811B ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:0000811B
.text$mn:0000811B ; ---------------------------------------------------------------------------
.text$mn:0000811E                 align 10h
.text$mn:0000811E _text$mn        ends
.text$mn:0000811E
.text$mn:00008120 ; ===========================================================================
.text$mn:00008120
.text$mn:00008120 ; Segment type: Pure code
.text$mn:00008120 ; Segment permissions: Read/Execute
.text$mn:00008120 _text$mn        segment para public 'CODE' use32
.text$mn:00008120                 assume cs:_text$mn
.text$mn:00008120                 ;org 8120h
.text$mn:00008120 ; COMDAT (pick any)
.text$mn:00008120                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008120
.text$mn:00008120 ; =============== S U B R O U T I N E =======================================
.text$mn:00008120
.text$mn:00008120 ; Attributes: bp-based frame
.text$mn:00008120
.text$mn:00008120 ; void __thiscall Gripper::init(Gripper *this, HINSTANCE, HWND)
.text$mn:00008120                 public ?init@Gripper@@QAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00008120 ?init@Gripper@@QAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00008120                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+2BDp
.text$mn:00008120
.text$mn:00008120 var_4           = dword ptr -4
.text$mn:00008120 arg_0           = dword ptr  8
.text$mn:00008120 arg_4           = dword ptr  0Ch
.text$mn:00008120
.text$mn:00008120                 push    ebp
.text$mn:00008121                 mov     ebp, esp
.text$mn:00008123                 push    ecx
.text$mn:00008124                 mov     [ebp+var_4], ecx
.text$mn:00008127                 mov     eax, [ebp+var_4]
.text$mn:0000812A                 mov     ecx, [ebp+arg_0]
.text$mn:0000812D                 mov     [eax], ecx
.text$mn:0000812F                 mov     edx, [ebp+var_4]
.text$mn:00008132                 mov     eax, [ebp+arg_4]
.text$mn:00008135                 mov     [edx+4], eax
.text$mn:00008138                 mov     esp, ebp
.text$mn:0000813A                 pop     ebp
.text$mn:0000813B                 retn    8
.text$mn:0000813B ?init@Gripper@@QAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:0000813B
.text$mn:0000813B ; ---------------------------------------------------------------------------
.text$mn:0000813E                 align 10h
.text$mn:0000813E _text$mn        ends
.text$mn:0000813E
.text$mn:00008140 ; ===========================================================================
.text$mn:00008140
.text$mn:00008140 ; Segment type: Pure code
.text$mn:00008140 ; Segment permissions: Read/Execute
.text$mn:00008140 _text$mn        segment para public 'CODE' use32
.text$mn:00008140                 assume cs:_text$mn
.text$mn:00008140                 ;org 8140h
.text$mn:00008140 ; COMDAT (pick any)
.text$mn:00008140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008140
.text$mn:00008140 ; =============== S U B R O U T I N E =======================================
.text$mn:00008140
.text$mn:00008140 ; Attributes: bp-based frame
.text$mn:00008140
.text$mn:00008140 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00008140                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00008140 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00008140                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+14p
.text$mn:00008140                                         ; DATA XREF: .rdata:00009C84o ...
.text$mn:00008140
.text$mn:00008140 var_4           = dword ptr -4
.text$mn:00008140 arg_0           = dword ptr  8
.text$mn:00008140 arg_4           = dword ptr  0Ch
.text$mn:00008140
.text$mn:00008140                 push    ebp
.text$mn:00008141                 mov     ebp, esp
.text$mn:00008143                 push    ecx
.text$mn:00008144                 mov     [ebp+var_4], ecx
.text$mn:00008147                 mov     eax, [ebp+var_4]
.text$mn:0000814A                 mov     ecx, [ebp+arg_0]
.text$mn:0000814D                 mov     [eax+4], ecx
.text$mn:00008150                 mov     edx, [ebp+var_4]
.text$mn:00008153                 mov     eax, [ebp+arg_4]
.text$mn:00008156                 mov     [edx+8], eax
.text$mn:00008159                 mov     esp, ebp
.text$mn:0000815B                 pop     ebp
.text$mn:0000815C                 retn    8
.text$mn:0000815C ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:0000815C
.text$mn:0000815C ; ---------------------------------------------------------------------------
.text$mn:0000815F                 align 10h
.text$mn:0000815F _text$mn        ends
.text$mn:0000815F
.text$mn:00008160 ; ===========================================================================
.text$mn:00008160
.text$mn:00008160 ; Segment type: Pure code
.text$mn:00008160 ; Segment permissions: Read/Execute
.text$mn:00008160 _text$mn        segment para public 'CODE' use32
.text$mn:00008160                 assume cs:_text$mn
.text$mn:00008160                 ;org 8160h
.text$mn:00008160 ; COMDAT (pick any)
.text$mn:00008160                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008160
.text$mn:00008160 ; =============== S U B R O U T I N E =======================================
.text$mn:00008160
.text$mn:00008160 ; Attributes: bp-based frame
.text$mn:00008160
.text$mn:00008160 ; bool __thiscall DockingCont::isFloating(DockingCont *__hidden this)
.text$mn:00008160                 public ?isFloating@DockingCont@@QAE_NXZ
.text$mn:00008160 ?isFloating@DockingCont@@QAE_NXZ proc near
.text$mn:00008160                                         ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+125p
.text$mn:00008160                                         ; DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+176p ...
.text$mn:00008160
.text$mn:00008160 var_4           = dword ptr -4
.text$mn:00008160
.text$mn:00008160                 push    ebp
.text$mn:00008161                 mov     ebp, esp
.text$mn:00008163                 push    ecx
.text$mn:00008164                 mov     [ebp+var_4], ecx
.text$mn:00008167                 mov     eax, [ebp+var_4]
.text$mn:0000816A                 mov     al, [eax+24h]
.text$mn:0000816D                 mov     esp, ebp
.text$mn:0000816F                 pop     ebp
.text$mn:00008170                 retn
.text$mn:00008170 ?isFloating@DockingCont@@QAE_NXZ endp
.text$mn:00008170
.text$mn:00008170 ; ---------------------------------------------------------------------------
.text$mn:00008171                 align 4
.text$mn:00008171 _text$mn        ends
.text$mn:00008171
.text$mn:00008174 ; ===========================================================================
.text$mn:00008174
.text$mn:00008174 ; Segment type: Pure code
.text$mn:00008174 ; Segment permissions: Read/Execute
.text$mn:00008174 _text$mn        segment para public 'CODE' use32
.text$mn:00008174                 assume cs:_text$mn
.text$mn:00008174                 ;org 8174h
.text$mn:00008174 ; COMDAT (pick any)
.text$mn:00008174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008174
.text$mn:00008174 ; =============== S U B R O U T I N E =======================================
.text$mn:00008174
.text$mn:00008174 ; Attributes: bp-based frame
.text$mn:00008174
.text$mn:00008174 ; bool __thiscall Window::isVisible(Window *__hidden this)
.text$mn:00008174                 public ?isVisible@Window@@UBE_NXZ
.text$mn:00008174 ?isVisible@Window@@UBE_NXZ proc near    ; DATA XREF: .rdata:00009CACo
.text$mn:00008174                                         ; .rdata:00009E38o ...
.text$mn:00008174
.text$mn:00008174 var_8           = dword ptr -8
.text$mn:00008174 var_1           = byte ptr -1
.text$mn:00008174
.text$mn:00008174                 push    ebp
.text$mn:00008175                 mov     ebp, esp
.text$mn:00008177                 sub     esp, 8
.text$mn:0000817A                 mov     [ebp+var_8], ecx
.text$mn:0000817D                 mov     eax, [ebp+var_8]
.text$mn:00008180                 mov     ecx, [eax+0Ch]
.text$mn:00008183                 push    ecx             ; hWnd
.text$mn:00008184                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:0000818A                 test    eax, eax
.text$mn:0000818C                 jz      short loc_8194
.text$mn:0000818E                 mov     [ebp+var_1], 1
.text$mn:00008192                 jmp     short loc_8198
.text$mn:00008194 ; ---------------------------------------------------------------------------
.text$mn:00008194
.text$mn:00008194 loc_8194:                               ; CODE XREF: Window::isVisible(void)+18j
.text$mn:00008194                 mov     [ebp+var_1], 0
.text$mn:00008198
.text$mn:00008198 loc_8198:                               ; CODE XREF: Window::isVisible(void)+1Ej
.text$mn:00008198                 mov     al, [ebp+var_1]
.text$mn:0000819B                 mov     esp, ebp
.text$mn:0000819D                 pop     ebp
.text$mn:0000819E                 retn
.text$mn:0000819E ?isVisible@Window@@UBE_NXZ endp
.text$mn:0000819E
.text$mn:0000819E ; ---------------------------------------------------------------------------
.text$mn:0000819F                 align 10h
.text$mn:0000819F _text$mn        ends
.text$mn:0000819F
.text$mn:000081A0 ; ===========================================================================
.text$mn:000081A0
.text$mn:000081A0 ; Segment type: Pure code
.text$mn:000081A0 ; Segment permissions: Read/Execute
.text$mn:000081A0 _text$mn        segment para public 'CODE' use32
.text$mn:000081A0                 assume cs:_text$mn
.text$mn:000081A0                 ;org 81A0h
.text$mn:000081A0 ; COMDAT (pick any)
.text$mn:000081A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000081A0
.text$mn:000081A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000081A0
.text$mn:000081A0 ; Attributes: bp-based frame
.text$mn:000081A0
.text$mn:000081A0 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:000081A0                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:000081A0 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:000081A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:000081A0
.text$mn:000081A0 var_4           = dword ptr -4
.text$mn:000081A0 Str             = dword ptr  8
.text$mn:000081A0
.text$mn:000081A0                 push    ebp
.text$mn:000081A1                 mov     ebp, esp
.text$mn:000081A3                 push    ecx
.text$mn:000081A4                 mov     eax, [ebp+Str]
.text$mn:000081A7                 movsx   ecx, byte ptr [eax]
.text$mn:000081AA                 test    ecx, ecx
.text$mn:000081AC                 jnz     short loc_81B7
.text$mn:000081AE                 mov     [ebp+var_4], 0
.text$mn:000081B5                 jmp     short loc_81C6
.text$mn:000081B7 ; ---------------------------------------------------------------------------
.text$mn:000081B7
.text$mn:000081B7 loc_81B7:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:000081B7                 mov     edx, [ebp+Str]
.text$mn:000081BA                 push    edx             ; Str
.text$mn:000081BB                 call    _strlen
.text$mn:000081C0                 add     esp, 4
.text$mn:000081C3                 mov     [ebp+var_4], eax
.text$mn:000081C6
.text$mn:000081C6 loc_81C6:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:000081C6                 mov     eax, [ebp+var_4]
.text$mn:000081C9                 mov     esp, ebp
.text$mn:000081CB                 pop     ebp
.text$mn:000081CC                 retn
.text$mn:000081CC ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:000081CC
.text$mn:000081CC ; ---------------------------------------------------------------------------
.text$mn:000081CD                 align 10h
.text$mn:000081CD _text$mn        ends
.text$mn:000081CD
.text$mn:000081D0 ; ===========================================================================
.text$mn:000081D0
.text$mn:000081D0 ; Segment type: Pure code
.text$mn:000081D0 ; Segment permissions: Read/Execute
.text$mn:000081D0 _text$mn        segment para public 'CODE' use32
.text$mn:000081D0                 assume cs:_text$mn
.text$mn:000081D0                 ;org 81D0h
.text$mn:000081D0 ; COMDAT (pick any)
.text$mn:000081D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000081D0
.text$mn:000081D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000081D0
.text$mn:000081D0 ; Attributes: bp-based frame
.text$mn:000081D0
.text$mn:000081D0 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:000081D0                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:000081D0 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:000081D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:000081D0
.text$mn:000081D0 var_4           = dword ptr -4
.text$mn:000081D0
.text$mn:000081D0                 push    ebp
.text$mn:000081D1                 mov     ebp, esp
.text$mn:000081D3                 push    ecx
.text$mn:000081D4                 mov     [ebp+var_4], ecx
.text$mn:000081D7                 mov     eax, [ebp+var_4]
.text$mn:000081DA                 push    eax
.text$mn:000081DB                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000081E0                 add     esp, 4
.text$mn:000081E3                 mov     esp, ebp
.text$mn:000081E5                 pop     ebp
.text$mn:000081E6                 retn
.text$mn:000081E6 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000081E6
.text$mn:000081E6 ; ---------------------------------------------------------------------------
.text$mn:000081E7                 align 4
.text$mn:000081E7 _text$mn        ends
.text$mn:000081E7
.text$mn:000081E8 ; ===========================================================================
.text$mn:000081E8
.text$mn:000081E8 ; Segment type: Pure code
.text$mn:000081E8 ; Segment permissions: Read/Execute
.text$mn:000081E8 _text$mn        segment para public 'CODE' use32
.text$mn:000081E8                 assume cs:_text$mn
.text$mn:000081E8                 ;org 81E8h
.text$mn:000081E8 ; COMDAT (pick any)
.text$mn:000081E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000081E8
.text$mn:000081E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000081E8
.text$mn:000081E8 ; Attributes: bp-based frame
.text$mn:000081E8
.text$mn:000081E8 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct HWND__ *>>::max_size(void)const
.text$mn:000081E8                 public ?max_size@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ
.text$mn:000081E8 ?max_size@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ proc near
.text$mn:000081E8                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::max_size(void)+17p
.text$mn:000081E8
.text$mn:000081E8 var_4           = dword ptr -4
.text$mn:000081E8
.text$mn:000081E8                 push    ebp
.text$mn:000081E9                 mov     ebp, esp
.text$mn:000081EB                 push    ecx
.text$mn:000081EC                 mov     [ebp+var_4], ecx
.text$mn:000081EF                 mov     eax, [ebp+var_4]
.text$mn:000081F2                 push    eax
.text$mn:000081F3                 call    ?max_size@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAIABV?$allocator@PAUHWND__@@@2@@Z ; std::allocator_traits<std::allocator<HWND__ *>>::max_size(std::allocator<HWND__ *> const &)
.text$mn:000081F8                 add     esp, 4
.text$mn:000081FB                 mov     esp, ebp
.text$mn:000081FD                 pop     ebp
.text$mn:000081FE                 retn
.text$mn:000081FE ?max_size@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ endp
.text$mn:000081FE
.text$mn:000081FE ; ---------------------------------------------------------------------------
.text$mn:000081FF                 align 10h
.text$mn:000081FF _text$mn        ends
.text$mn:000081FF
.text$mn:00008200 ; ===========================================================================
.text$mn:00008200
.text$mn:00008200 ; Segment type: Pure code
.text$mn:00008200 ; Segment permissions: Read/Execute
.text$mn:00008200 _text$mn        segment para public 'CODE' use32
.text$mn:00008200                 assume cs:_text$mn
.text$mn:00008200                 ;org 8200h
.text$mn:00008200 ; COMDAT (pick any)
.text$mn:00008200                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008200
.text$mn:00008200 ; =============== S U B R O U T I N E =======================================
.text$mn:00008200
.text$mn:00008200 ; Attributes: bp-based frame
.text$mn:00008200
.text$mn:00008200 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct tTbData *>>::max_size(void)const
.text$mn:00008200                 public ?max_size@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ
.text$mn:00008200 ?max_size@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ proc near
.text$mn:00008200                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::max_size(void)+17p
.text$mn:00008200
.text$mn:00008200 var_4           = dword ptr -4
.text$mn:00008200
.text$mn:00008200                 push    ebp
.text$mn:00008201                 mov     ebp, esp
.text$mn:00008203                 push    ecx
.text$mn:00008204                 mov     [ebp+var_4], ecx
.text$mn:00008207                 mov     eax, [ebp+var_4]
.text$mn:0000820A                 push    eax
.text$mn:0000820B                 call    ?max_size@?$allocator_traits@V?$allocator@PAUtTbData@@@std@@@std@@SAIABV?$allocator@PAUtTbData@@@2@@Z ; std::allocator_traits<std::allocator<tTbData *>>::max_size(std::allocator<tTbData *> const &)
.text$mn:00008210                 add     esp, 4
.text$mn:00008213                 mov     esp, ebp
.text$mn:00008215                 pop     ebp
.text$mn:00008216                 retn
.text$mn:00008216 ?max_size@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ endp
.text$mn:00008216
.text$mn:00008216 ; ---------------------------------------------------------------------------
.text$mn:00008217                 align 4
.text$mn:00008217 _text$mn        ends
.text$mn:00008217
.text$mn:00008218 ; ===========================================================================
.text$mn:00008218
.text$mn:00008218 ; Segment type: Pure code
.text$mn:00008218 ; Segment permissions: Read/Execute
.text$mn:00008218 _text$mn        segment para public 'CODE' use32
.text$mn:00008218                 assume cs:_text$mn
.text$mn:00008218                 ;org 8218h
.text$mn:00008218 ; COMDAT (pick any)
.text$mn:00008218                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008218
.text$mn:00008218 ; =============== S U B R O U T I N E =======================================
.text$mn:00008218
.text$mn:00008218 ; Attributes: bp-based frame
.text$mn:00008218
.text$mn:00008218 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class DockingCont *>>::max_size(void)const
.text$mn:00008218                 public ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ
.text$mn:00008218 ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ proc near
.text$mn:00008218                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::max_size(void)+17p
.text$mn:00008218
.text$mn:00008218 var_4           = dword ptr -4
.text$mn:00008218
.text$mn:00008218                 push    ebp
.text$mn:00008219                 mov     ebp, esp
.text$mn:0000821B                 push    ecx
.text$mn:0000821C                 mov     [ebp+var_4], ecx
.text$mn:0000821F                 mov     eax, [ebp+var_4]
.text$mn:00008222                 push    eax
.text$mn:00008223                 call    ?max_size@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAIABV?$allocator@PAVDockingCont@@@2@@Z ; std::allocator_traits<std::allocator<DockingCont *>>::max_size(std::allocator<DockingCont *> const &)
.text$mn:00008228                 add     esp, 4
.text$mn:0000822B                 mov     esp, ebp
.text$mn:0000822D                 pop     ebp
.text$mn:0000822E                 retn
.text$mn:0000822E ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ endp
.text$mn:0000822E
.text$mn:0000822E ; ---------------------------------------------------------------------------
.text$mn:0000822F                 align 10h
.text$mn:0000822F _text$mn        ends
.text$mn:0000822F
.text$mn:00008230 ; ===========================================================================
.text$mn:00008230
.text$mn:00008230 ; Segment type: Pure code
.text$mn:00008230 ; Segment permissions: Read/Execute
.text$mn:00008230 _text$mn        segment para public 'CODE' use32
.text$mn:00008230                 assume cs:_text$mn
.text$mn:00008230                 ;org 8230h
.text$mn:00008230 ; COMDAT (pick any)
.text$mn:00008230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008230
.text$mn:00008230 ; =============== S U B R O U T I N E =======================================
.text$mn:00008230
.text$mn:00008230 ; Attributes: bp-based frame
.text$mn:00008230
.text$mn:00008230 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class DockingSplitter *>>::max_size(void)const
.text$mn:00008230                 public ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ
.text$mn:00008230 ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ proc near
.text$mn:00008230                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::max_size(void)+17p
.text$mn:00008230
.text$mn:00008230 var_4           = dword ptr -4
.text$mn:00008230
.text$mn:00008230                 push    ebp
.text$mn:00008231                 mov     ebp, esp
.text$mn:00008233                 push    ecx
.text$mn:00008234                 mov     [ebp+var_4], ecx
.text$mn:00008237                 mov     eax, [ebp+var_4]
.text$mn:0000823A                 push    eax
.text$mn:0000823B                 call    ?max_size@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAIABV?$allocator@PAVDockingSplitter@@@2@@Z ; std::allocator_traits<std::allocator<DockingSplitter *>>::max_size(std::allocator<DockingSplitter *> const &)
.text$mn:00008240                 add     esp, 4
.text$mn:00008243                 mov     esp, ebp
.text$mn:00008245                 pop     ebp
.text$mn:00008246                 retn
.text$mn:00008246 ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ endp
.text$mn:00008246
.text$mn:00008246 ; ---------------------------------------------------------------------------
.text$mn:00008247                 align 4
.text$mn:00008247 _text$mn        ends
.text$mn:00008247
.text$mn:00008248 ; ===========================================================================
.text$mn:00008248
.text$mn:00008248 ; Segment type: Pure code
.text$mn:00008248 ; Segment permissions: Read/Execute
.text$mn:00008248 _text$mn        segment para public 'CODE' use32
.text$mn:00008248                 assume cs:_text$mn
.text$mn:00008248                 ;org 8248h
.text$mn:00008248 ; COMDAT (pick any)
.text$mn:00008248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008248
.text$mn:00008248 ; =============== S U B R O U T I N E =======================================
.text$mn:00008248
.text$mn:00008248 ; Attributes: bp-based frame
.text$mn:00008248
.text$mn:00008248 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00008248                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00008248 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00008248                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00008248
.text$mn:00008248 var_4           = dword ptr -4
.text$mn:00008248
.text$mn:00008248                 push    ebp
.text$mn:00008249                 mov     ebp, esp
.text$mn:0000824B                 push    ecx
.text$mn:0000824C                 mov     [ebp+var_4], ecx
.text$mn:0000824F                 or      eax, 0FFFFFFFFh
.text$mn:00008252                 mov     esp, ebp
.text$mn:00008254                 pop     ebp
.text$mn:00008255                 retn
.text$mn:00008255 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00008255
.text$mn:00008255 ; ---------------------------------------------------------------------------
.text$mn:00008256                 align 4
.text$mn:00008256 _text$mn        ends
.text$mn:00008256
.text$mn:00008258 ; ===========================================================================
.text$mn:00008258
.text$mn:00008258 ; Segment type: Pure code
.text$mn:00008258 ; Segment permissions: Read/Execute
.text$mn:00008258 _text$mn        segment para public 'CODE' use32
.text$mn:00008258                 assume cs:_text$mn
.text$mn:00008258                 ;org 8258h
.text$mn:00008258 ; COMDAT (pick any)
.text$mn:00008258                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008258
.text$mn:00008258 ; =============== S U B R O U T I N E =======================================
.text$mn:00008258
.text$mn:00008258 ; Attributes: bp-based frame
.text$mn:00008258
.text$mn:00008258 ; public: unsigned int __thiscall std::allocator<struct HWND__ *>::max_size(void)const
.text$mn:00008258                 public ?max_size@?$allocator@PAUHWND__@@@std@@QBEIXZ
.text$mn:00008258 ?max_size@?$allocator@PAUHWND__@@@std@@QBEIXZ proc near
.text$mn:00008258                                         ; CODE XREF: std::allocator_traits<std::allocator<HWND__ *>>::max_size(std::allocator<HWND__ *> const &)+6p
.text$mn:00008258
.text$mn:00008258 var_4           = dword ptr -4
.text$mn:00008258
.text$mn:00008258                 push    ebp
.text$mn:00008259                 mov     ebp, esp
.text$mn:0000825B                 push    ecx
.text$mn:0000825C                 mov     [ebp+var_4], ecx
.text$mn:0000825F                 mov     eax, 3FFFFFFFh
.text$mn:00008264                 mov     esp, ebp
.text$mn:00008266                 pop     ebp
.text$mn:00008267                 retn
.text$mn:00008267 ?max_size@?$allocator@PAUHWND__@@@std@@QBEIXZ endp
.text$mn:00008267
.text$mn:00008267 _text$mn        ends
.text$mn:00008267
.text$mn:00008268 ; ===========================================================================
.text$mn:00008268
.text$mn:00008268 ; Segment type: Pure code
.text$mn:00008268 ; Segment permissions: Read/Execute
.text$mn:00008268 _text$mn        segment para public 'CODE' use32
.text$mn:00008268                 assume cs:_text$mn
.text$mn:00008268                 ;org 8268h
.text$mn:00008268 ; COMDAT (pick any)
.text$mn:00008268                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008268
.text$mn:00008268 ; =============== S U B R O U T I N E =======================================
.text$mn:00008268
.text$mn:00008268 ; Attributes: bp-based frame
.text$mn:00008268
.text$mn:00008268 ; public: unsigned int __thiscall std::allocator<struct tTbData *>::max_size(void)const
.text$mn:00008268                 public ?max_size@?$allocator@PAUtTbData@@@std@@QBEIXZ
.text$mn:00008268 ?max_size@?$allocator@PAUtTbData@@@std@@QBEIXZ proc near
.text$mn:00008268                                         ; CODE XREF: std::allocator_traits<std::allocator<tTbData *>>::max_size(std::allocator<tTbData *> const &)+6p
.text$mn:00008268
.text$mn:00008268 var_4           = dword ptr -4
.text$mn:00008268
.text$mn:00008268                 push    ebp
.text$mn:00008269                 mov     ebp, esp
.text$mn:0000826B                 push    ecx
.text$mn:0000826C                 mov     [ebp+var_4], ecx
.text$mn:0000826F                 mov     eax, 3FFFFFFFh
.text$mn:00008274                 mov     esp, ebp
.text$mn:00008276                 pop     ebp
.text$mn:00008277                 retn
.text$mn:00008277 ?max_size@?$allocator@PAUtTbData@@@std@@QBEIXZ endp
.text$mn:00008277
.text$mn:00008277 _text$mn        ends
.text$mn:00008277
.text$mn:00008278 ; ===========================================================================
.text$mn:00008278
.text$mn:00008278 ; Segment type: Pure code
.text$mn:00008278 ; Segment permissions: Read/Execute
.text$mn:00008278 _text$mn        segment para public 'CODE' use32
.text$mn:00008278                 assume cs:_text$mn
.text$mn:00008278                 ;org 8278h
.text$mn:00008278 ; COMDAT (pick any)
.text$mn:00008278                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008278
.text$mn:00008278 ; =============== S U B R O U T I N E =======================================
.text$mn:00008278
.text$mn:00008278 ; Attributes: bp-based frame
.text$mn:00008278
.text$mn:00008278 ; public: unsigned int __thiscall std::allocator<class DockingCont *>::max_size(void)const
.text$mn:00008278                 public ?max_size@?$allocator@PAVDockingCont@@@std@@QBEIXZ
.text$mn:00008278 ?max_size@?$allocator@PAVDockingCont@@@std@@QBEIXZ proc near
.text$mn:00008278                                         ; CODE XREF: std::allocator_traits<std::allocator<DockingCont *>>::max_size(std::allocator<DockingCont *> const &)+6p
.text$mn:00008278
.text$mn:00008278 var_4           = dword ptr -4
.text$mn:00008278
.text$mn:00008278                 push    ebp
.text$mn:00008279                 mov     ebp, esp
.text$mn:0000827B                 push    ecx
.text$mn:0000827C                 mov     [ebp+var_4], ecx
.text$mn:0000827F                 mov     eax, 3FFFFFFFh
.text$mn:00008284                 mov     esp, ebp
.text$mn:00008286                 pop     ebp
.text$mn:00008287                 retn
.text$mn:00008287 ?max_size@?$allocator@PAVDockingCont@@@std@@QBEIXZ endp
.text$mn:00008287
.text$mn:00008287 _text$mn        ends
.text$mn:00008287
.text$mn:00008288 ; ===========================================================================
.text$mn:00008288
.text$mn:00008288 ; Segment type: Pure code
.text$mn:00008288 ; Segment permissions: Read/Execute
.text$mn:00008288 _text$mn        segment para public 'CODE' use32
.text$mn:00008288                 assume cs:_text$mn
.text$mn:00008288                 ;org 8288h
.text$mn:00008288 ; COMDAT (pick any)
.text$mn:00008288                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008288
.text$mn:00008288 ; =============== S U B R O U T I N E =======================================
.text$mn:00008288
.text$mn:00008288 ; Attributes: bp-based frame
.text$mn:00008288
.text$mn:00008288 ; public: unsigned int __thiscall std::allocator<class DockingSplitter *>::max_size(void)const
.text$mn:00008288                 public ?max_size@?$allocator@PAVDockingSplitter@@@std@@QBEIXZ
.text$mn:00008288 ?max_size@?$allocator@PAVDockingSplitter@@@std@@QBEIXZ proc near
.text$mn:00008288                                         ; CODE XREF: std::allocator_traits<std::allocator<DockingSplitter *>>::max_size(std::allocator<DockingSplitter *> const &)+6p
.text$mn:00008288
.text$mn:00008288 var_4           = dword ptr -4
.text$mn:00008288
.text$mn:00008288                 push    ebp
.text$mn:00008289                 mov     ebp, esp
.text$mn:0000828B                 push    ecx
.text$mn:0000828C                 mov     [ebp+var_4], ecx
.text$mn:0000828F                 mov     eax, 3FFFFFFFh
.text$mn:00008294                 mov     esp, ebp
.text$mn:00008296                 pop     ebp
.text$mn:00008297                 retn
.text$mn:00008297 ?max_size@?$allocator@PAVDockingSplitter@@@std@@QBEIXZ endp
.text$mn:00008297
.text$mn:00008297 _text$mn        ends
.text$mn:00008297
.text$mn:00008298 ; ===========================================================================
.text$mn:00008298
.text$mn:00008298 ; Segment type: Pure code
.text$mn:00008298 ; Segment permissions: Read/Execute
.text$mn:00008298 _text$mn        segment para public 'CODE' use32
.text$mn:00008298                 assume cs:_text$mn
.text$mn:00008298                 ;org 8298h
.text$mn:00008298 ; COMDAT (pick any)
.text$mn:00008298                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008298
.text$mn:00008298 ; =============== S U B R O U T I N E =======================================
.text$mn:00008298
.text$mn:00008298 ; Attributes: bp-based frame
.text$mn:00008298
.text$mn:00008298 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00008298                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00008298 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00008298                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00008298
.text$mn:00008298 arg_0           = dword ptr  8
.text$mn:00008298
.text$mn:00008298                 push    ebp
.text$mn:00008299                 mov     ebp, esp
.text$mn:0000829B                 mov     ecx, [ebp+arg_0]
.text$mn:0000829E                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000082A3                 pop     ebp
.text$mn:000082A4                 retn
.text$mn:000082A4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000082A4
.text$mn:000082A4 ; ---------------------------------------------------------------------------
.text$mn:000082A5                 align 4
.text$mn:000082A5 _text$mn        ends
.text$mn:000082A5
.text$mn:000082A8 ; ===========================================================================
.text$mn:000082A8
.text$mn:000082A8 ; Segment type: Pure code
.text$mn:000082A8 ; Segment permissions: Read/Execute
.text$mn:000082A8 _text$mn        segment para public 'CODE' use32
.text$mn:000082A8                 assume cs:_text$mn
.text$mn:000082A8                 ;org 82A8h
.text$mn:000082A8 ; COMDAT (pick any)
.text$mn:000082A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000082A8
.text$mn:000082A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000082A8
.text$mn:000082A8 ; Attributes: bp-based frame
.text$mn:000082A8
.text$mn:000082A8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct HWND__ *>>::max_size(class std::allocator<struct HWND__ *> const &)
.text$mn:000082A8                 public ?max_size@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAIABV?$allocator@PAUHWND__@@@2@@Z
.text$mn:000082A8 ?max_size@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAIABV?$allocator@PAUHWND__@@@2@@Z proc near
.text$mn:000082A8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<HWND__ *>>::max_size(void)+Bp
.text$mn:000082A8
.text$mn:000082A8 arg_0           = dword ptr  8
.text$mn:000082A8
.text$mn:000082A8                 push    ebp
.text$mn:000082A9                 mov     ebp, esp
.text$mn:000082AB                 mov     ecx, [ebp+arg_0]
.text$mn:000082AE                 call    ?max_size@?$allocator@PAUHWND__@@@std@@QBEIXZ ; std::allocator<HWND__ *>::max_size(void)
.text$mn:000082B3                 pop     ebp
.text$mn:000082B4                 retn
.text$mn:000082B4 ?max_size@?$allocator_traits@V?$allocator@PAUHWND__@@@std@@@std@@SAIABV?$allocator@PAUHWND__@@@2@@Z endp
.text$mn:000082B4
.text$mn:000082B4 ; ---------------------------------------------------------------------------
.text$mn:000082B5                 align 4
.text$mn:000082B5 _text$mn        ends
.text$mn:000082B5
.text$mn:000082B8 ; ===========================================================================
.text$mn:000082B8
.text$mn:000082B8 ; Segment type: Pure code
.text$mn:000082B8 ; Segment permissions: Read/Execute
.text$mn:000082B8 _text$mn        segment para public 'CODE' use32
.text$mn:000082B8                 assume cs:_text$mn
.text$mn:000082B8                 ;org 82B8h
.text$mn:000082B8 ; COMDAT (pick any)
.text$mn:000082B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000082B8
.text$mn:000082B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000082B8
.text$mn:000082B8 ; Attributes: bp-based frame
.text$mn:000082B8
.text$mn:000082B8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct tTbData *>>::max_size(class std::allocator<struct tTbData *> const &)
.text$mn:000082B8                 public ?max_size@?$allocator_traits@V?$allocator@PAUtTbData@@@std@@@std@@SAIABV?$allocator@PAUtTbData@@@2@@Z
.text$mn:000082B8 ?max_size@?$allocator_traits@V?$allocator@PAUtTbData@@@std@@@std@@SAIABV?$allocator@PAUtTbData@@@2@@Z proc near
.text$mn:000082B8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tTbData *>>::max_size(void)+Bp
.text$mn:000082B8
.text$mn:000082B8 arg_0           = dword ptr  8
.text$mn:000082B8
.text$mn:000082B8                 push    ebp
.text$mn:000082B9                 mov     ebp, esp
.text$mn:000082BB                 mov     ecx, [ebp+arg_0]
.text$mn:000082BE                 call    ?max_size@?$allocator@PAUtTbData@@@std@@QBEIXZ ; std::allocator<tTbData *>::max_size(void)
.text$mn:000082C3                 pop     ebp
.text$mn:000082C4                 retn
.text$mn:000082C4 ?max_size@?$allocator_traits@V?$allocator@PAUtTbData@@@std@@@std@@SAIABV?$allocator@PAUtTbData@@@2@@Z endp
.text$mn:000082C4
.text$mn:000082C4 ; ---------------------------------------------------------------------------
.text$mn:000082C5                 align 4
.text$mn:000082C5 _text$mn        ends
.text$mn:000082C5
.text$mn:000082C8 ; ===========================================================================
.text$mn:000082C8
.text$mn:000082C8 ; Segment type: Pure code
.text$mn:000082C8 ; Segment permissions: Read/Execute
.text$mn:000082C8 _text$mn        segment para public 'CODE' use32
.text$mn:000082C8                 assume cs:_text$mn
.text$mn:000082C8                 ;org 82C8h
.text$mn:000082C8 ; COMDAT (pick any)
.text$mn:000082C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000082C8
.text$mn:000082C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000082C8
.text$mn:000082C8 ; Attributes: bp-based frame
.text$mn:000082C8
.text$mn:000082C8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class DockingCont *>>::max_size(class std::allocator<class DockingCont *> const &)
.text$mn:000082C8                 public ?max_size@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAIABV?$allocator@PAVDockingCont@@@2@@Z
.text$mn:000082C8 ?max_size@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAIABV?$allocator@PAVDockingCont@@@2@@Z proc near
.text$mn:000082C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::max_size(void)+Bp
.text$mn:000082C8
.text$mn:000082C8 arg_0           = dword ptr  8
.text$mn:000082C8
.text$mn:000082C8                 push    ebp
.text$mn:000082C9                 mov     ebp, esp
.text$mn:000082CB                 mov     ecx, [ebp+arg_0]
.text$mn:000082CE                 call    ?max_size@?$allocator@PAVDockingCont@@@std@@QBEIXZ ; std::allocator<DockingCont *>::max_size(void)
.text$mn:000082D3                 pop     ebp
.text$mn:000082D4                 retn
.text$mn:000082D4 ?max_size@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAIABV?$allocator@PAVDockingCont@@@2@@Z endp
.text$mn:000082D4
.text$mn:000082D4 ; ---------------------------------------------------------------------------
.text$mn:000082D5                 align 4
.text$mn:000082D5 _text$mn        ends
.text$mn:000082D5
.text$mn:000082D8 ; ===========================================================================
.text$mn:000082D8
.text$mn:000082D8 ; Segment type: Pure code
.text$mn:000082D8 ; Segment permissions: Read/Execute
.text$mn:000082D8 _text$mn        segment para public 'CODE' use32
.text$mn:000082D8                 assume cs:_text$mn
.text$mn:000082D8                 ;org 82D8h
.text$mn:000082D8 ; COMDAT (pick any)
.text$mn:000082D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000082D8
.text$mn:000082D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000082D8
.text$mn:000082D8 ; Attributes: bp-based frame
.text$mn:000082D8
.text$mn:000082D8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class DockingSplitter *>>::max_size(class std::allocator<class DockingSplitter *> const &)
.text$mn:000082D8                 public ?max_size@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAIABV?$allocator@PAVDockingSplitter@@@2@@Z
.text$mn:000082D8 ?max_size@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAIABV?$allocator@PAVDockingSplitter@@@2@@Z proc near
.text$mn:000082D8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingSplitter *>>::max_size(void)+Bp
.text$mn:000082D8
.text$mn:000082D8 arg_0           = dword ptr  8
.text$mn:000082D8
.text$mn:000082D8                 push    ebp
.text$mn:000082D9                 mov     ebp, esp
.text$mn:000082DB                 mov     ecx, [ebp+arg_0]
.text$mn:000082DE                 call    ?max_size@?$allocator@PAVDockingSplitter@@@std@@QBEIXZ ; std::allocator<DockingSplitter *>::max_size(void)
.text$mn:000082E3                 pop     ebp
.text$mn:000082E4                 retn
.text$mn:000082E4 ?max_size@?$allocator_traits@V?$allocator@PAVDockingSplitter@@@std@@@std@@SAIABV?$allocator@PAVDockingSplitter@@@2@@Z endp
.text$mn:000082E4
.text$mn:000082E4 ; ---------------------------------------------------------------------------
.text$mn:000082E5                 align 4
.text$mn:000082E5 _text$mn        ends
.text$mn:000082E5
.text$mn:000082E8 ; ===========================================================================
.text$mn:000082E8
.text$mn:000082E8 ; Segment type: Pure code
.text$mn:000082E8 ; Segment permissions: Read/Execute
.text$mn:000082E8 _text$mn        segment para public 'CODE' use32
.text$mn:000082E8                 assume cs:_text$mn
.text$mn:000082E8                 ;org 82E8h
.text$mn:000082E8 ; COMDAT (pick any)
.text$mn:000082E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000082E8
.text$mn:000082E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000082E8
.text$mn:000082E8 ; Attributes: bp-based frame
.text$mn:000082E8
.text$mn:000082E8 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000082E8                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000082E8 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000082E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000082E8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000082E8
.text$mn:000082E8 var_10          = dword ptr -10h
.text$mn:000082E8 var_C           = dword ptr -0Ch
.text$mn:000082E8 var_8           = dword ptr -8
.text$mn:000082E8 var_1           = byte ptr -1
.text$mn:000082E8
.text$mn:000082E8                 push    ebp
.text$mn:000082E9                 mov     ebp, esp
.text$mn:000082EB                 sub     esp, 10h
.text$mn:000082EE                 mov     [ebp+var_10], ecx
.text$mn:000082F1                 lea     eax, [ebp+var_1]
.text$mn:000082F4                 push    eax
.text$mn:000082F5                 mov     ecx, [ebp+var_10]
.text$mn:000082F8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000082FD                 mov     ecx, eax
.text$mn:000082FF                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00008304                 mov     [ebp+var_8], eax
.text$mn:00008307                 cmp     [ebp+var_8], 1
.text$mn:0000830B                 ja      short loc_8316
.text$mn:0000830D                 mov     [ebp+var_C], 1
.text$mn:00008314                 jmp     short loc_831F
.text$mn:00008316 ; ---------------------------------------------------------------------------
.text$mn:00008316
.text$mn:00008316 loc_8316:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00008316                 mov     ecx, [ebp+var_8]
.text$mn:00008319                 sub     ecx, 1
.text$mn:0000831C                 mov     [ebp+var_C], ecx
.text$mn:0000831F
.text$mn:0000831F loc_831F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000831F                 mov     eax, [ebp+var_C]
.text$mn:00008322                 mov     esp, ebp
.text$mn:00008324                 pop     ebp
.text$mn:00008325                 retn
.text$mn:00008325 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00008325
.text$mn:00008325 ; ---------------------------------------------------------------------------
.text$mn:00008326                 align 4
.text$mn:00008326 _text$mn        ends
.text$mn:00008326
.text$mn:00008328 ; ===========================================================================
.text$mn:00008328
.text$mn:00008328 ; Segment type: Pure code
.text$mn:00008328 ; Segment permissions: Read/Execute
.text$mn:00008328 _text$mn        segment para public 'CODE' use32
.text$mn:00008328                 assume cs:_text$mn
.text$mn:00008328                 ;org 8328h
.text$mn:00008328 ; COMDAT (pick any)
.text$mn:00008328                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008328
.text$mn:00008328 ; =============== S U B R O U T I N E =======================================
.text$mn:00008328
.text$mn:00008328 ; Attributes: bp-based frame
.text$mn:00008328
.text$mn:00008328 ; public: unsigned int __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::max_size(void)const
.text$mn:00008328                 public ?max_size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ
.text$mn:00008328 ?max_size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ proc near
.text$mn:00008328                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Grow_to(uint)+17p
.text$mn:00008328                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reserve(uint)+18p
.text$mn:00008328
.text$mn:00008328 var_8           = dword ptr -8
.text$mn:00008328 var_1           = byte ptr -1
.text$mn:00008328
.text$mn:00008328                 push    ebp
.text$mn:00008329                 mov     ebp, esp
.text$mn:0000832B                 sub     esp, 8
.text$mn:0000832E                 mov     [ebp+var_8], ecx
.text$mn:00008331                 lea     eax, [ebp+var_1]
.text$mn:00008334                 push    eax
.text$mn:00008335                 mov     ecx, [ebp+var_8]
.text$mn:00008338                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Getal(void)
.text$mn:0000833D                 mov     ecx, eax
.text$mn:0000833F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<HWND__ *>>::max_size(void)
.text$mn:00008344                 mov     esp, ebp
.text$mn:00008346                 pop     ebp
.text$mn:00008347                 retn
.text$mn:00008347 ?max_size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ endp
.text$mn:00008347
.text$mn:00008347 _text$mn        ends
.text$mn:00008347
.text$mn:00008348 ; ===========================================================================
.text$mn:00008348
.text$mn:00008348 ; Segment type: Pure code
.text$mn:00008348 ; Segment permissions: Read/Execute
.text$mn:00008348 _text$mn        segment para public 'CODE' use32
.text$mn:00008348                 assume cs:_text$mn
.text$mn:00008348                 ;org 8348h
.text$mn:00008348 ; COMDAT (pick any)
.text$mn:00008348                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008348
.text$mn:00008348 ; =============== S U B R O U T I N E =======================================
.text$mn:00008348
.text$mn:00008348 ; Attributes: bp-based frame
.text$mn:00008348
.text$mn:00008348 ; public: unsigned int __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::max_size(void)const
.text$mn:00008348                 public ?max_size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ
.text$mn:00008348 ?max_size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ proc near
.text$mn:00008348                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::_Buy(uint)+36p
.text$mn:00008348
.text$mn:00008348 var_8           = dword ptr -8
.text$mn:00008348 var_1           = byte ptr -1
.text$mn:00008348
.text$mn:00008348                 push    ebp
.text$mn:00008349                 mov     ebp, esp
.text$mn:0000834B                 sub     esp, 8
.text$mn:0000834E                 mov     [ebp+var_8], ecx
.text$mn:00008351                 lea     eax, [ebp+var_1]
.text$mn:00008354                 push    eax
.text$mn:00008355                 mov     ecx, [ebp+var_8]
.text$mn:00008358                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tTbData *,std::allocator<tTbData *>>>::_Getal(void)
.text$mn:0000835D                 mov     ecx, eax
.text$mn:0000835F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<tTbData *>>::max_size(void)
.text$mn:00008364                 mov     esp, ebp
.text$mn:00008366                 pop     ebp
.text$mn:00008367                 retn
.text$mn:00008367 ?max_size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ endp
.text$mn:00008367
.text$mn:00008367 _text$mn        ends
.text$mn:00008367
.text$mn:00008368 ; ===========================================================================
.text$mn:00008368
.text$mn:00008368 ; Segment type: Pure code
.text$mn:00008368 ; Segment permissions: Read/Execute
.text$mn:00008368 _text$mn        segment para public 'CODE' use32
.text$mn:00008368                 assume cs:_text$mn
.text$mn:00008368                 ;org 8368h
.text$mn:00008368 ; COMDAT (pick any)
.text$mn:00008368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008368
.text$mn:00008368 ; =============== S U B R O U T I N E =======================================
.text$mn:00008368
.text$mn:00008368 ; Attributes: bp-based frame
.text$mn:00008368
.text$mn:00008368 ; public: unsigned int __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::max_size(void)const
.text$mn:00008368                 public ?max_size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ
.text$mn:00008368 ?max_size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ proc near
.text$mn:00008368                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Grow_to(uint)+17p
.text$mn:00008368                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reserve(uint)+18p
.text$mn:00008368
.text$mn:00008368 var_8           = dword ptr -8
.text$mn:00008368 var_1           = byte ptr -1
.text$mn:00008368
.text$mn:00008368                 push    ebp
.text$mn:00008369                 mov     ebp, esp
.text$mn:0000836B                 sub     esp, 8
.text$mn:0000836E                 mov     [ebp+var_8], ecx
.text$mn:00008371                 lea     eax, [ebp+var_1]
.text$mn:00008374                 push    eax
.text$mn:00008375                 mov     ecx, [ebp+var_8]
.text$mn:00008378                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:0000837D                 mov     ecx, eax
.text$mn:0000837F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<DockingCont *>>::max_size(void)
.text$mn:00008384                 mov     esp, ebp
.text$mn:00008386                 pop     ebp
.text$mn:00008387                 retn
.text$mn:00008387 ?max_size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ endp
.text$mn:00008387
.text$mn:00008387 _text$mn        ends
.text$mn:00008387
.text$mn:00008388 ; ===========================================================================
.text$mn:00008388
.text$mn:00008388 ; Segment type: Pure code
.text$mn:00008388 ; Segment permissions: Read/Execute
.text$mn:00008388 _text$mn        segment para public 'CODE' use32
.text$mn:00008388                 assume cs:_text$mn
.text$mn:00008388                 ;org 8388h
.text$mn:00008388 ; COMDAT (pick any)
.text$mn:00008388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008388
.text$mn:00008388 ; =============== S U B R O U T I N E =======================================
.text$mn:00008388
.text$mn:00008388 ; Attributes: bp-based frame
.text$mn:00008388
.text$mn:00008388 ; public: unsigned int __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::max_size(void)const
.text$mn:00008388                 public ?max_size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ
.text$mn:00008388 ?max_size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ proc near
.text$mn:00008388                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Grow_to(uint)+17p
.text$mn:00008388                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reserve(uint)+18p
.text$mn:00008388
.text$mn:00008388 var_8           = dword ptr -8
.text$mn:00008388 var_1           = byte ptr -1
.text$mn:00008388
.text$mn:00008388                 push    ebp
.text$mn:00008389                 mov     ebp, esp
.text$mn:0000838B                 sub     esp, 8
.text$mn:0000838E                 mov     [ebp+var_8], ecx
.text$mn:00008391                 lea     eax, [ebp+var_1]
.text$mn:00008394                 push    eax
.text$mn:00008395                 mov     ecx, [ebp+var_8]
.text$mn:00008398                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Getal(void)
.text$mn:0000839D                 mov     ecx, eax
.text$mn:0000839F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<DockingSplitter *>>::max_size(void)
.text$mn:000083A4                 mov     esp, ebp
.text$mn:000083A6                 pop     ebp
.text$mn:000083A7                 retn
.text$mn:000083A7 ?max_size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ endp
.text$mn:000083A7
.text$mn:000083A7 _text$mn        ends
.text$mn:000083A7
.text$mn:000083A8 ; ===========================================================================
.text$mn:000083A8
.text$mn:000083A8 ; Segment type: Pure code
.text$mn:000083A8 ; Segment permissions: Read/Execute
.text$mn:000083A8 _text$mn        segment para public 'CODE' use32
.text$mn:000083A8                 assume cs:_text$mn
.text$mn:000083A8                 ;org 83A8h
.text$mn:000083A8 ; COMDAT (pick any)
.text$mn:000083A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000083A8
.text$mn:000083A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000083A8
.text$mn:000083A8 ; Attributes: bp-based frame
.text$mn:000083A8
.text$mn:000083A8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000083A8                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000083A8 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000083A8                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000083A8                                         ; DATA XREF: .rdata:00009D68o
.text$mn:000083A8
.text$mn:000083A8 var_1C          = dword ptr -1Ch
.text$mn:000083A8 var_18          = dword ptr -18h
.text$mn:000083A8 Str             = dword ptr -14h
.text$mn:000083A8 var_10          = dword ptr -10h
.text$mn:000083A8 var_C           = dword ptr -0Ch
.text$mn:000083A8 var_4           = dword ptr -4
.text$mn:000083A8 arg_0           = dword ptr  8
.text$mn:000083A8 arg_4           = dword ptr  0Ch
.text$mn:000083A8
.text$mn:000083A8                 push    ebp
.text$mn:000083A9                 mov     ebp, esp
.text$mn:000083AB                 push    0FFFFFFFFh
.text$mn:000083AD                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000083B2                 mov     eax, large fs:0
.text$mn:000083B8                 push    eax
.text$mn:000083B9                 sub     esp, 10h
.text$mn:000083BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000083C1                 xor     eax, ebp
.text$mn:000083C3                 push    eax
.text$mn:000083C4                 lea     eax, [ebp+var_C]
.text$mn:000083C7                 mov     large fs:0, eax
.text$mn:000083CD                 mov     [ebp+var_1C], ecx
.text$mn:000083D0                 mov     [ebp+var_18], 0
.text$mn:000083D7                 mov     eax, [ebp+arg_4]
.text$mn:000083DA                 push    eax             ; int
.text$mn:000083DB                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000083E0                 add     esp, 4
.text$mn:000083E3                 mov     [ebp+var_10], eax
.text$mn:000083E6                 cmp     [ebp+var_10], 0
.text$mn:000083EA                 jz      short loc_83F4
.text$mn:000083EC                 mov     ecx, [ebp+var_10]
.text$mn:000083EF                 mov     [ebp+Str], ecx
.text$mn:000083F2                 jmp     short loc_83FB
.text$mn:000083F4 ; ---------------------------------------------------------------------------
.text$mn:000083F4
.text$mn:000083F4 loc_83F4:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000083F4                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000083FB
.text$mn:000083FB loc_83FB:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000083FB                 mov     edx, [ebp+Str]
.text$mn:000083FE                 push    edx             ; Str
.text$mn:000083FF                 mov     ecx, [ebp+arg_0]
.text$mn:00008402                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00008407                 mov     [ebp+var_4], 0
.text$mn:0000840E                 mov     eax, [ebp+var_18]
.text$mn:00008411                 or      eax, 1
.text$mn:00008414                 mov     [ebp+var_18], eax
.text$mn:00008417                 mov     eax, [ebp+arg_0]
.text$mn:0000841A                 mov     ecx, [ebp+var_C]
.text$mn:0000841D                 mov     large fs:0, ecx
.text$mn:00008424                 pop     ecx
.text$mn:00008425                 mov     esp, ebp
.text$mn:00008427                 pop     ebp
.text$mn:00008428                 retn    8
.text$mn:00008428 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00008428
.text$mn:00008428 ; ---------------------------------------------------------------------------
.text$mn:0000842B                 align 4
.text$mn:0000842B _text$mn        ends
.text$mn:0000842B
.text$x:0000842C ; ===========================================================================
.text$x:0000842C
.text$x:0000842C ; Segment type: Pure code
.text$x:0000842C ; Segment permissions: Read/Execute
.text$x:0000842C _text$x         segment para public 'CODE' use32
.text$x:0000842C                 assume cs:_text$x
.text$x:0000842C                 ;org 842Ch
.text$x:0000842C ; COMDAT (pick associative to section at 83A8)
.text$x:0000842C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000842C
.text$x:0000842C ; =============== S U B R O U T I N E =======================================
.text$x:0000842C
.text$x:0000842C
.text$x:0000842C __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000842C                                         ; DATA XREF: .xdata$x:00008F34o
.text$x:0000842C                 mov     eax, [ebp-18h]
.text$x:0000842F                 and     eax, 1
.text$x:00008432                 jz      $LN6
.text$x:00008438                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000843C                 mov     ecx, [ebp+8]
.text$x:0000843F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00008444 ; ---------------------------------------------------------------------------
.text$x:00008444
.text$x:00008444 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00008444                 retn
.text$x:00008444 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00008444
.text$x:00008445
.text$x:00008445 ; =============== S U B R O U T I N E =======================================
.text$x:00008445
.text$x:00008445
.text$x:00008445 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00008445                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00008445
.text$x:00008445 arg_4           = dword ptr  8
.text$x:00008445
.text$x:00008445                 mov     edx, [esp+arg_4]
.text$x:00008449                 lea     eax, [edx+0Ch]
.text$x:0000844C                 mov     ecx, [edx-14h]
.text$x:0000844F                 xor     ecx, eax
.text$x:00008451                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008456                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000845B                 jmp     ___CxxFrameHandler3
.text$x:0000845B __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000845B
.text$x:0000845B _text$x         ends
.text$x:0000845B
.text$mn:00008460 ; ===========================================================================
.text$mn:00008460
.text$mn:00008460 ; Segment type: Pure code
.text$mn:00008460 ; Segment permissions: Read/Execute
.text$mn:00008460 _text$mn        segment para public 'CODE' use32
.text$mn:00008460                 assume cs:_text$mn
.text$mn:00008460                 ;org 8460h
.text$mn:00008460 ; COMDAT (pick any)
.text$mn:00008460                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008460
.text$mn:00008460 ; =============== S U B R O U T I N E =======================================
.text$mn:00008460
.text$mn:00008460 ; Attributes: bp-based frame
.text$mn:00008460
.text$mn:00008460 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00008460                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008460 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00008460                                         ; DATA XREF: .rdata:00009D9Co
.text$mn:00008460
.text$mn:00008460 var_14          = dword ptr -14h
.text$mn:00008460 var_10          = dword ptr -10h
.text$mn:00008460 var_C           = dword ptr -0Ch
.text$mn:00008460 var_4           = dword ptr -4
.text$mn:00008460 arg_0           = dword ptr  8
.text$mn:00008460 arg_4           = dword ptr  0Ch
.text$mn:00008460
.text$mn:00008460                 push    ebp
.text$mn:00008461                 mov     ebp, esp
.text$mn:00008463                 push    0FFFFFFFFh
.text$mn:00008465                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000846A                 mov     eax, large fs:0
.text$mn:00008470                 push    eax
.text$mn:00008471                 sub     esp, 8
.text$mn:00008474                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008479                 xor     eax, ebp
.text$mn:0000847B                 push    eax
.text$mn:0000847C                 lea     eax, [ebp+var_C]
.text$mn:0000847F                 mov     large fs:0, eax
.text$mn:00008485                 mov     [ebp+var_14], ecx
.text$mn:00008488                 mov     [ebp+var_10], 0
.text$mn:0000848F                 cmp     [ebp+arg_4], 1
.text$mn:00008493                 jnz     short loc_84B9
.text$mn:00008495                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000849A                 mov     ecx, [ebp+arg_0]
.text$mn:0000849D                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000084A2                 mov     [ebp+var_4], 0
.text$mn:000084A9                 mov     eax, [ebp+var_10]
.text$mn:000084AC                 or      eax, 1
.text$mn:000084AF                 mov     [ebp+var_10], eax
.text$mn:000084B2                 mov     eax, [ebp+arg_0]
.text$mn:000084B5                 jmp     short loc_84DC
.text$mn:000084B7 ; ---------------------------------------------------------------------------
.text$mn:000084B7                 jmp     short loc_84DC
.text$mn:000084B9 ; ---------------------------------------------------------------------------
.text$mn:000084B9
.text$mn:000084B9 loc_84B9:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:000084B9                 mov     ecx, [ebp+arg_4]
.text$mn:000084BC                 push    ecx
.text$mn:000084BD                 mov     edx, [ebp+arg_0]
.text$mn:000084C0                 push    edx
.text$mn:000084C1                 mov     ecx, [ebp+var_14]
.text$mn:000084C4                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000084C9                 mov     [ebp+var_4], 0
.text$mn:000084D0                 mov     eax, [ebp+var_10]
.text$mn:000084D3                 or      eax, 1
.text$mn:000084D6                 mov     [ebp+var_10], eax
.text$mn:000084D9                 mov     eax, [ebp+arg_0]
.text$mn:000084DC
.text$mn:000084DC loc_84DC:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000084DC                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000084DC                 mov     ecx, [ebp+var_C]
.text$mn:000084DF                 mov     large fs:0, ecx
.text$mn:000084E6                 pop     ecx
.text$mn:000084E7                 mov     esp, ebp
.text$mn:000084E9                 pop     ebp
.text$mn:000084EA                 retn    8
.text$mn:000084EA ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000084EA
.text$mn:000084EA ; ---------------------------------------------------------------------------
.text$mn:000084ED                 align 10h
.text$mn:000084ED _text$mn        ends
.text$mn:000084ED
.text$x:000084F0 ; ===========================================================================
.text$x:000084F0
.text$x:000084F0 ; Segment type: Pure code
.text$x:000084F0 ; Segment permissions: Read/Execute
.text$x:000084F0 _text$x         segment para public 'CODE' use32
.text$x:000084F0                 assume cs:_text$x
.text$x:000084F0                 ;org 84F0h
.text$x:000084F0 ; COMDAT (pick associative to section at 8460)
.text$x:000084F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000084F0
.text$x:000084F0 ; =============== S U B R O U T I N E =======================================
.text$x:000084F0
.text$x:000084F0
.text$x:000084F0 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000084F0                                         ; DATA XREF: .xdata$x:00008FB8o
.text$x:000084F0                 mov     eax, [ebp-10h]
.text$x:000084F3                 and     eax, 1
.text$x:000084F6                 jz      $LN6_0
.text$x:000084FC                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008500                 mov     ecx, [ebp+8]
.text$x:00008503                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00008508 ; ---------------------------------------------------------------------------
.text$x:00008508
.text$x:00008508 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00008508                 retn
.text$x:00008508 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00008508
.text$x:00008509
.text$x:00008509 ; =============== S U B R O U T I N E =======================================
.text$x:00008509
.text$x:00008509
.text$x:00008509 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00008509                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00008509
.text$x:00008509 arg_4           = dword ptr  8
.text$x:00008509
.text$x:00008509                 mov     edx, [esp+arg_4]
.text$x:0000850D                 lea     eax, [edx+0Ch]
.text$x:00008510                 mov     ecx, [edx-0Ch]
.text$x:00008513                 xor     ecx, eax
.text$x:00008515                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000851A                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000851F                 jmp     ___CxxFrameHandler3
.text$x:0000851F __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000851F
.text$x:0000851F _text$x         ends
.text$x:0000851F
.text$mn:00008524 ; ===========================================================================
.text$mn:00008524
.text$mn:00008524 ; Segment type: Pure code
.text$mn:00008524 ; Segment permissions: Read/Execute
.text$mn:00008524 _text$mn        segment para public 'CODE' use32
.text$mn:00008524                 assume cs:_text$mn
.text$mn:00008524                 ;org 8524h
.text$mn:00008524 ; COMDAT (pick any)
.text$mn:00008524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008524
.text$mn:00008524 ; =============== S U B R O U T I N E =======================================
.text$mn:00008524
.text$mn:00008524 ; Attributes: bp-based frame
.text$mn:00008524
.text$mn:00008524 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00008524                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008524 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00008524                                         ; DATA XREF: .rdata:00009DDCo
.text$mn:00008524
.text$mn:00008524 var_1C          = dword ptr -1Ch
.text$mn:00008524 var_18          = dword ptr -18h
.text$mn:00008524 Str             = dword ptr -14h
.text$mn:00008524 var_10          = dword ptr -10h
.text$mn:00008524 var_C           = dword ptr -0Ch
.text$mn:00008524 var_4           = dword ptr -4
.text$mn:00008524 arg_0           = dword ptr  8
.text$mn:00008524 arg_4           = dword ptr  0Ch
.text$mn:00008524
.text$mn:00008524                 push    ebp
.text$mn:00008525                 mov     ebp, esp
.text$mn:00008527                 push    0FFFFFFFFh
.text$mn:00008529                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000852E                 mov     eax, large fs:0
.text$mn:00008534                 push    eax
.text$mn:00008535                 sub     esp, 10h
.text$mn:00008538                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000853D                 xor     eax, ebp
.text$mn:0000853F                 push    eax
.text$mn:00008540                 lea     eax, [ebp+var_C]
.text$mn:00008543                 mov     large fs:0, eax
.text$mn:00008549                 mov     [ebp+var_1C], ecx
.text$mn:0000854C                 mov     [ebp+var_18], 0
.text$mn:00008553                 mov     eax, [ebp+arg_4]
.text$mn:00008556                 push    eax             ; int
.text$mn:00008557                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:0000855C                 add     esp, 4
.text$mn:0000855F                 mov     [ebp+var_10], eax
.text$mn:00008562                 cmp     [ebp+var_10], 0
.text$mn:00008566                 jz      short loc_8570
.text$mn:00008568                 mov     ecx, [ebp+var_10]
.text$mn:0000856B                 mov     [ebp+Str], ecx
.text$mn:0000856E                 jmp     short loc_8577
.text$mn:00008570 ; ---------------------------------------------------------------------------
.text$mn:00008570
.text$mn:00008570 loc_8570:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00008570                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00008577
.text$mn:00008577 loc_8577:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00008577                 mov     edx, [ebp+Str]
.text$mn:0000857A                 push    edx             ; Str
.text$mn:0000857B                 mov     ecx, [ebp+arg_0]
.text$mn:0000857E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00008583                 mov     [ebp+var_4], 0
.text$mn:0000858A                 mov     eax, [ebp+var_18]
.text$mn:0000858D                 or      eax, 1
.text$mn:00008590                 mov     [ebp+var_18], eax
.text$mn:00008593                 mov     eax, [ebp+arg_0]
.text$mn:00008596                 mov     ecx, [ebp+var_C]
.text$mn:00008599                 mov     large fs:0, ecx
.text$mn:000085A0                 pop     ecx
.text$mn:000085A1                 mov     esp, ebp
.text$mn:000085A3                 pop     ebp
.text$mn:000085A4                 retn    8
.text$mn:000085A4 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000085A4
.text$mn:000085A4 ; ---------------------------------------------------------------------------
.text$mn:000085A7                 align 4
.text$mn:000085A7 _text$mn        ends
.text$mn:000085A7
.text$x:000085A8 ; ===========================================================================
.text$x:000085A8
.text$x:000085A8 ; Segment type: Pure code
.text$x:000085A8 ; Segment permissions: Read/Execute
.text$x:000085A8 _text$x         segment para public 'CODE' use32
.text$x:000085A8                 assume cs:_text$x
.text$x:000085A8                 ;org 85A8h
.text$x:000085A8 ; COMDAT (pick associative to section at 8524)
.text$x:000085A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000085A8
.text$x:000085A8 ; =============== S U B R O U T I N E =======================================
.text$x:000085A8
.text$x:000085A8
.text$x:000085A8 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000085A8                                         ; DATA XREF: .xdata$x:0000903Co
.text$x:000085A8                 mov     eax, [ebp-18h]
.text$x:000085AB                 and     eax, 1
.text$x:000085AE                 jz      $LN6_1
.text$x:000085B4                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000085B8                 mov     ecx, [ebp+8]
.text$x:000085BB                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000085C0 ; ---------------------------------------------------------------------------
.text$x:000085C0
.text$x:000085C0 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000085C0                 retn
.text$x:000085C0 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000085C0
.text$x:000085C1
.text$x:000085C1 ; =============== S U B R O U T I N E =======================================
.text$x:000085C1
.text$x:000085C1
.text$x:000085C1 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000085C1                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000085C1
.text$x:000085C1 arg_4           = dword ptr  8
.text$x:000085C1
.text$x:000085C1                 mov     edx, [esp+arg_4]
.text$x:000085C5                 lea     eax, [edx+0Ch]
.text$x:000085C8                 mov     ecx, [edx-14h]
.text$x:000085CB                 xor     ecx, eax
.text$x:000085CD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000085D2                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000085D7                 jmp     ___CxxFrameHandler3
.text$x:000085D7 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000085D7
.text$x:000085D7 _text$x         ends
.text$x:000085D7
.text$mn:000085DC ; ===========================================================================
.text$mn:000085DC
.text$mn:000085DC ; Segment type: Pure code
.text$mn:000085DC ; Segment permissions: Read/Execute
.text$mn:000085DC _text$mn        segment para public 'CODE' use32
.text$mn:000085DC                 assume cs:_text$mn
.text$mn:000085DC                 ;org 85DCh
.text$mn:000085DC ; COMDAT (pick any)
.text$mn:000085DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000085DC
.text$mn:000085DC ; =============== S U B R O U T I N E =======================================
.text$mn:000085DC
.text$mn:000085DC ; Attributes: bp-based frame
.text$mn:000085DC
.text$mn:000085DC ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000085DC                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000085DC ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000085DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000085DC
.text$mn:000085DC var_4           = dword ptr -4
.text$mn:000085DC Dst             = dword ptr  8
.text$mn:000085DC Src             = dword ptr  0Ch
.text$mn:000085DC Size            = dword ptr  10h
.text$mn:000085DC
.text$mn:000085DC                 push    ebp
.text$mn:000085DD                 mov     ebp, esp
.text$mn:000085DF                 push    ecx
.text$mn:000085E0                 cmp     [ebp+Size], 0
.text$mn:000085E4                 jnz     short loc_85EE
.text$mn:000085E6                 mov     eax, [ebp+Dst]
.text$mn:000085E9                 mov     [ebp+var_4], eax
.text$mn:000085EC                 jmp     short loc_8605
.text$mn:000085EE ; ---------------------------------------------------------------------------
.text$mn:000085EE
.text$mn:000085EE loc_85EE:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000085EE                 mov     ecx, [ebp+Size]
.text$mn:000085F1                 push    ecx             ; Size
.text$mn:000085F2                 mov     edx, [ebp+Src]
.text$mn:000085F5                 push    edx             ; Src
.text$mn:000085F6                 mov     eax, [ebp+Dst]
.text$mn:000085F9                 push    eax             ; Dst
.text$mn:000085FA                 call    _memmove
.text$mn:000085FF                 add     esp, 0Ch
.text$mn:00008602                 mov     [ebp+var_4], eax
.text$mn:00008605
.text$mn:00008605 loc_8605:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00008605                 mov     eax, [ebp+var_4]
.text$mn:00008608                 mov     esp, ebp
.text$mn:0000860A                 pop     ebp
.text$mn:0000860B                 retn
.text$mn:0000860B ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000860B
.text$mn:0000860B _text$mn        ends
.text$mn:0000860B
.text$mn:0000860C ; ===========================================================================
.text$mn:0000860C
.text$mn:0000860C ; Segment type: Pure code
.text$mn:0000860C ; Segment permissions: Read/Execute
.text$mn:0000860C _text$mn        segment para public 'CODE' use32
.text$mn:0000860C                 assume cs:_text$mn
.text$mn:0000860C                 ;org 860Ch
.text$mn:0000860C ; COMDAT (pick any)
.text$mn:0000860C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000860C
.text$mn:0000860C ; =============== S U B R O U T I N E =======================================
.text$mn:0000860C
.text$mn:0000860C ; Attributes: bp-based frame
.text$mn:0000860C
.text$mn:0000860C ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:0000860C                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:0000860C ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:0000860C                                         ; DATA XREF: .rdata:00009D64o
.text$mn:0000860C
.text$mn:0000860C var_4           = dword ptr -4
.text$mn:0000860C
.text$mn:0000860C                 push    ebp
.text$mn:0000860D                 mov     ebp, esp
.text$mn:0000860F                 push    ecx
.text$mn:00008610                 mov     [ebp+var_4], ecx
.text$mn:00008613                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00008618                 mov     esp, ebp
.text$mn:0000861A                 pop     ebp
.text$mn:0000861B                 retn
.text$mn:0000861B ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000861B
.text$mn:0000861B _text$mn        ends
.text$mn:0000861B
.text$mn:0000861C ; ===========================================================================
.text$mn:0000861C
.text$mn:0000861C ; Segment type: Pure code
.text$mn:0000861C ; Segment permissions: Read/Execute
.text$mn:0000861C _text$mn        segment para public 'CODE' use32
.text$mn:0000861C                 assume cs:_text$mn
.text$mn:0000861C                 ;org 861Ch
.text$mn:0000861C ; COMDAT (pick any)
.text$mn:0000861C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000861C
.text$mn:0000861C ; =============== S U B R O U T I N E =======================================
.text$mn:0000861C
.text$mn:0000861C ; Attributes: bp-based frame
.text$mn:0000861C
.text$mn:0000861C ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:0000861C                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:0000861C ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:0000861C                                         ; DATA XREF: .rdata:00009D98o
.text$mn:0000861C
.text$mn:0000861C var_4           = dword ptr -4
.text$mn:0000861C
.text$mn:0000861C                 push    ebp
.text$mn:0000861D                 mov     ebp, esp
.text$mn:0000861F                 push    ecx
.text$mn:00008620                 mov     [ebp+var_4], ecx
.text$mn:00008623                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00008628                 mov     esp, ebp
.text$mn:0000862A                 pop     ebp
.text$mn:0000862B                 retn
.text$mn:0000862B ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000862B
.text$mn:0000862B _text$mn        ends
.text$mn:0000862B
.text$mn:0000862C ; ===========================================================================
.text$mn:0000862C
.text$mn:0000862C ; Segment type: Pure code
.text$mn:0000862C ; Segment permissions: Read/Execute
.text$mn:0000862C _text$mn        segment para public 'CODE' use32
.text$mn:0000862C                 assume cs:_text$mn
.text$mn:0000862C                 ;org 862Ch
.text$mn:0000862C ; COMDAT (pick any)
.text$mn:0000862C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000862C
.text$mn:0000862C ; =============== S U B R O U T I N E =======================================
.text$mn:0000862C
.text$mn:0000862C ; Attributes: bp-based frame
.text$mn:0000862C
.text$mn:0000862C ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:0000862C                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:0000862C ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:0000862C                                         ; DATA XREF: .rdata:00009DD8o
.text$mn:0000862C
.text$mn:0000862C var_4           = dword ptr -4
.text$mn:0000862C
.text$mn:0000862C                 push    ebp
.text$mn:0000862D                 mov     ebp, esp
.text$mn:0000862F                 push    ecx
.text$mn:00008630                 mov     [ebp+var_4], ecx
.text$mn:00008633                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00008638                 mov     esp, ebp
.text$mn:0000863A                 pop     ebp
.text$mn:0000863B                 retn
.text$mn:0000863B ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000863B
.text$mn:0000863B _text$mn        ends
.text$mn:0000863B
.text$mn:0000863C ; ===========================================================================
.text$mn:0000863C
.text$mn:0000863C ; Segment type: Pure code
.text$mn:0000863C ; Segment permissions: Read/Execute
.text$mn:0000863C _text$mn        segment para public 'CODE' use32
.text$mn:0000863C                 assume cs:_text$mn
.text$mn:0000863C                 ;org 863Ch
.text$mn:0000863C ; COMDAT (pick any)
.text$mn:0000863C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000863C
.text$mn:0000863C ; =============== S U B R O U T I N E =======================================
.text$mn:0000863C
.text$mn:0000863C ; Attributes: bp-based frame
.text$mn:0000863C
.text$mn:0000863C ; public: void __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::push_back(struct HWND__ * const &)
.text$mn:0000863C                 public ?push_back@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAEXABQAUHWND__@@@Z
.text$mn:0000863C ?push_back@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAEXABQAUHWND__@@@Z proc near
.text$mn:0000863C                                         ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+8Fp
.text$mn:0000863C
.text$mn:0000863C var_C           = dword ptr -0Ch
.text$mn:0000863C var_8           = dword ptr -8
.text$mn:0000863C var_2           = byte ptr -2
.text$mn:0000863C var_1           = byte ptr -1
.text$mn:0000863C arg_0           = dword ptr  8
.text$mn:0000863C
.text$mn:0000863C                 push    ebp
.text$mn:0000863D                 mov     ebp, esp
.text$mn:0000863F                 sub     esp, 0Ch
.text$mn:00008642                 mov     [ebp+var_8], ecx
.text$mn:00008645                 mov     eax, [ebp+arg_0]
.text$mn:00008648                 push    eax
.text$mn:00008649                 call    ??$addressof@QAUHWND__@@@std@@YAPBQAUHWND__@@ABQAU1@@Z ; std::addressof<HWND__ * const>(HWND__ * const &)
.text$mn:0000864E                 add     esp, 4
.text$mn:00008651                 push    eax
.text$mn:00008652                 mov     ecx, [ebp+var_8]
.text$mn:00008655                 call    ?_Inside@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBE_NPBQAUHWND__@@@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Inside(HWND__ * const *)
.text$mn:0000865A                 movzx   ecx, al
.text$mn:0000865D                 test    ecx, ecx
.text$mn:0000865F                 jz      short loc_86DF
.text$mn:00008661                 mov     edx, [ebp+arg_0]
.text$mn:00008664                 push    edx
.text$mn:00008665                 call    ??$addressof@QAUHWND__@@@std@@YAPBQAUHWND__@@ABQAU1@@Z ; std::addressof<HWND__ * const>(HWND__ * const &)
.text$mn:0000866A                 add     esp, 4
.text$mn:0000866D                 mov     ecx, [ebp+var_8]
.text$mn:00008670                 sub     eax, [ecx+4]
.text$mn:00008673                 sar     eax, 2
.text$mn:00008676                 mov     [ebp+var_C], eax
.text$mn:00008679                 mov     edx, [ebp+var_8]
.text$mn:0000867C                 mov     eax, [ebp+var_8]
.text$mn:0000867F                 mov     ecx, [edx+8]
.text$mn:00008682                 cmp     ecx, [eax+0Ch]
.text$mn:00008685                 jnz     short loc_8691
.text$mn:00008687                 push    1
.text$mn:00008689                 mov     ecx, [ebp+var_8]
.text$mn:0000868C                 call    ?_Reserve@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reserve(uint)
.text$mn:00008691
.text$mn:00008691 loc_8691:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+49j
.text$mn:00008691                 mov     edx, [ebp+var_8]
.text$mn:00008694                 mov     eax, [edx+8]
.text$mn:00008697                 push    eax
.text$mn:00008698                 mov     ecx, [ebp+var_8]
.text$mn:0000869B                 mov     edx, [ecx+8]
.text$mn:0000869E                 push    edx
.text$mn:0000869F                 mov     ecx, [ebp+var_8]
.text$mn:000086A2                 call    ?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)
.text$mn:000086A7                 mov     eax, [ebp+var_8]
.text$mn:000086AA                 mov     ecx, [eax+4]
.text$mn:000086AD                 mov     edx, [ebp+var_C]
.text$mn:000086B0                 lea     eax, [ecx+edx*4]
.text$mn:000086B3                 push    eax             ; int
.text$mn:000086B4                 mov     ecx, [ebp+var_8]
.text$mn:000086B7                 mov     edx, [ecx+8]
.text$mn:000086BA                 push    edx             ; void *
.text$mn:000086BB                 lea     eax, [ebp+var_1]
.text$mn:000086BE                 push    eax
.text$mn:000086BF                 mov     ecx, [ebp+var_8]
.text$mn:000086C2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Getal(void)
.text$mn:000086C7                 mov     ecx, eax
.text$mn:000086C9                 call    ??$construct@PAUHWND__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z ; std::_Wrap_alloc<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * &>(HWND__ * *,HWND__ * &)
.text$mn:000086CE                 mov     ecx, [ebp+var_8]
.text$mn:000086D1                 mov     edx, [ecx+8]
.text$mn:000086D4                 add     edx, 4
.text$mn:000086D7                 mov     eax, [ebp+var_8]
.text$mn:000086DA                 mov     [eax+8], edx
.text$mn:000086DD                 jmp     short loc_873A
.text$mn:000086DF ; ---------------------------------------------------------------------------
.text$mn:000086DF
.text$mn:000086DF loc_86DF:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+23j
.text$mn:000086DF                 mov     ecx, [ebp+var_8]
.text$mn:000086E2                 mov     edx, [ebp+var_8]
.text$mn:000086E5                 mov     eax, [ecx+8]
.text$mn:000086E8                 cmp     eax, [edx+0Ch]
.text$mn:000086EB                 jnz     short loc_86F7
.text$mn:000086ED                 push    1
.text$mn:000086EF                 mov     ecx, [ebp+var_8]
.text$mn:000086F2                 call    ?_Reserve@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Reserve(uint)
.text$mn:000086F7
.text$mn:000086F7 loc_86F7:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+AFj
.text$mn:000086F7                 mov     ecx, [ebp+var_8]
.text$mn:000086FA                 mov     edx, [ecx+8]
.text$mn:000086FD                 push    edx
.text$mn:000086FE                 mov     eax, [ebp+var_8]
.text$mn:00008701                 mov     ecx, [eax+8]
.text$mn:00008704                 push    ecx
.text$mn:00008705                 mov     ecx, [ebp+var_8]
.text$mn:00008708                 call    ?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Orphan_range(HWND__ * *,HWND__ * *)
.text$mn:0000870D                 mov     edx, [ebp+arg_0]
.text$mn:00008710                 push    edx             ; int
.text$mn:00008711                 mov     eax, [ebp+var_8]
.text$mn:00008714                 mov     ecx, [eax+8]
.text$mn:00008717                 push    ecx             ; void *
.text$mn:00008718                 lea     edx, [ebp+var_2]
.text$mn:0000871B                 push    edx
.text$mn:0000871C                 mov     ecx, [ebp+var_8]
.text$mn:0000871F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HWND__ *,std::allocator<HWND__ *>>>::_Getal(void)
.text$mn:00008724                 mov     ecx, eax
.text$mn:00008726                 call    ??$construct@PAUHWND__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHWND__@@@std@@@std@@QAEXPAPAUHWND__@@ABQAU2@@Z ; std::_Wrap_alloc<std::allocator<HWND__ *>>::construct<HWND__ *,HWND__ * const &>(HWND__ * *,HWND__ * const &)
.text$mn:0000872B                 mov     eax, [ebp+var_8]
.text$mn:0000872E                 mov     ecx, [eax+8]
.text$mn:00008731                 add     ecx, 4
.text$mn:00008734                 mov     edx, [ebp+var_8]
.text$mn:00008737                 mov     [edx+8], ecx
.text$mn:0000873A
.text$mn:0000873A loc_873A:                               ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::push_back(HWND__ * const &)+A1j
.text$mn:0000873A                 mov     esp, ebp
.text$mn:0000873C                 pop     ebp
.text$mn:0000873D                 retn    4
.text$mn:0000873D ?push_back@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAEXABQAUHWND__@@@Z endp
.text$mn:0000873D
.text$mn:0000873D _text$mn        ends
.text$mn:0000873D
.text$mn:00008740 ; ===========================================================================
.text$mn:00008740
.text$mn:00008740 ; Segment type: Pure code
.text$mn:00008740 ; Segment permissions: Read/Execute
.text$mn:00008740 _text$mn        segment para public 'CODE' use32
.text$mn:00008740                 assume cs:_text$mn
.text$mn:00008740                 ;org 8740h
.text$mn:00008740 ; COMDAT (pick any)
.text$mn:00008740                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008740
.text$mn:00008740 ; =============== S U B R O U T I N E =======================================
.text$mn:00008740
.text$mn:00008740 ; Attributes: bp-based frame
.text$mn:00008740
.text$mn:00008740 ; public: void __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::push_back(class DockingCont * const &)
.text$mn:00008740                 public ?push_back@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXABQAVDockingCont@@@Z
.text$mn:00008740 ?push_back@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXABQAVDockingCont@@@Z proc near
.text$mn:00008740                                         ; CODE XREF: DockingManager::DockingManager(void)+15Ap
.text$mn:00008740                                         ; DockingManager::createDockableDlg(tTbData,int,bool)+16Ap ...
.text$mn:00008740
.text$mn:00008740 var_C           = dword ptr -0Ch
.text$mn:00008740 var_8           = dword ptr -8
.text$mn:00008740 var_2           = byte ptr -2
.text$mn:00008740 var_1           = byte ptr -1
.text$mn:00008740 arg_0           = dword ptr  8
.text$mn:00008740
.text$mn:00008740                 push    ebp
.text$mn:00008741                 mov     ebp, esp
.text$mn:00008743                 sub     esp, 0Ch
.text$mn:00008746                 mov     [ebp+var_8], ecx
.text$mn:00008749                 mov     eax, [ebp+arg_0]
.text$mn:0000874C                 push    eax
.text$mn:0000874D                 call    ??$addressof@QAVDockingCont@@@std@@YAPBQAVDockingCont@@ABQAV1@@Z ; std::addressof<DockingCont * const>(DockingCont * const &)
.text$mn:00008752                 add     esp, 4
.text$mn:00008755                 push    eax
.text$mn:00008756                 mov     ecx, [ebp+var_8]
.text$mn:00008759                 call    ?_Inside@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBE_NPBQAVDockingCont@@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Inside(DockingCont * const *)
.text$mn:0000875E                 movzx   ecx, al
.text$mn:00008761                 test    ecx, ecx
.text$mn:00008763                 jz      short loc_87E3
.text$mn:00008765                 mov     edx, [ebp+arg_0]
.text$mn:00008768                 push    edx
.text$mn:00008769                 call    ??$addressof@QAVDockingCont@@@std@@YAPBQAVDockingCont@@ABQAV1@@Z ; std::addressof<DockingCont * const>(DockingCont * const &)
.text$mn:0000876E                 add     esp, 4
.text$mn:00008771                 mov     ecx, [ebp+var_8]
.text$mn:00008774                 sub     eax, [ecx+4]
.text$mn:00008777                 sar     eax, 2
.text$mn:0000877A                 mov     [ebp+var_C], eax
.text$mn:0000877D                 mov     edx, [ebp+var_8]
.text$mn:00008780                 mov     eax, [ebp+var_8]
.text$mn:00008783                 mov     ecx, [edx+8]
.text$mn:00008786                 cmp     ecx, [eax+0Ch]
.text$mn:00008789                 jnz     short loc_8795
.text$mn:0000878B                 push    1
.text$mn:0000878D                 mov     ecx, [ebp+var_8]
.text$mn:00008790                 call    ?_Reserve@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reserve(uint)
.text$mn:00008795
.text$mn:00008795 loc_8795:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+49j
.text$mn:00008795                 mov     edx, [ebp+var_8]
.text$mn:00008798                 mov     eax, [edx+8]
.text$mn:0000879B                 push    eax
.text$mn:0000879C                 mov     ecx, [ebp+var_8]
.text$mn:0000879F                 mov     edx, [ecx+8]
.text$mn:000087A2                 push    edx
.text$mn:000087A3                 mov     ecx, [ebp+var_8]
.text$mn:000087A6                 call    ?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *)
.text$mn:000087AB                 mov     eax, [ebp+var_8]
.text$mn:000087AE                 mov     ecx, [eax+4]
.text$mn:000087B1                 mov     edx, [ebp+var_C]
.text$mn:000087B4                 lea     eax, [ecx+edx*4]
.text$mn:000087B7                 push    eax             ; int
.text$mn:000087B8                 mov     ecx, [ebp+var_8]
.text$mn:000087BB                 mov     edx, [ecx+8]
.text$mn:000087BE                 push    edx             ; void *
.text$mn:000087BF                 lea     eax, [ebp+var_1]
.text$mn:000087C2                 push    eax
.text$mn:000087C3                 mov     ecx, [ebp+var_8]
.text$mn:000087C6                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:000087CB                 mov     ecx, eax
.text$mn:000087CD                 call    ??$construct@PAVDockingCont@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * &>(DockingCont * *,DockingCont * &)
.text$mn:000087D2                 mov     ecx, [ebp+var_8]
.text$mn:000087D5                 mov     edx, [ecx+8]
.text$mn:000087D8                 add     edx, 4
.text$mn:000087DB                 mov     eax, [ebp+var_8]
.text$mn:000087DE                 mov     [eax+8], edx
.text$mn:000087E1                 jmp     short loc_883E
.text$mn:000087E3 ; ---------------------------------------------------------------------------
.text$mn:000087E3
.text$mn:000087E3 loc_87E3:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+23j
.text$mn:000087E3                 mov     ecx, [ebp+var_8]
.text$mn:000087E6                 mov     edx, [ebp+var_8]
.text$mn:000087E9                 mov     eax, [ecx+8]
.text$mn:000087EC                 cmp     eax, [edx+0Ch]
.text$mn:000087EF                 jnz     short loc_87FB
.text$mn:000087F1                 push    1
.text$mn:000087F3                 mov     ecx, [ebp+var_8]
.text$mn:000087F6                 call    ?_Reserve@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Reserve(uint)
.text$mn:000087FB
.text$mn:000087FB loc_87FB:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+AFj
.text$mn:000087FB                 mov     ecx, [ebp+var_8]
.text$mn:000087FE                 mov     edx, [ecx+8]
.text$mn:00008801                 push    edx
.text$mn:00008802                 mov     eax, [ebp+var_8]
.text$mn:00008805                 mov     ecx, [eax+8]
.text$mn:00008808                 push    ecx
.text$mn:00008809                 mov     ecx, [ebp+var_8]
.text$mn:0000880C                 call    ?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Orphan_range(DockingCont * *,DockingCont * *)
.text$mn:00008811                 mov     edx, [ebp+arg_0]
.text$mn:00008814                 push    edx             ; int
.text$mn:00008815                 mov     eax, [ebp+var_8]
.text$mn:00008818                 mov     ecx, [eax+8]
.text$mn:0000881B                 push    ecx             ; void *
.text$mn:0000881C                 lea     edx, [ebp+var_2]
.text$mn:0000881F                 push    edx
.text$mn:00008820                 mov     ecx, [ebp+var_8]
.text$mn:00008823                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:00008828                 mov     ecx, eax
.text$mn:0000882A                 call    ??$construct@PAVDockingCont@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<DockingCont *>>::construct<DockingCont *,DockingCont * const &>(DockingCont * *,DockingCont * const &)
.text$mn:0000882F                 mov     eax, [ebp+var_8]
.text$mn:00008832                 mov     ecx, [eax+8]
.text$mn:00008835                 add     ecx, 4
.text$mn:00008838                 mov     edx, [ebp+var_8]
.text$mn:0000883B                 mov     [edx+8], ecx
.text$mn:0000883E
.text$mn:0000883E loc_883E:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::push_back(DockingCont * const &)+A1j
.text$mn:0000883E                 mov     esp, ebp
.text$mn:00008840                 pop     ebp
.text$mn:00008841                 retn    4
.text$mn:00008841 ?push_back@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXABQAVDockingCont@@@Z endp
.text$mn:00008841
.text$mn:00008841 _text$mn        ends
.text$mn:00008841
.text$mn:00008844 ; ===========================================================================
.text$mn:00008844
.text$mn:00008844 ; Segment type: Pure code
.text$mn:00008844 ; Segment permissions: Read/Execute
.text$mn:00008844 _text$mn        segment para public 'CODE' use32
.text$mn:00008844                 assume cs:_text$mn
.text$mn:00008844                 ;org 8844h
.text$mn:00008844 ; COMDAT (pick any)
.text$mn:00008844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008844
.text$mn:00008844 ; =============== S U B R O U T I N E =======================================
.text$mn:00008844
.text$mn:00008844 ; Attributes: bp-based frame
.text$mn:00008844
.text$mn:00008844 ; public: void __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::push_back(class DockingSplitter * const &)
.text$mn:00008844                 public ?push_back@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXABQAVDockingSplitter@@@Z
.text$mn:00008844 ?push_back@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXABQAVDockingSplitter@@@Z proc near
.text$mn:00008844                                         ; CODE XREF: DockingManager::DockingManager(void)+1A7p
.text$mn:00008844
.text$mn:00008844 var_C           = dword ptr -0Ch
.text$mn:00008844 var_8           = dword ptr -8
.text$mn:00008844 var_2           = byte ptr -2
.text$mn:00008844 var_1           = byte ptr -1
.text$mn:00008844 arg_0           = dword ptr  8
.text$mn:00008844
.text$mn:00008844                 push    ebp
.text$mn:00008845                 mov     ebp, esp
.text$mn:00008847                 sub     esp, 0Ch
.text$mn:0000884A                 mov     [ebp+var_8], ecx
.text$mn:0000884D                 mov     eax, [ebp+arg_0]
.text$mn:00008850                 push    eax
.text$mn:00008851                 call    ??$addressof@QAVDockingSplitter@@@std@@YAPBQAVDockingSplitter@@ABQAV1@@Z ; std::addressof<DockingSplitter * const>(DockingSplitter * const &)
.text$mn:00008856                 add     esp, 4
.text$mn:00008859                 push    eax
.text$mn:0000885A                 mov     ecx, [ebp+var_8]
.text$mn:0000885D                 call    ?_Inside@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBE_NPBQAVDockingSplitter@@@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Inside(DockingSplitter * const *)
.text$mn:00008862                 movzx   ecx, al
.text$mn:00008865                 test    ecx, ecx
.text$mn:00008867                 jz      short loc_88E7
.text$mn:00008869                 mov     edx, [ebp+arg_0]
.text$mn:0000886C                 push    edx
.text$mn:0000886D                 call    ??$addressof@QAVDockingSplitter@@@std@@YAPBQAVDockingSplitter@@ABQAV1@@Z ; std::addressof<DockingSplitter * const>(DockingSplitter * const &)
.text$mn:00008872                 add     esp, 4
.text$mn:00008875                 mov     ecx, [ebp+var_8]
.text$mn:00008878                 sub     eax, [ecx+4]
.text$mn:0000887B                 sar     eax, 2
.text$mn:0000887E                 mov     [ebp+var_C], eax
.text$mn:00008881                 mov     edx, [ebp+var_8]
.text$mn:00008884                 mov     eax, [ebp+var_8]
.text$mn:00008887                 mov     ecx, [edx+8]
.text$mn:0000888A                 cmp     ecx, [eax+0Ch]
.text$mn:0000888D                 jnz     short loc_8899
.text$mn:0000888F                 push    1
.text$mn:00008891                 mov     ecx, [ebp+var_8]
.text$mn:00008894                 call    ?_Reserve@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reserve(uint)
.text$mn:00008899
.text$mn:00008899 loc_8899:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+49j
.text$mn:00008899                 mov     edx, [ebp+var_8]
.text$mn:0000889C                 mov     eax, [edx+8]
.text$mn:0000889F                 push    eax
.text$mn:000088A0                 mov     ecx, [ebp+var_8]
.text$mn:000088A3                 mov     edx, [ecx+8]
.text$mn:000088A6                 push    edx
.text$mn:000088A7                 mov     ecx, [ebp+var_8]
.text$mn:000088AA                 call    ?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Orphan_range(DockingSplitter * *,DockingSplitter * *)
.text$mn:000088AF                 mov     eax, [ebp+var_8]
.text$mn:000088B2                 mov     ecx, [eax+4]
.text$mn:000088B5                 mov     edx, [ebp+var_C]
.text$mn:000088B8                 lea     eax, [ecx+edx*4]
.text$mn:000088BB                 push    eax             ; int
.text$mn:000088BC                 mov     ecx, [ebp+var_8]
.text$mn:000088BF                 mov     edx, [ecx+8]
.text$mn:000088C2                 push    edx             ; void *
.text$mn:000088C3                 lea     eax, [ebp+var_1]
.text$mn:000088C6                 push    eax
.text$mn:000088C7                 mov     ecx, [ebp+var_8]
.text$mn:000088CA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Getal(void)
.text$mn:000088CF                 mov     ecx, eax
.text$mn:000088D1                 call    ??$construct@PAVDockingSplitter@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * &>(DockingSplitter * *,DockingSplitter * &)
.text$mn:000088D6                 mov     ecx, [ebp+var_8]
.text$mn:000088D9                 mov     edx, [ecx+8]
.text$mn:000088DC                 add     edx, 4
.text$mn:000088DF                 mov     eax, [ebp+var_8]
.text$mn:000088E2                 mov     [eax+8], edx
.text$mn:000088E5                 jmp     short loc_8942
.text$mn:000088E7 ; ---------------------------------------------------------------------------
.text$mn:000088E7
.text$mn:000088E7 loc_88E7:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+23j
.text$mn:000088E7                 mov     ecx, [ebp+var_8]
.text$mn:000088EA                 mov     edx, [ebp+var_8]
.text$mn:000088ED                 mov     eax, [ecx+8]
.text$mn:000088F0                 cmp     eax, [edx+0Ch]
.text$mn:000088F3                 jnz     short loc_88FF
.text$mn:000088F5                 push    1
.text$mn:000088F7                 mov     ecx, [ebp+var_8]
.text$mn:000088FA                 call    ?_Reserve@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reserve(uint)
.text$mn:000088FF
.text$mn:000088FF loc_88FF:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+AFj
.text$mn:000088FF                 mov     ecx, [ebp+var_8]
.text$mn:00008902                 mov     edx, [ecx+8]
.text$mn:00008905                 push    edx
.text$mn:00008906                 mov     eax, [ebp+var_8]
.text$mn:00008909                 mov     ecx, [eax+8]
.text$mn:0000890C                 push    ecx
.text$mn:0000890D                 mov     ecx, [ebp+var_8]
.text$mn:00008910                 call    ?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Orphan_range(DockingSplitter * *,DockingSplitter * *)
.text$mn:00008915                 mov     edx, [ebp+arg_0]
.text$mn:00008918                 push    edx             ; int
.text$mn:00008919                 mov     eax, [ebp+var_8]
.text$mn:0000891C                 mov     ecx, [eax+8]
.text$mn:0000891F                 push    ecx             ; void *
.text$mn:00008920                 lea     edx, [ebp+var_2]
.text$mn:00008923                 push    edx
.text$mn:00008924                 mov     ecx, [ebp+var_8]
.text$mn:00008927                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingSplitter *,std::allocator<DockingSplitter *>>>::_Getal(void)
.text$mn:0000892C                 mov     ecx, eax
.text$mn:0000892E                 call    ??$construct@PAVDockingSplitter@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXPAPAVDockingSplitter@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<DockingSplitter *>>::construct<DockingSplitter *,DockingSplitter * const &>(DockingSplitter * *,DockingSplitter * const &)
.text$mn:00008933                 mov     eax, [ebp+var_8]
.text$mn:00008936                 mov     ecx, [eax+8]
.text$mn:00008939                 add     ecx, 4
.text$mn:0000893C                 mov     edx, [ebp+var_8]
.text$mn:0000893F                 mov     [edx+8], ecx
.text$mn:00008942
.text$mn:00008942 loc_8942:                               ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::push_back(DockingSplitter * const &)+A1j
.text$mn:00008942                 mov     esp, ebp
.text$mn:00008944                 pop     ebp
.text$mn:00008945                 retn    4
.text$mn:00008945 ?push_back@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAEXABQAVDockingSplitter@@@Z endp
.text$mn:00008945
.text$mn:00008945 _text$mn        ends
.text$mn:00008945
.text$mn:00008948 ; ===========================================================================
.text$mn:00008948
.text$mn:00008948 ; Segment type: Pure code
.text$mn:00008948 ; Segment permissions: Read/Execute
.text$mn:00008948 _text$mn        segment para public 'CODE' use32
.text$mn:00008948                 assume cs:_text$mn
.text$mn:00008948                 ;org 8948h
.text$mn:00008948 ; COMDAT (pick any)
.text$mn:00008948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008948
.text$mn:00008948 ; =============== S U B R O U T I N E =======================================
.text$mn:00008948
.text$mn:00008948 ; Attributes: bp-based frame
.text$mn:00008948
.text$mn:00008948 ; void __thiscall Window::reSizeTo(Window *this, struct tagRECT *)
.text$mn:00008948                 public ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z
.text$mn:00008948 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:00008948                                         ; DATA XREF: .rdata:00009C90o
.text$mn:00008948                                         ; .rdata:00009E50o
.text$mn:00008948
.text$mn:00008948 var_4           = dword ptr -4
.text$mn:00008948 arg_0           = dword ptr  8
.text$mn:00008948
.text$mn:00008948                 push    ebp
.text$mn:00008949                 mov     ebp, esp
.text$mn:0000894B                 push    ecx
.text$mn:0000894C                 mov     [ebp+var_4], ecx
.text$mn:0000894F                 push    1               ; bRepaint
.text$mn:00008951                 mov     eax, [ebp+arg_0]
.text$mn:00008954                 mov     ecx, [eax+0Ch]
.text$mn:00008957                 push    ecx             ; nHeight
.text$mn:00008958                 mov     edx, [ebp+arg_0]
.text$mn:0000895B                 mov     eax, [edx+8]
.text$mn:0000895E                 push    eax             ; nWidth
.text$mn:0000895F                 mov     ecx, [ebp+arg_0]
.text$mn:00008962                 mov     edx, [ecx+4]
.text$mn:00008965                 push    edx             ; Y
.text$mn:00008966                 mov     eax, [ebp+arg_0]
.text$mn:00008969                 mov     ecx, [eax]
.text$mn:0000896B                 push    ecx             ; X
.text$mn:0000896C                 mov     edx, [ebp+var_4]
.text$mn:0000896F                 mov     eax, [edx+0Ch]
.text$mn:00008972                 push    eax             ; hWnd
.text$mn:00008973                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00008979                 push    0
.text$mn:0000897B                 mov     ecx, [ebp+var_4]
.text$mn:0000897E                 mov     edx, [ecx]
.text$mn:00008980                 mov     ecx, [ebp+var_4]
.text$mn:00008983                 mov     eax, [edx+18h]
.text$mn:00008986                 call    eax
.text$mn:00008988                 mov     esp, ebp
.text$mn:0000898A                 pop     ebp
.text$mn:0000898B                 retn    4
.text$mn:0000898B ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:0000898B
.text$mn:0000898B ; ---------------------------------------------------------------------------
.text$mn:0000898E                 align 10h
.text$mn:0000898E _text$mn        ends
.text$mn:0000898E
.text$mn:00008990 ; ===========================================================================
.text$mn:00008990
.text$mn:00008990 ; Segment type: Pure code
.text$mn:00008990 ; Segment permissions: Read/Execute
.text$mn:00008990 _text$mn        segment para public 'CODE' use32
.text$mn:00008990                 assume cs:_text$mn
.text$mn:00008990                 ;org 8990h
.text$mn:00008990 ; COMDAT (pick any)
.text$mn:00008990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008990
.text$mn:00008990 ; =============== S U B R O U T I N E =======================================
.text$mn:00008990
.text$mn:00008990 ; Attributes: bp-based frame
.text$mn:00008990
.text$mn:00008990 ; void __thiscall Window::reSizeToWH(Window *this, struct tagRECT *)
.text$mn:00008990                 public ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z
.text$mn:00008990 ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:00008990                                         ; DATA XREF: .rdata:00009C94o
.text$mn:00008990                                         ; .rdata:00009E20o ...
.text$mn:00008990
.text$mn:00008990 var_4           = dword ptr -4
.text$mn:00008990 arg_0           = dword ptr  8
.text$mn:00008990
.text$mn:00008990                 push    ebp
.text$mn:00008991                 mov     ebp, esp
.text$mn:00008993                 push    ecx
.text$mn:00008994                 mov     [ebp+var_4], ecx
.text$mn:00008997                 push    1               ; bRepaint
.text$mn:00008999                 mov     eax, [ebp+arg_0]
.text$mn:0000899C                 mov     ecx, [ebp+arg_0]
.text$mn:0000899F                 mov     edx, [eax+0Ch]
.text$mn:000089A2                 sub     edx, [ecx+4]
.text$mn:000089A5                 push    edx             ; nHeight
.text$mn:000089A6                 mov     eax, [ebp+arg_0]
.text$mn:000089A9                 mov     ecx, [ebp+arg_0]
.text$mn:000089AC                 mov     edx, [eax+8]
.text$mn:000089AF                 sub     edx, [ecx]
.text$mn:000089B1                 push    edx             ; nWidth
.text$mn:000089B2                 mov     eax, [ebp+arg_0]
.text$mn:000089B5                 mov     ecx, [eax+4]
.text$mn:000089B8                 push    ecx             ; Y
.text$mn:000089B9                 mov     edx, [ebp+arg_0]
.text$mn:000089BC                 mov     eax, [edx]
.text$mn:000089BE                 push    eax             ; X
.text$mn:000089BF                 mov     ecx, [ebp+var_4]
.text$mn:000089C2                 mov     edx, [ecx+0Ch]
.text$mn:000089C5                 push    edx             ; hWnd
.text$mn:000089C6                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:000089CC                 push    0
.text$mn:000089CE                 mov     eax, [ebp+var_4]
.text$mn:000089D1                 mov     edx, [eax]
.text$mn:000089D3                 mov     ecx, [ebp+var_4]
.text$mn:000089D6                 mov     eax, [edx+18h]
.text$mn:000089D9                 call    eax
.text$mn:000089DB                 mov     esp, ebp
.text$mn:000089DD                 pop     ebp
.text$mn:000089DE                 retn    4
.text$mn:000089DE ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:000089DE
.text$mn:000089DE ; ---------------------------------------------------------------------------
.text$mn:000089E1                 align 4
.text$mn:000089E1 _text$mn        ends
.text$mn:000089E1
.text$mn:000089E4 ; ===========================================================================
.text$mn:000089E4
.text$mn:000089E4 ; Segment type: Pure code
.text$mn:000089E4 ; Segment permissions: Read/Execute
.text$mn:000089E4 _text$mn        segment para public 'CODE' use32
.text$mn:000089E4                 assume cs:_text$mn
.text$mn:000089E4                 ;org 89E4h
.text$mn:000089E4 ; COMDAT (pick any)
.text$mn:000089E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000089E4
.text$mn:000089E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000089E4
.text$mn:000089E4 ; Attributes: bp-based frame
.text$mn:000089E4
.text$mn:000089E4 ; void __thiscall Window::redraw(Window *this, bool)
.text$mn:000089E4                 public ?redraw@Window@@UBEX_N@Z
.text$mn:000089E4 ?redraw@Window@@UBEX_N@Z proc near      ; DATA XREF: .rdata:00009C98o
.text$mn:000089E4                                         ; .rdata:00009E24o ...
.text$mn:000089E4
.text$mn:000089E4 var_4           = dword ptr -4
.text$mn:000089E4 arg_0           = byte ptr  8
.text$mn:000089E4
.text$mn:000089E4                 push    ebp
.text$mn:000089E5                 mov     ebp, esp
.text$mn:000089E7                 push    ecx
.text$mn:000089E8                 mov     [ebp+var_4], ecx
.text$mn:000089EB                 push    1               ; bErase
.text$mn:000089ED                 push    0               ; lpRect
.text$mn:000089EF                 mov     eax, [ebp+var_4]
.text$mn:000089F2                 mov     ecx, [eax+0Ch]
.text$mn:000089F5                 push    ecx             ; hWnd
.text$mn:000089F6                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:000089FC                 movzx   edx, [ebp+arg_0]
.text$mn:00008A00                 test    edx, edx
.text$mn:00008A02                 jz      short loc_8A11
.text$mn:00008A04                 mov     eax, [ebp+var_4]
.text$mn:00008A07                 mov     ecx, [eax+0Ch]
.text$mn:00008A0A                 push    ecx             ; hWnd
.text$mn:00008A0B                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:00008A11
.text$mn:00008A11 loc_8A11:                               ; CODE XREF: Window::redraw(bool)+1Ej
.text$mn:00008A11                 mov     esp, ebp
.text$mn:00008A13                 pop     ebp
.text$mn:00008A14                 retn    4
.text$mn:00008A14 ?redraw@Window@@UBEX_N@Z endp
.text$mn:00008A14
.text$mn:00008A14 ; ---------------------------------------------------------------------------
.text$mn:00008A17                 align 4
.text$mn:00008A17 _text$mn        ends
.text$mn:00008A17
.text$mn:00008A18 ; ===========================================================================
.text$mn:00008A18
.text$mn:00008A18 ; Segment type: Pure code
.text$mn:00008A18 ; Segment permissions: Read/Execute
.text$mn:00008A18 _text$mn        segment para public 'CODE' use32
.text$mn:00008A18                 assume cs:_text$mn
.text$mn:00008A18                 ;org 8A18h
.text$mn:00008A18 ; COMDAT (pick any)
.text$mn:00008A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A18
.text$mn:00008A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A18
.text$mn:00008A18 ; Attributes: bp-based frame
.text$mn:00008A18
.text$mn:00008A18 ; int __thiscall DPIManager::scaleY(DPIManager *this, int)
.text$mn:00008A18                 public ?scaleY@DPIManager@@QAEHH@Z
.text$mn:00008A18 ?scaleY@DPIManager@@QAEHH@Z proc near   ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+50p
.text$mn:00008A18
.text$mn:00008A18 var_4           = dword ptr -4
.text$mn:00008A18 nNumber         = dword ptr  8
.text$mn:00008A18
.text$mn:00008A18                 push    ebp
.text$mn:00008A19                 mov     ebp, esp
.text$mn:00008A1B                 push    ecx
.text$mn:00008A1C                 mov     [ebp+var_4], ecx
.text$mn:00008A1F                 push    60h ; '`'       ; nDenominator
.text$mn:00008A21                 mov     eax, [ebp+var_4]
.text$mn:00008A24                 mov     ecx, [eax+4]
.text$mn:00008A27                 push    ecx             ; nNumerator
.text$mn:00008A28                 mov     edx, [ebp+nNumber]
.text$mn:00008A2B                 push    edx             ; nNumber
.text$mn:00008A2C                 call    dword ptr ds:__imp__MulDiv@12 ; MulDiv(x,x,x)
.text$mn:00008A32                 mov     esp, ebp
.text$mn:00008A34                 pop     ebp
.text$mn:00008A35                 retn    4
.text$mn:00008A35 ?scaleY@DPIManager@@QAEHH@Z endp
.text$mn:00008A35
.text$mn:00008A35 _text$mn        ends
.text$mn:00008A35
.text$mn:00008A38 ; ===========================================================================
.text$mn:00008A38
.text$mn:00008A38 ; Segment type: Pure code
.text$mn:00008A38 ; Segment permissions: Read/Execute
.text$mn:00008A38 _text$mn        segment para public 'CODE' use32
.text$mn:00008A38                 assume cs:_text$mn
.text$mn:00008A38                 ;org 8A38h
.text$mn:00008A38 ; COMDAT (pick any)
.text$mn:00008A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A38
.text$mn:00008A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A38
.text$mn:00008A38 ; Attributes: bp-based frame
.text$mn:00008A38
.text$mn:00008A38 ; public: struct std::_Wrap_alloc<class std::allocator<struct tTbData *>> __thiscall std::_Wrap_alloc<class std::allocator<struct tTbData *>>::select_on_container_copy_construction(void)const
.text$mn:00008A38                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AU12@XZ
.text$mn:00008A38 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00008A38                                         ; CODE XREF: std::vector<tTbData *,std::allocator<tTbData *>>::vector<tTbData *,std::allocator<tTbData *>>(std::vector<tTbData *,std::allocator<tTbData *>> const &)+41p
.text$mn:00008A38
.text$mn:00008A38 var_8           = dword ptr -8
.text$mn:00008A38 var_1           = byte ptr -1
.text$mn:00008A38 arg_0           = dword ptr  8
.text$mn:00008A38
.text$mn:00008A38                 push    ebp
.text$mn:00008A39                 mov     ebp, esp
.text$mn:00008A3B                 sub     esp, 8
.text$mn:00008A3E                 mov     [ebp+var_8], ecx
.text$mn:00008A41                 mov     eax, [ebp+var_8]
.text$mn:00008A44                 push    eax
.text$mn:00008A45                 lea     ecx, [ebp+var_1]
.text$mn:00008A48                 push    ecx
.text$mn:00008A49                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAUtTbData@@@std@@@std@@SA?AV?$allocator@PAUtTbData@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<tTbData *>>::select_on_container_copy_construction(std::allocator<tTbData *> const &)
.text$mn:00008A4E                 add     esp, 8
.text$mn:00008A51                 push    eax
.text$mn:00008A52                 mov     ecx, [ebp+arg_0]
.text$mn:00008A55                 call    ??0?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z ; std::_Wrap_alloc<std::allocator<tTbData *>>::_Wrap_alloc<std::allocator<tTbData *>>(std::allocator<tTbData *> const &)
.text$mn:00008A5A                 mov     eax, [ebp+arg_0]
.text$mn:00008A5D                 mov     esp, ebp
.text$mn:00008A5F                 pop     ebp
.text$mn:00008A60                 retn    4
.text$mn:00008A60 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AU12@XZ endp
.text$mn:00008A60
.text$mn:00008A60 ; ---------------------------------------------------------------------------
.text$mn:00008A63                 align 4
.text$mn:00008A63 _text$mn        ends
.text$mn:00008A63
.text$mn:00008A64 ; ===========================================================================
.text$mn:00008A64
.text$mn:00008A64 ; Segment type: Pure code
.text$mn:00008A64 ; Segment permissions: Read/Execute
.text$mn:00008A64 _text$mn        segment para public 'CODE' use32
.text$mn:00008A64                 assume cs:_text$mn
.text$mn:00008A64                 ;org 8A64h
.text$mn:00008A64 ; COMDAT (pick any)
.text$mn:00008A64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A64
.text$mn:00008A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A64
.text$mn:00008A64 ; Attributes: bp-based frame
.text$mn:00008A64
.text$mn:00008A64 ; public: class std::allocator<struct tTbData *> __thiscall std::allocator<struct tTbData *>::select_on_container_copy_construction(void)const
.text$mn:00008A64                 public ?select_on_container_copy_construction@?$allocator@PAUtTbData@@@std@@QBE?AV12@XZ
.text$mn:00008A64 ?select_on_container_copy_construction@?$allocator@PAUtTbData@@@std@@QBE?AV12@XZ proc near
.text$mn:00008A64                                         ; CODE XREF: std::allocator_traits<std::allocator<tTbData *>>::select_on_container_copy_construction(std::allocator<tTbData *> const &)+Ap
.text$mn:00008A64
.text$mn:00008A64 var_4           = dword ptr -4
.text$mn:00008A64 arg_0           = dword ptr  8
.text$mn:00008A64
.text$mn:00008A64                 push    ebp
.text$mn:00008A65                 mov     ebp, esp
.text$mn:00008A67                 push    ecx
.text$mn:00008A68                 mov     [ebp+var_4], ecx
.text$mn:00008A6B                 mov     eax, [ebp+var_4]
.text$mn:00008A6E                 push    eax
.text$mn:00008A6F                 mov     ecx, [ebp+arg_0]
.text$mn:00008A72                 call    ??0?$allocator@PAUtTbData@@@std@@QAE@ABV01@@Z ; std::allocator<tTbData *>::allocator<tTbData *>(std::allocator<tTbData *> const &)
.text$mn:00008A77                 mov     eax, [ebp+arg_0]
.text$mn:00008A7A                 mov     esp, ebp
.text$mn:00008A7C                 pop     ebp
.text$mn:00008A7D                 retn    4
.text$mn:00008A7D ?select_on_container_copy_construction@?$allocator@PAUtTbData@@@std@@QBE?AV12@XZ endp
.text$mn:00008A7D
.text$mn:00008A7D _text$mn        ends
.text$mn:00008A7D
.text$mn:00008A80 ; ===========================================================================
.text$mn:00008A80
.text$mn:00008A80 ; Segment type: Pure code
.text$mn:00008A80 ; Segment permissions: Read/Execute
.text$mn:00008A80 _text$mn        segment para public 'CODE' use32
.text$mn:00008A80                 assume cs:_text$mn
.text$mn:00008A80                 ;org 8A80h
.text$mn:00008A80 ; COMDAT (pick any)
.text$mn:00008A80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A80
.text$mn:00008A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A80
.text$mn:00008A80 ; Attributes: bp-based frame
.text$mn:00008A80
.text$mn:00008A80 ; public: static class std::allocator<struct tTbData *> __cdecl std::allocator_traits<class std::allocator<struct tTbData *>>::select_on_container_copy_construction(class std::allocator<struct tTbData *> const &)
.text$mn:00008A80                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAUtTbData@@@std@@@std@@SA?AV?$allocator@PAUtTbData@@@2@ABV32@@Z
.text$mn:00008A80 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAUtTbData@@@std@@@std@@SA?AV?$allocator@PAUtTbData@@@2@ABV32@@Z proc near
.text$mn:00008A80                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tTbData *>>::select_on_container_copy_construction(void)+11p
.text$mn:00008A80
.text$mn:00008A80 arg_0           = dword ptr  8
.text$mn:00008A80 arg_4           = dword ptr  0Ch
.text$mn:00008A80
.text$mn:00008A80                 push    ebp
.text$mn:00008A81                 mov     ebp, esp
.text$mn:00008A83                 mov     eax, [ebp+arg_0]
.text$mn:00008A86                 push    eax
.text$mn:00008A87                 mov     ecx, [ebp+arg_4]
.text$mn:00008A8A                 call    ?select_on_container_copy_construction@?$allocator@PAUtTbData@@@std@@QBE?AV12@XZ ; std::allocator<tTbData *>::select_on_container_copy_construction(void)
.text$mn:00008A8F                 mov     eax, [ebp+arg_0]
.text$mn:00008A92                 pop     ebp
.text$mn:00008A93                 retn
.text$mn:00008A93 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAUtTbData@@@std@@@std@@SA?AV?$allocator@PAUtTbData@@@2@ABV32@@Z endp
.text$mn:00008A93
.text$mn:00008A93 _text$mn        ends
.text$mn:00008A93
.text$mn:00008A94 ; ===========================================================================
.text$mn:00008A94
.text$mn:00008A94 ; Segment type: Pure code
.text$mn:00008A94 ; Segment permissions: Read/Execute
.text$mn:00008A94 _text$mn        segment para public 'CODE' use32
.text$mn:00008A94                 assume cs:_text$mn
.text$mn:00008A94                 ;org 8A94h
.text$mn:00008A94 ; COMDAT (pick any)
.text$mn:00008A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A94
.text$mn:00008A94 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A94
.text$mn:00008A94 ; Attributes: bp-based frame
.text$mn:00008A94
.text$mn:00008A94 ; void __thiscall DockingManager::setClientWnd(DockingManager *this, struct Window **)
.text$mn:00008A94                 public ?setClientWnd@DockingManager@@QAEXPAPAVWindow@@@Z
.text$mn:00008A94 ?setClientWnd@DockingManager@@QAEXPAPAVWindow@@@Z proc near
.text$mn:00008A94                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+11Dp
.text$mn:00008A94
.text$mn:00008A94 var_4           = dword ptr -4
.text$mn:00008A94 arg_0           = dword ptr  8
.text$mn:00008A94
.text$mn:00008A94                 push    ebp
.text$mn:00008A95                 mov     ebp, esp
.text$mn:00008A97                 push    ecx
.text$mn:00008A98                 mov     [ebp+var_4], ecx
.text$mn:00008A9B                 mov     eax, [ebp+var_4]
.text$mn:00008A9E                 mov     ecx, [ebp+arg_0]
.text$mn:00008AA1                 mov     [eax+10h], ecx
.text$mn:00008AA4                 mov     edx, [ebp+var_4]
.text$mn:00008AA7                 mov     eax, [ebp+arg_0]
.text$mn:00008AAA                 mov     [edx+34h], eax
.text$mn:00008AAD                 mov     esp, ebp
.text$mn:00008AAF                 pop     ebp
.text$mn:00008AB0                 retn    4
.text$mn:00008AB0 ?setClientWnd@DockingManager@@QAEXPAPAVWindow@@@Z endp
.text$mn:00008AB0
.text$mn:00008AB0 ; ---------------------------------------------------------------------------
.text$mn:00008AB3                 align 4
.text$mn:00008AB3 _text$mn        ends
.text$mn:00008AB3
.text$mn:00008AB4 ; ===========================================================================
.text$mn:00008AB4
.text$mn:00008AB4 ; Segment type: Pure code
.text$mn:00008AB4 ; Segment permissions: Read/Execute
.text$mn:00008AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00008AB4                 assume cs:_text$mn
.text$mn:00008AB4                 ;org 8AB4h
.text$mn:00008AB4 ; COMDAT (pick any)
.text$mn:00008AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008AB4
.text$mn:00008AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008AB4
.text$mn:00008AB4 ; Attributes: bp-based frame
.text$mn:00008AB4
.text$mn:00008AB4 ; void __thiscall DockingManager::showContainer(DockingManager *this, unsigned int, int)
.text$mn:00008AB4                 public ?showContainer@DockingManager@@QAEXIH@Z
.text$mn:00008AB4 ?showContainer@DockingManager@@QAEXIH@Z proc near
.text$mn:00008AB4                                         ; CODE XREF: DockingManager::showContainer(HWND__ *,int)+57p
.text$mn:00008AB4
.text$mn:00008AB4 var_8           = dword ptr -8
.text$mn:00008AB4 var_1           = byte ptr -1
.text$mn:00008AB4 arg_0           = dword ptr  8
.text$mn:00008AB4 arg_4           = dword ptr  0Ch
.text$mn:00008AB4
.text$mn:00008AB4                 push    ebp
.text$mn:00008AB5                 mov     ebp, esp
.text$mn:00008AB7                 sub     esp, 8
.text$mn:00008ABA                 mov     [ebp+var_8], ecx
.text$mn:00008ABD                 cmp     [ebp+arg_4], 1
.text$mn:00008AC1                 jnz     short loc_8AC9
.text$mn:00008AC3                 mov     [ebp+var_1], 1
.text$mn:00008AC7                 jmp     short loc_8ACD
.text$mn:00008AC9 ; ---------------------------------------------------------------------------
.text$mn:00008AC9
.text$mn:00008AC9 loc_8AC9:                               ; CODE XREF: DockingManager::showContainer(uint,int)+Dj
.text$mn:00008AC9                 mov     [ebp+var_1], 0
.text$mn:00008ACD
.text$mn:00008ACD loc_8ACD:                               ; CODE XREF: DockingManager::showContainer(uint,int)+13j
.text$mn:00008ACD                 push    0               ; bool
.text$mn:00008ACF                 movzx   eax, [ebp+var_1]
.text$mn:00008AD3                 push    eax             ; bool
.text$mn:00008AD4                 mov     ecx, [ebp+arg_0]
.text$mn:00008AD7                 push    ecx
.text$mn:00008AD8                 mov     ecx, [ebp+var_8]
.text$mn:00008ADB                 add     ecx, 4Ch ; 'L'
.text$mn:00008ADE                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00008AE3                 mov     ecx, [eax]      ; this
.text$mn:00008AE5                 call    ?doDialog@DockingCont@@QAEX_N0@Z ; DockingCont::doDialog(bool,bool)
.text$mn:00008AEA                 mov     ecx, [ebp+var_8] ; this
.text$mn:00008AED                 call    ?onSize@DockingManager@@AAEXXZ ; DockingManager::onSize(void)
.text$mn:00008AF2                 mov     esp, ebp
.text$mn:00008AF4                 pop     ebp
.text$mn:00008AF5                 retn    8
.text$mn:00008AF5 ?showContainer@DockingManager@@QAEXIH@Z endp
.text$mn:00008AF5
.text$mn:00008AF5 _text$mn        ends
.text$mn:00008AF5
.text$mn:00008AF8 ; ===========================================================================
.text$mn:00008AF8
.text$mn:00008AF8 ; Segment type: Pure code
.text$mn:00008AF8 ; Segment permissions: Read/Execute
.text$mn:00008AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00008AF8                 assume cs:_text$mn
.text$mn:00008AF8                 ;org 8AF8h
.text$mn:00008AF8 ; COMDAT (pick any)
.text$mn:00008AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008AF8
.text$mn:00008AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008AF8
.text$mn:00008AF8 ; Attributes: bp-based frame
.text$mn:00008AF8
.text$mn:00008AF8 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00008AF8                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00008AF8 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00008AF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00008AF8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00008AF8
.text$mn:00008AF8 var_4           = dword ptr -4
.text$mn:00008AF8
.text$mn:00008AF8                 push    ebp
.text$mn:00008AF9                 mov     ebp, esp
.text$mn:00008AFB                 push    ecx
.text$mn:00008AFC                 mov     [ebp+var_4], ecx
.text$mn:00008AFF                 mov     eax, [ebp+var_4]
.text$mn:00008B02                 mov     eax, [eax+14h]
.text$mn:00008B05                 mov     esp, ebp
.text$mn:00008B07                 pop     ebp
.text$mn:00008B08                 retn
.text$mn:00008B08 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00008B08
.text$mn:00008B08 ; ---------------------------------------------------------------------------
.text$mn:00008B09                 align 4
.text$mn:00008B09 _text$mn        ends
.text$mn:00008B09
.text$mn:00008B0C ; ===========================================================================
.text$mn:00008B0C
.text$mn:00008B0C ; Segment type: Pure code
.text$mn:00008B0C ; Segment permissions: Read/Execute
.text$mn:00008B0C _text$mn        segment para public 'CODE' use32
.text$mn:00008B0C                 assume cs:_text$mn
.text$mn:00008B0C                 ;org 8B0Ch
.text$mn:00008B0C ; COMDAT (pick any)
.text$mn:00008B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B0C
.text$mn:00008B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00008B0C
.text$mn:00008B0C ; Attributes: bp-based frame
.text$mn:00008B0C
.text$mn:00008B0C ; public: unsigned int __thiscall std::vector<struct HWND__ *, class std::allocator<struct HWND__ *>>::size(void)const
.text$mn:00008B0C                 public ?size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ
.text$mn:00008B0C ?size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ proc near
.text$mn:00008B0C                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+5A7p
.text$mn:00008B0C                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+Ap ...
.text$mn:00008B0C
.text$mn:00008B0C var_4           = dword ptr -4
.text$mn:00008B0C
.text$mn:00008B0C                 push    ebp
.text$mn:00008B0D                 mov     ebp, esp
.text$mn:00008B0F                 push    ecx
.text$mn:00008B10                 mov     [ebp+var_4], ecx
.text$mn:00008B13                 mov     eax, [ebp+var_4]
.text$mn:00008B16                 mov     ecx, [ebp+var_4]
.text$mn:00008B19                 mov     eax, [eax+8]
.text$mn:00008B1C                 sub     eax, [ecx+4]
.text$mn:00008B1F                 sar     eax, 2
.text$mn:00008B22                 mov     esp, ebp
.text$mn:00008B24                 pop     ebp
.text$mn:00008B25                 retn
.text$mn:00008B25 ?size@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QBEIXZ endp
.text$mn:00008B25
.text$mn:00008B25 ; ---------------------------------------------------------------------------
.text$mn:00008B26                 align 4
.text$mn:00008B26 _text$mn        ends
.text$mn:00008B26
.text$mn:00008B28 ; ===========================================================================
.text$mn:00008B28
.text$mn:00008B28 ; Segment type: Pure code
.text$mn:00008B28 ; Segment permissions: Read/Execute
.text$mn:00008B28 _text$mn        segment para public 'CODE' use32
.text$mn:00008B28                 assume cs:_text$mn
.text$mn:00008B28                 ;org 8B28h
.text$mn:00008B28 ; COMDAT (pick any)
.text$mn:00008B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B28
.text$mn:00008B28 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B28
.text$mn:00008B28 ; Attributes: bp-based frame
.text$mn:00008B28
.text$mn:00008B28 ; public: unsigned int __thiscall std::vector<struct tTbData *, class std::allocator<struct tTbData *>>::size(void)const
.text$mn:00008B28                 public ?size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ
.text$mn:00008B28 ?size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ proc near
.text$mn:00008B28                                         ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+9Dp
.text$mn:00008B28                                         ; DockingManager::toggleVisTb(DockingCont *,DockingCont *)+69p ...
.text$mn:00008B28
.text$mn:00008B28 var_4           = dword ptr -4
.text$mn:00008B28
.text$mn:00008B28                 push    ebp
.text$mn:00008B29                 mov     ebp, esp
.text$mn:00008B2B                 push    ecx
.text$mn:00008B2C                 mov     [ebp+var_4], ecx
.text$mn:00008B2F                 mov     eax, [ebp+var_4]
.text$mn:00008B32                 mov     ecx, [ebp+var_4]
.text$mn:00008B35                 mov     eax, [eax+8]
.text$mn:00008B38                 sub     eax, [ecx+4]
.text$mn:00008B3B                 sar     eax, 2
.text$mn:00008B3E                 mov     esp, ebp
.text$mn:00008B40                 pop     ebp
.text$mn:00008B41                 retn
.text$mn:00008B41 ?size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ endp
.text$mn:00008B41
.text$mn:00008B41 ; ---------------------------------------------------------------------------
.text$mn:00008B42                 align 4
.text$mn:00008B42 _text$mn        ends
.text$mn:00008B42
.text$mn:00008B44 ; ===========================================================================
.text$mn:00008B44
.text$mn:00008B44 ; Segment type: Pure code
.text$mn:00008B44 ; Segment permissions: Read/Execute
.text$mn:00008B44 _text$mn        segment para public 'CODE' use32
.text$mn:00008B44                 assume cs:_text$mn
.text$mn:00008B44                 ;org 8B44h
.text$mn:00008B44 ; COMDAT (pick any)
.text$mn:00008B44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B44
.text$mn:00008B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B44
.text$mn:00008B44 ; Attributes: bp-based frame
.text$mn:00008B44
.text$mn:00008B44 ; public: unsigned int __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::size(void)const
.text$mn:00008B44                 public ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ
.text$mn:00008B44 ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ proc near
.text$mn:00008B44                                         ; CODE XREF: DockingManager::showContainer(HWND__ *,int)+16p
.text$mn:00008B44                                         ; DockingManager::updateContainerInfo(HWND__ *)+16p ...
.text$mn:00008B44
.text$mn:00008B44 var_4           = dword ptr -4
.text$mn:00008B44
.text$mn:00008B44                 push    ebp
.text$mn:00008B45                 mov     ebp, esp
.text$mn:00008B47                 push    ecx
.text$mn:00008B48                 mov     [ebp+var_4], ecx
.text$mn:00008B4B                 mov     eax, [ebp+var_4]
.text$mn:00008B4E                 mov     ecx, [ebp+var_4]
.text$mn:00008B51                 mov     eax, [eax+8]
.text$mn:00008B54                 sub     eax, [ecx+4]
.text$mn:00008B57                 sar     eax, 2
.text$mn:00008B5A                 mov     esp, ebp
.text$mn:00008B5C                 pop     ebp
.text$mn:00008B5D                 retn
.text$mn:00008B5D ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ endp
.text$mn:00008B5D
.text$mn:00008B5D ; ---------------------------------------------------------------------------
.text$mn:00008B5E                 align 10h
.text$mn:00008B5E _text$mn        ends
.text$mn:00008B5E
.text$mn:00008B60 ; ===========================================================================
.text$mn:00008B60
.text$mn:00008B60 ; Segment type: Pure code
.text$mn:00008B60 ; Segment permissions: Read/Execute
.text$mn:00008B60 _text$mn        segment para public 'CODE' use32
.text$mn:00008B60                 assume cs:_text$mn
.text$mn:00008B60                 ;org 8B60h
.text$mn:00008B60 ; COMDAT (pick any)
.text$mn:00008B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B60
.text$mn:00008B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B60
.text$mn:00008B60 ; Attributes: bp-based frame
.text$mn:00008B60
.text$mn:00008B60 ; public: unsigned int __thiscall std::vector<class DockingSplitter *, class std::allocator<class DockingSplitter *>>::size(void)const
.text$mn:00008B60                 public ?size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ
.text$mn:00008B60 ?size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ proc near
.text$mn:00008B60                                         ; CODE XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)+Ap
.text$mn:00008B60                                         ; std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::_Reallocate(uint)+A9p ...
.text$mn:00008B60
.text$mn:00008B60 var_4           = dword ptr -4
.text$mn:00008B60
.text$mn:00008B60                 push    ebp
.text$mn:00008B61                 mov     ebp, esp
.text$mn:00008B63                 push    ecx
.text$mn:00008B64                 mov     [ebp+var_4], ecx
.text$mn:00008B67                 mov     eax, [ebp+var_4]
.text$mn:00008B6A                 mov     ecx, [ebp+var_4]
.text$mn:00008B6D                 mov     eax, [eax+8]
.text$mn:00008B70                 sub     eax, [ecx+4]
.text$mn:00008B73                 sar     eax, 2
.text$mn:00008B76                 mov     esp, ebp
.text$mn:00008B78                 pop     ebp
.text$mn:00008B79                 retn
.text$mn:00008B79 ?size@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QBEIXZ endp
.text$mn:00008B79
.text$mn:00008B79 ; ---------------------------------------------------------------------------
.text$mn:00008B7A                 align 4
.text$mn:00008B7A _text$mn        ends
.text$mn:00008B7A
.text$mn:00008B7C ; ===========================================================================
.text$mn:00008B7C
.text$mn:00008B7C ; Segment type: Pure code
.text$mn:00008B7C ; Segment permissions: Read/Execute
.text$mn:00008B7C _text$mn        segment para public 'CODE' use32
.text$mn:00008B7C                 assume cs:_text$mn
.text$mn:00008B7C                 ;org 8B7Ch
.text$mn:00008B7C ; COMDAT (pick any)
.text$mn:00008B7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B7C
.text$mn:00008B7C ; =============== S U B R O U T I N E =======================================
.text$mn:00008B7C
.text$mn:00008B7C ; Attributes: bp-based frame
.text$mn:00008B7C
.text$mn:00008B7C ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00008B7C                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00008B7C ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00008B7C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_7D34p
.text$mn:00008B7C                 push    ebp
.text$mn:00008B7D                 mov     ebp, esp
.text$mn:00008B7F                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00008B84                 pop     ebp
.text$mn:00008B85                 retn
.text$mn:00008B85 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00008B85
.text$mn:00008B85 ; ---------------------------------------------------------------------------
.text$mn:00008B86                 align 4
.text$mn:00008B86 _text$mn        ends
.text$mn:00008B86
.text$mn:00008B88 ; ===========================================================================
.text$mn:00008B88
.text$mn:00008B88 ; Segment type: Pure code
.text$mn:00008B88 ; Segment permissions: Read/Execute
.text$mn:00008B88 _text$mn        segment para public 'CODE' use32
.text$mn:00008B88                 assume cs:_text$mn
.text$mn:00008B88                 ;org 8B88h
.text$mn:00008B88 ; COMDAT (pick any)
.text$mn:00008B88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B88
.text$mn:00008B88 ; =============== S U B R O U T I N E =======================================
.text$mn:00008B88
.text$mn:00008B88 ; Attributes: bp-based frame
.text$mn:00008B88
.text$mn:00008B88 ; int __thiscall DockingCont::updateInfo(DockingCont *this, HWND)
.text$mn:00008B88                 public ?updateInfo@DockingCont@@QAEHPAUHWND__@@@Z
.text$mn:00008B88 ?updateInfo@DockingCont@@QAEHPAUHWND__@@@Z proc near
.text$mn:00008B88                                         ; CODE XREF: DockingManager::updateContainerInfo(HWND__ *)+46p
.text$mn:00008B88
.text$mn:00008B88 var_8           = dword ptr -8
.text$mn:00008B88 var_4           = dword ptr -4
.text$mn:00008B88 arg_0           = dword ptr  8
.text$mn:00008B88
.text$mn:00008B88                 push    ebp
.text$mn:00008B89                 mov     ebp, esp
.text$mn:00008B8B                 sub     esp, 8
.text$mn:00008B8E                 mov     [ebp+var_8], ecx
.text$mn:00008B91                 mov     [ebp+var_4], 0
.text$mn:00008B98                 jmp     short loc_8BA3
.text$mn:00008B9A ; ---------------------------------------------------------------------------
.text$mn:00008B9A
.text$mn:00008B9A loc_8B9A:                               ; CODE XREF: DockingCont::updateInfo(HWND__ *):loc_8BE0j
.text$mn:00008B9A                 mov     eax, [ebp+var_4]
.text$mn:00008B9D                 add     eax, 1
.text$mn:00008BA0                 mov     [ebp+var_4], eax
.text$mn:00008BA3
.text$mn:00008BA3 loc_8BA3:                               ; CODE XREF: DockingCont::updateInfo(HWND__ *)+10j
.text$mn:00008BA3                 mov     ecx, [ebp+var_8]
.text$mn:00008BA6                 add     ecx, 9Ch ; '£'
.text$mn:00008BAC                 call    ?size@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBEIXZ ; std::vector<tTbData *,std::allocator<tTbData *>>::size(void)
.text$mn:00008BB1                 cmp     [ebp+var_4], eax
.text$mn:00008BB4                 jnb     short loc_8BE2
.text$mn:00008BB6                 mov     ecx, [ebp+var_4]
.text$mn:00008BB9                 push    ecx
.text$mn:00008BBA                 mov     ecx, [ebp+var_8]
.text$mn:00008BBD                 add     ecx, 9Ch ; '£'
.text$mn:00008BC3                 call    ??A?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAEAAPAUtTbData@@I@Z ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)
.text$mn:00008BC8                 mov     edx, [eax]
.text$mn:00008BCA                 mov     eax, [edx]
.text$mn:00008BCC                 cmp     eax, [ebp+arg_0]
.text$mn:00008BCF                 jnz     short loc_8BE0
.text$mn:00008BD1                 mov     ecx, [ebp+var_8] ; this
.text$mn:00008BD4                 call    ?updateCaption@DockingCont@@IAE_NXZ ; DockingCont::updateCaption(void)
.text$mn:00008BD9                 mov     eax, 1
.text$mn:00008BDE                 jmp     short loc_8BE4
.text$mn:00008BE0 ; ---------------------------------------------------------------------------
.text$mn:00008BE0
.text$mn:00008BE0 loc_8BE0:                               ; CODE XREF: DockingCont::updateInfo(HWND__ *)+47j
.text$mn:00008BE0                 jmp     short loc_8B9A
.text$mn:00008BE2 ; ---------------------------------------------------------------------------
.text$mn:00008BE2
.text$mn:00008BE2 loc_8BE2:                               ; CODE XREF: DockingCont::updateInfo(HWND__ *)+2Cj
.text$mn:00008BE2                 xor     eax, eax
.text$mn:00008BE4
.text$mn:00008BE4 loc_8BE4:                               ; CODE XREF: DockingCont::updateInfo(HWND__ *)+56j
.text$mn:00008BE4                 mov     esp, ebp
.text$mn:00008BE6                 pop     ebp
.text$mn:00008BE7                 retn    4
.text$mn:00008BE7 ?updateInfo@DockingCont@@QAEHPAUHWND__@@@Z endp
.text$mn:00008BE7
.text$mn:00008BE7 ; ---------------------------------------------------------------------------
.text$mn:00008BEA                 align 4
.text$mn:00008BEA _text$mn        ends
.text$mn:00008BEA
.text$mn:00008BEC ; ===========================================================================
.text$mn:00008BEC
.text$mn:00008BEC ; Segment type: Pure code
.text$mn:00008BEC ; Segment permissions: Read/Execute
.text$mn:00008BEC _text$mn        segment para public 'CODE' use32
.text$mn:00008BEC                 assume cs:_text$mn
.text$mn:00008BEC                 ;org 8BECh
.text$mn:00008BEC ; COMDAT (pick any)
.text$mn:00008BEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008BEC
.text$mn:00008BEC ; =============== S U B R O U T I N E =======================================
.text$mn:00008BEC
.text$mn:00008BEC ; Attributes: bp-based frame
.text$mn:00008BEC
.text$mn:00008BEC ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00008BEC                 public ?value@error_code@std@@QBEHXZ
.text$mn:00008BEC ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00008BEC
.text$mn:00008BEC var_4           = dword ptr -4
.text$mn:00008BEC
.text$mn:00008BEC                 push    ebp
.text$mn:00008BED                 mov     ebp, esp
.text$mn:00008BEF                 push    ecx
.text$mn:00008BF0                 mov     [ebp+var_4], ecx
.text$mn:00008BF3                 mov     eax, [ebp+var_4]
.text$mn:00008BF6                 mov     eax, [eax]
.text$mn:00008BF8                 mov     esp, ebp
.text$mn:00008BFA                 pop     ebp
.text$mn:00008BFB                 retn
.text$mn:00008BFB ?value@error_code@std@@QBEHXZ endp
.text$mn:00008BFB
.text$mn:00008BFB _text$mn        ends
.text$mn:00008BFB
.text$mn:00008BFC ; ===========================================================================
.text$mn:00008BFC
.text$mn:00008BFC ; Segment type: Pure code
.text$mn:00008BFC ; Segment permissions: Read/Execute
.text$mn:00008BFC _text$mn        segment para public 'CODE' use32
.text$mn:00008BFC                 assume cs:_text$mn
.text$mn:00008BFC                 ;org 8BFCh
.text$mn:00008BFC ; COMDAT (pick any)
.text$mn:00008BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008BFC
.text$mn:00008BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00008BFC
.text$mn:00008BFC ; Attributes: bp-based frame
.text$mn:00008BFC
.text$mn:00008BFC ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00008BFC                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00008BFC ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00008BFC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00008BFC                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00008BFC
.text$mn:00008BFC var_4           = dword ptr -4
.text$mn:00008BFC
.text$mn:00008BFC                 push    ebp
.text$mn:00008BFD                 mov     ebp, esp
.text$mn:00008BFF                 push    ecx
.text$mn:00008C00                 mov     [ebp+var_4], ecx
.text$mn:00008C03                 mov     eax, [ebp+var_4]
.text$mn:00008C06                 mov     eax, [eax]
.text$mn:00008C08                 mov     esp, ebp
.text$mn:00008C0A                 pop     ebp
.text$mn:00008C0B                 retn
.text$mn:00008C0B ?value@error_condition@std@@QBEHXZ endp
.text$mn:00008C0B
.text$mn:00008C0B _text$mn        ends
.text$mn:00008C0B
.text$mn:00008C0C ; ===========================================================================
.text$mn:00008C0C
.text$mn:00008C0C ; Segment type: Pure code
.text$mn:00008C0C ; Segment permissions: Read/Execute
.text$mn:00008C0C _text$mn        segment para public 'CODE' use32
.text$mn:00008C0C                 assume cs:_text$mn
.text$mn:00008C0C                 ;org 8C0Ch
.text$mn:00008C0C ; COMDAT (pick any)
.text$mn:00008C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008C0C
.text$mn:00008C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00008C0C
.text$mn:00008C0C ; Attributes: bp-based frame
.text$mn:00008C0C
.text$mn:00008C0C                 public _hypot
.text$mn:00008C0C _hypot          proc near
.text$mn:00008C0C
.text$mn:00008C0C var_10          = qword ptr -10h
.text$mn:00008C0C var_8           = qword ptr -8
.text$mn:00008C0C arg_0           = qword ptr  8
.text$mn:00008C0C arg_8           = qword ptr  10h
.text$mn:00008C0C
.text$mn:00008C0C                 push    ebp
.text$mn:00008C0D                 mov     ebp, esp
.text$mn:00008C0F                 sub     esp, 8
.text$mn:00008C12                 movsd   xmm0, [ebp+arg_8]
.text$mn:00008C17                 movsd   [esp+8+var_8], xmm0
.text$mn:00008C1C                 sub     esp, 8
.text$mn:00008C1F                 movsd   xmm0, [ebp+arg_0]
.text$mn:00008C24                 movsd   [esp+10h+var_10], xmm0
.text$mn:00008C29                 call    __hypot
.text$mn:00008C2E                 add     esp, 10h
.text$mn:00008C31                 pop     ebp
.text$mn:00008C32                 retn
.text$mn:00008C32 _hypot          endp
.text$mn:00008C32
.text$mn:00008C32 ; ---------------------------------------------------------------------------
.text$mn:00008C33                 align 4
.text$mn:00008C33 _text$mn        ends
.text$mn:00008C33
.xdata$x:00008C34 ; ===========================================================================
.xdata$x:00008C34
.xdata$x:00008C34 ; Segment type: Pure data
.xdata$x:00008C34 ; Segment permissions: Read
.xdata$x:00008C34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008C34                 assume cs:_xdata$x
.xdata$x:00008C34                 ;org 8C34h
.xdata$x:00008C34 ; COMDAT (pick associative to section at 6A34)
.xdata$x:00008C34 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00008C34                                         ; DATA XREF: .xdata$x:00008C44o
.xdata$x:00008C35                 db 0FFh
.xdata$x:00008C36                 db 0FFh
.xdata$x:00008C37                 db 0FFh
.xdata$x:00008C38                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00008C3C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00008C3C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00008C3D                 db    5
.xdata$x:00008C3E                 db  93h ; ô
.xdata$x:00008C3F                 db  19h
.xdata$x:00008C40                 db    1
.xdata$x:00008C41                 db    0
.xdata$x:00008C42                 db    0
.xdata$x:00008C43                 db    0
.xdata$x:00008C44                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00008C48                 align 20h
.xdata$x:00008C48 _xdata$x        ends
.xdata$x:00008C48
.xdata$x:00008C60 ; ===========================================================================
.xdata$x:00008C60
.xdata$x:00008C60 ; Segment type: Pure data
.xdata$x:00008C60 ; Segment permissions: Read
.xdata$x:00008C60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008C60                 assume cs:_xdata$x
.xdata$x:00008C60                 ;org 8C60h
.xdata$x:00008C60 ; COMDAT (pick associative to section at 5980)
.xdata$x:00008C60 __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:00008C60                                         ; DATA XREF: .xdata$x:00008C70o
.xdata$x:00008C61                 db 0FFh
.xdata$x:00008C62                 db 0FFh
.xdata$x:00008C63                 db 0FFh
.xdata$x:00008C64                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:00008C68 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:00008C68                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:00008C69                 db    5
.xdata$x:00008C6A                 db  93h ; ô
.xdata$x:00008C6B                 db  19h
.xdata$x:00008C6C                 db    1
.xdata$x:00008C6D                 db    0
.xdata$x:00008C6E                 db    0
.xdata$x:00008C6F                 db    0
.xdata$x:00008C70                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:00008C74                 db    0
.xdata$x:00008C75                 db    0
.xdata$x:00008C76                 db    0
.xdata$x:00008C77                 db    0
.xdata$x:00008C78                 db    0
.xdata$x:00008C79                 db    0
.xdata$x:00008C7A                 db    0
.xdata$x:00008C7B                 db    0
.xdata$x:00008C7C                 db    0
.xdata$x:00008C7D                 db    0
.xdata$x:00008C7E                 db    0
.xdata$x:00008C7F                 db    0
.xdata$x:00008C80                 db    0
.xdata$x:00008C81                 db    0
.xdata$x:00008C82                 db    0
.xdata$x:00008C83                 db    0
.xdata$x:00008C84                 db    0
.xdata$x:00008C85                 db    0
.xdata$x:00008C86                 db    0
.xdata$x:00008C87                 db    0
.xdata$x:00008C88                 db    0
.xdata$x:00008C89                 db    0
.xdata$x:00008C8A                 db    0
.xdata$x:00008C8B                 db    0
.xdata$x:00008C8B _xdata$x        ends
.xdata$x:00008C8B
.xdata$x:00008C8C ; ===========================================================================
.xdata$x:00008C8C
.xdata$x:00008C8C ; Segment type: Pure data
.xdata$x:00008C8C ; Segment permissions: Read
.xdata$x:00008C8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008C8C                 assume cs:_xdata$x
.xdata$x:00008C8C                 ;org 8C8Ch
.xdata$x:00008C8C ; COMDAT (pick associative to section at 57F8)
.xdata$x:00008C8C __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:00008C8C                                         ; DATA XREF: .xdata$x:00008C9Co
.xdata$x:00008C8D                 db 0FFh
.xdata$x:00008C8E                 db 0FFh
.xdata$x:00008C8F                 db 0FFh
.xdata$x:00008C90                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:00008C94 __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:00008C94                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:00008C95                 db    5
.xdata$x:00008C96                 db  93h ; ô
.xdata$x:00008C97                 db  19h
.xdata$x:00008C98                 db    1
.xdata$x:00008C99                 db    0
.xdata$x:00008C9A                 db    0
.xdata$x:00008C9B                 db    0
.xdata$x:00008C9C                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:00008CA0                 db    0
.xdata$x:00008CA1                 db    0
.xdata$x:00008CA2                 db    0
.xdata$x:00008CA3                 db    0
.xdata$x:00008CA4                 db    0
.xdata$x:00008CA5                 db    0
.xdata$x:00008CA6                 db    0
.xdata$x:00008CA7                 db    0
.xdata$x:00008CA8                 db    0
.xdata$x:00008CA9                 db    0
.xdata$x:00008CAA                 db    0
.xdata$x:00008CAB                 db    0
.xdata$x:00008CAC                 db    0
.xdata$x:00008CAD                 db    0
.xdata$x:00008CAE                 db    0
.xdata$x:00008CAF                 db    0
.xdata$x:00008CB0                 db    0
.xdata$x:00008CB1                 db    0
.xdata$x:00008CB2                 db    0
.xdata$x:00008CB3                 db    0
.xdata$x:00008CB4                 db    0
.xdata$x:00008CB5                 db    0
.xdata$x:00008CB6                 db    0
.xdata$x:00008CB7                 db    0
.xdata$x:00008CB7 _xdata$x        ends
.xdata$x:00008CB7
.xdata$x:00008CB8 ; ===========================================================================
.xdata$x:00008CB8
.xdata$x:00008CB8 ; Segment type: Pure data
.xdata$x:00008CB8 ; Segment permissions: Read
.xdata$x:00008CB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008CB8                 assume cs:_xdata$x
.xdata$x:00008CB8                 ;org 8CB8h
.xdata$x:00008CB8 ; COMDAT (pick associative to section at 5F6C)
.xdata$x:00008CB8 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:00008CB8                                         ; DATA XREF: .xdata$x:00008CD0o
.xdata$x:00008CB9                 db 0FFh
.xdata$x:00008CBA                 db 0FFh
.xdata$x:00008CBB                 db 0FFh
.xdata$x:00008CBC                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:00008CC0                 db 0FFh
.xdata$x:00008CC1                 db 0FFh
.xdata$x:00008CC2                 db 0FFh
.xdata$x:00008CC3                 db 0FFh
.xdata$x:00008CC4                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:00008CC8 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:00008CC8                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:00008CC9                 db    5
.xdata$x:00008CCA                 db  93h ; ô
.xdata$x:00008CCB                 db  19h
.xdata$x:00008CCC                 db    2
.xdata$x:00008CCD                 db    0
.xdata$x:00008CCE                 db    0
.xdata$x:00008CCF                 db    0
.xdata$x:00008CD0                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:00008CD4                 db    0
.xdata$x:00008CD5                 db    0
.xdata$x:00008CD6                 db    0
.xdata$x:00008CD7                 db    0
.xdata$x:00008CD8                 db    0
.xdata$x:00008CD9                 db    0
.xdata$x:00008CDA                 db    0
.xdata$x:00008CDB                 db    0
.xdata$x:00008CDC                 db    0
.xdata$x:00008CDD                 db    0
.xdata$x:00008CDE                 db    0
.xdata$x:00008CDF                 db    0
.xdata$x:00008CE0                 db    0
.xdata$x:00008CE1                 db    0
.xdata$x:00008CE2                 db    0
.xdata$x:00008CE3                 db    0
.xdata$x:00008CE4                 db    0
.xdata$x:00008CE5                 db    0
.xdata$x:00008CE6                 db    0
.xdata$x:00008CE7                 db    0
.xdata$x:00008CE8                 db    0
.xdata$x:00008CE9                 db    0
.xdata$x:00008CEA                 db    0
.xdata$x:00008CEB                 db    0
.xdata$x:00008CEB _xdata$x        ends
.xdata$x:00008CEB
.xdata$x:00008CEC ; ===========================================================================
.xdata$x:00008CEC
.xdata$x:00008CEC ; Segment type: Pure data
.xdata$x:00008CEC ; Segment permissions: Read
.xdata$x:00008CEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008CEC                 assume cs:_xdata$x
.xdata$x:00008CEC                 ;org 8CECh
.xdata$x:00008CEC ; COMDAT (pick associative to section at 4044)
.xdata$x:00008CEC __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008CEC                                         ; DATA XREF: .xdata$x:00008CFCo
.xdata$x:00008CED                 db 0FFh
.xdata$x:00008CEE                 db 0FFh
.xdata$x:00008CEF                 db 0FFh
.xdata$x:00008CF0                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00008CF4 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008CF4                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00008CF5                 db    5
.xdata$x:00008CF6                 db  93h ; ô
.xdata$x:00008CF7                 db  19h
.xdata$x:00008CF8                 db    1
.xdata$x:00008CF9                 db    0
.xdata$x:00008CFA                 db    0
.xdata$x:00008CFB                 db    0
.xdata$x:00008CFC                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00008D00                 db    0
.xdata$x:00008D01                 db    0
.xdata$x:00008D02                 db    0
.xdata$x:00008D03                 db    0
.xdata$x:00008D04                 db    0
.xdata$x:00008D05                 db    0
.xdata$x:00008D06                 db    0
.xdata$x:00008D07                 db    0
.xdata$x:00008D08                 db    0
.xdata$x:00008D09                 db    0
.xdata$x:00008D0A                 db    0
.xdata$x:00008D0B                 db    0
.xdata$x:00008D0C                 db    0
.xdata$x:00008D0D                 db    0
.xdata$x:00008D0E                 db    0
.xdata$x:00008D0F                 db    0
.xdata$x:00008D10                 db    0
.xdata$x:00008D11                 db    0
.xdata$x:00008D12                 db    0
.xdata$x:00008D13                 db    0
.xdata$x:00008D14                 db    0
.xdata$x:00008D15                 db    0
.xdata$x:00008D16                 db    0
.xdata$x:00008D17                 db    0
.xdata$x:00008D17 _xdata$x        ends
.xdata$x:00008D17
.xdata$x:00008D18 ; ===========================================================================
.xdata$x:00008D18
.xdata$x:00008D18 ; Segment type: Pure data
.xdata$x:00008D18 ; Segment permissions: Read
.xdata$x:00008D18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008D18                 assume cs:_xdata$x
.xdata$x:00008D18                 ;org 8D18h
.xdata$x:00008D18 ; COMDAT (pick associative to section at 4F9C)
.xdata$x:00008D18 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008D18                                         ; DATA XREF: .xdata$x:00008D28o
.xdata$x:00008D19                 db 0FFh
.xdata$x:00008D1A                 db 0FFh
.xdata$x:00008D1B                 db 0FFh
.xdata$x:00008D1C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00008D20 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008D20                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00008D21                 db    5
.xdata$x:00008D22                 db  93h ; ô
.xdata$x:00008D23                 db  19h
.xdata$x:00008D24                 db    1
.xdata$x:00008D25                 db    0
.xdata$x:00008D26                 db    0
.xdata$x:00008D27                 db    0
.xdata$x:00008D28                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00008D2C                 db    0
.xdata$x:00008D2D                 db    0
.xdata$x:00008D2E                 db    0
.xdata$x:00008D2F                 db    0
.xdata$x:00008D30                 db    0
.xdata$x:00008D31                 db    0
.xdata$x:00008D32                 db    0
.xdata$x:00008D33                 db    0
.xdata$x:00008D34                 db    0
.xdata$x:00008D35                 db    0
.xdata$x:00008D36                 db    0
.xdata$x:00008D37                 db    0
.xdata$x:00008D38                 db    0
.xdata$x:00008D39                 db    0
.xdata$x:00008D3A                 db    0
.xdata$x:00008D3B                 db    0
.xdata$x:00008D3C                 db    0
.xdata$x:00008D3D                 db    0
.xdata$x:00008D3E                 db    0
.xdata$x:00008D3F                 db    0
.xdata$x:00008D40                 db    0
.xdata$x:00008D41                 db    0
.xdata$x:00008D42                 db    0
.xdata$x:00008D43                 db    0
.xdata$x:00008D43 _xdata$x        ends
.xdata$x:00008D43
.xdata$x:00008D44 ; ===========================================================================
.xdata$x:00008D44
.xdata$x:00008D44 ; Segment type: Pure data
.xdata$x:00008D44 ; Segment permissions: Read
.xdata$x:00008D44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008D44                 assume cs:_xdata$x
.xdata$x:00008D44                 ;org 8D44h
.xdata$x:00008D44 ; COMDAT (pick associative to section at 3FC8)
.xdata$x:00008D44 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00008D44                                         ; DATA XREF: .xdata$x:00008D54o
.xdata$x:00008D45                 db 0FFh
.xdata$x:00008D46                 db 0FFh
.xdata$x:00008D47                 db 0FFh
.xdata$x:00008D48                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00008D4C __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00008D4C                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00008D4D                 db    5
.xdata$x:00008D4E                 db  93h ; ô
.xdata$x:00008D4F                 db  19h
.xdata$x:00008D50                 db    1
.xdata$x:00008D51                 db    0
.xdata$x:00008D52                 db    0
.xdata$x:00008D53                 db    0
.xdata$x:00008D54                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00008D58                 db    0
.xdata$x:00008D59                 db    0
.xdata$x:00008D5A                 db    0
.xdata$x:00008D5B                 db    0
.xdata$x:00008D5C                 db    0
.xdata$x:00008D5D                 db    0
.xdata$x:00008D5E                 db    0
.xdata$x:00008D5F                 db    0
.xdata$x:00008D60                 db    0
.xdata$x:00008D61                 db    0
.xdata$x:00008D62                 db    0
.xdata$x:00008D63                 db    0
.xdata$x:00008D64                 db    0
.xdata$x:00008D65                 db    0
.xdata$x:00008D66                 db    0
.xdata$x:00008D67                 db    0
.xdata$x:00008D68                 db    0
.xdata$x:00008D69                 db    0
.xdata$x:00008D6A                 db    0
.xdata$x:00008D6B                 db    0
.xdata$x:00008D6C                 db    0
.xdata$x:00008D6D                 db    0
.xdata$x:00008D6E                 db    0
.xdata$x:00008D6F                 db    0
.xdata$x:00008D6F _xdata$x        ends
.xdata$x:00008D6F
.xdata$x:00008D70 ; ===========================================================================
.xdata$x:00008D70
.xdata$x:00008D70 ; Segment type: Pure data
.xdata$x:00008D70 ; Segment permissions: Read
.xdata$x:00008D70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008D70                 assume cs:_xdata$x
.xdata$x:00008D70                 ;org 8D70h
.xdata$x:00008D70 ; COMDAT (pick associative to section at 4F24)
.xdata$x:00008D70 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008D70                                         ; DATA XREF: .xdata$x:00008D80o
.xdata$x:00008D71                 db 0FFh
.xdata$x:00008D72                 db 0FFh
.xdata$x:00008D73                 db 0FFh
.xdata$x:00008D74                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00008D78 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008D78                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00008D79                 db    5
.xdata$x:00008D7A                 db  93h ; ô
.xdata$x:00008D7B                 db  19h
.xdata$x:00008D7C                 db    1
.xdata$x:00008D7D                 db    0
.xdata$x:00008D7E                 db    0
.xdata$x:00008D7F                 db    0
.xdata$x:00008D80                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00008D84                 db    0
.xdata$x:00008D85                 db    0
.xdata$x:00008D86                 db    0
.xdata$x:00008D87                 db    0
.xdata$x:00008D88                 db    0
.xdata$x:00008D89                 db    0
.xdata$x:00008D8A                 db    0
.xdata$x:00008D8B                 db    0
.xdata$x:00008D8C                 db    0
.xdata$x:00008D8D                 db    0
.xdata$x:00008D8E                 db    0
.xdata$x:00008D8F                 db    0
.xdata$x:00008D90                 db    0
.xdata$x:00008D91                 db    0
.xdata$x:00008D92                 db    0
.xdata$x:00008D93                 db    0
.xdata$x:00008D94                 db    0
.xdata$x:00008D95                 db    0
.xdata$x:00008D96                 db    0
.xdata$x:00008D97                 db    0
.xdata$x:00008D98                 db    0
.xdata$x:00008D99                 db    0
.xdata$x:00008D9A                 db    0
.xdata$x:00008D9B                 db    0
.xdata$x:00008D9B _xdata$x        ends
.xdata$x:00008D9B
.xdata$x:00008D9C ; ===========================================================================
.xdata$x:00008D9C
.xdata$x:00008D9C ; Segment type: Pure data
.xdata$x:00008D9C ; Segment permissions: Read
.xdata$x:00008D9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008D9C                 assume cs:_xdata$x
.xdata$x:00008D9C                 ;org 8D9Ch
.xdata$x:00008D9C ; COMDAT (pick associative to section at 4728)
.xdata$x:00008D9C __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00008D9C                                         ; DATA XREF: .xdata$x:00008DACo
.xdata$x:00008D9D                 db 0FFh
.xdata$x:00008D9E                 db 0FFh
.xdata$x:00008D9F                 db 0FFh
.xdata$x:00008DA0                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00008DA4 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00008DA4                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00008DA5                 db    5
.xdata$x:00008DA6                 db  93h ; ô
.xdata$x:00008DA7                 db  19h
.xdata$x:00008DA8                 db    1
.xdata$x:00008DA9                 db    0
.xdata$x:00008DAA                 db    0
.xdata$x:00008DAB                 db    0
.xdata$x:00008DAC                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00008DB0                 db    0
.xdata$x:00008DB1                 db    0
.xdata$x:00008DB2                 db    0
.xdata$x:00008DB3                 db    0
.xdata$x:00008DB4                 db    0
.xdata$x:00008DB5                 db    0
.xdata$x:00008DB6                 db    0
.xdata$x:00008DB7                 db    0
.xdata$x:00008DB8                 db    0
.xdata$x:00008DB9                 db    0
.xdata$x:00008DBA                 db    0
.xdata$x:00008DBB                 db    0
.xdata$x:00008DBC                 db    0
.xdata$x:00008DBD                 db    0
.xdata$x:00008DBE                 db    0
.xdata$x:00008DBF                 db    0
.xdata$x:00008DC0                 db    0
.xdata$x:00008DC1                 db    0
.xdata$x:00008DC2                 db    0
.xdata$x:00008DC3                 db    0
.xdata$x:00008DC4                 db    0
.xdata$x:00008DC5                 db    0
.xdata$x:00008DC6                 db    0
.xdata$x:00008DC7                 db    0
.xdata$x:00008DC7 _xdata$x        ends
.xdata$x:00008DC7
.xdata$x:00008DC8 ; ===========================================================================
.xdata$x:00008DC8
.xdata$x:00008DC8 ; Segment type: Pure data
.xdata$x:00008DC8 ; Segment permissions: Read
.xdata$x:00008DC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008DC8                 assume cs:_xdata$x
.xdata$x:00008DC8                 ;org 8DC8h
.xdata$x:00008DC8 ; COMDAT (pick associative to section at 541C)
.xdata$x:00008DC8 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00008DC8                                         ; DATA XREF: .xdata$x:00008DD8o
.xdata$x:00008DC9                 db 0FFh
.xdata$x:00008DCA                 db 0FFh
.xdata$x:00008DCB                 db 0FFh
.xdata$x:00008DCC                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00008DD0 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00008DD0                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00008DD1                 db    5
.xdata$x:00008DD2                 db  93h ; ô
.xdata$x:00008DD3                 db  19h
.xdata$x:00008DD4                 db    1
.xdata$x:00008DD5                 db    0
.xdata$x:00008DD6                 db    0
.xdata$x:00008DD7                 db    0
.xdata$x:00008DD8                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00008DDC                 db    0
.xdata$x:00008DDD                 db    0
.xdata$x:00008DDE                 db    0
.xdata$x:00008DDF                 db    0
.xdata$x:00008DE0                 db    0
.xdata$x:00008DE1                 db    0
.xdata$x:00008DE2                 db    0
.xdata$x:00008DE3                 db    0
.xdata$x:00008DE4                 db    0
.xdata$x:00008DE5                 db    0
.xdata$x:00008DE6                 db    0
.xdata$x:00008DE7                 db    0
.xdata$x:00008DE8                 db    0
.xdata$x:00008DE9                 db    0
.xdata$x:00008DEA                 db    0
.xdata$x:00008DEB                 db    0
.xdata$x:00008DEC                 db    0
.xdata$x:00008DED                 db    0
.xdata$x:00008DEE                 db    0
.xdata$x:00008DEF                 db    0
.xdata$x:00008DF0                 db    0
.xdata$x:00008DF1                 db    0
.xdata$x:00008DF2                 db    0
.xdata$x:00008DF3                 db    0
.xdata$x:00008DF3 _xdata$x        ends
.xdata$x:00008DF3
.xdata$x:00008DF4 ; ===========================================================================
.xdata$x:00008DF4
.xdata$x:00008DF4 ; Segment type: Pure data
.xdata$x:00008DF4 ; Segment permissions: Read
.xdata$x:00008DF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008DF4                 assume cs:_xdata$x
.xdata$x:00008DF4                 ;org 8DF4h
.xdata$x:00008DF4 ; COMDAT (pick associative to section at 6264)
.xdata$x:00008DF4 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00008DF4                                         ; DATA XREF: .xdata$x:00008E7Co
.xdata$x:00008DF5                 db    0
.xdata$x:00008DF6                 db    0
.xdata$x:00008DF7                 db    0
.xdata$x:00008DF8                 db    0
.xdata$x:00008DF9                 db    0
.xdata$x:00008DFA                 db    0
.xdata$x:00008DFB                 db    0
.xdata$x:00008DFC                 db    0
.xdata$x:00008DFD                 db    0
.xdata$x:00008DFE                 db    0
.xdata$x:00008DFF                 db    0
.xdata$x:00008E00                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00008E04 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00008E04                                         ; DATA XREF: .xdata$x:00008E68o
.xdata$x:00008E05                 db    0
.xdata$x:00008E06                 db    0
.xdata$x:00008E07                 db    0
.xdata$x:00008E08                 db    0
.xdata$x:00008E09                 db    0
.xdata$x:00008E0A                 db    0
.xdata$x:00008E0B                 db    0
.xdata$x:00008E0C                 db    0
.xdata$x:00008E0D                 db    0
.xdata$x:00008E0E                 db    0
.xdata$x:00008E0F                 db    0
.xdata$x:00008E10                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00008E14 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00008E14                                         ; DATA XREF: .xdata$x:00008E3Co
.xdata$x:00008E15                 db 0FFh
.xdata$x:00008E16                 db 0FFh
.xdata$x:00008E17                 db 0FFh
.xdata$x:00008E18                 db    0
.xdata$x:00008E19                 db    0
.xdata$x:00008E1A                 db    0
.xdata$x:00008E1B                 db    0
.xdata$x:00008E1C                 db 0FFh
.xdata$x:00008E1D                 db 0FFh
.xdata$x:00008E1E                 db 0FFh
.xdata$x:00008E1F                 db 0FFh
.xdata$x:00008E20                 db    0
.xdata$x:00008E21                 db    0
.xdata$x:00008E22                 db    0
.xdata$x:00008E23                 db    0
.xdata$x:00008E24                 db    1
.xdata$x:00008E25                 db    0
.xdata$x:00008E26                 db    0
.xdata$x:00008E27                 db    0
.xdata$x:00008E28                 db    0
.xdata$x:00008E29                 db    0
.xdata$x:00008E2A                 db    0
.xdata$x:00008E2B                 db    0
.xdata$x:00008E2C                 db    1
.xdata$x:00008E2D                 db    0
.xdata$x:00008E2E                 db    0
.xdata$x:00008E2F                 db    0
.xdata$x:00008E30                 db    0
.xdata$x:00008E31                 db    0
.xdata$x:00008E32                 db    0
.xdata$x:00008E33                 db    0
.xdata$x:00008E34 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00008E34                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00008E35                 db    5
.xdata$x:00008E36                 db  93h ; ô
.xdata$x:00008E37                 db  19h
.xdata$x:00008E38                 db    4
.xdata$x:00008E39                 db    0
.xdata$x:00008E3A                 db    0
.xdata$x:00008E3B                 db    0
.xdata$x:00008E3C                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00008E40                 db    2
.xdata$x:00008E41                 db    0
.xdata$x:00008E42                 db    0
.xdata$x:00008E43                 db    0
.xdata$x:00008E44                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00008E48                 db    0
.xdata$x:00008E49                 db    0
.xdata$x:00008E4A                 db    0
.xdata$x:00008E4B                 db    0
.xdata$x:00008E4C                 db    0
.xdata$x:00008E4D                 db    0
.xdata$x:00008E4E                 db    0
.xdata$x:00008E4F                 db    0
.xdata$x:00008E50                 db    0
.xdata$x:00008E51                 db    0
.xdata$x:00008E52                 db    0
.xdata$x:00008E53                 db    0
.xdata$x:00008E54                 db    0
.xdata$x:00008E55                 db    0
.xdata$x:00008E56                 db    0
.xdata$x:00008E57                 db    0
.xdata$x:00008E58 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00008E58                                         ; DATA XREF: .xdata$x:00008E44o
.xdata$x:00008E59                 db    0
.xdata$x:00008E5A                 db    0
.xdata$x:00008E5B                 db    0
.xdata$x:00008E5C                 db    2
.xdata$x:00008E5D                 db    0
.xdata$x:00008E5E                 db    0
.xdata$x:00008E5F                 db    0
.xdata$x:00008E60                 db    3
.xdata$x:00008E61                 db    0
.xdata$x:00008E62                 db    0
.xdata$x:00008E63                 db    0
.xdata$x:00008E64                 db    1
.xdata$x:00008E65                 db    0
.xdata$x:00008E66                 db    0
.xdata$x:00008E67                 db    0
.xdata$x:00008E68                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00008E6C                 db    0
.xdata$x:00008E6D                 db    0
.xdata$x:00008E6E                 db    0
.xdata$x:00008E6F                 db    0
.xdata$x:00008E70                 db    0
.xdata$x:00008E71                 db    0
.xdata$x:00008E72                 db    0
.xdata$x:00008E73                 db    0
.xdata$x:00008E74                 db    3
.xdata$x:00008E75                 db    0
.xdata$x:00008E76                 db    0
.xdata$x:00008E77                 db    0
.xdata$x:00008E78                 db    1
.xdata$x:00008E79                 db    0
.xdata$x:00008E7A                 db    0
.xdata$x:00008E7B                 db    0
.xdata$x:00008E7C                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00008E7C _xdata$x        ends
.xdata$x:00008E7C
.xdata$x:00008E80 ; ===========================================================================
.xdata$x:00008E80
.xdata$x:00008E80 ; Segment type: Pure data
.xdata$x:00008E80 ; Segment permissions: Read
.xdata$x:00008E80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008E80                 assume cs:_xdata$x
.xdata$x:00008E80                 ;org 8E80h
.xdata$x:00008E80 ; COMDAT (pick associative to section at 4E30)
.xdata$x:00008E80 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00008E80                                         ; DATA XREF: .xdata$x:00008E90o
.xdata$x:00008E81                 db 0FFh
.xdata$x:00008E82                 db 0FFh
.xdata$x:00008E83                 db 0FFh
.xdata$x:00008E84                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:00008E88 __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00008E88                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:00008E89                 db    5
.xdata$x:00008E8A                 db  93h ; ô
.xdata$x:00008E8B                 db  19h
.xdata$x:00008E8C                 db    1
.xdata$x:00008E8D                 db    0
.xdata$x:00008E8E                 db    0
.xdata$x:00008E8F                 db    0
.xdata$x:00008E90                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00008E94                 db    0
.xdata$x:00008E95                 db    0
.xdata$x:00008E96                 db    0
.xdata$x:00008E97                 db    0
.xdata$x:00008E98                 db    0
.xdata$x:00008E99                 db    0
.xdata$x:00008E9A                 db    0
.xdata$x:00008E9B                 db    0
.xdata$x:00008E9C                 db    0
.xdata$x:00008E9D                 db    0
.xdata$x:00008E9E                 db    0
.xdata$x:00008E9F                 db    0
.xdata$x:00008EA0                 db    0
.xdata$x:00008EA1                 db    0
.xdata$x:00008EA2                 db    0
.xdata$x:00008EA3                 db    0
.xdata$x:00008EA4                 db    0
.xdata$x:00008EA5                 db    0
.xdata$x:00008EA6                 db    0
.xdata$x:00008EA7                 db    0
.xdata$x:00008EA8                 db    0
.xdata$x:00008EA9                 db    0
.xdata$x:00008EAA                 db    0
.xdata$x:00008EAB                 db    0
.xdata$x:00008EAB _xdata$x        ends
.xdata$x:00008EAB
.xdata$x:00008EAC ; ===========================================================================
.xdata$x:00008EAC
.xdata$x:00008EAC ; Segment type: Pure data
.xdata$x:00008EAC ; Segment permissions: Read
.xdata$x:00008EAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008EAC                 assume cs:_xdata$x
.xdata$x:00008EAC                 ;org 8EACh
.xdata$x:00008EAC ; COMDAT (pick associative to section at 5900)
.xdata$x:00008EAC __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:00008EAC                                         ; DATA XREF: .xdata$x:00008EBCo
.xdata$x:00008EAD                 db 0FFh
.xdata$x:00008EAE                 db 0FFh
.xdata$x:00008EAF                 db 0FFh
.xdata$x:00008EB0                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00008EB4 __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00008EB4                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00008EB5                 db    5
.xdata$x:00008EB6                 db  93h ; ô
.xdata$x:00008EB7                 db  19h
.xdata$x:00008EB8                 db    1
.xdata$x:00008EB9                 db    0
.xdata$x:00008EBA                 db    0
.xdata$x:00008EBB                 db    0
.xdata$x:00008EBC                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:00008EC0                 db    0
.xdata$x:00008EC1                 db    0
.xdata$x:00008EC2                 db    0
.xdata$x:00008EC3                 db    0
.xdata$x:00008EC4                 db    0
.xdata$x:00008EC5                 db    0
.xdata$x:00008EC6                 db    0
.xdata$x:00008EC7                 db    0
.xdata$x:00008EC8                 db    0
.xdata$x:00008EC9                 db    0
.xdata$x:00008ECA                 db    0
.xdata$x:00008ECB                 db    0
.xdata$x:00008ECC                 db    0
.xdata$x:00008ECD                 db    0
.xdata$x:00008ECE                 db    0
.xdata$x:00008ECF                 db    0
.xdata$x:00008ED0                 db    0
.xdata$x:00008ED1                 db    0
.xdata$x:00008ED2                 db    0
.xdata$x:00008ED3                 db    0
.xdata$x:00008ED4                 db    0
.xdata$x:00008ED5                 db    0
.xdata$x:00008ED6                 db    0
.xdata$x:00008ED7                 db    0
.xdata$x:00008ED7 _xdata$x        ends
.xdata$x:00008ED7
.xdata$x:00008ED8 ; ===========================================================================
.xdata$x:00008ED8
.xdata$x:00008ED8 ; Segment type: Pure data
.xdata$x:00008ED8 ; Segment permissions: Read
.xdata$x:00008ED8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008ED8                 assume cs:_xdata$x
.xdata$x:00008ED8                 ;org 8ED8h
.xdata$x:00008ED8 ; COMDAT (pick associative to section at 4DAC)
.xdata$x:00008ED8 __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00008ED8                                         ; DATA XREF: .xdata$x:00008EE8o
.xdata$x:00008ED9                 db 0FFh
.xdata$x:00008EDA                 db 0FFh
.xdata$x:00008EDB                 db 0FFh
.xdata$x:00008EDC                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:00008EE0 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00008EE0                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:00008EE1                 db    5
.xdata$x:00008EE2                 db  93h ; ô
.xdata$x:00008EE3                 db  19h
.xdata$x:00008EE4                 db    1
.xdata$x:00008EE5                 db    0
.xdata$x:00008EE6                 db    0
.xdata$x:00008EE7                 db    0
.xdata$x:00008EE8                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:00008EEC                 db    0
.xdata$x:00008EED                 db    0
.xdata$x:00008EEE                 db    0
.xdata$x:00008EEF                 db    0
.xdata$x:00008EF0                 db    0
.xdata$x:00008EF1                 db    0
.xdata$x:00008EF2                 db    0
.xdata$x:00008EF3                 db    0
.xdata$x:00008EF4                 db    0
.xdata$x:00008EF5                 db    0
.xdata$x:00008EF6                 db    0
.xdata$x:00008EF7                 db    0
.xdata$x:00008EF8                 db    0
.xdata$x:00008EF9                 db    0
.xdata$x:00008EFA                 db    0
.xdata$x:00008EFB                 db    0
.xdata$x:00008EFC                 db    0
.xdata$x:00008EFD                 db    0
.xdata$x:00008EFE                 db    0
.xdata$x:00008EFF                 db    0
.xdata$x:00008F00                 db    0
.xdata$x:00008F01                 db    0
.xdata$x:00008F02                 db    0
.xdata$x:00008F03                 db    0
.xdata$x:00008F03 _xdata$x        ends
.xdata$x:00008F03
.xdata$x:00008F04 ; ===========================================================================
.xdata$x:00008F04
.xdata$x:00008F04 ; Segment type: Pure data
.xdata$x:00008F04 ; Segment permissions: Read
.xdata$x:00008F04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F04                 assume cs:_xdata$x
.xdata$x:00008F04                 ;org 8F04h
.xdata$x:00008F04 ; COMDAT (pick associative to section at 4B90)
.xdata$x:00008F04 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00008F04                                         ; DATA XREF: .xdata$x:00008F14o
.xdata$x:00008F05                 db 0FFh
.xdata$x:00008F06                 db 0FFh
.xdata$x:00008F07                 db 0FFh
.xdata$x:00008F08                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00008F0C __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00008F0C                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00008F0D                 db    5
.xdata$x:00008F0E                 db  93h ; ô
.xdata$x:00008F0F                 db  19h
.xdata$x:00008F10                 db    1
.xdata$x:00008F11                 db    0
.xdata$x:00008F12                 db    0
.xdata$x:00008F13                 db    0
.xdata$x:00008F14                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00008F18                 db    0
.xdata$x:00008F19                 db    0
.xdata$x:00008F1A                 db    0
.xdata$x:00008F1B                 db    0
.xdata$x:00008F1C                 db    0
.xdata$x:00008F1D                 db    0
.xdata$x:00008F1E                 db    0
.xdata$x:00008F1F                 db    0
.xdata$x:00008F20                 db    0
.xdata$x:00008F21                 db    0
.xdata$x:00008F22                 db    0
.xdata$x:00008F23                 db    0
.xdata$x:00008F24                 db    0
.xdata$x:00008F25                 db    0
.xdata$x:00008F26                 db    0
.xdata$x:00008F27                 db    0
.xdata$x:00008F28                 db    0
.xdata$x:00008F29                 db    0
.xdata$x:00008F2A                 db    0
.xdata$x:00008F2B                 db    0
.xdata$x:00008F2C                 db    0
.xdata$x:00008F2D                 db    0
.xdata$x:00008F2E                 db    0
.xdata$x:00008F2F                 db    0
.xdata$x:00008F2F _xdata$x        ends
.xdata$x:00008F2F
.xdata$x:00008F30 ; ===========================================================================
.xdata$x:00008F30
.xdata$x:00008F30 ; Segment type: Pure data
.xdata$x:00008F30 ; Segment permissions: Read
.xdata$x:00008F30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F30                 assume cs:_xdata$x
.xdata$x:00008F30                 ;org 8F30h
.xdata$x:00008F30 ; COMDAT (pick associative to section at 83A8)
.xdata$x:00008F30 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00008F30                                         ; DATA XREF: .xdata$x:00008F40o
.xdata$x:00008F31                 db 0FFh
.xdata$x:00008F32                 db 0FFh
.xdata$x:00008F33                 db 0FFh
.xdata$x:00008F34                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00008F38 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00008F38                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00008F39                 db    5
.xdata$x:00008F3A                 db  93h ; ô
.xdata$x:00008F3B                 db  19h
.xdata$x:00008F3C                 db    1
.xdata$x:00008F3D                 db    0
.xdata$x:00008F3E                 db    0
.xdata$x:00008F3F                 db    0
.xdata$x:00008F40                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00008F44                 db    0
.xdata$x:00008F45                 db    0
.xdata$x:00008F46                 db    0
.xdata$x:00008F47                 db    0
.xdata$x:00008F48                 db    0
.xdata$x:00008F49                 db    0
.xdata$x:00008F4A                 db    0
.xdata$x:00008F4B                 db    0
.xdata$x:00008F4C                 db    0
.xdata$x:00008F4D                 db    0
.xdata$x:00008F4E                 db    0
.xdata$x:00008F4F                 db    0
.xdata$x:00008F50                 db    0
.xdata$x:00008F51                 db    0
.xdata$x:00008F52                 db    0
.xdata$x:00008F53                 db    0
.xdata$x:00008F54                 db    0
.xdata$x:00008F55                 db    0
.xdata$x:00008F56                 db    0
.xdata$x:00008F57                 db    0
.xdata$x:00008F58                 db    0
.xdata$x:00008F59                 db    0
.xdata$x:00008F5A                 db    0
.xdata$x:00008F5B                 db    0
.xdata$x:00008F5B _xdata$x        ends
.xdata$x:00008F5B
.xdata$x:00008F5C ; ===========================================================================
.xdata$x:00008F5C
.xdata$x:00008F5C ; Segment type: Pure data
.xdata$x:00008F5C ; Segment permissions: Read
.xdata$x:00008F5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F5C                 assume cs:_xdata$x
.xdata$x:00008F5C                 ;org 8F5Ch
.xdata$x:00008F5C ; COMDAT (pick associative to section at 5718)
.xdata$x:00008F5C __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00008F5C                                         ; DATA XREF: .xdata$x:00008F6Co
.xdata$x:00008F5D                 db 0FFh
.xdata$x:00008F5E                 db 0FFh
.xdata$x:00008F5F                 db 0FFh
.xdata$x:00008F60                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00008F64 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00008F64                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00008F65                 db    5
.xdata$x:00008F66                 db  93h ; ô
.xdata$x:00008F67                 db  19h
.xdata$x:00008F68                 db    1
.xdata$x:00008F69                 db    0
.xdata$x:00008F6A                 db    0
.xdata$x:00008F6B                 db    0
.xdata$x:00008F6C                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00008F70                 db    0
.xdata$x:00008F71                 db    0
.xdata$x:00008F72                 db    0
.xdata$x:00008F73                 db    0
.xdata$x:00008F74                 db    0
.xdata$x:00008F75                 db    0
.xdata$x:00008F76                 db    0
.xdata$x:00008F77                 db    0
.xdata$x:00008F78                 db    0
.xdata$x:00008F79                 db    0
.xdata$x:00008F7A                 db    0
.xdata$x:00008F7B                 db    0
.xdata$x:00008F7C                 db    0
.xdata$x:00008F7D                 db    0
.xdata$x:00008F7E                 db    0
.xdata$x:00008F7F                 db    0
.xdata$x:00008F80                 db    0
.xdata$x:00008F81                 db    0
.xdata$x:00008F82                 db    0
.xdata$x:00008F83                 db    0
.xdata$x:00008F84                 db    0
.xdata$x:00008F85                 db    0
.xdata$x:00008F86                 db    0
.xdata$x:00008F87                 db    0
.xdata$x:00008F87 _xdata$x        ends
.xdata$x:00008F87
.xdata$x:00008F88 ; ===========================================================================
.xdata$x:00008F88
.xdata$x:00008F88 ; Segment type: Pure data
.xdata$x:00008F88 ; Segment permissions: Read
.xdata$x:00008F88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F88                 assume cs:_xdata$x
.xdata$x:00008F88                 ;org 8F88h
.xdata$x:00008F88 ; COMDAT (pick associative to section at 4C0C)
.xdata$x:00008F88 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00008F88                                         ; DATA XREF: .xdata$x:00008F98o
.xdata$x:00008F89                 db 0FFh
.xdata$x:00008F8A                 db 0FFh
.xdata$x:00008F8B                 db 0FFh
.xdata$x:00008F8C                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00008F90 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00008F90                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00008F91                 db    5
.xdata$x:00008F92                 db  93h ; ô
.xdata$x:00008F93                 db  19h
.xdata$x:00008F94                 db    1
.xdata$x:00008F95                 db    0
.xdata$x:00008F96                 db    0
.xdata$x:00008F97                 db    0
.xdata$x:00008F98                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00008F9C                 db    0
.xdata$x:00008F9D                 db    0
.xdata$x:00008F9E                 db    0
.xdata$x:00008F9F                 db    0
.xdata$x:00008FA0                 db    0
.xdata$x:00008FA1                 db    0
.xdata$x:00008FA2                 db    0
.xdata$x:00008FA3                 db    0
.xdata$x:00008FA4                 db    0
.xdata$x:00008FA5                 db    0
.xdata$x:00008FA6                 db    0
.xdata$x:00008FA7                 db    0
.xdata$x:00008FA8                 db    0
.xdata$x:00008FA9                 db    0
.xdata$x:00008FAA                 db    0
.xdata$x:00008FAB                 db    0
.xdata$x:00008FAC                 db    0
.xdata$x:00008FAD                 db    0
.xdata$x:00008FAE                 db    0
.xdata$x:00008FAF                 db    0
.xdata$x:00008FB0                 db    0
.xdata$x:00008FB1                 db    0
.xdata$x:00008FB2                 db    0
.xdata$x:00008FB3                 db    0
.xdata$x:00008FB3 _xdata$x        ends
.xdata$x:00008FB3
.xdata$x:00008FB4 ; ===========================================================================
.xdata$x:00008FB4
.xdata$x:00008FB4 ; Segment type: Pure data
.xdata$x:00008FB4 ; Segment permissions: Read
.xdata$x:00008FB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008FB4                 assume cs:_xdata$x
.xdata$x:00008FB4                 ;org 8FB4h
.xdata$x:00008FB4 ; COMDAT (pick associative to section at 8460)
.xdata$x:00008FB4 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00008FB4                                         ; DATA XREF: .xdata$x:00008FC4o
.xdata$x:00008FB5                 db 0FFh
.xdata$x:00008FB6                 db 0FFh
.xdata$x:00008FB7                 db 0FFh
.xdata$x:00008FB8                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00008FBC __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00008FBC                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00008FBD                 db    5
.xdata$x:00008FBE                 db  93h ; ô
.xdata$x:00008FBF                 db  19h
.xdata$x:00008FC0                 db    1
.xdata$x:00008FC1                 db    0
.xdata$x:00008FC2                 db    0
.xdata$x:00008FC3                 db    0
.xdata$x:00008FC4                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00008FC8                 align 20h
.xdata$x:00008FC8 _xdata$x        ends
.xdata$x:00008FC8
.xdata$x:00008FE0 ; ===========================================================================
.xdata$x:00008FE0
.xdata$x:00008FE0 ; Segment type: Pure data
.xdata$x:00008FE0 ; Segment permissions: Read
.xdata$x:00008FE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008FE0                 assume cs:_xdata$x
.xdata$x:00008FE0                 ;org 8FE0h
.xdata$x:00008FE0 ; COMDAT (pick associative to section at 5788)
.xdata$x:00008FE0 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00008FE0                                         ; DATA XREF: .xdata$x:00008FF0o
.xdata$x:00008FE1                 db 0FFh
.xdata$x:00008FE2                 db 0FFh
.xdata$x:00008FE3                 db 0FFh
.xdata$x:00008FE4                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00008FE8 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00008FE8                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00008FE9                 db    5
.xdata$x:00008FEA                 db  93h ; ô
.xdata$x:00008FEB                 db  19h
.xdata$x:00008FEC                 db    1
.xdata$x:00008FED                 db    0
.xdata$x:00008FEE                 db    0
.xdata$x:00008FEF                 db    0
.xdata$x:00008FF0                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00008FF4                 db    0
.xdata$x:00008FF5                 db    0
.xdata$x:00008FF6                 db    0
.xdata$x:00008FF7                 db    0
.xdata$x:00008FF8                 db    0
.xdata$x:00008FF9                 db    0
.xdata$x:00008FFA                 db    0
.xdata$x:00008FFB                 db    0
.xdata$x:00008FFC                 db    0
.xdata$x:00008FFD                 db    0
.xdata$x:00008FFE                 db    0
.xdata$x:00008FFF                 db    0
.xdata$x:00009000                 db    0
.xdata$x:00009001                 db    0
.xdata$x:00009002                 db    0
.xdata$x:00009003                 db    0
.xdata$x:00009004                 db    0
.xdata$x:00009005                 db    0
.xdata$x:00009006                 db    0
.xdata$x:00009007                 db    0
.xdata$x:00009008                 db    0
.xdata$x:00009009                 db    0
.xdata$x:0000900A                 db    0
.xdata$x:0000900B                 db    0
.xdata$x:0000900B _xdata$x        ends
.xdata$x:0000900B
.xdata$x:0000900C ; ===========================================================================
.xdata$x:0000900C
.xdata$x:0000900C ; Segment type: Pure data
.xdata$x:0000900C ; Segment permissions: Read
.xdata$x:0000900C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000900C                 assume cs:_xdata$x
.xdata$x:0000900C                 ;org 900Ch
.xdata$x:0000900C ; COMDAT (pick associative to section at 4CDC)
.xdata$x:0000900C __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000900C                                         ; DATA XREF: .xdata$x:0000901Co
.xdata$x:0000900D                 db 0FFh
.xdata$x:0000900E                 db 0FFh
.xdata$x:0000900F                 db 0FFh
.xdata$x:00009010                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00009014 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00009014                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00009015                 db    5
.xdata$x:00009016                 db  93h ; ô
.xdata$x:00009017                 db  19h
.xdata$x:00009018                 db    1
.xdata$x:00009019                 db    0
.xdata$x:0000901A                 db    0
.xdata$x:0000901B                 db    0
.xdata$x:0000901C                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00009020                 db    0
.xdata$x:00009021                 db    0
.xdata$x:00009022                 db    0
.xdata$x:00009023                 db    0
.xdata$x:00009024                 db    0
.xdata$x:00009025                 db    0
.xdata$x:00009026                 db    0
.xdata$x:00009027                 db    0
.xdata$x:00009028                 db    0
.xdata$x:00009029                 db    0
.xdata$x:0000902A                 db    0
.xdata$x:0000902B                 db    0
.xdata$x:0000902C                 db    0
.xdata$x:0000902D                 db    0
.xdata$x:0000902E                 db    0
.xdata$x:0000902F                 db    0
.xdata$x:00009030                 db    0
.xdata$x:00009031                 db    0
.xdata$x:00009032                 db    0
.xdata$x:00009033                 db    0
.xdata$x:00009034                 db    0
.xdata$x:00009035                 db    0
.xdata$x:00009036                 db    0
.xdata$x:00009037                 db    0
.xdata$x:00009037 _xdata$x        ends
.xdata$x:00009037
.xdata$x:00009038 ; ===========================================================================
.xdata$x:00009038
.xdata$x:00009038 ; Segment type: Pure data
.xdata$x:00009038 ; Segment permissions: Read
.xdata$x:00009038 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009038                 assume cs:_xdata$x
.xdata$x:00009038                 ;org 9038h
.xdata$x:00009038 ; COMDAT (pick associative to section at 8524)
.xdata$x:00009038 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00009038                                         ; DATA XREF: .xdata$x:00009048o
.xdata$x:00009039                 db 0FFh
.xdata$x:0000903A                 db 0FFh
.xdata$x:0000903B                 db 0FFh
.xdata$x:0000903C                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00009040 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00009040                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00009041                 db    5
.xdata$x:00009042                 db  93h ; ô
.xdata$x:00009043                 db  19h
.xdata$x:00009044                 db    1
.xdata$x:00009045                 db    0
.xdata$x:00009046                 db    0
.xdata$x:00009047                 db    0
.xdata$x:00009048                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000904C                 db    0
.xdata$x:0000904D                 db    0
.xdata$x:0000904E                 db    0
.xdata$x:0000904F                 db    0
.xdata$x:00009050                 db    0
.xdata$x:00009051                 db    0
.xdata$x:00009052                 db    0
.xdata$x:00009053                 db    0
.xdata$x:00009054                 db    0
.xdata$x:00009055                 db    0
.xdata$x:00009056                 db    0
.xdata$x:00009057                 db    0
.xdata$x:00009058                 db    0
.xdata$x:00009059                 db    0
.xdata$x:0000905A                 db    0
.xdata$x:0000905B                 db    0
.xdata$x:0000905C                 db    0
.xdata$x:0000905D                 db    0
.xdata$x:0000905E                 db    0
.xdata$x:0000905F                 db    0
.xdata$x:00009060                 db    0
.xdata$x:00009061                 db    0
.xdata$x:00009062                 db    0
.xdata$x:00009063                 db    0
.xdata$x:00009063 _xdata$x        ends
.xdata$x:00009063
.xdata$x:00009064 ; ===========================================================================
.xdata$x:00009064
.xdata$x:00009064 ; Segment type: Pure data
.xdata$x:00009064 ; Segment permissions: Read
.xdata$x:00009064 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009064                 assume cs:_xdata$x
.xdata$x:00009064                 ;org 9064h
.xdata$x:00009064 ; COMDAT (pick associative to section at 587C)
.xdata$x:00009064 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00009064                                         ; DATA XREF: .xdata$x:00009074o
.xdata$x:00009065                 db 0FFh
.xdata$x:00009066                 db 0FFh
.xdata$x:00009067                 db 0FFh
.xdata$x:00009068                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:0000906C __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000906C                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:0000906D                 db    5
.xdata$x:0000906E                 db  93h ; ô
.xdata$x:0000906F                 db  19h
.xdata$x:00009070                 db    1
.xdata$x:00009071                 db    0
.xdata$x:00009072                 db    0
.xdata$x:00009073                 db    0
.xdata$x:00009074                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00009078                 db    0
.xdata$x:00009079                 db    0
.xdata$x:0000907A                 db    0
.xdata$x:0000907B                 db    0
.xdata$x:0000907C                 db    0
.xdata$x:0000907D                 db    0
.xdata$x:0000907E                 db    0
.xdata$x:0000907F                 db    0
.xdata$x:00009080                 db    0
.xdata$x:00009081                 db    0
.xdata$x:00009082                 db    0
.xdata$x:00009083                 db    0
.xdata$x:00009084                 db    0
.xdata$x:00009085                 db    0
.xdata$x:00009086                 db    0
.xdata$x:00009087                 db    0
.xdata$x:00009088                 db    0
.xdata$x:00009089                 db    0
.xdata$x:0000908A                 db    0
.xdata$x:0000908B                 db    0
.xdata$x:0000908C                 db    0
.xdata$x:0000908D                 db    0
.xdata$x:0000908E                 db    0
.xdata$x:0000908F                 db    0
.xdata$x:0000908F _xdata$x        ends
.xdata$x:0000908F
.xdata$x:00009090 ; ===========================================================================
.xdata$x:00009090
.xdata$x:00009090 ; Segment type: Pure data
.xdata$x:00009090 ; Segment permissions: Read
.xdata$x:00009090 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009090                 assume cs:_xdata$x
.xdata$x:00009090                 ;org 9090h
.xdata$x:00009090 ; COMDAT (pick associative to section at 7FC0)
.xdata$x:00009090 __unwindtable$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ db 0FFh
.xdata$x:00009090                                         ; DATA XREF: .xdata$x:000090A0o
.xdata$x:00009091                 db 0FFh
.xdata$x:00009092                 db 0FFh
.xdata$x:00009093                 db 0FFh
.xdata$x:00009094                 dd offset __unwindfunclet$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ$0
.xdata$x:00009098 __ehfuncinfo$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ db  22h ; "
.xdata$x:00009098                                         ; DATA XREF: __ehhandler$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ+11o
.xdata$x:00009099                 db    5
.xdata$x:0000909A                 db  93h ; ô
.xdata$x:0000909B                 db  19h
.xdata$x:0000909C                 db    1
.xdata$x:0000909D                 db    0
.xdata$x:0000909E                 db    0
.xdata$x:0000909F                 db    0
.xdata$x:000090A0                 dd offset __unwindtable$?getDataOfAllTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ
.xdata$x:000090A4                 db    0
.xdata$x:000090A5                 db    0
.xdata$x:000090A6                 db    0
.xdata$x:000090A7                 db    0
.xdata$x:000090A8                 db    0
.xdata$x:000090A9                 db    0
.xdata$x:000090AA                 db    0
.xdata$x:000090AB                 db    0
.xdata$x:000090AC                 db    0
.xdata$x:000090AD                 db    0
.xdata$x:000090AE                 db    0
.xdata$x:000090AF                 db    0
.xdata$x:000090B0                 db    0
.xdata$x:000090B1                 db    0
.xdata$x:000090B2                 db    0
.xdata$x:000090B3                 db    0
.xdata$x:000090B4                 db    0
.xdata$x:000090B5                 db    0
.xdata$x:000090B6                 db    0
.xdata$x:000090B7                 db    0
.xdata$x:000090B8                 db    0
.xdata$x:000090B9                 db    0
.xdata$x:000090BA                 db    0
.xdata$x:000090BB                 db    0
.xdata$x:000090BB _xdata$x        ends
.xdata$x:000090BB
.xdata$x:000090BC ; ===========================================================================
.xdata$x:000090BC
.xdata$x:000090BC ; Segment type: Pure data
.xdata$x:000090BC ; Segment permissions: Read
.xdata$x:000090BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000090BC                 assume cs:_xdata$x
.xdata$x:000090BC                 ;org 90BCh
.xdata$x:000090BC ; COMDAT (pick associative to section at 445C)
.xdata$x:000090BC __unwindtable$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000090BC                                         ; DATA XREF: .xdata$x:000090CCo
.xdata$x:000090BD                 db 0FFh
.xdata$x:000090BE                 db 0FFh
.xdata$x:000090BF                 db 0FFh
.xdata$x:000090C0                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ$0
.xdata$x:000090C4 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000090C4                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ+11o
.xdata$x:000090C5                 db    5
.xdata$x:000090C6                 db  93h ; ô
.xdata$x:000090C7                 db  19h
.xdata$x:000090C8                 db    1
.xdata$x:000090C9                 db    0
.xdata$x:000090CA                 db    0
.xdata$x:000090CB                 db    0
.xdata$x:000090CC                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ
.xdata$x:000090D0                 db    0
.xdata$x:000090D1                 db    0
.xdata$x:000090D2                 db    0
.xdata$x:000090D3                 db    0
.xdata$x:000090D4                 db    0
.xdata$x:000090D5                 db    0
.xdata$x:000090D6                 db    0
.xdata$x:000090D7                 db    0
.xdata$x:000090D8                 db    0
.xdata$x:000090D9                 db    0
.xdata$x:000090DA                 db    0
.xdata$x:000090DB                 db    0
.xdata$x:000090DC                 db    0
.xdata$x:000090DD                 db    0
.xdata$x:000090DE                 db    0
.xdata$x:000090DF                 db    0
.xdata$x:000090E0                 db    0
.xdata$x:000090E1                 db    0
.xdata$x:000090E2                 db    0
.xdata$x:000090E3                 db    0
.xdata$x:000090E4                 db    0
.xdata$x:000090E5                 db    0
.xdata$x:000090E6                 db    0
.xdata$x:000090E7                 db    0
.xdata$x:000090E7 _xdata$x        ends
.xdata$x:000090E7
.xdata$x:000090E8 ; ===========================================================================
.xdata$x:000090E8
.xdata$x:000090E8 ; Segment type: Pure data
.xdata$x:000090E8 ; Segment permissions: Read
.xdata$x:000090E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000090E8                 assume cs:_xdata$x
.xdata$x:000090E8                 ;org 90E8h
.xdata$x:000090E8 ; COMDAT (pick associative to section at 52CC)
.xdata$x:000090E8 __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000090E8                                         ; DATA XREF: .xdata$x:000090F8o
.xdata$x:000090E9                 db 0FFh
.xdata$x:000090EA                 db 0FFh
.xdata$x:000090EB                 db 0FFh
.xdata$x:000090EC                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ$0
.xdata$x:000090F0 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000090F0                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ+11o
.xdata$x:000090F1                 db    5
.xdata$x:000090F2                 db  93h ; ô
.xdata$x:000090F3                 db  19h
.xdata$x:000090F4                 db    1
.xdata$x:000090F5                 db    0
.xdata$x:000090F6                 db    0
.xdata$x:000090F7                 db    0
.xdata$x:000090F8                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@QAE@XZ
.xdata$x:000090FC                 db    0
.xdata$x:000090FD                 db    0
.xdata$x:000090FE                 db    0
.xdata$x:000090FF                 db    0
.xdata$x:00009100                 db    0
.xdata$x:00009101                 db    0
.xdata$x:00009102                 db    0
.xdata$x:00009103                 db    0
.xdata$x:00009104                 db    0
.xdata$x:00009105                 db    0
.xdata$x:00009106                 db    0
.xdata$x:00009107                 db    0
.xdata$x:00009108                 db    0
.xdata$x:00009109                 db    0
.xdata$x:0000910A                 db    0
.xdata$x:0000910B                 db    0
.xdata$x:0000910C                 db    0
.xdata$x:0000910D                 db    0
.xdata$x:0000910E                 db    0
.xdata$x:0000910F                 db    0
.xdata$x:00009110                 db    0
.xdata$x:00009111                 db    0
.xdata$x:00009112                 db    0
.xdata$x:00009113                 db    0
.xdata$x:00009113 _xdata$x        ends
.xdata$x:00009113
.xdata$x:00009114 ; ===========================================================================
.xdata$x:00009114
.xdata$x:00009114 ; Segment type: Pure data
.xdata$x:00009114 ; Segment permissions: Read
.xdata$x:00009114 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009114                 assume cs:_xdata$x
.xdata$x:00009114                 ;org 9114h
.xdata$x:00009114 ; COMDAT (pick associative to section at 4148)
.xdata$x:00009114 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z db 0FFh
.xdata$x:00009114                                         ; DATA XREF: .xdata$x:00009124o
.xdata$x:00009115                 db 0FFh
.xdata$x:00009116                 db 0FFh
.xdata$x:00009117                 db 0FFh
.xdata$x:00009118                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z$0
.xdata$x:0000911C __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z db  22h ; "
.xdata$x:0000911C                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z+11o
.xdata$x:0000911D                 db    5
.xdata$x:0000911E                 db  93h ; ô
.xdata$x:0000911F                 db  19h
.xdata$x:00009120                 db    1
.xdata$x:00009121                 db    0
.xdata$x:00009122                 db    0
.xdata$x:00009123                 db    0
.xdata$x:00009124                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUtTbData@@@1@@Z
.xdata$x:00009128                 align 20h
.xdata$x:00009128 _xdata$x        ends
.xdata$x:00009128
.xdata$x:00009140 ; ===========================================================================
.xdata$x:00009140
.xdata$x:00009140 ; Segment type: Pure data
.xdata$x:00009140 ; Segment permissions: Read
.xdata$x:00009140 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009140                 assume cs:_xdata$x
.xdata$x:00009140                 ;org 9140h
.xdata$x:00009140 ; COMDAT (pick associative to section at 5084)
.xdata$x:00009140 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009140                                         ; DATA XREF: .xdata$x:00009150o
.xdata$x:00009141                 db 0FFh
.xdata$x:00009142                 db 0FFh
.xdata$x:00009143                 db 0FFh
.xdata$x:00009144                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009148 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009148                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009149                 db    5
.xdata$x:0000914A                 db  93h ; ô
.xdata$x:0000914B                 db  19h
.xdata$x:0000914C                 db    1
.xdata$x:0000914D                 db    0
.xdata$x:0000914E                 db    0
.xdata$x:0000914F                 db    0
.xdata$x:00009150                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00009154                 db    0
.xdata$x:00009155                 db    0
.xdata$x:00009156                 db    0
.xdata$x:00009157                 db    0
.xdata$x:00009158                 db    0
.xdata$x:00009159                 db    0
.xdata$x:0000915A                 db    0
.xdata$x:0000915B                 db    0
.xdata$x:0000915C                 db    0
.xdata$x:0000915D                 db    0
.xdata$x:0000915E                 db    0
.xdata$x:0000915F                 db    0
.xdata$x:00009160                 db    0
.xdata$x:00009161                 db    0
.xdata$x:00009162                 db    0
.xdata$x:00009163                 db    0
.xdata$x:00009164                 db    0
.xdata$x:00009165                 db    0
.xdata$x:00009166                 db    0
.xdata$x:00009167                 db    0
.xdata$x:00009168                 db    0
.xdata$x:00009169                 db    0
.xdata$x:0000916A                 db    0
.xdata$x:0000916B                 db    0
.xdata$x:0000916B _xdata$x        ends
.xdata$x:0000916B
.xdata$x:0000916C ; ===========================================================================
.xdata$x:0000916C
.xdata$x:0000916C ; Segment type: Pure data
.xdata$x:0000916C ; Segment permissions: Read
.xdata$x:0000916C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000916C                 assume cs:_xdata$x
.xdata$x:0000916C                 ;org 916Ch
.xdata$x:0000916C ; COMDAT (pick associative to section at 4840)
.xdata$x:0000916C __catchsym$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$5 db    0
.xdata$x:0000916C                                         ; DATA XREF: .xdata$x:0000918Co
.xdata$x:0000916D                 db    0
.xdata$x:0000916E                 db    0
.xdata$x:0000916F                 db    0
.xdata$x:00009170                 db    0
.xdata$x:00009171                 db    0
.xdata$x:00009172                 db    0
.xdata$x:00009173                 db    0
.xdata$x:00009174                 db    0
.xdata$x:00009175                 db    0
.xdata$x:00009176                 db    0
.xdata$x:00009177                 db    0
.xdata$x:00009178                 dd offset __catch$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000917C __tryblocktable$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z db    1
.xdata$x:0000917C                                         ; DATA XREF: .xdata$x:000091A0o
.xdata$x:0000917D                 db    0
.xdata$x:0000917E                 db    0
.xdata$x:0000917F                 db    0
.xdata$x:00009180                 db    3
.xdata$x:00009181                 db    0
.xdata$x:00009182                 db    0
.xdata$x:00009183                 db    0
.xdata$x:00009184                 db    4
.xdata$x:00009185                 db    0
.xdata$x:00009186                 db    0
.xdata$x:00009187                 db    0
.xdata$x:00009188                 db    1
.xdata$x:00009189                 db    0
.xdata$x:0000918A                 db    0
.xdata$x:0000918B                 db    0
.xdata$x:0000918C                 dd offset __catchsym$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$5
.xdata$x:00009190 __ehfuncinfo$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009190                                         ; DATA XREF: __ehhandler$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009191                 db    5
.xdata$x:00009192                 db  93h ; ô
.xdata$x:00009193                 db  19h
.xdata$x:00009194                 db    5
.xdata$x:00009195                 db    0
.xdata$x:00009196                 db    0
.xdata$x:00009197                 db    0
.xdata$x:00009198                 dd offset __unwindtable$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000919C                 db    1
.xdata$x:0000919D                 db    0
.xdata$x:0000919E                 db    0
.xdata$x:0000919F                 db    0
.xdata$x:000091A0                 dd offset __tryblocktable$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:000091A4                 db    0
.xdata$x:000091A5                 db    0
.xdata$x:000091A6                 db    0
.xdata$x:000091A7                 db    0
.xdata$x:000091A8                 db    0
.xdata$x:000091A9                 db    0
.xdata$x:000091AA                 db    0
.xdata$x:000091AB                 db    0
.xdata$x:000091AC                 db    0
.xdata$x:000091AD                 db    0
.xdata$x:000091AE                 db    0
.xdata$x:000091AF                 db    0
.xdata$x:000091B0                 db    0
.xdata$x:000091B1                 db    0
.xdata$x:000091B2                 db    0
.xdata$x:000091B3                 db    0
.xdata$x:000091B4 __unwindtable$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000091B4                                         ; DATA XREF: .xdata$x:00009198o
.xdata$x:000091B5                 db 0FFh
.xdata$x:000091B6                 db 0FFh
.xdata$x:000091B7                 db 0FFh
.xdata$x:000091B8                 dd offset __unwindfunclet$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$2
.xdata$x:000091BC                 db    0
.xdata$x:000091BD                 db    0
.xdata$x:000091BE                 db    0
.xdata$x:000091BF                 db    0
.xdata$x:000091C0                 db    0
.xdata$x:000091C1                 db    0
.xdata$x:000091C2                 db    0
.xdata$x:000091C3                 db    0
.xdata$x:000091C4                 db    1
.xdata$x:000091C5                 db    0
.xdata$x:000091C6                 db    0
.xdata$x:000091C7                 db    0
.xdata$x:000091C8                 dd offset __unwindfunclet$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$3
.xdata$x:000091CC                 db    2
.xdata$x:000091CD                 db    0
.xdata$x:000091CE                 db    0
.xdata$x:000091CF                 db    0
.xdata$x:000091D0                 dd offset __unwindfunclet$??0?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@ABV01@@Z$4
.xdata$x:000091D4                 db    0
.xdata$x:000091D5                 db    0
.xdata$x:000091D6                 db    0
.xdata$x:000091D7                 db    0
.xdata$x:000091D8                 db    0
.xdata$x:000091D9                 db    0
.xdata$x:000091DA                 db    0
.xdata$x:000091DB                 db    0
.xdata$x:000091DB _xdata$x        ends
.xdata$x:000091DB
.xdata$x:000091DC ; ===========================================================================
.xdata$x:000091DC
.xdata$x:000091DC ; Segment type: Pure data
.xdata$x:000091DC ; Segment permissions: Read
.xdata$x:000091DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000091DC                 assume cs:_xdata$x
.xdata$x:000091DC                 ;org 91DCh
.xdata$x:000091DC ; COMDAT (pick associative to section at 5510)
.xdata$x:000091DC __unwindtable$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000091DC                                         ; DATA XREF: .xdata$x:000091ECo
.xdata$x:000091DD                 db 0FFh
.xdata$x:000091DE                 db 0FFh
.xdata$x:000091DF                 db 0FFh
.xdata$x:000091E0                 dd offset __unwindfunclet$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ$0
.xdata$x:000091E4 __ehfuncinfo$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000091E4                                         ; DATA XREF: __ehhandler$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ+11o
.xdata$x:000091E5                 db    5
.xdata$x:000091E6                 db  93h ; ô
.xdata$x:000091E7                 db  19h
.xdata$x:000091E8                 db    1
.xdata$x:000091E9                 db    0
.xdata$x:000091EA                 db    0
.xdata$x:000091EB                 db    0
.xdata$x:000091EC                 dd offset __unwindtable$??1?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QAE@XZ
.xdata$x:000091F0                 db    0
.xdata$x:000091F1                 db    0
.xdata$x:000091F2                 db    0
.xdata$x:000091F3                 db    0
.xdata$x:000091F4                 db    0
.xdata$x:000091F5                 db    0
.xdata$x:000091F6                 db    0
.xdata$x:000091F7                 db    0
.xdata$x:000091F8                 db    0
.xdata$x:000091F9                 db    0
.xdata$x:000091FA                 db    0
.xdata$x:000091FB                 db    0
.xdata$x:000091FC                 db    0
.xdata$x:000091FD                 db    0
.xdata$x:000091FE                 db    0
.xdata$x:000091FF                 db    0
.xdata$x:00009200                 db    0
.xdata$x:00009201                 db    0
.xdata$x:00009202                 db    0
.xdata$x:00009203                 db    0
.xdata$x:00009204                 db    0
.xdata$x:00009205                 db    0
.xdata$x:00009206                 db    0
.xdata$x:00009207                 db    0
.xdata$x:00009207 _xdata$x        ends
.xdata$x:00009207
.xdata$x:00009208 ; ===========================================================================
.xdata$x:00009208
.xdata$x:00009208 ; Segment type: Pure data
.xdata$x:00009208 ; Segment permissions: Read
.xdata$x:00009208 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009208                 assume cs:_xdata$x
.xdata$x:00009208                 ;org 9208h
.xdata$x:00009208 ; COMDAT (pick associative to section at 7994)
.xdata$x:00009208 __unwindtable$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:00009208                                         ; DATA XREF: .xdata$x:00009218o
.xdata$x:00009209                 db 0FFh
.xdata$x:0000920A                 db 0FFh
.xdata$x:0000920B                 db 0FFh
.xdata$x:0000920C                 dd offset __unwindfunclet$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ$0
.xdata$x:00009210 __ehfuncinfo$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00009210                                         ; DATA XREF: __ehhandler$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ+11o
.xdata$x:00009211                 db    5
.xdata$x:00009212                 db  93h ; ô
.xdata$x:00009213                 db  19h
.xdata$x:00009214                 db    1
.xdata$x:00009215                 db    0
.xdata$x:00009216                 db    0
.xdata$x:00009217                 db    0
.xdata$x:00009218                 dd offset __unwindtable$?begin@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ
.xdata$x:0000921C                 db    0
.xdata$x:0000921D                 db    0
.xdata$x:0000921E                 db    0
.xdata$x:0000921F                 db    0
.xdata$x:00009220                 db    0
.xdata$x:00009221                 db    0
.xdata$x:00009222                 db    0
.xdata$x:00009223                 db    0
.xdata$x:00009224                 db    0
.xdata$x:00009225                 db    0
.xdata$x:00009226                 db    0
.xdata$x:00009227                 db    0
.xdata$x:00009228                 db    0
.xdata$x:00009229                 db    0
.xdata$x:0000922A                 db    0
.xdata$x:0000922B                 db    0
.xdata$x:0000922C                 db    0
.xdata$x:0000922D                 db    0
.xdata$x:0000922E                 db    0
.xdata$x:0000922F                 db    0
.xdata$x:00009230                 db    0
.xdata$x:00009231                 db    0
.xdata$x:00009232                 db    0
.xdata$x:00009233                 db    0
.xdata$x:00009233 _xdata$x        ends
.xdata$x:00009233
.xdata$x:00009234 ; ===========================================================================
.xdata$x:00009234
.xdata$x:00009234 ; Segment type: Pure data
.xdata$x:00009234 ; Segment permissions: Read
.xdata$x:00009234 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009234                 assume cs:_xdata$x
.xdata$x:00009234                 ;org 9234h
.xdata$x:00009234 ; COMDAT (pick associative to section at 7DB4)
.xdata$x:00009234 __unwindtable$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:00009234                                         ; DATA XREF: .xdata$x:00009244o
.xdata$x:00009235                 db 0FFh
.xdata$x:00009236                 db 0FFh
.xdata$x:00009237                 db 0FFh
.xdata$x:00009238                 dd offset __unwindfunclet$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ$0
.xdata$x:0000923C __ehfuncinfo$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000923C                                         ; DATA XREF: __ehhandler$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ+11o
.xdata$x:0000923D                 db    5
.xdata$x:0000923E                 db  93h ; ô
.xdata$x:0000923F                 db  19h
.xdata$x:00009240                 db    1
.xdata$x:00009241                 db    0
.xdata$x:00009242                 db    0
.xdata$x:00009243                 db    0
.xdata$x:00009244                 dd offset __unwindtable$?end@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@2@XZ
.xdata$x:00009248                 align 20h
.xdata$x:00009248 _xdata$x        ends
.xdata$x:00009248
.xdata$x:00009260 ; ===========================================================================
.xdata$x:00009260
.xdata$x:00009260 ; Segment type: Pure data
.xdata$x:00009260 ; Segment permissions: Read
.xdata$x:00009260 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009260                 assume cs:_xdata$x
.xdata$x:00009260                 ;org 9260h
.xdata$x:00009260 __unwindtable$?FindEmptyContainer@DockingManager@@AAEHXZ db 0FFh
.xdata$x:00009260                                         ; DATA XREF: .xdata$x:000092D0o
.xdata$x:00009261                 db 0FFh
.xdata$x:00009262                 db 0FFh
.xdata$x:00009263                 db 0FFh
.xdata$x:00009264                 dd offset __unwindfunclet$?FindEmptyContainer@DockingManager@@AAEHXZ$0
.xdata$x:00009268 __unwindtable$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z db 0FFh
.xdata$x:00009268                                         ; DATA XREF: .xdata$x:000092F4o
.xdata$x:00009269                 db 0FFh
.xdata$x:0000926A                 db 0FFh
.xdata$x:0000926B                 db 0FFh
.xdata$x:0000926C                 dd offset __unwindfunclet$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z$0
.xdata$x:00009270 __unwindtable$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z db 0FFh
.xdata$x:00009270                                         ; DATA XREF: .xdata$x:00009318o
.xdata$x:00009271                 db 0FFh
.xdata$x:00009272                 db 0FFh
.xdata$x:00009273                 db 0FFh
.xdata$x:00009274                 dd offset __unwindfunclet$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z$0
.xdata$x:00009278 __unwindtable$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z db 0FFh
.xdata$x:00009278                                         ; DATA XREF: .xdata$x:00009360o
.xdata$x:00009279                 db 0FFh
.xdata$x:0000927A                 db 0FFh
.xdata$x:0000927B                 db 0FFh
.xdata$x:0000927C                 dd offset __unwindfunclet$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z$0
.xdata$x:00009280 __unwindtable$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z db 0FFh
.xdata$x:00009280                                         ; DATA XREF: .xdata$x:0000933Co
.xdata$x:00009281                 db 0FFh
.xdata$x:00009282                 db 0FFh
.xdata$x:00009283                 db 0FFh
.xdata$x:00009284                 dd offset __unwindfunclet$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z$0
.xdata$x:00009288                 db    0
.xdata$x:00009289                 db    0
.xdata$x:0000928A                 db    0
.xdata$x:0000928B                 db    0
.xdata$x:0000928C                 dd offset __unwindfunclet$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z$1
.xdata$x:00009290 __unwindtable$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z db 0FFh
.xdata$x:00009290                                         ; DATA XREF: .xdata$x:00009384o
.xdata$x:00009291                 db 0FFh
.xdata$x:00009292                 db 0FFh
.xdata$x:00009293                 db 0FFh
.xdata$x:00009294                 dd offset __unwindfunclet$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z$0
.xdata$x:00009298                 db 0FFh
.xdata$x:00009299                 db 0FFh
.xdata$x:0000929A                 db 0FFh
.xdata$x:0000929B                 db 0FFh
.xdata$x:0000929C                 dd offset __unwindfunclet$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z$1
.xdata$x:000092A0                 db 0FFh
.xdata$x:000092A1                 db 0FFh
.xdata$x:000092A2                 db 0FFh
.xdata$x:000092A3                 db 0FFh
.xdata$x:000092A4                 dd offset __unwindfunclet$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z$2
.xdata$x:000092A8 __unwindtable$??1DockingManager@@UAE@XZ db 0FFh
.xdata$x:000092A8                                         ; DATA XREF: .xdata$x:000093A8o
.xdata$x:000092A9                 db 0FFh
.xdata$x:000092AA                 db 0FFh
.xdata$x:000092AB                 db 0FFh
.xdata$x:000092AC                 dd offset __unwindfunclet$??1DockingManager@@UAE@XZ$0
.xdata$x:000092B0                 db    0
.xdata$x:000092B1                 db    0
.xdata$x:000092B2                 db    0
.xdata$x:000092B3                 db    0
.xdata$x:000092B4                 dd offset __unwindfunclet$??1DockingManager@@UAE@XZ$1
.xdata$x:000092B8                 db    1
.xdata$x:000092B9                 db    0
.xdata$x:000092BA                 db    0
.xdata$x:000092BB                 db    0
.xdata$x:000092BC                 dd offset __unwindfunclet$??1DockingManager@@UAE@XZ$2
.xdata$x:000092C0                 db    2
.xdata$x:000092C1                 db    0
.xdata$x:000092C2                 db    0
.xdata$x:000092C3                 db    0
.xdata$x:000092C4                 dd offset __unwindfunclet$??1DockingManager@@UAE@XZ$3
.xdata$x:000092C8 __ehfuncinfo$?FindEmptyContainer@DockingManager@@AAEHXZ db  22h ; "
.xdata$x:000092C8                                         ; DATA XREF: __ehhandler$?FindEmptyContainer@DockingManager@@AAEHXZ+11o
.xdata$x:000092C9                 db    5
.xdata$x:000092CA                 db  93h ; ô
.xdata$x:000092CB                 db  19h
.xdata$x:000092CC                 db    1
.xdata$x:000092CD                 db    0
.xdata$x:000092CE                 db    0
.xdata$x:000092CF                 db    0
.xdata$x:000092D0                 dd offset __unwindtable$?FindEmptyContainer@DockingManager@@AAEHXZ
.xdata$x:000092D4                 db    0
.xdata$x:000092D5                 db    0
.xdata$x:000092D6                 db    0
.xdata$x:000092D7                 db    0
.xdata$x:000092D8                 db    0
.xdata$x:000092D9                 db    0
.xdata$x:000092DA                 db    0
.xdata$x:000092DB                 db    0
.xdata$x:000092DC                 db    0
.xdata$x:000092DD                 db    0
.xdata$x:000092DE                 db    0
.xdata$x:000092DF                 db    0
.xdata$x:000092E0                 db    0
.xdata$x:000092E1                 db    0
.xdata$x:000092E2                 db    0
.xdata$x:000092E3                 db    0
.xdata$x:000092E4                 db    0
.xdata$x:000092E5                 db    0
.xdata$x:000092E6                 db    0
.xdata$x:000092E7                 db    0
.xdata$x:000092E8                 db    0
.xdata$x:000092E9                 db    0
.xdata$x:000092EA                 db    0
.xdata$x:000092EB                 db    0
.xdata$x:000092EC __ehfuncinfo$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z db  22h ; "
.xdata$x:000092EC                                         ; DATA XREF: __ehhandler$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z+1Eo
.xdata$x:000092ED                 db    5
.xdata$x:000092EE                 db  93h ; ô
.xdata$x:000092EF                 db  19h
.xdata$x:000092F0                 db    1
.xdata$x:000092F1                 db    0
.xdata$x:000092F2                 db    0
.xdata$x:000092F3                 db    0
.xdata$x:000092F4                 dd offset __unwindtable$?runProc@DockingManager@@AAEJPAUHWND__@@IIJ@Z
.xdata$x:000092F8                 db    0
.xdata$x:000092F9                 db    0
.xdata$x:000092FA                 db    0
.xdata$x:000092FB                 db    0
.xdata$x:000092FC                 db    0
.xdata$x:000092FD                 db    0
.xdata$x:000092FE                 db    0
.xdata$x:000092FF                 db    0
.xdata$x:00009300                 db    0
.xdata$x:00009301                 db    0
.xdata$x:00009302                 db    0
.xdata$x:00009303                 db    0
.xdata$x:00009304                 db    0
.xdata$x:00009305                 db    0
.xdata$x:00009306                 db    0
.xdata$x:00009307                 db    0
.xdata$x:00009308                 db    0
.xdata$x:00009309                 db    0
.xdata$x:0000930A                 db    0
.xdata$x:0000930B                 db    0
.xdata$x:0000930C                 db    0
.xdata$x:0000930D                 db    0
.xdata$x:0000930E                 db    0
.xdata$x:0000930F                 db    0
.xdata$x:00009310 __ehfuncinfo$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z db  22h ; "
.xdata$x:00009310                                         ; DATA XREF: __ehhandler$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z+1Bo
.xdata$x:00009311                 db    5
.xdata$x:00009312                 db  93h ; ô
.xdata$x:00009313                 db  19h
.xdata$x:00009314                 db    1
.xdata$x:00009315                 db    0
.xdata$x:00009316                 db    0
.xdata$x:00009317                 db    0
.xdata$x:00009318                 dd offset __unwindtable$?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z
.xdata$x:0000931C                 db    0
.xdata$x:0000931D                 db    0
.xdata$x:0000931E                 db    0
.xdata$x:0000931F                 db    0
.xdata$x:00009320                 db    0
.xdata$x:00009321                 db    0
.xdata$x:00009322                 db    0
.xdata$x:00009323                 db    0
.xdata$x:00009324                 db    0
.xdata$x:00009325                 db    0
.xdata$x:00009326                 db    0
.xdata$x:00009327                 db    0
.xdata$x:00009328                 db    0
.xdata$x:00009329                 db    0
.xdata$x:0000932A                 db    0
.xdata$x:0000932B                 db    0
.xdata$x:0000932C                 db    0
.xdata$x:0000932D                 db    0
.xdata$x:0000932E                 db    0
.xdata$x:0000932F                 db    0
.xdata$x:00009330                 db    0
.xdata$x:00009331                 db    0
.xdata$x:00009332                 db    0
.xdata$x:00009333                 db    0
.xdata$x:00009334 __ehfuncinfo$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z db  22h ; "
.xdata$x:00009334                                         ; DATA XREF: __ehhandler$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z+1Eo
.xdata$x:00009335                 db    5
.xdata$x:00009336                 db  93h ; ô
.xdata$x:00009337                 db  19h
.xdata$x:00009338                 db    2
.xdata$x:00009339                 db    0
.xdata$x:0000933A                 db    0
.xdata$x:0000933B                 db    0
.xdata$x:0000933C                 dd offset __unwindtable$?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z
.xdata$x:00009340                 db    0
.xdata$x:00009341                 db    0
.xdata$x:00009342                 db    0
.xdata$x:00009343                 db    0
.xdata$x:00009344                 db    0
.xdata$x:00009345                 db    0
.xdata$x:00009346                 db    0
.xdata$x:00009347                 db    0
.xdata$x:00009348                 db    0
.xdata$x:00009349                 db    0
.xdata$x:0000934A                 db    0
.xdata$x:0000934B                 db    0
.xdata$x:0000934C                 db    0
.xdata$x:0000934D                 db    0
.xdata$x:0000934E                 db    0
.xdata$x:0000934F                 db    0
.xdata$x:00009350                 db    0
.xdata$x:00009351                 db    0
.xdata$x:00009352                 db    0
.xdata$x:00009353                 db    0
.xdata$x:00009354                 db    0
.xdata$x:00009355                 db    0
.xdata$x:00009356                 db    0
.xdata$x:00009357                 db    0
.xdata$x:00009358 __ehfuncinfo$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z db  22h ; "
.xdata$x:00009358                                         ; DATA XREF: __ehhandler$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z+1Bo
.xdata$x:00009359                 db    5
.xdata$x:0000935A                 db  93h ; ô
.xdata$x:0000935B                 db  19h
.xdata$x:0000935C                 db    1
.xdata$x:0000935D                 db    0
.xdata$x:0000935E                 db    0
.xdata$x:0000935F                 db    0
.xdata$x:00009360                 dd offset __unwindtable$?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z
.xdata$x:00009364                 db    0
.xdata$x:00009365                 db    0
.xdata$x:00009366                 db    0
.xdata$x:00009367                 db    0
.xdata$x:00009368                 db    0
.xdata$x:00009369                 db    0
.xdata$x:0000936A                 db    0
.xdata$x:0000936B                 db    0
.xdata$x:0000936C                 db    0
.xdata$x:0000936D                 db    0
.xdata$x:0000936E                 db    0
.xdata$x:0000936F                 db    0
.xdata$x:00009370                 db    0
.xdata$x:00009371                 db    0
.xdata$x:00009372                 db    0
.xdata$x:00009373                 db    0
.xdata$x:00009374                 db    0
.xdata$x:00009375                 db    0
.xdata$x:00009376                 db    0
.xdata$x:00009377                 db    0
.xdata$x:00009378                 db    0
.xdata$x:00009379                 db    0
.xdata$x:0000937A                 db    0
.xdata$x:0000937B                 db    0
.xdata$x:0000937C __ehfuncinfo$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z db  22h ; "
.xdata$x:0000937C                                         ; DATA XREF: __ehhandler$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z+1Bo
.xdata$x:0000937D                 db    5
.xdata$x:0000937E                 db  93h ; ô
.xdata$x:0000937F                 db  19h
.xdata$x:00009380                 db    3
.xdata$x:00009381                 db    0
.xdata$x:00009382                 db    0
.xdata$x:00009383                 db    0
.xdata$x:00009384                 dd offset __unwindtable$?createDockableDlg@DockingManager@@QAEXUtTbData@@H_N@Z
.xdata$x:00009388                 align 20h
.xdata$x:000093A0 __ehfuncinfo$??1DockingManager@@UAE@XZ db  22h ; "
.xdata$x:000093A0                                         ; DATA XREF: __ehhandler$??1DockingManager@@UAE@XZ+11o
.xdata$x:000093A1                 db    5
.xdata$x:000093A2                 db  93h ; ô
.xdata$x:000093A3                 db  19h
.xdata$x:000093A4                 db    4
.xdata$x:000093A5                 db    0
.xdata$x:000093A6                 db    0
.xdata$x:000093A7                 db    0
.xdata$x:000093A8                 dd offset __unwindtable$??1DockingManager@@UAE@XZ
.xdata$x:000093AC                 db    0
.xdata$x:000093AD                 db    0
.xdata$x:000093AE                 db    0
.xdata$x:000093AF                 db    0
.xdata$x:000093B0                 db    0
.xdata$x:000093B1                 db    0
.xdata$x:000093B2                 db    0
.xdata$x:000093B3                 db    0
.xdata$x:000093B4                 db    0
.xdata$x:000093B5                 db    0
.xdata$x:000093B6                 db    0
.xdata$x:000093B7                 db    0
.xdata$x:000093B8                 db    0
.xdata$x:000093B9                 db    0
.xdata$x:000093BA                 db    0
.xdata$x:000093BB                 db    0
.xdata$x:000093BC                 db    0
.xdata$x:000093BD                 db    0
.xdata$x:000093BE                 db    0
.xdata$x:000093BF                 db    0
.xdata$x:000093C0                 db    0
.xdata$x:000093C1                 db    0
.xdata$x:000093C2                 db    0
.xdata$x:000093C3                 db    0
.xdata$x:000093C4 __ehfuncinfo$??0DockingManager@@QAE@XZ db  22h ; "
.xdata$x:000093C4                                         ; DATA XREF: __ehhandler$??0DockingManager@@QAE@XZ+11o
.xdata$x:000093C5                 db    5
.xdata$x:000093C6                 db  93h ; ô
.xdata$x:000093C7                 db  19h
.xdata$x:000093C8                 db    6
.xdata$x:000093C9                 db    0
.xdata$x:000093CA                 db    0
.xdata$x:000093CB                 db    0
.xdata$x:000093CC                 dd offset __unwindtable$??0DockingManager@@QAE@XZ
.xdata$x:000093D0                 db    0
.xdata$x:000093D1                 db    0
.xdata$x:000093D2                 db    0
.xdata$x:000093D3                 db    0
.xdata$x:000093D4                 db    0
.xdata$x:000093D5                 db    0
.xdata$x:000093D6                 db    0
.xdata$x:000093D7                 db    0
.xdata$x:000093D8                 db    0
.xdata$x:000093D9                 db    0
.xdata$x:000093DA                 db    0
.xdata$x:000093DB                 db    0
.xdata$x:000093DC                 db    0
.xdata$x:000093DD                 db    0
.xdata$x:000093DE                 db    0
.xdata$x:000093DF                 db    0
.xdata$x:000093E0                 db    0
.xdata$x:000093E1                 db    0
.xdata$x:000093E2                 db    0
.xdata$x:000093E3                 db    0
.xdata$x:000093E4                 db    0
.xdata$x:000093E5                 db    0
.xdata$x:000093E6                 db    0
.xdata$x:000093E7                 db    0
.xdata$x:000093E8 __unwindtable$??0DockingManager@@QAE@XZ db 0FFh
.xdata$x:000093E8                                         ; DATA XREF: .xdata$x:000093CCo
.xdata$x:000093E9                 db 0FFh
.xdata$x:000093EA                 db 0FFh
.xdata$x:000093EB                 db 0FFh
.xdata$x:000093EC                 dd offset __unwindfunclet$??0DockingManager@@QAE@XZ$0
.xdata$x:000093F0                 db    0
.xdata$x:000093F1                 db    0
.xdata$x:000093F2                 db    0
.xdata$x:000093F3                 db    0
.xdata$x:000093F4                 dd offset __unwindfunclet$??0DockingManager@@QAE@XZ$1
.xdata$x:000093F8                 db    1
.xdata$x:000093F9                 db    0
.xdata$x:000093FA                 db    0
.xdata$x:000093FB                 db    0
.xdata$x:000093FC                 dd offset __unwindfunclet$??0DockingManager@@QAE@XZ$2
.xdata$x:00009400                 db    2
.xdata$x:00009401                 db    0
.xdata$x:00009402                 db    0
.xdata$x:00009403                 db    0
.xdata$x:00009404                 dd offset __unwindfunclet$??0DockingManager@@QAE@XZ$3
.xdata$x:00009408                 db    3
.xdata$x:00009409                 db    0
.xdata$x:0000940A                 db    0
.xdata$x:0000940B                 db    0
.xdata$x:0000940C                 dd offset __unwindfunclet$??0DockingManager@@QAE@XZ$4
.xdata$x:00009410                 db    3
.xdata$x:00009411                 db    0
.xdata$x:00009412                 db    0
.xdata$x:00009413                 db    0
.xdata$x:00009414                 dd offset __unwindfunclet$??0DockingManager@@QAE@XZ$5
.xdata$x:00009414 _xdata$x        ends
.xdata$x:00009414
.xdata$x:00009418 ; ===========================================================================
.xdata$x:00009418
.xdata$x:00009418 ; Segment type: Pure data
.xdata$x:00009418 ; Segment permissions: Read
.xdata$x:00009418 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009418                 assume cs:_xdata$x
.xdata$x:00009418                 ;org 9418h
.xdata$x:00009418 ; COMDAT (pick associative to section at 43CC)
.xdata$x:00009418 __unwindtable$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009418                                         ; DATA XREF: .xdata$x:00009428o
.xdata$x:00009419                 db 0FFh
.xdata$x:0000941A                 db 0FFh
.xdata$x:0000941B                 db 0FFh
.xdata$x:0000941C                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ$0
.xdata$x:00009420 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009420                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009421                 db    5
.xdata$x:00009422                 db  93h ; ô
.xdata$x:00009423                 db  19h
.xdata$x:00009424                 db    1
.xdata$x:00009425                 db    0
.xdata$x:00009426                 db    0
.xdata$x:00009427                 db    0
.xdata$x:00009428                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ
.xdata$x:0000942C                 db    0
.xdata$x:0000942D                 db    0
.xdata$x:0000942E                 db    0
.xdata$x:0000942F                 db    0
.xdata$x:00009430                 db    0
.xdata$x:00009431                 db    0
.xdata$x:00009432                 db    0
.xdata$x:00009433                 db    0
.xdata$x:00009434                 db    0
.xdata$x:00009435                 db    0
.xdata$x:00009436                 db    0
.xdata$x:00009437                 db    0
.xdata$x:00009438                 db    0
.xdata$x:00009439                 db    0
.xdata$x:0000943A                 db    0
.xdata$x:0000943B                 db    0
.xdata$x:0000943C                 db    0
.xdata$x:0000943D                 db    0
.xdata$x:0000943E                 db    0
.xdata$x:0000943F                 db    0
.xdata$x:00009440                 db    0
.xdata$x:00009441                 db    0
.xdata$x:00009442                 db    0
.xdata$x:00009443                 db    0
.xdata$x:00009443 _xdata$x        ends
.xdata$x:00009443
.xdata$x:00009444 ; ===========================================================================
.xdata$x:00009444
.xdata$x:00009444 ; Segment type: Pure data
.xdata$x:00009444 ; Segment permissions: Read
.xdata$x:00009444 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009444                 assume cs:_xdata$x
.xdata$x:00009444                 ;org 9444h
.xdata$x:00009444 ; COMDAT (pick associative to section at 525C)
.xdata$x:00009444 __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009444                                         ; DATA XREF: .xdata$x:00009454o
.xdata$x:00009445                 db 0FFh
.xdata$x:00009446                 db 0FFh
.xdata$x:00009447                 db 0FFh
.xdata$x:00009448                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ$0
.xdata$x:0000944C __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000944C                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000944D                 db    5
.xdata$x:0000944E                 db  93h ; ô
.xdata$x:0000944F                 db  19h
.xdata$x:00009450                 db    1
.xdata$x:00009451                 db    0
.xdata$x:00009452                 db    0
.xdata$x:00009453                 db    0
.xdata$x:00009454                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAUHWND__@@@std@@@std@@QAE@XZ
.xdata$x:00009458                 db    0
.xdata$x:00009459                 db    0
.xdata$x:0000945A                 db    0
.xdata$x:0000945B                 db    0
.xdata$x:0000945C                 db    0
.xdata$x:0000945D                 db    0
.xdata$x:0000945E                 db    0
.xdata$x:0000945F                 db    0
.xdata$x:00009460                 db    0
.xdata$x:00009461                 db    0
.xdata$x:00009462                 db    0
.xdata$x:00009463                 db    0
.xdata$x:00009464                 db    0
.xdata$x:00009465                 db    0
.xdata$x:00009466                 db    0
.xdata$x:00009467                 db    0
.xdata$x:00009468                 db    0
.xdata$x:00009469                 db    0
.xdata$x:0000946A                 db    0
.xdata$x:0000946B                 db    0
.xdata$x:0000946C                 db    0
.xdata$x:0000946D                 db    0
.xdata$x:0000946E                 db    0
.xdata$x:0000946F                 db    0
.xdata$x:0000946F _xdata$x        ends
.xdata$x:0000946F
.xdata$x:00009470 ; ===========================================================================
.xdata$x:00009470
.xdata$x:00009470 ; Segment type: Pure data
.xdata$x:00009470 ; Segment permissions: Read
.xdata$x:00009470 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009470                 assume cs:_xdata$x
.xdata$x:00009470                 ;org 9470h
.xdata$x:00009470 ; COMDAT (pick associative to section at 40CC)
.xdata$x:00009470 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z db 0FFh
.xdata$x:00009470                                         ; DATA XREF: .xdata$x:00009480o
.xdata$x:00009471                 db 0FFh
.xdata$x:00009472                 db 0FFh
.xdata$x:00009473                 db 0FFh
.xdata$x:00009474                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z$0
.xdata$x:00009478 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z db  22h ; "
.xdata$x:00009478                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z+11o
.xdata$x:00009479                 db    5
.xdata$x:0000947A                 db  93h ; ô
.xdata$x:0000947B                 db  19h
.xdata$x:0000947C                 db    1
.xdata$x:0000947D                 db    0
.xdata$x:0000947E                 db    0
.xdata$x:0000947F                 db    0
.xdata$x:00009480                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHWND__@@@1@@Z
.xdata$x:00009484                 db    0
.xdata$x:00009485                 db    0
.xdata$x:00009486                 db    0
.xdata$x:00009487                 db    0
.xdata$x:00009488                 db    0
.xdata$x:00009489                 db    0
.xdata$x:0000948A                 db    0
.xdata$x:0000948B                 db    0
.xdata$x:0000948C                 db    0
.xdata$x:0000948D                 db    0
.xdata$x:0000948E                 db    0
.xdata$x:0000948F                 db    0
.xdata$x:00009490                 db    0
.xdata$x:00009491                 db    0
.xdata$x:00009492                 db    0
.xdata$x:00009493                 db    0
.xdata$x:00009494                 db    0
.xdata$x:00009495                 db    0
.xdata$x:00009496                 db    0
.xdata$x:00009497                 db    0
.xdata$x:00009498                 db    0
.xdata$x:00009499                 db    0
.xdata$x:0000949A                 db    0
.xdata$x:0000949B                 db    0
.xdata$x:0000949B _xdata$x        ends
.xdata$x:0000949B
.xdata$x:0000949C ; ===========================================================================
.xdata$x:0000949C
.xdata$x:0000949C ; Segment type: Pure data
.xdata$x:0000949C ; Segment permissions: Read
.xdata$x:0000949C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000949C                 assume cs:_xdata$x
.xdata$x:0000949C                 ;org 949Ch
.xdata$x:0000949C ; COMDAT (pick associative to section at 500C)
.xdata$x:0000949C __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000949C                                         ; DATA XREF: .xdata$x:000094ACo
.xdata$x:0000949D                 db 0FFh
.xdata$x:0000949E                 db 0FFh
.xdata$x:0000949F                 db 0FFh
.xdata$x:000094A0                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000094A4 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000094A4                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000094A5                 db    5
.xdata$x:000094A6                 db  93h ; ô
.xdata$x:000094A7                 db  19h
.xdata$x:000094A8                 db    1
.xdata$x:000094A9                 db    0
.xdata$x:000094AA                 db    0
.xdata$x:000094AB                 db    0
.xdata$x:000094AC                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@@std@@QAE@XZ
.xdata$x:000094B0                 db    0
.xdata$x:000094B1                 db    0
.xdata$x:000094B2                 db    0
.xdata$x:000094B3                 db    0
.xdata$x:000094B4                 db    0
.xdata$x:000094B5                 db    0
.xdata$x:000094B6                 db    0
.xdata$x:000094B7                 db    0
.xdata$x:000094B8                 db    0
.xdata$x:000094B9                 db    0
.xdata$x:000094BA                 db    0
.xdata$x:000094BB                 db    0
.xdata$x:000094BC                 db    0
.xdata$x:000094BD                 db    0
.xdata$x:000094BE                 db    0
.xdata$x:000094BF                 db    0
.xdata$x:000094C0                 db    0
.xdata$x:000094C1                 db    0
.xdata$x:000094C2                 db    0
.xdata$x:000094C3                 db    0
.xdata$x:000094C4                 db    0
.xdata$x:000094C5                 db    0
.xdata$x:000094C6                 db    0
.xdata$x:000094C7                 db    0
.xdata$x:000094C7 _xdata$x        ends
.xdata$x:000094C7
.xdata$x:000094C8 ; ===========================================================================
.xdata$x:000094C8
.xdata$x:000094C8 ; Segment type: Pure data
.xdata$x:000094C8 ; Segment permissions: Read
.xdata$x:000094C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000094C8                 assume cs:_xdata$x
.xdata$x:000094C8                 ;org 94C8h
.xdata$x:000094C8 ; COMDAT (pick associative to section at 47C0)
.xdata$x:000094C8 __unwindtable$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000094C8                                         ; DATA XREF: .xdata$x:000094D8o
.xdata$x:000094C9                 db 0FFh
.xdata$x:000094CA                 db 0FFh
.xdata$x:000094CB                 db 0FFh
.xdata$x:000094CC                 dd offset __unwindfunclet$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ$0
.xdata$x:000094D0 __ehfuncinfo$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000094D0                                         ; DATA XREF: __ehhandler$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ+11o
.xdata$x:000094D1                 db    5
.xdata$x:000094D2                 db  93h ; ô
.xdata$x:000094D3                 db  19h
.xdata$x:000094D4                 db    1
.xdata$x:000094D5                 db    0
.xdata$x:000094D6                 db    0
.xdata$x:000094D7                 db    0
.xdata$x:000094D8                 dd offset __unwindtable$??0?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ
.xdata$x:000094DC                 db    0
.xdata$x:000094DD                 db    0
.xdata$x:000094DE                 db    0
.xdata$x:000094DF                 db    0
.xdata$x:000094E0                 db    0
.xdata$x:000094E1                 db    0
.xdata$x:000094E2                 db    0
.xdata$x:000094E3                 db    0
.xdata$x:000094E4                 db    0
.xdata$x:000094E5                 db    0
.xdata$x:000094E6                 db    0
.xdata$x:000094E7                 db    0
.xdata$x:000094E8                 db    0
.xdata$x:000094E9                 db    0
.xdata$x:000094EA                 db    0
.xdata$x:000094EB                 db    0
.xdata$x:000094EC                 db    0
.xdata$x:000094ED                 db    0
.xdata$x:000094EE                 db    0
.xdata$x:000094EF                 db    0
.xdata$x:000094F0                 db    0
.xdata$x:000094F1                 db    0
.xdata$x:000094F2                 db    0
.xdata$x:000094F3                 db    0
.xdata$x:000094F3 _xdata$x        ends
.xdata$x:000094F3
.xdata$x:000094F4 ; ===========================================================================
.xdata$x:000094F4
.xdata$x:000094F4 ; Segment type: Pure data
.xdata$x:000094F4 ; Segment permissions: Read
.xdata$x:000094F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000094F4                 assume cs:_xdata$x
.xdata$x:000094F4                 ;org 94F4h
.xdata$x:000094F4 ; COMDAT (pick associative to section at 5498)
.xdata$x:000094F4 __unwindtable$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000094F4                                         ; DATA XREF: .xdata$x:00009504o
.xdata$x:000094F5                 db 0FFh
.xdata$x:000094F6                 db 0FFh
.xdata$x:000094F7                 db 0FFh
.xdata$x:000094F8                 dd offset __unwindfunclet$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ$0
.xdata$x:000094FC __ehfuncinfo$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000094FC                                         ; DATA XREF: __ehhandler$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ+11o
.xdata$x:000094FD                 db    5
.xdata$x:000094FE                 db  93h ; ô
.xdata$x:000094FF                 db  19h
.xdata$x:00009500                 db    1
.xdata$x:00009501                 db    0
.xdata$x:00009502                 db    0
.xdata$x:00009503                 db    0
.xdata$x:00009504                 dd offset __unwindtable$??1?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@QAE@XZ
.xdata$x:00009508                 align 20h
.xdata$x:00009508 _xdata$x        ends
.xdata$x:00009508
.xdata$x:00009520 ; ===========================================================================
.xdata$x:00009520
.xdata$x:00009520 ; Segment type: Pure data
.xdata$x:00009520 ; Segment permissions: Read
.xdata$x:00009520 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009520                 assume cs:_xdata$x
.xdata$x:00009520                 ;org 9520h
.xdata$x:00009520 ; COMDAT (pick associative to section at 6DFC)
.xdata$x:00009520 __catchsym$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00009520                                         ; DATA XREF: .xdata$x:00009550o
.xdata$x:00009521                 db    0
.xdata$x:00009522                 db    0
.xdata$x:00009523                 db    0
.xdata$x:00009524                 db    0
.xdata$x:00009525                 db    0
.xdata$x:00009526                 db    0
.xdata$x:00009527                 db    0
.xdata$x:00009528                 db    0
.xdata$x:00009529                 db    0
.xdata$x:0000952A                 db    0
.xdata$x:0000952B                 db    0
.xdata$x:0000952C                 dd offset __catch$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z$0
.xdata$x:00009530 __unwindtable$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00009530                                         ; DATA XREF: .xdata$x:0000955Co
.xdata$x:00009531                 db 0FFh
.xdata$x:00009532                 db 0FFh
.xdata$x:00009533                 db 0FFh
.xdata$x:00009534                 db    0
.xdata$x:00009535                 db    0
.xdata$x:00009536                 db    0
.xdata$x:00009537                 db    0
.xdata$x:00009538                 db 0FFh
.xdata$x:00009539                 db 0FFh
.xdata$x:0000953A                 db 0FFh
.xdata$x:0000953B                 db 0FFh
.xdata$x:0000953C                 db    0
.xdata$x:0000953D                 db    0
.xdata$x:0000953E                 db    0
.xdata$x:0000953F                 db    0
.xdata$x:00009540 __tryblocktable$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z db    0
.xdata$x:00009540                                         ; DATA XREF: .xdata$x:00009564o
.xdata$x:00009541                 db    0
.xdata$x:00009542                 db    0
.xdata$x:00009543                 db    0
.xdata$x:00009544                 db    0
.xdata$x:00009545                 db    0
.xdata$x:00009546                 db    0
.xdata$x:00009547                 db    0
.xdata$x:00009548                 db    1
.xdata$x:00009549                 db    0
.xdata$x:0000954A                 db    0
.xdata$x:0000954B                 db    0
.xdata$x:0000954C                 db    1
.xdata$x:0000954D                 db    0
.xdata$x:0000954E                 db    0
.xdata$x:0000954F                 db    0
.xdata$x:00009550                 dd offset __catchsym$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z$2
.xdata$x:00009554 __ehfuncinfo$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:00009554                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z+11o
.xdata$x:00009555                 db    5
.xdata$x:00009556                 db  93h ; ô
.xdata$x:00009557                 db  19h
.xdata$x:00009558                 db    2
.xdata$x:00009559                 db    0
.xdata$x:0000955A                 db    0
.xdata$x:0000955B                 db    0
.xdata$x:0000955C                 dd offset __unwindtable$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z
.xdata$x:00009560                 db    1
.xdata$x:00009561                 db    0
.xdata$x:00009562                 db    0
.xdata$x:00009563                 db    0
.xdata$x:00009564                 dd offset __tryblocktable$?_Reallocate@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IAEXI@Z
.xdata$x:00009568                 db    0
.xdata$x:00009569                 db    0
.xdata$x:0000956A                 db    0
.xdata$x:0000956B                 db    0
.xdata$x:0000956C                 db    0
.xdata$x:0000956D                 db    0
.xdata$x:0000956E                 db    0
.xdata$x:0000956F                 db    0
.xdata$x:00009570                 db    0
.xdata$x:00009571                 db    0
.xdata$x:00009572                 db    0
.xdata$x:00009573                 db    0
.xdata$x:00009574                 db    0
.xdata$x:00009575                 db    0
.xdata$x:00009576                 db    0
.xdata$x:00009577                 db    0
.xdata$x:00009577 _xdata$x        ends
.xdata$x:00009577
.xdata$x:00009578 ; ===========================================================================
.xdata$x:00009578
.xdata$x:00009578 ; Segment type: Pure data
.xdata$x:00009578 ; Segment permissions: Read
.xdata$x:00009578 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009578                 assume cs:_xdata$x
.xdata$x:00009578                 ;org 9578h
.xdata$x:00009578 ; COMDAT (pick associative to section at 6B68)
.xdata$x:00009578 __unwindtable$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z db 0FFh
.xdata$x:00009578                                         ; DATA XREF: .xdata$x:00009588o
.xdata$x:00009579                 db 0FFh
.xdata$x:0000957A                 db 0FFh
.xdata$x:0000957B                 db 0FFh
.xdata$x:0000957C                 dd offset __unwindfunclet$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z$0
.xdata$x:00009580 __ehfuncinfo$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z db  22h ; "
.xdata$x:00009580                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z+11o
.xdata$x:00009581                 db    5
.xdata$x:00009582                 db  93h ; ô
.xdata$x:00009583                 db  19h
.xdata$x:00009584                 db    1
.xdata$x:00009585                 db    0
.xdata$x:00009586                 db    0
.xdata$x:00009587                 db    0
.xdata$x:00009588                 dd offset __unwindtable$?_Orphan_range@?$vector@PAUHWND__@@V?$allocator@PAUHWND__@@@std@@@std@@IBEXPAPAUHWND__@@0@Z
.xdata$x:0000958C                 db    0
.xdata$x:0000958D                 db    0
.xdata$x:0000958E                 db    0
.xdata$x:0000958F                 db    0
.xdata$x:00009590                 db    0
.xdata$x:00009591                 db    0
.xdata$x:00009592                 db    0
.xdata$x:00009593                 db    0
.xdata$x:00009594                 db    0
.xdata$x:00009595                 db    0
.xdata$x:00009596                 db    0
.xdata$x:00009597                 db    0
.xdata$x:00009598                 db    0
.xdata$x:00009599                 db    0
.xdata$x:0000959A                 db    0
.xdata$x:0000959B                 db    0
.xdata$x:0000959C                 db    0
.xdata$x:0000959D                 db    0
.xdata$x:0000959E                 db    0
.xdata$x:0000959F                 db    0
.xdata$x:000095A0                 db    0
.xdata$x:000095A1                 db    0
.xdata$x:000095A2                 db    0
.xdata$x:000095A3                 db    0
.xdata$x:000095A3 _xdata$x        ends
.xdata$x:000095A3
.xdata$x:000095A4 ; ===========================================================================
.xdata$x:000095A4
.xdata$x:000095A4 ; Segment type: Pure data
.xdata$x:000095A4 ; Segment permissions: Read
.xdata$x:000095A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000095A4                 assume cs:_xdata$x
.xdata$x:000095A4                 ;org 95A4h
.xdata$x:000095A4 ; COMDAT (pick associative to section at 44EC)
.xdata$x:000095A4 __unwindtable$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000095A4                                         ; DATA XREF: .xdata$x:000095B4o
.xdata$x:000095A5                 db 0FFh
.xdata$x:000095A6                 db 0FFh
.xdata$x:000095A7                 db 0FFh
.xdata$x:000095A8                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0
.xdata$x:000095AC __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000095AC                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ+11o
.xdata$x:000095AD                 db    5
.xdata$x:000095AE                 db  93h ; ô
.xdata$x:000095AF                 db  19h
.xdata$x:000095B0                 db    1
.xdata$x:000095B1                 db    0
.xdata$x:000095B2                 db    0
.xdata$x:000095B3                 db    0
.xdata$x:000095B4                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.xdata$x:000095B8                 db    0
.xdata$x:000095B9                 db    0
.xdata$x:000095BA                 db    0
.xdata$x:000095BB                 db    0
.xdata$x:000095BC                 db    0
.xdata$x:000095BD                 db    0
.xdata$x:000095BE                 db    0
.xdata$x:000095BF                 db    0
.xdata$x:000095C0                 db    0
.xdata$x:000095C1                 db    0
.xdata$x:000095C2                 db    0
.xdata$x:000095C3                 db    0
.xdata$x:000095C4                 db    0
.xdata$x:000095C5                 db    0
.xdata$x:000095C6                 db    0
.xdata$x:000095C7                 db    0
.xdata$x:000095C8                 db    0
.xdata$x:000095C9                 db    0
.xdata$x:000095CA                 db    0
.xdata$x:000095CB                 db    0
.xdata$x:000095CC                 db    0
.xdata$x:000095CD                 db    0
.xdata$x:000095CE                 db    0
.xdata$x:000095CF                 db    0
.xdata$x:000095CF _xdata$x        ends
.xdata$x:000095CF
.xdata$x:000095D0 ; ===========================================================================
.xdata$x:000095D0
.xdata$x:000095D0 ; Segment type: Pure data
.xdata$x:000095D0 ; Segment permissions: Read
.xdata$x:000095D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000095D0                 assume cs:_xdata$x
.xdata$x:000095D0                 ;org 95D0h
.xdata$x:000095D0 ; COMDAT (pick associative to section at 533C)
.xdata$x:000095D0 __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000095D0                                         ; DATA XREF: .xdata$x:000095E0o
.xdata$x:000095D1                 db 0FFh
.xdata$x:000095D2                 db 0FFh
.xdata$x:000095D3                 db 0FFh
.xdata$x:000095D4                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0
.xdata$x:000095D8 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000095D8                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ+11o
.xdata$x:000095D9                 db    5
.xdata$x:000095DA                 db  93h ; ô
.xdata$x:000095DB                 db  19h
.xdata$x:000095DC                 db    1
.xdata$x:000095DD                 db    0
.xdata$x:000095DE                 db    0
.xdata$x:000095DF                 db    0
.xdata$x:000095E0                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.xdata$x:000095E4                 db    0
.xdata$x:000095E5                 db    0
.xdata$x:000095E6                 db    0
.xdata$x:000095E7                 db    0
.xdata$x:000095E8                 db    0
.xdata$x:000095E9                 db    0
.xdata$x:000095EA                 db    0
.xdata$x:000095EB                 db    0
.xdata$x:000095EC                 db    0
.xdata$x:000095ED                 db    0
.xdata$x:000095EE                 db    0
.xdata$x:000095EF                 db    0
.xdata$x:000095F0                 db    0
.xdata$x:000095F1                 db    0
.xdata$x:000095F2                 db    0
.xdata$x:000095F3                 db    0
.xdata$x:000095F4                 db    0
.xdata$x:000095F5                 db    0
.xdata$x:000095F6                 db    0
.xdata$x:000095F7                 db    0
.xdata$x:000095F8                 db    0
.xdata$x:000095F9                 db    0
.xdata$x:000095FA                 db    0
.xdata$x:000095FB                 db    0
.xdata$x:000095FB _xdata$x        ends
.xdata$x:000095FB
.xdata$x:000095FC ; ===========================================================================
.xdata$x:000095FC
.xdata$x:000095FC ; Segment type: Pure data
.xdata$x:000095FC ; Segment permissions: Read
.xdata$x:000095FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000095FC                 assume cs:_xdata$x
.xdata$x:000095FC                 ;org 95FCh
.xdata$x:000095FC ; COMDAT (pick associative to section at 41C4)
.xdata$x:000095FC __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z db 0FFh
.xdata$x:000095FC                                         ; DATA XREF: .xdata$x:0000960Co
.xdata$x:000095FD                 db 0FFh
.xdata$x:000095FE                 db 0FFh
.xdata$x:000095FF                 db 0FFh
.xdata$x:00009600                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z$0
.xdata$x:00009604 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z db  22h ; "
.xdata$x:00009604                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z+11o
.xdata$x:00009605                 db    5
.xdata$x:00009606                 db  93h ; ô
.xdata$x:00009607                 db  19h
.xdata$x:00009608                 db    1
.xdata$x:00009609                 db    0
.xdata$x:0000960A                 db    0
.xdata$x:0000960B                 db    0
.xdata$x:0000960C                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z
.xdata$x:00009610                 db    0
.xdata$x:00009611                 db    0
.xdata$x:00009612                 db    0
.xdata$x:00009613                 db    0
.xdata$x:00009614                 db    0
.xdata$x:00009615                 db    0
.xdata$x:00009616                 db    0
.xdata$x:00009617                 db    0
.xdata$x:00009618                 db    0
.xdata$x:00009619                 db    0
.xdata$x:0000961A                 db    0
.xdata$x:0000961B                 db    0
.xdata$x:0000961C                 db    0
.xdata$x:0000961D                 db    0
.xdata$x:0000961E                 db    0
.xdata$x:0000961F                 db    0
.xdata$x:00009620                 db    0
.xdata$x:00009621                 db    0
.xdata$x:00009622                 db    0
.xdata$x:00009623                 db    0
.xdata$x:00009624                 db    0
.xdata$x:00009625                 db    0
.xdata$x:00009626                 db    0
.xdata$x:00009627                 db    0
.xdata$x:00009627 _xdata$x        ends
.xdata$x:00009627
.xdata$x:00009628 ; ===========================================================================
.xdata$x:00009628
.xdata$x:00009628 ; Segment type: Pure data
.xdata$x:00009628 ; Segment permissions: Read
.xdata$x:00009628 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009628                 assume cs:_xdata$x
.xdata$x:00009628                 ;org 9628h
.xdata$x:00009628 ; COMDAT (pick associative to section at 50FC)
.xdata$x:00009628 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009628                                         ; DATA XREF: .xdata$x:00009638o
.xdata$x:00009629                 db 0FFh
.xdata$x:0000962A                 db 0FFh
.xdata$x:0000962B                 db 0FFh
.xdata$x:0000962C                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009630 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009630                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009631                 db    5
.xdata$x:00009632                 db  93h ; ô
.xdata$x:00009633                 db  19h
.xdata$x:00009634                 db    1
.xdata$x:00009635                 db    0
.xdata$x:00009636                 db    0
.xdata$x:00009637                 db    0
.xdata$x:00009638                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000963C                 db    0
.xdata$x:0000963D                 db    0
.xdata$x:0000963E                 db    0
.xdata$x:0000963F                 db    0
.xdata$x:00009640                 db    0
.xdata$x:00009641                 db    0
.xdata$x:00009642                 db    0
.xdata$x:00009643                 db    0
.xdata$x:00009644                 db    0
.xdata$x:00009645                 db    0
.xdata$x:00009646                 db    0
.xdata$x:00009647                 db    0
.xdata$x:00009648                 db    0
.xdata$x:00009649                 db    0
.xdata$x:0000964A                 db    0
.xdata$x:0000964B                 db    0
.xdata$x:0000964C                 db    0
.xdata$x:0000964D                 db    0
.xdata$x:0000964E                 db    0
.xdata$x:0000964F                 db    0
.xdata$x:00009650                 db    0
.xdata$x:00009651                 db    0
.xdata$x:00009652                 db    0
.xdata$x:00009653                 db    0
.xdata$x:00009653 _xdata$x        ends
.xdata$x:00009653
.xdata$x:00009654 ; ===========================================================================
.xdata$x:00009654
.xdata$x:00009654 ; Segment type: Pure data
.xdata$x:00009654 ; Segment permissions: Read
.xdata$x:00009654 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009654                 assume cs:_xdata$x
.xdata$x:00009654                 ;org 9654h
.xdata$x:00009654 ; COMDAT (pick associative to section at 498C)
.xdata$x:00009654 __unwindtable$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009654                                         ; DATA XREF: .xdata$x:00009664o
.xdata$x:00009655                 db 0FFh
.xdata$x:00009656                 db 0FFh
.xdata$x:00009657                 db 0FFh
.xdata$x:00009658                 dd offset __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ$0
.xdata$x:0000965C __ehfuncinfo$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000965C                                         ; DATA XREF: __ehhandler$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000965D                 db    5
.xdata$x:0000965E                 db  93h ; ô
.xdata$x:0000965F                 db  19h
.xdata$x:00009660                 db    1
.xdata$x:00009661                 db    0
.xdata$x:00009662                 db    0
.xdata$x:00009663                 db    0
.xdata$x:00009664                 dd offset __unwindtable$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.xdata$x:00009668                 align 20h
.xdata$x:00009668 _xdata$x        ends
.xdata$x:00009668
.xdata$x:00009680 ; ===========================================================================
.xdata$x:00009680
.xdata$x:00009680 ; Segment type: Pure data
.xdata$x:00009680 ; Segment permissions: Read
.xdata$x:00009680 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009680                 assume cs:_xdata$x
.xdata$x:00009680                 ;org 9680h
.xdata$x:00009680 ; COMDAT (pick associative to section at 5588)
.xdata$x:00009680 __unwindtable$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009680                                         ; DATA XREF: .xdata$x:00009690o
.xdata$x:00009681                 db 0FFh
.xdata$x:00009682                 db 0FFh
.xdata$x:00009683                 db 0FFh
.xdata$x:00009684                 dd offset __unwindfunclet$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ$0
.xdata$x:00009688 __ehfuncinfo$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009688                                         ; DATA XREF: __ehhandler$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009689                 db    5
.xdata$x:0000968A                 db  93h ; ô
.xdata$x:0000968B                 db  19h
.xdata$x:0000968C                 db    1
.xdata$x:0000968D                 db    0
.xdata$x:0000968E                 db    0
.xdata$x:0000968F                 db    0
.xdata$x:00009690                 dd offset __unwindtable$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.xdata$x:00009694                 db    0
.xdata$x:00009695                 db    0
.xdata$x:00009696                 db    0
.xdata$x:00009697                 db    0
.xdata$x:00009698                 db    0
.xdata$x:00009699                 db    0
.xdata$x:0000969A                 db    0
.xdata$x:0000969B                 db    0
.xdata$x:0000969C                 db    0
.xdata$x:0000969D                 db    0
.xdata$x:0000969E                 db    0
.xdata$x:0000969F                 db    0
.xdata$x:000096A0                 db    0
.xdata$x:000096A1                 db    0
.xdata$x:000096A2                 db    0
.xdata$x:000096A3                 db    0
.xdata$x:000096A4                 db    0
.xdata$x:000096A5                 db    0
.xdata$x:000096A6                 db    0
.xdata$x:000096A7                 db    0
.xdata$x:000096A8                 db    0
.xdata$x:000096A9                 db    0
.xdata$x:000096AA                 db    0
.xdata$x:000096AB                 db    0
.xdata$x:000096AB _xdata$x        ends
.xdata$x:000096AB
.xdata$x:000096AC ; ===========================================================================
.xdata$x:000096AC
.xdata$x:000096AC ; Segment type: Pure data
.xdata$x:000096AC ; Segment permissions: Read
.xdata$x:000096AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000096AC                 assume cs:_xdata$x
.xdata$x:000096AC                 ;org 96ACh
.xdata$x:000096AC ; COMDAT (pick associative to section at 6F58)
.xdata$x:000096AC __catchsym$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:000096AC                                         ; DATA XREF: .xdata$x:000096DCo
.xdata$x:000096AD                 db    0
.xdata$x:000096AE                 db    0
.xdata$x:000096AF                 db    0
.xdata$x:000096B0                 db    0
.xdata$x:000096B1                 db    0
.xdata$x:000096B2                 db    0
.xdata$x:000096B3                 db    0
.xdata$x:000096B4                 db    0
.xdata$x:000096B5                 db    0
.xdata$x:000096B6                 db    0
.xdata$x:000096B7                 db    0
.xdata$x:000096B8                 dd offset __catch$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z$0
.xdata$x:000096BC __unwindtable$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:000096BC                                         ; DATA XREF: .xdata$x:000096E8o
.xdata$x:000096BD                 db 0FFh
.xdata$x:000096BE                 db 0FFh
.xdata$x:000096BF                 db 0FFh
.xdata$x:000096C0                 db    0
.xdata$x:000096C1                 db    0
.xdata$x:000096C2                 db    0
.xdata$x:000096C3                 db    0
.xdata$x:000096C4                 db 0FFh
.xdata$x:000096C5                 db 0FFh
.xdata$x:000096C6                 db 0FFh
.xdata$x:000096C7                 db 0FFh
.xdata$x:000096C8                 db    0
.xdata$x:000096C9                 db    0
.xdata$x:000096CA                 db    0
.xdata$x:000096CB                 db    0
.xdata$x:000096CC __tryblocktable$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z db    0
.xdata$x:000096CC                                         ; DATA XREF: .xdata$x:000096F0o
.xdata$x:000096CD                 db    0
.xdata$x:000096CE                 db    0
.xdata$x:000096CF                 db    0
.xdata$x:000096D0                 db    0
.xdata$x:000096D1                 db    0
.xdata$x:000096D2                 db    0
.xdata$x:000096D3                 db    0
.xdata$x:000096D4                 db    1
.xdata$x:000096D5                 db    0
.xdata$x:000096D6                 db    0
.xdata$x:000096D7                 db    0
.xdata$x:000096D8                 db    1
.xdata$x:000096D9                 db    0
.xdata$x:000096DA                 db    0
.xdata$x:000096DB                 db    0
.xdata$x:000096DC                 dd offset __catchsym$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z$2
.xdata$x:000096E0 __ehfuncinfo$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:000096E0                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z+11o
.xdata$x:000096E1                 db    5
.xdata$x:000096E2                 db  93h ; ô
.xdata$x:000096E3                 db  19h
.xdata$x:000096E4                 db    2
.xdata$x:000096E5                 db    0
.xdata$x:000096E6                 db    0
.xdata$x:000096E7                 db    0
.xdata$x:000096E8                 dd offset __unwindtable$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z
.xdata$x:000096EC                 db    1
.xdata$x:000096ED                 db    0
.xdata$x:000096EE                 db    0
.xdata$x:000096EF                 db    0
.xdata$x:000096F0                 dd offset __tryblocktable$?_Reallocate@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXI@Z
.xdata$x:000096F4                 db    0
.xdata$x:000096F5                 db    0
.xdata$x:000096F6                 db    0
.xdata$x:000096F7                 db    0
.xdata$x:000096F8                 db    0
.xdata$x:000096F9                 db    0
.xdata$x:000096FA                 db    0
.xdata$x:000096FB                 db    0
.xdata$x:000096FC                 db    0
.xdata$x:000096FD                 db    0
.xdata$x:000096FE                 db    0
.xdata$x:000096FF                 db    0
.xdata$x:00009700                 db    0
.xdata$x:00009701                 db    0
.xdata$x:00009702                 db    0
.xdata$x:00009703                 db    0
.xdata$x:00009703 _xdata$x        ends
.xdata$x:00009703
.xdata$x:00009704 ; ===========================================================================
.xdata$x:00009704
.xdata$x:00009704 ; Segment type: Pure data
.xdata$x:00009704 ; Segment permissions: Read
.xdata$x:00009704 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009704                 assume cs:_xdata$x
.xdata$x:00009704                 ;org 9704h
.xdata$x:00009704 ; COMDAT (pick associative to section at 6C44)
.xdata$x:00009704 __unwindtable$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z db 0FFh
.xdata$x:00009704                                         ; DATA XREF: .xdata$x:00009714o
.xdata$x:00009705                 db 0FFh
.xdata$x:00009706                 db 0FFh
.xdata$x:00009707                 db 0FFh
.xdata$x:00009708                 dd offset __unwindfunclet$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z$0
.xdata$x:0000970C __ehfuncinfo$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z db  22h ; "
.xdata$x:0000970C                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z+11o
.xdata$x:0000970D                 db    5
.xdata$x:0000970E                 db  93h ; ô
.xdata$x:0000970F                 db  19h
.xdata$x:00009710                 db    1
.xdata$x:00009711                 db    0
.xdata$x:00009712                 db    0
.xdata$x:00009713                 db    0
.xdata$x:00009714                 dd offset __unwindtable$?_Orphan_range@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXPAPAVDockingCont@@0@Z
.xdata$x:00009718                 db    0
.xdata$x:00009719                 db    0
.xdata$x:0000971A                 db    0
.xdata$x:0000971B                 db    0
.xdata$x:0000971C                 db    0
.xdata$x:0000971D                 db    0
.xdata$x:0000971E                 db    0
.xdata$x:0000971F                 db    0
.xdata$x:00009720                 db    0
.xdata$x:00009721                 db    0
.xdata$x:00009722                 db    0
.xdata$x:00009723                 db    0
.xdata$x:00009724                 db    0
.xdata$x:00009725                 db    0
.xdata$x:00009726                 db    0
.xdata$x:00009727                 db    0
.xdata$x:00009728                 db    0
.xdata$x:00009729                 db    0
.xdata$x:0000972A                 db    0
.xdata$x:0000972B                 db    0
.xdata$x:0000972C                 db    0
.xdata$x:0000972D                 db    0
.xdata$x:0000972E                 db    0
.xdata$x:0000972F                 db    0
.xdata$x:0000972F _xdata$x        ends
.xdata$x:0000972F
.xdata$x:00009730 ; ===========================================================================
.xdata$x:00009730
.xdata$x:00009730 ; Segment type: Pure data
.xdata$x:00009730 ; Segment permissions: Read
.xdata$x:00009730 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009730                 assume cs:_xdata$x
.xdata$x:00009730                 ;org 9730h
.xdata$x:00009730 ; COMDAT (pick associative to section at 457C)
.xdata$x:00009730 __unwindtable$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009730                                         ; DATA XREF: .xdata$x:00009740o
.xdata$x:00009731                 db 0FFh
.xdata$x:00009732                 db 0FFh
.xdata$x:00009733                 db 0FFh
.xdata$x:00009734                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0
.xdata$x:00009738 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009738                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009739                 db    5
.xdata$x:0000973A                 db  93h ; ô
.xdata$x:0000973B                 db  19h
.xdata$x:0000973C                 db    1
.xdata$x:0000973D                 db    0
.xdata$x:0000973E                 db    0
.xdata$x:0000973F                 db    0
.xdata$x:00009740                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.xdata$x:00009744                 db    0
.xdata$x:00009745                 db    0
.xdata$x:00009746                 db    0
.xdata$x:00009747                 db    0
.xdata$x:00009748                 db    0
.xdata$x:00009749                 db    0
.xdata$x:0000974A                 db    0
.xdata$x:0000974B                 db    0
.xdata$x:0000974C                 db    0
.xdata$x:0000974D                 db    0
.xdata$x:0000974E                 db    0
.xdata$x:0000974F                 db    0
.xdata$x:00009750                 db    0
.xdata$x:00009751                 db    0
.xdata$x:00009752                 db    0
.xdata$x:00009753                 db    0
.xdata$x:00009754                 db    0
.xdata$x:00009755                 db    0
.xdata$x:00009756                 db    0
.xdata$x:00009757                 db    0
.xdata$x:00009758                 db    0
.xdata$x:00009759                 db    0
.xdata$x:0000975A                 db    0
.xdata$x:0000975B                 db    0
.xdata$x:0000975B _xdata$x        ends
.xdata$x:0000975B
.xdata$x:0000975C ; ===========================================================================
.xdata$x:0000975C
.xdata$x:0000975C ; Segment type: Pure data
.xdata$x:0000975C ; Segment permissions: Read
.xdata$x:0000975C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000975C                 assume cs:_xdata$x
.xdata$x:0000975C                 ;org 975Ch
.xdata$x:0000975C ; COMDAT (pick associative to section at 53AC)
.xdata$x:0000975C __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000975C                                         ; DATA XREF: .xdata$x:0000976Co
.xdata$x:0000975D                 db 0FFh
.xdata$x:0000975E                 db 0FFh
.xdata$x:0000975F                 db 0FFh
.xdata$x:00009760                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0
.xdata$x:00009764 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009764                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009765                 db    5
.xdata$x:00009766                 db  93h ; ô
.xdata$x:00009767                 db  19h
.xdata$x:00009768                 db    1
.xdata$x:00009769                 db    0
.xdata$x:0000976A                 db    0
.xdata$x:0000976B                 db    0
.xdata$x:0000976C                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.xdata$x:00009770                 db    0
.xdata$x:00009771                 db    0
.xdata$x:00009772                 db    0
.xdata$x:00009773                 db    0
.xdata$x:00009774                 db    0
.xdata$x:00009775                 db    0
.xdata$x:00009776                 db    0
.xdata$x:00009777                 db    0
.xdata$x:00009778                 db    0
.xdata$x:00009779                 db    0
.xdata$x:0000977A                 db    0
.xdata$x:0000977B                 db    0
.xdata$x:0000977C                 db    0
.xdata$x:0000977D                 db    0
.xdata$x:0000977E                 db    0
.xdata$x:0000977F                 db    0
.xdata$x:00009780                 db    0
.xdata$x:00009781                 db    0
.xdata$x:00009782                 db    0
.xdata$x:00009783                 db    0
.xdata$x:00009784                 db    0
.xdata$x:00009785                 db    0
.xdata$x:00009786                 db    0
.xdata$x:00009787                 db    0
.xdata$x:00009787 _xdata$x        ends
.xdata$x:00009787
.xdata$x:00009788 ; ===========================================================================
.xdata$x:00009788
.xdata$x:00009788 ; Segment type: Pure data
.xdata$x:00009788 ; Segment permissions: Read
.xdata$x:00009788 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009788                 assume cs:_xdata$x
.xdata$x:00009788                 ;org 9788h
.xdata$x:00009788 ; COMDAT (pick associative to section at 4240)
.xdata$x:00009788 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z db 0FFh
.xdata$x:00009788                                         ; DATA XREF: .xdata$x:00009798o
.xdata$x:00009789                 db 0FFh
.xdata$x:0000978A                 db 0FFh
.xdata$x:0000978B                 db 0FFh
.xdata$x:0000978C                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z$0
.xdata$x:00009790 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z db  22h ; "
.xdata$x:00009790                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z+11o
.xdata$x:00009791                 db    5
.xdata$x:00009792                 db  93h ; ô
.xdata$x:00009793                 db  19h
.xdata$x:00009794                 db    1
.xdata$x:00009795                 db    0
.xdata$x:00009796                 db    0
.xdata$x:00009797                 db    0
.xdata$x:00009798                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingSplitter@@@1@@Z
.xdata$x:0000979C                 db    0
.xdata$x:0000979D                 db    0
.xdata$x:0000979E                 db    0
.xdata$x:0000979F                 db    0
.xdata$x:000097A0                 db    0
.xdata$x:000097A1                 db    0
.xdata$x:000097A2                 db    0
.xdata$x:000097A3                 db    0
.xdata$x:000097A4                 db    0
.xdata$x:000097A5                 db    0
.xdata$x:000097A6                 db    0
.xdata$x:000097A7                 db    0
.xdata$x:000097A8                 db    0
.xdata$x:000097A9                 db    0
.xdata$x:000097AA                 db    0
.xdata$x:000097AB                 db    0
.xdata$x:000097AC                 db    0
.xdata$x:000097AD                 db    0
.xdata$x:000097AE                 db    0
.xdata$x:000097AF                 db    0
.xdata$x:000097B0                 db    0
.xdata$x:000097B1                 db    0
.xdata$x:000097B2                 db    0
.xdata$x:000097B3                 db    0
.xdata$x:000097B3 _xdata$x        ends
.xdata$x:000097B3
.xdata$x:000097B4 ; ===========================================================================
.xdata$x:000097B4
.xdata$x:000097B4 ; Segment type: Pure data
.xdata$x:000097B4 ; Segment permissions: Read
.xdata$x:000097B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000097B4                 assume cs:_xdata$x
.xdata$x:000097B4                 ;org 97B4h
.xdata$x:000097B4 ; COMDAT (pick associative to section at 5174)
.xdata$x:000097B4 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000097B4                                         ; DATA XREF: .xdata$x:000097C4o
.xdata$x:000097B5                 db 0FFh
.xdata$x:000097B6                 db 0FFh
.xdata$x:000097B7                 db 0FFh
.xdata$x:000097B8                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000097BC __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000097BC                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000097BD                 db    5
.xdata$x:000097BE                 db  93h ; ô
.xdata$x:000097BF                 db  19h
.xdata$x:000097C0                 db    1
.xdata$x:000097C1                 db    0
.xdata$x:000097C2                 db    0
.xdata$x:000097C3                 db    0
.xdata$x:000097C4                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@@std@@QAE@XZ
.xdata$x:000097C8                 align 20h
.xdata$x:000097C8 _xdata$x        ends
.xdata$x:000097C8
.xdata$x:000097E0 ; ===========================================================================
.xdata$x:000097E0
.xdata$x:000097E0 ; Segment type: Pure data
.xdata$x:000097E0 ; Segment permissions: Read
.xdata$x:000097E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000097E0                 assume cs:_xdata$x
.xdata$x:000097E0                 ;org 97E0h
.xdata$x:000097E0 ; COMDAT (pick associative to section at 4A0C)
.xdata$x:000097E0 __unwindtable$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000097E0                                         ; DATA XREF: .xdata$x:000097F0o
.xdata$x:000097E1                 db 0FFh
.xdata$x:000097E2                 db 0FFh
.xdata$x:000097E3                 db 0FFh
.xdata$x:000097E4                 dd offset __unwindfunclet$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0
.xdata$x:000097E8 __ehfuncinfo$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000097E8                                         ; DATA XREF: __ehhandler$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ+11o
.xdata$x:000097E9                 db    5
.xdata$x:000097EA                 db  93h ; ô
.xdata$x:000097EB                 db  19h
.xdata$x:000097EC                 db    1
.xdata$x:000097ED                 db    0
.xdata$x:000097EE                 db    0
.xdata$x:000097EF                 db    0
.xdata$x:000097F0                 dd offset __unwindtable$??0?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.xdata$x:000097F4                 db    0
.xdata$x:000097F5                 db    0
.xdata$x:000097F6                 db    0
.xdata$x:000097F7                 db    0
.xdata$x:000097F8                 db    0
.xdata$x:000097F9                 db    0
.xdata$x:000097FA                 db    0
.xdata$x:000097FB                 db    0
.xdata$x:000097FC                 db    0
.xdata$x:000097FD                 db    0
.xdata$x:000097FE                 db    0
.xdata$x:000097FF                 db    0
.xdata$x:00009800                 db    0
.xdata$x:00009801                 db    0
.xdata$x:00009802                 db    0
.xdata$x:00009803                 db    0
.xdata$x:00009804                 db    0
.xdata$x:00009805                 db    0
.xdata$x:00009806                 db    0
.xdata$x:00009807                 db    0
.xdata$x:00009808                 db    0
.xdata$x:00009809                 db    0
.xdata$x:0000980A                 db    0
.xdata$x:0000980B                 db    0
.xdata$x:0000980B _xdata$x        ends
.xdata$x:0000980B
.xdata$x:0000980C ; ===========================================================================
.xdata$x:0000980C
.xdata$x:0000980C ; Segment type: Pure data
.xdata$x:0000980C ; Segment permissions: Read
.xdata$x:0000980C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000980C                 assume cs:_xdata$x
.xdata$x:0000980C                 ;org 980Ch
.xdata$x:0000980C ; COMDAT (pick associative to section at 5600)
.xdata$x:0000980C __unwindtable$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000980C                                         ; DATA XREF: .xdata$x:0000981Co
.xdata$x:0000980D                 db 0FFh
.xdata$x:0000980E                 db 0FFh
.xdata$x:0000980F                 db 0FFh
.xdata$x:00009810                 dd offset __unwindfunclet$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ$0
.xdata$x:00009814 __ehfuncinfo$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009814                                         ; DATA XREF: __ehhandler$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009815                 db    5
.xdata$x:00009816                 db  93h ; ô
.xdata$x:00009817                 db  19h
.xdata$x:00009818                 db    1
.xdata$x:00009819                 db    0
.xdata$x:0000981A                 db    0
.xdata$x:0000981B                 db    0
.xdata$x:0000981C                 dd offset __unwindtable$??1?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@QAE@XZ
.xdata$x:00009820                 db    0
.xdata$x:00009821                 db    0
.xdata$x:00009822                 db    0
.xdata$x:00009823                 db    0
.xdata$x:00009824                 db    0
.xdata$x:00009825                 db    0
.xdata$x:00009826                 db    0
.xdata$x:00009827                 db    0
.xdata$x:00009828                 db    0
.xdata$x:00009829                 db    0
.xdata$x:0000982A                 db    0
.xdata$x:0000982B                 db    0
.xdata$x:0000982C                 db    0
.xdata$x:0000982D                 db    0
.xdata$x:0000982E                 db    0
.xdata$x:0000982F                 db    0
.xdata$x:00009830                 db    0
.xdata$x:00009831                 db    0
.xdata$x:00009832                 db    0
.xdata$x:00009833                 db    0
.xdata$x:00009834                 db    0
.xdata$x:00009835                 db    0
.xdata$x:00009836                 db    0
.xdata$x:00009837                 db    0
.xdata$x:00009837 _xdata$x        ends
.xdata$x:00009837
.xdata$x:00009838 ; ===========================================================================
.xdata$x:00009838
.xdata$x:00009838 ; Segment type: Pure data
.xdata$x:00009838 ; Segment permissions: Read
.xdata$x:00009838 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009838                 assume cs:_xdata$x
.xdata$x:00009838                 ;org 9838h
.xdata$x:00009838 ; COMDAT (pick associative to section at 70B4)
.xdata$x:00009838 __catchsym$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00009838                                         ; DATA XREF: .xdata$x:00009868o
.xdata$x:00009839                 db    0
.xdata$x:0000983A                 db    0
.xdata$x:0000983B                 db    0
.xdata$x:0000983C                 db    0
.xdata$x:0000983D                 db    0
.xdata$x:0000983E                 db    0
.xdata$x:0000983F                 db    0
.xdata$x:00009840                 db    0
.xdata$x:00009841                 db    0
.xdata$x:00009842                 db    0
.xdata$x:00009843                 db    0
.xdata$x:00009844                 dd offset __catch$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z$0
.xdata$x:00009848 __unwindtable$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00009848                                         ; DATA XREF: .xdata$x:00009874o
.xdata$x:00009849                 db 0FFh
.xdata$x:0000984A                 db 0FFh
.xdata$x:0000984B                 db 0FFh
.xdata$x:0000984C                 db    0
.xdata$x:0000984D                 db    0
.xdata$x:0000984E                 db    0
.xdata$x:0000984F                 db    0
.xdata$x:00009850                 db 0FFh
.xdata$x:00009851                 db 0FFh
.xdata$x:00009852                 db 0FFh
.xdata$x:00009853                 db 0FFh
.xdata$x:00009854                 db    0
.xdata$x:00009855                 db    0
.xdata$x:00009856                 db    0
.xdata$x:00009857                 db    0
.xdata$x:00009858 __tryblocktable$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z db    0
.xdata$x:00009858                                         ; DATA XREF: .xdata$x:0000987Co
.xdata$x:00009859                 db    0
.xdata$x:0000985A                 db    0
.xdata$x:0000985B                 db    0
.xdata$x:0000985C                 db    0
.xdata$x:0000985D                 db    0
.xdata$x:0000985E                 db    0
.xdata$x:0000985F                 db    0
.xdata$x:00009860                 db    1
.xdata$x:00009861                 db    0
.xdata$x:00009862                 db    0
.xdata$x:00009863                 db    0
.xdata$x:00009864                 db    1
.xdata$x:00009865                 db    0
.xdata$x:00009866                 db    0
.xdata$x:00009867                 db    0
.xdata$x:00009868                 dd offset __catchsym$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z$2
.xdata$x:0000986C __ehfuncinfo$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000986C                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z+11o
.xdata$x:0000986D                 db    5
.xdata$x:0000986E                 db  93h ; ô
.xdata$x:0000986F                 db  19h
.xdata$x:00009870                 db    2
.xdata$x:00009871                 db    0
.xdata$x:00009872                 db    0
.xdata$x:00009873                 db    0
.xdata$x:00009874                 dd offset __unwindtable$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z
.xdata$x:00009878                 db    1
.xdata$x:00009879                 db    0
.xdata$x:0000987A                 db    0
.xdata$x:0000987B                 db    0
.xdata$x:0000987C                 dd offset __tryblocktable$?_Reallocate@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IAEXI@Z
.xdata$x:00009880                 db    0
.xdata$x:00009881                 db    0
.xdata$x:00009882                 db    0
.xdata$x:00009883                 db    0
.xdata$x:00009884                 db    0
.xdata$x:00009885                 db    0
.xdata$x:00009886                 db    0
.xdata$x:00009887                 db    0
.xdata$x:00009888                 db    0
.xdata$x:00009889                 db    0
.xdata$x:0000988A                 db    0
.xdata$x:0000988B                 db    0
.xdata$x:0000988C                 db    0
.xdata$x:0000988D                 db    0
.xdata$x:0000988E                 db    0
.xdata$x:0000988F                 db    0
.xdata$x:0000988F _xdata$x        ends
.xdata$x:0000988F
.xdata$x:00009890 ; ===========================================================================
.xdata$x:00009890
.xdata$x:00009890 ; Segment type: Pure data
.xdata$x:00009890 ; Segment permissions: Read
.xdata$x:00009890 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009890                 assume cs:_xdata$x
.xdata$x:00009890                 ;org 9890h
.xdata$x:00009890 ; COMDAT (pick associative to section at 6D20)
.xdata$x:00009890 __unwindtable$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z db 0FFh
.xdata$x:00009890                                         ; DATA XREF: .xdata$x:000098A0o
.xdata$x:00009891                 db 0FFh
.xdata$x:00009892                 db 0FFh
.xdata$x:00009893                 db 0FFh
.xdata$x:00009894                 dd offset __unwindfunclet$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z$0
.xdata$x:00009898 __ehfuncinfo$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z db  22h ; "
.xdata$x:00009898                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z+11o
.xdata$x:00009899                 db    5
.xdata$x:0000989A                 db  93h ; ô
.xdata$x:0000989B                 db  19h
.xdata$x:0000989C                 db    1
.xdata$x:0000989D                 db    0
.xdata$x:0000989E                 db    0
.xdata$x:0000989F                 db    0
.xdata$x:000098A0                 dd offset __unwindtable$?_Orphan_range@?$vector@PAVDockingSplitter@@V?$allocator@PAVDockingSplitter@@@std@@@std@@IBEXPAPAVDockingSplitter@@0@Z
.xdata$x:000098A4                 db    0
.xdata$x:000098A5                 db    0
.xdata$x:000098A6                 db    0
.xdata$x:000098A7                 db    0
.xdata$x:000098A8                 db    0
.xdata$x:000098A9                 db    0
.xdata$x:000098AA                 db    0
.xdata$x:000098AB                 db    0
.xdata$x:000098AC                 db    0
.xdata$x:000098AD                 db    0
.xdata$x:000098AE                 db    0
.xdata$x:000098AF                 db    0
.xdata$x:000098B0                 db    0
.xdata$x:000098B1                 db    0
.xdata$x:000098B2                 db    0
.xdata$x:000098B3                 db    0
.xdata$x:000098B4                 db    0
.xdata$x:000098B5                 db    0
.xdata$x:000098B6                 db    0
.xdata$x:000098B7                 db    0
.xdata$x:000098B8                 db    0
.xdata$x:000098B9                 db    0
.xdata$x:000098BA                 db    0
.xdata$x:000098BB                 db    0
.xdata$x:000098BB _xdata$x        ends
.xdata$x:000098BB
.xdata$x:000098BC ; ===========================================================================
.xdata$x:000098BC
.xdata$x:000098BC ; Segment type: Pure data
.xdata$x:000098BC ; Segment permissions: Read
.xdata$x:000098BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000098BC                 assume cs:_xdata$x
.xdata$x:000098BC                 ;org 98BCh
.xdata$x:000098BC ; COMDAT (pick associative to section at 4A8C)
.xdata$x:000098BC __unwindtable$??0DockingSplitter@@QAE@XZ db 0FFh
.xdata$x:000098BC                                         ; DATA XREF: .xdata$x:000098CCo
.xdata$x:000098BD                 db 0FFh
.xdata$x:000098BE                 db 0FFh
.xdata$x:000098BF                 db 0FFh
.xdata$x:000098C0                 dd offset __unwindfunclet$??0DockingSplitter@@QAE@XZ$0
.xdata$x:000098C4 __ehfuncinfo$??0DockingSplitter@@QAE@XZ db  22h ; "
.xdata$x:000098C4                                         ; DATA XREF: __ehhandler$??0DockingSplitter@@QAE@XZ+11o
.xdata$x:000098C5                 db    5
.xdata$x:000098C6                 db  93h ; ô
.xdata$x:000098C7                 db  19h
.xdata$x:000098C8                 db    1
.xdata$x:000098C9                 db    0
.xdata$x:000098CA                 db    0
.xdata$x:000098CB                 db    0
.xdata$x:000098CC                 dd offset __unwindtable$??0DockingSplitter@@QAE@XZ
.xdata$x:000098D0                 db    0
.xdata$x:000098D1                 db    0
.xdata$x:000098D2                 db    0
.xdata$x:000098D3                 db    0
.xdata$x:000098D4                 db    0
.xdata$x:000098D5                 db    0
.xdata$x:000098D6                 db    0
.xdata$x:000098D7                 db    0
.xdata$x:000098D8                 db    0
.xdata$x:000098D9                 db    0
.xdata$x:000098DA                 db    0
.xdata$x:000098DB                 db    0
.xdata$x:000098DC                 db    0
.xdata$x:000098DD                 db    0
.xdata$x:000098DE                 db    0
.xdata$x:000098DF                 db    0
.xdata$x:000098E0                 db    0
.xdata$x:000098E1                 db    0
.xdata$x:000098E2                 db    0
.xdata$x:000098E3                 db    0
.xdata$x:000098E4                 db    0
.xdata$x:000098E5                 db    0
.xdata$x:000098E6                 db    0
.xdata$x:000098E7                 db    0
.xdata$x:000098E7 _xdata$x        ends
.xdata$x:000098E7
.xdata$x:000098E8 ; ===========================================================================
.xdata$x:000098E8
.xdata$x:000098E8 ; Segment type: Pure data
.xdata$x:000098E8 ; Segment permissions: Read
.xdata$x:000098E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000098E8                 assume cs:_xdata$x
.xdata$x:000098E8                 ;org 98E8h
.xdata$x:000098E8 ; COMDAT (pick associative to section at 5678)
.xdata$x:000098E8 __unwindtable$??1DockingSplitter@@UAE@XZ db 0FFh
.xdata$x:000098E8                                         ; DATA XREF: .xdata$x:000098F8o
.xdata$x:000098E9                 db 0FFh
.xdata$x:000098EA                 db 0FFh
.xdata$x:000098EB                 db 0FFh
.xdata$x:000098EC                 dd offset __unwindfunclet$??1DockingSplitter@@UAE@XZ$0
.xdata$x:000098F0 __ehfuncinfo$??1DockingSplitter@@UAE@XZ db  22h ; "
.xdata$x:000098F0                                         ; DATA XREF: __ehhandler$??1DockingSplitter@@UAE@XZ+11o
.xdata$x:000098F1                 db    5
.xdata$x:000098F2                 db  93h ; ô
.xdata$x:000098F3                 db  19h
.xdata$x:000098F4                 db    1
.xdata$x:000098F5                 db    0
.xdata$x:000098F6                 db    0
.xdata$x:000098F7                 db    0
.xdata$x:000098F8                 dd offset __unwindtable$??1DockingSplitter@@UAE@XZ
.xdata$x:000098FC                 db    0
.xdata$x:000098FD                 db    0
.xdata$x:000098FE                 db    0
.xdata$x:000098FF                 db    0
.xdata$x:00009900                 db    0
.xdata$x:00009901                 db    0
.xdata$x:00009902                 db    0
.xdata$x:00009903                 db    0
.xdata$x:00009904                 db    0
.xdata$x:00009905                 db    0
.xdata$x:00009906                 db    0
.xdata$x:00009907                 db    0
.xdata$x:00009908                 db    0
.xdata$x:00009909                 db    0
.xdata$x:0000990A                 db    0
.xdata$x:0000990B                 db    0
.xdata$x:0000990C                 db    0
.xdata$x:0000990D                 db    0
.xdata$x:0000990E                 db    0
.xdata$x:0000990F                 db    0
.xdata$x:00009910                 db    0
.xdata$x:00009911                 db    0
.xdata$x:00009912                 db    0
.xdata$x:00009913                 db    0
.xdata$x:00009913 _xdata$x        ends
.xdata$x:00009913
.xdata$x:00009914 ; ===========================================================================
.xdata$x:00009914
.xdata$x:00009914 ; Segment type: Pure data
.xdata$x:00009914 ; Segment permissions: Read
.xdata$x:00009914 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009914                 assume cs:_xdata$x
.xdata$x:00009914                 ;org 9914h
.xdata$x:00009914 ; COMDAT (pick associative to section at 3F54)
.xdata$x:00009914 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009914                                         ; DATA XREF: .xdata$x:00009924o
.xdata$x:00009915                 db 0FFh
.xdata$x:00009916                 db 0FFh
.xdata$x:00009917                 db 0FFh
.xdata$x:00009918                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:0000991C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000991C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:0000991D                 db    5
.xdata$x:0000991E                 db  93h ; ô
.xdata$x:0000991F                 db  19h
.xdata$x:00009920                 db    1
.xdata$x:00009921                 db    0
.xdata$x:00009922                 db    0
.xdata$x:00009923                 db    0
.xdata$x:00009924                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00009928                 align 20h
.xdata$x:00009928 _xdata$x        ends
.xdata$x:00009928
.xdata$x:00009940 ; ===========================================================================
.xdata$x:00009940
.xdata$x:00009940 ; Segment type: Pure data
.xdata$x:00009940 ; Segment permissions: Read
.xdata$x:00009940 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009940                 assume cs:_xdata$x
.xdata$x:00009940                 ;org 9940h
.xdata$x:00009940 ; COMDAT (pick associative to section at 4EB4)
.xdata$x:00009940 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009940                                         ; DATA XREF: .xdata$x:00009950o
.xdata$x:00009941                 db 0FFh
.xdata$x:00009942                 db 0FFh
.xdata$x:00009943                 db 0FFh
.xdata$x:00009944                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00009948 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009948                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00009949                 db    5
.xdata$x:0000994A                 db  93h ; ô
.xdata$x:0000994B                 db  19h
.xdata$x:0000994C                 db    1
.xdata$x:0000994D                 db    0
.xdata$x:0000994E                 db    0
.xdata$x:0000994F                 db    0
.xdata$x:00009950                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00009954                 db    0
.xdata$x:00009955                 db    0
.xdata$x:00009956                 db    0
.xdata$x:00009957                 db    0
.xdata$x:00009958                 db    0
.xdata$x:00009959                 db    0
.xdata$x:0000995A                 db    0
.xdata$x:0000995B                 db    0
.xdata$x:0000995C                 db    0
.xdata$x:0000995D                 db    0
.xdata$x:0000995E                 db    0
.xdata$x:0000995F                 db    0
.xdata$x:00009960                 db    0
.xdata$x:00009961                 db    0
.xdata$x:00009962                 db    0
.xdata$x:00009963                 db    0
.xdata$x:00009964                 db    0
.xdata$x:00009965                 db    0
.xdata$x:00009966                 db    0
.xdata$x:00009967                 db    0
.xdata$x:00009968                 db    0
.xdata$x:00009969                 db    0
.xdata$x:0000996A                 db    0
.xdata$x:0000996B                 db    0
.xdata$x:0000996B _xdata$x        ends
.xdata$x:0000996B
.xdata$x:0000996C ; ===========================================================================
.xdata$x:0000996C
.xdata$x:0000996C ; Segment type: Pure data
.xdata$x:0000996C ; Segment permissions: Read
.xdata$x:0000996C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000996C                 assume cs:_xdata$x
.xdata$x:0000996C                 ;org 996Ch
.xdata$x:0000996C ; COMDAT (pick associative to section at 3EDC)
.xdata$x:0000996C __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:0000996C                                         ; DATA XREF: .xdata$x:0000997Co
.xdata$x:0000996D                 db 0FFh
.xdata$x:0000996E                 db 0FFh
.xdata$x:0000996F                 db 0FFh
.xdata$x:00009970                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:00009974 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00009974                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:00009975                 db    5
.xdata$x:00009976                 db  93h ; ô
.xdata$x:00009977                 db  19h
.xdata$x:00009978                 db    1
.xdata$x:00009979                 db    0
.xdata$x:0000997A                 db    0
.xdata$x:0000997B                 db    0
.xdata$x:0000997C                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAUtTbData@@HPBQAU3@ABQAU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:00009980                 db    0
.xdata$x:00009981                 db    0
.xdata$x:00009982                 db    0
.xdata$x:00009983                 db    0
.xdata$x:00009984                 db    0
.xdata$x:00009985                 db    0
.xdata$x:00009986                 db    0
.xdata$x:00009987                 db    0
.xdata$x:00009988                 db    0
.xdata$x:00009989                 db    0
.xdata$x:0000998A                 db    0
.xdata$x:0000998B                 db    0
.xdata$x:0000998C                 db    0
.xdata$x:0000998D                 db    0
.xdata$x:0000998E                 db    0
.xdata$x:0000998F                 db    0
.xdata$x:00009990                 db    0
.xdata$x:00009991                 db    0
.xdata$x:00009992                 db    0
.xdata$x:00009993                 db    0
.xdata$x:00009994                 db    0
.xdata$x:00009995                 db    0
.xdata$x:00009996                 db    0
.xdata$x:00009997                 db    0
.xdata$x:00009997 _xdata$x        ends
.xdata$x:00009997
.xdata$x:00009998 ; ===========================================================================
.xdata$x:00009998
.xdata$x:00009998 ; Segment type: Pure data
.xdata$x:00009998 ; Segment permissions: Read
.xdata$x:00009998 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009998                 assume cs:_xdata$x
.xdata$x:00009998                 ;org 9998h
.xdata$x:00009998 ; COMDAT (pick associative to section at 4340)
.xdata$x:00009998 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:00009998                                         ; DATA XREF: .xdata$x:000099A8o
.xdata$x:00009999                 db 0FFh
.xdata$x:0000999A                 db 0FFh
.xdata$x:0000999B                 db 0FFh
.xdata$x:0000999C                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z$0
.xdata$x:000099A0 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:000099A0                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z+11o
.xdata$x:000099A1                 db    5
.xdata$x:000099A2                 db  93h ; ô
.xdata$x:000099A3                 db  19h
.xdata$x:000099A4                 db    1
.xdata$x:000099A5                 db    0
.xdata$x:000099A6                 db    0
.xdata$x:000099A7                 db    0
.xdata$x:000099A8                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@PAPAUtTbData@@PBU_Container_base12@1@@Z
.xdata$x:000099AC                 db    0
.xdata$x:000099AD                 db    0
.xdata$x:000099AE                 db    0
.xdata$x:000099AF                 db    0
.xdata$x:000099B0                 db    0
.xdata$x:000099B1                 db    0
.xdata$x:000099B2                 db    0
.xdata$x:000099B3                 db    0
.xdata$x:000099B4                 db    0
.xdata$x:000099B5                 db    0
.xdata$x:000099B6                 db    0
.xdata$x:000099B7                 db    0
.xdata$x:000099B8                 db    0
.xdata$x:000099B9                 db    0
.xdata$x:000099BA                 db    0
.xdata$x:000099BB                 db    0
.xdata$x:000099BC                 db    0
.xdata$x:000099BD                 db    0
.xdata$x:000099BE                 db    0
.xdata$x:000099BF                 db    0
.xdata$x:000099C0                 db    0
.xdata$x:000099C1                 db    0
.xdata$x:000099C2                 db    0
.xdata$x:000099C3                 db    0
.xdata$x:000099C3 _xdata$x        ends
.xdata$x:000099C3
.xdata$x:000099C4 ; ===========================================================================
.xdata$x:000099C4
.xdata$x:000099C4 ; Segment type: Pure data
.xdata$x:000099C4 ; Segment permissions: Read
.xdata$x:000099C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000099C4                 assume cs:_xdata$x
.xdata$x:000099C4                 ;org 99C4h
.xdata$x:000099C4 ; COMDAT (pick associative to section at 51EC)
.xdata$x:000099C4 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000099C4                                         ; DATA XREF: .xdata$x:000099D4o
.xdata$x:000099C5                 db 0FFh
.xdata$x:000099C6                 db 0FFh
.xdata$x:000099C7                 db 0FFh
.xdata$x:000099C8                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000099CC __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000099CC                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000099CD                 db    5
.xdata$x:000099CE                 db  93h ; ô
.xdata$x:000099CF                 db  19h
.xdata$x:000099D0                 db    1
.xdata$x:000099D1                 db    0
.xdata$x:000099D2                 db    0
.xdata$x:000099D3                 db    0
.xdata$x:000099D4                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@XZ
.xdata$x:000099D8                 db    0
.xdata$x:000099D9                 db    0
.xdata$x:000099DA                 db    0
.xdata$x:000099DB                 db    0
.xdata$x:000099DC                 db    0
.xdata$x:000099DD                 db    0
.xdata$x:000099DE                 db    0
.xdata$x:000099DF                 db    0
.xdata$x:000099E0                 db    0
.xdata$x:000099E1                 db    0
.xdata$x:000099E2                 db    0
.xdata$x:000099E3                 db    0
.xdata$x:000099E4                 db    0
.xdata$x:000099E5                 db    0
.xdata$x:000099E6                 db    0
.xdata$x:000099E7                 db    0
.xdata$x:000099E8                 db    0
.xdata$x:000099E9                 db    0
.xdata$x:000099EA                 db    0
.xdata$x:000099EB                 db    0
.xdata$x:000099EC                 db    0
.xdata$x:000099ED                 db    0
.xdata$x:000099EE                 db    0
.xdata$x:000099EF                 db    0
.xdata$x:000099EF _xdata$x        ends
.xdata$x:000099EF
.xdata$x:000099F0 ; ===========================================================================
.xdata$x:000099F0
.xdata$x:000099F0 ; Segment type: Pure data
.xdata$x:000099F0 ; Segment permissions: Read
.xdata$x:000099F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000099F0                 assume cs:_xdata$x
.xdata$x:000099F0                 ;org 99F0h
.xdata$x:000099F0 ; COMDAT (pick associative to section at 42BC)
.xdata$x:000099F0 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000099F0                                         ; DATA XREF: .xdata$x:00009A00o
.xdata$x:000099F1                 db 0FFh
.xdata$x:000099F2                 db 0FFh
.xdata$x:000099F3                 db 0FFh
.xdata$x:000099F4                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:000099F8 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000099F8                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:000099F9                 db    5
.xdata$x:000099FA                 db  93h ; ô
.xdata$x:000099FB                 db  19h
.xdata$x:000099FC                 db    1
.xdata$x:000099FD                 db    0
.xdata$x:000099FE                 db    0
.xdata$x:000099FF                 db    0
.xdata$x:00009A00                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009A04                 db    0
.xdata$x:00009A05                 db    0
.xdata$x:00009A06                 db    0
.xdata$x:00009A07                 db    0
.xdata$x:00009A08                 db    0
.xdata$x:00009A09                 db    0
.xdata$x:00009A0A                 db    0
.xdata$x:00009A0B                 db    0
.xdata$x:00009A0C                 db    0
.xdata$x:00009A0D                 db    0
.xdata$x:00009A0E                 db    0
.xdata$x:00009A0F                 db    0
.xdata$x:00009A10                 db    0
.xdata$x:00009A11                 db    0
.xdata$x:00009A12                 db    0
.xdata$x:00009A13                 db    0
.xdata$x:00009A14                 db    0
.xdata$x:00009A15                 db    0
.xdata$x:00009A16                 db    0
.xdata$x:00009A17                 db    0
.xdata$x:00009A18                 db    0
.xdata$x:00009A19                 db    0
.xdata$x:00009A1A                 db    0
.xdata$x:00009A1B                 db    0
.xdata$x:00009A1B _xdata$x        ends
.xdata$x:00009A1B
.xdata$x:00009A1C ; ===========================================================================
.xdata$x:00009A1C
.xdata$x:00009A1C ; Segment type: Pure data
.xdata$x:00009A1C ; Segment permissions: Read
.xdata$x:00009A1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A1C                 assume cs:_xdata$x
.xdata$x:00009A1C                 ;org 9A1Ch
.xdata$x:00009A1C ; COMDAT (pick associative to section at 311C)
.xdata$x:00009A1C __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z db 0FFh
.xdata$x:00009A1C                                         ; DATA XREF: .xdata$x:00009A44o
.xdata$x:00009A1D                 db 0FFh
.xdata$x:00009A1E                 db 0FFh
.xdata$x:00009A1F                 db 0FFh
.xdata$x:00009A20                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$0
.xdata$x:00009A24                 align 8
.xdata$x:00009A28                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$1
.xdata$x:00009A2C                 db    1
.xdata$x:00009A2D                 db    0
.xdata$x:00009A2E                 db    0
.xdata$x:00009A2F                 db    0
.xdata$x:00009A30                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$2
.xdata$x:00009A34                 db    2
.xdata$x:00009A35                 db    0
.xdata$x:00009A36                 db    0
.xdata$x:00009A37                 db    0
.xdata$x:00009A38                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z$3
.xdata$x:00009A3C __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z db  22h ; "
.xdata$x:00009A3C                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z+11o
.xdata$x:00009A3D                 db    5
.xdata$x:00009A3E                 db  93h ; ô
.xdata$x:00009A3F                 db  19h
.xdata$x:00009A40                 db    4
.xdata$x:00009A41                 db    0
.xdata$x:00009A42                 db    0
.xdata$x:00009A43                 db    0
.xdata$x:00009A44                 dd offset __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@@?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@IAEPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@1@0PAPAU2@@Z
.xdata$x:00009A48                 align 20h
.xdata$x:00009A48 _xdata$x        ends
.xdata$x:00009A48
.xdata$x:00009A60 ; ===========================================================================
.xdata$x:00009A60
.xdata$x:00009A60 ; Segment type: Pure data
.xdata$x:00009A60 ; Segment permissions: Read
.xdata$x:00009A60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A60                 assume cs:_xdata$x
.xdata$x:00009A60                 ;org 9A60h
.xdata$x:00009A60 ; COMDAT (pick associative to section at 3D3C)
.xdata$x:00009A60 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00009A60                                         ; DATA XREF: .xdata$x:00009A70o
.xdata$x:00009A61                 db 0FFh
.xdata$x:00009A62                 db 0FFh
.xdata$x:00009A63                 db 0FFh
.xdata$x:00009A64                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00009A68 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00009A68                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00009A69                 db    5
.xdata$x:00009A6A                 db  93h ; ô
.xdata$x:00009A6B                 db  19h
.xdata$x:00009A6C                 db    1
.xdata$x:00009A6D                 db    0
.xdata$x:00009A6E                 db    0
.xdata$x:00009A6F                 db    0
.xdata$x:00009A70                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00009A74                 db    0
.xdata$x:00009A75                 db    0
.xdata$x:00009A76                 db    0
.xdata$x:00009A77                 db    0
.xdata$x:00009A78                 db    0
.xdata$x:00009A79                 db    0
.xdata$x:00009A7A                 db    0
.xdata$x:00009A7B                 db    0
.xdata$x:00009A7C                 db    0
.xdata$x:00009A7D                 db    0
.xdata$x:00009A7E                 db    0
.xdata$x:00009A7F                 db    0
.xdata$x:00009A80                 db    0
.xdata$x:00009A81                 db    0
.xdata$x:00009A82                 db    0
.xdata$x:00009A83                 db    0
.xdata$x:00009A84                 db    0
.xdata$x:00009A85                 db    0
.xdata$x:00009A86                 db    0
.xdata$x:00009A87                 db    0
.xdata$x:00009A88                 db    0
.xdata$x:00009A89                 db    0
.xdata$x:00009A8A                 db    0
.xdata$x:00009A8B                 db    0
.xdata$x:00009A8B _xdata$x        ends
.xdata$x:00009A8B
.xdata$x:00009A8C ; ===========================================================================
.xdata$x:00009A8C
.xdata$x:00009A8C ; Segment type: Pure data
.xdata$x:00009A8C ; Segment permissions: Read
.xdata$x:00009A8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A8C                 assume cs:_xdata$x
.xdata$x:00009A8C                 ;org 9A8Ch
.xdata$x:00009A8C ; COMDAT (pick associative to section at 35F4)
.xdata$x:00009A8C __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z db 0FFh
.xdata$x:00009A8C                                         ; DATA XREF: .xdata$x:00009AB4o
.xdata$x:00009A8D                 db 0FFh
.xdata$x:00009A8E                 db 0FFh
.xdata$x:00009A8F                 db 0FFh
.xdata$x:00009A90                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$0
.xdata$x:00009A94                 align 8
.xdata$x:00009A98                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$1
.xdata$x:00009A9C                 db    1
.xdata$x:00009A9D                 db    0
.xdata$x:00009A9E                 db    0
.xdata$x:00009A9F                 db    0
.xdata$x:00009AA0                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$2
.xdata$x:00009AA4                 db    1
.xdata$x:00009AA5                 db    0
.xdata$x:00009AA6                 db    0
.xdata$x:00009AA7                 db    0
.xdata$x:00009AA8                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z$3
.xdata$x:00009AAC __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z db  22h ; "
.xdata$x:00009AAC                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z+11o
.xdata$x:00009AAD                 db    5
.xdata$x:00009AAE                 db  93h ; ô
.xdata$x:00009AAF                 db  19h
.xdata$x:00009AB0                 db    4
.xdata$x:00009AB1                 db    0
.xdata$x:00009AB2                 db    0
.xdata$x:00009AB3                 db    0
.xdata$x:00009AB4                 dd offset __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@PAPAUtTbData@@U?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@2@@std@@YAPAPAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@0PAPAU1@AAU?$_Wrap_alloc@V?$allocator@PAUtTbData@@@std@@@0@@Z
.xdata$x:00009AB8                 db    0
.xdata$x:00009AB9                 db    0
.xdata$x:00009ABA                 db    0
.xdata$x:00009ABB                 db    0
.xdata$x:00009ABC                 db    0
.xdata$x:00009ABD                 db    0
.xdata$x:00009ABE                 db    0
.xdata$x:00009ABF                 db    0
.xdata$x:00009AC0                 db    0
.xdata$x:00009AC1                 db    0
.xdata$x:00009AC2                 db    0
.xdata$x:00009AC3                 db    0
.xdata$x:00009AC4                 db    0
.xdata$x:00009AC5                 db    0
.xdata$x:00009AC6                 db    0
.xdata$x:00009AC7                 db    0
.xdata$x:00009AC8                 db    0
.xdata$x:00009AC9                 db    0
.xdata$x:00009ACA                 db    0
.xdata$x:00009ACB                 db    0
.xdata$x:00009ACC                 db    0
.xdata$x:00009ACD                 db    0
.xdata$x:00009ACE                 db    0
.xdata$x:00009ACF                 db    0
.xdata$x:00009ACF _xdata$x        ends
.xdata$x:00009ACF
.xdata$x:00009AD0 ; ===========================================================================
.xdata$x:00009AD0
.xdata$x:00009AD0 ; Segment type: Pure data
.xdata$x:00009AD0 ; Segment permissions: Read
.xdata$x:00009AD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009AD0                 assume cs:_xdata$x
.xdata$x:00009AD0                 ;org 9AD0h
.xdata$x:00009AD0 ; COMDAT (pick associative to section at 32D8)
.xdata$x:00009AD0 __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z db 0FFh
.xdata$x:00009AD0                                         ; DATA XREF: .xdata$x:00009AE0o
.xdata$x:00009AD1                 db 0FFh
.xdata$x:00009AD2                 db 0FFh
.xdata$x:00009AD3                 db 0FFh
.xdata$x:00009AD4                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z$0
.xdata$x:00009AD8 __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z db  22h ; "
.xdata$x:00009AD8                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z+11o
.xdata$x:00009AD9                 db    5
.xdata$x:00009ADA                 db  93h ; ô
.xdata$x:00009ADB                 db  19h
.xdata$x:00009ADC                 db    1
.xdata$x:00009ADD                 db    0
.xdata$x:00009ADE                 db    0
.xdata$x:00009ADF                 db    0
.xdata$x:00009AE0                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@std@@YAPBQAUtTbData@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUtTbData@@@std@@@std@@@0@@Z
.xdata$x:00009AE4                 db    0
.xdata$x:00009AE5                 db    0
.xdata$x:00009AE6                 db    0
.xdata$x:00009AE7                 db    0
.xdata$x:00009AE8                 db    0
.xdata$x:00009AE9                 db    0
.xdata$x:00009AEA                 db    0
.xdata$x:00009AEB                 db    0
.xdata$x:00009AEC                 db    0
.xdata$x:00009AED                 db    0
.xdata$x:00009AEE                 db    0
.xdata$x:00009AEF                 db    0
.xdata$x:00009AF0                 db    0
.xdata$x:00009AF1                 db    0
.xdata$x:00009AF2                 db    0
.xdata$x:00009AF3                 db    0
.xdata$x:00009AF4                 db    0
.xdata$x:00009AF5                 db    0
.xdata$x:00009AF6                 db    0
.xdata$x:00009AF7                 db    0
.xdata$x:00009AF8                 db    0
.xdata$x:00009AF9                 db    0
.xdata$x:00009AFA                 db    0
.xdata$x:00009AFB                 db    0
.xdata$x:00009AFB _xdata$x        ends
.xdata$x:00009AFB
.xdata$x:00009AFC ; ===========================================================================
.xdata$x:00009AFC
.xdata$x:00009AFC ; Segment type: Pure data
.xdata$x:00009AFC ; Segment permissions: Read
.xdata$x:00009AFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009AFC                 assume cs:_xdata$x
.xdata$x:00009AFC                 ;org 9AFCh
.xdata$x:00009AFC ; COMDAT (pick associative to section at 3958)
.xdata$x:00009AFC __unwindtable$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z db 0FFh
.xdata$x:00009AFC                                         ; DATA XREF: .xdata$x:00009B0Co
.xdata$x:00009AFD                 db 0FFh
.xdata$x:00009AFE                 db 0FFh
.xdata$x:00009AFF                 db 0FFh
.xdata$x:00009B00                 dd offset __unwindfunclet$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z$0
.xdata$x:00009B04 __ehfuncinfo$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z db  22h ; "
.xdata$x:00009B04                                         ; DATA XREF: __ehhandler$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z+11o
.xdata$x:00009B05                 db    5
.xdata$x:00009B06                 db  93h ; ô
.xdata$x:00009B07                 db  19h
.xdata$x:00009B08                 db    1
.xdata$x:00009B09                 db    0
.xdata$x:00009B0A                 db    0
.xdata$x:00009B0B                 db    0
.xdata$x:00009B0C                 dd offset __unwindtable$??$construct@PAUHWND__@@AAPAU1@@?$allocator@PAUHWND__@@@std@@QAEXPAPAUHWND__@@AAPAU2@@Z
.xdata$x:00009B10                 db    0
.xdata$x:00009B11                 db    0
.xdata$x:00009B12                 db    0
.xdata$x:00009B13                 db    0
.xdata$x:00009B14                 db    0
.xdata$x:00009B15                 db    0
.xdata$x:00009B16                 db    0
.xdata$x:00009B17                 db    0
.xdata$x:00009B18                 db    0
.xdata$x:00009B19                 db    0
.xdata$x:00009B1A                 db    0
.xdata$x:00009B1B                 db    0
.xdata$x:00009B1C                 db    0
.xdata$x:00009B1D                 db    0
.xdata$x:00009B1E                 db    0
.xdata$x:00009B1F                 db    0
.xdata$x:00009B20                 db    0
.xdata$x:00009B21                 db    0
.xdata$x:00009B22                 db    0
.xdata$x:00009B23                 db    0
.xdata$x:00009B24                 db    0
.xdata$x:00009B25                 db    0
.xdata$x:00009B26                 db    0
.xdata$x:00009B27                 db    0
.xdata$x:00009B27 _xdata$x        ends
.xdata$x:00009B27
.xdata$x:00009B28 ; ===========================================================================
.xdata$x:00009B28
.xdata$x:00009B28 ; Segment type: Pure data
.xdata$x:00009B28 ; Segment permissions: Read
.xdata$x:00009B28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B28                 assume cs:_xdata$x
.xdata$x:00009B28                 ;org 9B28h
.xdata$x:00009B28 ; COMDAT (pick associative to section at 3AA4)
.xdata$x:00009B28 __unwindtable$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z db 0FFh
.xdata$x:00009B28                                         ; DATA XREF: .xdata$x:00009B38o
.xdata$x:00009B29                 db 0FFh
.xdata$x:00009B2A                 db 0FFh
.xdata$x:00009B2B                 db 0FFh
.xdata$x:00009B2C                 dd offset __unwindfunclet$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z$0
.xdata$x:00009B30 __ehfuncinfo$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z db  22h ; "
.xdata$x:00009B30                                         ; DATA XREF: __ehhandler$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z+11o
.xdata$x:00009B31                 db    5
.xdata$x:00009B32                 db  93h ; ô
.xdata$x:00009B33                 db  19h
.xdata$x:00009B34                 db    1
.xdata$x:00009B35                 db    0
.xdata$x:00009B36                 db    0
.xdata$x:00009B37                 db    0
.xdata$x:00009B38                 dd offset __unwindtable$??$construct@PAVDockingCont@@AAPAV1@@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@AAPAV2@@Z
.xdata$x:00009B3C                 db    0
.xdata$x:00009B3D                 db    0
.xdata$x:00009B3E                 db    0
.xdata$x:00009B3F                 db    0
.xdata$x:00009B40                 db    0
.xdata$x:00009B41                 db    0
.xdata$x:00009B42                 db    0
.xdata$x:00009B43                 db    0
.xdata$x:00009B44                 db    0
.xdata$x:00009B45                 db    0
.xdata$x:00009B46                 db    0
.xdata$x:00009B47                 db    0
.xdata$x:00009B48                 db    0
.xdata$x:00009B49                 db    0
.xdata$x:00009B4A                 db    0
.xdata$x:00009B4B                 db    0
.xdata$x:00009B4C                 db    0
.xdata$x:00009B4D                 db    0
.xdata$x:00009B4E                 db    0
.xdata$x:00009B4F                 db    0
.xdata$x:00009B50                 db    0
.xdata$x:00009B51                 db    0
.xdata$x:00009B52                 db    0
.xdata$x:00009B53                 db    0
.xdata$x:00009B53 _xdata$x        ends
.xdata$x:00009B53
.xdata$x:00009B54 ; ===========================================================================
.xdata$x:00009B54
.xdata$x:00009B54 ; Segment type: Pure data
.xdata$x:00009B54 ; Segment permissions: Read
.xdata$x:00009B54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B54                 assume cs:_xdata$x
.xdata$x:00009B54                 ;org 9B54h
.xdata$x:00009B54 ; COMDAT (pick associative to section at 3BF0)
.xdata$x:00009B54 __unwindtable$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z db 0FFh
.xdata$x:00009B54                                         ; DATA XREF: .xdata$x:00009B64o
.xdata$x:00009B55                 db 0FFh
.xdata$x:00009B56                 db 0FFh
.xdata$x:00009B57                 db 0FFh
.xdata$x:00009B58                 dd offset __unwindfunclet$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z$0
.xdata$x:00009B5C __ehfuncinfo$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z db  22h ; "
.xdata$x:00009B5C                                         ; DATA XREF: __ehhandler$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z+11o
.xdata$x:00009B5D                 db    5
.xdata$x:00009B5E                 db  93h ; ô
.xdata$x:00009B5F                 db  19h
.xdata$x:00009B60                 db    1
.xdata$x:00009B61                 db    0
.xdata$x:00009B62                 db    0
.xdata$x:00009B63                 db    0
.xdata$x:00009B64                 dd offset __unwindtable$??$construct@PAVDockingSplitter@@AAPAV1@@?$allocator@PAVDockingSplitter@@@std@@QAEXPAPAVDockingSplitter@@AAPAV2@@Z
.xdata$x:00009B68                 align 20h
.xdata$x:00009B68 _xdata$x        ends
.xdata$x:00009B68
.xdata$x:00009B80 ; ===========================================================================
.xdata$x:00009B80
.xdata$x:00009B80 ; Segment type: Pure data
.xdata$x:00009B80 ; Segment permissions: Read
.xdata$x:00009B80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B80                 assume cs:_xdata$x
.xdata$x:00009B80                 ;org 9B80h
.xdata$x:00009B80 ; COMDAT (pick associative to section at 3858)
.xdata$x:00009B80 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00009B80                                         ; DATA XREF: .xdata$x:00009B90o
.xdata$x:00009B81                 db 0FFh
.xdata$x:00009B82                 db 0FFh
.xdata$x:00009B83                 db 0FFh
.xdata$x:00009B84                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00009B88 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00009B88                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00009B89                 db    5
.xdata$x:00009B8A                 db  93h ; ô
.xdata$x:00009B8B                 db  19h
.xdata$x:00009B8C                 db    1
.xdata$x:00009B8D                 db    0
.xdata$x:00009B8E                 db    0
.xdata$x:00009B8F                 db    0
.xdata$x:00009B90                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00009B94                 db    0
.xdata$x:00009B95                 db    0
.xdata$x:00009B96                 db    0
.xdata$x:00009B97                 db    0
.xdata$x:00009B98                 db    0
.xdata$x:00009B99                 db    0
.xdata$x:00009B9A                 db    0
.xdata$x:00009B9B                 db    0
.xdata$x:00009B9C                 db    0
.xdata$x:00009B9D                 db    0
.xdata$x:00009B9E                 db    0
.xdata$x:00009B9F                 db    0
.xdata$x:00009BA0                 db    0
.xdata$x:00009BA1                 db    0
.xdata$x:00009BA2                 db    0
.xdata$x:00009BA3                 db    0
.xdata$x:00009BA4                 db    0
.xdata$x:00009BA5                 db    0
.xdata$x:00009BA6                 db    0
.xdata$x:00009BA7                 db    0
.xdata$x:00009BA8                 db    0
.xdata$x:00009BA9                 db    0
.xdata$x:00009BAA                 db    0
.xdata$x:00009BAB                 db    0
.xdata$x:00009BAB _xdata$x        ends
.xdata$x:00009BAB
.rdata:00009BAC ; ===========================================================================
.rdata:00009BAC
.rdata:00009BAC ; Segment type: Pure data
.rdata:00009BAC ; Segment permissions: Read
.rdata:00009BAC ; Segment alignment 'qword' can not be represented in assembly
.rdata:00009BAC _rdata          segment para public 'DATA' use32
.rdata:00009BAC                 assume cs:_rdata
.rdata:00009BAC                 ;org 9BACh
.rdata:00009BAC ; COMDAT (pick any)
.rdata:00009BAC                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00009BAC ; wchar_t `string'
.rdata:00009BAC ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00009BAC                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:00009BAC                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00009BAC                 unicode 0, <clude\xutility>,0
.rdata:00009BAC _rdata          ends
.rdata:00009BAC
.rdata:00009C3C ; ===========================================================================
.rdata:00009C3C
.rdata:00009C3C ; Segment type: Pure data
.rdata:00009C3C ; Segment permissions: Read
.rdata:00009C3C _rdata          segment dword public 'DATA' use32
.rdata:00009C3C                 assume cs:_rdata
.rdata:00009C3C                 ;org 9C3Ch
.rdata:00009C3C ; COMDAT (pick any)
.rdata:00009C3C                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:00009C3C ; wchar_t `string'
.rdata:00009C3C ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:00009C3C                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:00009C3C                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:00009C6E                 align 10h
.rdata:00009C6E _rdata          ends
.rdata:00009C6E
.rdata:00009C70 ; ===========================================================================
.rdata:00009C70
.rdata:00009C70 ; Segment type: Pure data
.rdata:00009C70 ; Segment permissions: Read
.rdata:00009C70 _rdata          segment dword public 'DATA' use32
.rdata:00009C70                 assume cs:_rdata
.rdata:00009C70                 ;org 9C70h
.rdata:00009C70 ; COMDAT (pick largest)
.rdata:00009C70                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:00009C74                 public ??_7runtime_error@std@@6B@
.rdata:00009C74 ; const std::runtime_error::`vftable'
.rdata:00009C74 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:00009C74                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:00009C74                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:00009C74                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:00009C78                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00009C78 _rdata          ends
.rdata:00009C78
.rdata:00009C7C ; ===========================================================================
.rdata:00009C7C
.rdata:00009C7C ; Segment type: Pure data
.rdata:00009C7C ; Segment permissions: Read
.rdata:00009C7C _rdata          segment dword public 'DATA' use32
.rdata:00009C7C                 assume cs:_rdata
.rdata:00009C7C                 ;org 9C7Ch
.rdata:00009C7C ; COMDAT (pick largest)
.rdata:00009C7C                 dd offset ??_R4Window@@6B@ ; const Window::`RTTI Complete Object Locator'
.rdata:00009C80                 public ??_7Window@@6B@
.rdata:00009C80 ; const Window::`vftable'
.rdata:00009C80 ??_7Window@@6B@ dd offset ??_EWindow@@UAEPAXI@Z
.rdata:00009C80                                         ; DATA XREF: Window::Window(void)+Ao
.rdata:00009C80                                         ; Window::~Window(void)+Ao
.rdata:00009C80                                         ; Window::`vector deleting destructor'(uint)
.rdata:00009C84                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:00009C88                 dd offset __purecall
.rdata:00009C8C                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:00009C90                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:00009C94                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:00009C98                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00009C9C                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:00009CA0                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00009CA4                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:00009CA8                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00009CAC                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:00009CAC _rdata          ends
.rdata:00009CAC
.xdata$x:00009CB0 ; ===========================================================================
.xdata$x:00009CB0
.xdata$x:00009CB0 ; Segment type: Pure data
.xdata$x:00009CB0 ; Segment permissions: Read
.xdata$x:00009CB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009CB0                 assume cs:_xdata$x
.xdata$x:00009CB0                 ;org 9CB0h
.xdata$x:00009CB0 ; COMDAT (pick any)
.xdata$x:00009CB0                 public __TI2?AVruntime_error@std@@
.xdata$x:00009CB0 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+95o
.xdata$x:00009CB0                                         ; DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+108o ...
.xdata$x:00009CB1                 db    0
.xdata$x:00009CB2                 db    0
.xdata$x:00009CB3                 db    0
.xdata$x:00009CB4                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:00009CB8                 db    0
.xdata$x:00009CB9                 db    0
.xdata$x:00009CBA                 db    0
.xdata$x:00009CBB                 db    0
.xdata$x:00009CBC                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:00009CBC _xdata$x        ends
.xdata$x:00009CBC
.xdata$x:00009CC0 ; ===========================================================================
.xdata$x:00009CC0
.xdata$x:00009CC0 ; Segment type: Pure data
.xdata$x:00009CC0 ; Segment permissions: Read
.xdata$x:00009CC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009CC0                 assume cs:_xdata$x
.xdata$x:00009CC0                 ;org 9CC0h
.xdata$x:00009CC0 ; COMDAT (pick any)
.xdata$x:00009CC0                 public __CTA2?AVruntime_error@std@@
.xdata$x:00009CC0 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:00009CBCo
.xdata$x:00009CC1                 db    0
.xdata$x:00009CC2                 db    0
.xdata$x:00009CC3                 db    0
.xdata$x:00009CC4                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00009CC8                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00009CC8 _xdata$x        ends
.xdata$x:00009CC8
.data$r:00009CCC ; ===========================================================================
.data$r:00009CCC
.data$r:00009CCC ; Segment type: Pure data
.data$r:00009CCC ; Segment permissions: Read/Write
.data$r:00009CCC _data$r         segment dword public 'DATA' use32
.data$r:00009CCC                 assume cs:_data$r
.data$r:00009CCC                 ;org 9CCCh
.data$r:00009CCC ; COMDAT (pick any)
.data$r:00009CCC                 public ??_R0?AVruntime_error@std@@@8
.data$r:00009CCC ; class std::runtime_error `RTTI Type Descriptor'
.data$r:00009CCC ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00009CCC                                         ; DATA XREF: .xdata$x:00009CF0o
.data$r:00009CCC                                         ; .rdata$r:0000A4A0o ...
.data$r:00009CCC                                         ; const type_info::`vftable'
.data$r:00009CD0                 db    0
.data$r:00009CD1                 db    0
.data$r:00009CD2                 db    0
.data$r:00009CD3                 db    0
.data$r:00009CD4                 db  2Eh ; .
.data$r:00009CD5                 db  3Fh ; ?
.data$r:00009CD6                 db  41h ; A
.data$r:00009CD7                 db  56h ; V
.data$r:00009CD8                 db  72h ; r
.data$r:00009CD9                 db  75h ; u
.data$r:00009CDA                 db  6Eh ; n
.data$r:00009CDB                 db  74h ; t
.data$r:00009CDC                 db  69h ; i
.data$r:00009CDD                 db  6Dh ; m
.data$r:00009CDE                 db  65h ; e
.data$r:00009CDF                 db  5Fh ; _
.data$r:00009CE0                 db  65h ; e
.data$r:00009CE1                 db  72h ; r
.data$r:00009CE2                 db  72h ; r
.data$r:00009CE3                 db  6Fh ; o
.data$r:00009CE4                 db  72h ; r
.data$r:00009CE5                 db  40h ; @
.data$r:00009CE6                 db  73h ; s
.data$r:00009CE7                 db  74h ; t
.data$r:00009CE8                 db  64h ; d
.data$r:00009CE9                 db  40h ; @
.data$r:00009CEA                 db  40h ; @
.data$r:00009CEB                 db    0
.data$r:00009CEB _data$r         ends
.data$r:00009CEB
.xdata$x:00009CEC ; ===========================================================================
.xdata$x:00009CEC
.xdata$x:00009CEC ; Segment type: Pure data
.xdata$x:00009CEC ; Segment permissions: Read
.xdata$x:00009CEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009CEC                 assume cs:_xdata$x
.xdata$x:00009CEC                 ;org 9CECh
.xdata$x:00009CEC ; COMDAT (pick any)
.xdata$x:00009CEC                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00009CEC __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00009CEC                                         ; DATA XREF: .xdata$x:00009CC4o
.xdata$x:00009CED                 db    0
.xdata$x:00009CEE                 db    0
.xdata$x:00009CEF                 db    0
.xdata$x:00009CF0                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:00009CF4                 align 8
.xdata$x:00009CF8                 db 0FFh
.xdata$x:00009CF9                 db 0FFh
.xdata$x:00009CFA                 db 0FFh
.xdata$x:00009CFB                 db 0FFh
.xdata$x:00009CFC                 db    0
.xdata$x:00009CFD                 db    0
.xdata$x:00009CFE                 db    0
.xdata$x:00009CFF                 db    0
.xdata$x:00009D00                 db  0Ch
.xdata$x:00009D01                 db    0
.xdata$x:00009D02                 db    0
.xdata$x:00009D03                 db    0
.xdata$x:00009D04                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:00009D04 _xdata$x        ends
.xdata$x:00009D04
.data$r:00009D08 ; ===========================================================================
.data$r:00009D08
.data$r:00009D08 ; Segment type: Pure data
.data$r:00009D08 ; Segment permissions: Read/Write
.data$r:00009D08 _data$r         segment dword public 'DATA' use32
.data$r:00009D08                 assume cs:_data$r
.data$r:00009D08                 ;org 9D08h
.data$r:00009D08 ; COMDAT (pick any)
.data$r:00009D08                 public ??_R0?AVexception@std@@@8
.data$r:00009D08 ; class std::exception `RTTI Type Descriptor'
.data$r:00009D08 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00009D08                                         ; DATA XREF: .xdata$x:00009D28o
.data$r:00009D08                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009D08                                         ; const type_info::`vftable'
.data$r:00009D0C                 align 10h
.data$r:00009D10 a_?avexception@ db '.?AVexception@std@@',0
.data$r:00009D10 _data$r         ends
.data$r:00009D10
.xdata$x:00009D24 ; ===========================================================================
.xdata$x:00009D24
.xdata$x:00009D24 ; Segment type: Pure data
.xdata$x:00009D24 ; Segment permissions: Read
.xdata$x:00009D24 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D24                 assume cs:_xdata$x
.xdata$x:00009D24                 ;org 9D24h
.xdata$x:00009D24 ; COMDAT (pick any)
.xdata$x:00009D24                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00009D24 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00009D24                                         ; DATA XREF: .xdata$x:00009CC8o
.xdata$x:00009D25                 db    0
.xdata$x:00009D26                 db    0
.xdata$x:00009D27                 db    0
.xdata$x:00009D28                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:00009D2C                 align 10h
.xdata$x:00009D30                 db 0FFh
.xdata$x:00009D31                 db 0FFh
.xdata$x:00009D32                 db 0FFh
.xdata$x:00009D33                 db 0FFh
.xdata$x:00009D34                 db    0
.xdata$x:00009D35                 db    0
.xdata$x:00009D36                 db    0
.xdata$x:00009D37                 db    0
.xdata$x:00009D38                 db  0Ch
.xdata$x:00009D39                 db    0
.xdata$x:00009D3A                 db    0
.xdata$x:00009D3B                 db    0
.xdata$x:00009D3C                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00009D3C _xdata$x        ends
.xdata$x:00009D3C
.rdata:00009D40 ; ===========================================================================
.rdata:00009D40
.rdata:00009D40 ; Segment type: Pure data
.rdata:00009D40 ; Segment permissions: Read
.rdata:00009D40 _rdata          segment dword public 'DATA' use32
.rdata:00009D40                 assume cs:_rdata
.rdata:00009D40                 ;org 9D40h
.rdata:00009D40 ; COMDAT (pick largest)
.rdata:00009D40                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00009D44                 public ??_7error_category@std@@6B@
.rdata:00009D44 ; const std::error_category::`vftable'
.rdata:00009D44 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00009D44                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00009D44                                         ; std::error_category::~error_category(void)+Ao
.rdata:00009D44                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00009D48                 dd offset __purecall
.rdata:00009D4C                 dd offset __purecall
.rdata:00009D50                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00009D54                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00009D58                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00009D58 _rdata          ends
.rdata:00009D58
.rdata:00009D5C ; ===========================================================================
.rdata:00009D5C
.rdata:00009D5C ; Segment type: Pure data
.rdata:00009D5C ; Segment permissions: Read
.rdata:00009D5C _rdata          segment dword public 'DATA' use32
.rdata:00009D5C                 assume cs:_rdata
.rdata:00009D5C                 ;org 9D5Ch
.rdata:00009D5C ; COMDAT (pick largest)
.rdata:00009D5C                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00009D60                 public ??_7_Generic_error_category@std@@6B@
.rdata:00009D60 ; const std::_Generic_error_category::`vftable'
.rdata:00009D60 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00009D60                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00009D60                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00009D64                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00009D68                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00009D6C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00009D70                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00009D74                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00009D74 _rdata          ends
.rdata:00009D74
.rdata:00009D78 ; ===========================================================================
.rdata:00009D78
.rdata:00009D78 ; Segment type: Pure data
.rdata:00009D78 ; Segment permissions: Read
.rdata:00009D78 _rdata          segment dword public 'DATA' use32
.rdata:00009D78                 assume cs:_rdata
.rdata:00009D78                 ;org 9D78h
.rdata:00009D78 ; COMDAT (pick any)
.rdata:00009D78                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00009D78 ; `string'
.rdata:00009D78 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00009D78                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00009D78 _rdata          ends
.rdata:00009D78
.rdata:00009D80 ; ===========================================================================
.rdata:00009D80
.rdata:00009D80 ; Segment type: Pure data
.rdata:00009D80 ; Segment permissions: Read
.rdata:00009D80 _rdata          segment dword public 'DATA' use32
.rdata:00009D80                 assume cs:_rdata
.rdata:00009D80                 ;org 9D80h
.rdata:00009D80 ; COMDAT (pick any)
.rdata:00009D80                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00009D80 ; `string'
.rdata:00009D80 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00009D80                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_83F4o
.rdata:00009D80                                         ; std::_System_error_category::message(int):loc_8570o
.rdata:00009D8E                 align 10h
.rdata:00009D8E _rdata          ends
.rdata:00009D8E
.rdata:00009D90 ; ===========================================================================
.rdata:00009D90
.rdata:00009D90 ; Segment type: Pure data
.rdata:00009D90 ; Segment permissions: Read
.rdata:00009D90 _rdata          segment dword public 'DATA' use32
.rdata:00009D90                 assume cs:_rdata
.rdata:00009D90                 ;org 9D90h
.rdata:00009D90 ; COMDAT (pick largest)
.rdata:00009D90                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00009D94                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00009D94 ; const std::_Iostream_error_category::`vftable'
.rdata:00009D94 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00009D94                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00009D94                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00009D98                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00009D9C                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00009DA0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00009DA4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00009DA8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00009DA8 _rdata          ends
.rdata:00009DA8
.rdata:00009DAC ; ===========================================================================
.rdata:00009DAC
.rdata:00009DAC ; Segment type: Pure data
.rdata:00009DAC ; Segment permissions: Read
.rdata:00009DAC _rdata          segment dword public 'DATA' use32
.rdata:00009DAC                 assume cs:_rdata
.rdata:00009DAC                 ;org 9DACh
.rdata:00009DAC ; COMDAT (pick any)
.rdata:00009DAC                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00009DAC ; `string'
.rdata:00009DAC ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00009DAC                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00009DB5                 align 4
.rdata:00009DB5 _rdata          ends
.rdata:00009DB5
.rdata:00009DB8 ; ===========================================================================
.rdata:00009DB8
.rdata:00009DB8 ; Segment type: Pure data
.rdata:00009DB8 ; Segment permissions: Read
.rdata:00009DB8 _rdata          segment dword public 'DATA' use32
.rdata:00009DB8                 assume cs:_rdata
.rdata:00009DB8                 ;org 9DB8h
.rdata:00009DB8 ; COMDAT (pick any)
.rdata:00009DB8                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00009DB8 ; char `string'[]
.rdata:00009DB8 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00009DB8                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00009DCE                 align 10h
.rdata:00009DCE _rdata          ends
.rdata:00009DCE
.rdata:00009DD0 ; ===========================================================================
.rdata:00009DD0
.rdata:00009DD0 ; Segment type: Pure data
.rdata:00009DD0 ; Segment permissions: Read
.rdata:00009DD0 _rdata          segment dword public 'DATA' use32
.rdata:00009DD0                 assume cs:_rdata
.rdata:00009DD0                 ;org 9DD0h
.rdata:00009DD0 ; COMDAT (pick largest)
.rdata:00009DD0                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00009DD4                 public ??_7_System_error_category@std@@6B@
.rdata:00009DD4 ; const std::_System_error_category::`vftable'
.rdata:00009DD4 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00009DD4                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00009DD4                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00009DD8                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00009DDC                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00009DE0                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00009DE4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00009DE8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00009DE8 _rdata          ends
.rdata:00009DE8
.rdata:00009DEC ; ===========================================================================
.rdata:00009DEC
.rdata:00009DEC ; Segment type: Pure data
.rdata:00009DEC ; Segment permissions: Read
.rdata:00009DEC _rdata          segment dword public 'DATA' use32
.rdata:00009DEC                 assume cs:_rdata
.rdata:00009DEC                 ;org 9DECh
.rdata:00009DEC ; COMDAT (pick any)
.rdata:00009DEC                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00009DEC ; `string'
.rdata:00009DEC ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00009DEC                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00009DF3                 align 4
.rdata:00009DF3 _rdata          ends
.rdata:00009DF3
.bss:00009DF4 ; ===========================================================================
.bss:00009DF4
.bss:00009DF4 ; Segment type: Uninitialized
.bss:00009DF4 ; Segment permissions: Read/Write
.bss:00009DF4 _bss            segment dword public 'BSS' use32
.bss:00009DF4                 assume cs:_bss
.bss:00009DF4                 ;org 9DF4h
.bss:00009DF4 ; COMDAT (pick any)
.bss:00009DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009DF4                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00009DF4 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00009DF4 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00009DF4                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00009DF4                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00009DF5                 db    ? ;
.bss:00009DF6                 db    ? ;
.bss:00009DF7                 db    ? ;
.bss:00009DF7 _bss            ends
.bss:00009DF7
.bss:00009DF8 ; ===========================================================================
.bss:00009DF8
.bss:00009DF8 ; Segment type: Uninitialized
.bss:00009DF8 ; Segment permissions: Read/Write
.bss:00009DF8 _bss            segment dword public 'BSS' use32
.bss:00009DF8                 assume cs:_bss
.bss:00009DF8                 ;org 9DF8h
.bss:00009DF8 ; COMDAT (pick any)
.bss:00009DF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009DF8                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00009DF8 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00009DF8 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00009DF8                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00009DF8                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00009DF9                 db    ? ;
.bss:00009DFA                 db    ? ;
.bss:00009DFB                 db    ? ;
.bss:00009DFB _bss            ends
.bss:00009DFB
.bss:00009DFC ; ===========================================================================
.bss:00009DFC
.bss:00009DFC ; Segment type: Uninitialized
.bss:00009DFC ; Segment permissions: Read/Write
.bss:00009DFC _bss            segment dword public 'BSS' use32
.bss:00009DFC                 assume cs:_bss
.bss:00009DFC                 ;org 9DFCh
.bss:00009DFC ; COMDAT (pick any)
.bss:00009DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009DFC                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00009DFC ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00009DFC ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00009DFC                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00009DFC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00009DFD                 db    ? ;
.bss:00009DFE                 db    ? ;
.bss:00009DFF                 db    ? ;
.bss:00009DFF _bss            ends
.bss:00009DFF
.bss:00009E00 ; ===========================================================================
.bss:00009E00
.bss:00009E00 ; Segment type: Uninitialized
.bss:00009E00 ; Segment permissions: Read/Write
.bss:00009E00 _bss            segment dword public 'BSS' use32
.bss:00009E00                 assume cs:_bss
.bss:00009E00                 ;org 9E00h
.bss:00009E00 ; COMDAT (pick any)
.bss:00009E00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009E00                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00009E00 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00009E00 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00009E00                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00009E01                 db    ? ;
.bss:00009E02                 db    ? ;
.bss:00009E03                 db    ? ;
.bss:00009E03 _bss            ends
.bss:00009E03
.bss:00009E04 ; ===========================================================================
.bss:00009E04
.bss:00009E04 ; Segment type: Uninitialized
.bss:00009E04 ; Segment permissions: Read/Write
.bss:00009E04 _bss            segment dword public 'BSS' use32
.bss:00009E04                 assume cs:_bss
.bss:00009E04                 ;org 9E04h
.bss:00009E04 ; COMDAT (pick any)
.bss:00009E04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009E04                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00009E04 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00009E04 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00009E04                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00009E05                 db    ? ;
.bss:00009E06                 db    ? ;
.bss:00009E07                 db    ? ;
.bss:00009E07 _bss            ends
.bss:00009E07
.rdata:00009E08 ; ===========================================================================
.rdata:00009E08
.rdata:00009E08 ; Segment type: Pure data
.rdata:00009E08 ; Segment permissions: Read
.rdata:00009E08 _rdata          segment dword public 'DATA' use32
.rdata:00009E08                 assume cs:_rdata
.rdata:00009E08                 ;org 9E08h
.rdata:00009E08 ; COMDAT (pick largest)
.rdata:00009E08                 dd offset ??_R4DockingManager@@6B@ ; const DockingManager::`RTTI Complete Object Locator'
.rdata:00009E0C                 public ??_7DockingManager@@6B@
.rdata:00009E0C ; const DockingManager::`vftable'
.rdata:00009E0C ??_7DockingManager@@6B@ dd offset ??_EDockingManager@@UAEPAXI@Z
.rdata:00009E0C                                         ; DATA XREF: DockingManager::DockingManager(void)+3Ao
.rdata:00009E0C                                         ; DockingManager::~DockingManager(void)+2Bo
.rdata:00009E0C                                         ; DockingManager::`vector deleting destructor'(uint)
.rdata:00009E10                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:00009E14                 dd offset ?destroy@DockingManager@@UAEXXZ ; DockingManager::destroy(void)
.rdata:00009E18                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:00009E1C                 dd offset ?reSizeTo@DockingManager@@UAEXAAUtagRECT@@@Z ; DockingManager::reSizeTo(tagRECT &)
.rdata:00009E20                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:00009E24                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00009E28                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:00009E2C                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00009E30                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:00009E34                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00009E38                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:00009E38 _rdata          ends
.rdata:00009E38
.rdata:00009E3C ; ===========================================================================
.rdata:00009E3C
.rdata:00009E3C ; Segment type: Pure data
.rdata:00009E3C ; Segment permissions: Read
.rdata:00009E3C _rdata          segment dword public 'DATA' use32
.rdata:00009E3C                 assume cs:_rdata
.rdata:00009E3C                 ;org 9E3Ch
.rdata:00009E3C ; COMDAT (pick largest)
.rdata:00009E3C                 dd offset ??_R4DockingSplitter@@6B@ ; const DockingSplitter::`RTTI Complete Object Locator'
.rdata:00009E40                 public ??_7DockingSplitter@@6B@
.rdata:00009E40 ; const DockingSplitter::`vftable'
.rdata:00009E40 ??_7DockingSplitter@@6B@ dd offset ??_EDockingSplitter@@UAEPAXI@Z
.rdata:00009E40                                         ; DATA XREF: DockingSplitter::DockingSplitter(void)+38o
.rdata:00009E40                                         ; DockingSplitter::~DockingSplitter(void)+29o
.rdata:00009E40                                         ; DockingSplitter::`vector deleting destructor'(uint)
.rdata:00009E44                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:00009E48                 dd offset ?destroy@DockingSplitter@@UAEXXZ ; DockingSplitter::destroy(void)
.rdata:00009E4C                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:00009E50                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:00009E54                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:00009E58                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00009E5C                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:00009E60                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00009E64                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:00009E68                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00009E6C                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:00009E6C _rdata          ends
.rdata:00009E6C
.rdata:00009E70 ; ===========================================================================
.rdata:00009E70
.rdata:00009E70 ; Segment type: Pure data
.rdata:00009E70 ; Segment permissions: Read
.rdata:00009E70 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00009E70 _rdata          segment para public 'DATA' use32
.rdata:00009E70                 assume cs:_rdata
.rdata:00009E70                 ;org 9E70h
.rdata:00009E70 ; COMDAT (pick any)
.rdata:00009E70                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00009E70 ; wchar_t `string'
.rdata:00009E70 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00009E70                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00009E70                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00009E70                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00009E70                 unicode 0, <clude\xstring>,0
.rdata:00009EFE                 align 10h
.rdata:00009EFE _rdata          ends
.rdata:00009EFE
.bss:00009F00 ; ===========================================================================
.bss:00009F00
.bss:00009F00 ; Segment type: Uninitialized
.bss:00009F00 ; Segment permissions: Read/Write
.bss:00009F00 _bss            segment dword public 'BSS' use32
.bss:00009F00                 assume cs:_bss
.bss:00009F00                 ;org 9F00h
.bss:00009F00 ; COMDAT (pick any)
.bss:00009F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009F00                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00009F00 ; std::locale::id std::numpunct<char>::id
.bss:00009F00 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00009F00                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00009F01                 db    ? ;
.bss:00009F02                 db    ? ;
.bss:00009F03                 db    ? ;
.bss:00009F03 _bss            ends
.bss:00009F03
.bss:00009F04 ; ===========================================================================
.bss:00009F04
.bss:00009F04 ; Segment type: Uninitialized
.bss:00009F04 ; Segment permissions: Read/Write
.bss:00009F04 _bss            segment dword public 'BSS' use32
.bss:00009F04                 assume cs:_bss
.bss:00009F04                 ;org 9F04h
.bss:00009F04 ; COMDAT (pick any)
.bss:00009F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009F04                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00009F04 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00009F04 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00009F04                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00009F05                 db    ? ;
.bss:00009F06                 db    ? ;
.bss:00009F07                 db    ? ;
.bss:00009F07 _bss            ends
.bss:00009F07
.rdata:00009F08 ; ===========================================================================
.rdata:00009F08
.rdata:00009F08 ; Segment type: Pure data
.rdata:00009F08 ; Segment permissions: Read
.rdata:00009F08 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00009F08 _rdata          segment para public 'DATA' use32
.rdata:00009F08                 assume cs:_rdata
.rdata:00009F08                 ;org 9F08h
.rdata:00009F08 ; COMDAT (pick any)
.rdata:00009F08                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00009F08 ; wchar_t `string'
.rdata:00009F08 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00009F08                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+19o
.rdata:00009F08                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+49o ...
.rdata:00009F08                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00009F08                 unicode 0, <clude\vector>,0
.rdata:00009F08 _rdata          ends
.rdata:00009F08
.rdata:00009F94 ; ===========================================================================
.rdata:00009F94
.rdata:00009F94 ; Segment type: Pure data
.rdata:00009F94 ; Segment permissions: Read
.rdata:00009F94 _rdata          segment dword public 'DATA' use32
.rdata:00009F94                 assume cs:_rdata
.rdata:00009F94                 ;org 9F94h
.rdata:00009F94 ; COMDAT (pick any)
.rdata:00009F94                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00009F94 ; wchar_t `string'
.rdata:00009F94 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00009F94                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+1Eo
.rdata:00009F94                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+1Eo ...
.rdata:00009F94                 unicode 0, <vector subscript out of range>,0
.rdata:00009F94 _rdata          ends
.rdata:00009F94
.rdata:00009FD0 ; ===========================================================================
.rdata:00009FD0
.rdata:00009FD0 ; Segment type: Pure data
.rdata:00009FD0 ; Segment permissions: Read
.rdata:00009FD0 _rdata          segment dword public 'DATA' use32
.rdata:00009FD0                 assume cs:_rdata
.rdata:00009FD0                 ;org 9FD0h
.rdata:00009FD0 ; COMDAT (pick any)
.rdata:00009FD0                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:00009FD0 ; `string'
.rdata:00009FD0 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:00009FD0                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+2Bo
.rdata:00009FD0                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+2Bo ...
.rdata:00009FD0 _rdata          ends
.rdata:00009FD0
.rdata:00009FF4 ; ===========================================================================
.rdata:00009FF4
.rdata:00009FF4 ; Segment type: Pure data
.rdata:00009FF4 ; Segment permissions: Read
.rdata:00009FF4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00009FF4 _rdata          segment para public 'DATA' use32
.rdata:00009FF4                 assume cs:_rdata
.rdata:00009FF4                 ;org 9FF4h
.rdata:00009FF4 ; COMDAT (pick any)
.rdata:00009FF4                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:00009FF4 ; `string'
.rdata:00009FF4 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:00009FF4                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint):loc_5AF0o
.rdata:00009FF4                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint):loc_5B80o ...
.rdata:00009FF4                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000A04A                 align 4
.rdata:0000A04A _rdata          ends
.rdata:0000A04A
.rdata:0000A04C ; ===========================================================================
.rdata:0000A04C
.rdata:0000A04C ; Segment type: Pure data
.rdata:0000A04C ; Segment permissions: Read
.rdata:0000A04C _rdata          segment dword public 'DATA' use32
.rdata:0000A04C                 assume cs:_rdata
.rdata:0000A04C                 ;org 0A04Ch
.rdata:0000A04C ; COMDAT (pick any)
.rdata:0000A04C                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000A04C ; `string'
.rdata:0000A04C ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000A04C                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+3Do
.rdata:0000A04C                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+3Do ...
.rdata:0000A04C                 unicode 0, <%s>,0
.rdata:0000A052                 align 4
.rdata:0000A052 _rdata          ends
.rdata:0000A052
.rdata:0000A054 ; ===========================================================================
.rdata:0000A054
.rdata:0000A054 ; Segment type: Pure data
.rdata:0000A054 ; Segment permissions: Read
.rdata:0000A054 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A054 _rdata          segment para public 'DATA' use32
.rdata:0000A054                 assume cs:_rdata
.rdata:0000A054                 ;org 0A054h
.rdata:0000A054 ; COMDAT (pick any)
.rdata:0000A054                 public ??_C@_1KG@EEBFNKPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAt?$AAT?$AAb?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa@
.rdata:0000A054 ; `string'
.rdata:0000A054 ??_C@_1KG@EEBFNKPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAt?$AAT?$AAb?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa@:
.rdata:0000A054                                         ; DATA XREF: std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+6Ao
.rdata:0000A054                 unicode 0, <std::vector>
.rdata:0000A054                 dw 3Ch
.rdata:0000A054                 unicode 0, <struct tTbData *,class std::allocator>
.rdata:0000A054                 dw 3Ch
.rdata:0000A054                 unicode 0, <struct tTbData *>
.rdata:0000A054                 dw 3Eh
.rdata:0000A054                 unicode 0, < >
.rdata:0000A054                 dw 3Eh
.rdata:0000A054                 unicode 0, <::operator []>,0
.rdata:0000A0FA                 align 4
.rdata:0000A0FA _rdata          ends
.rdata:0000A0FA
.rdata:0000A0FC ; ===========================================================================
.rdata:0000A0FC
.rdata:0000A0FC ; Segment type: Pure data
.rdata:0000A0FC ; Segment permissions: Read
.rdata:0000A0FC _rdata          segment dword public 'DATA' use32
.rdata:0000A0FC                 assume cs:_rdata
.rdata:0000A0FC                 ;org 0A0FCh
.rdata:0000A0FC ; COMDAT (pick any)
.rdata:0000A0FC                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000A0FC ; `string'
.rdata:0000A0FC ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000A0FC                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+6Fo
.rdata:0000A0FC                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+6Fo ...
.rdata:0000A0FC                 unicode 0, <"out of range">,0
.rdata:0000A11A                 align 4
.rdata:0000A11A _rdata          ends
.rdata:0000A11A
.rdata:0000A11C ; ===========================================================================
.rdata:0000A11C
.rdata:0000A11C ; Segment type: Pure data
.rdata:0000A11C ; Segment permissions: Read
.rdata:0000A11C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A11C _rdata          segment para public 'DATA' use32
.rdata:0000A11C                 assume cs:_rdata
.rdata:0000A11C                 ;org 0A11Ch
.rdata:0000A11C ; COMDAT (pick any)
.rdata:0000A11C                 public ??_C@_1KC@CCKJJADN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAH?$AAW?$AAN?$AAD?$AA_?$AA_?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs@
.rdata:0000A11C ; `string'
.rdata:0000A11C ??_C@_1KC@CCKJJADN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAH?$AAW?$AAN?$AAD?$AA_?$AA_?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000A11C                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+6Ao
.rdata:0000A11C                 unicode 0, <std::vector>
.rdata:0000A11C                 dw 3Ch
.rdata:0000A11C                 unicode 0, <struct HWND__ *,class std::allocator>
.rdata:0000A11C                 dw 3Ch
.rdata:0000A11C                 unicode 0, <struct HWND__ *>
.rdata:0000A11C                 dw 3Eh
.rdata:0000A11C                 unicode 0, < >
.rdata:0000A11C                 dw 3Eh
.rdata:0000A11C                 unicode 0, <::operator []>,0
.rdata:0000A1BE                 align 10h
.rdata:0000A1BE _rdata          ends
.rdata:0000A1BE
.rdata:0000A1C0 ; ===========================================================================
.rdata:0000A1C0
.rdata:0000A1C0 ; Segment type: Pure data
.rdata:0000A1C0 ; Segment permissions: Read
.rdata:0000A1C0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A1C0 _rdata          segment para public 'DATA' use32
.rdata:0000A1C0                 assume cs:_rdata
.rdata:0000A1C0                 ;org 0A1C0h
.rdata:0000A1C0 ; COMDAT (pick any)
.rdata:0000A1C0                 public ??_C@_1LC@HLAKEHED@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAo?$AAc?$AAk?$AAi?$AAn?$AAg?$AAC?$AAo?$AAn?$AAt?$AA?5?$AA?$CK?$AA?0@
.rdata:0000A1C0 ; `string'
.rdata:0000A1C0 ??_C@_1LC@HLAKEHED@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAo?$AAc?$AAk?$AAi?$AAn?$AAg?$AAC?$AAo?$AAn?$AAt?$AA?5?$AA?$CK?$AA?0@:
.rdata:0000A1C0                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+6Ao
.rdata:0000A1C0                 unicode 0, <std::vector>
.rdata:0000A1C0                 dw 3Ch
.rdata:0000A1C0                 unicode 0, <class DockingCont *,class std::allocator>
.rdata:0000A1C0                 dw 3Ch
.rdata:0000A1C0                 unicode 0, <class DockingCont *>
.rdata:0000A1C0                 dw 3Eh
.rdata:0000A1C0                 unicode 0, < >
.rdata:0000A1C0                 dw 3Eh
.rdata:0000A1C0                 unicode 0, <::operator []>,0
.rdata:0000A272                 align 4
.rdata:0000A272 _rdata          ends
.rdata:0000A272
.rdata:0000A274 ; ===========================================================================
.rdata:0000A274
.rdata:0000A274 ; Segment type: Pure data
.rdata:0000A274 ; Segment permissions: Read
.rdata:0000A274 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A274 _rdata          segment para public 'DATA' use32
.rdata:0000A274                 assume cs:_rdata
.rdata:0000A274                 ;org 0A274h
.rdata:0000A274 ; COMDAT (pick any)
.rdata:0000A274                 public ??_C@_1MC@HLIHCBPD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAo?$AAc?$AAk?$AAi?$AAn?$AAg?$AAS?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe@
.rdata:0000A274 ; `string'
.rdata:0000A274 ??_C@_1MC@HLIHCBPD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAo?$AAc?$AAk?$AAi?$AAn?$AAg?$AAS?$AAp?$AAl?$AAi?$AAt?$AAt?$AAe@:
.rdata:0000A274                                         ; DATA XREF: std::vector<DockingSplitter *,std::allocator<DockingSplitter *>>::operator[](uint)+6Ao
.rdata:0000A274                 unicode 0, <std::vector>
.rdata:0000A274                 dw 3Ch
.rdata:0000A274                 unicode 0, <class DockingSplitter *,class std::allocator>
.rdata:0000A274                 dw 3Ch
.rdata:0000A274                 unicode 0, <class DockingSplitter *>
.rdata:0000A274                 dw 3Eh
.rdata:0000A274                 unicode 0, < >
.rdata:0000A274                 dw 3Eh
.rdata:0000A274                 unicode 0, <::operator []>,0
.rdata:0000A336                 align 4
.rdata:0000A336 _rdata          ends
.rdata:0000A336
.rdata:0000A338 ; ===========================================================================
.rdata:0000A338
.rdata:0000A338 ; Segment type: Pure data
.rdata:0000A338 ; Segment permissions: Read
.rdata:0000A338 _rdata          segment dword public 'DATA' use32
.rdata:0000A338                 assume cs:_rdata
.rdata:0000A338                 ;org 0A338h
.rdata:0000A338 ; COMDAT (pick any)
.rdata:0000A338                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000A338 ; char `string'[]
.rdata:0000A338 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000A338                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000A338 _rdata          ends
.rdata:0000A338
.rdata:0000A348 ; ===========================================================================
.rdata:0000A348
.rdata:0000A348 ; Segment type: Pure data
.rdata:0000A348 ; Segment permissions: Read
.rdata:0000A348 _rdata          segment dword public 'DATA' use32
.rdata:0000A348                 assume cs:_rdata
.rdata:0000A348                 ;org 0A348h
.rdata:0000A348 ; COMDAT (pick any)
.rdata:0000A348                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000A348 ; char `string'[]
.rdata:0000A348 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000A348                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000A348 _rdata          ends
.rdata:0000A348
.rdata:0000A360 ; ===========================================================================
.rdata:0000A360
.rdata:0000A360 ; Segment type: Pure data
.rdata:0000A360 ; Segment permissions: Read
.rdata:0000A360 _rdata          segment dword public 'DATA' use32
.rdata:0000A360                 assume cs:_rdata
.rdata:0000A360                 ;org 0A360h
.rdata:0000A360 ; COMDAT (pick any)
.rdata:0000A360                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000A360 ; char `string'[]
.rdata:0000A360 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000A360                                         ; DATA XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::_Xlen(void)+7o
.rdata:0000A360                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::_Xlen(void)+7o ...
.rdata:0000A373                 align 4
.rdata:0000A373 _rdata          ends
.rdata:0000A373
.rdata:0000A374 ; ===========================================================================
.rdata:0000A374
.rdata:0000A374 ; Segment type: Pure data
.rdata:0000A374 ; Segment permissions: Read
.rdata:0000A374 _rdata          segment dword public 'DATA' use32
.rdata:0000A374                 assume cs:_rdata
.rdata:0000A374                 ;org 0A374h
.rdata:0000A374 ; COMDAT (pick any)
.rdata:0000A374                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000A374 ; wchar_t `string'
.rdata:0000A374 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000A374                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000A374                                         ; std::_Debug_pointer<HWND__ *>(HWND__ * *,wchar_t const *,uint)+11o ...
.rdata:0000A374                 unicode 0, <invalid null pointer>,0
.rdata:0000A39E                 align 10h
.rdata:0000A39E _rdata          ends
.rdata:0000A39E
.rdata:0000A3A0 ; ===========================================================================
.rdata:0000A3A0
.rdata:0000A3A0 ; Segment type: Pure data
.rdata:0000A3A0 ; Segment permissions: Read
.rdata:0000A3A0 _rdata          segment dword public 'DATA' use32
.rdata:0000A3A0                 assume cs:_rdata
.rdata:0000A3A0                 ;org 0A3A0h
.rdata:0000A3A0 ; COMDAT (pick any)
.rdata:0000A3A0                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000A3A0 ; wchar_t `string'
.rdata:0000A3A0 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000A3A0                                         ; DATA XREF: std::_Debug_range2<HWND__ * *>(HWND__ * *,HWND__ * *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000A3A0                                         ; std::_Debug_range2<DockingCont * *>(DockingCont * *,DockingCont * *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:0000A3A0                 unicode 0, <invalid iterator range>,0
.rdata:0000A3CE                 align 10h
.rdata:0000A3CE _rdata          ends
.rdata:0000A3CE
.rdata:0000A3D0 ; ===========================================================================
.rdata:0000A3D0
.rdata:0000A3D0 ; Segment type: Pure data
.rdata:0000A3D0 ; Segment permissions: Read
.rdata:0000A3D0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A3D0 _rdata          segment para public 'DATA' use32
.rdata:0000A3D0                 assume cs:_rdata
.rdata:0000A3D0                 ;org 0A3D0h
.rdata:0000A3D0 ; COMDAT (pick any)
.rdata:0000A3D0                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000A3D0 ; wchar_t `string'
.rdata:0000A3D0 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000A3D0                                         ; DATA XREF: std::_Uninit_copy<tTbData * const,tTbData *>(tTbData * const *,tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &,std::_Scalar_ptr_iterator_tag)+9o
.rdata:0000A3D0                                         ; std::_Uninit_copy<tTbData * const,tTbData *>(tTbData * const *,tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &,std::_Scalar_ptr_iterator_tag)+23o ...
.rdata:0000A3D0                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000A3D0                 unicode 0, <clude\xmemory>,0
.rdata:0000A45E                 align 10h
.rdata:0000A45E _rdata          ends
.rdata:0000A45E
.rdata$r:0000A460 ; ===========================================================================
.rdata$r:0000A460
.rdata$r:0000A460 ; Segment type: Pure data
.rdata$r:0000A460 ; Segment permissions: Read
.rdata$r:0000A460 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A460                 assume cs:_rdata$r
.rdata$r:0000A460                 ;org 0A460h
.rdata$r:0000A460 ; COMDAT (pick any)
.rdata$r:0000A460                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:0000A460 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A460 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:0000A460                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:0000A460                                         ; .rdata$r:0000A4BCo
.rdata$r:0000A460                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:0000A464                 db    0
.rdata$r:0000A465                 db    0
.rdata$r:0000A466                 db    0
.rdata$r:0000A467                 db    0
.rdata$r:0000A468                 db    0
.rdata$r:0000A469                 db    0
.rdata$r:0000A46A                 db    0
.rdata$r:0000A46B                 db    0
.rdata$r:0000A46C                 db 0FFh
.rdata$r:0000A46D                 db 0FFh
.rdata$r:0000A46E                 db 0FFh
.rdata$r:0000A46F                 db 0FFh
.rdata$r:0000A470                 db    0
.rdata$r:0000A471                 db    0
.rdata$r:0000A472                 db    0
.rdata$r:0000A473                 db    0
.rdata$r:0000A474                 db  40h ; @
.rdata$r:0000A475                 db    0
.rdata$r:0000A476                 db    0
.rdata$r:0000A477                 db    0
.rdata$r:0000A478                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A478 _rdata$r        ends
.rdata$r:0000A478
.rdata$r:0000A47C ; ===========================================================================
.rdata$r:0000A47C
.rdata$r:0000A47C ; Segment type: Pure data
.rdata$r:0000A47C ; Segment permissions: Read
.rdata$r:0000A47C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A47C                 assume cs:_rdata$r
.rdata$r:0000A47C                 ;org 0A47Ch
.rdata$r:0000A47C ; COMDAT (pick any)
.rdata$r:0000A47C                 public ??_R3exception@std@@8
.rdata$r:0000A47C ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A47C ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:0000A478o
.rdata$r:0000A47D                 db    0
.rdata$r:0000A47E                 db    0
.rdata$r:0000A47F                 db    0
.rdata$r:0000A480                 db    0
.rdata$r:0000A481                 db    0
.rdata$r:0000A482                 db    0
.rdata$r:0000A483                 db    0
.rdata$r:0000A484                 db    1
.rdata$r:0000A485                 db    0
.rdata$r:0000A486                 db    0
.rdata$r:0000A487                 db    0
.rdata$r:0000A488                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:0000A488 _rdata$r        ends
.rdata$r:0000A488
.rdata$r:0000A48C ; ===========================================================================
.rdata$r:0000A48C
.rdata$r:0000A48C ; Segment type: Pure data
.rdata$r:0000A48C ; Segment permissions: Read
.rdata$r:0000A48C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A48C                 assume cs:_rdata$r
.rdata$r:0000A48C                 ;org 0A48Ch
.rdata$r:0000A48C ; COMDAT (pick any)
.rdata$r:0000A48C                 public ??_R2exception@std@@8
.rdata$r:0000A48C ; std::exception::`RTTI Base Class Array'
.rdata$r:0000A48C ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:0000A48C                                         ; DATA XREF: .rdata$r:0000A488o
.rdata$r:0000A48C                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A490                 db    0
.rdata$r:0000A491                 align 4
.rdata$r:0000A491 _rdata$r        ends
.rdata$r:0000A491
.rdata$r:0000A494 ; ===========================================================================
.rdata$r:0000A494
.rdata$r:0000A494 ; Segment type: Pure data
.rdata$r:0000A494 ; Segment permissions: Read
.rdata$r:0000A494 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A494                 assume cs:_rdata$r
.rdata$r:0000A494                 ;org 0A494h
.rdata$r:0000A494 ; COMDAT (pick any)
.rdata$r:0000A494                 public ??_R4runtime_error@std@@6B@
.rdata$r:0000A494 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:0000A494 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:00009C70o
.rdata$r:0000A495                 db    0
.rdata$r:0000A496                 db    0
.rdata$r:0000A497                 db    0
.rdata$r:0000A498                 db    0
.rdata$r:0000A499                 db    0
.rdata$r:0000A49A                 db    0
.rdata$r:0000A49B                 db    0
.rdata$r:0000A49C                 db    0
.rdata$r:0000A49D                 db    0
.rdata$r:0000A49E                 db    0
.rdata$r:0000A49F                 db    0
.rdata$r:0000A4A0                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:0000A4A4                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A4A4 _rdata$r        ends
.rdata$r:0000A4A4
.rdata$r:0000A4A8 ; ===========================================================================
.rdata$r:0000A4A8
.rdata$r:0000A4A8 ; Segment type: Pure data
.rdata$r:0000A4A8 ; Segment permissions: Read
.rdata$r:0000A4A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A4A8                 assume cs:_rdata$r
.rdata$r:0000A4A8                 ;org 0A4A8h
.rdata$r:0000A4A8 ; COMDAT (pick any)
.rdata$r:0000A4A8                 public ??_R3runtime_error@std@@8
.rdata$r:0000A4A8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A4A8 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:0000A4A4o
.rdata$r:0000A4A8                                         ; .rdata$r:0000A4DCo
.rdata$r:0000A4A9                 db    0
.rdata$r:0000A4AA                 db    0
.rdata$r:0000A4AB                 db    0
.rdata$r:0000A4AC                 db    0
.rdata$r:0000A4AD                 db    0
.rdata$r:0000A4AE                 db    0
.rdata$r:0000A4AF                 db    0
.rdata$r:0000A4B0                 db    2
.rdata$r:0000A4B1                 db    0
.rdata$r:0000A4B2                 db    0
.rdata$r:0000A4B3                 db    0
.rdata$r:0000A4B4                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:0000A4B4 _rdata$r        ends
.rdata$r:0000A4B4
.rdata$r:0000A4B8 ; ===========================================================================
.rdata$r:0000A4B8
.rdata$r:0000A4B8 ; Segment type: Pure data
.rdata$r:0000A4B8 ; Segment permissions: Read
.rdata$r:0000A4B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A4B8                 assume cs:_rdata$r
.rdata$r:0000A4B8                 ;org 0A4B8h
.rdata$r:0000A4B8 ; COMDAT (pick any)
.rdata$r:0000A4B8                 public ??_R2runtime_error@std@@8
.rdata$r:0000A4B8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:0000A4B8 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:0000A4B8                                         ; DATA XREF: .rdata$r:0000A4B4o
.rdata$r:0000A4B8                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A4BC                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A4C0                 db    0
.rdata$r:0000A4C1                 align 4
.rdata$r:0000A4C1 _rdata$r        ends
.rdata$r:0000A4C1
.rdata$r:0000A4C4 ; ===========================================================================
.rdata$r:0000A4C4
.rdata$r:0000A4C4 ; Segment type: Pure data
.rdata$r:0000A4C4 ; Segment permissions: Read
.rdata$r:0000A4C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A4C4                 assume cs:_rdata$r
.rdata$r:0000A4C4                 ;org 0A4C4h
.rdata$r:0000A4C4 ; COMDAT (pick any)
.rdata$r:0000A4C4                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:0000A4C4 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A4C4 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:0000A4C4                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:0000A4C4                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:0000A4C8                 db    1
.rdata$r:0000A4C9                 db    0
.rdata$r:0000A4CA                 db    0
.rdata$r:0000A4CB                 db    0
.rdata$r:0000A4CC                 db    0
.rdata$r:0000A4CD                 db    0
.rdata$r:0000A4CE                 db    0
.rdata$r:0000A4CF                 db    0
.rdata$r:0000A4D0                 db 0FFh
.rdata$r:0000A4D1                 db 0FFh
.rdata$r:0000A4D2                 db 0FFh
.rdata$r:0000A4D3                 db 0FFh
.rdata$r:0000A4D4                 db    0
.rdata$r:0000A4D5                 db    0
.rdata$r:0000A4D6                 db    0
.rdata$r:0000A4D7                 db    0
.rdata$r:0000A4D8                 db  40h ; @
.rdata$r:0000A4D9                 db    0
.rdata$r:0000A4DA                 db    0
.rdata$r:0000A4DB                 db    0
.rdata$r:0000A4DC                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A4DC _rdata$r        ends
.rdata$r:0000A4DC
.rdata$r:0000A4E0 ; ===========================================================================
.rdata$r:0000A4E0
.rdata$r:0000A4E0 ; Segment type: Pure data
.rdata$r:0000A4E0 ; Segment permissions: Read
.rdata$r:0000A4E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A4E0                 assume cs:_rdata$r
.rdata$r:0000A4E0                 ;org 0A4E0h
.rdata$r:0000A4E0 ; COMDAT (pick any)
.rdata$r:0000A4E0                 public ??_R4Window@@6B@
.rdata$r:0000A4E0 ; const Window::`RTTI Complete Object Locator'
.rdata$r:0000A4E0 ??_R4Window@@6B@ db    0                ; DATA XREF: .rdata:00009C7Co
.rdata$r:0000A4E1                 db    0
.rdata$r:0000A4E2                 db    0
.rdata$r:0000A4E3                 db    0
.rdata$r:0000A4E4                 db    0
.rdata$r:0000A4E5                 db    0
.rdata$r:0000A4E6                 db    0
.rdata$r:0000A4E7                 db    0
.rdata$r:0000A4E8                 db    0
.rdata$r:0000A4E9                 db    0
.rdata$r:0000A4EA                 db    0
.rdata$r:0000A4EB                 db    0
.rdata$r:0000A4EC                 dd offset ??_R0?AVWindow@@@8 ; Window `RTTI Type Descriptor'
.rdata$r:0000A4F0                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A4F0 _rdata$r        ends
.rdata$r:0000A4F0
.data$r:0000A4F4 ; ===========================================================================
.data$r:0000A4F4
.data$r:0000A4F4 ; Segment type: Pure data
.data$r:0000A4F4 ; Segment permissions: Read/Write
.data$r:0000A4F4 _data$r         segment dword public 'DATA' use32
.data$r:0000A4F4                 assume cs:_data$r
.data$r:0000A4F4                 ;org 0A4F4h
.data$r:0000A4F4 ; COMDAT (pick any)
.data$r:0000A4F4                 public ??_R0?AVWindow@@@8
.data$r:0000A4F4 ; class Window `RTTI Type Descriptor'
.data$r:0000A4F4 ??_R0?AVWindow@@@8 dd offset ??_7type_info@@6B@
.data$r:0000A4F4                                         ; DATA XREF: .rdata$r:0000A4ECo
.data$r:0000A4F4                                         ; .rdata$r:Window::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000A4F4                                         ; const type_info::`vftable'
.data$r:0000A4F8                 db    0
.data$r:0000A4F9                 db    0
.data$r:0000A4FA                 db    0
.data$r:0000A4FB                 db    0
.data$r:0000A4FC                 db  2Eh ; .
.data$r:0000A4FD                 db  3Fh ; ?
.data$r:0000A4FE                 db  41h ; A
.data$r:0000A4FF                 db  56h ; V
.data$r:0000A500                 db  57h ; W
.data$r:0000A501                 db  69h ; i
.data$r:0000A502                 db  6Eh ; n
.data$r:0000A503                 db  64h ; d
.data$r:0000A504                 db  6Fh ; o
.data$r:0000A505                 db  77h ; w
.data$r:0000A506                 db  40h ; @
.data$r:0000A507                 db  40h ; @
.data$r:0000A508                 db    0
.data$r:0000A509                 align 4
.data$r:0000A509 _data$r         ends
.data$r:0000A509
.rdata$r:0000A50C ; ===========================================================================
.rdata$r:0000A50C
.rdata$r:0000A50C ; Segment type: Pure data
.rdata$r:0000A50C ; Segment permissions: Read
.rdata$r:0000A50C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A50C                 assume cs:_rdata$r
.rdata$r:0000A50C                 ;org 0A50Ch
.rdata$r:0000A50C ; COMDAT (pick any)
.rdata$r:0000A50C                 public ??_R3Window@@8
.rdata$r:0000A50C ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A50C ??_R3Window@@8  db    0                 ; DATA XREF: .rdata$r:0000A4F0o
.rdata$r:0000A50C                                         ; .rdata$r:0000A53Co
.rdata$r:0000A50D                 db    0
.rdata$r:0000A50E                 db    0
.rdata$r:0000A50F                 db    0
.rdata$r:0000A510                 db    0
.rdata$r:0000A511                 db    0
.rdata$r:0000A512                 db    0
.rdata$r:0000A513                 db    0
.rdata$r:0000A514                 db    1
.rdata$r:0000A515                 db    0
.rdata$r:0000A516                 db    0
.rdata$r:0000A517                 db    0
.rdata$r:0000A518                 dd offset ??_R2Window@@8 ; Window::`RTTI Base Class Array'
.rdata$r:0000A518 _rdata$r        ends
.rdata$r:0000A518
.rdata$r:0000A51C ; ===========================================================================
.rdata$r:0000A51C
.rdata$r:0000A51C ; Segment type: Pure data
.rdata$r:0000A51C ; Segment permissions: Read
.rdata$r:0000A51C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A51C                 assume cs:_rdata$r
.rdata$r:0000A51C                 ;org 0A51Ch
.rdata$r:0000A51C ; COMDAT (pick any)
.rdata$r:0000A51C                 public ??_R2Window@@8
.rdata$r:0000A51C ; Window::`RTTI Base Class Array'
.rdata$r:0000A51C ??_R2Window@@8  dd offset ??_R1A@?0A@EA@Window@@8
.rdata$r:0000A51C                                         ; DATA XREF: .rdata$r:0000A518o
.rdata$r:0000A51C                                         ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A520                 db    0
.rdata$r:0000A521                 align 4
.rdata$r:0000A521 _rdata$r        ends
.rdata$r:0000A521
.rdata$r:0000A524 ; ===========================================================================
.rdata$r:0000A524
.rdata$r:0000A524 ; Segment type: Pure data
.rdata$r:0000A524 ; Segment permissions: Read
.rdata$r:0000A524 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A524                 assume cs:_rdata$r
.rdata$r:0000A524                 ;org 0A524h
.rdata$r:0000A524 ; COMDAT (pick any)
.rdata$r:0000A524                 public ??_R1A@?0A@EA@Window@@8
.rdata$r:0000A524 ; Window::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A524 ??_R1A@?0A@EA@Window@@8 dd offset ??_R0?AVWindow@@@8
.rdata$r:0000A524                                         ; DATA XREF: .rdata$r:Window::`RTTI Base Class Array'o
.rdata$r:0000A524                                         ; .rdata$r:0000A764o ...
.rdata$r:0000A524                                         ; Window `RTTI Type Descriptor'
.rdata$r:0000A528                 align 10h
.rdata$r:0000A530                 db 0FFh
.rdata$r:0000A531                 db 0FFh
.rdata$r:0000A532                 db 0FFh
.rdata$r:0000A533                 db 0FFh
.rdata$r:0000A534                 db    0
.rdata$r:0000A535                 db    0
.rdata$r:0000A536                 db    0
.rdata$r:0000A537                 db    0
.rdata$r:0000A538                 db  40h ; @
.rdata$r:0000A539                 db    0
.rdata$r:0000A53A                 db    0
.rdata$r:0000A53B                 db    0
.rdata$r:0000A53C                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A53C _rdata$r        ends
.rdata$r:0000A53C
.rdata$r:0000A540 ; ===========================================================================
.rdata$r:0000A540
.rdata$r:0000A540 ; Segment type: Pure data
.rdata$r:0000A540 ; Segment permissions: Read
.rdata$r:0000A540 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A540                 assume cs:_rdata$r
.rdata$r:0000A540                 ;org 0A540h
.rdata$r:0000A540 ; COMDAT (pick any)
.rdata$r:0000A540                 public ??_R4error_category@std@@6B@
.rdata$r:0000A540 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000A540 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00009D40o
.rdata$r:0000A541                 db    0
.rdata$r:0000A542                 db    0
.rdata$r:0000A543                 db    0
.rdata$r:0000A544                 db    0
.rdata$r:0000A545                 db    0
.rdata$r:0000A546                 db    0
.rdata$r:0000A547                 db    0
.rdata$r:0000A548                 db    0
.rdata$r:0000A549                 db    0
.rdata$r:0000A54A                 db    0
.rdata$r:0000A54B                 db    0
.rdata$r:0000A54C                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000A550                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A550 _rdata$r        ends
.rdata$r:0000A550
.data$r:0000A554 ; ===========================================================================
.data$r:0000A554
.data$r:0000A554 ; Segment type: Pure data
.data$r:0000A554 ; Segment permissions: Read/Write
.data$r:0000A554 _data$r         segment dword public 'DATA' use32
.data$r:0000A554                 assume cs:_data$r
.data$r:0000A554                 ;org 0A554h
.data$r:0000A554 ; COMDAT (pick any)
.data$r:0000A554                 public ??_R0?AVerror_category@std@@@8
.data$r:0000A554 ; class std::error_category `RTTI Type Descriptor'
.data$r:0000A554 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000A554                                         ; DATA XREF: .rdata$r:0000A54Co
.data$r:0000A554                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000A554                                         ; const type_info::`vftable'
.data$r:0000A558                 db    0
.data$r:0000A559                 db    0
.data$r:0000A55A                 db    0
.data$r:0000A55B                 db    0
.data$r:0000A55C                 db  2Eh ; .
.data$r:0000A55D                 db  3Fh ; ?
.data$r:0000A55E                 db  41h ; A
.data$r:0000A55F                 db  56h ; V
.data$r:0000A560                 db  65h ; e
.data$r:0000A561                 db  72h ; r
.data$r:0000A562                 db  72h ; r
.data$r:0000A563                 db  6Fh ; o
.data$r:0000A564                 db  72h ; r
.data$r:0000A565                 db  5Fh ; _
.data$r:0000A566                 db  63h ; c
.data$r:0000A567                 db  61h ; a
.data$r:0000A568                 db  74h ; t
.data$r:0000A569                 db  65h ; e
.data$r:0000A56A                 db  67h ; g
.data$r:0000A56B                 db  6Fh ; o
.data$r:0000A56C                 db  72h ; r
.data$r:0000A56D                 db  79h ; y
.data$r:0000A56E                 db  40h ; @
.data$r:0000A56F                 db  73h ; s
.data$r:0000A570                 db  74h ; t
.data$r:0000A571                 db  64h ; d
.data$r:0000A572                 db  40h ; @
.data$r:0000A573                 db  40h ; @
.data$r:0000A574                 db    0
.data$r:0000A575                 align 4
.data$r:0000A575 _data$r         ends
.data$r:0000A575
.rdata$r:0000A578 ; ===========================================================================
.rdata$r:0000A578
.rdata$r:0000A578 ; Segment type: Pure data
.rdata$r:0000A578 ; Segment permissions: Read
.rdata$r:0000A578 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A578                 assume cs:_rdata$r
.rdata$r:0000A578                 ;org 0A578h
.rdata$r:0000A578 ; COMDAT (pick any)
.rdata$r:0000A578                 public ??_R3error_category@std@@8
.rdata$r:0000A578 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A578 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000A550o
.rdata$r:0000A578                                         ; .rdata$r:0000A5A8o
.rdata$r:0000A579                 db    0
.rdata$r:0000A57A                 db    0
.rdata$r:0000A57B                 db    0
.rdata$r:0000A57C                 db    0
.rdata$r:0000A57D                 db    0
.rdata$r:0000A57E                 db    0
.rdata$r:0000A57F                 db    0
.rdata$r:0000A580                 db    1
.rdata$r:0000A581                 db    0
.rdata$r:0000A582                 db    0
.rdata$r:0000A583                 db    0
.rdata$r:0000A584                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000A584 _rdata$r        ends
.rdata$r:0000A584
.rdata$r:0000A588 ; ===========================================================================
.rdata$r:0000A588
.rdata$r:0000A588 ; Segment type: Pure data
.rdata$r:0000A588 ; Segment permissions: Read
.rdata$r:0000A588 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A588                 assume cs:_rdata$r
.rdata$r:0000A588                 ;org 0A588h
.rdata$r:0000A588 ; COMDAT (pick any)
.rdata$r:0000A588                 public ??_R2error_category@std@@8
.rdata$r:0000A588 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000A588 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000A588                                         ; DATA XREF: .rdata$r:0000A584o
.rdata$r:0000A588                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A58C                 db    0
.rdata$r:0000A58D                 align 10h
.rdata$r:0000A58D _rdata$r        ends
.rdata$r:0000A58D
.rdata$r:0000A590 ; ===========================================================================
.rdata$r:0000A590
.rdata$r:0000A590 ; Segment type: Pure data
.rdata$r:0000A590 ; Segment permissions: Read
.rdata$r:0000A590 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A590                 assume cs:_rdata$r
.rdata$r:0000A590                 ;org 0A590h
.rdata$r:0000A590 ; COMDAT (pick any)
.rdata$r:0000A590                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000A590 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A590 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000A590                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000A590                                         ; .rdata$r:0000A600o ...
.rdata$r:0000A590                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000A594                 db    0
.rdata$r:0000A595                 db    0
.rdata$r:0000A596                 db    0
.rdata$r:0000A597                 db    0
.rdata$r:0000A598                 db    0
.rdata$r:0000A599                 db    0
.rdata$r:0000A59A                 db    0
.rdata$r:0000A59B                 db    0
.rdata$r:0000A59C                 db 0FFh
.rdata$r:0000A59D                 db 0FFh
.rdata$r:0000A59E                 db 0FFh
.rdata$r:0000A59F                 db 0FFh
.rdata$r:0000A5A0                 db    0
.rdata$r:0000A5A1                 db    0
.rdata$r:0000A5A2                 db    0
.rdata$r:0000A5A3                 db    0
.rdata$r:0000A5A4                 db  40h ; @
.rdata$r:0000A5A5                 db    0
.rdata$r:0000A5A6                 db    0
.rdata$r:0000A5A7                 db    0
.rdata$r:0000A5A8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A5A8 _rdata$r        ends
.rdata$r:0000A5A8
.rdata$r:0000A5AC ; ===========================================================================
.rdata$r:0000A5AC
.rdata$r:0000A5AC ; Segment type: Pure data
.rdata$r:0000A5AC ; Segment permissions: Read
.rdata$r:0000A5AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A5AC                 assume cs:_rdata$r
.rdata$r:0000A5AC                 ;org 0A5ACh
.rdata$r:0000A5AC ; COMDAT (pick any)
.rdata$r:0000A5AC                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000A5AC ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000A5AC ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000A5AC                                         ; DATA XREF: .rdata:00009D5Co
.rdata$r:0000A5AD                 db    0
.rdata$r:0000A5AE                 db    0
.rdata$r:0000A5AF                 db    0
.rdata$r:0000A5B0                 db    0
.rdata$r:0000A5B1                 db    0
.rdata$r:0000A5B2                 db    0
.rdata$r:0000A5B3                 db    0
.rdata$r:0000A5B4                 db    0
.rdata$r:0000A5B5                 db    0
.rdata$r:0000A5B6                 db    0
.rdata$r:0000A5B7                 db    0
.rdata$r:0000A5B8                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000A5BC                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A5BC _rdata$r        ends
.rdata$r:0000A5BC
.data$r:0000A5C0 ; ===========================================================================
.data$r:0000A5C0
.data$r:0000A5C0 ; Segment type: Pure data
.data$r:0000A5C0 ; Segment permissions: Read/Write
.data$r:0000A5C0 _data$r         segment dword public 'DATA' use32
.data$r:0000A5C0                 assume cs:_data$r
.data$r:0000A5C0                 ;org 0A5C0h
.data$r:0000A5C0 ; COMDAT (pick any)
.data$r:0000A5C0                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000A5C0 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000A5C0 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000A5C0                                         ; DATA XREF: .rdata$r:0000A5B8o
.data$r:0000A5C0                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000A5C0                                         ; const type_info::`vftable'
.data$r:0000A5C4                 align 8
.data$r:0000A5C8 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:0000A5EA                 align 4
.data$r:0000A5EA _data$r         ends
.data$r:0000A5EA
.rdata$r:0000A5EC ; ===========================================================================
.rdata$r:0000A5EC
.rdata$r:0000A5EC ; Segment type: Pure data
.rdata$r:0000A5EC ; Segment permissions: Read
.rdata$r:0000A5EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A5EC                 assume cs:_rdata$r
.rdata$r:0000A5EC                 ;org 0A5ECh
.rdata$r:0000A5EC ; COMDAT (pick any)
.rdata$r:0000A5EC                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000A5EC ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A5EC ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000A5EC                                         ; DATA XREF: .rdata$r:0000A5BCo
.rdata$r:0000A5EC                                         ; .rdata$r:0000A620o
.rdata$r:0000A5ED                 db    0
.rdata$r:0000A5EE                 db    0
.rdata$r:0000A5EF                 db    0
.rdata$r:0000A5F0                 db    0
.rdata$r:0000A5F1                 db    0
.rdata$r:0000A5F2                 db    0
.rdata$r:0000A5F3                 db    0
.rdata$r:0000A5F4                 db    2
.rdata$r:0000A5F5                 db    0
.rdata$r:0000A5F6                 db    0
.rdata$r:0000A5F7                 db    0
.rdata$r:0000A5F8                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000A5F8 _rdata$r        ends
.rdata$r:0000A5F8
.rdata$r:0000A5FC ; ===========================================================================
.rdata$r:0000A5FC
.rdata$r:0000A5FC ; Segment type: Pure data
.rdata$r:0000A5FC ; Segment permissions: Read
.rdata$r:0000A5FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A5FC                 assume cs:_rdata$r
.rdata$r:0000A5FC                 ;org 0A5FCh
.rdata$r:0000A5FC ; COMDAT (pick any)
.rdata$r:0000A5FC                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000A5FC ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000A5FC ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000A5FC                                         ; DATA XREF: .rdata$r:0000A5F8o
.rdata$r:0000A5FC                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A600                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A604                 db    0
.rdata$r:0000A605                 align 4
.rdata$r:0000A605 _rdata$r        ends
.rdata$r:0000A605
.rdata$r:0000A608 ; ===========================================================================
.rdata$r:0000A608
.rdata$r:0000A608 ; Segment type: Pure data
.rdata$r:0000A608 ; Segment permissions: Read
.rdata$r:0000A608 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A608                 assume cs:_rdata$r
.rdata$r:0000A608                 ;org 0A608h
.rdata$r:0000A608 ; COMDAT (pick any)
.rdata$r:0000A608                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000A608 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A608 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000A608                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000A608                                         ; .rdata$r:0000A678o ...
.rdata$r:0000A608                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000A60C                 db    1
.rdata$r:0000A60D                 db    0
.rdata$r:0000A60E                 db    0
.rdata$r:0000A60F                 db    0
.rdata$r:0000A610                 db    0
.rdata$r:0000A611                 db    0
.rdata$r:0000A612                 db    0
.rdata$r:0000A613                 db    0
.rdata$r:0000A614                 db 0FFh
.rdata$r:0000A615                 db 0FFh
.rdata$r:0000A616                 db 0FFh
.rdata$r:0000A617                 db 0FFh
.rdata$r:0000A618                 db    0
.rdata$r:0000A619                 db    0
.rdata$r:0000A61A                 db    0
.rdata$r:0000A61B                 db    0
.rdata$r:0000A61C                 db  40h ; @
.rdata$r:0000A61D                 db    0
.rdata$r:0000A61E                 db    0
.rdata$r:0000A61F                 db    0
.rdata$r:0000A620                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A620 _rdata$r        ends
.rdata$r:0000A620
.rdata$r:0000A624 ; ===========================================================================
.rdata$r:0000A624
.rdata$r:0000A624 ; Segment type: Pure data
.rdata$r:0000A624 ; Segment permissions: Read
.rdata$r:0000A624 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A624                 assume cs:_rdata$r
.rdata$r:0000A624                 ;org 0A624h
.rdata$r:0000A624 ; COMDAT (pick any)
.rdata$r:0000A624                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000A624 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000A624 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000A624                                         ; DATA XREF: .rdata:00009D90o
.rdata$r:0000A625                 db    0
.rdata$r:0000A626                 db    0
.rdata$r:0000A627                 db    0
.rdata$r:0000A628                 db    0
.rdata$r:0000A629                 db    0
.rdata$r:0000A62A                 db    0
.rdata$r:0000A62B                 db    0
.rdata$r:0000A62C                 db    0
.rdata$r:0000A62D                 db    0
.rdata$r:0000A62E                 db    0
.rdata$r:0000A62F                 db    0
.rdata$r:0000A630                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000A634                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A634 _rdata$r        ends
.rdata$r:0000A634
.data$r:0000A638 ; ===========================================================================
.data$r:0000A638
.data$r:0000A638 ; Segment type: Pure data
.data$r:0000A638 ; Segment permissions: Read/Write
.data$r:0000A638 _data$r         segment dword public 'DATA' use32
.data$r:0000A638                 assume cs:_data$r
.data$r:0000A638                 ;org 0A638h
.data$r:0000A638 ; COMDAT (pick any)
.data$r:0000A638                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000A638 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000A638 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000A638                                         ; DATA XREF: .rdata$r:0000A630o
.data$r:0000A638                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000A638                                         ; const type_info::`vftable'
.data$r:0000A63C                 align 10h
.data$r:0000A640 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:0000A663                 align 4
.data$r:0000A663 _data$r         ends
.data$r:0000A663
.rdata$r:0000A664 ; ===========================================================================
.rdata$r:0000A664
.rdata$r:0000A664 ; Segment type: Pure data
.rdata$r:0000A664 ; Segment permissions: Read
.rdata$r:0000A664 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A664                 assume cs:_rdata$r
.rdata$r:0000A664                 ;org 0A664h
.rdata$r:0000A664 ; COMDAT (pick any)
.rdata$r:0000A664                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000A664 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A664 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000A664                                         ; DATA XREF: .rdata$r:0000A634o
.rdata$r:0000A664                                         ; .rdata$r:0000A69Co
.rdata$r:0000A665                 db    0
.rdata$r:0000A666                 db    0
.rdata$r:0000A667                 db    0
.rdata$r:0000A668                 db    0
.rdata$r:0000A669                 db    0
.rdata$r:0000A66A                 db    0
.rdata$r:0000A66B                 db    0
.rdata$r:0000A66C                 db    3
.rdata$r:0000A66D                 db    0
.rdata$r:0000A66E                 db    0
.rdata$r:0000A66F                 db    0
.rdata$r:0000A670                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000A670 _rdata$r        ends
.rdata$r:0000A670
.rdata$r:0000A674 ; ===========================================================================
.rdata$r:0000A674
.rdata$r:0000A674 ; Segment type: Pure data
.rdata$r:0000A674 ; Segment permissions: Read
.rdata$r:0000A674 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A674                 assume cs:_rdata$r
.rdata$r:0000A674                 ;org 0A674h
.rdata$r:0000A674 ; COMDAT (pick any)
.rdata$r:0000A674                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000A674 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000A674 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000A674                                         ; DATA XREF: .rdata$r:0000A670o
.rdata$r:0000A674                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A678                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A67C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A680                 db    0
.rdata$r:0000A681                 align 4
.rdata$r:0000A681 _rdata$r        ends
.rdata$r:0000A681
.rdata$r:0000A684 ; ===========================================================================
.rdata$r:0000A684
.rdata$r:0000A684 ; Segment type: Pure data
.rdata$r:0000A684 ; Segment permissions: Read
.rdata$r:0000A684 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A684                 assume cs:_rdata$r
.rdata$r:0000A684                 ;org 0A684h
.rdata$r:0000A684 ; COMDAT (pick any)
.rdata$r:0000A684                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000A684 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A684 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000A684                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000A684                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000A688                 db    2
.rdata$r:0000A689                 db    0
.rdata$r:0000A68A                 db    0
.rdata$r:0000A68B                 db    0
.rdata$r:0000A68C                 db    0
.rdata$r:0000A68D                 db    0
.rdata$r:0000A68E                 db    0
.rdata$r:0000A68F                 db    0
.rdata$r:0000A690                 db 0FFh
.rdata$r:0000A691                 db 0FFh
.rdata$r:0000A692                 db 0FFh
.rdata$r:0000A693                 db 0FFh
.rdata$r:0000A694                 db    0
.rdata$r:0000A695                 db    0
.rdata$r:0000A696                 db    0
.rdata$r:0000A697                 db    0
.rdata$r:0000A698                 db  40h ; @
.rdata$r:0000A699                 db    0
.rdata$r:0000A69A                 db    0
.rdata$r:0000A69B                 db    0
.rdata$r:0000A69C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A69C _rdata$r        ends
.rdata$r:0000A69C
.rdata$r:0000A6A0 ; ===========================================================================
.rdata$r:0000A6A0
.rdata$r:0000A6A0 ; Segment type: Pure data
.rdata$r:0000A6A0 ; Segment permissions: Read
.rdata$r:0000A6A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A6A0                 assume cs:_rdata$r
.rdata$r:0000A6A0                 ;org 0A6A0h
.rdata$r:0000A6A0 ; COMDAT (pick any)
.rdata$r:0000A6A0                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000A6A0 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000A6A0 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00009DD0o
.rdata$r:0000A6A1                 db    0
.rdata$r:0000A6A2                 db    0
.rdata$r:0000A6A3                 db    0
.rdata$r:0000A6A4                 db    0
.rdata$r:0000A6A5                 db    0
.rdata$r:0000A6A6                 db    0
.rdata$r:0000A6A7                 db    0
.rdata$r:0000A6A8                 db    0
.rdata$r:0000A6A9                 db    0
.rdata$r:0000A6AA                 db    0
.rdata$r:0000A6AB                 db    0
.rdata$r:0000A6AC                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000A6B0                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A6B0 _rdata$r        ends
.rdata$r:0000A6B0
.data$r:0000A6B4 ; ===========================================================================
.data$r:0000A6B4
.data$r:0000A6B4 ; Segment type: Pure data
.data$r:0000A6B4 ; Segment permissions: Read/Write
.data$r:0000A6B4 _data$r         segment dword public 'DATA' use32
.data$r:0000A6B4                 assume cs:_data$r
.data$r:0000A6B4                 ;org 0A6B4h
.data$r:0000A6B4 ; COMDAT (pick any)
.data$r:0000A6B4                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000A6B4 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000A6B4 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000A6B4                                         ; DATA XREF: .rdata$r:0000A6ACo
.data$r:0000A6B4                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000A6B4                                         ; const type_info::`vftable'
.data$r:0000A6B8                 db    0
.data$r:0000A6B9                 db    0
.data$r:0000A6BA                 db    0
.data$r:0000A6BB                 db    0
.data$r:0000A6BC                 db  2Eh ; .
.data$r:0000A6BD                 db  3Fh ; ?
.data$r:0000A6BE                 db  41h ; A
.data$r:0000A6BF                 db  56h ; V
.data$r:0000A6C0                 db  5Fh ; _
.data$r:0000A6C1                 db  53h ; S
.data$r:0000A6C2                 db  79h ; y
.data$r:0000A6C3                 db  73h ; s
.data$r:0000A6C4                 db  74h ; t
.data$r:0000A6C5                 db  65h ; e
.data$r:0000A6C6                 db  6Dh ; m
.data$r:0000A6C7                 db  5Fh ; _
.data$r:0000A6C8                 db  65h ; e
.data$r:0000A6C9                 db  72h ; r
.data$r:0000A6CA                 db  72h ; r
.data$r:0000A6CB                 db  6Fh ; o
.data$r:0000A6CC                 db  72h ; r
.data$r:0000A6CD                 db  5Fh ; _
.data$r:0000A6CE                 db  63h ; c
.data$r:0000A6CF                 db  61h ; a
.data$r:0000A6D0                 db  74h ; t
.data$r:0000A6D1                 db  65h ; e
.data$r:0000A6D2                 db  67h ; g
.data$r:0000A6D3                 db  6Fh ; o
.data$r:0000A6D4                 db  72h ; r
.data$r:0000A6D5                 db  79h ; y
.data$r:0000A6D6                 db  40h ; @
.data$r:0000A6D7                 db  73h ; s
.data$r:0000A6D8                 db  74h ; t
.data$r:0000A6D9                 db  64h ; d
.data$r:0000A6DA                 db  40h ; @
.data$r:0000A6DB                 db  40h ; @
.data$r:0000A6DC                 db    0
.data$r:0000A6DD                 align 10h
.data$r:0000A6DD _data$r         ends
.data$r:0000A6DD
.rdata$r:0000A6E0 ; ===========================================================================
.rdata$r:0000A6E0
.rdata$r:0000A6E0 ; Segment type: Pure data
.rdata$r:0000A6E0 ; Segment permissions: Read
.rdata$r:0000A6E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A6E0                 assume cs:_rdata$r
.rdata$r:0000A6E0                 ;org 0A6E0h
.rdata$r:0000A6E0 ; COMDAT (pick any)
.rdata$r:0000A6E0                 public ??_R3_System_error_category@std@@8
.rdata$r:0000A6E0 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A6E0 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000A6B0o
.rdata$r:0000A6E0                                         ; .rdata$r:0000A718o
.rdata$r:0000A6E1                 db    0
.rdata$r:0000A6E2                 db    0
.rdata$r:0000A6E3                 db    0
.rdata$r:0000A6E4                 db    0
.rdata$r:0000A6E5                 db    0
.rdata$r:0000A6E6                 db    0
.rdata$r:0000A6E7                 db    0
.rdata$r:0000A6E8                 db    3
.rdata$r:0000A6E9                 db    0
.rdata$r:0000A6EA                 db    0
.rdata$r:0000A6EB                 db    0
.rdata$r:0000A6EC                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000A6EC _rdata$r        ends
.rdata$r:0000A6EC
.rdata$r:0000A6F0 ; ===========================================================================
.rdata$r:0000A6F0
.rdata$r:0000A6F0 ; Segment type: Pure data
.rdata$r:0000A6F0 ; Segment permissions: Read
.rdata$r:0000A6F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A6F0                 assume cs:_rdata$r
.rdata$r:0000A6F0                 ;org 0A6F0h
.rdata$r:0000A6F0 ; COMDAT (pick any)
.rdata$r:0000A6F0                 public ??_R2_System_error_category@std@@8
.rdata$r:0000A6F0 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000A6F0 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000A6F0                                         ; DATA XREF: .rdata$r:0000A6ECo
.rdata$r:0000A6F0                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A6F4                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A6F8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A6FC                 db    0
.rdata$r:0000A6FD                 align 10h
.rdata$r:0000A6FD _rdata$r        ends
.rdata$r:0000A6FD
.rdata$r:0000A700 ; ===========================================================================
.rdata$r:0000A700
.rdata$r:0000A700 ; Segment type: Pure data
.rdata$r:0000A700 ; Segment permissions: Read
.rdata$r:0000A700 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A700                 assume cs:_rdata$r
.rdata$r:0000A700                 ;org 0A700h
.rdata$r:0000A700 ; COMDAT (pick any)
.rdata$r:0000A700                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000A700 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A700 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0000A700                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0000A700                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000A704                 db    2
.rdata$r:0000A705                 db    0
.rdata$r:0000A706                 db    0
.rdata$r:0000A707                 db    0
.rdata$r:0000A708                 db    0
.rdata$r:0000A709                 db    0
.rdata$r:0000A70A                 db    0
.rdata$r:0000A70B                 db    0
.rdata$r:0000A70C                 db 0FFh
.rdata$r:0000A70D                 db 0FFh
.rdata$r:0000A70E                 db 0FFh
.rdata$r:0000A70F                 db 0FFh
.rdata$r:0000A710                 db    0
.rdata$r:0000A711                 db    0
.rdata$r:0000A712                 db    0
.rdata$r:0000A713                 db    0
.rdata$r:0000A714                 db  40h ; @
.rdata$r:0000A715                 db    0
.rdata$r:0000A716                 db    0
.rdata$r:0000A717                 db    0
.rdata$r:0000A718                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A718 _rdata$r        ends
.rdata$r:0000A718
.rdata$r:0000A71C ; ===========================================================================
.rdata$r:0000A71C
.rdata$r:0000A71C ; Segment type: Pure data
.rdata$r:0000A71C ; Segment permissions: Read
.rdata$r:0000A71C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A71C                 assume cs:_rdata$r
.rdata$r:0000A71C                 ;org 0A71Ch
.rdata$r:0000A71C ; COMDAT (pick any)
.rdata$r:0000A71C                 public ??_R4DockingSplitter@@6B@
.rdata$r:0000A71C ; const DockingSplitter::`RTTI Complete Object Locator'
.rdata$r:0000A71C ??_R4DockingSplitter@@6B@ db    0       ; DATA XREF: .rdata:00009E3Co
.rdata$r:0000A71D                 db    0
.rdata$r:0000A71E                 db    0
.rdata$r:0000A71F                 db    0
.rdata$r:0000A720                 db    0
.rdata$r:0000A721                 db    0
.rdata$r:0000A722                 db    0
.rdata$r:0000A723                 db    0
.rdata$r:0000A724                 db    0
.rdata$r:0000A725                 db    0
.rdata$r:0000A726                 db    0
.rdata$r:0000A727                 db    0
.rdata$r:0000A728                 dd offset ??_R0?AVDockingSplitter@@@8 ; DockingSplitter `RTTI Type Descriptor'
.rdata$r:0000A72C                 dd offset ??_R3DockingSplitter@@8 ; DockingSplitter::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A72C _rdata$r        ends
.rdata$r:0000A72C
.data$r:0000A730 ; ===========================================================================
.data$r:0000A730
.data$r:0000A730 ; Segment type: Pure data
.data$r:0000A730 ; Segment permissions: Read/Write
.data$r:0000A730 _data$r         segment dword public 'DATA' use32
.data$r:0000A730                 assume cs:_data$r
.data$r:0000A730                 ;org 0A730h
.data$r:0000A730 ; COMDAT (pick any)
.data$r:0000A730                 public ??_R0?AVDockingSplitter@@@8
.data$r:0000A730 ; class DockingSplitter `RTTI Type Descriptor'
.data$r:0000A730 ??_R0?AVDockingSplitter@@@8 dd offset ??_7type_info@@6B@
.data$r:0000A730                                         ; DATA XREF: .rdata$r:0000A728o
.data$r:0000A730                                         ; .rdata$r:DockingSplitter::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000A730                                         ; const type_info::`vftable'
.data$r:0000A734                 align 8
.data$r:0000A738 a_?avdockingspl db '.?AVDockingSplitter@@',0
.data$r:0000A74E                 align 10h
.data$r:0000A74E _data$r         ends
.data$r:0000A74E
.rdata$r:0000A750 ; ===========================================================================
.rdata$r:0000A750
.rdata$r:0000A750 ; Segment type: Pure data
.rdata$r:0000A750 ; Segment permissions: Read
.rdata$r:0000A750 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A750                 assume cs:_rdata$r
.rdata$r:0000A750                 ;org 0A750h
.rdata$r:0000A750 ; COMDAT (pick any)
.rdata$r:0000A750                 public ??_R3DockingSplitter@@8
.rdata$r:0000A750 ; DockingSplitter::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A750 ??_R3DockingSplitter@@8 db    0         ; DATA XREF: .rdata$r:0000A72Co
.rdata$r:0000A750                                         ; .rdata$r:0000A784o
.rdata$r:0000A751                 db    0
.rdata$r:0000A752                 db    0
.rdata$r:0000A753                 db    0
.rdata$r:0000A754                 db    0
.rdata$r:0000A755                 db    0
.rdata$r:0000A756                 db    0
.rdata$r:0000A757                 db    0
.rdata$r:0000A758                 db    2
.rdata$r:0000A759                 db    0
.rdata$r:0000A75A                 db    0
.rdata$r:0000A75B                 db    0
.rdata$r:0000A75C                 dd offset ??_R2DockingSplitter@@8 ; DockingSplitter::`RTTI Base Class Array'
.rdata$r:0000A75C _rdata$r        ends
.rdata$r:0000A75C
.rdata$r:0000A760 ; ===========================================================================
.rdata$r:0000A760
.rdata$r:0000A760 ; Segment type: Pure data
.rdata$r:0000A760 ; Segment permissions: Read
.rdata$r:0000A760 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A760                 assume cs:_rdata$r
.rdata$r:0000A760                 ;org 0A760h
.rdata$r:0000A760 ; COMDAT (pick any)
.rdata$r:0000A760                 public ??_R2DockingSplitter@@8
.rdata$r:0000A760 ; DockingSplitter::`RTTI Base Class Array'
.rdata$r:0000A760 ??_R2DockingSplitter@@8 dd offset ??_R1A@?0A@EA@DockingSplitter@@8
.rdata$r:0000A760                                         ; DATA XREF: .rdata$r:0000A75Co
.rdata$r:0000A760                                         ; DockingSplitter::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A764                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A768                 db    0
.rdata$r:0000A769                 align 4
.rdata$r:0000A769 _rdata$r        ends
.rdata$r:0000A769
.rdata$r:0000A76C ; ===========================================================================
.rdata$r:0000A76C
.rdata$r:0000A76C ; Segment type: Pure data
.rdata$r:0000A76C ; Segment permissions: Read
.rdata$r:0000A76C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A76C                 assume cs:_rdata$r
.rdata$r:0000A76C                 ;org 0A76Ch
.rdata$r:0000A76C ; COMDAT (pick any)
.rdata$r:0000A76C                 public ??_R1A@?0A@EA@DockingSplitter@@8
.rdata$r:0000A76C ; DockingSplitter::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A76C ??_R1A@?0A@EA@DockingSplitter@@8 dd offset ??_R0?AVDockingSplitter@@@8
.rdata$r:0000A76C                                         ; DATA XREF: .rdata$r:DockingSplitter::`RTTI Base Class Array'o
.rdata$r:0000A76C                                         ; DockingSplitter `RTTI Type Descriptor'
.rdata$r:0000A770                 db    1
.rdata$r:0000A771                 db    0
.rdata$r:0000A772                 db    0
.rdata$r:0000A773                 db    0
.rdata$r:0000A774                 db    0
.rdata$r:0000A775                 db    0
.rdata$r:0000A776                 db    0
.rdata$r:0000A777                 db    0
.rdata$r:0000A778                 db 0FFh
.rdata$r:0000A779                 db 0FFh
.rdata$r:0000A77A                 db 0FFh
.rdata$r:0000A77B                 db 0FFh
.rdata$r:0000A77C                 db    0
.rdata$r:0000A77D                 db    0
.rdata$r:0000A77E                 db    0
.rdata$r:0000A77F                 db    0
.rdata$r:0000A780                 db  40h ; @
.rdata$r:0000A781                 db    0
.rdata$r:0000A782                 db    0
.rdata$r:0000A783                 db    0
.rdata$r:0000A784                 dd offset ??_R3DockingSplitter@@8 ; DockingSplitter::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A784 _rdata$r        ends
.rdata$r:0000A784
.rdata$r:0000A788 ; ===========================================================================
.rdata$r:0000A788
.rdata$r:0000A788 ; Segment type: Pure data
.rdata$r:0000A788 ; Segment permissions: Read
.rdata$r:0000A788 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A788                 assume cs:_rdata$r
.rdata$r:0000A788                 ;org 0A788h
.rdata$r:0000A788 ; COMDAT (pick any)
.rdata$r:0000A788                 public ??_R4DockingManager@@6B@
.rdata$r:0000A788 ; const DockingManager::`RTTI Complete Object Locator'
.rdata$r:0000A788 ??_R4DockingManager@@6B@ db    0        ; DATA XREF: .rdata:00009E08o
.rdata$r:0000A789                 db    0
.rdata$r:0000A78A                 db    0
.rdata$r:0000A78B                 db    0
.rdata$r:0000A78C                 db    0
.rdata$r:0000A78D                 db    0
.rdata$r:0000A78E                 db    0
.rdata$r:0000A78F                 db    0
.rdata$r:0000A790                 db    0
.rdata$r:0000A791                 db    0
.rdata$r:0000A792                 db    0
.rdata$r:0000A793                 db    0
.rdata$r:0000A794                 dd offset ??_R0?AVDockingManager@@@8 ; DockingManager `RTTI Type Descriptor'
.rdata$r:0000A798                 dd offset ??_R3DockingManager@@8 ; DockingManager::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A798 _rdata$r        ends
.rdata$r:0000A798
.data$r:0000A79C ; ===========================================================================
.data$r:0000A79C
.data$r:0000A79C ; Segment type: Pure data
.data$r:0000A79C ; Segment permissions: Read/Write
.data$r:0000A79C _data$r         segment dword public 'DATA' use32
.data$r:0000A79C                 assume cs:_data$r
.data$r:0000A79C                 ;org 0A79Ch
.data$r:0000A79C ; COMDAT (pick any)
.data$r:0000A79C                 public ??_R0?AVDockingManager@@@8
.data$r:0000A79C ; class DockingManager `RTTI Type Descriptor'
.data$r:0000A79C ??_R0?AVDockingManager@@@8 dd offset ??_7type_info@@6B@
.data$r:0000A79C                                         ; DATA XREF: .rdata$r:0000A794o
.data$r:0000A79C                                         ; .rdata$r:DockingManager::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000A79C                                         ; const type_info::`vftable'
.data$r:0000A7A0                 db    0
.data$r:0000A7A1                 db    0
.data$r:0000A7A2                 db    0
.data$r:0000A7A3                 db    0
.data$r:0000A7A4                 db  2Eh ; .
.data$r:0000A7A5                 db  3Fh ; ?
.data$r:0000A7A6                 db  41h ; A
.data$r:0000A7A7                 db  56h ; V
.data$r:0000A7A8                 db  44h ; D
.data$r:0000A7A9                 db  6Fh ; o
.data$r:0000A7AA                 db  63h ; c
.data$r:0000A7AB                 db  6Bh ; k
.data$r:0000A7AC                 db  69h ; i
.data$r:0000A7AD                 db  6Eh ; n
.data$r:0000A7AE                 db  67h ; g
.data$r:0000A7AF                 db  4Dh ; M
.data$r:0000A7B0                 db  61h ; a
.data$r:0000A7B1                 db  6Eh ; n
.data$r:0000A7B2                 db  61h ; a
.data$r:0000A7B3                 db  67h ; g
.data$r:0000A7B4                 db  65h ; e
.data$r:0000A7B5                 db  72h ; r
.data$r:0000A7B6                 db  40h ; @
.data$r:0000A7B7                 db  40h ; @
.data$r:0000A7B8                 db    0
.data$r:0000A7B9                 align 4
.data$r:0000A7B9 _data$r         ends
.data$r:0000A7B9
.rdata$r:0000A7BC ; ===========================================================================
.rdata$r:0000A7BC
.rdata$r:0000A7BC ; Segment type: Pure data
.rdata$r:0000A7BC ; Segment permissions: Read
.rdata$r:0000A7BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A7BC                 assume cs:_rdata$r
.rdata$r:0000A7BC                 ;org 0A7BCh
.rdata$r:0000A7BC ; COMDAT (pick any)
.rdata$r:0000A7BC                 public ??_R3DockingManager@@8
.rdata$r:0000A7BC ; DockingManager::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A7BC ??_R3DockingManager@@8 db    0          ; DATA XREF: .rdata$r:0000A798o
.rdata$r:0000A7BC                                         ; .rdata$r:0000A7F0o
.rdata$r:0000A7BD                 db    0
.rdata$r:0000A7BE                 db    0
.rdata$r:0000A7BF                 db    0
.rdata$r:0000A7C0                 db    0
.rdata$r:0000A7C1                 db    0
.rdata$r:0000A7C2                 db    0
.rdata$r:0000A7C3                 db    0
.rdata$r:0000A7C4                 db    2
.rdata$r:0000A7C5                 db    0
.rdata$r:0000A7C6                 db    0
.rdata$r:0000A7C7                 db    0
.rdata$r:0000A7C8                 dd offset ??_R2DockingManager@@8 ; DockingManager::`RTTI Base Class Array'
.rdata$r:0000A7C8 _rdata$r        ends
.rdata$r:0000A7C8
.rdata$r:0000A7CC ; ===========================================================================
.rdata$r:0000A7CC
.rdata$r:0000A7CC ; Segment type: Pure data
.rdata$r:0000A7CC ; Segment permissions: Read
.rdata$r:0000A7CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A7CC                 assume cs:_rdata$r
.rdata$r:0000A7CC                 ;org 0A7CCh
.rdata$r:0000A7CC ; COMDAT (pick any)
.rdata$r:0000A7CC                 public ??_R2DockingManager@@8
.rdata$r:0000A7CC ; DockingManager::`RTTI Base Class Array'
.rdata$r:0000A7CC ??_R2DockingManager@@8 dd offset ??_R1A@?0A@EA@DockingManager@@8
.rdata$r:0000A7CC                                         ; DATA XREF: .rdata$r:0000A7C8o
.rdata$r:0000A7CC                                         ; DockingManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A7D0                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000A7D4                 db    0
.rdata$r:0000A7D5                 align 4
.rdata$r:0000A7D5 _rdata$r        ends
.rdata$r:0000A7D5
.rdata$r:0000A7D8 ; ===========================================================================
.rdata$r:0000A7D8
.rdata$r:0000A7D8 ; Segment type: Pure data
.rdata$r:0000A7D8 ; Segment permissions: Read
.rdata$r:0000A7D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000A7D8                 assume cs:_rdata$r
.rdata$r:0000A7D8                 ;org 0A7D8h
.rdata$r:0000A7D8 ; COMDAT (pick any)
.rdata$r:0000A7D8                 public ??_R1A@?0A@EA@DockingManager@@8
.rdata$r:0000A7D8 ; DockingManager::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000A7D8 ??_R1A@?0A@EA@DockingManager@@8 dd offset ??_R0?AVDockingManager@@@8
.rdata$r:0000A7D8                                         ; DATA XREF: .rdata$r:DockingManager::`RTTI Base Class Array'o
.rdata$r:0000A7D8                                         ; DockingManager `RTTI Type Descriptor'
.rdata$r:0000A7DC                 db    1
.rdata$r:0000A7DD                 db    0
.rdata$r:0000A7DE                 db    0
.rdata$r:0000A7DF                 db    0
.rdata$r:0000A7E0                 db    0
.rdata$r:0000A7E1                 db    0
.rdata$r:0000A7E2                 db    0
.rdata$r:0000A7E3                 db    0
.rdata$r:0000A7E4                 db 0FFh
.rdata$r:0000A7E5                 db 0FFh
.rdata$r:0000A7E6                 db 0FFh
.rdata$r:0000A7E7                 db 0FFh
.rdata$r:0000A7E8                 db    0
.rdata$r:0000A7E9                 db    0
.rdata$r:0000A7EA                 db    0
.rdata$r:0000A7EB                 db    0
.rdata$r:0000A7EC                 db  40h ; @
.rdata$r:0000A7ED                 db    0
.rdata$r:0000A7EE                 db    0
.rdata$r:0000A7EF                 db    0
.rdata$r:0000A7F0                 dd offset ??_R3DockingManager@@8 ; DockingManager::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000A7F0 _rdata$r        ends
.rdata$r:0000A7F0
.CRT$XCU:0000A7F4 ; ===========================================================================
.CRT$XCU:0000A7F4
.CRT$XCU:0000A7F4 ; Segment type: Pure data
.CRT$XCU:0000A7F4 ; Segment permissions: Read
.CRT$XCU:0000A7F4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000A7F4                 assume cs:_CRT$XCU
.CRT$XCU:0000A7F4                 ;org 0A7F4h
.CRT$XCU:0000A7F4 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0000A7F8 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:0000A7F8 _CRT$XCU        ends
.CRT$XCU:0000A7F8
.CRT$XCU:0000A7FC ; ===========================================================================
.CRT$XCU:0000A7FC
.CRT$XCU:0000A7FC ; Segment type: Pure data
.CRT$XCU:0000A7FC ; Segment permissions: Read
.CRT$XCU:0000A7FC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000A7FC                 assume cs:_CRT$XCU
.CRT$XCU:0000A7FC                 ;org 0A7FCh
.CRT$XCU:0000A7FC ; COMDAT (pick associative to section at 9DF4)
.CRT$XCU:0000A7FC ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000A7FC ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000A7FC _CRT$XCU        ends
.CRT$XCU:0000A7FC
.CRT$XCU:0000A800 ; ===========================================================================
.CRT$XCU:0000A800
.CRT$XCU:0000A800 ; Segment type: Pure data
.CRT$XCU:0000A800 ; Segment permissions: Read
.CRT$XCU:0000A800 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000A800                 assume cs:_CRT$XCU
.CRT$XCU:0000A800                 ;org 0A800h
.CRT$XCU:0000A800 ; COMDAT (pick associative to section at 9DF8)
.CRT$XCU:0000A800 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000A800 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000A800 _CRT$XCU        ends
.CRT$XCU:0000A800
.CRT$XCU:0000A804 ; ===========================================================================
.CRT$XCU:0000A804
.CRT$XCU:0000A804 ; Segment type: Pure data
.CRT$XCU:0000A804 ; Segment permissions: Read
.CRT$XCU:0000A804 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000A804                 assume cs:_CRT$XCU
.CRT$XCU:0000A804                 ;org 0A804h
.CRT$XCU:0000A804 ; COMDAT (pick associative to section at 9DFC)
.CRT$XCU:0000A804 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000A804 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000A804 _CRT$XCU        ends
.CRT$XCU:0000A804
.CRT$XCU:0000A808 ; ===========================================================================
.CRT$XCU:0000A808
.CRT$XCU:0000A808 ; Segment type: Pure data
.CRT$XCU:0000A808 ; Segment permissions: Read
.CRT$XCU:0000A808 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000A808                 assume cs:_CRT$XCU
.CRT$XCU:0000A808                 ;org 0A808h
.CRT$XCU:0000A808 ; COMDAT (pick associative to section at 9E00)
.CRT$XCU:0000A808 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:0000A808 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:0000A808 _CRT$XCU        ends
.CRT$XCU:0000A808
.CRT$XCU:0000A80C ; ===========================================================================
.CRT$XCU:0000A80C
.CRT$XCU:0000A80C ; Segment type: Pure data
.CRT$XCU:0000A80C ; Segment permissions: Read
.CRT$XCU:0000A80C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000A80C                 assume cs:_CRT$XCU
.CRT$XCU:0000A80C                 ;org 0A80Ch
.CRT$XCU:0000A80C ; COMDAT (pick associative to section at 9E04)
.CRT$XCU:0000A80C ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000A80C ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000A80C _CRT$XCU        ends
.CRT$XCU:0000A80C
.CRT$XCU:0000A810 ; ===========================================================================
.CRT$XCU:0000A810
.CRT$XCU:0000A810 ; Segment type: Pure data
.CRT$XCU:0000A810 ; Segment permissions: Read
.CRT$XCU:0000A810 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000A810                 assume cs:_CRT$XCU
.CRT$XCU:0000A810                 ;org 0A810h
.CRT$XCU:0000A810 ; COMDAT (pick associative to section at 9F00)
.CRT$XCU:0000A810 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000A810 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000A810 _CRT$XCU        ends
.CRT$XCU:0000A810
.CRT$XCU:0000A814 ; ===========================================================================
.CRT$XCU:0000A814
.CRT$XCU:0000A814 ; Segment type: Pure data
.CRT$XCU:0000A814 ; Segment permissions: Read
.CRT$XCU:0000A814 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000A814                 assume cs:_CRT$XCU
.CRT$XCU:0000A814                 ;org 0A814h
.CRT$XCU:0000A814 ; COMDAT (pick associative to section at 9F04)
.CRT$XCU:0000A814 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:0000A814 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:0000A814 _CRT$XCU        ends
.CRT$XCU:0000A814
UNDEF:0000A820 ; ===========================================================================
UNDEF:0000A820
UNDEF:0000A820 ; Segment type: Externs
UNDEF:0000A820 ; UNDEF
UNDEF:0000A820                 extrn __purecall:near   ; DATA XREF: .rdata:00009C88o
UNDEF:0000A820                                         ; .rdata:00009D48o ...
UNDEF:0000A824 ; void *__cdecl operator new(unsigned int)
UNDEF:0000A824                 extrn ??2@YAPAXI@Z:near ; CODE XREF: DockingManager::DockingManager(void)+117p
UNDEF:0000A824                                         ; DockingManager::DockingManager(void)+161p ...
UNDEF:0000A828 ; void __cdecl operator delete(void *)
UNDEF:0000A828                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$??0DockingManager@@QAE@XZ$4+4p
UNDEF:0000A828                                         ; __unwindfunclet$??0DockingManager@@QAE@XZ$5+4p ...
UNDEF:0000A82C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000A82C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000A82C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:0000A830                 extrn __invalid_parameter:near
UNDEF:0000A830                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+74p
UNDEF:0000A830                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+74p ...
UNDEF:0000A834 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000A834                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000A834                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:0000A834                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:0000A838 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000A838                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000A838                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:0000A838                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000A83C                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000A840 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000A840                 extrn _memmove:near     ; CODE XREF: std::_Uninit_copy<tTbData * const,tTbData *>(tTbData * const *,tTbData * const *,tTbData * *,std::_Wrap_alloc<std::allocator<tTbData *>> &,std::_Scalar_ptr_iterator_tag)+4Fp
UNDEF:0000A840                                         ; std::_Uninit_move<HWND__ *,HWND__ *,HWND__ *>(HWND__ * *,HWND__ * *,HWND__ * *,std::_Wrap_alloc<std::allocator<HWND__ *>> &,HWND__ * *,std::_Scalar_ptr_iterator_tag)+4Fp ...
UNDEF:0000A844 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000A844                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:0000A848 ; int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size)
UNDEF:0000A848                 extrn _memcmp:near      ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+C1p
UNDEF:0000A84C ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:0000A84C                 extrn _memset:near      ; CODE XREF: DockingManager::DockingManager(void)+97p
UNDEF:0000A850 ; size_t __cdecl strlen(const char *Str)
UNDEF:0000A850                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000A854 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:0000A854                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:0000A854                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:0000A858 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:0000A858                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:0000A858                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:0000A858                                         ; DATA XREF: .xdata$x:00009D3Co
UNDEF:0000A85C ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:0000A85C                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:0000A85C                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:0000A85C                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:0000A860 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:0000A860                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:0000A860                                         ; DATA XREF: .rdata:00009C78o
UNDEF:0000A864 ; void __cdecl operator delete[](void *)
UNDEF:0000A864                 extrn ??_V@YAXPAX@Z:near
UNDEF:0000A864                                         ; CODE XREF: DockingManager::FindEmptyContainer(void)+1A6p
UNDEF:0000A868 ; void *__cdecl operator new[](unsigned int)
UNDEF:0000A868                 extrn ??_U@YAPAXI@Z:near
UNDEF:0000A868                                         ; CODE XREF: DockingManager::FindEmptyContainer(void)+4Ep
UNDEF:0000A86C                 extrn __CrtDbgReportW:near
UNDEF:0000A86C                                         ; CODE XREF: std::vector<HWND__ *,std::allocator<HWND__ *>>::operator[](uint)+50p
UNDEF:0000A86C                                         ; std::vector<tTbData *,std::allocator<tTbData *>>::operator[](uint)+50p ...
UNDEF:0000A870 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000A870                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000A870                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000A870                                         ; std::_Debug_pointer<HWND__ *>(HWND__ * *,wchar_t const *,uint)+16p ...
UNDEF:0000A874 ; void __cdecl std::_Xbad_alloc()
UNDEF:0000A874                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000A874                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_2B22p
UNDEF:0000A874                                         ; std::_Allocate<HWND__ *>(uint,HWND__ * *):loc_2B64p ...
UNDEF:0000A878 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000A878                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000A878                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000A878                                         ; std::vector<HWND__ *,std::allocator<HWND__ *>>::_Xlen(void)+Cp ...
UNDEF:0000A87C ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000A87C                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000A87C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000A880 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:0000A880                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:0000A880                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:0000A884 ; DWORD __stdcall GetCurrentThreadId()
UNDEF:0000A884                 extrn __imp__GetCurrentThreadId@0:near
UNDEF:0000A884                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+244p
UNDEF:0000A884                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+244r
UNDEF:0000A888 ; int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator)
UNDEF:0000A888                 extrn __imp__MulDiv@12:near
UNDEF:0000A888                                         ; CODE XREF: DPIManager::scaleY(int)+14p
UNDEF:0000A888                                         ; DATA XREF: DPIManager::scaleY(int)+14r
UNDEF:0000A88C ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000A88C                 extrn __imp__SendMessageW@16:near
UNDEF:0000A88C                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+DDp
UNDEF:0000A88C                                         ; DockingManager::runProc(HWND__ *,uint,uint,long)+FDp ...
UNDEF:0000A890 ; BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000A890                 extrn __imp__PostMessageW@16:near
UNDEF:0000A890                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+553p
UNDEF:0000A890                                         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+553r
UNDEF:0000A894 ; LRESULT __stdcall DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000A894                 extrn __imp__DefWindowProcW@16:near
UNDEF:0000A894                                         ; CODE XREF: DockingManager::staticWinProc(HWND__ *,uint,uint,long)+6Bp
UNDEF:0000A894                                         ; DockingManager::runProc(HWND__ *,uint,uint,long)+5FDp
UNDEF:0000A894                                         ; DATA XREF: ...
UNDEF:0000A898 ; ATOM __stdcall RegisterClassW(const WNDCLASSW *lpWndClass)
UNDEF:0000A898                 extrn __imp__RegisterClassW@4:near
UNDEF:0000A898                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+7Bp
UNDEF:0000A898                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+7Br
UNDEF:0000A89C ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:0000A89C                 extrn __imp__CreateWindowExW@48:near
UNDEF:0000A89C                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+E6p
UNDEF:0000A89C                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+E6r
UNDEF:0000A8A0 ; BOOL __stdcall IsChild(HWND hWndParent, HWND hWnd)
UNDEF:0000A8A0                 extrn __imp__IsChild@8:near
UNDEF:0000A8A0                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+239p
UNDEF:0000A8A0                                         ; FocusWndProc(int,uint,long)+BFp
UNDEF:0000A8A0                                         ; DATA XREF: ...
UNDEF:0000A8A4 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:0000A8A4                 extrn __imp__DestroyWindow@4:near
UNDEF:0000A8A4                                         ; CODE XREF: DockingManager::destroy(void)+Ep
UNDEF:0000A8A4                                         ; DATA XREF: DockingManager::destroy(void)+Er
UNDEF:0000A8A8 ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:0000A8A8                 extrn __imp__ShowWindow@8:near
UNDEF:0000A8A8                                         ; CODE XREF: Window::display(bool)+2Cp
UNDEF:0000A8A8                                         ; DATA XREF: Window::display(bool)+2Cr
UNDEF:0000A8AC ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:0000A8AC                 extrn __imp__MoveWindow@24:near
UNDEF:0000A8AC                                         ; CODE XREF: Window::reSizeTo(tagRECT &)+2Bp
UNDEF:0000A8AC                                         ; Window::reSizeToWH(tagRECT &)+36p
UNDEF:0000A8AC                                         ; DATA XREF: ...
UNDEF:0000A8B0 ; BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
UNDEF:0000A8B0                 extrn __imp__SetWindowPos@28:near
UNDEF:0000A8B0                                         ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+657p
UNDEF:0000A8B0                                         ; DockingManager::reSizeTo(tagRECT &)+712p ...
UNDEF:0000A8B4 ; BOOL __stdcall IsWindowVisible(HWND hWnd)
UNDEF:0000A8B4                 extrn __imp__IsWindowVisible@4:near
UNDEF:0000A8B4                                         ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+EDp
UNDEF:0000A8B4                                         ; Window::getHeight(void)+2Bp ...
UNDEF:0000A8B8 ; int __stdcall GetDlgCtrlID(HWND hWnd)
UNDEF:0000A8B8                 extrn __imp__GetDlgCtrlID@4:near
UNDEF:0000A8B8                                         ; CODE XREF: DockingManager::SendNotify(HWND__ *,uint)+1Fp
UNDEF:0000A8B8                                         ; DATA XREF: DockingManager::SendNotify(HWND__ *,uint)+1Fr
UNDEF:0000A8BC ; HWND __stdcall GetActiveWindow()
UNDEF:0000A8BC                 extrn __imp__GetActiveWindow@0:near
UNDEF:0000A8BC                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long):$LN37p
UNDEF:0000A8BC                                         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long):$LN37r
UNDEF:0000A8C0 ; HWND __stdcall GetFocus()
UNDEF:0000A8C0                 extrn __imp__GetFocus@0:near
UNDEF:0000A8C0                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+21Bp
UNDEF:0000A8C0                                         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+21Br
UNDEF:0000A8C4 ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:0000A8C4                 extrn __imp__UpdateWindow@4:near
UNDEF:0000A8C4                                         ; CODE XREF: Window::redraw(bool)+27p
UNDEF:0000A8C4                                         ; DATA XREF: Window::redraw(bool)+27r
UNDEF:0000A8C8 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:0000A8C8                 extrn __imp__InvalidateRect@12:near
UNDEF:0000A8C8                                         ; CODE XREF: Window::redraw(bool)+12p
UNDEF:0000A8C8                                         ; DATA XREF: Window::redraw(bool)+12r
UNDEF:0000A8CC ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000A8CC                 extrn __imp__GetClientRect@8:near
UNDEF:0000A8CC                                         ; CODE XREF: Window::getClientRect(tagRECT &)+12p
UNDEF:0000A8CC                                         ; Window::getHeight(void)+1Ep ...
UNDEF:0000A8D0 ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000A8D0                 extrn __imp__GetWindowRect@8:near
UNDEF:0000A8D0                                         ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+D9p
UNDEF:0000A8D0                                         ; Window::getWindowRect(tagRECT &)+12p
UNDEF:0000A8D0                                         ; DATA XREF: ...
UNDEF:0000A8D4 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:0000A8D4                 extrn __imp__GetWindowLongW@8:near
UNDEF:0000A8D4                                         ; CODE XREF: DockingManager::staticWinProc(HWND__ *,uint,uint,long)+4Cp
UNDEF:0000A8D4                                         ; DockingManager::SendNotify(HWND__ *,uint)+42p ...
UNDEF:0000A8D8 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:0000A8D8                 extrn __imp__SetWindowLongW@12:near
UNDEF:0000A8D8                                         ; CODE XREF: DockingManager::staticWinProc(HWND__ *,uint,uint,long)+39p
UNDEF:0000A8D8                                         ; DATA XREF: DockingManager::staticWinProc(HWND__ *,uint,uint,long)+39r
UNDEF:0000A8DC ; HWND __stdcall SetParent(HWND hWndChild, HWND hWndNewParent)
UNDEF:0000A8DC                 extrn __imp__SetParent@8:near
UNDEF:0000A8DC                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+1A5p
UNDEF:0000A8DC                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+1A5r
UNDEF:0000A8E0 ; HHOOK __stdcall SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
UNDEF:0000A8E0                 extrn __imp__SetWindowsHookExW@16:near
UNDEF:0000A8E0                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+256p
UNDEF:0000A8E0                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+256r
UNDEF:0000A8E4 ; BOOL __stdcall UnhookWindowsHookEx(HHOOK hhk)
UNDEF:0000A8E4                 extrn __imp__UnhookWindowsHookEx@4:near
UNDEF:0000A8E4                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+127p
UNDEF:0000A8E4                                         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+127r
UNDEF:0000A8E8 ; LRESULT __stdcall CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
UNDEF:0000A8E8                 extrn __imp__CallNextHookEx@16:near
UNDEF:0000A8E8                                         ; CODE XREF: FocusWndProc(int,uint,long)+EEp
UNDEF:0000A8E8                                         ; DATA XREF: FocusWndProc(int,uint,long)+EEr
UNDEF:0000A8EC ; HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
UNDEF:0000A8EC                 extrn __imp__LoadCursorW@8:near
UNDEF:0000A8EC                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+59p
UNDEF:0000A8EC                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+59r
UNDEF:0000A8F0 ; void __stdcall CoUninitialize()
UNDEF:0000A8F0                 extrn __imp__CoUninitialize@0:near
UNDEF:0000A8F0                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long):loc_1FC1p
UNDEF:0000A8F0                                         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long):loc_1FC1r
UNDEF:0000A8F4 ; HRESULT __stdcall CoInitialize(LPVOID pvReserved)
UNDEF:0000A8F4                 extrn __imp__CoInitialize@4:near
UNDEF:0000A8F4                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+235p
UNDEF:0000A8F4                                         ; DATA XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+235r
UNDEF:0000A8F8 ; HIMAGELIST __stdcall ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow)
UNDEF:0000A8F8                 extrn __imp__ImageList_Create@20:near
UNDEF:0000A8F8                                         ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+66p
UNDEF:0000A8F8                                         ; DATA XREF: DockingManager::createDockableDlg(tTbData,int,bool)+66r
UNDEF:0000A8FC ; BOOL __stdcall ImageList_Destroy(HIMAGELIST himl)
UNDEF:0000A8FC                 extrn __imp__ImageList_Destroy@4:near
UNDEF:0000A8FC                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+151p
UNDEF:0000A8FC                                         ; DATA XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+151r
UNDEF:0000A900 ; int __stdcall ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon)
UNDEF:0000A900                 extrn __imp__ImageList_ReplaceIcon@12:near
UNDEF:0000A900                                         ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+7Fp
UNDEF:0000A900                                         ; DATA XREF: DockingManager::createDockableDlg(tTbData,int,bool)+7Fr
UNDEF:0000A904 ; public: virtual void * __thiscall Window::`vector deleting destructor'(unsigned int)
UNDEF:0000A904                 extrn ??_EWindow@@UAEPAXI@Z:near ; weak
UNDEF:0000A904                                         ; DATA XREF: .rdata:const Window::`vftable'o
UNDEF:0000A908 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000A908                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000A908                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000A90C ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000A90C                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000A90C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000A90C                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000A910 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000A910                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000A910                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000A914 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000A914                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000A914                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000A918 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000A918                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000A918                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000A91C ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000A91C                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000A91C                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000A920 ; public: __thiscall DockingCont::DockingCont(void)
UNDEF:0000A920                 extrn ??0DockingCont@@QAE@XZ:near
UNDEF:0000A920                                         ; CODE XREF: DockingManager::DockingManager(void)+12Fp
UNDEF:0000A920                                         ; DockingManager::createDockableDlg(tTbData,int,bool)+13Cp ...
UNDEF:0000A924 ; struct tTbData *__thiscall __high DockingCont::createToolbar(struct tTbData)
UNDEF:0000A924                 extrn ?createToolbar@DockingCont@@QAEPAUtTbData@@U2@@Z:near
UNDEF:0000A924                                         ; CODE XREF: DockingManager::createDockableDlg(tTbData,int,bool)+3BFp
UNDEF:0000A924                                         ; DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+149p ...
UNDEF:0000A928 ; void __thiscall __high DockingCont::removeToolbar(struct tTbData)
UNDEF:0000A928                 extrn ?removeToolbar@DockingCont@@QAEXUtTbData@@@Z:near
UNDEF:0000A928                                         ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+248p
UNDEF:0000A928                                         ; DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+245p ...
UNDEF:0000A92C ; struct tTbData *__thiscall DockingCont::findToolbarByWnd(DockingCont *__hidden this, HWND)
UNDEF:0000A92C                 extrn ?findToolbarByWnd@DockingCont@@QAEPAUtTbData@@PAUHWND__@@@Z:near
UNDEF:0000A92C                                         ; CODE XREF: DockingManager::showDockableDlg(HWND__ *,int)+46p
UNDEF:0000A930 ; struct tTbData *__thiscall DockingCont::findToolbarByName(DockingCont *__hidden this, wchar_t *)
UNDEF:0000A930                 extrn ?findToolbarByName@DockingCont@@QAEPAUtTbData@@PA_W@Z:near
UNDEF:0000A930                                         ; CODE XREF: DockingManager::showDockableDlg(wchar_t *,int)+4Dp
UNDEF:0000A934 ; void __thiscall DockingCont::showToolbar(DockingCont *__hidden this, struct tTbData *, int)
UNDEF:0000A934                 extrn ?showToolbar@DockingCont@@QAEXPAUtTbData@@H@Z:near
UNDEF:0000A934                                         ; CODE XREF: DockingManager::showDockableDlg(HWND__ *,int)+6Dp
UNDEF:0000A934                                         ; DockingManager::showDockableDlg(wchar_t *,int)+74p
UNDEF:0000A938 ; void __thiscall DockingCont::setActiveTb(DockingCont *__hidden this, struct tTbData *)
UNDEF:0000A938                 extrn ?setActiveTb@DockingCont@@QAEXPAUtTbData@@@Z:near
UNDEF:0000A938                                         ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+264p
UNDEF:0000A938                                         ; DockingManager::toggleVisTb(DockingCont *,DockingCont *)+C4p
UNDEF:0000A93C ; void __thiscall DockingCont::setActiveTb(DockingCont *__hidden this, int)
UNDEF:0000A93C                 extrn ?setActiveTb@DockingCont@@QAEXH@Z:near
UNDEF:0000A93C                                         ; CODE XREF: DockingManager::setActiveTab(int,int)+3Ep
UNDEF:0000A940 ; struct tTbData *__thiscall DockingCont::getDataOfActiveTb(DockingCont *__hidden this)
UNDEF:0000A940                 extrn ?getDataOfActiveTb@DockingCont@@QAEPAUtTbData@@XZ:near
UNDEF:0000A940                                         ; CODE XREF: DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)+30p
UNDEF:0000A940                                         ; DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+46p ...
UNDEF:0000A944 ; public: class std::vector<struct tTbData *, class std::allocator<struct tTbData *>> __thiscall DockingCont::getDataOfVisTb(void)
UNDEF:0000A944                 extrn ?getDataOfVisTb@DockingCont@@QAE?AV?$vector@PAUtTbData@@V?$allocator@PAUtTbData@@@std@@@std@@XZ:near
UNDEF:0000A944                                         ; CODE XREF: DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)+37p
UNDEF:0000A944                                         ; DockingManager::toggleVisTb(DockingCont *,DockingCont *)+34p
UNDEF:0000A948 ; void __thiscall DockingCont::doDialog(DockingCont *__hidden this, bool, bool)
UNDEF:0000A948                 extrn ?doDialog@DockingCont@@QAEX_N0@Z:near
UNDEF:0000A948                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+182p
UNDEF:0000A948                                         ; DockingManager::createDockableDlg(tTbData,int,bool)+194p ...
UNDEF:0000A94C ; bool __thiscall DockingCont::updateCaption(DockingCont *__hidden this)
UNDEF:0000A94C                 extrn ?updateCaption@DockingCont@@IAE_NXZ:near
UNDEF:0000A94C                                         ; CODE XREF: DockingCont::SetActive(int)+13p
UNDEF:0000A94C                                         ; DockingCont::updateInfo(HWND__ *)+4Cp
UNDEF:0000A950 ; public: virtual void * __thiscall DockingManager::`vector deleting destructor'(unsigned int)
UNDEF:0000A950                 extrn ??_EDockingManager@@UAEPAXI@Z:near ; weak
UNDEF:0000A950                                         ; DATA XREF: .rdata:const DockingManager::`vftable'o
UNDEF:0000A954 ; void __thiscall DockingSplitter::init(DockingSplitter *__hidden this, HINSTANCE, HWND, HWND, unsigned int)
UNDEF:0000A954                 extrn ?init@DockingSplitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@1I@Z:near
UNDEF:0000A954                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+1E2p
UNDEF:0000A954                                         ; DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+214p
UNDEF:0000A958 ; public: virtual void * __thiscall DockingSplitter::`vector deleting destructor'(unsigned int)
UNDEF:0000A958                 extrn ??_EDockingSplitter@@UAEPAXI@Z:near ; weak
UNDEF:0000A958                                         ; DATA XREF: .rdata:const DockingSplitter::`vftable'o
UNDEF:0000A95C ; public: __thiscall Gripper::Gripper(void)
UNDEF:0000A95C                 extrn ??0Gripper@@QAE@XZ:near
UNDEF:0000A95C                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+282p
UNDEF:0000A960 ; void __thiscall Gripper::startGrip(Gripper *__hidden this, struct DockingCont *, struct DockingManager *)
UNDEF:0000A960                 extrn ?startGrip@Gripper@@QAEXPAVDockingCont@@PAVDockingManager@@@Z:near
UNDEF:0000A960                                         ; CODE XREF: DockingManager::runProc(HWND__ *,uint,uint,long)+2CDp
UNDEF:0000A964 ; __fastcall __security_check_cookie(x)
UNDEF:0000A964                 extrn @__security_check_cookie@4:near
UNDEF:0000A964                                         ; CODE XREF: DockingManager::reSizeTo(tagRECT &)+897p
UNDEF:0000A964                                         ; DockingManager::createDockableDlg(tTbData,int,bool)+420p ...
UNDEF:0000A968 ; __stdcall _CxxThrowException(x, x)
UNDEF:0000A968                 extrn __CxxThrowException@8:near
UNDEF:0000A968                                         ; CODE XREF: DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+9Ep
UNDEF:0000A968                                         ; DockingManager::init(HINSTANCE__ *,HWND__ *,Window * *)+111p ...
UNDEF:0000A96C                 extrn ___CxxFrameHandler3:near
UNDEF:0000A96C                                         ; CODE XREF: __ehhandler$??0DockingManager@@QAE@XZ+16j
UNDEF:0000A96C                                         ; __ehhandler$??1DockingManager@@UAE@XZ+16j ...
UNDEF:0000A970 ; const type_info::`vftable'
UNDEF:0000A970                 extrn ??_7type_info@@6B@:near
UNDEF:0000A970                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:0000A970                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:0000A974 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:0000A974                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:0000A974                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:0000A978                 extrn ___security_cookie:near
UNDEF:0000A978                                         ; DATA XREF: DockingManager::DockingManager(void)+14r
UNDEF:0000A978                                         ; DockingManager::~DockingManager(void)+14r ...
UNDEF:0000A97C                 extrn __fltused:near
UNDEF:0000A97C
UNDEF:0000A97C
UNDEF:0000A97C                 end