.text$mn:00000000 ;
.text$mn:00000000 ; +-------------------------------------------------------------------------+
.text$mn:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text$mn:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text$mn:00000000 ; |                      License info: 48-3677-7074-51                      |
.text$mn:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text$mn:00000000 ; +-------------------------------------------------------------------------+
.text$mn:00000000 ;
.text$mn:00000000 ; Input MD5   : 7F537579FE35A2617DD83896B2B91704
.text$mn:00000000 ; Input CRC32 : 4400618C
.text$mn:00000000
.text$mn:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\SizeableDlg.obj
.text$mn:00000000 ; Format      : COFF (X386MAGIC)
.text$mn:00000000 ; includelib "uuid.lib"
.text$mn:00000000 ; includelib "libcpmtd"
.text$mn:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.text$mn:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.text$mn:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.text$mn:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.text$mn:00000000 ; includelib "LIBCMTD"
.text$mn:00000000 ; includelib "OLDNAMES"
.text$mn:00000000
.text$mn:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.text$mn:00000000
.text$mn:00000000                 .686p
.text$mn:00000000                 .mmx
.text$mn:00000000                 .model flat
.text$mn:00000000
.text$mn:00000000 ; ===========================================================================
.text$mn:00000000
.text$mn:00000000 ; Segment type: Pure code
.text$mn:00000000 ; Segment permissions: Read/Execute
.text$mn:00000000 _text$mn        segment para public 'CODE' use32
.text$mn:00000000                 assume cs:_text$mn
.text$mn:00000000                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000000
.text$mn:00000000 ; =============== S U B R O U T I N E =======================================
.text$mn:00000000
.text$mn:00000000 ; Attributes: bp-based frame
.text$mn:00000000
.text$mn:00000000 ; int __stdcall SizeableDlg::SizeableDlg(struct WINRECT *)
.text$mn:00000000                 public ??0SizeableDlg@@QAE@PAVWINRECT@@@Z
.text$mn:00000000 ??0SizeableDlg@@QAE@PAVWINRECT@@@Z proc near
.text$mn:00000000
.text$mn:00000000 var_10          = dword ptr -10h
.text$mn:00000000 var_C           = dword ptr -0Ch
.text$mn:00000000 var_4           = dword ptr -4
.text$mn:00000000 arg_0           = dword ptr  8
.text$mn:00000000
.text$mn:00000000                 push    ebp
.text$mn:00000001                 mov     ebp, esp
.text$mn:00000003                 push    0FFFFFFFFh
.text$mn:00000005                 push    offset __ehhandler$??0SizeableDlg@@QAE@PAVWINRECT@@@Z
.text$mn:0000000A                 mov     eax, large fs:0
.text$mn:00000010                 push    eax
.text$mn:00000011                 push    ecx
.text$mn:00000012                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000017                 xor     eax, ebp
.text$mn:00000019                 push    eax
.text$mn:0000001A                 lea     eax, [ebp+var_C]
.text$mn:0000001D                 mov     large fs:0, eax
.text$mn:00000023                 mov     [ebp+var_10], ecx
.text$mn:00000026                 mov     ecx, [ebp+var_10]
.text$mn:00000029                 call    ??0StaticDialog@@QAE@XZ ; StaticDialog::StaticDialog(void)
.text$mn:0000002E                 mov     [ebp+var_4], 0
.text$mn:00000035                 mov     eax, [ebp+var_10]
.text$mn:00000038                 mov     dword ptr [eax], offset ??_7SizeableDlg@@6B@ ; const SizeableDlg::`vftable'
.text$mn:0000003E                 mov     ecx, [ebp+arg_0]
.text$mn:00000041                 push    ecx             ; struct WINRECT *
.text$mn:00000042                 mov     ecx, [ebp+var_10]
.text$mn:00000045                 add     ecx, 20h ; ' '  ; this
.text$mn:00000048                 call    ??0CWinMgr@@QAE@PAVWINRECT@@@Z ; CWinMgr::CWinMgr(WINRECT *)
.text$mn:0000004D                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000051                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000058                 mov     eax, [ebp+var_10]
.text$mn:0000005B                 mov     ecx, [ebp+var_C]
.text$mn:0000005E                 mov     large fs:0, ecx
.text$mn:00000065                 pop     ecx
.text$mn:00000066                 mov     esp, ebp
.text$mn:00000068                 pop     ebp
.text$mn:00000069                 retn    4
.text$mn:00000069 ??0SizeableDlg@@QAE@PAVWINRECT@@@Z endp
.text$mn:00000069
.text$mn:00000069 ; ---------------------------------------------------------------------------
.text$mn:0000006C                 align 10h
.text$mn:00000070
.text$mn:00000070 ; =============== S U B R O U T I N E =======================================
.text$mn:00000070
.text$mn:00000070 ; Attributes: bp-based frame
.text$mn:00000070
.text$mn:00000070 ; int __stdcall SizeableDlg::run_dlgProc(SizeableDlg *this, unsigned int, unsigned int, __int32)
.text$mn:00000070                 public ?run_dlgProc@SizeableDlg@@MAGHIIJ@Z
.text$mn:00000070 ?run_dlgProc@SizeableDlg@@MAGHIIJ@Z proc near
.text$mn:00000070                                         ; DATA XREF: .rdata:00002764o
.text$mn:00000070
.text$mn:00000070 var_4           = dword ptr -4
.text$mn:00000070 this            = dword ptr  8
.text$mn:00000070 arg_4           = dword ptr  0Ch
.text$mn:00000070 arg_8           = dword ptr  10h
.text$mn:00000070 arg_C           = dword ptr  14h
.text$mn:00000070
.text$mn:00000070                 push    ebp
.text$mn:00000071                 mov     ebp, esp
.text$mn:00000073                 push    ecx
.text$mn:00000074                 mov     eax, [ebp+arg_4]
.text$mn:00000077                 mov     [ebp+var_4], eax
.text$mn:0000007A                 cmp     [ebp+var_4], 5
.text$mn:0000007E                 jz      short loc_B8
.text$mn:00000080                 cmp     [ebp+var_4], 24h ; '$'
.text$mn:00000084                 jz      short loc_A0
.text$mn:00000086                 cmp     [ebp+var_4], 110h
.text$mn:0000008D                 jz      short loc_91
.text$mn:0000008F                 jmp     short loc_EC
.text$mn:00000091 ; ---------------------------------------------------------------------------
.text$mn:00000091
.text$mn:00000091 loc_91:                                 ; CODE XREF: SizeableDlg::run_dlgProc(uint,uint,long)+1Dj
.text$mn:00000091                 mov     ecx, [ebp+this]
.text$mn:00000094                 mov     edx, [ecx]
.text$mn:00000096                 mov     ecx, [ebp+this]
.text$mn:00000099                 mov     eax, [edx+3Ch]
.text$mn:0000009C                 call    eax
.text$mn:0000009E                 jmp     short loc_110
.text$mn:000000A0 ; ---------------------------------------------------------------------------
.text$mn:000000A0
.text$mn:000000A0 loc_A0:                                 ; CODE XREF: SizeableDlg::run_dlgProc(uint,uint,long)+14j
.text$mn:000000A0                 mov     ecx, [ebp+arg_C]
.text$mn:000000A3                 push    ecx
.text$mn:000000A4                 mov     edx, [ebp+this]
.text$mn:000000A7                 mov     eax, [edx]
.text$mn:000000A9                 mov     ecx, [ebp+this]
.text$mn:000000AC                 mov     edx, [eax+44h]
.text$mn:000000AF                 call    edx
.text$mn:000000B1                 mov     eax, 1
.text$mn:000000B6                 jmp     short loc_110
.text$mn:000000B8 ; ---------------------------------------------------------------------------
.text$mn:000000B8
.text$mn:000000B8 loc_B8:                                 ; CODE XREF: SizeableDlg::run_dlgProc(uint,uint,long)+Ej
.text$mn:000000B8                 mov     eax, [ebp+arg_C]
.text$mn:000000BB                 shr     eax, 10h
.text$mn:000000BE                 and     eax, 0FFFFh
.text$mn:000000C3                 movzx   ecx, ax
.text$mn:000000C6                 push    ecx
.text$mn:000000C7                 mov     edx, [ebp+arg_C]
.text$mn:000000CA                 and     edx, 0FFFFh
.text$mn:000000D0                 movzx   eax, dx
.text$mn:000000D3                 push    eax
.text$mn:000000D4                 mov     ecx, [ebp+arg_8]
.text$mn:000000D7                 push    ecx
.text$mn:000000D8                 mov     edx, [ebp+this]
.text$mn:000000DB                 mov     eax, [edx]
.text$mn:000000DD                 mov     ecx, [ebp+this]
.text$mn:000000E0                 mov     edx, [eax+40h]
.text$mn:000000E3                 call    edx
.text$mn:000000E5                 mov     eax, 1
.text$mn:000000EA                 jmp     short loc_110
.text$mn:000000EC ; ---------------------------------------------------------------------------
.text$mn:000000EC
.text$mn:000000EC loc_EC:                                 ; CODE XREF: SizeableDlg::run_dlgProc(uint,uint,long)+1Fj
.text$mn:000000EC                 mov     eax, [ebp+arg_4]
.text$mn:000000EF                 cmp     eax, dword ptr ds:?WM_WINMGR@@3IB ; uint const WM_WINMGR
.text$mn:000000F5                 jnz     short loc_10E
.text$mn:000000F7                 mov     ecx, [ebp+arg_C]
.text$mn:000000FA                 push    ecx
.text$mn:000000FB                 mov     edx, [ebp+arg_8]
.text$mn:000000FE                 push    edx
.text$mn:000000FF                 mov     eax, [ebp+this]
.text$mn:00000102                 mov     edx, [eax]
.text$mn:00000104                 mov     ecx, [ebp+this]
.text$mn:00000107                 mov     eax, [edx+48h]
.text$mn:0000010A                 call    eax
.text$mn:0000010C                 jmp     short loc_110
.text$mn:0000010E ; ---------------------------------------------------------------------------
.text$mn:0000010E
.text$mn:0000010E loc_10E:                                ; CODE XREF: SizeableDlg::run_dlgProc(uint,uint,long)+85j
.text$mn:0000010E                 xor     eax, eax
.text$mn:00000110
.text$mn:00000110 loc_110:                                ; CODE XREF: SizeableDlg::run_dlgProc(uint,uint,long)+2Ej
.text$mn:00000110                                         ; SizeableDlg::run_dlgProc(uint,uint,long)+46j ...
.text$mn:00000110                 mov     esp, ebp
.text$mn:00000112                 pop     ebp
.text$mn:00000113                 retn    10h
.text$mn:00000113 ?run_dlgProc@SizeableDlg@@MAGHIIJ@Z endp
.text$mn:00000113
.text$mn:00000113 ; ---------------------------------------------------------------------------
.text$mn:00000116                 align 10h
.text$mn:00000120
.text$mn:00000120 ; =============== S U B R O U T I N E =======================================
.text$mn:00000120
.text$mn:00000120 ; Attributes: bp-based frame
.text$mn:00000120
.text$mn:00000120 ; int __thiscall SizeableDlg::onInitDialog(SizeableDlg *__hidden this)
.text$mn:00000120                 public ?onInitDialog@SizeableDlg@@MAEHXZ
.text$mn:00000120 ?onInitDialog@SizeableDlg@@MAEHXZ proc near ; DATA XREF: .rdata:00002768o
.text$mn:00000120
.text$mn:00000120 var_4           = dword ptr -4
.text$mn:00000120
.text$mn:00000120                 push    ebp
.text$mn:00000121                 mov     ebp, esp
.text$mn:00000123                 push    ecx
.text$mn:00000124                 mov     [ebp+var_4], ecx
.text$mn:00000127                 mov     eax, [ebp+var_4]
.text$mn:0000012A                 mov     ecx, [eax+0Ch]
.text$mn:0000012D                 push    ecx             ; HWND
.text$mn:0000012E                 mov     ecx, [ebp+var_4]
.text$mn:00000131                 add     ecx, 20h ; ' '  ; this
.text$mn:00000134                 call    ?InitToFitSizeFromCurrent@CWinMgr@@QAEXPAUHWND__@@@Z ; CWinMgr::InitToFitSizeFromCurrent(HWND__ *)
.text$mn:00000139                 mov     edx, [ebp+var_4]
.text$mn:0000013C                 mov     eax, [edx+0Ch]
.text$mn:0000013F                 push    eax             ; HWND
.text$mn:00000140                 mov     ecx, [ebp+var_4]
.text$mn:00000143                 add     ecx, 20h ; ' '  ; this
.text$mn:00000146                 call    ?CalcLayout@CWinMgr@@QAEXPAUHWND__@@@Z ; CWinMgr::CalcLayout(HWND__ *)
.text$mn:0000014B                 mov     ecx, [ebp+var_4]
.text$mn:0000014E                 mov     edx, [ecx+0Ch]
.text$mn:00000151                 push    edx
.text$mn:00000152                 mov     ecx, [ebp+var_4]
.text$mn:00000155                 add     ecx, 20h ; ' '
.text$mn:00000158                 mov     eax, [ebp+var_4]
.text$mn:0000015B                 mov     edx, [eax+20h]
.text$mn:0000015E                 mov     eax, [edx+8]
.text$mn:00000161                 call    eax
.text$mn:00000163                 mov     eax, 1
.text$mn:00000168                 mov     esp, ebp
.text$mn:0000016A                 pop     ebp
.text$mn:0000016B                 retn
.text$mn:0000016B ?onInitDialog@SizeableDlg@@MAEHXZ endp
.text$mn:0000016B
.text$mn:0000016B ; ---------------------------------------------------------------------------
.text$mn:0000016C                 align 10h
.text$mn:00000170
.text$mn:00000170 ; =============== S U B R O U T I N E =======================================
.text$mn:00000170
.text$mn:00000170 ; Attributes: bp-based frame
.text$mn:00000170
.text$mn:00000170 ; void __thiscall SizeableDlg::onSize(SizeableDlg *this, unsigned int, int, int)
.text$mn:00000170                 public ?onSize@SizeableDlg@@MAEXIHH@Z
.text$mn:00000170 ?onSize@SizeableDlg@@MAEXIHH@Z proc near ; DATA XREF: .rdata:0000276Co
.text$mn:00000170
.text$mn:00000170 var_4           = dword ptr -4
.text$mn:00000170 arg_4           = dword ptr  0Ch
.text$mn:00000170 arg_8           = dword ptr  10h
.text$mn:00000170
.text$mn:00000170                 push    ebp
.text$mn:00000171                 mov     ebp, esp
.text$mn:00000173                 push    ecx
.text$mn:00000174                 mov     [ebp+var_4], ecx
.text$mn:00000177                 mov     eax, [ebp+var_4]
.text$mn:0000017A                 mov     ecx, [eax+0Ch]
.text$mn:0000017D                 push    ecx             ; HWND
.text$mn:0000017E                 mov     edx, [ebp+arg_8]
.text$mn:00000181                 push    edx             ; int
.text$mn:00000182                 mov     eax, [ebp+arg_4]
.text$mn:00000185                 push    eax             ; int
.text$mn:00000186                 mov     ecx, [ebp+var_4]
.text$mn:00000189                 add     ecx, 20h ; ' '  ; this
.text$mn:0000018C                 call    ?CalcLayout@CWinMgr@@QAEXHHPAUHWND__@@@Z ; CWinMgr::CalcLayout(int,int,HWND__ *)
.text$mn:00000191                 mov     ecx, [ebp+var_4]
.text$mn:00000194                 mov     edx, [ecx+0Ch]
.text$mn:00000197                 push    edx
.text$mn:00000198                 mov     ecx, [ebp+var_4]
.text$mn:0000019B                 add     ecx, 20h ; ' '
.text$mn:0000019E                 mov     eax, [ebp+var_4]
.text$mn:000001A1                 mov     edx, [eax+20h]
.text$mn:000001A4                 mov     eax, [edx+8]
.text$mn:000001A7                 call    eax
.text$mn:000001A9                 mov     esp, ebp
.text$mn:000001AB                 pop     ebp
.text$mn:000001AC                 retn    0Ch
.text$mn:000001AC ?onSize@SizeableDlg@@MAEXIHH@Z endp
.text$mn:000001AC
.text$mn:000001AC ; ---------------------------------------------------------------------------
.text$mn:000001AF                 align 10h
.text$mn:000001B0
.text$mn:000001B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000001B0
.text$mn:000001B0 ; Attributes: bp-based frame
.text$mn:000001B0
.text$mn:000001B0 ; void __thiscall SizeableDlg::onGetMinMaxInfo(SizeableDlg *this, struct tagMINMAXINFO *)
.text$mn:000001B0                 public ?onGetMinMaxInfo@SizeableDlg@@MAEXPAUtagMINMAXINFO@@@Z
.text$mn:000001B0 ?onGetMinMaxInfo@SizeableDlg@@MAEXPAUtagMINMAXINFO@@@Z proc near
.text$mn:000001B0                                         ; DATA XREF: .rdata:00002770o
.text$mn:000001B0
.text$mn:000001B0 var_4           = dword ptr -4
.text$mn:000001B0 arg_0           = dword ptr  8
.text$mn:000001B0
.text$mn:000001B0                 push    ebp
.text$mn:000001B1                 mov     ebp, esp
.text$mn:000001B3                 push    ecx
.text$mn:000001B4                 mov     [ebp+var_4], ecx
.text$mn:000001B7                 mov     eax, [ebp+arg_0]
.text$mn:000001BA                 push    eax             ; struct tagMINMAXINFO *
.text$mn:000001BB                 mov     ecx, [ebp+var_4]
.text$mn:000001BE                 mov     edx, [ecx+0Ch]
.text$mn:000001C1                 push    edx             ; HWND
.text$mn:000001C2                 mov     ecx, [ebp+var_4]
.text$mn:000001C5                 add     ecx, 20h ; ' '  ; this
.text$mn:000001C8                 call    ?GetMinMaxInfo@CWinMgr@@QAEXPAUHWND__@@PAUtagMINMAXINFO@@@Z ; CWinMgr::GetMinMaxInfo(HWND__ *,tagMINMAXINFO *)
.text$mn:000001CD                 mov     esp, ebp
.text$mn:000001CF                 pop     ebp
.text$mn:000001D0                 retn    4
.text$mn:000001D0 ?onGetMinMaxInfo@SizeableDlg@@MAEXPAUtagMINMAXINFO@@@Z endp
.text$mn:000001D0
.text$mn:000001D0 ; ---------------------------------------------------------------------------
.text$mn:000001D3                 align 10h
.text$mn:000001E0
.text$mn:000001E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000001E0
.text$mn:000001E0 ; Attributes: bp-based frame
.text$mn:000001E0
.text$mn:000001E0 ; __int32 __thiscall SizeableDlg::onWinMgr(SizeableDlg *this, unsigned int, __int32)
.text$mn:000001E0                 public ?onWinMgr@SizeableDlg@@MAEJIJ@Z
.text$mn:000001E0 ?onWinMgr@SizeableDlg@@MAEJIJ@Z proc near ; DATA XREF: .rdata:00002774o
.text$mn:000001E0
.text$mn:000001E0 var_4           = dword ptr -4
.text$mn:000001E0
.text$mn:000001E0                 push    ebp
.text$mn:000001E1                 mov     ebp, esp
.text$mn:000001E3                 push    ecx
.text$mn:000001E4                 mov     [ebp+var_4], ecx
.text$mn:000001E7                 xor     eax, eax
.text$mn:000001E9                 mov     esp, ebp
.text$mn:000001EB                 pop     ebp
.text$mn:000001EC                 retn    8
.text$mn:000001EC ?onWinMgr@SizeableDlg@@MAEJIJ@Z endp
.text$mn:000001EC
.text$mn:000001EC ; ---------------------------------------------------------------------------
.text$mn:000001EF                 align 10h
.text$mn:000001EF _text$mn        ends
.text$mn:000001EF
.text$x:000001F0 ; ===========================================================================
.text$x:000001F0
.text$x:000001F0 ; Segment type: Pure code
.text$x:000001F0 ; Segment permissions: Read/Execute
.text$x:000001F0 _text$x         segment para public 'CODE' use32
.text$x:000001F0                 assume cs:_text$x
.text$x:000001F0                 ;org 1F0h
.text$x:000001F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000001F0
.text$x:000001F0 ; =============== S U B R O U T I N E =======================================
.text$x:000001F0
.text$x:000001F0
.text$x:000001F0 __unwindfunclet$??0SizeableDlg@@QAE@PAVWINRECT@@@Z$0 proc near
.text$x:000001F0                                         ; DATA XREF: .xdata$x:000021E4o
.text$x:000001F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000001F3                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:000001F3 __unwindfunclet$??0SizeableDlg@@QAE@PAVWINRECT@@@Z$0 endp
.text$x:000001F3
.text$x:000001F8
.text$x:000001F8 ; =============== S U B R O U T I N E =======================================
.text$x:000001F8
.text$x:000001F8
.text$x:000001F8 __unwindfunclet$??0SizeableDlg@@QAE@PAVWINRECT@@@Z$1 proc near
.text$x:000001F8                                         ; DATA XREF: .xdata$x:000021ECo
.text$x:000001F8                 mov     ecx, [ebp-10h]
.text$x:000001FB                 add     ecx, 20h ; ' '  ; this
.text$x:000001FE                 jmp     ??1CWinMgr@@UAE@XZ ; CWinMgr::~CWinMgr(void)
.text$x:000001FE __unwindfunclet$??0SizeableDlg@@QAE@PAVWINRECT@@@Z$1 endp
.text$x:000001FE
.text$x:00000203
.text$x:00000203 ; =============== S U B R O U T I N E =======================================
.text$x:00000203
.text$x:00000203
.text$x:00000203 __ehhandler$??0SizeableDlg@@QAE@PAVWINRECT@@@Z proc near
.text$x:00000203                                         ; DATA XREF: SizeableDlg::SizeableDlg(WINRECT *)+5o
.text$x:00000203
.text$x:00000203 arg_4           = dword ptr  8
.text$x:00000203
.text$x:00000203                 mov     edx, [esp+arg_4]
.text$x:00000207                 lea     eax, [edx+0Ch]
.text$x:0000020A                 mov     ecx, [edx-8]
.text$x:0000020D                 xor     ecx, eax
.text$x:0000020F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000214                 mov     eax, offset __ehfuncinfo$??0SizeableDlg@@QAE@PAVWINRECT@@@Z
.text$x:00000219                 jmp     ___CxxFrameHandler3
.text$x:00000219 __ehhandler$??0SizeableDlg@@QAE@PAVWINRECT@@@Z endp
.text$x:00000219
.text$x:00000219 ; ---------------------------------------------------------------------------
.text$x:0000021E                 align 10h
.text$x:0000021E _text$x         ends
.text$x:0000021E
.text$mn:00000220 ; ===========================================================================
.text$mn:00000220
.text$mn:00000220 ; Segment type: Pure code
.text$mn:00000220 ; Segment permissions: Read/Execute
.text$mn:00000220 _text$mn        segment para public 'CODE' use32
.text$mn:00000220                 assume cs:_text$mn
.text$mn:00000220                 ;org 220h
.text$mn:00000220 ; COMDAT (pick any)
.text$mn:00000220                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000220
.text$mn:00000220 ; =============== S U B R O U T I N E =======================================
.text$mn:00000220
.text$mn:00000220 ; Attributes: bp-based frame
.text$mn:00000220
.text$mn:00000220 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000220                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000220 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000220                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000220
.text$mn:00000220 var_4           = dword ptr -4
.text$mn:00000220 arg_0           = dword ptr  8
.text$mn:00000220
.text$mn:00000220                 push    ebp
.text$mn:00000221                 mov     ebp, esp
.text$mn:00000223                 push    ecx
.text$mn:00000224                 mov     [ebp+var_4], 0
.text$mn:0000022B                 cmp     [ebp+arg_0], 0
.text$mn:0000022F                 jnz     short loc_233
.text$mn:00000231                 jmp     short loc_253
.text$mn:00000233 ; ---------------------------------------------------------------------------
.text$mn:00000233
.text$mn:00000233 loc_233:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000233                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00000237                 ja      short loc_24E
.text$mn:00000239                 mov     eax, [ebp+arg_0]
.text$mn:0000023C                 push    eax             ; unsigned int
.text$mn:0000023D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000242                 add     esp, 4
.text$mn:00000245                 mov     [ebp+var_4], eax
.text$mn:00000248                 cmp     [ebp+var_4], 0
.text$mn:0000024C                 jnz     short loc_253
.text$mn:0000024E
.text$mn:0000024E loc_24E:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000024E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000253
.text$mn:00000253 loc_253:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000253                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000253                 mov     eax, [ebp+var_4]
.text$mn:00000256                 mov     esp, ebp
.text$mn:00000258                 pop     ebp
.text$mn:00000259                 retn
.text$mn:00000259 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00000259
.text$mn:00000259 ; ---------------------------------------------------------------------------
.text$mn:0000025A                 align 4
.text$mn:0000025A _text$mn        ends
.text$mn:0000025A
.text$mn:0000025C ; ===========================================================================
.text$mn:0000025C
.text$mn:0000025C ; Segment type: Pure code
.text$mn:0000025C ; Segment permissions: Read/Execute
.text$mn:0000025C _text$mn        segment para public 'CODE' use32
.text$mn:0000025C                 assume cs:_text$mn
.text$mn:0000025C                 ;org 25Ch
.text$mn:0000025C ; COMDAT (pick any)
.text$mn:0000025C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000025C
.text$mn:0000025C ; =============== S U B R O U T I N E =======================================
.text$mn:0000025C
.text$mn:0000025C ; Attributes: bp-based frame
.text$mn:0000025C
.text$mn:0000025C ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:0000025C                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:0000025C ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:0000025C                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:0000025C
.text$mn:0000025C var_4           = dword ptr -4
.text$mn:0000025C arg_0           = dword ptr  8
.text$mn:0000025C
.text$mn:0000025C                 push    ebp
.text$mn:0000025D                 mov     ebp, esp
.text$mn:0000025F                 push    ecx
.text$mn:00000260                 mov     [ebp+var_4], 0
.text$mn:00000267                 cmp     [ebp+arg_0], 0
.text$mn:0000026B                 jnz     short loc_26F
.text$mn:0000026D                 jmp     short loc_295
.text$mn:0000026F ; ---------------------------------------------------------------------------
.text$mn:0000026F
.text$mn:0000026F loc_26F:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:0000026F                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00000276                 ja      short loc_290
.text$mn:00000278                 mov     eax, [ebp+arg_0]
.text$mn:0000027B                 shl     eax, 3
.text$mn:0000027E                 push    eax             ; unsigned int
.text$mn:0000027F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000284                 add     esp, 4
.text$mn:00000287                 mov     [ebp+var_4], eax
.text$mn:0000028A                 cmp     [ebp+var_4], 0
.text$mn:0000028E                 jnz     short loc_295
.text$mn:00000290
.text$mn:00000290 loc_290:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00000290                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000295
.text$mn:00000295 loc_295:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000295                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000295                 mov     eax, [ebp+var_4]
.text$mn:00000298                 mov     esp, ebp
.text$mn:0000029A                 pop     ebp
.text$mn:0000029B                 retn
.text$mn:0000029B ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000029B
.text$mn:0000029B _text$mn        ends
.text$mn:0000029B
.text$mn:0000029C ; ===========================================================================
.text$mn:0000029C
.text$mn:0000029C ; Segment type: Pure code
.text$mn:0000029C ; Segment permissions: Read/Execute
.text$mn:0000029C _text$mn        segment para public 'CODE' use32
.text$mn:0000029C                 assume cs:_text$mn
.text$mn:0000029C                 ;org 29Ch
.text$mn:0000029C ; COMDAT (pick any)
.text$mn:0000029C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000029C
.text$mn:0000029C ; =============== S U B R O U T I N E =======================================
.text$mn:0000029C
.text$mn:0000029C ; Attributes: bp-based frame
.text$mn:0000029C
.text$mn:0000029C ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:0000029C                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:0000029C ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:0000029C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:0000029C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:0000029C
.text$mn:0000029C arg_0           = dword ptr  8
.text$mn:0000029C arg_4           = dword ptr  0Ch
.text$mn:0000029C arg_8           = dword ptr  10h
.text$mn:0000029C
.text$mn:0000029C                 push    ebp
.text$mn:0000029D                 mov     ebp, esp
.text$mn:0000029F                 cmp     [ebp+arg_0], 0
.text$mn:000002A3                 jnz     short loc_2BA
.text$mn:000002A5                 mov     eax, [ebp+arg_8]
.text$mn:000002A8                 push    eax             ; unsigned int
.text$mn:000002A9                 mov     ecx, [ebp+arg_4]
.text$mn:000002AC                 push    ecx             ; wchar_t *
.text$mn:000002AD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000002B2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000002B7                 add     esp, 0Ch
.text$mn:000002BA
.text$mn:000002BA loc_2BA:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000002BA                 pop     ebp
.text$mn:000002BB                 retn
.text$mn:000002BB ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000002BB
.text$mn:000002BB _text$mn        ends
.text$mn:000002BB
.text$mn:000002BC ; ===========================================================================
.text$mn:000002BC
.text$mn:000002BC ; Segment type: Pure code
.text$mn:000002BC ; Segment permissions: Read/Execute
.text$mn:000002BC _text$mn        segment para public 'CODE' use32
.text$mn:000002BC                 assume cs:_text$mn
.text$mn:000002BC                 ;org 2BCh
.text$mn:000002BC ; COMDAT (pick any)
.text$mn:000002BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000002BC
.text$mn:000002BC ; =============== S U B R O U T I N E =======================================
.text$mn:000002BC
.text$mn:000002BC ; Attributes: bp-based frame
.text$mn:000002BC
.text$mn:000002BC ; char * __cdecl std::addressof<char>(char &)
.text$mn:000002BC                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000002BC ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000002BC                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000002BC                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000002BC
.text$mn:000002BC arg_0           = dword ptr  8
.text$mn:000002BC
.text$mn:000002BC                 push    ebp
.text$mn:000002BD                 mov     ebp, esp
.text$mn:000002BF                 mov     eax, [ebp+arg_0]
.text$mn:000002C2                 pop     ebp
.text$mn:000002C3                 retn
.text$mn:000002C3 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000002C3
.text$mn:000002C3 _text$mn        ends
.text$mn:000002C3
.text$mn:000002C4 ; ===========================================================================
.text$mn:000002C4
.text$mn:000002C4 ; Segment type: Pure code
.text$mn:000002C4 ; Segment permissions: Read/Execute
.text$mn:000002C4 _text$mn        segment para public 'CODE' use32
.text$mn:000002C4                 assume cs:_text$mn
.text$mn:000002C4                 ;org 2C4h
.text$mn:000002C4 ; COMDAT (pick any)
.text$mn:000002C4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000002C4
.text$mn:000002C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000002C4
.text$mn:000002C4 ; Attributes: bp-based frame
.text$mn:000002C4
.text$mn:000002C4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000002C4                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000002C4 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000002C4                                         ; CODE XREF: $LN19+4Bp
.text$mn:000002C4
.text$mn:000002C4 var_4           = dword ptr -4
.text$mn:000002C4 arg_0           = dword ptr  8
.text$mn:000002C4 arg_4           = dword ptr  0Ch
.text$mn:000002C4
.text$mn:000002C4                 push    ebp
.text$mn:000002C5                 mov     ebp, esp
.text$mn:000002C7                 push    ecx
.text$mn:000002C8                 mov     [ebp+var_4], ecx
.text$mn:000002CB                 mov     eax, [ebp+arg_4]
.text$mn:000002CE                 push    eax
.text$mn:000002CF                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000002D4                 add     esp, 4
.text$mn:000002D7                 push    eax             ; int
.text$mn:000002D8                 mov     ecx, [ebp+arg_0]
.text$mn:000002DB                 push    ecx             ; void *
.text$mn:000002DC                 mov     edx, [ebp+var_4]
.text$mn:000002DF                 push    edx             ; int
.text$mn:000002E0                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000002E5                 add     esp, 0Ch
.text$mn:000002E8                 mov     esp, ebp
.text$mn:000002EA                 pop     ebp
.text$mn:000002EB                 retn    8
.text$mn:000002EB ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000002EB
.text$mn:000002EB ; ---------------------------------------------------------------------------
.text$mn:000002EE                 align 10h
.text$mn:000002EE _text$mn        ends
.text$mn:000002EE
.text$mn:000002F0 ; ===========================================================================
.text$mn:000002F0
.text$mn:000002F0 ; Segment type: Pure code
.text$mn:000002F0 ; Segment permissions: Read/Execute
.text$mn:000002F0 _text$mn        segment para public 'CODE' use32
.text$mn:000002F0                 assume cs:_text$mn
.text$mn:000002F0                 ;org 2F0h
.text$mn:000002F0 ; COMDAT (pick any)
.text$mn:000002F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000002F0
.text$mn:000002F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000002F0
.text$mn:000002F0 ; Attributes: bp-based frame
.text$mn:000002F0
.text$mn:000002F0 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000002F0                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000002F0 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000002F0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000002F0
.text$mn:000002F0 var_1C          = dword ptr -1Ch
.text$mn:000002F0 var_18          = dword ptr -18h
.text$mn:000002F0 var_14          = dword ptr -14h
.text$mn:000002F0 var_10          = dword ptr -10h
.text$mn:000002F0 var_C           = dword ptr -0Ch
.text$mn:000002F0 var_4           = dword ptr -4
.text$mn:000002F0 arg_0           = dword ptr  8
.text$mn:000002F0 arg_4           = dword ptr  0Ch
.text$mn:000002F0
.text$mn:000002F0                 push    ebp
.text$mn:000002F1                 mov     ebp, esp
.text$mn:000002F3                 push    0FFFFFFFFh
.text$mn:000002F5                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000002FA                 mov     eax, large fs:0
.text$mn:00000300                 push    eax
.text$mn:00000301                 sub     esp, 10h
.text$mn:00000304                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000309                 xor     eax, ebp
.text$mn:0000030B                 push    eax
.text$mn:0000030C                 lea     eax, [ebp+var_C]
.text$mn:0000030F                 mov     large fs:0, eax
.text$mn:00000315                 mov     [ebp+var_18], ecx
.text$mn:00000318                 mov     eax, [ebp+arg_0]
.text$mn:0000031B                 push    eax             ; void *
.text$mn:0000031C                 push    4               ; unsigned int
.text$mn:0000031E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000323                 add     esp, 8
.text$mn:00000326                 mov     [ebp+var_10], eax
.text$mn:00000329                 mov     [ebp+var_4], 0
.text$mn:00000330                 cmp     [ebp+var_10], 0
.text$mn:00000334                 jz      short loc_351
.text$mn:00000336                 mov     ecx, [ebp+arg_4]
.text$mn:00000339                 push    ecx
.text$mn:0000033A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000033F                 add     esp, 4
.text$mn:00000342                 mov     edx, [ebp+var_10]
.text$mn:00000345                 mov     eax, [eax]
.text$mn:00000347                 mov     [edx], eax
.text$mn:00000349                 mov     ecx, [ebp+var_10]
.text$mn:0000034C                 mov     [ebp+var_14], ecx
.text$mn:0000034F                 jmp     short loc_358
.text$mn:00000351 ; ---------------------------------------------------------------------------
.text$mn:00000351
.text$mn:00000351 loc_351:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000351                 mov     [ebp+var_14], 0
.text$mn:00000358
.text$mn:00000358 loc_358:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000358                 mov     edx, [ebp+var_14]
.text$mn:0000035B                 mov     [ebp+var_1C], edx
.text$mn:0000035E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000365                 mov     ecx, [ebp+var_C]
.text$mn:00000368                 mov     large fs:0, ecx
.text$mn:0000036F                 pop     ecx
.text$mn:00000370                 mov     esp, ebp
.text$mn:00000372                 pop     ebp
.text$mn:00000373                 retn    8
.text$mn:00000373 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000373
.text$mn:00000373 ; ---------------------------------------------------------------------------
.text$mn:00000376                 align 4
.text$mn:00000376 _text$mn        ends
.text$mn:00000376
.text$x:00000378 ; ===========================================================================
.text$x:00000378
.text$x:00000378 ; Segment type: Pure code
.text$x:00000378 ; Segment permissions: Read/Execute
.text$x:00000378 _text$x         segment para public 'CODE' use32
.text$x:00000378                 assume cs:_text$x
.text$x:00000378                 ;org 378h
.text$x:00000378 ; COMDAT (pick associative to section at 2F0)
.text$x:00000378                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000378
.text$x:00000378 ; =============== S U B R O U T I N E =======================================
.text$x:00000378
.text$x:00000378
.text$x:00000378 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000378                                         ; DATA XREF: .xdata$x:000025C4o
.text$x:00000378                 mov     eax, [ebp+8]
.text$x:0000037B                 push    eax
.text$x:0000037C                 mov     eax, [ebp-10h]
.text$x:0000037F                 push    eax             ; void *
.text$x:00000380                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000385                 add     esp, 8
.text$x:00000388                 retn
.text$x:00000388 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000388
.text$x:00000389
.text$x:00000389 ; =============== S U B R O U T I N E =======================================
.text$x:00000389
.text$x:00000389
.text$x:00000389 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000389                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000389
.text$x:00000389 arg_4           = dword ptr  8
.text$x:00000389
.text$x:00000389                 mov     edx, [esp+arg_4]
.text$x:0000038D                 lea     eax, [edx+0Ch]
.text$x:00000390                 mov     ecx, [edx-14h]
.text$x:00000393                 xor     ecx, eax
.text$x:00000395                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000039A                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000039F                 jmp     ___CxxFrameHandler3
.text$x:0000039F __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000039F
.text$x:0000039F _text$x         ends
.text$x:0000039F
.text$mn:000003A4 ; ===========================================================================
.text$mn:000003A4
.text$mn:000003A4 ; Segment type: Pure code
.text$mn:000003A4 ; Segment permissions: Read/Execute
.text$mn:000003A4 _text$mn        segment para public 'CODE' use32
.text$mn:000003A4                 assume cs:_text$mn
.text$mn:000003A4                 ;org 3A4h
.text$mn:000003A4 ; COMDAT (pick any)
.text$mn:000003A4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000003A4
.text$mn:000003A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000003A4
.text$mn:000003A4 ; Attributes: bp-based frame
.text$mn:000003A4
.text$mn:000003A4 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000003A4                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000003A4 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000003A4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000003A4
.text$mn:000003A4 arg_0           = dword ptr  8
.text$mn:000003A4 arg_4           = dword ptr  0Ch
.text$mn:000003A4 arg_8           = dword ptr  10h
.text$mn:000003A4
.text$mn:000003A4                 push    ebp
.text$mn:000003A5                 mov     ebp, esp
.text$mn:000003A7                 mov     eax, [ebp+arg_8]
.text$mn:000003AA                 push    eax
.text$mn:000003AB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000003B0                 add     esp, 4
.text$mn:000003B3                 push    eax             ; int
.text$mn:000003B4                 mov     ecx, [ebp+arg_4]
.text$mn:000003B7                 push    ecx             ; void *
.text$mn:000003B8                 mov     ecx, [ebp+arg_0]
.text$mn:000003BB                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000003C0                 pop     ebp
.text$mn:000003C1                 retn
.text$mn:000003C1 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000003C1
.text$mn:000003C1 ; ---------------------------------------------------------------------------
.text$mn:000003C2                 align 4
.text$mn:000003C2 _text$mn        ends
.text$mn:000003C2
.text$mn:000003C4 ; ===========================================================================
.text$mn:000003C4
.text$mn:000003C4 ; Segment type: Pure code
.text$mn:000003C4 ; Segment permissions: Read/Execute
.text$mn:000003C4 _text$mn        segment para public 'CODE' use32
.text$mn:000003C4                 assume cs:_text$mn
.text$mn:000003C4                 ;org 3C4h
.text$mn:000003C4 ; COMDAT (pick any)
.text$mn:000003C4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000003C4
.text$mn:000003C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000003C4
.text$mn:000003C4 ; Attributes: bp-based frame
.text$mn:000003C4
.text$mn:000003C4 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000003C4                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000003C4 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000003C4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000003C4
.text$mn:000003C4 var_1C          = dword ptr -1Ch
.text$mn:000003C4 var_18          = dword ptr -18h
.text$mn:000003C4 var_14          = dword ptr -14h
.text$mn:000003C4 var_10          = dword ptr -10h
.text$mn:000003C4 var_C           = dword ptr -0Ch
.text$mn:000003C4 var_4           = dword ptr -4
.text$mn:000003C4 arg_0           = dword ptr  8
.text$mn:000003C4 arg_4           = dword ptr  0Ch
.text$mn:000003C4
.text$mn:000003C4                 push    ebp
.text$mn:000003C5                 mov     ebp, esp
.text$mn:000003C7                 push    0FFFFFFFFh
.text$mn:000003C9                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000003CE                 mov     eax, large fs:0
.text$mn:000003D4                 push    eax
.text$mn:000003D5                 sub     esp, 10h
.text$mn:000003D8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000003DD                 xor     eax, ebp
.text$mn:000003DF                 push    eax
.text$mn:000003E0                 lea     eax, [ebp+var_C]
.text$mn:000003E3                 mov     large fs:0, eax
.text$mn:000003E9                 mov     [ebp+var_18], ecx
.text$mn:000003EC                 mov     eax, [ebp+arg_0]
.text$mn:000003EF                 push    eax             ; void *
.text$mn:000003F0                 push    8               ; unsigned int
.text$mn:000003F2                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000003F7                 add     esp, 8
.text$mn:000003FA                 mov     [ebp+var_10], eax
.text$mn:000003FD                 mov     [ebp+var_4], 0
.text$mn:00000404                 cmp     [ebp+var_10], 0
.text$mn:00000408                 jz      short loc_42B
.text$mn:0000040A                 mov     ecx, [ebp+arg_4]
.text$mn:0000040D                 push    ecx
.text$mn:0000040E                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00000413                 add     esp, 4
.text$mn:00000416                 mov     edx, [eax]
.text$mn:00000418                 mov     eax, [eax+4]
.text$mn:0000041B                 mov     ecx, [ebp+var_10]
.text$mn:0000041E                 mov     [ecx], edx
.text$mn:00000420                 mov     [ecx+4], eax
.text$mn:00000423                 mov     edx, [ebp+var_10]
.text$mn:00000426                 mov     [ebp+var_14], edx
.text$mn:00000429                 jmp     short loc_432
.text$mn:0000042B ; ---------------------------------------------------------------------------
.text$mn:0000042B
.text$mn:0000042B loc_42B:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:0000042B                 mov     [ebp+var_14], 0
.text$mn:00000432
.text$mn:00000432 loc_432:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00000432                 mov     eax, [ebp+var_14]
.text$mn:00000435                 mov     [ebp+var_1C], eax
.text$mn:00000438                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000043F                 mov     ecx, [ebp+var_C]
.text$mn:00000442                 mov     large fs:0, ecx
.text$mn:00000449                 pop     ecx
.text$mn:0000044A                 mov     esp, ebp
.text$mn:0000044C                 pop     ebp
.text$mn:0000044D                 retn    8
.text$mn:0000044D ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:0000044D
.text$mn:0000044D _text$mn        ends
.text$mn:0000044D
.text$x:00000450 ; ===========================================================================
.text$x:00000450
.text$x:00000450 ; Segment type: Pure code
.text$x:00000450 ; Segment permissions: Read/Execute
.text$x:00000450 _text$x         segment para public 'CODE' use32
.text$x:00000450                 assume cs:_text$x
.text$x:00000450                 ;org 450h
.text$x:00000450 ; COMDAT (pick associative to section at 3C4)
.text$x:00000450                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000450
.text$x:00000450 ; =============== S U B R O U T I N E =======================================
.text$x:00000450
.text$x:00000450
.text$x:00000450 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000450                                         ; DATA XREF: .xdata$x:00002598o
.text$x:00000450                 mov     eax, [ebp+8]
.text$x:00000453                 push    eax
.text$x:00000454                 mov     eax, [ebp-10h]
.text$x:00000457                 push    eax             ; void *
.text$x:00000458                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000045D                 add     esp, 8
.text$x:00000460                 retn
.text$x:00000460 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000460
.text$x:00000461
.text$x:00000461 ; =============== S U B R O U T I N E =======================================
.text$x:00000461
.text$x:00000461
.text$x:00000461 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000461                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000461
.text$x:00000461 arg_4           = dword ptr  8
.text$x:00000461
.text$x:00000461                 mov     edx, [esp+arg_4]
.text$x:00000465                 lea     eax, [edx+0Ch]
.text$x:00000468                 mov     ecx, [edx-14h]
.text$x:0000046B                 xor     ecx, eax
.text$x:0000046D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000472                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000477                 jmp     ___CxxFrameHandler3
.text$x:00000477 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000477
.text$x:00000477 _text$x         ends
.text$x:00000477
.text$mn:0000047C ; ===========================================================================
.text$mn:0000047C
.text$mn:0000047C ; Segment type: Pure code
.text$mn:0000047C ; Segment permissions: Read/Execute
.text$mn:0000047C _text$mn        segment para public 'CODE' use32
.text$mn:0000047C                 assume cs:_text$mn
.text$mn:0000047C                 ;org 47Ch
.text$mn:0000047C ; COMDAT (pick any)
.text$mn:0000047C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000047C
.text$mn:0000047C ; =============== S U B R O U T I N E =======================================
.text$mn:0000047C
.text$mn:0000047C ; Attributes: bp-based frame
.text$mn:0000047C
.text$mn:0000047C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000047C                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:0000047C ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:0000047C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:0000047C
.text$mn:0000047C var_4           = dword ptr -4
.text$mn:0000047C arg_0           = dword ptr  8
.text$mn:0000047C
.text$mn:0000047C                 push    ebp
.text$mn:0000047D                 mov     ebp, esp
.text$mn:0000047F                 push    ecx
.text$mn:00000480                 mov     [ebp+var_4], ecx
.text$mn:00000483                 mov     eax, [ebp+arg_0]
.text$mn:00000486                 push    eax
.text$mn:00000487                 mov     ecx, [ebp+var_4]
.text$mn:0000048A                 push    ecx
.text$mn:0000048B                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00000490                 add     esp, 8
.text$mn:00000493                 mov     esp, ebp
.text$mn:00000495                 pop     ebp
.text$mn:00000496                 retn    4
.text$mn:00000496 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000496
.text$mn:00000496 ; ---------------------------------------------------------------------------
.text$mn:00000499                 align 4
.text$mn:00000499 _text$mn        ends
.text$mn:00000499
.text$mn:0000049C ; ===========================================================================
.text$mn:0000049C
.text$mn:0000049C ; Segment type: Pure code
.text$mn:0000049C ; Segment permissions: Read/Execute
.text$mn:0000049C _text$mn        segment para public 'CODE' use32
.text$mn:0000049C                 assume cs:_text$mn
.text$mn:0000049C                 ;org 49Ch
.text$mn:0000049C ; COMDAT (pick any)
.text$mn:0000049C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000049C
.text$mn:0000049C ; =============== S U B R O U T I N E =======================================
.text$mn:0000049C
.text$mn:0000049C ; Attributes: bp-based frame
.text$mn:0000049C
.text$mn:0000049C ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000049C                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:0000049C ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:0000049C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:0000049C
.text$mn:0000049C var_4           = dword ptr -4
.text$mn:0000049C
.text$mn:0000049C                 push    ebp
.text$mn:0000049D                 mov     ebp, esp
.text$mn:0000049F                 push    ecx
.text$mn:000004A0                 mov     [ebp+var_4], ecx
.text$mn:000004A3                 mov     esp, ebp
.text$mn:000004A5                 pop     ebp
.text$mn:000004A6                 retn    4
.text$mn:000004A6 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000004A6
.text$mn:000004A6 ; ---------------------------------------------------------------------------
.text$mn:000004A9                 align 4
.text$mn:000004A9 _text$mn        ends
.text$mn:000004A9
.text$mn:000004AC ; ===========================================================================
.text$mn:000004AC
.text$mn:000004AC ; Segment type: Pure code
.text$mn:000004AC ; Segment permissions: Read/Execute
.text$mn:000004AC _text$mn        segment para public 'CODE' use32
.text$mn:000004AC                 assume cs:_text$mn
.text$mn:000004AC                 ;org 4ACh
.text$mn:000004AC ; COMDAT (pick any)
.text$mn:000004AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004AC
.text$mn:000004AC ; =============== S U B R O U T I N E =======================================
.text$mn:000004AC
.text$mn:000004AC ; Attributes: bp-based frame
.text$mn:000004AC
.text$mn:000004AC ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000004AC                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000004AC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000004AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000004AC
.text$mn:000004AC arg_0           = dword ptr  8
.text$mn:000004AC arg_4           = dword ptr  0Ch
.text$mn:000004AC
.text$mn:000004AC                 push    ebp
.text$mn:000004AD                 mov     ebp, esp
.text$mn:000004AF                 mov     eax, [ebp+arg_4]
.text$mn:000004B2                 push    eax
.text$mn:000004B3                 mov     ecx, [ebp+arg_0]
.text$mn:000004B6                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000004BB                 pop     ebp
.text$mn:000004BC                 retn
.text$mn:000004BC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000004BC
.text$mn:000004BC ; ---------------------------------------------------------------------------
.text$mn:000004BD                 align 10h
.text$mn:000004BD _text$mn        ends
.text$mn:000004BD
.text$mn:000004C0 ; ===========================================================================
.text$mn:000004C0
.text$mn:000004C0 ; Segment type: Pure code
.text$mn:000004C0 ; Segment permissions: Read/Execute
.text$mn:000004C0 _text$mn        segment para public 'CODE' use32
.text$mn:000004C0                 assume cs:_text$mn
.text$mn:000004C0                 ;org 4C0h
.text$mn:000004C0 ; COMDAT (pick any)
.text$mn:000004C0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004C0
.text$mn:000004C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000004C0
.text$mn:000004C0 ; Attributes: bp-based frame
.text$mn:000004C0
.text$mn:000004C0 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000004C0                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000004C0 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000004C0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:000004C0
.text$mn:000004C0 var_4           = dword ptr -4
.text$mn:000004C0
.text$mn:000004C0                 push    ebp
.text$mn:000004C1                 mov     ebp, esp
.text$mn:000004C3                 push    ecx
.text$mn:000004C4                 mov     [ebp+var_4], ecx
.text$mn:000004C7                 mov     esp, ebp
.text$mn:000004C9                 pop     ebp
.text$mn:000004CA                 retn    4
.text$mn:000004CA ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000004CA
.text$mn:000004CA ; ---------------------------------------------------------------------------
.text$mn:000004CD                 align 10h
.text$mn:000004CD _text$mn        ends
.text$mn:000004CD
.text$mn:000004D0 ; ===========================================================================
.text$mn:000004D0
.text$mn:000004D0 ; Segment type: Pure code
.text$mn:000004D0 ; Segment permissions: Read/Execute
.text$mn:000004D0 _text$mn        segment para public 'CODE' use32
.text$mn:000004D0                 assume cs:_text$mn
.text$mn:000004D0                 ;org 4D0h
.text$mn:000004D0 ; COMDAT (pick any)
.text$mn:000004D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004D0
.text$mn:000004D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000004D0
.text$mn:000004D0 ; Attributes: bp-based frame
.text$mn:000004D0
.text$mn:000004D0 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:000004D0                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:000004D0 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:000004D0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:000004D0                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:000004D0
.text$mn:000004D0 arg_0           = dword ptr  8
.text$mn:000004D0
.text$mn:000004D0                 push    ebp
.text$mn:000004D1                 mov     ebp, esp
.text$mn:000004D3                 mov     eax, [ebp+arg_0]
.text$mn:000004D6                 pop     ebp
.text$mn:000004D7                 retn
.text$mn:000004D7 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:000004D7
.text$mn:000004D7 _text$mn        ends
.text$mn:000004D7
.text$mn:000004D8 ; ===========================================================================
.text$mn:000004D8
.text$mn:000004D8 ; Segment type: Pure code
.text$mn:000004D8 ; Segment permissions: Read/Execute
.text$mn:000004D8 _text$mn        segment para public 'CODE' use32
.text$mn:000004D8                 assume cs:_text$mn
.text$mn:000004D8                 ;org 4D8h
.text$mn:000004D8 ; COMDAT (pick any)
.text$mn:000004D8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004D8
.text$mn:000004D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000004D8
.text$mn:000004D8 ; Attributes: bp-based frame
.text$mn:000004D8
.text$mn:000004D8 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000004D8                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000004D8 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000004D8                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:000004D8
.text$mn:000004D8 arg_0           = dword ptr  8
.text$mn:000004D8
.text$mn:000004D8                 push    ebp
.text$mn:000004D9                 mov     ebp, esp
.text$mn:000004DB                 mov     eax, [ebp+arg_0]
.text$mn:000004DE                 pop     ebp
.text$mn:000004DF                 retn
.text$mn:000004DF ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000004DF
.text$mn:000004DF _text$mn        ends
.text$mn:000004DF
.text$mn:000004E0 ; ===========================================================================
.text$mn:000004E0
.text$mn:000004E0 ; Segment type: Pure code
.text$mn:000004E0 ; Segment permissions: Read/Execute
.text$mn:000004E0 _text$mn        segment para public 'CODE' use32
.text$mn:000004E0                 assume cs:_text$mn
.text$mn:000004E0                 ;org 4E0h
.text$mn:000004E0 ; COMDAT (pick any)
.text$mn:000004E0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004E0
.text$mn:000004E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000004E0
.text$mn:000004E0 ; Attributes: bp-based frame
.text$mn:000004E0
.text$mn:000004E0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:000004E0                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000004E0 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:000004E0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:000004E0
.text$mn:000004E0 var_10          = dword ptr -10h
.text$mn:000004E0 var_C           = dword ptr -0Ch
.text$mn:000004E0 var_4           = dword ptr -4
.text$mn:000004E0
.text$mn:000004E0                 push    ebp
.text$mn:000004E1                 mov     ebp, esp
.text$mn:000004E3                 push    0FFFFFFFFh
.text$mn:000004E5                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000004EA                 mov     eax, large fs:0
.text$mn:000004F0                 push    eax
.text$mn:000004F1                 push    ecx
.text$mn:000004F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000004F7                 xor     eax, ebp
.text$mn:000004F9                 push    eax
.text$mn:000004FA                 lea     eax, [ebp+var_C]
.text$mn:000004FD                 mov     large fs:0, eax
.text$mn:00000503                 mov     [ebp+var_10], ecx
.text$mn:00000506                 mov     ecx, [ebp+var_10]
.text$mn:00000509                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:0000050E                 mov     [ebp+var_4], 0
.text$mn:00000515                 mov     ecx, [ebp+var_10]
.text$mn:00000518                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:0000051D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000524                 mov     eax, [ebp+var_10]
.text$mn:00000527                 mov     ecx, [ebp+var_C]
.text$mn:0000052A                 mov     large fs:0, ecx
.text$mn:00000531                 pop     ecx
.text$mn:00000532                 mov     esp, ebp
.text$mn:00000534                 pop     ebp
.text$mn:00000535                 retn    4
.text$mn:00000535 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000535
.text$mn:00000535 _text$mn        ends
.text$mn:00000535
.text$x:00000538 ; ===========================================================================
.text$x:00000538
.text$x:00000538 ; Segment type: Pure code
.text$x:00000538 ; Segment permissions: Read/Execute
.text$x:00000538 _text$x         segment para public 'CODE' use32
.text$x:00000538                 assume cs:_text$x
.text$x:00000538                 ;org 538h
.text$x:00000538 ; COMDAT (pick associative to section at 4E0)
.text$x:00000538                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000538
.text$x:00000538 ; =============== S U B R O U T I N E =======================================
.text$x:00000538
.text$x:00000538
.text$x:00000538 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000538                                         ; DATA XREF: .xdata$x:000022D0o
.text$x:00000538                 mov     ecx, [ebp-10h]
.text$x:0000053B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000053B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:0000053B
.text$x:00000540
.text$x:00000540 ; =============== S U B R O U T I N E =======================================
.text$x:00000540
.text$x:00000540
.text$x:00000540 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000540                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000540
.text$x:00000540 arg_4           = dword ptr  8
.text$x:00000540
.text$x:00000540                 mov     edx, [esp+arg_4]
.text$x:00000544                 lea     eax, [edx+0Ch]
.text$x:00000547                 mov     ecx, [edx-8]
.text$x:0000054A                 xor     ecx, eax
.text$x:0000054C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000551                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00000556                 jmp     ___CxxFrameHandler3
.text$x:00000556 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00000556
.text$x:00000556 ; ---------------------------------------------------------------------------
.text$x:0000055B                 align 4
.text$x:0000055B _text$x         ends
.text$x:0000055B
.text$mn:0000055C ; ===========================================================================
.text$mn:0000055C
.text$mn:0000055C ; Segment type: Pure code
.text$mn:0000055C ; Segment permissions: Read/Execute
.text$mn:0000055C _text$mn        segment para public 'CODE' use32
.text$mn:0000055C                 assume cs:_text$mn
.text$mn:0000055C                 ;org 55Ch
.text$mn:0000055C ; COMDAT (pick any)
.text$mn:0000055C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000055C
.text$mn:0000055C ; =============== S U B R O U T I N E =======================================
.text$mn:0000055C
.text$mn:0000055C ; Attributes: bp-based frame
.text$mn:0000055C
.text$mn:0000055C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:0000055C                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000055C ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:0000055C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:0000055C
.text$mn:0000055C var_10          = dword ptr -10h
.text$mn:0000055C var_C           = dword ptr -0Ch
.text$mn:0000055C var_4           = dword ptr -4
.text$mn:0000055C
.text$mn:0000055C                 push    ebp
.text$mn:0000055D                 mov     ebp, esp
.text$mn:0000055F                 push    0FFFFFFFFh
.text$mn:00000561                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000566                 mov     eax, large fs:0
.text$mn:0000056C                 push    eax
.text$mn:0000056D                 push    ecx
.text$mn:0000056E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000573                 xor     eax, ebp
.text$mn:00000575                 push    eax
.text$mn:00000576                 lea     eax, [ebp+var_C]
.text$mn:00000579                 mov     large fs:0, eax
.text$mn:0000057F                 mov     [ebp+var_10], ecx
.text$mn:00000582                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000585                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000058A                 mov     [ebp+var_4], 0
.text$mn:00000591                 mov     eax, [ebp+var_10]
.text$mn:00000594                 mov     dword ptr [eax+14h], 0
.text$mn:0000059B                 mov     ecx, [ebp+var_10]
.text$mn:0000059E                 mov     dword ptr [ecx+18h], 0
.text$mn:000005A5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000005AC                 mov     eax, [ebp+var_10]
.text$mn:000005AF                 mov     ecx, [ebp+var_C]
.text$mn:000005B2                 mov     large fs:0, ecx
.text$mn:000005B9                 pop     ecx
.text$mn:000005BA                 mov     esp, ebp
.text$mn:000005BC                 pop     ebp
.text$mn:000005BD                 retn
.text$mn:000005BD ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000005BD
.text$mn:000005BD ; ---------------------------------------------------------------------------
.text$mn:000005BE                 align 10h
.text$mn:000005BE _text$mn        ends
.text$mn:000005BE
.text$x:000005C0 ; ===========================================================================
.text$x:000005C0
.text$x:000005C0 ; Segment type: Pure code
.text$x:000005C0 ; Segment permissions: Read/Execute
.text$x:000005C0 _text$x         segment para public 'CODE' use32
.text$x:000005C0                 assume cs:_text$x
.text$x:000005C0                 ;org 5C0h
.text$x:000005C0 ; COMDAT (pick associative to section at 55C)
.text$x:000005C0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000005C0
.text$x:000005C0 ; =============== S U B R O U T I N E =======================================
.text$x:000005C0
.text$x:000005C0
.text$x:000005C0 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000005C0                                         ; DATA XREF: .xdata$x:00002278o
.text$x:000005C0                 mov     ecx, [ebp-10h]  ; this
.text$x:000005C3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000005C3 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000005C3
.text$x:000005C8
.text$x:000005C8 ; =============== S U B R O U T I N E =======================================
.text$x:000005C8
.text$x:000005C8
.text$x:000005C8 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000005C8                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000005C8
.text$x:000005C8 arg_4           = dword ptr  8
.text$x:000005C8
.text$x:000005C8                 mov     edx, [esp+arg_4]
.text$x:000005CC                 lea     eax, [edx+0Ch]
.text$x:000005CF                 mov     ecx, [edx-8]
.text$x:000005D2                 xor     ecx, eax
.text$x:000005D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000005D9                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000005DE                 jmp     ___CxxFrameHandler3
.text$x:000005DE __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000005DE
.text$x:000005DE ; ---------------------------------------------------------------------------
.text$x:000005E3                 align 4
.text$x:000005E3 _text$x         ends
.text$x:000005E3
.text$mn:000005E4 ; ===========================================================================
.text$mn:000005E4
.text$mn:000005E4 ; Segment type: Pure code
.text$mn:000005E4 ; Segment permissions: Read/Execute
.text$mn:000005E4 _text$mn        segment para public 'CODE' use32
.text$mn:000005E4                 assume cs:_text$mn
.text$mn:000005E4                 ;org 5E4h
.text$mn:000005E4 ; COMDAT (pick any)
.text$mn:000005E4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000005E4
.text$mn:000005E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000005E4
.text$mn:000005E4 ; Attributes: bp-based frame
.text$mn:000005E4
.text$mn:000005E4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000005E4                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000005E4 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000005E4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000005E4
.text$mn:000005E4 var_4           = dword ptr -4
.text$mn:000005E4
.text$mn:000005E4                 push    ebp
.text$mn:000005E5                 mov     ebp, esp
.text$mn:000005E7                 push    ecx
.text$mn:000005E8                 mov     [ebp+var_4], ecx
.text$mn:000005EB                 mov     ecx, [ebp+var_4]
.text$mn:000005EE                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000005F3                 mov     eax, [ebp+var_4]
.text$mn:000005F6                 mov     esp, ebp
.text$mn:000005F8                 pop     ebp
.text$mn:000005F9                 retn
.text$mn:000005F9 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000005F9
.text$mn:000005F9 ; ---------------------------------------------------------------------------
.text$mn:000005FA                 align 4
.text$mn:000005FA _text$mn        ends
.text$mn:000005FA
.text$mn:000005FC ; ===========================================================================
.text$mn:000005FC
.text$mn:000005FC ; Segment type: Pure code
.text$mn:000005FC ; Segment permissions: Read/Execute
.text$mn:000005FC _text$mn        segment para public 'CODE' use32
.text$mn:000005FC                 assume cs:_text$mn
.text$mn:000005FC                 ;org 5FCh
.text$mn:000005FC ; COMDAT (pick any)
.text$mn:000005FC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000005FC
.text$mn:000005FC ; =============== S U B R O U T I N E =======================================
.text$mn:000005FC
.text$mn:000005FC ; Attributes: bp-based frame
.text$mn:000005FC
.text$mn:000005FC ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:000005FC                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:000005FC ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:000005FC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:000005FC
.text$mn:000005FC var_4           = dword ptr -4
.text$mn:000005FC
.text$mn:000005FC                 push    ebp
.text$mn:000005FD                 mov     ebp, esp
.text$mn:000005FF                 push    ecx
.text$mn:00000600                 mov     [ebp+var_4], ecx
.text$mn:00000603                 mov     eax, [ebp+var_4]
.text$mn:00000606                 mov     esp, ebp
.text$mn:00000608                 pop     ebp
.text$mn:00000609                 retn
.text$mn:00000609 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000609
.text$mn:00000609 ; ---------------------------------------------------------------------------
.text$mn:0000060A                 align 4
.text$mn:0000060A _text$mn        ends
.text$mn:0000060A
.text$mn:0000060C ; ===========================================================================
.text$mn:0000060C
.text$mn:0000060C ; Segment type: Pure code
.text$mn:0000060C ; Segment permissions: Read/Execute
.text$mn:0000060C _text$mn        segment para public 'CODE' use32
.text$mn:0000060C                 assume cs:_text$mn
.text$mn:0000060C                 ;org 60Ch
.text$mn:0000060C ; COMDAT (pick any)
.text$mn:0000060C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000060C
.text$mn:0000060C ; =============== S U B R O U T I N E =======================================
.text$mn:0000060C
.text$mn:0000060C ; Attributes: bp-based frame
.text$mn:0000060C
.text$mn:0000060C ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:0000060C                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:0000060C ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:0000060C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:0000060C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:0000060C
.text$mn:0000060C var_4           = dword ptr -4
.text$mn:0000060C
.text$mn:0000060C                 push    ebp
.text$mn:0000060D                 mov     ebp, esp
.text$mn:0000060F                 push    ecx
.text$mn:00000610                 mov     [ebp+var_4], ecx
.text$mn:00000613                 mov     eax, [ebp+var_4]
.text$mn:00000616                 mov     esp, ebp
.text$mn:00000618                 pop     ebp
.text$mn:00000619                 retn
.text$mn:00000619 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000619
.text$mn:00000619 ; ---------------------------------------------------------------------------
.text$mn:0000061A                 align 4
.text$mn:0000061A _text$mn        ends
.text$mn:0000061A
.text$mn:0000061C ; ===========================================================================
.text$mn:0000061C
.text$mn:0000061C ; Segment type: Pure code
.text$mn:0000061C ; Segment permissions: Read/Execute
.text$mn:0000061C _text$mn        segment para public 'CODE' use32
.text$mn:0000061C                 assume cs:_text$mn
.text$mn:0000061C                 ;org 61Ch
.text$mn:0000061C ; COMDAT (pick any)
.text$mn:0000061C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000061C
.text$mn:0000061C ; =============== S U B R O U T I N E =======================================
.text$mn:0000061C
.text$mn:0000061C ; Attributes: bp-based frame
.text$mn:0000061C
.text$mn:0000061C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:0000061C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000061C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:0000061C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:0000061C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:0000061C
.text$mn:0000061C var_14          = dword ptr -14h
.text$mn:0000061C var_D           = byte ptr -0Dh
.text$mn:0000061C var_C           = dword ptr -0Ch
.text$mn:0000061C var_4           = dword ptr -4
.text$mn:0000061C Str             = dword ptr  8
.text$mn:0000061C
.text$mn:0000061C                 push    ebp
.text$mn:0000061D                 mov     ebp, esp
.text$mn:0000061F                 push    0FFFFFFFFh
.text$mn:00000621                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000626                 mov     eax, large fs:0
.text$mn:0000062C                 push    eax
.text$mn:0000062D                 sub     esp, 8
.text$mn:00000630                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000635                 xor     eax, ebp
.text$mn:00000637                 push    eax
.text$mn:00000638                 lea     eax, [ebp+var_C]
.text$mn:0000063B                 mov     large fs:0, eax
.text$mn:00000641                 mov     [ebp+var_14], ecx
.text$mn:00000644                 lea     ecx, [ebp+var_D]
.text$mn:00000647                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000064C                 push    eax
.text$mn:0000064D                 mov     ecx, [ebp+var_14]
.text$mn:00000650                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000655                 mov     [ebp+var_4], 0
.text$mn:0000065C                 push    0               ; Size
.text$mn:0000065E                 push    0               ; char
.text$mn:00000660                 mov     ecx, [ebp+var_14]
.text$mn:00000663                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000668                 mov     eax, [ebp+Str]
.text$mn:0000066B                 push    eax             ; Str
.text$mn:0000066C                 mov     ecx, [ebp+var_14]
.text$mn:0000066F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000674                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000067B                 mov     eax, [ebp+var_14]
.text$mn:0000067E                 mov     ecx, [ebp+var_C]
.text$mn:00000681                 mov     large fs:0, ecx
.text$mn:00000688                 pop     ecx
.text$mn:00000689                 mov     esp, ebp
.text$mn:0000068B                 pop     ebp
.text$mn:0000068C                 retn    4
.text$mn:0000068C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:0000068C
.text$mn:0000068C ; ---------------------------------------------------------------------------
.text$mn:0000068F                 align 10h
.text$mn:0000068F _text$mn        ends
.text$mn:0000068F
.text$x:00000690 ; ===========================================================================
.text$x:00000690
.text$x:00000690 ; Segment type: Pure code
.text$x:00000690 ; Segment permissions: Read/Execute
.text$x:00000690 _text$x         segment para public 'CODE' use32
.text$x:00000690                 assume cs:_text$x
.text$x:00000690                 ;org 690h
.text$x:00000690 ; COMDAT (pick associative to section at 61C)
.text$x:00000690                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000690
.text$x:00000690 ; =============== S U B R O U T I N E =======================================
.text$x:00000690
.text$x:00000690
.text$x:00000690 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000690                                         ; DATA XREF: .xdata$x:00002328o
.text$x:00000690                 mov     ecx, [ebp-14h]
.text$x:00000693                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000693 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000693
.text$x:00000698
.text$x:00000698 ; =============== S U B R O U T I N E =======================================
.text$x:00000698
.text$x:00000698
.text$x:00000698 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000698                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000698
.text$x:00000698 arg_4           = dword ptr  8
.text$x:00000698
.text$x:00000698                 mov     edx, [esp+arg_4]
.text$x:0000069C                 lea     eax, [edx+0Ch]
.text$x:0000069F                 mov     ecx, [edx-0Ch]
.text$x:000006A2                 xor     ecx, eax
.text$x:000006A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000006A9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000006AE                 jmp     ___CxxFrameHandler3
.text$x:000006AE __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000006AE
.text$x:000006AE ; ---------------------------------------------------------------------------
.text$x:000006B3                 align 4
.text$x:000006B3 _text$x         ends
.text$x:000006B3
.text$mn:000006B4 ; ===========================================================================
.text$mn:000006B4
.text$mn:000006B4 ; Segment type: Pure code
.text$mn:000006B4 ; Segment permissions: Read/Execute
.text$mn:000006B4 _text$mn        segment para public 'CODE' use32
.text$mn:000006B4                 assume cs:_text$mn
.text$mn:000006B4                 ;org 6B4h
.text$mn:000006B4 ; COMDAT (pick any)
.text$mn:000006B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000006B4
.text$mn:000006B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000006B4
.text$mn:000006B4 ; Attributes: bp-based frame
.text$mn:000006B4
.text$mn:000006B4 ; public: __thiscall StaticDialog::StaticDialog(void)
.text$mn:000006B4                 public ??0StaticDialog@@QAE@XZ
.text$mn:000006B4 ??0StaticDialog@@QAE@XZ proc near       ; CODE XREF: SizeableDlg::SizeableDlg(WINRECT *)+29p
.text$mn:000006B4
.text$mn:000006B4 var_10          = dword ptr -10h
.text$mn:000006B4 var_C           = dword ptr -0Ch
.text$mn:000006B4 var_4           = dword ptr -4
.text$mn:000006B4
.text$mn:000006B4                 push    ebp
.text$mn:000006B5                 mov     ebp, esp
.text$mn:000006B7                 push    0FFFFFFFFh
.text$mn:000006B9                 push    offset __ehhandler$??0StaticDialog@@QAE@XZ
.text$mn:000006BE                 mov     eax, large fs:0
.text$mn:000006C4                 push    eax
.text$mn:000006C5                 push    ecx
.text$mn:000006C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000006CB                 xor     eax, ebp
.text$mn:000006CD                 push    eax
.text$mn:000006CE                 lea     eax, [ebp+var_C]
.text$mn:000006D1                 mov     large fs:0, eax
.text$mn:000006D7                 mov     [ebp+var_10], ecx
.text$mn:000006DA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000006DD                 call    ??0Window@@QAE@XZ ; Window::Window(void)
.text$mn:000006E2                 mov     [ebp+var_4], 0
.text$mn:000006E9                 mov     eax, [ebp+var_10]
.text$mn:000006EC                 mov     dword ptr [eax], offset ??_7StaticDialog@@6B@ ; const StaticDialog::`vftable'
.text$mn:000006F2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000006F9                 mov     eax, [ebp+var_10]
.text$mn:000006FC                 mov     ecx, [ebp+var_C]
.text$mn:000006FF                 mov     large fs:0, ecx
.text$mn:00000706                 pop     ecx
.text$mn:00000707                 mov     esp, ebp
.text$mn:00000709                 pop     ebp
.text$mn:0000070A                 retn
.text$mn:0000070A ??0StaticDialog@@QAE@XZ endp
.text$mn:0000070A
.text$mn:0000070A ; ---------------------------------------------------------------------------
.text$mn:0000070B                 align 4
.text$mn:0000070B _text$mn        ends
.text$mn:0000070B
.text$x:0000070C ; ===========================================================================
.text$x:0000070C
.text$x:0000070C ; Segment type: Pure code
.text$x:0000070C ; Segment permissions: Read/Execute
.text$x:0000070C _text$x         segment para public 'CODE' use32
.text$x:0000070C                 assume cs:_text$x
.text$x:0000070C                 ;org 70Ch
.text$x:0000070C ; COMDAT (pick associative to section at 6B4)
.text$x:0000070C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000070C
.text$x:0000070C ; =============== S U B R O U T I N E =======================================
.text$x:0000070C
.text$x:0000070C
.text$x:0000070C __unwindfunclet$??0StaticDialog@@QAE@XZ$0 proc near
.text$x:0000070C                                         ; DATA XREF: .xdata$x:0000218Co
.text$x:0000070C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000070F                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:0000070F __unwindfunclet$??0StaticDialog@@QAE@XZ$0 endp
.text$x:0000070F
.text$x:00000714
.text$x:00000714 ; =============== S U B R O U T I N E =======================================
.text$x:00000714
.text$x:00000714
.text$x:00000714 __ehhandler$??0StaticDialog@@QAE@XZ proc near
.text$x:00000714                                         ; DATA XREF: StaticDialog::StaticDialog(void)+5o
.text$x:00000714
.text$x:00000714 arg_4           = dword ptr  8
.text$x:00000714
.text$x:00000714                 mov     edx, [esp+arg_4]
.text$x:00000718                 lea     eax, [edx+0Ch]
.text$x:0000071B                 mov     ecx, [edx-8]
.text$x:0000071E                 xor     ecx, eax
.text$x:00000720                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000725                 mov     eax, offset __ehfuncinfo$??0StaticDialog@@QAE@XZ
.text$x:0000072A                 jmp     ___CxxFrameHandler3
.text$x:0000072A __ehhandler$??0StaticDialog@@QAE@XZ endp
.text$x:0000072A
.text$x:0000072A ; ---------------------------------------------------------------------------
.text$x:0000072F                 align 10h
.text$x:0000072F _text$x         ends
.text$x:0000072F
.text$mn:00000730 ; ===========================================================================
.text$mn:00000730
.text$mn:00000730 ; Segment type: Pure code
.text$mn:00000730 ; Segment permissions: Read/Execute
.text$mn:00000730 _text$mn        segment para public 'CODE' use32
.text$mn:00000730                 assume cs:_text$mn
.text$mn:00000730                 ;org 730h
.text$mn:00000730 ; COMDAT (pick any)
.text$mn:00000730                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000730
.text$mn:00000730 ; =============== S U B R O U T I N E =======================================
.text$mn:00000730
.text$mn:00000730 ; Attributes: bp-based frame
.text$mn:00000730
.text$mn:00000730 ; _DWORD __thiscall Window::Window(Window *__hidden this)
.text$mn:00000730                 public ??0Window@@QAE@XZ
.text$mn:00000730 ??0Window@@QAE@XZ proc near             ; CODE XREF: StaticDialog::StaticDialog(void)+29p
.text$mn:00000730
.text$mn:00000730 var_4           = dword ptr -4
.text$mn:00000730
.text$mn:00000730                 push    ebp
.text$mn:00000731                 mov     ebp, esp
.text$mn:00000733                 push    ecx
.text$mn:00000734                 mov     [ebp+var_4], ecx
.text$mn:00000737                 mov     eax, [ebp+var_4]
.text$mn:0000073A                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00000740                 mov     ecx, [ebp+var_4]
.text$mn:00000743                 mov     dword ptr [ecx+4], 0
.text$mn:0000074A                 mov     edx, [ebp+var_4]
.text$mn:0000074D                 mov     dword ptr [edx+8], 0
.text$mn:00000754                 mov     eax, [ebp+var_4]
.text$mn:00000757                 mov     dword ptr [eax+0Ch], 0
.text$mn:0000075E                 mov     eax, [ebp+var_4]
.text$mn:00000761                 mov     esp, ebp
.text$mn:00000763                 pop     ebp
.text$mn:00000764                 retn
.text$mn:00000764 ??0Window@@QAE@XZ endp
.text$mn:00000764
.text$mn:00000764 ; ---------------------------------------------------------------------------
.text$mn:00000765                 align 4
.text$mn:00000765 _text$mn        ends
.text$mn:00000765
.text$mn:00000768 ; ===========================================================================
.text$mn:00000768
.text$mn:00000768 ; Segment type: Pure code
.text$mn:00000768 ; Segment permissions: Read/Execute
.text$mn:00000768 _text$mn        segment para public 'CODE' use32
.text$mn:00000768                 assume cs:_text$mn
.text$mn:00000768                 ;org 768h
.text$mn:00000768 ; COMDAT (pick any)
.text$mn:00000768                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000768
.text$mn:00000768 ; =============== S U B R O U T I N E =======================================
.text$mn:00000768
.text$mn:00000768 ; Attributes: bp-based frame
.text$mn:00000768
.text$mn:00000768 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000768                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000768 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000768                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000768
.text$mn:00000768 var_4           = dword ptr -4
.text$mn:00000768
.text$mn:00000768                 push    ebp
.text$mn:00000769                 mov     ebp, esp
.text$mn:0000076B                 push    ecx
.text$mn:0000076C                 mov     [ebp+var_4], ecx
.text$mn:0000076F                 mov     eax, [ebp+var_4]
.text$mn:00000772                 mov     dword ptr [eax], 0
.text$mn:00000778                 mov     eax, [ebp+var_4]
.text$mn:0000077B                 mov     esp, ebp
.text$mn:0000077D                 pop     ebp
.text$mn:0000077E                 retn
.text$mn:0000077E ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000077E
.text$mn:0000077E ; ---------------------------------------------------------------------------
.text$mn:0000077F                 align 10h
.text$mn:0000077F _text$mn        ends
.text$mn:0000077F
.text$mn:00000780 ; ===========================================================================
.text$mn:00000780
.text$mn:00000780 ; Segment type: Pure code
.text$mn:00000780 ; Segment permissions: Read/Execute
.text$mn:00000780 _text$mn        segment para public 'CODE' use32
.text$mn:00000780                 assume cs:_text$mn
.text$mn:00000780                 ;org 780h
.text$mn:00000780 ; COMDAT (pick any)
.text$mn:00000780                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000780
.text$mn:00000780 ; =============== S U B R O U T I N E =======================================
.text$mn:00000780
.text$mn:00000780 ; Attributes: bp-based frame
.text$mn:00000780
.text$mn:00000780 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000780                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000780 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000780                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000780
.text$mn:00000780 var_4           = dword ptr -4
.text$mn:00000780
.text$mn:00000780                 push    ebp
.text$mn:00000781                 mov     ebp, esp
.text$mn:00000783                 push    ecx
.text$mn:00000784                 mov     [ebp+var_4], ecx
.text$mn:00000787                 mov     eax, [ebp+var_4]
.text$mn:0000078A                 mov     dword ptr [eax], 0
.text$mn:00000790                 mov     ecx, [ebp+var_4]
.text$mn:00000793                 mov     dword ptr [ecx+4], 0
.text$mn:0000079A                 mov     eax, [ebp+var_4]
.text$mn:0000079D                 mov     esp, ebp
.text$mn:0000079F                 pop     ebp
.text$mn:000007A0                 retn
.text$mn:000007A0 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:000007A0
.text$mn:000007A0 ; ---------------------------------------------------------------------------
.text$mn:000007A1                 align 4
.text$mn:000007A1 _text$mn        ends
.text$mn:000007A1
.text$mn:000007A4 ; ===========================================================================
.text$mn:000007A4
.text$mn:000007A4 ; Segment type: Pure code
.text$mn:000007A4 ; Segment permissions: Read/Execute
.text$mn:000007A4 _text$mn        segment para public 'CODE' use32
.text$mn:000007A4                 assume cs:_text$mn
.text$mn:000007A4                 ;org 7A4h
.text$mn:000007A4 ; COMDAT (pick any)
.text$mn:000007A4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000007A4
.text$mn:000007A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000007A4
.text$mn:000007A4 ; Attributes: bp-based frame
.text$mn:000007A4
.text$mn:000007A4 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000007A4                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:000007A4 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:000007A4                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:000007A4                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:000007A4
.text$mn:000007A4 var_10          = dword ptr -10h
.text$mn:000007A4 var_C           = dword ptr -0Ch
.text$mn:000007A4 var_4           = dword ptr -4
.text$mn:000007A4
.text$mn:000007A4                 push    ebp
.text$mn:000007A5                 mov     ebp, esp
.text$mn:000007A7                 push    0FFFFFFFFh
.text$mn:000007A9                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:000007AE                 mov     eax, large fs:0
.text$mn:000007B4                 push    eax
.text$mn:000007B5                 push    ecx
.text$mn:000007B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000007BB                 xor     eax, ebp
.text$mn:000007BD                 push    eax
.text$mn:000007BE                 lea     eax, [ebp+var_C]
.text$mn:000007C1                 mov     large fs:0, eax
.text$mn:000007C7                 mov     [ebp+var_10], ecx
.text$mn:000007CA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000007CD                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000007D2                 mov     [ebp+var_4], 0
.text$mn:000007D9                 mov     eax, [ebp+var_10]
.text$mn:000007DC                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000007E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000007E9                 mov     eax, [ebp+var_10]
.text$mn:000007EC                 mov     ecx, [ebp+var_C]
.text$mn:000007EF                 mov     large fs:0, ecx
.text$mn:000007F6                 pop     ecx
.text$mn:000007F7                 mov     esp, ebp
.text$mn:000007F9                 pop     ebp
.text$mn:000007FA                 retn
.text$mn:000007FA ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000007FA
.text$mn:000007FA ; ---------------------------------------------------------------------------
.text$mn:000007FB                 align 4
.text$mn:000007FB _text$mn        ends
.text$mn:000007FB
.text$x:000007FC ; ===========================================================================
.text$x:000007FC
.text$x:000007FC ; Segment type: Pure code
.text$x:000007FC ; Segment permissions: Read/Execute
.text$x:000007FC _text$x         segment para public 'CODE' use32
.text$x:000007FC                 assume cs:_text$x
.text$x:000007FC                 ;org 7FCh
.text$x:000007FC ; COMDAT (pick associative to section at 7A4)
.text$x:000007FC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000007FC
.text$x:000007FC ; =============== S U B R O U T I N E =======================================
.text$x:000007FC
.text$x:000007FC
.text$x:000007FC __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000007FC                                         ; DATA XREF: .xdata$x:0000240Co
.text$x:000007FC                 mov     ecx, [ebp-10h]  ; this
.text$x:000007FF                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000007FF __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000007FF
.text$x:00000804
.text$x:00000804 ; =============== S U B R O U T I N E =======================================
.text$x:00000804
.text$x:00000804
.text$x:00000804 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00000804                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00000804
.text$x:00000804 arg_4           = dword ptr  8
.text$x:00000804
.text$x:00000804                 mov     edx, [esp+arg_4]
.text$x:00000808                 lea     eax, [edx+0Ch]
.text$x:0000080B                 mov     ecx, [edx-8]
.text$x:0000080E                 xor     ecx, eax
.text$x:00000810                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000815                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:0000081A                 jmp     ___CxxFrameHandler3
.text$x:0000081A __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:0000081A
.text$x:0000081A ; ---------------------------------------------------------------------------
.text$x:0000081F                 align 10h
.text$x:0000081F _text$x         ends
.text$x:0000081F
.text$mn:00000820 ; ===========================================================================
.text$mn:00000820
.text$mn:00000820 ; Segment type: Pure code
.text$mn:00000820 ; Segment permissions: Read/Execute
.text$mn:00000820 _text$mn        segment para public 'CODE' use32
.text$mn:00000820                 assume cs:_text$mn
.text$mn:00000820                 ;org 820h
.text$mn:00000820 ; COMDAT (pick any)
.text$mn:00000820                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000820
.text$mn:00000820 ; =============== S U B R O U T I N E =======================================
.text$mn:00000820
.text$mn:00000820 ; Attributes: bp-based frame
.text$mn:00000820
.text$mn:00000820 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000820                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000820 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00000820                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000820
.text$mn:00000820 var_10          = dword ptr -10h
.text$mn:00000820 var_C           = dword ptr -0Ch
.text$mn:00000820 var_4           = dword ptr -4
.text$mn:00000820
.text$mn:00000820                 push    ebp
.text$mn:00000821                 mov     ebp, esp
.text$mn:00000823                 push    0FFFFFFFFh
.text$mn:00000825                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000082A                 mov     eax, large fs:0
.text$mn:00000830                 push    eax
.text$mn:00000831                 push    ecx
.text$mn:00000832                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000837                 xor     eax, ebp
.text$mn:00000839                 push    eax
.text$mn:0000083A                 lea     eax, [ebp+var_C]
.text$mn:0000083D                 mov     large fs:0, eax
.text$mn:00000843                 mov     [ebp+var_10], ecx
.text$mn:00000846                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000849                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000084E                 mov     [ebp+var_4], 0
.text$mn:00000855                 mov     eax, [ebp+var_10]
.text$mn:00000858                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000085E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000865                 mov     eax, [ebp+var_10]
.text$mn:00000868                 mov     ecx, [ebp+var_C]
.text$mn:0000086B                 mov     large fs:0, ecx
.text$mn:00000872                 pop     ecx
.text$mn:00000873                 mov     esp, ebp
.text$mn:00000875                 pop     ebp
.text$mn:00000876                 retn
.text$mn:00000876 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00000876
.text$mn:00000876 ; ---------------------------------------------------------------------------
.text$mn:00000877                 align 4
.text$mn:00000877 _text$mn        ends
.text$mn:00000877
.text$x:00000878 ; ===========================================================================
.text$x:00000878
.text$x:00000878 ; Segment type: Pure code
.text$x:00000878 ; Segment permissions: Read/Execute
.text$x:00000878 _text$x         segment para public 'CODE' use32
.text$x:00000878                 assume cs:_text$x
.text$x:00000878                 ;org 878h
.text$x:00000878 ; COMDAT (pick associative to section at 820)
.text$x:00000878                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000878
.text$x:00000878 ; =============== S U B R O U T I N E =======================================
.text$x:00000878
.text$x:00000878
.text$x:00000878 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000878                                         ; DATA XREF: .xdata$x:00002490o
.text$x:00000878                 mov     ecx, [ebp-10h]  ; this
.text$x:0000087B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000087B __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:0000087B
.text$x:00000880
.text$x:00000880 ; =============== S U B R O U T I N E =======================================
.text$x:00000880
.text$x:00000880
.text$x:00000880 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000880                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000880
.text$x:00000880 arg_4           = dword ptr  8
.text$x:00000880
.text$x:00000880                 mov     edx, [esp+arg_4]
.text$x:00000884                 lea     eax, [edx+0Ch]
.text$x:00000887                 mov     ecx, [edx-8]
.text$x:0000088A                 xor     ecx, eax
.text$x:0000088C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000891                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00000896                 jmp     ___CxxFrameHandler3
.text$x:00000896 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00000896
.text$x:00000896 ; ---------------------------------------------------------------------------
.text$x:0000089B                 align 4
.text$x:0000089B _text$x         ends
.text$x:0000089B
.text$mn:0000089C ; ===========================================================================
.text$mn:0000089C
.text$mn:0000089C ; Segment type: Pure code
.text$mn:0000089C ; Segment permissions: Read/Execute
.text$mn:0000089C _text$mn        segment para public 'CODE' use32
.text$mn:0000089C                 assume cs:_text$mn
.text$mn:0000089C                 ;org 89Ch
.text$mn:0000089C ; COMDAT (pick any)
.text$mn:0000089C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000089C
.text$mn:0000089C ; =============== S U B R O U T I N E =======================================
.text$mn:0000089C
.text$mn:0000089C ; Attributes: bp-based frame
.text$mn:0000089C
.text$mn:0000089C ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:0000089C                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:0000089C ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:0000089C                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:0000089C
.text$mn:0000089C var_10          = dword ptr -10h
.text$mn:0000089C var_C           = dword ptr -0Ch
.text$mn:0000089C var_4           = dword ptr -4
.text$mn:0000089C
.text$mn:0000089C                 push    ebp
.text$mn:0000089D                 mov     ebp, esp
.text$mn:0000089F                 push    0FFFFFFFFh
.text$mn:000008A1                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:000008A6                 mov     eax, large fs:0
.text$mn:000008AC                 push    eax
.text$mn:000008AD                 push    ecx
.text$mn:000008AE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000008B3                 xor     eax, ebp
.text$mn:000008B5                 push    eax
.text$mn:000008B6                 lea     eax, [ebp+var_C]
.text$mn:000008B9                 mov     large fs:0, eax
.text$mn:000008BF                 mov     [ebp+var_10], ecx
.text$mn:000008C2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000008C5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000008CA                 mov     [ebp+var_4], 0
.text$mn:000008D1                 mov     eax, [ebp+var_10]
.text$mn:000008D4                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000008DA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000008E1                 mov     eax, [ebp+var_10]
.text$mn:000008E4                 mov     ecx, [ebp+var_C]
.text$mn:000008E7                 mov     large fs:0, ecx
.text$mn:000008EE                 pop     ecx
.text$mn:000008EF                 mov     esp, ebp
.text$mn:000008F1                 pop     ebp
.text$mn:000008F2                 retn
.text$mn:000008F2 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000008F2
.text$mn:000008F2 ; ---------------------------------------------------------------------------
.text$mn:000008F3                 align 4
.text$mn:000008F3 _text$mn        ends
.text$mn:000008F3
.text$x:000008F4 ; ===========================================================================
.text$x:000008F4
.text$x:000008F4 ; Segment type: Pure code
.text$x:000008F4 ; Segment permissions: Read/Execute
.text$x:000008F4 _text$x         segment para public 'CODE' use32
.text$x:000008F4                 assume cs:_text$x
.text$x:000008F4                 ;org 8F4h
.text$x:000008F4 ; COMDAT (pick associative to section at 89C)
.text$x:000008F4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000008F4
.text$x:000008F4 ; =============== S U B R O U T I N E =======================================
.text$x:000008F4
.text$x:000008F4
.text$x:000008F4 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000008F4                                         ; DATA XREF: .xdata$x:00002514o
.text$x:000008F4                 mov     ecx, [ebp-10h]  ; this
.text$x:000008F7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000008F7 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000008F7
.text$x:000008FC
.text$x:000008FC ; =============== S U B R O U T I N E =======================================
.text$x:000008FC
.text$x:000008FC
.text$x:000008FC __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000008FC                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000008FC
.text$x:000008FC arg_4           = dword ptr  8
.text$x:000008FC
.text$x:000008FC                 mov     edx, [esp+arg_4]
.text$x:00000900                 lea     eax, [edx+0Ch]
.text$x:00000903                 mov     ecx, [edx-8]
.text$x:00000906                 xor     ecx, eax
.text$x:00000908                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000090D                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00000912                 jmp     ___CxxFrameHandler3
.text$x:00000912 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00000912
.text$x:00000912 ; ---------------------------------------------------------------------------
.text$x:00000917                 align 4
.text$x:00000917 _text$x         ends
.text$x:00000917
.text$mn:00000918 ; ===========================================================================
.text$mn:00000918
.text$mn:00000918 ; Segment type: Pure code
.text$mn:00000918 ; Segment permissions: Read/Execute
.text$mn:00000918 _text$mn        segment para public 'CODE' use32
.text$mn:00000918                 assume cs:_text$mn
.text$mn:00000918                 ;org 918h
.text$mn:00000918 ; COMDAT (pick any)
.text$mn:00000918                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000918
.text$mn:00000918 ; =============== S U B R O U T I N E =======================================
.text$mn:00000918
.text$mn:00000918 ; Attributes: bp-based frame
.text$mn:00000918
.text$mn:00000918 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00000918                 public ??0error_category@std@@QAE@XZ
.text$mn:00000918 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00000918
.text$mn:00000918 var_4           = dword ptr -4
.text$mn:00000918
.text$mn:00000918                 push    ebp
.text$mn:00000919                 mov     ebp, esp
.text$mn:0000091B                 push    ecx
.text$mn:0000091C                 mov     [ebp+var_4], ecx
.text$mn:0000091F                 mov     eax, [ebp+var_4]
.text$mn:00000922                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000928                 mov     eax, [ebp+var_4]
.text$mn:0000092B                 mov     esp, ebp
.text$mn:0000092D                 pop     ebp
.text$mn:0000092E                 retn
.text$mn:0000092E ??0error_category@std@@QAE@XZ endp
.text$mn:0000092E
.text$mn:0000092E ; ---------------------------------------------------------------------------
.text$mn:0000092F                 align 10h
.text$mn:0000092F _text$mn        ends
.text$mn:0000092F
.text$mn:00000930 ; ===========================================================================
.text$mn:00000930
.text$mn:00000930 ; Segment type: Pure code
.text$mn:00000930 ; Segment permissions: Read/Execute
.text$mn:00000930 _text$mn        segment para public 'CODE' use32
.text$mn:00000930                 assume cs:_text$mn
.text$mn:00000930                 ;org 930h
.text$mn:00000930 ; COMDAT (pick any)
.text$mn:00000930                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000930
.text$mn:00000930 ; =============== S U B R O U T I N E =======================================
.text$mn:00000930
.text$mn:00000930 ; Attributes: bp-based frame
.text$mn:00000930
.text$mn:00000930 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000930                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000930 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000930                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000930                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000930
.text$mn:00000930 var_4           = dword ptr -4
.text$mn:00000930 arg_0           = dword ptr  8
.text$mn:00000930 arg_4           = dword ptr  0Ch
.text$mn:00000930
.text$mn:00000930                 push    ebp
.text$mn:00000931                 mov     ebp, esp
.text$mn:00000933                 push    ecx
.text$mn:00000934                 mov     [ebp+var_4], ecx
.text$mn:00000937                 mov     eax, [ebp+var_4]
.text$mn:0000093A                 mov     ecx, [ebp+arg_0]
.text$mn:0000093D                 mov     [eax], ecx
.text$mn:0000093F                 mov     edx, [ebp+var_4]
.text$mn:00000942                 mov     eax, [ebp+arg_4]
.text$mn:00000945                 mov     [edx+4], eax
.text$mn:00000948                 mov     eax, [ebp+var_4]
.text$mn:0000094B                 mov     esp, ebp
.text$mn:0000094D                 pop     ebp
.text$mn:0000094E                 retn    8
.text$mn:0000094E ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000094E
.text$mn:0000094E ; ---------------------------------------------------------------------------
.text$mn:00000951                 align 4
.text$mn:00000951 _text$mn        ends
.text$mn:00000951
.text$mn:00000954 ; ===========================================================================
.text$mn:00000954
.text$mn:00000954 ; Segment type: Pure code
.text$mn:00000954 ; Segment permissions: Read/Execute
.text$mn:00000954 _text$mn        segment para public 'CODE' use32
.text$mn:00000954                 assume cs:_text$mn
.text$mn:00000954                 ;org 954h
.text$mn:00000954 ; COMDAT (pick any)
.text$mn:00000954                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000954
.text$mn:00000954 ; =============== S U B R O U T I N E =======================================
.text$mn:00000954
.text$mn:00000954 ; Attributes: bp-based frame
.text$mn:00000954
.text$mn:00000954 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00000954                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00000954 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00000954                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00000954
.text$mn:00000954 var_4           = dword ptr -4
.text$mn:00000954 arg_0           = dword ptr  8
.text$mn:00000954
.text$mn:00000954                 push    ebp
.text$mn:00000955                 mov     ebp, esp
.text$mn:00000957                 push    ecx
.text$mn:00000958                 mov     [ebp+var_4], ecx
.text$mn:0000095B                 mov     eax, [ebp+var_4]
.text$mn:0000095E                 mov     ecx, [ebp+arg_0]
.text$mn:00000961                 mov     [eax], ecx
.text$mn:00000963                 mov     eax, [ebp+var_4]
.text$mn:00000966                 mov     esp, ebp
.text$mn:00000968                 pop     ebp
.text$mn:00000969                 retn    4
.text$mn:00000969 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00000969
.text$mn:00000969 _text$mn        ends
.text$mn:00000969
.text$mn:0000096C ; ===========================================================================
.text$mn:0000096C
.text$mn:0000096C ; Segment type: Pure code
.text$mn:0000096C ; Segment permissions: Read/Execute
.text$mn:0000096C _text$mn        segment para public 'CODE' use32
.text$mn:0000096C                 assume cs:_text$mn
.text$mn:0000096C                 ;org 96Ch
.text$mn:0000096C ; COMDAT (pick any)
.text$mn:0000096C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000096C
.text$mn:0000096C ; =============== S U B R O U T I N E =======================================
.text$mn:0000096C
.text$mn:0000096C ; Attributes: bp-based frame
.text$mn:0000096C
.text$mn:0000096C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:0000096C                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000096C ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000096C                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:0000096C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:0000096C
.text$mn:0000096C var_10          = dword ptr -10h
.text$mn:0000096C var_C           = dword ptr -0Ch
.text$mn:0000096C var_4           = dword ptr -4
.text$mn:0000096C
.text$mn:0000096C                 push    ebp
.text$mn:0000096D                 mov     ebp, esp
.text$mn:0000096F                 push    0FFFFFFFFh
.text$mn:00000971                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000976                 mov     eax, large fs:0
.text$mn:0000097C                 push    eax
.text$mn:0000097D                 push    ecx
.text$mn:0000097E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000983                 xor     eax, ebp
.text$mn:00000985                 push    eax
.text$mn:00000986                 lea     eax, [ebp+var_C]
.text$mn:00000989                 mov     large fs:0, eax
.text$mn:0000098F                 mov     [ebp+var_10], ecx
.text$mn:00000992                 mov     [ebp+var_4], 0
.text$mn:00000999                 mov     ecx, [ebp+var_10]
.text$mn:0000099C                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:000009A1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000009A8                 mov     ecx, [ebp+var_10]
.text$mn:000009AB                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:000009B0                 mov     ecx, [ebp+var_C]
.text$mn:000009B3                 mov     large fs:0, ecx
.text$mn:000009BA                 pop     ecx
.text$mn:000009BB                 mov     esp, ebp
.text$mn:000009BD                 pop     ebp
.text$mn:000009BE                 retn
.text$mn:000009BE ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:000009BE
.text$mn:000009BE ; ---------------------------------------------------------------------------
.text$mn:000009BF                 align 10h
.text$mn:000009BF _text$mn        ends
.text$mn:000009BF
.text$x:000009C0 ; ===========================================================================
.text$x:000009C0
.text$x:000009C0 ; Segment type: Pure code
.text$x:000009C0 ; Segment permissions: Read/Execute
.text$x:000009C0 _text$x         segment para public 'CODE' use32
.text$x:000009C0                 assume cs:_text$x
.text$x:000009C0                 ;org 9C0h
.text$x:000009C0 ; COMDAT (pick associative to section at 96C)
.text$x:000009C0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000009C0
.text$x:000009C0 ; =============== S U B R O U T I N E =======================================
.text$x:000009C0
.text$x:000009C0
.text$x:000009C0 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000009C0                                         ; DATA XREF: .xdata$x:000022FCo
.text$x:000009C0                 mov     ecx, [ebp-10h]
.text$x:000009C3                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000009C3 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000009C3
.text$x:000009C8
.text$x:000009C8 ; =============== S U B R O U T I N E =======================================
.text$x:000009C8
.text$x:000009C8
.text$x:000009C8 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:000009C8                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:000009C8
.text$x:000009C8 arg_4           = dword ptr  8
.text$x:000009C8
.text$x:000009C8                 mov     edx, [esp+arg_4]
.text$x:000009CC                 lea     eax, [edx+0Ch]
.text$x:000009CF                 mov     ecx, [edx-8]
.text$x:000009D2                 xor     ecx, eax
.text$x:000009D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000009D9                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:000009DE                 jmp     ___CxxFrameHandler3
.text$x:000009DE __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000009DE
.text$x:000009DE ; ---------------------------------------------------------------------------
.text$x:000009E3                 align 4
.text$x:000009E3 _text$x         ends
.text$x:000009E3
.text$mn:000009E4 ; ===========================================================================
.text$mn:000009E4
.text$mn:000009E4 ; Segment type: Pure code
.text$mn:000009E4 ; Segment permissions: Read/Execute
.text$mn:000009E4 _text$mn        segment para public 'CODE' use32
.text$mn:000009E4                 assume cs:_text$mn
.text$mn:000009E4                 ;org 9E4h
.text$mn:000009E4 ; COMDAT (pick any)
.text$mn:000009E4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009E4
.text$mn:000009E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000009E4
.text$mn:000009E4 ; Attributes: bp-based frame
.text$mn:000009E4
.text$mn:000009E4 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000009E4                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000009E4 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000009E4                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:000009E4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:000009E4
.text$mn:000009E4 var_10          = dword ptr -10h
.text$mn:000009E4 var_C           = dword ptr -0Ch
.text$mn:000009E4 var_4           = dword ptr -4
.text$mn:000009E4
.text$mn:000009E4                 push    ebp
.text$mn:000009E5                 mov     ebp, esp
.text$mn:000009E7                 push    0FFFFFFFFh
.text$mn:000009E9                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000009EE                 mov     eax, large fs:0
.text$mn:000009F4                 push    eax
.text$mn:000009F5                 push    ecx
.text$mn:000009F6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009FB                 xor     eax, ebp
.text$mn:000009FD                 push    eax
.text$mn:000009FE                 lea     eax, [ebp+var_C]
.text$mn:00000A01                 mov     large fs:0, eax
.text$mn:00000A07                 mov     [ebp+var_10], ecx
.text$mn:00000A0A                 mov     [ebp+var_4], 0
.text$mn:00000A11                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A18                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000A1B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00000A20                 mov     ecx, [ebp+var_C]
.text$mn:00000A23                 mov     large fs:0, ecx
.text$mn:00000A2A                 pop     ecx
.text$mn:00000A2B                 mov     esp, ebp
.text$mn:00000A2D                 pop     ebp
.text$mn:00000A2E                 retn
.text$mn:00000A2E ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000A2E
.text$mn:00000A2E ; ---------------------------------------------------------------------------
.text$mn:00000A2F                 align 10h
.text$mn:00000A2F _text$mn        ends
.text$mn:00000A2F
.text$x:00000A30 ; ===========================================================================
.text$x:00000A30
.text$x:00000A30 ; Segment type: Pure code
.text$x:00000A30 ; Segment permissions: Read/Execute
.text$x:00000A30 _text$x         segment para public 'CODE' use32
.text$x:00000A30                 assume cs:_text$x
.text$x:00000A30                 ;org 0A30h
.text$x:00000A30 ; COMDAT (pick associative to section at 9E4)
.text$x:00000A30                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000A30
.text$x:00000A30 ; =============== S U B R O U T I N E =======================================
.text$x:00000A30
.text$x:00000A30
.text$x:00000A30 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000A30                                         ; DATA XREF: .xdata$x:000022A4o
.text$x:00000A30                 mov     ecx, [ebp-10h]  ; this
.text$x:00000A33                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000A33 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000A33
.text$x:00000A38
.text$x:00000A38 ; =============== S U B R O U T I N E =======================================
.text$x:00000A38
.text$x:00000A38
.text$x:00000A38 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000A38                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000A38
.text$x:00000A38 arg_4           = dword ptr  8
.text$x:00000A38
.text$x:00000A38                 mov     edx, [esp+arg_4]
.text$x:00000A3C                 lea     eax, [edx+0Ch]
.text$x:00000A3F                 mov     ecx, [edx-8]
.text$x:00000A42                 xor     ecx, eax
.text$x:00000A44                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A49                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000A4E                 jmp     ___CxxFrameHandler3
.text$x:00000A4E __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000A4E
.text$x:00000A4E ; ---------------------------------------------------------------------------
.text$x:00000A53                 align 4
.text$x:00000A53 _text$x         ends
.text$x:00000A53
.text$mn:00000A54 ; ===========================================================================
.text$mn:00000A54
.text$mn:00000A54 ; Segment type: Pure code
.text$mn:00000A54 ; Segment permissions: Read/Execute
.text$mn:00000A54 _text$mn        segment para public 'CODE' use32
.text$mn:00000A54                 assume cs:_text$mn
.text$mn:00000A54                 ;org 0A54h
.text$mn:00000A54 ; COMDAT (pick any)
.text$mn:00000A54                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000A54
.text$mn:00000A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A54
.text$mn:00000A54 ; Attributes: bp-based frame
.text$mn:00000A54
.text$mn:00000A54 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000A54                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000A54 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000A54                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00000A54                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00000A54
.text$mn:00000A54 var_10          = dword ptr -10h
.text$mn:00000A54 var_C           = dword ptr -0Ch
.text$mn:00000A54 var_4           = dword ptr -4
.text$mn:00000A54
.text$mn:00000A54                 push    ebp
.text$mn:00000A55                 mov     ebp, esp
.text$mn:00000A57                 push    0FFFFFFFFh
.text$mn:00000A59                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000A5E                 mov     eax, large fs:0
.text$mn:00000A64                 push    eax
.text$mn:00000A65                 push    ecx
.text$mn:00000A66                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A6B                 xor     eax, ebp
.text$mn:00000A6D                 push    eax
.text$mn:00000A6E                 lea     eax, [ebp+var_C]
.text$mn:00000A71                 mov     large fs:0, eax
.text$mn:00000A77                 mov     [ebp+var_10], ecx
.text$mn:00000A7A                 mov     [ebp+var_4], 0
.text$mn:00000A81                 push    0               ; Size
.text$mn:00000A83                 push    1               ; char
.text$mn:00000A85                 mov     ecx, [ebp+var_10]
.text$mn:00000A88                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000A8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A94                 mov     ecx, [ebp+var_10]
.text$mn:00000A97                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000A9C                 mov     ecx, [ebp+var_C]
.text$mn:00000A9F                 mov     large fs:0, ecx
.text$mn:00000AA6                 pop     ecx
.text$mn:00000AA7                 mov     esp, ebp
.text$mn:00000AA9                 pop     ebp
.text$mn:00000AAA                 retn
.text$mn:00000AAA ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000AAA
.text$mn:00000AAA ; ---------------------------------------------------------------------------
.text$mn:00000AAB                 align 4
.text$mn:00000AAB _text$mn        ends
.text$mn:00000AAB
.text$x:00000AAC ; ===========================================================================
.text$x:00000AAC
.text$x:00000AAC ; Segment type: Pure code
.text$x:00000AAC ; Segment permissions: Read/Execute
.text$x:00000AAC _text$x         segment para public 'CODE' use32
.text$x:00000AAC                 assume cs:_text$x
.text$x:00000AAC                 ;org 0AACh
.text$x:00000AAC ; COMDAT (pick associative to section at A54)
.text$x:00000AAC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000AAC
.text$x:00000AAC ; =============== S U B R O U T I N E =======================================
.text$x:00000AAC
.text$x:00000AAC
.text$x:00000AAC __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000AAC                                         ; DATA XREF: .xdata$x:00002354o
.text$x:00000AAC                 mov     ecx, [ebp-10h]
.text$x:00000AAF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000AAF __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000AAF
.text$x:00000AB4
.text$x:00000AB4 ; =============== S U B R O U T I N E =======================================
.text$x:00000AB4
.text$x:00000AB4
.text$x:00000AB4 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00000AB4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00000AB4
.text$x:00000AB4 arg_4           = dword ptr  8
.text$x:00000AB4
.text$x:00000AB4                 mov     edx, [esp+arg_4]
.text$x:00000AB8                 lea     eax, [edx+0Ch]
.text$x:00000ABB                 mov     ecx, [edx-8]
.text$x:00000ABE                 xor     ecx, eax
.text$x:00000AC0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000AC5                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000ACA                 jmp     ___CxxFrameHandler3
.text$x:00000ACA __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000ACA
.text$x:00000ACA ; ---------------------------------------------------------------------------
.text$x:00000ACF                 align 10h
.text$x:00000ACF _text$x         ends
.text$x:00000ACF
.text$mn:00000AD0 ; ===========================================================================
.text$mn:00000AD0
.text$mn:00000AD0 ; Segment type: Pure code
.text$mn:00000AD0 ; Segment permissions: Read/Execute
.text$mn:00000AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00000AD0                 assume cs:_text$mn
.text$mn:00000AD0                 ;org 0AD0h
.text$mn:00000AD0 ; COMDAT (pick any)
.text$mn:00000AD0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000AD0
.text$mn:00000AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AD0
.text$mn:00000AD0 ; Attributes: bp-based frame
.text$mn:00000AD0
.text$mn:00000AD0 ; _DWORD __thiscall SizeableDlg::~SizeableDlg(SizeableDlg *__hidden this)
.text$mn:00000AD0                 public ??1SizeableDlg@@UAE@XZ
.text$mn:00000AD0 ??1SizeableDlg@@UAE@XZ proc near        ; CODE XREF: SizeableDlg::`scalar deleting destructor'(uint)+Ap
.text$mn:00000AD0
.text$mn:00000AD0 var_10          = dword ptr -10h
.text$mn:00000AD0 var_C           = dword ptr -0Ch
.text$mn:00000AD0 var_4           = dword ptr -4
.text$mn:00000AD0
.text$mn:00000AD0                 push    ebp
.text$mn:00000AD1                 mov     ebp, esp
.text$mn:00000AD3                 push    0FFFFFFFFh
.text$mn:00000AD5                 push    offset __ehhandler$??1SizeableDlg@@UAE@XZ
.text$mn:00000ADA                 mov     eax, large fs:0
.text$mn:00000AE0                 push    eax
.text$mn:00000AE1                 push    ecx
.text$mn:00000AE2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AE7                 xor     eax, ebp
.text$mn:00000AE9                 push    eax
.text$mn:00000AEA                 lea     eax, [ebp+var_C]
.text$mn:00000AED                 mov     large fs:0, eax
.text$mn:00000AF3                 mov     [ebp+var_10], ecx
.text$mn:00000AF6                 mov     [ebp+var_4], 1
.text$mn:00000AFD                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000B01                 mov     ecx, [ebp+var_10]
.text$mn:00000B04                 add     ecx, 20h ; ' '  ; this
.text$mn:00000B07                 call    ??1CWinMgr@@UAE@XZ ; CWinMgr::~CWinMgr(void)
.text$mn:00000B0C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B13                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B16                 call    ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$mn:00000B1B                 mov     ecx, [ebp+var_C]
.text$mn:00000B1E                 mov     large fs:0, ecx
.text$mn:00000B25                 pop     ecx
.text$mn:00000B26                 mov     esp, ebp
.text$mn:00000B28                 pop     ebp
.text$mn:00000B29                 retn
.text$mn:00000B29 ??1SizeableDlg@@UAE@XZ endp
.text$mn:00000B29
.text$mn:00000B29 ; ---------------------------------------------------------------------------
.text$mn:00000B2A                 align 4
.text$mn:00000B2A _text$mn        ends
.text$mn:00000B2A
.text$x:00000B2C ; ===========================================================================
.text$x:00000B2C
.text$x:00000B2C ; Segment type: Pure code
.text$x:00000B2C ; Segment permissions: Read/Execute
.text$x:00000B2C _text$x         segment para public 'CODE' use32
.text$x:00000B2C                 assume cs:_text$x
.text$x:00000B2C                 ;org 0B2Ch
.text$x:00000B2C ; COMDAT (pick associative to section at AD0)
.text$x:00000B2C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000B2C
.text$x:00000B2C ; =============== S U B R O U T I N E =======================================
.text$x:00000B2C
.text$x:00000B2C
.text$x:00000B2C __unwindfunclet$??1SizeableDlg@@UAE@XZ$0 proc near
.text$x:00000B2C                                         ; DATA XREF: .xdata$x:00002218o
.text$x:00000B2C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000B2F                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:00000B2F __unwindfunclet$??1SizeableDlg@@UAE@XZ$0 endp
.text$x:00000B2F
.text$x:00000B34
.text$x:00000B34 ; =============== S U B R O U T I N E =======================================
.text$x:00000B34
.text$x:00000B34
.text$x:00000B34 __unwindfunclet$??1SizeableDlg@@UAE@XZ$1 proc near
.text$x:00000B34                                         ; DATA XREF: .xdata$x:00002220o
.text$x:00000B34                 mov     ecx, [ebp-10h]
.text$x:00000B37                 add     ecx, 20h ; ' '  ; this
.text$x:00000B3A                 jmp     ??1CWinMgr@@UAE@XZ ; CWinMgr::~CWinMgr(void)
.text$x:00000B3A __unwindfunclet$??1SizeableDlg@@UAE@XZ$1 endp
.text$x:00000B3A
.text$x:00000B3F
.text$x:00000B3F ; =============== S U B R O U T I N E =======================================
.text$x:00000B3F
.text$x:00000B3F
.text$x:00000B3F __ehhandler$??1SizeableDlg@@UAE@XZ proc near
.text$x:00000B3F                                         ; DATA XREF: SizeableDlg::~SizeableDlg(void)+5o
.text$x:00000B3F
.text$x:00000B3F arg_4           = dword ptr  8
.text$x:00000B3F
.text$x:00000B3F                 mov     edx, [esp+arg_4]
.text$x:00000B43                 lea     eax, [edx+0Ch]
.text$x:00000B46                 mov     ecx, [edx-8]
.text$x:00000B49                 xor     ecx, eax
.text$x:00000B4B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B50                 mov     eax, offset __ehfuncinfo$??1SizeableDlg@@UAE@XZ
.text$x:00000B55                 jmp     ___CxxFrameHandler3
.text$x:00000B55 __ehhandler$??1SizeableDlg@@UAE@XZ endp
.text$x:00000B55
.text$x:00000B55 ; ---------------------------------------------------------------------------
.text$x:00000B5A                 align 4
.text$x:00000B5A _text$x         ends
.text$x:00000B5A
.text$mn:00000B5C ; ===========================================================================
.text$mn:00000B5C
.text$mn:00000B5C ; Segment type: Pure code
.text$mn:00000B5C ; Segment permissions: Read/Execute
.text$mn:00000B5C _text$mn        segment para public 'CODE' use32
.text$mn:00000B5C                 assume cs:_text$mn
.text$mn:00000B5C                 ;org 0B5Ch
.text$mn:00000B5C ; COMDAT (pick any)
.text$mn:00000B5C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000B5C
.text$mn:00000B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B5C
.text$mn:00000B5C ; Attributes: bp-based frame
.text$mn:00000B5C
.text$mn:00000B5C ; _DWORD __thiscall StaticDialog::~StaticDialog(StaticDialog *__hidden this)
.text$mn:00000B5C                 public ??1StaticDialog@@UAE@XZ
.text$mn:00000B5C ??1StaticDialog@@UAE@XZ proc near       ; CODE XREF: __unwindfunclet$??0SizeableDlg@@QAE@PAVWINRECT@@@Z$0+3j
.text$mn:00000B5C                                         ; SizeableDlg::~SizeableDlg(void)+46p ...
.text$mn:00000B5C
.text$mn:00000B5C var_10          = dword ptr -10h
.text$mn:00000B5C var_C           = dword ptr -0Ch
.text$mn:00000B5C var_4           = dword ptr -4
.text$mn:00000B5C
.text$mn:00000B5C                 push    ebp
.text$mn:00000B5D                 mov     ebp, esp
.text$mn:00000B5F                 push    0FFFFFFFFh
.text$mn:00000B61                 push    offset __ehhandler$??1StaticDialog@@UAE@XZ
.text$mn:00000B66                 mov     eax, large fs:0
.text$mn:00000B6C                 push    eax
.text$mn:00000B6D                 push    ecx
.text$mn:00000B6E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B73                 xor     eax, ebp
.text$mn:00000B75                 push    eax
.text$mn:00000B76                 lea     eax, [ebp+var_C]
.text$mn:00000B79                 mov     large fs:0, eax
.text$mn:00000B7F                 mov     [ebp+var_10], ecx
.text$mn:00000B82                 mov     eax, [ebp+var_10]
.text$mn:00000B85                 mov     dword ptr [eax], offset ??_7StaticDialog@@6B@ ; const StaticDialog::`vftable'
.text$mn:00000B8B                 mov     [ebp+var_4], 0
.text$mn:00000B92                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B95                 call    ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.text$mn:00000B9A                 movzx   ecx, al
.text$mn:00000B9D                 test    ecx, ecx
.text$mn:00000B9F                 jz      short loc_BBA
.text$mn:00000BA1                 push    0               ; dwNewLong
.text$mn:00000BA3                 push    0FFFFFFEBh      ; nIndex
.text$mn:00000BA5                 mov     edx, [ebp+var_10]
.text$mn:00000BA8                 mov     eax, [edx+0Ch]
.text$mn:00000BAB                 push    eax             ; hWnd
.text$mn:00000BAC                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000BB2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000BB5                 call    ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.text$mn:00000BBA
.text$mn:00000BBA loc_BBA:                                ; CODE XREF: StaticDialog::~StaticDialog(void)+43j
.text$mn:00000BBA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BC1                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000BC4                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:00000BC9                 mov     ecx, [ebp+var_C]
.text$mn:00000BCC                 mov     large fs:0, ecx
.text$mn:00000BD3                 pop     ecx
.text$mn:00000BD4                 mov     esp, ebp
.text$mn:00000BD6                 pop     ebp
.text$mn:00000BD7                 retn
.text$mn:00000BD7 ??1StaticDialog@@UAE@XZ endp
.text$mn:00000BD7
.text$mn:00000BD7 _text$mn        ends
.text$mn:00000BD7
.text$x:00000BD8 ; ===========================================================================
.text$x:00000BD8
.text$x:00000BD8 ; Segment type: Pure code
.text$x:00000BD8 ; Segment permissions: Read/Execute
.text$x:00000BD8 _text$x         segment para public 'CODE' use32
.text$x:00000BD8                 assume cs:_text$x
.text$x:00000BD8                 ;org 0BD8h
.text$x:00000BD8 ; COMDAT (pick associative to section at B5C)
.text$x:00000BD8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000BD8
.text$x:00000BD8 ; =============== S U B R O U T I N E =======================================
.text$x:00000BD8
.text$x:00000BD8
.text$x:00000BD8 __unwindfunclet$??1StaticDialog@@UAE@XZ$0 proc near
.text$x:00000BD8                                         ; DATA XREF: .xdata$x:000021B8o
.text$x:00000BD8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000BDB                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:00000BDB __unwindfunclet$??1StaticDialog@@UAE@XZ$0 endp
.text$x:00000BDB
.text$x:00000BE0
.text$x:00000BE0 ; =============== S U B R O U T I N E =======================================
.text$x:00000BE0
.text$x:00000BE0
.text$x:00000BE0 __ehhandler$??1StaticDialog@@UAE@XZ proc near
.text$x:00000BE0                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+5o
.text$x:00000BE0
.text$x:00000BE0 arg_4           = dword ptr  8
.text$x:00000BE0
.text$x:00000BE0                 mov     edx, [esp+arg_4]
.text$x:00000BE4                 lea     eax, [edx+0Ch]
.text$x:00000BE7                 mov     ecx, [edx-8]
.text$x:00000BEA                 xor     ecx, eax
.text$x:00000BEC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000BF1                 mov     eax, offset __ehfuncinfo$??1StaticDialog@@UAE@XZ
.text$x:00000BF6                 jmp     ___CxxFrameHandler3
.text$x:00000BF6 __ehhandler$??1StaticDialog@@UAE@XZ endp
.text$x:00000BF6
.text$x:00000BF6 ; ---------------------------------------------------------------------------
.text$x:00000BFB                 align 4
.text$x:00000BFB _text$x         ends
.text$x:00000BFB
.text$mn:00000BFC ; ===========================================================================
.text$mn:00000BFC
.text$mn:00000BFC ; Segment type: Pure code
.text$mn:00000BFC ; Segment permissions: Read/Execute
.text$mn:00000BFC _text$mn        segment para public 'CODE' use32
.text$mn:00000BFC                 assume cs:_text$mn
.text$mn:00000BFC                 ;org 0BFCh
.text$mn:00000BFC ; COMDAT (pick any)
.text$mn:00000BFC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BFC
.text$mn:00000BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00000BFC
.text$mn:00000BFC ; Attributes: bp-based frame
.text$mn:00000BFC
.text$mn:00000BFC ; _DWORD __thiscall Window::~Window(Window *__hidden this)
.text$mn:00000BFC                 public ??1Window@@UAE@XZ
.text$mn:00000BFC ??1Window@@UAE@XZ proc near             ; CODE XREF: __unwindfunclet$??0StaticDialog@@QAE@XZ$0+3j
.text$mn:00000BFC                                         ; StaticDialog::~StaticDialog(void)+68p ...
.text$mn:00000BFC
.text$mn:00000BFC var_4           = dword ptr -4
.text$mn:00000BFC
.text$mn:00000BFC                 push    ebp
.text$mn:00000BFD                 mov     ebp, esp
.text$mn:00000BFF                 push    ecx
.text$mn:00000C00                 mov     [ebp+var_4], ecx
.text$mn:00000C03                 mov     eax, [ebp+var_4]
.text$mn:00000C06                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00000C0C                 mov     esp, ebp
.text$mn:00000C0E                 pop     ebp
.text$mn:00000C0F                 retn
.text$mn:00000C0F ??1Window@@UAE@XZ endp
.text$mn:00000C0F
.text$mn:00000C0F _text$mn        ends
.text$mn:00000C0F
.text$mn:00000C10 ; ===========================================================================
.text$mn:00000C10
.text$mn:00000C10 ; Segment type: Pure code
.text$mn:00000C10 ; Segment permissions: Read/Execute
.text$mn:00000C10 _text$mn        segment para public 'CODE' use32
.text$mn:00000C10                 assume cs:_text$mn
.text$mn:00000C10                 ;org 0C10h
.text$mn:00000C10 ; COMDAT (pick any)
.text$mn:00000C10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C10
.text$mn:00000C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C10
.text$mn:00000C10 ; Attributes: bp-based frame
.text$mn:00000C10
.text$mn:00000C10 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000C10                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000C10 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000C10                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000C10                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000C10
.text$mn:00000C10 var_4           = dword ptr -4
.text$mn:00000C10
.text$mn:00000C10                 push    ebp
.text$mn:00000C11                 mov     ebp, esp
.text$mn:00000C13                 push    ecx
.text$mn:00000C14                 mov     [ebp+var_4], ecx
.text$mn:00000C17                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000C1A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000C1F                 mov     esp, ebp
.text$mn:00000C21                 pop     ebp
.text$mn:00000C22                 retn
.text$mn:00000C22 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00000C22
.text$mn:00000C22 ; ---------------------------------------------------------------------------
.text$mn:00000C23                 align 4
.text$mn:00000C23 _text$mn        ends
.text$mn:00000C23
.text$mn:00000C24 ; ===========================================================================
.text$mn:00000C24
.text$mn:00000C24 ; Segment type: Pure code
.text$mn:00000C24 ; Segment permissions: Read/Execute
.text$mn:00000C24 _text$mn        segment para public 'CODE' use32
.text$mn:00000C24                 assume cs:_text$mn
.text$mn:00000C24                 ;org 0C24h
.text$mn:00000C24 ; COMDAT (pick any)
.text$mn:00000C24                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C24
.text$mn:00000C24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C24
.text$mn:00000C24 ; Attributes: bp-based frame
.text$mn:00000C24
.text$mn:00000C24 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000C24                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000C24 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000C24                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000C24                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000C24
.text$mn:00000C24 var_10          = dword ptr -10h
.text$mn:00000C24 var_C           = dword ptr -0Ch
.text$mn:00000C24 var_4           = dword ptr -4
.text$mn:00000C24
.text$mn:00000C24                 push    ebp
.text$mn:00000C25                 mov     ebp, esp
.text$mn:00000C27                 push    0FFFFFFFFh
.text$mn:00000C29                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000C2E                 mov     eax, large fs:0
.text$mn:00000C34                 push    eax
.text$mn:00000C35                 push    ecx
.text$mn:00000C36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C3B                 xor     eax, ebp
.text$mn:00000C3D                 push    eax
.text$mn:00000C3E                 lea     eax, [ebp+var_C]
.text$mn:00000C41                 mov     large fs:0, eax
.text$mn:00000C47                 mov     [ebp+var_10], ecx
.text$mn:00000C4A                 mov     [ebp+var_4], 0
.text$mn:00000C51                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C58                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000C5B                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000C60                 mov     ecx, [ebp+var_C]
.text$mn:00000C63                 mov     large fs:0, ecx
.text$mn:00000C6A                 pop     ecx
.text$mn:00000C6B                 mov     esp, ebp
.text$mn:00000C6D                 pop     ebp
.text$mn:00000C6E                 retn
.text$mn:00000C6E ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00000C6E
.text$mn:00000C6E ; ---------------------------------------------------------------------------
.text$mn:00000C6F                 align 10h
.text$mn:00000C6F _text$mn        ends
.text$mn:00000C6F
.text$x:00000C70 ; ===========================================================================
.text$x:00000C70
.text$x:00000C70 ; Segment type: Pure code
.text$x:00000C70 ; Segment permissions: Read/Execute
.text$x:00000C70 _text$x         segment para public 'CODE' use32
.text$x:00000C70                 assume cs:_text$x
.text$x:00000C70                 ;org 0C70h
.text$x:00000C70 ; COMDAT (pick associative to section at C24)
.text$x:00000C70                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000C70
.text$x:00000C70 ; =============== S U B R O U T I N E =======================================
.text$x:00000C70
.text$x:00000C70
.text$x:00000C70 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00000C70                                         ; DATA XREF: .xdata$x:00002464o
.text$x:00000C70                 mov     ecx, [ebp-10h]  ; this
.text$x:00000C73                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000C73 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00000C73
.text$x:00000C78
.text$x:00000C78 ; =============== S U B R O U T I N E =======================================
.text$x:00000C78
.text$x:00000C78
.text$x:00000C78 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00000C78                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00000C78
.text$x:00000C78 arg_4           = dword ptr  8
.text$x:00000C78
.text$x:00000C78                 mov     edx, [esp+arg_4]
.text$x:00000C7C                 lea     eax, [edx+0Ch]
.text$x:00000C7F                 mov     ecx, [edx-8]
.text$x:00000C82                 xor     ecx, eax
.text$x:00000C84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C89                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00000C8E                 jmp     ___CxxFrameHandler3
.text$x:00000C8E __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00000C8E
.text$x:00000C8E ; ---------------------------------------------------------------------------
.text$x:00000C93                 align 4
.text$x:00000C93 _text$x         ends
.text$x:00000C93
.text$mn:00000C94 ; ===========================================================================
.text$mn:00000C94
.text$mn:00000C94 ; Segment type: Pure code
.text$mn:00000C94 ; Segment permissions: Read/Execute
.text$mn:00000C94 _text$mn        segment para public 'CODE' use32
.text$mn:00000C94                 assume cs:_text$mn
.text$mn:00000C94                 ;org 0C94h
.text$mn:00000C94 ; COMDAT (pick any)
.text$mn:00000C94                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C94
.text$mn:00000C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C94
.text$mn:00000C94 ; Attributes: bp-based frame
.text$mn:00000C94
.text$mn:00000C94 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000C94                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000C94 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00000C94                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000C94                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000C94
.text$mn:00000C94 var_10          = dword ptr -10h
.text$mn:00000C94 var_C           = dword ptr -0Ch
.text$mn:00000C94 var_4           = dword ptr -4
.text$mn:00000C94
.text$mn:00000C94                 push    ebp
.text$mn:00000C95                 mov     ebp, esp
.text$mn:00000C97                 push    0FFFFFFFFh
.text$mn:00000C99                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000C9E                 mov     eax, large fs:0
.text$mn:00000CA4                 push    eax
.text$mn:00000CA5                 push    ecx
.text$mn:00000CA6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000CAB                 xor     eax, ebp
.text$mn:00000CAD                 push    eax
.text$mn:00000CAE                 lea     eax, [ebp+var_C]
.text$mn:00000CB1                 mov     large fs:0, eax
.text$mn:00000CB7                 mov     [ebp+var_10], ecx
.text$mn:00000CBA                 mov     [ebp+var_4], 0
.text$mn:00000CC1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000CC8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000CCB                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000CD0                 mov     ecx, [ebp+var_C]
.text$mn:00000CD3                 mov     large fs:0, ecx
.text$mn:00000CDA                 pop     ecx
.text$mn:00000CDB                 mov     esp, ebp
.text$mn:00000CDD                 pop     ebp
.text$mn:00000CDE                 retn
.text$mn:00000CDE ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00000CDE
.text$mn:00000CDE ; ---------------------------------------------------------------------------
.text$mn:00000CDF                 align 10h
.text$mn:00000CDF _text$mn        ends
.text$mn:00000CDF
.text$x:00000CE0 ; ===========================================================================
.text$x:00000CE0
.text$x:00000CE0 ; Segment type: Pure code
.text$x:00000CE0 ; Segment permissions: Read/Execute
.text$x:00000CE0 _text$x         segment para public 'CODE' use32
.text$x:00000CE0                 assume cs:_text$x
.text$x:00000CE0                 ;org 0CE0h
.text$x:00000CE0 ; COMDAT (pick associative to section at C94)
.text$x:00000CE0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000CE0
.text$x:00000CE0 ; =============== S U B R O U T I N E =======================================
.text$x:00000CE0
.text$x:00000CE0
.text$x:00000CE0 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00000CE0                                         ; DATA XREF: .xdata$x:000024E8o
.text$x:00000CE0                 mov     ecx, [ebp-10h]  ; this
.text$x:00000CE3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000CE3 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00000CE3
.text$x:00000CE8
.text$x:00000CE8 ; =============== S U B R O U T I N E =======================================
.text$x:00000CE8
.text$x:00000CE8
.text$x:00000CE8 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00000CE8                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00000CE8
.text$x:00000CE8 arg_4           = dword ptr  8
.text$x:00000CE8
.text$x:00000CE8                 mov     edx, [esp+arg_4]
.text$x:00000CEC                 lea     eax, [edx+0Ch]
.text$x:00000CEF                 mov     ecx, [edx-8]
.text$x:00000CF2                 xor     ecx, eax
.text$x:00000CF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CF9                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00000CFE                 jmp     ___CxxFrameHandler3
.text$x:00000CFE __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00000CFE
.text$x:00000CFE ; ---------------------------------------------------------------------------
.text$x:00000D03                 align 4
.text$x:00000D03 _text$x         ends
.text$x:00000D03
.text$mn:00000D04 ; ===========================================================================
.text$mn:00000D04
.text$mn:00000D04 ; Segment type: Pure code
.text$mn:00000D04 ; Segment permissions: Read/Execute
.text$mn:00000D04 _text$mn        segment para public 'CODE' use32
.text$mn:00000D04                 assume cs:_text$mn
.text$mn:00000D04                 ;org 0D04h
.text$mn:00000D04 ; COMDAT (pick any)
.text$mn:00000D04                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D04
.text$mn:00000D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D04
.text$mn:00000D04 ; Attributes: bp-based frame
.text$mn:00000D04
.text$mn:00000D04 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000D04                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00000D04 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00000D04                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000D04                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000D04
.text$mn:00000D04 var_10          = dword ptr -10h
.text$mn:00000D04 var_C           = dword ptr -0Ch
.text$mn:00000D04 var_4           = dword ptr -4
.text$mn:00000D04
.text$mn:00000D04                 push    ebp
.text$mn:00000D05                 mov     ebp, esp
.text$mn:00000D07                 push    0FFFFFFFFh
.text$mn:00000D09                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00000D0E                 mov     eax, large fs:0
.text$mn:00000D14                 push    eax
.text$mn:00000D15                 push    ecx
.text$mn:00000D16                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D1B                 xor     eax, ebp
.text$mn:00000D1D                 push    eax
.text$mn:00000D1E                 lea     eax, [ebp+var_C]
.text$mn:00000D21                 mov     large fs:0, eax
.text$mn:00000D27                 mov     [ebp+var_10], ecx
.text$mn:00000D2A                 mov     [ebp+var_4], 0
.text$mn:00000D31                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D38                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000D3B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000D40                 mov     ecx, [ebp+var_C]
.text$mn:00000D43                 mov     large fs:0, ecx
.text$mn:00000D4A                 pop     ecx
.text$mn:00000D4B                 mov     esp, ebp
.text$mn:00000D4D                 pop     ebp
.text$mn:00000D4E                 retn
.text$mn:00000D4E ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00000D4E
.text$mn:00000D4E ; ---------------------------------------------------------------------------
.text$mn:00000D4F                 align 10h
.text$mn:00000D4F _text$mn        ends
.text$mn:00000D4F
.text$x:00000D50 ; ===========================================================================
.text$x:00000D50
.text$x:00000D50 ; Segment type: Pure code
.text$x:00000D50 ; Segment permissions: Read/Execute
.text$x:00000D50 _text$x         segment para public 'CODE' use32
.text$x:00000D50                 assume cs:_text$x
.text$x:00000D50                 ;org 0D50h
.text$x:00000D50 ; COMDAT (pick associative to section at D04)
.text$x:00000D50                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000D50
.text$x:00000D50 ; =============== S U B R O U T I N E =======================================
.text$x:00000D50
.text$x:00000D50
.text$x:00000D50 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00000D50                                         ; DATA XREF: .xdata$x:0000256Co
.text$x:00000D50                 mov     ecx, [ebp-10h]  ; this
.text$x:00000D53                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000D53 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00000D53
.text$x:00000D58
.text$x:00000D58 ; =============== S U B R O U T I N E =======================================
.text$x:00000D58
.text$x:00000D58
.text$x:00000D58 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00000D58                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00000D58
.text$x:00000D58 arg_4           = dword ptr  8
.text$x:00000D58
.text$x:00000D58                 mov     edx, [esp+arg_4]
.text$x:00000D5C                 lea     eax, [edx+0Ch]
.text$x:00000D5F                 mov     ecx, [edx-8]
.text$x:00000D62                 xor     ecx, eax
.text$x:00000D64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D69                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00000D6E                 jmp     ___CxxFrameHandler3
.text$x:00000D6E __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00000D6E
.text$x:00000D6E ; ---------------------------------------------------------------------------
.text$x:00000D73                 align 4
.text$x:00000D73 _text$x         ends
.text$x:00000D73
.text$mn:00000D74 ; ===========================================================================
.text$mn:00000D74
.text$mn:00000D74 ; Segment type: Pure code
.text$mn:00000D74 ; Segment permissions: Read/Execute
.text$mn:00000D74 _text$mn        segment para public 'CODE' use32
.text$mn:00000D74                 assume cs:_text$mn
.text$mn:00000D74                 ;org 0D74h
.text$mn:00000D74 ; COMDAT (pick any)
.text$mn:00000D74                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D74
.text$mn:00000D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D74
.text$mn:00000D74 ; Attributes: bp-based frame
.text$mn:00000D74
.text$mn:00000D74 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00000D74                 public ??1error_category@std@@UAE@XZ
.text$mn:00000D74 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00000D74                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00000D74
.text$mn:00000D74 var_4           = dword ptr -4
.text$mn:00000D74
.text$mn:00000D74                 push    ebp
.text$mn:00000D75                 mov     ebp, esp
.text$mn:00000D77                 push    ecx
.text$mn:00000D78                 mov     [ebp+var_4], ecx
.text$mn:00000D7B                 mov     eax, [ebp+var_4]
.text$mn:00000D7E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000D84                 mov     esp, ebp
.text$mn:00000D86                 pop     ebp
.text$mn:00000D87                 retn
.text$mn:00000D87 ??1error_category@std@@UAE@XZ endp
.text$mn:00000D87
.text$mn:00000D87 _text$mn        ends
.text$mn:00000D87
.text$mn:00000D88 ; ===========================================================================
.text$mn:00000D88
.text$mn:00000D88 ; Segment type: Pure code
.text$mn:00000D88 ; Segment permissions: Read/Execute
.text$mn:00000D88 _text$mn        segment para public 'CODE' use32
.text$mn:00000D88                 assume cs:_text$mn
.text$mn:00000D88                 ;org 0D88h
.text$mn:00000D88 ; COMDAT (pick any)
.text$mn:00000D88                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D88
.text$mn:00000D88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D88
.text$mn:00000D88 ; Attributes: bp-based frame
.text$mn:00000D88
.text$mn:00000D88 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00000D88                 public ??2@YAPAXIPAX@Z
.text$mn:00000D88 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00000D88                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00000D88
.text$mn:00000D88 arg_4           = dword ptr  0Ch
.text$mn:00000D88
.text$mn:00000D88                 push    ebp
.text$mn:00000D89                 mov     ebp, esp
.text$mn:00000D8B                 mov     eax, [ebp+arg_4]
.text$mn:00000D8E                 pop     ebp
.text$mn:00000D8F                 retn
.text$mn:00000D8F ??2@YAPAXIPAX@Z endp
.text$mn:00000D8F
.text$mn:00000D8F _text$mn        ends
.text$mn:00000D8F
.text$mn:00000D90 ; ===========================================================================
.text$mn:00000D90
.text$mn:00000D90 ; Segment type: Pure code
.text$mn:00000D90 ; Segment permissions: Read/Execute
.text$mn:00000D90 _text$mn        segment para public 'CODE' use32
.text$mn:00000D90                 assume cs:_text$mn
.text$mn:00000D90                 ;org 0D90h
.text$mn:00000D90 ; COMDAT (pick any)
.text$mn:00000D90                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D90
.text$mn:00000D90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D90
.text$mn:00000D90 ; Attributes: bp-based frame
.text$mn:00000D90
.text$mn:00000D90 ; void __cdecl operator delete(void *)
.text$mn:00000D90                 public ??3@YAXPAX0@Z
.text$mn:00000D90 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00000D90                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00000D90                 push    ebp
.text$mn:00000D91                 mov     ebp, esp
.text$mn:00000D93                 pop     ebp
.text$mn:00000D94                 retn
.text$mn:00000D94 ??3@YAXPAX0@Z   endp
.text$mn:00000D94
.text$mn:00000D94 ; ---------------------------------------------------------------------------
.text$mn:00000D95                 align 4
.text$mn:00000D95 _text$mn        ends
.text$mn:00000D95
.text$mn:00000D98 ; ===========================================================================
.text$mn:00000D98
.text$mn:00000D98 ; Segment type: Pure code
.text$mn:00000D98 ; Segment permissions: Read/Execute
.text$mn:00000D98 _text$mn        segment para public 'CODE' use32
.text$mn:00000D98                 assume cs:_text$mn
.text$mn:00000D98                 ;org 0D98h
.text$mn:00000D98 ; COMDAT (pick any)
.text$mn:00000D98                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D98
.text$mn:00000D98 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D98
.text$mn:00000D98 ; Attributes: bp-based frame
.text$mn:00000D98
.text$mn:00000D98 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00000D98                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00000D98 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00000D98                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00000D98                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00000D98
.text$mn:00000D98 var_8           = dword ptr -8
.text$mn:00000D98 var_4           = dword ptr -4
.text$mn:00000D98 arg_0           = dword ptr  8
.text$mn:00000D98
.text$mn:00000D98                 push    ebp
.text$mn:00000D99                 mov     ebp, esp
.text$mn:00000D9B                 sub     esp, 8
.text$mn:00000D9E                 mov     [ebp+var_8], ecx
.text$mn:00000DA1                 mov     eax, [ebp+var_8]
.text$mn:00000DA4                 cmp     eax, [ebp+arg_0]
.text$mn:00000DA7                 jnz     short loc_DB2
.text$mn:00000DA9                 mov     [ebp+var_4], 1
.text$mn:00000DB0                 jmp     short loc_DB9
.text$mn:00000DB2 ; ---------------------------------------------------------------------------
.text$mn:00000DB2
.text$mn:00000DB2 loc_DB2:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00000DB2                 mov     [ebp+var_4], 0
.text$mn:00000DB9
.text$mn:00000DB9 loc_DB9:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00000DB9                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000DBC                 mov     esp, ebp
.text$mn:00000DBE                 pop     ebp
.text$mn:00000DBF                 retn    4
.text$mn:00000DBF ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00000DBF
.text$mn:00000DBF ; ---------------------------------------------------------------------------
.text$mn:00000DC2                 align 4
.text$mn:00000DC2 _text$mn        ends
.text$mn:00000DC2
.text$mn:00000DC4 ; ===========================================================================
.text$mn:00000DC4
.text$mn:00000DC4 ; Segment type: Pure code
.text$mn:00000DC4 ; Segment permissions: Read/Execute
.text$mn:00000DC4 _text$mn        segment para public 'CODE' use32
.text$mn:00000DC4                 assume cs:_text$mn
.text$mn:00000DC4                 ;org 0DC4h
.text$mn:00000DC4 ; COMDAT (pick any)
.text$mn:00000DC4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000DC4
.text$mn:00000DC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DC4
.text$mn:00000DC4 ; Attributes: bp-based frame
.text$mn:00000DC4
.text$mn:00000DC4 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00000DC4                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00000DC4 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00000DC4                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00000DC4
.text$mn:00000DC4 var_8           = dword ptr -8
.text$mn:00000DC4 var_4           = dword ptr -4
.text$mn:00000DC4 arg_0           = dword ptr  8
.text$mn:00000DC4
.text$mn:00000DC4                 push    ebp
.text$mn:00000DC5                 mov     ebp, esp
.text$mn:00000DC7                 sub     esp, 8
.text$mn:00000DCA                 push    esi
.text$mn:00000DCB                 mov     [ebp+var_4], ecx
.text$mn:00000DCE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000DD1                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000DD6                 push    eax
.text$mn:00000DD7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DDA                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000DDF                 mov     ecx, eax
.text$mn:00000DE1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00000DE6                 movzx   eax, al
.text$mn:00000DE9                 test    eax, eax
.text$mn:00000DEB                 jz      short loc_E0C
.text$mn:00000DED                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DF0                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000DF5                 mov     esi, eax
.text$mn:00000DF7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000DFA                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000DFF                 cmp     esi, eax
.text$mn:00000E01                 jnz     short loc_E0C
.text$mn:00000E03                 mov     [ebp+var_8], 1
.text$mn:00000E0A                 jmp     short loc_E13
.text$mn:00000E0C ; ---------------------------------------------------------------------------
.text$mn:00000E0C
.text$mn:00000E0C loc_E0C:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00000E0C                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00000E0C                 mov     [ebp+var_8], 0
.text$mn:00000E13
.text$mn:00000E13 loc_E13:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00000E13                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000E16                 pop     esi
.text$mn:00000E17                 mov     esp, ebp
.text$mn:00000E19                 pop     ebp
.text$mn:00000E1A                 retn    4
.text$mn:00000E1A ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00000E1A
.text$mn:00000E1A ; ---------------------------------------------------------------------------
.text$mn:00000E1D                 align 10h
.text$mn:00000E1D _text$mn        ends
.text$mn:00000E1D
.text$mn:00000E20 ; ===========================================================================
.text$mn:00000E20
.text$mn:00000E20 ; Segment type: Pure code
.text$mn:00000E20 ; Segment permissions: Read/Execute
.text$mn:00000E20 _text$mn        segment para public 'CODE' use32
.text$mn:00000E20                 assume cs:_text$mn
.text$mn:00000E20                 ;org 0E20h
.text$mn:00000E20 ; COMDAT (pick any)
.text$mn:00000E20                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E20
.text$mn:00000E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E20
.text$mn:00000E20 ; Attributes: bp-based frame
.text$mn:00000E20
.text$mn:00000E20 ; public: virtual void * __thiscall SizeableDlg::`scalar deleting destructor'(unsigned int)
.text$mn:00000E20                 public ??_GSizeableDlg@@UAEPAXI@Z
.text$mn:00000E20 ??_GSizeableDlg@@UAEPAXI@Z proc near
.text$mn:00000E20
.text$mn:00000E20 var_4           = dword ptr -4
.text$mn:00000E20 arg_0           = dword ptr  8
.text$mn:00000E20
.text$mn:00000E20                 push    ebp
.text$mn:00000E21                 mov     ebp, esp
.text$mn:00000E23                 push    ecx
.text$mn:00000E24                 mov     [ebp+var_4], ecx
.text$mn:00000E27                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E2A                 call    ??1SizeableDlg@@UAE@XZ ; SizeableDlg::~SizeableDlg(void)
.text$mn:00000E2F                 mov     eax, [ebp+arg_0]
.text$mn:00000E32                 and     eax, 1
.text$mn:00000E35                 jz      short loc_E43
.text$mn:00000E37                 mov     ecx, [ebp+var_4]
.text$mn:00000E3A                 push    ecx             ; void *
.text$mn:00000E3B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000E40                 add     esp, 4
.text$mn:00000E43
.text$mn:00000E43 loc_E43:                                ; CODE XREF: SizeableDlg::`scalar deleting destructor'(uint)+15j
.text$mn:00000E43                 mov     eax, [ebp+var_4]
.text$mn:00000E46                 mov     esp, ebp
.text$mn:00000E48                 pop     ebp
.text$mn:00000E49                 retn    4
.text$mn:00000E49 ??_GSizeableDlg@@UAEPAXI@Z endp
.text$mn:00000E49
.text$mn:00000E49 _text$mn        ends
.text$mn:00000E49
.text$mn:00000E4C ; ===========================================================================
.text$mn:00000E4C
.text$mn:00000E4C ; Segment type: Pure code
.text$mn:00000E4C ; Segment permissions: Read/Execute
.text$mn:00000E4C _text$mn        segment para public 'CODE' use32
.text$mn:00000E4C                 assume cs:_text$mn
.text$mn:00000E4C                 ;org 0E4Ch
.text$mn:00000E4C ; COMDAT (pick any)
.text$mn:00000E4C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E4C
.text$mn:00000E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E4C
.text$mn:00000E4C ; Attributes: bp-based frame
.text$mn:00000E4C
.text$mn:00000E4C ; public: virtual void * __thiscall StaticDialog::`scalar deleting destructor'(unsigned int)
.text$mn:00000E4C                 public ??_GStaticDialog@@UAEPAXI@Z
.text$mn:00000E4C ??_GStaticDialog@@UAEPAXI@Z proc near
.text$mn:00000E4C
.text$mn:00000E4C var_4           = dword ptr -4
.text$mn:00000E4C arg_0           = dword ptr  8
.text$mn:00000E4C
.text$mn:00000E4C                 push    ebp
.text$mn:00000E4D                 mov     ebp, esp
.text$mn:00000E4F                 push    ecx
.text$mn:00000E50                 mov     [ebp+var_4], ecx
.text$mn:00000E53                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E56                 call    ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$mn:00000E5B                 mov     eax, [ebp+arg_0]
.text$mn:00000E5E                 and     eax, 1
.text$mn:00000E61                 jz      short loc_E6F
.text$mn:00000E63                 mov     ecx, [ebp+var_4]
.text$mn:00000E66                 push    ecx             ; void *
.text$mn:00000E67                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000E6C                 add     esp, 4
.text$mn:00000E6F
.text$mn:00000E6F loc_E6F:                                ; CODE XREF: StaticDialog::`scalar deleting destructor'(uint)+15j
.text$mn:00000E6F                 mov     eax, [ebp+var_4]
.text$mn:00000E72                 mov     esp, ebp
.text$mn:00000E74                 pop     ebp
.text$mn:00000E75                 retn    4
.text$mn:00000E75 ??_GStaticDialog@@UAEPAXI@Z endp
.text$mn:00000E75
.text$mn:00000E75 _text$mn        ends
.text$mn:00000E75
.text$mn:00000E78 ; ===========================================================================
.text$mn:00000E78
.text$mn:00000E78 ; Segment type: Pure code
.text$mn:00000E78 ; Segment permissions: Read/Execute
.text$mn:00000E78 _text$mn        segment para public 'CODE' use32
.text$mn:00000E78                 assume cs:_text$mn
.text$mn:00000E78                 ;org 0E78h
.text$mn:00000E78 ; COMDAT (pick any)
.text$mn:00000E78                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E78
.text$mn:00000E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E78
.text$mn:00000E78 ; Attributes: bp-based frame
.text$mn:00000E78
.text$mn:00000E78 ; public: virtual void * __thiscall Window::`scalar deleting destructor'(unsigned int)
.text$mn:00000E78                 public ??_GWindow@@UAEPAXI@Z
.text$mn:00000E78 ??_GWindow@@UAEPAXI@Z proc near
.text$mn:00000E78
.text$mn:00000E78 var_4           = dword ptr -4
.text$mn:00000E78 arg_0           = dword ptr  8
.text$mn:00000E78
.text$mn:00000E78                 push    ebp
.text$mn:00000E79                 mov     ebp, esp
.text$mn:00000E7B                 push    ecx
.text$mn:00000E7C                 mov     [ebp+var_4], ecx
.text$mn:00000E7F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E82                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:00000E87                 mov     eax, [ebp+arg_0]
.text$mn:00000E8A                 and     eax, 1
.text$mn:00000E8D                 jz      short loc_E9B
.text$mn:00000E8F                 mov     ecx, [ebp+var_4]
.text$mn:00000E92                 push    ecx             ; void *
.text$mn:00000E93                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000E98                 add     esp, 4
.text$mn:00000E9B
.text$mn:00000E9B loc_E9B:                                ; CODE XREF: Window::`scalar deleting destructor'(uint)+15j
.text$mn:00000E9B                 mov     eax, [ebp+var_4]
.text$mn:00000E9E                 mov     esp, ebp
.text$mn:00000EA0                 pop     ebp
.text$mn:00000EA1                 retn    4
.text$mn:00000EA1 ??_GWindow@@UAEPAXI@Z endp
.text$mn:00000EA1
.text$mn:00000EA1 _text$mn        ends
.text$mn:00000EA1
.text$mn:00000EA4 ; ===========================================================================
.text$mn:00000EA4
.text$mn:00000EA4 ; Segment type: Pure code
.text$mn:00000EA4 ; Segment permissions: Read/Execute
.text$mn:00000EA4 _text$mn        segment para public 'CODE' use32
.text$mn:00000EA4                 assume cs:_text$mn
.text$mn:00000EA4                 ;org 0EA4h
.text$mn:00000EA4 ; COMDAT (pick any)
.text$mn:00000EA4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000EA4
.text$mn:00000EA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EA4
.text$mn:00000EA4 ; Attributes: bp-based frame
.text$mn:00000EA4
.text$mn:00000EA4 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000EA4                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00000EA4 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000EA4
.text$mn:00000EA4 var_4           = dword ptr -4
.text$mn:00000EA4 arg_0           = dword ptr  8
.text$mn:00000EA4
.text$mn:00000EA4                 push    ebp
.text$mn:00000EA5                 mov     ebp, esp
.text$mn:00000EA7                 push    ecx
.text$mn:00000EA8                 mov     [ebp+var_4], ecx
.text$mn:00000EAB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000EAE                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000EB3                 mov     eax, [ebp+arg_0]
.text$mn:00000EB6                 and     eax, 1
.text$mn:00000EB9                 jz      short loc_EC7
.text$mn:00000EBB                 mov     ecx, [ebp+var_4]
.text$mn:00000EBE                 push    ecx             ; void *
.text$mn:00000EBF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000EC4                 add     esp, 4
.text$mn:00000EC7
.text$mn:00000EC7 loc_EC7:                                ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000EC7                 mov     eax, [ebp+var_4]
.text$mn:00000ECA                 mov     esp, ebp
.text$mn:00000ECC                 pop     ebp
.text$mn:00000ECD                 retn    4
.text$mn:00000ECD ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00000ECD
.text$mn:00000ECD _text$mn        ends
.text$mn:00000ECD
.text$mn:00000ED0 ; ===========================================================================
.text$mn:00000ED0
.text$mn:00000ED0 ; Segment type: Pure code
.text$mn:00000ED0 ; Segment permissions: Read/Execute
.text$mn:00000ED0 _text$mn        segment para public 'CODE' use32
.text$mn:00000ED0                 assume cs:_text$mn
.text$mn:00000ED0                 ;org 0ED0h
.text$mn:00000ED0 ; COMDAT (pick any)
.text$mn:00000ED0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000ED0
.text$mn:00000ED0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000ED0
.text$mn:00000ED0 ; Attributes: bp-based frame
.text$mn:00000ED0
.text$mn:00000ED0 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000ED0                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00000ED0 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000ED0
.text$mn:00000ED0 var_4           = dword ptr -4
.text$mn:00000ED0 arg_0           = dword ptr  8
.text$mn:00000ED0
.text$mn:00000ED0                 push    ebp
.text$mn:00000ED1                 mov     ebp, esp
.text$mn:00000ED3                 push    ecx
.text$mn:00000ED4                 mov     [ebp+var_4], ecx
.text$mn:00000ED7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000EDA                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00000EDF                 mov     eax, [ebp+arg_0]
.text$mn:00000EE2                 and     eax, 1
.text$mn:00000EE5                 jz      short loc_EF3
.text$mn:00000EE7                 mov     ecx, [ebp+var_4]
.text$mn:00000EEA                 push    ecx             ; void *
.text$mn:00000EEB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000EF0                 add     esp, 4
.text$mn:00000EF3
.text$mn:00000EF3 loc_EF3:                                ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000EF3                 mov     eax, [ebp+var_4]
.text$mn:00000EF6                 mov     esp, ebp
.text$mn:00000EF8                 pop     ebp
.text$mn:00000EF9                 retn    4
.text$mn:00000EF9 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00000EF9
.text$mn:00000EF9 _text$mn        ends
.text$mn:00000EF9
.text$mn:00000EFC ; ===========================================================================
.text$mn:00000EFC
.text$mn:00000EFC ; Segment type: Pure code
.text$mn:00000EFC ; Segment permissions: Read/Execute
.text$mn:00000EFC _text$mn        segment para public 'CODE' use32
.text$mn:00000EFC                 assume cs:_text$mn
.text$mn:00000EFC                 ;org 0EFCh
.text$mn:00000EFC ; COMDAT (pick any)
.text$mn:00000EFC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000EFC
.text$mn:00000EFC ; =============== S U B R O U T I N E =======================================
.text$mn:00000EFC
.text$mn:00000EFC ; Attributes: bp-based frame
.text$mn:00000EFC
.text$mn:00000EFC ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000EFC                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00000EFC ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000EFC
.text$mn:00000EFC var_4           = dword ptr -4
.text$mn:00000EFC arg_0           = dword ptr  8
.text$mn:00000EFC
.text$mn:00000EFC                 push    ebp
.text$mn:00000EFD                 mov     ebp, esp
.text$mn:00000EFF                 push    ecx
.text$mn:00000F00                 mov     [ebp+var_4], ecx
.text$mn:00000F03                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F06                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00000F0B                 mov     eax, [ebp+arg_0]
.text$mn:00000F0E                 and     eax, 1
.text$mn:00000F11                 jz      short loc_F1F
.text$mn:00000F13                 mov     ecx, [ebp+var_4]
.text$mn:00000F16                 push    ecx             ; void *
.text$mn:00000F17                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000F1C                 add     esp, 4
.text$mn:00000F1F
.text$mn:00000F1F loc_F1F:                                ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000F1F                 mov     eax, [ebp+var_4]
.text$mn:00000F22                 mov     esp, ebp
.text$mn:00000F24                 pop     ebp
.text$mn:00000F25                 retn    4
.text$mn:00000F25 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00000F25
.text$mn:00000F25 _text$mn        ends
.text$mn:00000F25
.text$mn:00000F28 ; ===========================================================================
.text$mn:00000F28
.text$mn:00000F28 ; Segment type: Pure code
.text$mn:00000F28 ; Segment permissions: Read/Execute
.text$mn:00000F28 _text$mn        segment para public 'CODE' use32
.text$mn:00000F28                 assume cs:_text$mn
.text$mn:00000F28                 ;org 0F28h
.text$mn:00000F28 ; COMDAT (pick any)
.text$mn:00000F28                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F28
.text$mn:00000F28 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F28
.text$mn:00000F28 ; Attributes: bp-based frame
.text$mn:00000F28
.text$mn:00000F28 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000F28                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00000F28 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00000F28
.text$mn:00000F28 var_4           = dword ptr -4
.text$mn:00000F28 arg_0           = dword ptr  8
.text$mn:00000F28
.text$mn:00000F28                 push    ebp
.text$mn:00000F29                 mov     ebp, esp
.text$mn:00000F2B                 push    ecx
.text$mn:00000F2C                 mov     [ebp+var_4], ecx
.text$mn:00000F2F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F32                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000F37                 mov     eax, [ebp+arg_0]
.text$mn:00000F3A                 and     eax, 1
.text$mn:00000F3D                 jz      short loc_F4B
.text$mn:00000F3F                 mov     ecx, [ebp+var_4]
.text$mn:00000F42                 push    ecx             ; void *
.text$mn:00000F43                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000F48                 add     esp, 4
.text$mn:00000F4B
.text$mn:00000F4B loc_F4B:                                ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000F4B                 mov     eax, [ebp+var_4]
.text$mn:00000F4E                 mov     esp, ebp
.text$mn:00000F50                 pop     ebp
.text$mn:00000F51                 retn    4
.text$mn:00000F51 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00000F51
.text$mn:00000F51 _text$mn        ends
.text$mn:00000F51
.text$di:00000F54 ; ===========================================================================
.text$di:00000F54
.text$di:00000F54 ; Segment type: Pure code
.text$di:00000F54 ; Segment permissions: Read/Execute
.text$di:00000F54 _text$di        segment para public 'CODE' use32
.text$di:00000F54                 assume cs:_text$di
.text$di:00000F54                 ;org 0F54h
.text$di:00000F54 ; COMDAT (pick any)
.text$di:00000F54                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000F54
.text$di:00000F54 ; =============== S U B R O U T I N E =======================================
.text$di:00000F54
.text$di:00000F54 ; Attributes: bp-based frame
.text$di:00000F54
.text$di:00000F54 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00000F54 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00000F54                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00000F54                 push    ebp
.text$di:00000F55                 mov     ebp, esp
.text$di:00000F57                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00000F5C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00000F61                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000F66                 call    _atexit
.text$di:00000F6B                 add     esp, 4
.text$di:00000F6E                 pop     ebp
.text$di:00000F6F                 retn
.text$di:00000F6F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00000F6F
.text$di:00000F6F _text$di        ends
.text$di:00000F6F
.text$di:00000F70 ; ===========================================================================
.text$di:00000F70
.text$di:00000F70 ; Segment type: Pure code
.text$di:00000F70 ; Segment permissions: Read/Execute
.text$di:00000F70 _text$di        segment para public 'CODE' use32
.text$di:00000F70                 assume cs:_text$di
.text$di:00000F70                 ;org 0F70h
.text$di:00000F70 ; COMDAT (pick any)
.text$di:00000F70                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000F70
.text$di:00000F70 ; =============== S U B R O U T I N E =======================================
.text$di:00000F70
.text$di:00000F70 ; Attributes: bp-based frame
.text$di:00000F70
.text$di:00000F70 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00000F70 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00000F70                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00000F70                 push    ebp
.text$di:00000F71                 mov     ebp, esp
.text$di:00000F73                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00000F78                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00000F7D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000F82                 call    _atexit
.text$di:00000F87                 add     esp, 4
.text$di:00000F8A                 pop     ebp
.text$di:00000F8B                 retn
.text$di:00000F8B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00000F8B
.text$di:00000F8B _text$di        ends
.text$di:00000F8B
.text$di:00000F8C ; ===========================================================================
.text$di:00000F8C
.text$di:00000F8C ; Segment type: Pure code
.text$di:00000F8C ; Segment permissions: Read/Execute
.text$di:00000F8C _text$di        segment para public 'CODE' use32
.text$di:00000F8C                 assume cs:_text$di
.text$di:00000F8C                 ;org 0F8Ch
.text$di:00000F8C ; COMDAT (pick any)
.text$di:00000F8C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000F8C
.text$di:00000F8C ; =============== S U B R O U T I N E =======================================
.text$di:00000F8C
.text$di:00000F8C ; Attributes: bp-based frame
.text$di:00000F8C
.text$di:00000F8C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00000F8C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00000F8C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00000F8C                 push    ebp
.text$di:00000F8D                 mov     ebp, esp
.text$di:00000F8F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00000F94                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00000F99                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000F9E                 call    _atexit
.text$di:00000FA3                 add     esp, 4
.text$di:00000FA6                 pop     ebp
.text$di:00000FA7                 retn
.text$di:00000FA7 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00000FA7
.text$di:00000FA7 _text$di        ends
.text$di:00000FA7
.text$di:00000FA8 ; ===========================================================================
.text$di:00000FA8
.text$di:00000FA8 ; Segment type: Pure code
.text$di:00000FA8 ; Segment permissions: Read/Execute
.text$di:00000FA8 _text$di        segment para public 'CODE' use32
.text$di:00000FA8                 assume cs:_text$di
.text$di:00000FA8                 ;org 0FA8h
.text$di:00000FA8 ; COMDAT (pick any)
.text$di:00000FA8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000FA8
.text$di:00000FA8 ; =============== S U B R O U T I N E =======================================
.text$di:00000FA8
.text$di:00000FA8 ; Attributes: bp-based frame
.text$di:00000FA8
.text$di:00000FA8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00000FA8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000FA8                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00000FA8                 push    ebp
.text$di:00000FA9                 mov     ebp, esp
.text$di:00000FAB                 push    0               ; unsigned int
.text$di:00000FAD                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000FB2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000FB7                 pop     ebp
.text$di:00000FB8                 retn
.text$di:00000FB8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000FB8
.text$di:00000FB8 ; ---------------------------------------------------------------------------
.text$di:00000FB9                 align 4
.text$di:00000FB9 _text$di        ends
.text$di:00000FB9
.text$di:00000FBC ; ===========================================================================
.text$di:00000FBC
.text$di:00000FBC ; Segment type: Pure code
.text$di:00000FBC ; Segment permissions: Read/Execute
.text$di:00000FBC _text$di        segment para public 'CODE' use32
.text$di:00000FBC                 assume cs:_text$di
.text$di:00000FBC                 ;org 0FBCh
.text$di:00000FBC ; COMDAT (pick any)
.text$di:00000FBC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000FBC
.text$di:00000FBC ; =============== S U B R O U T I N E =======================================
.text$di:00000FBC
.text$di:00000FBC ; Attributes: bp-based frame
.text$di:00000FBC
.text$di:00000FBC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00000FBC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000FBC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00000FBC                 push    ebp
.text$di:00000FBD                 mov     ebp, esp
.text$di:00000FBF                 push    0               ; unsigned int
.text$di:00000FC1                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000FC6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000FCB                 pop     ebp
.text$di:00000FCC                 retn
.text$di:00000FCC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000FCC
.text$di:00000FCC ; ---------------------------------------------------------------------------
.text$di:00000FCD                 align 10h
.text$di:00000FCD _text$di        ends
.text$di:00000FCD
.text$di:00000FD0 ; ===========================================================================
.text$di:00000FD0
.text$di:00000FD0 ; Segment type: Pure code
.text$di:00000FD0 ; Segment permissions: Read/Execute
.text$di:00000FD0 _text$di        segment para public 'CODE' use32
.text$di:00000FD0                 assume cs:_text$di
.text$di:00000FD0                 ;org 0FD0h
.text$di:00000FD0 ; COMDAT (pick any)
.text$di:00000FD0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000FD0
.text$di:00000FD0 ; =============== S U B R O U T I N E =======================================
.text$di:00000FD0
.text$di:00000FD0 ; Attributes: bp-based frame
.text$di:00000FD0
.text$di:00000FD0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00000FD0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000FD0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00000FD0                 push    ebp
.text$di:00000FD1                 mov     ebp, esp
.text$di:00000FD3                 push    0               ; unsigned int
.text$di:00000FD5                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00000FDA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000FDF                 pop     ebp
.text$di:00000FE0                 retn
.text$di:00000FE0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000FE0
.text$di:00000FE0 ; ---------------------------------------------------------------------------
.text$di:00000FE1                 align 4
.text$di:00000FE1 _text$di        ends
.text$di:00000FE1
.text$di:00000FE4 ; ===========================================================================
.text$di:00000FE4
.text$di:00000FE4 ; Segment type: Pure code
.text$di:00000FE4 ; Segment permissions: Read/Execute
.text$di:00000FE4 _text$di        segment para public 'CODE' use32
.text$di:00000FE4                 assume cs:_text$di
.text$di:00000FE4                 ;org 0FE4h
.text$di:00000FE4 ; COMDAT (pick any)
.text$di:00000FE4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000FE4
.text$di:00000FE4 ; =============== S U B R O U T I N E =======================================
.text$di:00000FE4
.text$di:00000FE4 ; Attributes: bp-based frame
.text$di:00000FE4
.text$di:00000FE4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00000FE4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000FE4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00000FE4                 push    ebp
.text$di:00000FE5                 mov     ebp, esp
.text$di:00000FE7                 push    0               ; unsigned int
.text$di:00000FE9                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00000FEE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000FF3                 pop     ebp
.text$di:00000FF4                 retn
.text$di:00000FF4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000FF4
.text$di:00000FF4 ; ---------------------------------------------------------------------------
.text$di:00000FF5                 align 4
.text$di:00000FF5 _text$di        ends
.text$di:00000FF5
.text$di:00000FF8 ; ===========================================================================
.text$di:00000FF8
.text$di:00000FF8 ; Segment type: Pure code
.text$di:00000FF8 ; Segment permissions: Read/Execute
.text$di:00000FF8 _text$di        segment para public 'CODE' use32
.text$di:00000FF8                 assume cs:_text$di
.text$di:00000FF8                 ;org 0FF8h
.text$di:00000FF8 ; COMDAT (pick any)
.text$di:00000FF8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000FF8
.text$di:00000FF8 ; =============== S U B R O U T I N E =======================================
.text$di:00000FF8
.text$di:00000FF8 ; Attributes: bp-based frame
.text$di:00000FF8
.text$di:00000FF8 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00000FF8 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00000FF8
.text$di:00000FF8 var_1           = byte ptr -1
.text$di:00000FF8
.text$di:00000FF8                 push    ebp
.text$di:00000FF9                 mov     ebp, esp
.text$di:00000FFB                 push    ecx
.text$di:00000FFC                 xor     eax, eax
.text$di:00000FFE                 mov     [ebp+var_1], al
.text$di:00001001                 mov     esp, ebp
.text$di:00001003                 pop     ebp
.text$di:00001004                 retn
.text$di:00001004 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001004
.text$di:00001004 ; ---------------------------------------------------------------------------
.text$di:00001005                 align 4
.text$di:00001005 _text$di        ends
.text$di:00001005
.text$di:00001008 ; ===========================================================================
.text$di:00001008
.text$di:00001008 ; Segment type: Pure code
.text$di:00001008 ; Segment permissions: Read/Execute
.text$di:00001008 _text$di        segment para public 'CODE' use32
.text$di:00001008                 assume cs:_text$di
.text$di:00001008                 ;org 1008h
.text$di:00001008 ; COMDAT (pick any)
.text$di:00001008                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00001008
.text$di:00001008 ; =============== S U B R O U T I N E =======================================
.text$di:00001008
.text$di:00001008 ; Attributes: bp-based frame
.text$di:00001008
.text$di:00001008 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00001008 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00001008                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00001008
.text$di:00001008 var_1           = byte ptr -1
.text$di:00001008
.text$di:00001008                 push    ebp
.text$di:00001009                 mov     ebp, esp
.text$di:0000100B                 push    ecx
.text$di:0000100C                 xor     eax, eax
.text$di:0000100E                 mov     [ebp+var_1], al
.text$di:00001011                 mov     esp, ebp
.text$di:00001013                 pop     ebp
.text$di:00001014                 retn
.text$di:00001014 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001014
.text$di:00001014 ; ---------------------------------------------------------------------------
.text$di:00001015                 align 4
.text$di:00001015 _text$di        ends
.text$di:00001015
.text$yd:00001018 ; ===========================================================================
.text$yd:00001018
.text$yd:00001018 ; Segment type: Pure code
.text$yd:00001018 ; Segment permissions: Read/Execute
.text$yd:00001018 _text$yd        segment para public 'CODE' use32
.text$yd:00001018                 assume cs:_text$yd
.text$yd:00001018                 ;org 1018h
.text$yd:00001018 ; COMDAT (pick any)
.text$yd:00001018                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00001018
.text$yd:00001018 ; =============== S U B R O U T I N E =======================================
.text$yd:00001018
.text$yd:00001018 ; Attributes: bp-based frame
.text$yd:00001018
.text$yd:00001018 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001018 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001018                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001018                 push    ebp
.text$yd:00001019                 mov     ebp, esp
.text$yd:0000101B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001020                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001025                 pop     ebp
.text$yd:00001026                 retn
.text$yd:00001026 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00001026
.text$yd:00001026 ; ---------------------------------------------------------------------------
.text$yd:00001027                 align 4
.text$yd:00001027 _text$yd        ends
.text$yd:00001027
.text$yd:00001028 ; ===========================================================================
.text$yd:00001028
.text$yd:00001028 ; Segment type: Pure code
.text$yd:00001028 ; Segment permissions: Read/Execute
.text$yd:00001028 _text$yd        segment para public 'CODE' use32
.text$yd:00001028                 assume cs:_text$yd
.text$yd:00001028                 ;org 1028h
.text$yd:00001028 ; COMDAT (pick any)
.text$yd:00001028                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00001028
.text$yd:00001028 ; =============== S U B R O U T I N E =======================================
.text$yd:00001028
.text$yd:00001028 ; Attributes: bp-based frame
.text$yd:00001028
.text$yd:00001028 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00001028 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00001028                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00001028                 push    ebp
.text$yd:00001029                 mov     ebp, esp
.text$yd:0000102B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001030                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001035                 pop     ebp
.text$yd:00001036                 retn
.text$yd:00001036 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00001036
.text$yd:00001036 ; ---------------------------------------------------------------------------
.text$yd:00001037                 align 4
.text$yd:00001037 _text$yd        ends
.text$yd:00001037
.text$yd:00001038 ; ===========================================================================
.text$yd:00001038
.text$yd:00001038 ; Segment type: Pure code
.text$yd:00001038 ; Segment permissions: Read/Execute
.text$yd:00001038 _text$yd        segment para public 'CODE' use32
.text$yd:00001038                 assume cs:_text$yd
.text$yd:00001038                 ;org 1038h
.text$yd:00001038 ; COMDAT (pick any)
.text$yd:00001038                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00001038
.text$yd:00001038 ; =============== S U B R O U T I N E =======================================
.text$yd:00001038
.text$yd:00001038 ; Attributes: bp-based frame
.text$yd:00001038
.text$yd:00001038 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00001038 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00001038                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00001038                 push    ebp
.text$yd:00001039                 mov     ebp, esp
.text$yd:0000103B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001040                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001045                 pop     ebp
.text$yd:00001046                 retn
.text$yd:00001046 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00001046
.text$yd:00001046 ; ---------------------------------------------------------------------------
.text$yd:00001047                 align 4
.text$yd:00001047 _text$yd        ends
.text$yd:00001047
.text$mn:00001048 ; ===========================================================================
.text$mn:00001048
.text$mn:00001048 ; Segment type: Pure code
.text$mn:00001048 ; Segment permissions: Read/Execute
.text$mn:00001048 _text$mn        segment para public 'CODE' use32
.text$mn:00001048                 assume cs:_text$mn
.text$mn:00001048                 ;org 1048h
.text$mn:00001048 ; COMDAT (pick any)
.text$mn:00001048                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001048
.text$mn:00001048 ; =============== S U B R O U T I N E =======================================
.text$mn:00001048
.text$mn:00001048 ; Attributes: bp-based frame
.text$mn:00001048
.text$mn:00001048 ; void __thiscall CWinMgr::CalcLayout(CWinMgr *this, int, int, HWND)
.text$mn:00001048                 public ?CalcLayout@CWinMgr@@QAEXHHPAUHWND__@@@Z
.text$mn:00001048 ?CalcLayout@CWinMgr@@QAEXHHPAUHWND__@@@Z proc near
.text$mn:00001048                                         ; CODE XREF: SizeableDlg::onSize(uint,int,int)+1Cp
.text$mn:00001048
.text$mn:00001048 var_18          = dword ptr -18h
.text$mn:00001048 var_14          = dword ptr -14h
.text$mn:00001048 var_10          = dword ptr -10h
.text$mn:00001048 var_C           = dword ptr -0Ch
.text$mn:00001048 var_8           = dword ptr -8
.text$mn:00001048 var_4           = dword ptr -4
.text$mn:00001048 arg_0           = dword ptr  8
.text$mn:00001048 arg_4           = dword ptr  0Ch
.text$mn:00001048 arg_8           = dword ptr  10h
.text$mn:00001048
.text$mn:00001048                 push    ebp
.text$mn:00001049                 mov     ebp, esp
.text$mn:0000104B                 sub     esp, 18h
.text$mn:0000104E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001053                 xor     eax, ebp
.text$mn:00001055                 mov     [ebp+var_4], eax
.text$mn:00001058                 mov     [ebp+var_18], ecx
.text$mn:0000105B                 mov     [ebp+var_14], 0
.text$mn:00001062                 mov     [ebp+var_10], 0
.text$mn:00001069                 mov     eax, [ebp+arg_0]
.text$mn:0000106C                 mov     [ebp+var_C], eax
.text$mn:0000106F                 mov     ecx, [ebp+arg_4]
.text$mn:00001072                 mov     [ebp+var_8], ecx
.text$mn:00001075                 mov     edx, [ebp+arg_8]
.text$mn:00001078                 push    edx             ; HWND
.text$mn:00001079                 sub     esp, 10h
.text$mn:0000107C                 mov     eax, esp
.text$mn:0000107E                 mov     ecx, [ebp+var_14]
.text$mn:00001081                 mov     [eax], ecx
.text$mn:00001083                 mov     edx, [ebp+var_10]
.text$mn:00001086                 mov     [eax+4], edx
.text$mn:00001089                 mov     ecx, [ebp+var_C]
.text$mn:0000108C                 mov     [eax+8], ecx
.text$mn:0000108F                 mov     edx, [ebp+var_8]
.text$mn:00001092                 mov     [eax+0Ch], edx
.text$mn:00001095                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001098                 call    ?CalcLayout@CWinMgr@@QAEXUtagRECT@@PAUHWND__@@@Z ; CWinMgr::CalcLayout(tagRECT,HWND__ *)
.text$mn:0000109D                 mov     ecx, [ebp+var_4]
.text$mn:000010A0                 xor     ecx, ebp
.text$mn:000010A2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000010A7                 mov     esp, ebp
.text$mn:000010A9                 pop     ebp
.text$mn:000010AA                 retn    0Ch
.text$mn:000010AA ?CalcLayout@CWinMgr@@QAEXHHPAUHWND__@@@Z endp
.text$mn:000010AA
.text$mn:000010AA ; ---------------------------------------------------------------------------
.text$mn:000010AD                 align 10h
.text$mn:000010AD _text$mn        ends
.text$mn:000010AD
.text$mn:000010B0 ; ===========================================================================
.text$mn:000010B0
.text$mn:000010B0 ; Segment type: Pure code
.text$mn:000010B0 ; Segment permissions: Read/Execute
.text$mn:000010B0 _text$mn        segment para public 'CODE' use32
.text$mn:000010B0                 assume cs:_text$mn
.text$mn:000010B0                 ;org 10B0h
.text$mn:000010B0 ; COMDAT (pick any)
.text$mn:000010B0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000010B0
.text$mn:000010B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000010B0
.text$mn:000010B0 ; Attributes: bp-based frame
.text$mn:000010B0
.text$mn:000010B0 ; void __thiscall CWinMgr::CalcLayout(CWinMgr *this, HWND)
.text$mn:000010B0                 public ?CalcLayout@CWinMgr@@QAEXPAUHWND__@@@Z
.text$mn:000010B0 ?CalcLayout@CWinMgr@@QAEXPAUHWND__@@@Z proc near
.text$mn:000010B0                                         ; CODE XREF: SizeableDlg::onInitDialog(void)+26p
.text$mn:000010B0
.text$mn:000010B0 var_18          = dword ptr -18h
.text$mn:000010B0 Rect            = tagRECT ptr -14h
.text$mn:000010B0 var_4           = dword ptr -4
.text$mn:000010B0 hWnd            = dword ptr  8
.text$mn:000010B0
.text$mn:000010B0                 push    ebp
.text$mn:000010B1                 mov     ebp, esp
.text$mn:000010B3                 sub     esp, 18h
.text$mn:000010B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000010BB                 xor     eax, ebp
.text$mn:000010BD                 mov     [ebp+var_4], eax
.text$mn:000010C0                 mov     [ebp+var_18], ecx
.text$mn:000010C3                 cmp     [ebp+hWnd], 0
.text$mn:000010C7                 jnz     short loc_10E0
.text$mn:000010C9                 push    0EFh ; 'n'      ; Line
.text$mn:000010CE                 push    offset ??_C@_1KO@LJAFCIDL@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@ ; "c:\\workspace\\notepad-plus-plus-6.7.9."...
.text$mn:000010D3                 push    offset ??_C@_19HBMCHKM@?$AAh?$AAW?$AAn?$AAd?$AA?$AA@ ; "hWnd"
.text$mn:000010D8                 call    __wassert
.text$mn:000010DD ; ---------------------------------------------------------------------------
.text$mn:000010DD                 add     esp, 0Ch
.text$mn:000010E0
.text$mn:000010E0 loc_10E0:                               ; CODE XREF: CWinMgr::CalcLayout(HWND__ *)+17j
.text$mn:000010E0                 lea     ecx, [ebp+Rect]
.text$mn:000010E3                 push    ecx             ; lpRect
.text$mn:000010E4                 mov     edx, [ebp+hWnd]
.text$mn:000010E7                 push    edx             ; hWnd
.text$mn:000010E8                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:000010EE                 mov     eax, [ebp+hWnd]
.text$mn:000010F1                 push    eax             ; HWND
.text$mn:000010F2                 sub     esp, 10h
.text$mn:000010F5                 mov     ecx, esp
.text$mn:000010F7                 mov     edx, [ebp+Rect.left]
.text$mn:000010FA                 mov     [ecx], edx
.text$mn:000010FC                 mov     eax, [ebp+Rect.top]
.text$mn:000010FF                 mov     [ecx+4], eax
.text$mn:00001102                 mov     edx, [ebp+Rect.right]
.text$mn:00001105                 mov     [ecx+8], edx
.text$mn:00001108                 mov     eax, [ebp+Rect.bottom]
.text$mn:0000110B                 mov     [ecx+0Ch], eax
.text$mn:0000110E                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001111                 call    ?CalcLayout@CWinMgr@@QAEXUtagRECT@@PAUHWND__@@@Z ; CWinMgr::CalcLayout(tagRECT,HWND__ *)
.text$mn:00001116                 mov     ecx, [ebp+var_4]
.text$mn:00001119                 xor     ecx, ebp
.text$mn:0000111B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001120                 mov     esp, ebp
.text$mn:00001122                 pop     ebp
.text$mn:00001123                 retn    4
.text$mn:00001123 ?CalcLayout@CWinMgr@@QAEXPAUHWND__@@@Z endp
.text$mn:00001123
.text$mn:00001123 ; ---------------------------------------------------------------------------
.text$mn:00001126                 align 4
.text$mn:00001126 _text$mn        ends
.text$mn:00001126
.text$mn:00001128 ; ===========================================================================
.text$mn:00001128
.text$mn:00001128 ; Segment type: Pure code
.text$mn:00001128 ; Segment permissions: Read/Execute
.text$mn:00001128 _text$mn        segment para public 'CODE' use32
.text$mn:00001128                 assume cs:_text$mn
.text$mn:00001128                 ;org 1128h
.text$mn:00001128 ; COMDAT (pick any)
.text$mn:00001128                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001128
.text$mn:00001128 ; =============== S U B R O U T I N E =======================================
.text$mn:00001128
.text$mn:00001128 ; Attributes: bp-based frame
.text$mn:00001128
.text$mn:00001128 ; void __thiscall CWinMgr::CalcLayout(CWinMgr *this, struct tagRECT, HWND)
.text$mn:00001128                 public ?CalcLayout@CWinMgr@@QAEXUtagRECT@@PAUHWND__@@@Z
.text$mn:00001128 ?CalcLayout@CWinMgr@@QAEXUtagRECT@@PAUHWND__@@@Z proc near
.text$mn:00001128                                         ; CODE XREF: CWinMgr::CalcLayout(int,int,HWND__ *)+50p
.text$mn:00001128                                         ; CWinMgr::CalcLayout(HWND__ *)+61p
.text$mn:00001128
.text$mn:00001128 var_4           = dword ptr -4
.text$mn:00001128 arg_0           = tagRECT ptr  8
.text$mn:00001128 arg_10          = dword ptr  18h
.text$mn:00001128
.text$mn:00001128                 push    ebp
.text$mn:00001129                 mov     ebp, esp
.text$mn:0000112B                 push    ecx
.text$mn:0000112C                 mov     [ebp+var_4], ecx
.text$mn:0000112F                 mov     eax, [ebp+var_4]
.text$mn:00001132                 cmp     dword ptr [eax+4], 0
.text$mn:00001136                 jnz     short loc_114F
.text$mn:00001138                 push    0FDh ; '²'      ; Line
.text$mn:0000113D                 push    offset ??_C@_1KO@LJAFCIDL@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@ ; "c:\\workspace\\notepad-plus-plus-6.7.9."...
.text$mn:00001142                 push    offset ??_C@_1M@JJLBEALK@?$AAm?$AA_?$AAm?$AAa?$AAp?$AA?$AA@ ; "m_map"
.text$mn:00001147                 call    __wassert
.text$mn:0000114C ; ---------------------------------------------------------------------------
.text$mn:0000114C                 add     esp, 0Ch
.text$mn:0000114F
.text$mn:0000114F loc_114F:                               ; CODE XREF: CWinMgr::CalcLayout(tagRECT,HWND__ *)+Ej
.text$mn:0000114F                 lea     edx, [ebp+arg_0]
.text$mn:00001152                 push    edx             ; struct tagRECT *
.text$mn:00001153                 mov     eax, [ebp+var_4]
.text$mn:00001156                 mov     ecx, [eax+4]    ; this
.text$mn:00001159                 call    ?SetRect@WINRECT@@QAEXABUtagRECT@@@Z ; WINRECT::SetRect(tagRECT const &)
.text$mn:0000115E                 mov     ecx, [ebp+arg_10]
.text$mn:00001161                 push    ecx
.text$mn:00001162                 mov     edx, [ebp+var_4]
.text$mn:00001165                 mov     eax, [edx+4]
.text$mn:00001168                 push    eax
.text$mn:00001169                 mov     ecx, [ebp+var_4]
.text$mn:0000116C                 mov     edx, [ecx]
.text$mn:0000116E                 mov     ecx, [ebp+var_4]
.text$mn:00001171                 mov     eax, [edx+10h]
.text$mn:00001174                 call    eax
.text$mn:00001176                 mov     esp, ebp
.text$mn:00001178                 pop     ebp
.text$mn:00001179                 retn    14h
.text$mn:00001179 ?CalcLayout@CWinMgr@@QAEXUtagRECT@@PAUHWND__@@@Z endp
.text$mn:00001179
.text$mn:00001179 _text$mn        ends
.text$mn:00001179
.text$mn:0000117C ; ===========================================================================
.text$mn:0000117C
.text$mn:0000117C ; Segment type: Pure code
.text$mn:0000117C ; Segment permissions: Read/Execute
.text$mn:0000117C _text$mn        segment para public 'CODE' use32
.text$mn:0000117C                 assume cs:_text$mn
.text$mn:0000117C                 ;org 117Ch
.text$mn:0000117C ; COMDAT (pick any)
.text$mn:0000117C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000117C
.text$mn:0000117C ; =============== S U B R O U T I N E =======================================
.text$mn:0000117C
.text$mn:0000117C ; Attributes: bp-based frame
.text$mn:0000117C
.text$mn:0000117C ; void __thiscall WINRECT::SetRect(WINRECT *this, const struct tagRECT *)
.text$mn:0000117C                 public ?SetRect@WINRECT@@QAEXABUtagRECT@@@Z
.text$mn:0000117C ?SetRect@WINRECT@@QAEXABUtagRECT@@@Z proc near
.text$mn:0000117C                                         ; CODE XREF: CWinMgr::CalcLayout(tagRECT,HWND__ *)+31p
.text$mn:0000117C
.text$mn:0000117C var_4           = dword ptr -4
.text$mn:0000117C arg_0           = dword ptr  8
.text$mn:0000117C
.text$mn:0000117C                 push    ebp
.text$mn:0000117D                 mov     ebp, esp
.text$mn:0000117F                 push    ecx
.text$mn:00001180                 mov     [ebp+var_4], ecx
.text$mn:00001183                 mov     eax, [ebp+var_4]
.text$mn:00001186                 add     eax, 8
.text$mn:00001189                 mov     ecx, [ebp+arg_0]
.text$mn:0000118C                 mov     edx, [ecx]
.text$mn:0000118E                 mov     [eax], edx
.text$mn:00001190                 mov     edx, [ecx+4]
.text$mn:00001193                 mov     [eax+4], edx
.text$mn:00001196                 mov     edx, [ecx+8]
.text$mn:00001199                 mov     [eax+8], edx
.text$mn:0000119C                 mov     ecx, [ecx+0Ch]
.text$mn:0000119F                 mov     [eax+0Ch], ecx
.text$mn:000011A2                 mov     esp, ebp
.text$mn:000011A4                 pop     ebp
.text$mn:000011A5                 retn    4
.text$mn:000011A5 ?SetRect@WINRECT@@QAEXABUtagRECT@@@Z endp
.text$mn:000011A5
.text$mn:000011A5 _text$mn        ends
.text$mn:000011A5
.text$mn:000011A8 ; ===========================================================================
.text$mn:000011A8
.text$mn:000011A8 ; Segment type: Pure code
.text$mn:000011A8 ; Segment permissions: Read/Execute
.text$mn:000011A8 _text$mn        segment para public 'CODE' use32
.text$mn:000011A8                 assume cs:_text$mn
.text$mn:000011A8                 ;org 11A8h
.text$mn:000011A8 ; COMDAT (pick any)
.text$mn:000011A8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000011A8
.text$mn:000011A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000011A8
.text$mn:000011A8 ; Attributes: bp-based frame
.text$mn:000011A8
.text$mn:000011A8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000011A8                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000011A8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000011A8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000011A8
.text$mn:000011A8 var_10          = byte ptr -10h
.text$mn:000011A8 var_8           = dword ptr -8
.text$mn:000011A8 var_1           = byte ptr -1
.text$mn:000011A8
.text$mn:000011A8                 push    ebp
.text$mn:000011A9                 mov     ebp, esp
.text$mn:000011AB                 sub     esp, 10h
.text$mn:000011AE                 mov     [ebp+var_8], ecx
.text$mn:000011B1                 lea     ecx, [ebp+var_1]
.text$mn:000011B4                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000011B9                 push    1
.text$mn:000011BB                 lea     ecx, [ebp+var_1]
.text$mn:000011BE                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000011C3                 mov     ecx, [ebp+var_8]
.text$mn:000011C6                 mov     [ecx], eax
.text$mn:000011C8                 lea     ecx, [ebp+var_10] ; this
.text$mn:000011CB                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000011D0                 push    eax             ; int
.text$mn:000011D1                 mov     edx, [ebp+var_8]
.text$mn:000011D4                 mov     eax, [edx]
.text$mn:000011D6                 push    eax             ; void *
.text$mn:000011D7                 lea     ecx, [ebp+var_1]
.text$mn:000011DA                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000011DF                 mov     ecx, [ebp+var_8]
.text$mn:000011E2                 mov     edx, [ecx]
.text$mn:000011E4                 mov     eax, [ebp+var_8]
.text$mn:000011E7                 mov     [edx], eax
.text$mn:000011E9                 mov     esp, ebp
.text$mn:000011EB                 pop     ebp
.text$mn:000011EC                 retn
.text$mn:000011EC ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000011EC
.text$mn:000011EC ; ---------------------------------------------------------------------------
.text$mn:000011ED                 align 10h
.text$mn:000011ED _text$mn        ends
.text$mn:000011ED
.text$mn:000011F0 ; ===========================================================================
.text$mn:000011F0
.text$mn:000011F0 ; Segment type: Pure code
.text$mn:000011F0 ; Segment permissions: Read/Execute
.text$mn:000011F0 _text$mn        segment para public 'CODE' use32
.text$mn:000011F0                 assume cs:_text$mn
.text$mn:000011F0                 ;org 11F0h
.text$mn:000011F0 ; COMDAT (pick any)
.text$mn:000011F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000011F0
.text$mn:000011F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011F0
.text$mn:000011F0 ; Attributes: bp-based frame
.text$mn:000011F0
.text$mn:000011F0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:000011F0                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000011F0 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:000011F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:000011F0
.text$mn:000011F0 var_20          = dword ptr -20h
.text$mn:000011F0 var_1C          = dword ptr -1Ch
.text$mn:000011F0 var_18          = dword ptr -18h
.text$mn:000011F0 var_11          = byte ptr -11h
.text$mn:000011F0 var_10          = dword ptr -10h
.text$mn:000011F0 var_C           = byte ptr -0Ch
.text$mn:000011F0 var_4           = dword ptr -4
.text$mn:000011F0 arg_0           = dword ptr  8
.text$mn:000011F0
.text$mn:000011F0 ; FUNCTION CHUNK AT .text$mn:00001312 SIZE 00000009 BYTES
.text$mn:000011F0
.text$mn:000011F0                 push    ebp
.text$mn:000011F1                 mov     ebp, esp
.text$mn:000011F3                 push    0FFFFFFFFh
.text$mn:000011F5                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000011FA                 mov     eax, large fs:0
.text$mn:00001200                 push    eax
.text$mn:00001201                 push    ecx
.text$mn:00001202                 sub     esp, 10h
.text$mn:00001205                 push    ebx
.text$mn:00001206                 push    esi
.text$mn:00001207                 push    edi
.text$mn:00001208                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000120D                 xor     eax, ebp
.text$mn:0000120F                 push    eax
.text$mn:00001210                 lea     eax, [ebp+var_C]
.text$mn:00001213                 mov     large fs:0, eax
.text$mn:00001219                 mov     [ebp+var_10], esp
.text$mn:0000121C                 mov     [ebp+var_18], ecx
.text$mn:0000121F                 mov     eax, [ebp+arg_0]
.text$mn:00001222                 or      eax, 0Fh
.text$mn:00001225                 mov     [ebp+var_1C], eax
.text$mn:00001228                 mov     ecx, [ebp+var_18]
.text$mn:0000122B                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001230                 cmp     eax, [ebp+var_1C]
.text$mn:00001233                 jnb     short loc_123D
.text$mn:00001235                 mov     ecx, [ebp+arg_0]
.text$mn:00001238                 mov     [ebp+var_1C], ecx
.text$mn:0000123B                 jmp     short loc_128F
.text$mn:0000123D ; ---------------------------------------------------------------------------
.text$mn:0000123D
.text$mn:0000123D loc_123D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:0000123D                 mov     edx, [ebp+var_18]
.text$mn:00001240                 mov     ecx, [edx+18h]
.text$mn:00001243                 shr     ecx, 1
.text$mn:00001245                 mov     eax, [ebp+var_1C]
.text$mn:00001248                 xor     edx, edx
.text$mn:0000124A                 mov     esi, 3
.text$mn:0000124F                 div     esi
.text$mn:00001251                 cmp     ecx, eax
.text$mn:00001253                 ja      short loc_1257
.text$mn:00001255                 jmp     short loc_128F
.text$mn:00001257 ; ---------------------------------------------------------------------------
.text$mn:00001257
.text$mn:00001257 loc_1257:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00001257                 mov     ecx, [ebp+var_18]
.text$mn:0000125A                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000125F                 mov     edx, [ebp+var_18]
.text$mn:00001262                 mov     ecx, [edx+18h]
.text$mn:00001265                 shr     ecx, 1
.text$mn:00001267                 sub     eax, ecx
.text$mn:00001269                 mov     edx, [ebp+var_18]
.text$mn:0000126C                 cmp     [edx+18h], eax
.text$mn:0000126F                 ja      short loc_1284
.text$mn:00001271                 mov     eax, [ebp+var_18]
.text$mn:00001274                 mov     ecx, [eax+18h]
.text$mn:00001277                 shr     ecx, 1
.text$mn:00001279                 mov     edx, [ebp+var_18]
.text$mn:0000127C                 add     ecx, [edx+18h]
.text$mn:0000127F                 mov     [ebp+var_1C], ecx
.text$mn:00001282                 jmp     short loc_128F
.text$mn:00001284 ; ---------------------------------------------------------------------------
.text$mn:00001284
.text$mn:00001284 loc_1284:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001284                 mov     ecx, [ebp+var_18]
.text$mn:00001287                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000128C                 mov     [ebp+var_1C], eax
.text$mn:0000128F
.text$mn:0000128F loc_128F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:0000128F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:0000128F                 mov     [ebp+var_4], 0
.text$mn:00001296                 mov     eax, [ebp+var_1C]
.text$mn:00001299                 add     eax, 1
.text$mn:0000129C                 push    eax
.text$mn:0000129D                 lea     ecx, [ebp+var_11]
.text$mn:000012A0                 push    ecx
.text$mn:000012A1                 mov     ecx, [ebp+var_18]
.text$mn:000012A4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000012A9                 mov     ecx, eax
.text$mn:000012AB                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000012B0                 mov     [ebp+var_20], eax
.text$mn:000012B3                 jmp     short loc_1312
.text$mn:000012B3 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000012B3
.text$mn:000012B5
.text$mn:000012B5 ; =============== S U B R O U T I N E =======================================
.text$mn:000012B5
.text$mn:000012B5
.text$mn:000012B5 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000012B5                                         ; DATA XREF: .xdata$x:00002388o
.text$mn:000012B5
.text$mn:000012B5 ; FUNCTION CHUNK AT .text$mn:000012FC SIZE 00000009 BYTES
.text$mn:000012B5 ; FUNCTION CHUNK AT .text$mn:0000130C SIZE 00000006 BYTES
.text$mn:000012B5
.text$mn:000012B5                 mov     [ebp-10h], esp
.text$mn:000012B8                 mov     edx, [ebp+8]
.text$mn:000012BB                 mov     [ebp-1Ch], edx
.text$mn:000012BE                 mov     byte ptr [ebp-4], 2
.text$mn:000012C2                 mov     eax, [ebp-1Ch]
.text$mn:000012C5                 add     eax, 1
.text$mn:000012C8                 push    eax
.text$mn:000012C9                 lea     ecx, [ebp-12h]
.text$mn:000012CC                 push    ecx
.text$mn:000012CD                 mov     ecx, [ebp-18h]
.text$mn:000012D0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000012D5                 mov     ecx, eax
.text$mn:000012D7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000012DC                 mov     [ebp-20h], eax
.text$mn:000012DF                 jmp     short loc_12FC
.text$mn:000012DF __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000012DF
.text$mn:000012E1
.text$mn:000012E1 ; =============== S U B R O U T I N E =======================================
.text$mn:000012E1
.text$mn:000012E1 ; Attributes: noreturn
.text$mn:000012E1
.text$mn:000012E1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000012E1                                         ; DATA XREF: .xdata$x:00002398o
.text$mn:000012E1                 push    0               ; Size
.text$mn:000012E3                 push    1               ; char
.text$mn:000012E5                 mov     ecx, [ebp-18h]
.text$mn:000012E8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000012ED                 push    0
.text$mn:000012EF                 push    0
.text$mn:000012F1                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000012F1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000012F1
.text$mn:000012F6 ; ---------------------------------------------------------------------------
.text$mn:000012F6                 mov     eax, offset $LN17
.text$mn:000012FB                 retn
.text$mn:000012FC ; ---------------------------------------------------------------------------
.text$mn:000012FC ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000012FC
.text$mn:000012FC loc_12FC:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000012FC                 mov     dword ptr [ebp-4], 1
.text$mn:00001303                 jmp     short loc_130C
.text$mn:00001303 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001305
.text$mn:00001305 ; =============== S U B R O U T I N E =======================================
.text$mn:00001305
.text$mn:00001305
.text$mn:00001305 $LN17           proc near               ; DATA XREF: .text$mn:000012F6o
.text$mn:00001305                 mov     dword ptr [ebp-4], 1
.text$mn:00001305 $LN17           endp ; sp-analysis failed
.text$mn:00001305
.text$mn:0000130C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000130C
.text$mn:0000130C loc_130C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:0000130C                 mov     eax, offset $LN19
.text$mn:00001311                 retn
.text$mn:00001311 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001312 ; ---------------------------------------------------------------------------
.text$mn:00001312 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001312
.text$mn:00001312 loc_1312:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001312                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001319                 jmp     short loc_1322
.text$mn:00001319 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000131B
.text$mn:0000131B ; =============== S U B R O U T I N E =======================================
.text$mn:0000131B
.text$mn:0000131B
.text$mn:0000131B $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_130Co
.text$mn:0000131B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001322
.text$mn:00001322 loc_1322:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001322                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001326                 jbe     short loc_1341
.text$mn:00001328                 mov     edx, [ebp+0Ch]
.text$mn:0000132B                 push    edx             ; Size
.text$mn:0000132C                 mov     ecx, [ebp-18h]
.text$mn:0000132F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001334                 push    eax             ; Src
.text$mn:00001335                 mov     eax, [ebp-20h]
.text$mn:00001338                 push    eax             ; Dst
.text$mn:00001339                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000133E                 add     esp, 0Ch
.text$mn:00001341
.text$mn:00001341 loc_1341:                               ; CODE XREF: $LN19+Bj
.text$mn:00001341                 push    0               ; Size
.text$mn:00001343                 push    1               ; char
.text$mn:00001345                 mov     ecx, [ebp-18h]
.text$mn:00001348                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000134D                 lea     ecx, [ebp-20h]
.text$mn:00001350                 push    ecx             ; int
.text$mn:00001351                 mov     edx, [ebp-18h]
.text$mn:00001354                 add     edx, 4
.text$mn:00001357                 push    edx             ; void *
.text$mn:00001358                 lea     eax, [ebp-13h]
.text$mn:0000135B                 push    eax
.text$mn:0000135C                 mov     ecx, [ebp-18h]
.text$mn:0000135F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001364                 mov     ecx, eax
.text$mn:00001366                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000136B                 mov     ecx, [ebp-18h]
.text$mn:0000136E                 mov     edx, [ebp-1Ch]
.text$mn:00001371                 mov     [ecx+18h], edx
.text$mn:00001374                 mov     eax, [ebp+0Ch]
.text$mn:00001377                 push    eax
.text$mn:00001378                 mov     ecx, [ebp-18h]
.text$mn:0000137B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001380                 mov     ecx, [ebp-0Ch]
.text$mn:00001383                 mov     large fs:0, ecx
.text$mn:0000138A                 pop     ecx
.text$mn:0000138B                 pop     edi
.text$mn:0000138C                 pop     esi
.text$mn:0000138D                 pop     ebx
.text$mn:0000138E                 mov     esp, ebp
.text$mn:00001390                 pop     ebp
.text$mn:00001391                 retn    8
.text$mn:00001391 $LN19           endp ; sp-analysis failed
.text$mn:00001391
.text$mn:00001391 _text$mn        ends
.text$mn:00001391
.text$x:00001394 ; ===========================================================================
.text$x:00001394
.text$x:00001394 ; Segment type: Pure code
.text$x:00001394 ; Segment permissions: Read/Execute
.text$x:00001394 _text$x         segment para public 'CODE' use32
.text$x:00001394                 assume cs:_text$x
.text$x:00001394                 ;org 1394h
.text$x:00001394 ; COMDAT (pick associative to section at 11F0)
.text$x:00001394                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001394
.text$x:00001394 ; =============== S U B R O U T I N E =======================================
.text$x:00001394
.text$x:00001394
.text$x:00001394 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001394                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001394
.text$x:00001394 arg_4           = dword ptr  8
.text$x:00001394
.text$x:00001394                 mov     edx, [esp+arg_4]
.text$x:00001398                 lea     eax, [edx+0Ch]
.text$x:0000139B                 mov     ecx, [edx-24h]
.text$x:0000139E                 xor     ecx, eax
.text$x:000013A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013A5                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000013AA                 jmp     ___CxxFrameHandler3
.text$x:000013AA __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000013AA
.text$x:000013AA ; ---------------------------------------------------------------------------
.text$x:000013AF                 align 10h
.text$x:000013AF _text$x         ends
.text$x:000013AF
.text$mn:000013B0 ; ===========================================================================
.text$mn:000013B0
.text$mn:000013B0 ; Segment type: Pure code
.text$mn:000013B0 ; Segment permissions: Read/Execute
.text$mn:000013B0 _text$mn        segment para public 'CODE' use32
.text$mn:000013B0                 assume cs:_text$mn
.text$mn:000013B0                 ;org 13B0h
.text$mn:000013B0 ; COMDAT (pick any)
.text$mn:000013B0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000013B0
.text$mn:000013B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000013B0
.text$mn:000013B0 ; Attributes: bp-based frame
.text$mn:000013B0
.text$mn:000013B0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:000013B0                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:000013B0 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:000013B0                                         ; CODE XREF: $LN19+60p
.text$mn:000013B0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:000013B0
.text$mn:000013B0 var_8           = dword ptr -8
.text$mn:000013B0 var_1           = byte ptr -1
.text$mn:000013B0 arg_0           = dword ptr  8
.text$mn:000013B0
.text$mn:000013B0                 push    ebp
.text$mn:000013B1                 mov     ebp, esp
.text$mn:000013B3                 sub     esp, 8
.text$mn:000013B6                 mov     [ebp+var_8], ecx
.text$mn:000013B9                 mov     [ebp+var_1], 0
.text$mn:000013BD                 mov     eax, [ebp+var_8]
.text$mn:000013C0                 mov     ecx, [ebp+arg_0]
.text$mn:000013C3                 mov     [eax+14h], ecx
.text$mn:000013C6                 lea     edx, [ebp+var_1]
.text$mn:000013C9                 push    edx
.text$mn:000013CA                 mov     ecx, [ebp+var_8]
.text$mn:000013CD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000013D2                 add     eax, [ebp+arg_0]
.text$mn:000013D5                 push    eax
.text$mn:000013D6                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000013DB                 add     esp, 8
.text$mn:000013DE                 mov     esp, ebp
.text$mn:000013E0                 pop     ebp
.text$mn:000013E1                 retn    4
.text$mn:000013E1 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000013E1
.text$mn:000013E1 _text$mn        ends
.text$mn:000013E1
.text$mn:000013E4 ; ===========================================================================
.text$mn:000013E4
.text$mn:000013E4 ; Segment type: Pure code
.text$mn:000013E4 ; Segment permissions: Read/Execute
.text$mn:000013E4 _text$mn        segment para public 'CODE' use32
.text$mn:000013E4                 assume cs:_text$mn
.text$mn:000013E4                 ;org 13E4h
.text$mn:000013E4 ; COMDAT (pick any)
.text$mn:000013E4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000013E4
.text$mn:000013E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013E4
.text$mn:000013E4 ; Attributes: bp-based frame
.text$mn:000013E4
.text$mn:000013E4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000013E4                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000013E4 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000013E4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000013E4
.text$mn:000013E4 var_8           = dword ptr -8
.text$mn:000013E4 var_1           = byte ptr -1
.text$mn:000013E4
.text$mn:000013E4                 push    ebp
.text$mn:000013E5                 mov     ebp, esp
.text$mn:000013E7                 sub     esp, 8
.text$mn:000013EA                 mov     [ebp+var_8], ecx
.text$mn:000013ED                 lea     ecx, [ebp+var_1]
.text$mn:000013F0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000013F5                 mov     ecx, [ebp+var_8] ; this
.text$mn:000013F8                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000013FD                 mov     eax, [ebp+var_8]
.text$mn:00001400                 mov     ecx, [eax]
.text$mn:00001402                 push    ecx
.text$mn:00001403                 lea     ecx, [ebp+var_1]
.text$mn:00001406                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000140B                 push    1               ; int
.text$mn:0000140D                 mov     edx, [ebp+var_8]
.text$mn:00001410                 mov     eax, [edx]
.text$mn:00001412                 push    eax             ; void *
.text$mn:00001413                 lea     ecx, [ebp+var_1]
.text$mn:00001416                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000141B                 mov     ecx, [ebp+var_8]
.text$mn:0000141E                 mov     dword ptr [ecx], 0
.text$mn:00001424                 mov     esp, ebp
.text$mn:00001426                 pop     ebp
.text$mn:00001427                 retn
.text$mn:00001427 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001427
.text$mn:00001427 _text$mn        ends
.text$mn:00001427
.text$mn:00001428 ; ===========================================================================
.text$mn:00001428
.text$mn:00001428 ; Segment type: Pure code
.text$mn:00001428 ; Segment permissions: Read/Execute
.text$mn:00001428 _text$mn        segment para public 'CODE' use32
.text$mn:00001428                 assume cs:_text$mn
.text$mn:00001428                 ;org 1428h
.text$mn:00001428 ; COMDAT (pick any)
.text$mn:00001428                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001428
.text$mn:00001428 ; =============== S U B R O U T I N E =======================================
.text$mn:00001428
.text$mn:00001428 ; Attributes: bp-based frame
.text$mn:00001428
.text$mn:00001428 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00001428                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00001428 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00001428                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00001428                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001428
.text$mn:00001428 var_4           = dword ptr -4
.text$mn:00001428 arg_0           = dword ptr  8
.text$mn:00001428
.text$mn:00001428                 push    ebp
.text$mn:00001429                 mov     ebp, esp
.text$mn:0000142B                 push    ecx
.text$mn:0000142C                 mov     [ebp+var_4], ecx
.text$mn:0000142F                 mov     ecx, [ebp+arg_0]
.text$mn:00001432                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00001437                 mov     eax, [ebp+arg_0]
.text$mn:0000143A                 mov     esp, ebp
.text$mn:0000143C                 pop     ebp
.text$mn:0000143D                 retn    4
.text$mn:0000143D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:0000143D
.text$mn:0000143D _text$mn        ends
.text$mn:0000143D
.text$mn:00001440 ; ===========================================================================
.text$mn:00001440
.text$mn:00001440 ; Segment type: Pure code
.text$mn:00001440 ; Segment permissions: Read/Execute
.text$mn:00001440 _text$mn        segment para public 'CODE' use32
.text$mn:00001440                 assume cs:_text$mn
.text$mn:00001440                 ;org 1440h
.text$mn:00001440 ; COMDAT (pick any)
.text$mn:00001440                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001440
.text$mn:00001440 ; =============== S U B R O U T I N E =======================================
.text$mn:00001440
.text$mn:00001440 ; Attributes: bp-based frame
.text$mn:00001440
.text$mn:00001440 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001440                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001440 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001440                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001440                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001440
.text$mn:00001440 var_C           = dword ptr -0Ch
.text$mn:00001440 Size            = dword ptr -8
.text$mn:00001440 var_4           = dword ptr -4
.text$mn:00001440 arg_0           = dword ptr  8
.text$mn:00001440 arg_4           = byte ptr  0Ch
.text$mn:00001440
.text$mn:00001440                 push    ebp
.text$mn:00001441                 mov     ebp, esp
.text$mn:00001443                 sub     esp, 0Ch
.text$mn:00001446                 mov     [ebp+var_4], ecx
.text$mn:00001449                 mov     ecx, [ebp+var_4]
.text$mn:0000144C                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001451                 cmp     eax, [ebp+arg_0]
.text$mn:00001454                 jnb     short loc_145E
.text$mn:00001456                 mov     ecx, [ebp+var_4]
.text$mn:00001459                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000145E
.text$mn:0000145E loc_145E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:0000145E                 mov     eax, [ebp+var_4]
.text$mn:00001461                 mov     ecx, [eax+18h]
.text$mn:00001464                 cmp     ecx, [ebp+arg_0]
.text$mn:00001467                 jnb     short loc_147E
.text$mn:00001469                 mov     edx, [ebp+var_4]
.text$mn:0000146C                 mov     eax, [edx+14h]
.text$mn:0000146F                 push    eax
.text$mn:00001470                 mov     ecx, [ebp+arg_0]
.text$mn:00001473                 push    ecx
.text$mn:00001474                 mov     ecx, [ebp+var_4]
.text$mn:00001477                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:0000147C                 jmp     short loc_14C8
.text$mn:0000147E ; ---------------------------------------------------------------------------
.text$mn:0000147E
.text$mn:0000147E loc_147E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000147E                 movzx   edx, [ebp+arg_4]
.text$mn:00001482                 test    edx, edx
.text$mn:00001484                 jz      short loc_14B8
.text$mn:00001486                 cmp     [ebp+arg_0], 10h
.text$mn:0000148A                 jnb     short loc_14B8
.text$mn:0000148C                 mov     eax, [ebp+var_4]
.text$mn:0000148F                 mov     ecx, [ebp+arg_0]
.text$mn:00001492                 cmp     ecx, [eax+14h]
.text$mn:00001495                 jnb     short loc_149F
.text$mn:00001497                 mov     edx, [ebp+arg_0]
.text$mn:0000149A                 mov     [ebp+Size], edx
.text$mn:0000149D                 jmp     short loc_14A8
.text$mn:0000149F ; ---------------------------------------------------------------------------
.text$mn:0000149F
.text$mn:0000149F loc_149F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:0000149F                 mov     eax, [ebp+var_4]
.text$mn:000014A2                 mov     ecx, [eax+14h]
.text$mn:000014A5                 mov     [ebp+Size], ecx
.text$mn:000014A8
.text$mn:000014A8 loc_14A8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:000014A8                 mov     edx, [ebp+Size]
.text$mn:000014AB                 push    edx             ; Size
.text$mn:000014AC                 push    1               ; char
.text$mn:000014AE                 mov     ecx, [ebp+var_4]
.text$mn:000014B1                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000014B6                 jmp     short loc_14C8
.text$mn:000014B8 ; ---------------------------------------------------------------------------
.text$mn:000014B8
.text$mn:000014B8 loc_14B8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:000014B8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:000014B8                 cmp     [ebp+arg_0], 0
.text$mn:000014BC                 jnz     short loc_14C8
.text$mn:000014BE                 push    0
.text$mn:000014C0                 mov     ecx, [ebp+var_4]
.text$mn:000014C3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000014C8
.text$mn:000014C8 loc_14C8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:000014C8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:000014C8                 cmp     [ebp+arg_0], 0
.text$mn:000014CC                 jbe     short loc_14D7
.text$mn:000014CE                 mov     [ebp+var_C], 1
.text$mn:000014D5                 jmp     short loc_14DE
.text$mn:000014D7 ; ---------------------------------------------------------------------------
.text$mn:000014D7
.text$mn:000014D7 loc_14D7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:000014D7                 mov     [ebp+var_C], 0
.text$mn:000014DE
.text$mn:000014DE loc_14DE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000014DE                 mov     al, byte ptr [ebp+var_C]
.text$mn:000014E1                 mov     esp, ebp
.text$mn:000014E3                 pop     ebp
.text$mn:000014E4                 retn    8
.text$mn:000014E4 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000014E4
.text$mn:000014E4 ; ---------------------------------------------------------------------------
.text$mn:000014E7                 align 4
.text$mn:000014E7 _text$mn        ends
.text$mn:000014E7
.text$mn:000014E8 ; ===========================================================================
.text$mn:000014E8
.text$mn:000014E8 ; Segment type: Pure code
.text$mn:000014E8 ; Segment permissions: Read/Execute
.text$mn:000014E8 _text$mn        segment para public 'CODE' use32
.text$mn:000014E8                 assume cs:_text$mn
.text$mn:000014E8                 ;org 14E8h
.text$mn:000014E8 ; COMDAT (pick any)
.text$mn:000014E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000014E8
.text$mn:000014E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014E8
.text$mn:000014E8 ; Attributes: bp-based frame
.text$mn:000014E8
.text$mn:000014E8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000014E8                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000014E8 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000014E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000014E8
.text$mn:000014E8 var_4           = dword ptr -4
.text$mn:000014E8 arg_0           = dword ptr  8
.text$mn:000014E8
.text$mn:000014E8                 push    ebp
.text$mn:000014E9                 mov     ebp, esp
.text$mn:000014EB                 push    ecx
.text$mn:000014EC                 mov     [ebp+var_4], ecx
.text$mn:000014EF                 cmp     [ebp+arg_0], 0
.text$mn:000014F3                 jz      short loc_1515
.text$mn:000014F5                 mov     ecx, [ebp+var_4]
.text$mn:000014F8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000014FD                 cmp     [ebp+arg_0], eax
.text$mn:00001500                 jb      short loc_1515
.text$mn:00001502                 mov     ecx, [ebp+var_4]
.text$mn:00001505                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000150A                 mov     ecx, [ebp+var_4]
.text$mn:0000150D                 add     eax, [ecx+14h]
.text$mn:00001510                 cmp     eax, [ebp+arg_0]
.text$mn:00001513                 ja      short loc_151B
.text$mn:00001515
.text$mn:00001515 loc_1515:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001515                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001515                 xor     al, al
.text$mn:00001517                 jmp     short loc_151D
.text$mn:00001519 ; ---------------------------------------------------------------------------
.text$mn:00001519                 jmp     short loc_151D
.text$mn:0000151B ; ---------------------------------------------------------------------------
.text$mn:0000151B
.text$mn:0000151B loc_151B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000151B                 mov     al, 1
.text$mn:0000151D
.text$mn:0000151D loc_151D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:0000151D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:0000151D                 mov     esp, ebp
.text$mn:0000151F                 pop     ebp
.text$mn:00001520                 retn    4
.text$mn:00001520 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001520
.text$mn:00001520 ; ---------------------------------------------------------------------------
.text$mn:00001523                 align 4
.text$mn:00001523 _text$mn        ends
.text$mn:00001523
.text$mn:00001524 ; ===========================================================================
.text$mn:00001524
.text$mn:00001524 ; Segment type: Pure code
.text$mn:00001524 ; Segment permissions: Read/Execute
.text$mn:00001524 _text$mn        segment para public 'CODE' use32
.text$mn:00001524                 assume cs:_text$mn
.text$mn:00001524                 ;org 1524h
.text$mn:00001524 ; COMDAT (pick any)
.text$mn:00001524                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001524
.text$mn:00001524 ; =============== S U B R O U T I N E =======================================
.text$mn:00001524
.text$mn:00001524 ; Attributes: bp-based frame
.text$mn:00001524
.text$mn:00001524 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001524                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00001524 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00001524                                         ; CODE XREF: $LN19+14p
.text$mn:00001524                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00001524
.text$mn:00001524 var_8           = dword ptr -8
.text$mn:00001524 var_4           = dword ptr -4
.text$mn:00001524
.text$mn:00001524                 push    ebp
.text$mn:00001525                 mov     ebp, esp
.text$mn:00001527                 sub     esp, 8
.text$mn:0000152A                 mov     [ebp+var_4], ecx
.text$mn:0000152D                 mov     eax, [ebp+var_4]
.text$mn:00001530                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001534                 jb      short loc_154A
.text$mn:00001536                 mov     ecx, [ebp+var_4]
.text$mn:00001539                 mov     edx, [ecx+4]
.text$mn:0000153C                 push    edx
.text$mn:0000153D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001542                 add     esp, 4
.text$mn:00001545                 mov     [ebp+var_8], eax
.text$mn:00001548                 jmp     short loc_1553
.text$mn:0000154A ; ---------------------------------------------------------------------------
.text$mn:0000154A
.text$mn:0000154A loc_154A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000154A                 mov     eax, [ebp+var_4]
.text$mn:0000154D                 add     eax, 4
.text$mn:00001550                 mov     [ebp+var_8], eax
.text$mn:00001553
.text$mn:00001553 loc_1553:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001553                 mov     eax, [ebp+var_8]
.text$mn:00001556                 mov     esp, ebp
.text$mn:00001558                 pop     ebp
.text$mn:00001559                 retn
.text$mn:00001559 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00001559
.text$mn:00001559 ; ---------------------------------------------------------------------------
.text$mn:0000155A                 align 4
.text$mn:0000155A _text$mn        ends
.text$mn:0000155A
.text$mn:0000155C ; ===========================================================================
.text$mn:0000155C
.text$mn:0000155C ; Segment type: Pure code
.text$mn:0000155C ; Segment permissions: Read/Execute
.text$mn:0000155C _text$mn        segment para public 'CODE' use32
.text$mn:0000155C                 assume cs:_text$mn
.text$mn:0000155C                 ;org 155Ch
.text$mn:0000155C ; COMDAT (pick any)
.text$mn:0000155C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000155C
.text$mn:0000155C ; =============== S U B R O U T I N E =======================================
.text$mn:0000155C
.text$mn:0000155C ; Attributes: bp-based frame
.text$mn:0000155C
.text$mn:0000155C ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:0000155C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:0000155C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:0000155C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:0000155C
.text$mn:0000155C var_8           = dword ptr -8
.text$mn:0000155C var_4           = dword ptr -4
.text$mn:0000155C
.text$mn:0000155C                 push    ebp
.text$mn:0000155D                 mov     ebp, esp
.text$mn:0000155F                 sub     esp, 8
.text$mn:00001562                 mov     [ebp+var_4], ecx
.text$mn:00001565                 mov     eax, [ebp+var_4]
.text$mn:00001568                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000156C                 jb      short loc_1582
.text$mn:0000156E                 mov     ecx, [ebp+var_4]
.text$mn:00001571                 mov     edx, [ecx+4]
.text$mn:00001574                 push    edx
.text$mn:00001575                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000157A                 add     esp, 4
.text$mn:0000157D                 mov     [ebp+var_8], eax
.text$mn:00001580                 jmp     short loc_158B
.text$mn:00001582 ; ---------------------------------------------------------------------------
.text$mn:00001582
.text$mn:00001582 loc_1582:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001582                 mov     eax, [ebp+var_4]
.text$mn:00001585                 add     eax, 4
.text$mn:00001588                 mov     [ebp+var_8], eax
.text$mn:0000158B
.text$mn:0000158B loc_158B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000158B                 mov     eax, [ebp+var_8]
.text$mn:0000158E                 mov     esp, ebp
.text$mn:00001590                 pop     ebp
.text$mn:00001591                 retn
.text$mn:00001591 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00001591
.text$mn:00001591 ; ---------------------------------------------------------------------------
.text$mn:00001592                 align 4
.text$mn:00001592 _text$mn        ends
.text$mn:00001592
.text$mn:00001594 ; ===========================================================================
.text$mn:00001594
.text$mn:00001594 ; Segment type: Pure code
.text$mn:00001594 ; Segment permissions: Read/Execute
.text$mn:00001594 _text$mn        segment para public 'CODE' use32
.text$mn:00001594                 assume cs:_text$mn
.text$mn:00001594                 ;org 1594h
.text$mn:00001594 ; COMDAT (pick any)
.text$mn:00001594                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001594
.text$mn:00001594 ; =============== S U B R O U T I N E =======================================
.text$mn:00001594
.text$mn:00001594 ; Attributes: bp-based frame
.text$mn:00001594
.text$mn:00001594 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001594                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001594 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001594                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001594                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00001594
.text$mn:00001594 var_18          = byte ptr -18h
.text$mn:00001594 var_14          = dword ptr -14h
.text$mn:00001594 var_10          = dword ptr -10h
.text$mn:00001594 var_C           = dword ptr -0Ch
.text$mn:00001594 var_4           = dword ptr -4
.text$mn:00001594
.text$mn:00001594                 push    ebp
.text$mn:00001595                 mov     ebp, esp
.text$mn:00001597                 push    0FFFFFFFFh
.text$mn:00001599                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000159E                 mov     eax, large fs:0
.text$mn:000015A4                 push    eax
.text$mn:000015A5                 sub     esp, 0Ch
.text$mn:000015A8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000015AD                 xor     eax, ebp
.text$mn:000015AF                 push    eax
.text$mn:000015B0                 lea     eax, [ebp+var_C]
.text$mn:000015B3                 mov     large fs:0, eax
.text$mn:000015B9                 mov     [ebp+var_14], ecx
.text$mn:000015BC                 mov     eax, [ebp+var_14]
.text$mn:000015BF                 cmp     dword ptr [eax], 0
.text$mn:000015C2                 jz      short loc_161F
.text$mn:000015C4                 push    3               ; int
.text$mn:000015C6                 lea     ecx, [ebp+var_18] ; this
.text$mn:000015C9                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000015CE                 mov     [ebp+var_4], 0
.text$mn:000015D5                 mov     ecx, [ebp+var_14]
.text$mn:000015D8                 mov     edx, [ecx]
.text$mn:000015DA                 add     edx, 4
.text$mn:000015DD                 mov     [ebp+var_10], edx
.text$mn:000015E0                 jmp     short loc_15EF
.text$mn:000015E2 ; ---------------------------------------------------------------------------
.text$mn:000015E2
.text$mn:000015E2 loc_15E2:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000015E2                 mov     eax, [ebp+var_10]
.text$mn:000015E5                 mov     ecx, [eax]
.text$mn:000015E7                 mov     edx, [ebp+var_10]
.text$mn:000015EA                 mov     eax, [ecx+4]
.text$mn:000015ED                 mov     [edx], eax
.text$mn:000015EF
.text$mn:000015EF loc_15EF:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000015EF                 mov     ecx, [ebp+var_10]
.text$mn:000015F2                 cmp     dword ptr [ecx], 0
.text$mn:000015F5                 jz      short loc_1604
.text$mn:000015F7                 mov     edx, [ebp+var_10]
.text$mn:000015FA                 mov     eax, [edx]
.text$mn:000015FC                 mov     dword ptr [eax], 0
.text$mn:00001602                 jmp     short loc_15E2
.text$mn:00001604 ; ---------------------------------------------------------------------------
.text$mn:00001604
.text$mn:00001604 loc_1604:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00001604                 mov     ecx, [ebp+var_14]
.text$mn:00001607                 mov     edx, [ecx]
.text$mn:00001609                 mov     dword ptr [edx+4], 0
.text$mn:00001610                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001617                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000161A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000161F
.text$mn:0000161F loc_161F:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:0000161F                 mov     ecx, [ebp+var_C]
.text$mn:00001622                 mov     large fs:0, ecx
.text$mn:00001629                 pop     ecx
.text$mn:0000162A                 mov     esp, ebp
.text$mn:0000162C                 pop     ebp
.text$mn:0000162D                 retn
.text$mn:0000162D ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:0000162D
.text$mn:0000162D ; ---------------------------------------------------------------------------
.text$mn:0000162E                 align 10h
.text$mn:0000162E _text$mn        ends
.text$mn:0000162E
.text$x:00001630 ; ===========================================================================
.text$x:00001630
.text$x:00001630 ; Segment type: Pure code
.text$x:00001630 ; Segment permissions: Read/Execute
.text$x:00001630 _text$x         segment para public 'CODE' use32
.text$x:00001630                 assume cs:_text$x
.text$x:00001630                 ;org 1630h
.text$x:00001630 ; COMDAT (pick associative to section at 1594)
.text$x:00001630                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001630
.text$x:00001630 ; =============== S U B R O U T I N E =======================================
.text$x:00001630
.text$x:00001630
.text$x:00001630 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00001630                                         ; DATA XREF: .xdata$x:0000224Co
.text$x:00001630                 lea     ecx, [ebp-18h]  ; this
.text$x:00001633                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00001633 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00001633
.text$x:00001638
.text$x:00001638 ; =============== S U B R O U T I N E =======================================
.text$x:00001638
.text$x:00001638
.text$x:00001638 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001638                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001638
.text$x:00001638 arg_4           = dword ptr  8
.text$x:00001638
.text$x:00001638                 mov     edx, [esp+arg_4]
.text$x:0000163C                 lea     eax, [edx+0Ch]
.text$x:0000163F                 mov     ecx, [edx-10h]
.text$x:00001642                 xor     ecx, eax
.text$x:00001644                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001649                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:0000164E                 jmp     ___CxxFrameHandler3
.text$x:0000164E __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:0000164E
.text$x:0000164E ; ---------------------------------------------------------------------------
.text$x:00001653                 align 4
.text$x:00001653 _text$x         ends
.text$x:00001653
.text$mn:00001654 ; ===========================================================================
.text$mn:00001654
.text$mn:00001654 ; Segment type: Pure code
.text$mn:00001654 ; Segment permissions: Read/Execute
.text$mn:00001654 _text$mn        segment para public 'CODE' use32
.text$mn:00001654                 assume cs:_text$mn
.text$mn:00001654                 ;org 1654h
.text$mn:00001654 ; COMDAT (pick any)
.text$mn:00001654                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001654
.text$mn:00001654 ; =============== S U B R O U T I N E =======================================
.text$mn:00001654
.text$mn:00001654 ; Attributes: bp-based frame
.text$mn:00001654
.text$mn:00001654 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00001654                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00001654 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00001654                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00001654                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00001654
.text$mn:00001654 var_C           = dword ptr -0Ch
.text$mn:00001654 var_8           = dword ptr -8
.text$mn:00001654 var_2           = byte ptr -2
.text$mn:00001654 var_1           = byte ptr -1
.text$mn:00001654 arg_0           = byte ptr  8
.text$mn:00001654 Size            = dword ptr  0Ch
.text$mn:00001654
.text$mn:00001654                 push    ebp
.text$mn:00001655                 mov     ebp, esp
.text$mn:00001657                 sub     esp, 0Ch
.text$mn:0000165A                 mov     [ebp+var_8], ecx
.text$mn:0000165D                 movzx   eax, [ebp+arg_0]
.text$mn:00001661                 test    eax, eax
.text$mn:00001663                 jnz     short loc_1667
.text$mn:00001665                 jmp     short loc_16DA
.text$mn:00001667 ; ---------------------------------------------------------------------------
.text$mn:00001667
.text$mn:00001667 loc_1667:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00001667                 mov     ecx, [ebp+var_8]
.text$mn:0000166A                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000166E                 jb      short loc_16DA
.text$mn:00001670                 mov     edx, [ebp+var_8]
.text$mn:00001673                 mov     eax, [edx+4]
.text$mn:00001676                 mov     [ebp+var_C], eax
.text$mn:00001679                 mov     ecx, [ebp+var_8]
.text$mn:0000167C                 add     ecx, 4
.text$mn:0000167F                 push    ecx
.text$mn:00001680                 lea     edx, [ebp+var_1]
.text$mn:00001683                 push    edx
.text$mn:00001684                 mov     ecx, [ebp+var_8]
.text$mn:00001687                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000168C                 mov     ecx, eax
.text$mn:0000168E                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001693                 cmp     [ebp+Size], 0
.text$mn:00001697                 jbe     short loc_16B9
.text$mn:00001699                 mov     eax, [ebp+Size]
.text$mn:0000169C                 push    eax             ; Size
.text$mn:0000169D                 mov     ecx, [ebp+var_C]
.text$mn:000016A0                 push    ecx
.text$mn:000016A1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000016A6                 add     esp, 4
.text$mn:000016A9                 push    eax             ; Src
.text$mn:000016AA                 mov     edx, [ebp+var_8]
.text$mn:000016AD                 add     edx, 4
.text$mn:000016B0                 push    edx             ; Dst
.text$mn:000016B1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000016B6                 add     esp, 0Ch
.text$mn:000016B9
.text$mn:000016B9 loc_16B9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000016B9                 mov     eax, [ebp+var_8]
.text$mn:000016BC                 mov     ecx, [eax+18h]
.text$mn:000016BF                 add     ecx, 1
.text$mn:000016C2                 push    ecx             ; int
.text$mn:000016C3                 mov     edx, [ebp+var_C]
.text$mn:000016C6                 push    edx             ; void *
.text$mn:000016C7                 lea     eax, [ebp+var_2]
.text$mn:000016CA                 push    eax
.text$mn:000016CB                 mov     ecx, [ebp+var_8]
.text$mn:000016CE                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000016D3                 mov     ecx, eax
.text$mn:000016D5                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000016DA
.text$mn:000016DA loc_16DA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000016DA                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000016DA                 mov     ecx, [ebp+var_8]
.text$mn:000016DD                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000016E4                 mov     edx, [ebp+Size]
.text$mn:000016E7                 push    edx
.text$mn:000016E8                 mov     ecx, [ebp+var_8]
.text$mn:000016EB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000016F0                 mov     esp, ebp
.text$mn:000016F2                 pop     ebp
.text$mn:000016F3                 retn    8
.text$mn:000016F3 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000016F3
.text$mn:000016F3 ; ---------------------------------------------------------------------------
.text$mn:000016F6                 align 4
.text$mn:000016F6 _text$mn        ends
.text$mn:000016F6
.text$mn:000016F8 ; ===========================================================================
.text$mn:000016F8
.text$mn:000016F8 ; Segment type: Pure code
.text$mn:000016F8 ; Segment permissions: Read/Execute
.text$mn:000016F8 _text$mn        segment para public 'CODE' use32
.text$mn:000016F8                 assume cs:_text$mn
.text$mn:000016F8                 ;org 16F8h
.text$mn:000016F8 ; COMDAT (pick any)
.text$mn:000016F8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000016F8
.text$mn:000016F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F8
.text$mn:000016F8 ; Attributes: bp-based frame
.text$mn:000016F8
.text$mn:000016F8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000016F8                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000016F8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000016F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000016F8
.text$mn:000016F8 var_4           = dword ptr -4
.text$mn:000016F8
.text$mn:000016F8                 push    ebp
.text$mn:000016F9                 mov     ebp, esp
.text$mn:000016FB                 push    ecx
.text$mn:000016FC                 mov     [ebp+var_4], ecx
.text$mn:000016FF                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001704                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001709                 mov     esp, ebp
.text$mn:0000170B                 pop     ebp
.text$mn:0000170C                 retn
.text$mn:0000170C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000170C
.text$mn:0000170C ; ---------------------------------------------------------------------------
.text$mn:0000170D                 align 10h
.text$mn:0000170D _text$mn        ends
.text$mn:0000170D
.text$mn:00001710 ; ===========================================================================
.text$mn:00001710
.text$mn:00001710 ; Segment type: Pure code
.text$mn:00001710 ; Segment permissions: Read/Execute
.text$mn:00001710 _text$mn        segment para public 'CODE' use32
.text$mn:00001710                 assume cs:_text$mn
.text$mn:00001710                 ;org 1710h
.text$mn:00001710 ; COMDAT (pick any)
.text$mn:00001710                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001710
.text$mn:00001710 ; =============== S U B R O U T I N E =======================================
.text$mn:00001710
.text$mn:00001710 ; Attributes: bp-based frame
.text$mn:00001710
.text$mn:00001710 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001710                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001710 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001710                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001710                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001710
.text$mn:00001710 var_4           = dword ptr -4
.text$mn:00001710
.text$mn:00001710                 push    ebp
.text$mn:00001711                 mov     ebp, esp
.text$mn:00001713                 push    ecx
.text$mn:00001714                 mov     [ebp+var_4], ecx
.text$mn:00001717                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000171C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001721                 mov     esp, ebp
.text$mn:00001723                 pop     ebp
.text$mn:00001724                 retn
.text$mn:00001724 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001724
.text$mn:00001724 ; ---------------------------------------------------------------------------
.text$mn:00001725                 align 4
.text$mn:00001725 _text$mn        ends
.text$mn:00001725
.text$mn:00001728 ; ===========================================================================
.text$mn:00001728
.text$mn:00001728 ; Segment type: Pure code
.text$mn:00001728 ; Segment permissions: Read/Execute
.text$mn:00001728 _text$mn        segment para public 'CODE' use32
.text$mn:00001728                 assume cs:_text$mn
.text$mn:00001728                 ;org 1728h
.text$mn:00001728 ; COMDAT (pick any)
.text$mn:00001728                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001728
.text$mn:00001728 ; =============== S U B R O U T I N E =======================================
.text$mn:00001728
.text$mn:00001728 ; Attributes: bp-based frame
.text$mn:00001728
.text$mn:00001728 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001728                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001728 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001728                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001728                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001728
.text$mn:00001728 var_4           = dword ptr -4
.text$mn:00001728 arg_0           = dword ptr  8
.text$mn:00001728
.text$mn:00001728                 push    ebp
.text$mn:00001729                 mov     ebp, esp
.text$mn:0000172B                 push    ecx
.text$mn:0000172C                 mov     [ebp+var_4], ecx
.text$mn:0000172F                 mov     eax, [ebp+arg_0]
.text$mn:00001732                 push    eax
.text$mn:00001733                 mov     ecx, [ebp+var_4]
.text$mn:00001736                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000173B                 mov     esp, ebp
.text$mn:0000173D                 pop     ebp
.text$mn:0000173E                 retn    4
.text$mn:0000173E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000173E
.text$mn:0000173E ; ---------------------------------------------------------------------------
.text$mn:00001741                 align 4
.text$mn:00001741 _text$mn        ends
.text$mn:00001741
.text$mn:00001744 ; ===========================================================================
.text$mn:00001744
.text$mn:00001744 ; Segment type: Pure code
.text$mn:00001744 ; Segment permissions: Read/Execute
.text$mn:00001744 _text$mn        segment para public 'CODE' use32
.text$mn:00001744                 assume cs:_text$mn
.text$mn:00001744                 ;org 1744h
.text$mn:00001744 ; COMDAT (pick any)
.text$mn:00001744                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001744
.text$mn:00001744 ; =============== S U B R O U T I N E =======================================
.text$mn:00001744
.text$mn:00001744 ; Attributes: bp-based frame
.text$mn:00001744
.text$mn:00001744 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00001744                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00001744 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00001744                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00001744
.text$mn:00001744 var_4           = dword ptr -4
.text$mn:00001744 arg_0           = dword ptr  8
.text$mn:00001744
.text$mn:00001744                 push    ebp
.text$mn:00001745                 mov     ebp, esp
.text$mn:00001747                 push    ecx
.text$mn:00001748                 mov     [ebp+var_4], ecx
.text$mn:0000174B                 push    0
.text$mn:0000174D                 mov     eax, [ebp+arg_0]
.text$mn:00001750                 push    eax
.text$mn:00001751                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00001756                 add     esp, 8
.text$mn:00001759                 mov     esp, ebp
.text$mn:0000175B                 pop     ebp
.text$mn:0000175C                 retn    4
.text$mn:0000175C ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000175C
.text$mn:0000175C ; ---------------------------------------------------------------------------
.text$mn:0000175F                 align 10h
.text$mn:0000175F _text$mn        ends
.text$mn:0000175F
.text$mn:00001760 ; ===========================================================================
.text$mn:00001760
.text$mn:00001760 ; Segment type: Pure code
.text$mn:00001760 ; Segment permissions: Read/Execute
.text$mn:00001760 _text$mn        segment para public 'CODE' use32
.text$mn:00001760                 assume cs:_text$mn
.text$mn:00001760                 ;org 1760h
.text$mn:00001760 ; COMDAT (pick any)
.text$mn:00001760                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001760
.text$mn:00001760 ; =============== S U B R O U T I N E =======================================
.text$mn:00001760
.text$mn:00001760 ; Attributes: bp-based frame
.text$mn:00001760
.text$mn:00001760 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001760                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001760 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001760                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001760
.text$mn:00001760 var_4           = dword ptr -4
.text$mn:00001760 arg_0           = dword ptr  8
.text$mn:00001760
.text$mn:00001760                 push    ebp
.text$mn:00001761                 mov     ebp, esp
.text$mn:00001763                 push    ecx
.text$mn:00001764                 mov     [ebp+var_4], ecx
.text$mn:00001767                 push    0
.text$mn:00001769                 mov     eax, [ebp+arg_0]
.text$mn:0000176C                 push    eax
.text$mn:0000176D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00001772                 add     esp, 8
.text$mn:00001775                 mov     esp, ebp
.text$mn:00001777                 pop     ebp
.text$mn:00001778                 retn    4
.text$mn:00001778 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001778
.text$mn:00001778 ; ---------------------------------------------------------------------------
.text$mn:0000177B                 align 4
.text$mn:0000177B _text$mn        ends
.text$mn:0000177B
.text$mn:0000177C ; ===========================================================================
.text$mn:0000177C
.text$mn:0000177C ; Segment type: Pure code
.text$mn:0000177C ; Segment permissions: Read/Execute
.text$mn:0000177C _text$mn        segment para public 'CODE' use32
.text$mn:0000177C                 assume cs:_text$mn
.text$mn:0000177C                 ;org 177Ch
.text$mn:0000177C ; COMDAT (pick any)
.text$mn:0000177C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000177C
.text$mn:0000177C ; =============== S U B R O U T I N E =======================================
.text$mn:0000177C
.text$mn:0000177C ; Attributes: bp-based frame
.text$mn:0000177C
.text$mn:0000177C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:0000177C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000177C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000177C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:0000177C
.text$mn:0000177C Size            = dword ptr -8
.text$mn:0000177C var_4           = dword ptr -4
.text$mn:0000177C arg_0           = dword ptr  8
.text$mn:0000177C arg_4           = dword ptr  0Ch
.text$mn:0000177C arg_8           = dword ptr  10h
.text$mn:0000177C
.text$mn:0000177C                 push    ebp
.text$mn:0000177D                 mov     ebp, esp
.text$mn:0000177F                 sub     esp, 8
.text$mn:00001782                 mov     [ebp+var_4], ecx
.text$mn:00001785                 mov     ecx, [ebp+arg_0]
.text$mn:00001788                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000178D                 cmp     eax, [ebp+arg_4]
.text$mn:00001790                 jnb     short loc_179A
.text$mn:00001792                 mov     ecx, [ebp+var_4]
.text$mn:00001795                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000179A
.text$mn:0000179A loc_179A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000179A                 mov     ecx, [ebp+arg_0]
.text$mn:0000179D                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000017A2                 sub     eax, [ebp+arg_4]
.text$mn:000017A5                 mov     [ebp+Size], eax
.text$mn:000017A8                 mov     eax, [ebp+arg_8]
.text$mn:000017AB                 cmp     eax, [ebp+Size]
.text$mn:000017AE                 jnb     short loc_17B6
.text$mn:000017B0                 mov     ecx, [ebp+arg_8]
.text$mn:000017B3                 mov     [ebp+Size], ecx
.text$mn:000017B6
.text$mn:000017B6 loc_17B6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000017B6                 mov     edx, [ebp+var_4]
.text$mn:000017B9                 cmp     edx, [ebp+arg_0]
.text$mn:000017BC                 jnz     short loc_17DD
.text$mn:000017BE                 mov     eax, [ebp+arg_4]
.text$mn:000017C1                 add     eax, [ebp+Size]
.text$mn:000017C4                 push    eax
.text$mn:000017C5                 mov     ecx, [ebp+var_4]
.text$mn:000017C8                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000017CD                 mov     ecx, [ebp+arg_4]
.text$mn:000017D0                 push    ecx
.text$mn:000017D1                 push    0
.text$mn:000017D3                 mov     ecx, [ebp+var_4]
.text$mn:000017D6                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000017DB                 jmp     short loc_181F
.text$mn:000017DD ; ---------------------------------------------------------------------------
.text$mn:000017DD
.text$mn:000017DD loc_17DD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000017DD                 push    0
.text$mn:000017DF                 mov     edx, [ebp+Size]
.text$mn:000017E2                 push    edx
.text$mn:000017E3                 mov     ecx, [ebp+var_4]
.text$mn:000017E6                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000017EB                 movzx   eax, al
.text$mn:000017EE                 test    eax, eax
.text$mn:000017F0                 jz      short loc_181F
.text$mn:000017F2                 mov     ecx, [ebp+Size]
.text$mn:000017F5                 push    ecx             ; Size
.text$mn:000017F6                 mov     ecx, [ebp+arg_0]
.text$mn:000017F9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000017FE                 add     eax, [ebp+arg_4]
.text$mn:00001801                 push    eax             ; Src
.text$mn:00001802                 mov     ecx, [ebp+var_4]
.text$mn:00001805                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000180A                 push    eax             ; Dst
.text$mn:0000180B                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001810                 add     esp, 0Ch
.text$mn:00001813                 mov     edx, [ebp+Size]
.text$mn:00001816                 push    edx
.text$mn:00001817                 mov     ecx, [ebp+var_4]
.text$mn:0000181A                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000181F
.text$mn:0000181F loc_181F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:0000181F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:0000181F                 mov     eax, [ebp+var_4]
.text$mn:00001822                 mov     esp, ebp
.text$mn:00001824                 pop     ebp
.text$mn:00001825                 retn    0Ch
.text$mn:00001825 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001825
.text$mn:00001825 _text$mn        ends
.text$mn:00001825
.text$mn:00001828 ; ===========================================================================
.text$mn:00001828
.text$mn:00001828 ; Segment type: Pure code
.text$mn:00001828 ; Segment permissions: Read/Execute
.text$mn:00001828 _text$mn        segment para public 'CODE' use32
.text$mn:00001828                 assume cs:_text$mn
.text$mn:00001828                 ;org 1828h
.text$mn:00001828 ; COMDAT (pick any)
.text$mn:00001828                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001828
.text$mn:00001828 ; =============== S U B R O U T I N E =======================================
.text$mn:00001828
.text$mn:00001828 ; Attributes: bp-based frame
.text$mn:00001828
.text$mn:00001828 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001828                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001828 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001828                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001828
.text$mn:00001828 var_4           = dword ptr -4
.text$mn:00001828 Str             = dword ptr  8
.text$mn:00001828
.text$mn:00001828                 push    ebp
.text$mn:00001829                 mov     ebp, esp
.text$mn:0000182B                 push    ecx
.text$mn:0000182C                 mov     [ebp+var_4], ecx
.text$mn:0000182F                 push    490h            ; unsigned int
.text$mn:00001834                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001839                 mov     eax, [ebp+Str]
.text$mn:0000183C                 push    eax             ; int
.text$mn:0000183D                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001842                 add     esp, 0Ch
.text$mn:00001845                 mov     ecx, [ebp+Str]
.text$mn:00001848                 push    ecx             ; Str
.text$mn:00001849                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000184E                 add     esp, 4
.text$mn:00001851                 push    eax             ; Size
.text$mn:00001852                 mov     edx, [ebp+Str]
.text$mn:00001855                 push    edx             ; Src
.text$mn:00001856                 mov     ecx, [ebp+var_4]
.text$mn:00001859                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000185E                 mov     esp, ebp
.text$mn:00001860                 pop     ebp
.text$mn:00001861                 retn    4
.text$mn:00001861 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001861
.text$mn:00001861 _text$mn        ends
.text$mn:00001861
.text$mn:00001864 ; ===========================================================================
.text$mn:00001864
.text$mn:00001864 ; Segment type: Pure code
.text$mn:00001864 ; Segment permissions: Read/Execute
.text$mn:00001864 _text$mn        segment para public 'CODE' use32
.text$mn:00001864                 assume cs:_text$mn
.text$mn:00001864                 ;org 1864h
.text$mn:00001864 ; COMDAT (pick any)
.text$mn:00001864                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001864
.text$mn:00001864 ; =============== S U B R O U T I N E =======================================
.text$mn:00001864
.text$mn:00001864 ; Attributes: bp-based frame
.text$mn:00001864
.text$mn:00001864 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001864                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001864 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001864                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001864
.text$mn:00001864 var_4           = dword ptr -4
.text$mn:00001864 Src             = dword ptr  8
.text$mn:00001864 Size            = dword ptr  0Ch
.text$mn:00001864
.text$mn:00001864                 push    ebp
.text$mn:00001865                 mov     ebp, esp
.text$mn:00001867                 push    ecx
.text$mn:00001868                 mov     [ebp+var_4], ecx
.text$mn:0000186B                 cmp     [ebp+Size], 0
.text$mn:0000186F                 jz      short loc_1887
.text$mn:00001871                 push    47Fh            ; unsigned int
.text$mn:00001876                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000187B                 mov     eax, [ebp+Src]
.text$mn:0000187E                 push    eax             ; int
.text$mn:0000187F                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001884                 add     esp, 0Ch
.text$mn:00001887
.text$mn:00001887 loc_1887:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001887                 mov     ecx, [ebp+Src]
.text$mn:0000188A                 push    ecx
.text$mn:0000188B                 mov     ecx, [ebp+var_4]
.text$mn:0000188E                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001893                 movzx   edx, al
.text$mn:00001896                 test    edx, edx
.text$mn:00001898                 jz      short loc_18BA
.text$mn:0000189A                 mov     eax, [ebp+Size]
.text$mn:0000189D                 push    eax
.text$mn:0000189E                 mov     ecx, [ebp+var_4]
.text$mn:000018A1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000018A6                 mov     ecx, [ebp+Src]
.text$mn:000018A9                 sub     ecx, eax
.text$mn:000018AB                 push    ecx
.text$mn:000018AC                 mov     edx, [ebp+var_4]
.text$mn:000018AF                 push    edx
.text$mn:000018B0                 mov     ecx, [ebp+var_4]
.text$mn:000018B3                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000018B8                 jmp     short loc_18F7
.text$mn:000018BA ; ---------------------------------------------------------------------------
.text$mn:000018BA
.text$mn:000018BA loc_18BA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:000018BA                 push    0
.text$mn:000018BC                 mov     eax, [ebp+Size]
.text$mn:000018BF                 push    eax
.text$mn:000018C0                 mov     ecx, [ebp+var_4]
.text$mn:000018C3                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000018C8                 movzx   ecx, al
.text$mn:000018CB                 test    ecx, ecx
.text$mn:000018CD                 jz      short loc_18F4
.text$mn:000018CF                 mov     edx, [ebp+Size]
.text$mn:000018D2                 push    edx             ; Size
.text$mn:000018D3                 mov     eax, [ebp+Src]
.text$mn:000018D6                 push    eax             ; Src
.text$mn:000018D7                 mov     ecx, [ebp+var_4]
.text$mn:000018DA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000018DF                 push    eax             ; Dst
.text$mn:000018E0                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000018E5                 add     esp, 0Ch
.text$mn:000018E8                 mov     ecx, [ebp+Size]
.text$mn:000018EB                 push    ecx
.text$mn:000018EC                 mov     ecx, [ebp+var_4]
.text$mn:000018EF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000018F4
.text$mn:000018F4 loc_18F4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000018F4                 mov     eax, [ebp+var_4]
.text$mn:000018F7
.text$mn:000018F7 loc_18F7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000018F7                 mov     esp, ebp
.text$mn:000018F9                 pop     ebp
.text$mn:000018FA                 retn    8
.text$mn:000018FA ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000018FA
.text$mn:000018FA ; ---------------------------------------------------------------------------
.text$mn:000018FD                 align 10h
.text$mn:000018FD _text$mn        ends
.text$mn:000018FD
.text$mn:00001900 ; ===========================================================================
.text$mn:00001900
.text$mn:00001900 ; Segment type: Pure code
.text$mn:00001900 ; Segment permissions: Read/Execute
.text$mn:00001900 _text$mn        segment para public 'CODE' use32
.text$mn:00001900                 assume cs:_text$mn
.text$mn:00001900                 ;org 1900h
.text$mn:00001900 ; COMDAT (pick any)
.text$mn:00001900                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001900
.text$mn:00001900 ; =============== S U B R O U T I N E =======================================
.text$mn:00001900
.text$mn:00001900 ; Attributes: bp-based frame
.text$mn:00001900
.text$mn:00001900 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00001900                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00001900 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00001900                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00001900
.text$mn:00001900 arg_0           = dword ptr  8
.text$mn:00001900 arg_4           = dword ptr  0Ch
.text$mn:00001900
.text$mn:00001900                 push    ebp
.text$mn:00001901                 mov     ebp, esp
.text$mn:00001903                 mov     eax, [ebp+arg_0]
.text$mn:00001906                 mov     ecx, [ebp+arg_4]
.text$mn:00001909                 mov     dl, [ecx]
.text$mn:0000190B                 mov     [eax], dl
.text$mn:0000190D                 pop     ebp
.text$mn:0000190E                 retn
.text$mn:0000190E ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:0000190E
.text$mn:0000190E ; ---------------------------------------------------------------------------
.text$mn:0000190F                 align 10h
.text$mn:0000190F _text$mn        ends
.text$mn:0000190F
.text$mn:00001910 ; ===========================================================================
.text$mn:00001910
.text$mn:00001910 ; Segment type: Pure code
.text$mn:00001910 ; Segment permissions: Read/Execute
.text$mn:00001910 _text$mn        segment para public 'CODE' use32
.text$mn:00001910                 assume cs:_text$mn
.text$mn:00001910                 ;org 1910h
.text$mn:00001910 ; COMDAT (pick any)
.text$mn:00001910                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001910
.text$mn:00001910 ; =============== S U B R O U T I N E =======================================
.text$mn:00001910
.text$mn:00001910 ; Attributes: bp-based frame
.text$mn:00001910
.text$mn:00001910 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00001910                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00001910 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001910                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00001910
.text$mn:00001910 var_4           = dword ptr -4
.text$mn:00001910
.text$mn:00001910                 push    ebp
.text$mn:00001911                 mov     ebp, esp
.text$mn:00001913                 push    ecx
.text$mn:00001914                 mov     [ebp+var_4], ecx
.text$mn:00001917                 mov     eax, [ebp+var_4]
.text$mn:0000191A                 mov     eax, [eax+4]
.text$mn:0000191D                 mov     esp, ebp
.text$mn:0000191F                 pop     ebp
.text$mn:00001920                 retn
.text$mn:00001920 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001920
.text$mn:00001920 ; ---------------------------------------------------------------------------
.text$mn:00001921                 align 4
.text$mn:00001921 _text$mn        ends
.text$mn:00001921
.text$mn:00001924 ; ===========================================================================
.text$mn:00001924
.text$mn:00001924 ; Segment type: Pure code
.text$mn:00001924 ; Segment permissions: Read/Execute
.text$mn:00001924 _text$mn        segment para public 'CODE' use32
.text$mn:00001924                 assume cs:_text$mn
.text$mn:00001924                 ;org 1924h
.text$mn:00001924 ; COMDAT (pick any)
.text$mn:00001924                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001924
.text$mn:00001924 ; =============== S U B R O U T I N E =======================================
.text$mn:00001924
.text$mn:00001924 ; Attributes: bp-based frame
.text$mn:00001924
.text$mn:00001924 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00001924                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00001924 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001924                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00001924                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00001924
.text$mn:00001924 var_4           = dword ptr -4
.text$mn:00001924
.text$mn:00001924                 push    ebp
.text$mn:00001925                 mov     ebp, esp
.text$mn:00001927                 push    ecx
.text$mn:00001928                 mov     [ebp+var_4], ecx
.text$mn:0000192B                 mov     eax, [ebp+var_4]
.text$mn:0000192E                 mov     eax, [eax+4]
.text$mn:00001931                 mov     esp, ebp
.text$mn:00001933                 pop     ebp
.text$mn:00001934                 retn
.text$mn:00001934 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001934
.text$mn:00001934 ; ---------------------------------------------------------------------------
.text$mn:00001935                 align 4
.text$mn:00001935 _text$mn        ends
.text$mn:00001935
.text$mn:00001938 ; ===========================================================================
.text$mn:00001938
.text$mn:00001938 ; Segment type: Pure code
.text$mn:00001938 ; Segment permissions: Read/Execute
.text$mn:00001938 _text$mn        segment para public 'CODE' use32
.text$mn:00001938                 assume cs:_text$mn
.text$mn:00001938                 ;org 1938h
.text$mn:00001938 ; COMDAT (pick any)
.text$mn:00001938                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001938
.text$mn:00001938 ; =============== S U B R O U T I N E =======================================
.text$mn:00001938
.text$mn:00001938 ; Attributes: bp-based frame
.text$mn:00001938
.text$mn:00001938 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00001938                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001938 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00001938                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001938
.text$mn:00001938 var_4           = dword ptr -4
.text$mn:00001938 Dst             = dword ptr  8
.text$mn:00001938 Src             = dword ptr  0Ch
.text$mn:00001938 Size            = dword ptr  10h
.text$mn:00001938
.text$mn:00001938                 push    ebp
.text$mn:00001939                 mov     ebp, esp
.text$mn:0000193B                 push    ecx
.text$mn:0000193C                 cmp     [ebp+Size], 0
.text$mn:00001940                 jnz     short loc_194A
.text$mn:00001942                 mov     eax, [ebp+Dst]
.text$mn:00001945                 mov     [ebp+var_4], eax
.text$mn:00001948                 jmp     short loc_1961
.text$mn:0000194A ; ---------------------------------------------------------------------------
.text$mn:0000194A
.text$mn:0000194A loc_194A:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:0000194A                 mov     ecx, [ebp+Size]
.text$mn:0000194D                 push    ecx             ; Size
.text$mn:0000194E                 mov     edx, [ebp+Src]
.text$mn:00001951                 push    edx             ; Src
.text$mn:00001952                 mov     eax, [ebp+Dst]
.text$mn:00001955                 push    eax             ; Dst
.text$mn:00001956                 call    _memcpy
.text$mn:0000195B                 add     esp, 0Ch
.text$mn:0000195E                 mov     [ebp+var_4], eax
.text$mn:00001961
.text$mn:00001961 loc_1961:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00001961                 mov     eax, [ebp+var_4]
.text$mn:00001964                 mov     esp, ebp
.text$mn:00001966                 pop     ebp
.text$mn:00001967                 retn
.text$mn:00001967 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001967
.text$mn:00001967 _text$mn        ends
.text$mn:00001967
.text$mn:00001968 ; ===========================================================================
.text$mn:00001968
.text$mn:00001968 ; Segment type: Pure code
.text$mn:00001968 ; Segment permissions: Read/Execute
.text$mn:00001968 _text$mn        segment para public 'CODE' use32
.text$mn:00001968                 assume cs:_text$mn
.text$mn:00001968                 ;org 1968h
.text$mn:00001968 ; COMDAT (pick any)
.text$mn:00001968                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001968
.text$mn:00001968 ; =============== S U B R O U T I N E =======================================
.text$mn:00001968
.text$mn:00001968 ; Attributes: bp-based frame
.text$mn:00001968
.text$mn:00001968 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001968                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001968 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001968                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001968
.text$mn:00001968 var_4           = dword ptr -4
.text$mn:00001968 arg_0           = dword ptr  8
.text$mn:00001968 arg_4           = dword ptr  0Ch
.text$mn:00001968
.text$mn:00001968                 push    ebp
.text$mn:00001969                 mov     ebp, esp
.text$mn:0000196B                 push    ecx
.text$mn:0000196C                 mov     [ebp+var_4], ecx
.text$mn:0000196F                 mov     eax, [ebp+arg_4]
.text$mn:00001972                 push    eax             ; int
.text$mn:00001973                 mov     ecx, [ebp+arg_0]
.text$mn:00001976                 push    ecx             ; void *
.text$mn:00001977                 mov     ecx, [ebp+var_4]
.text$mn:0000197A                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000197F                 mov     esp, ebp
.text$mn:00001981                 pop     ebp
.text$mn:00001982                 retn    8
.text$mn:00001982 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00001982
.text$mn:00001982 ; ---------------------------------------------------------------------------
.text$mn:00001985                 align 4
.text$mn:00001985 _text$mn        ends
.text$mn:00001985
.text$mn:00001988 ; ===========================================================================
.text$mn:00001988
.text$mn:00001988 ; Segment type: Pure code
.text$mn:00001988 ; Segment permissions: Read/Execute
.text$mn:00001988 _text$mn        segment para public 'CODE' use32
.text$mn:00001988                 assume cs:_text$mn
.text$mn:00001988                 ;org 1988h
.text$mn:00001988 ; COMDAT (pick any)
.text$mn:00001988                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001988
.text$mn:00001988 ; =============== S U B R O U T I N E =======================================
.text$mn:00001988
.text$mn:00001988 ; Attributes: bp-based frame
.text$mn:00001988
.text$mn:00001988 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00001988                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00001988 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00001988                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00001988
.text$mn:00001988 var_4           = dword ptr -4
.text$mn:00001988 arg_0           = dword ptr  8
.text$mn:00001988
.text$mn:00001988                 push    ebp
.text$mn:00001989                 mov     ebp, esp
.text$mn:0000198B                 push    ecx
.text$mn:0000198C                 mov     [ebp+var_4], ecx
.text$mn:0000198F                 mov     eax, [ebp+arg_0]
.text$mn:00001992                 push    eax             ; void *
.text$mn:00001993                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001998                 add     esp, 4
.text$mn:0000199B                 mov     esp, ebp
.text$mn:0000199D                 pop     ebp
.text$mn:0000199E                 retn    8
.text$mn:0000199E ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000199E
.text$mn:0000199E ; ---------------------------------------------------------------------------
.text$mn:000019A1                 align 4
.text$mn:000019A1 _text$mn        ends
.text$mn:000019A1
.text$mn:000019A4 ; ===========================================================================
.text$mn:000019A4
.text$mn:000019A4 ; Segment type: Pure code
.text$mn:000019A4 ; Segment permissions: Read/Execute
.text$mn:000019A4 _text$mn        segment para public 'CODE' use32
.text$mn:000019A4                 assume cs:_text$mn
.text$mn:000019A4                 ;org 19A4h
.text$mn:000019A4 ; COMDAT (pick any)
.text$mn:000019A4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019A4
.text$mn:000019A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019A4
.text$mn:000019A4 ; Attributes: bp-based frame
.text$mn:000019A4
.text$mn:000019A4 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000019A4                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000019A4 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000019A4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000019A4
.text$mn:000019A4 var_4           = dword ptr -4
.text$mn:000019A4 arg_0           = dword ptr  8
.text$mn:000019A4
.text$mn:000019A4                 push    ebp
.text$mn:000019A5                 mov     ebp, esp
.text$mn:000019A7                 push    ecx
.text$mn:000019A8                 mov     [ebp+var_4], ecx
.text$mn:000019AB                 mov     eax, [ebp+arg_0]
.text$mn:000019AE                 push    eax             ; void *
.text$mn:000019AF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000019B4                 add     esp, 4
.text$mn:000019B7                 mov     esp, ebp
.text$mn:000019B9                 pop     ebp
.text$mn:000019BA                 retn    8
.text$mn:000019BA ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000019BA
.text$mn:000019BA ; ---------------------------------------------------------------------------
.text$mn:000019BD                 align 10h
.text$mn:000019BD _text$mn        ends
.text$mn:000019BD
.text$mn:000019C0 ; ===========================================================================
.text$mn:000019C0
.text$mn:000019C0 ; Segment type: Pure code
.text$mn:000019C0 ; Segment permissions: Read/Execute
.text$mn:000019C0 _text$mn        segment para public 'CODE' use32
.text$mn:000019C0                 assume cs:_text$mn
.text$mn:000019C0                 ;org 19C0h
.text$mn:000019C0 ; COMDAT (pick any)
.text$mn:000019C0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019C0
.text$mn:000019C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019C0
.text$mn:000019C0 ; Attributes: bp-based frame
.text$mn:000019C0
.text$mn:000019C0 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:000019C0                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000019C0 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000019C0                                         ; DATA XREF: .rdata:0000281Co
.text$mn:000019C0
.text$mn:000019C0 var_4           = dword ptr -4
.text$mn:000019C0 arg_0           = dword ptr  8
.text$mn:000019C0 arg_4           = dword ptr  0Ch
.text$mn:000019C0
.text$mn:000019C0                 push    ebp
.text$mn:000019C1                 mov     ebp, esp
.text$mn:000019C3                 push    ecx
.text$mn:000019C4                 mov     [ebp+var_4], ecx
.text$mn:000019C7                 mov     eax, [ebp+arg_4]
.text$mn:000019CA                 push    eax             ; int
.text$mn:000019CB                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000019D0                 add     esp, 4
.text$mn:000019D3                 test    eax, eax
.text$mn:000019D5                 jz      short loc_19F0
.text$mn:000019D7                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000019DC                 push    eax             ; struct std::error_category *
.text$mn:000019DD                 mov     ecx, [ebp+arg_4]
.text$mn:000019E0                 push    ecx             ; int
.text$mn:000019E1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000019E4                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000019E9                 mov     eax, [ebp+arg_0]
.text$mn:000019EC                 jmp     short loc_1A05
.text$mn:000019EE ; ---------------------------------------------------------------------------
.text$mn:000019EE                 jmp     short loc_1A05
.text$mn:000019F0 ; ---------------------------------------------------------------------------
.text$mn:000019F0
.text$mn:000019F0 loc_19F0:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000019F0                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000019F5                 push    eax             ; struct std::error_category *
.text$mn:000019F6                 mov     edx, [ebp+arg_4]
.text$mn:000019F9                 push    edx             ; int
.text$mn:000019FA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000019FD                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001A02                 mov     eax, [ebp+arg_0]
.text$mn:00001A05
.text$mn:00001A05 loc_1A05:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00001A05                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00001A05                 mov     esp, ebp
.text$mn:00001A07                 pop     ebp
.text$mn:00001A08                 retn    8
.text$mn:00001A08 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001A08
.text$mn:00001A08 ; ---------------------------------------------------------------------------
.text$mn:00001A0B                 align 4
.text$mn:00001A0B _text$mn        ends
.text$mn:00001A0B
.text$mn:00001A0C ; ===========================================================================
.text$mn:00001A0C
.text$mn:00001A0C ; Segment type: Pure code
.text$mn:00001A0C ; Segment permissions: Read/Execute
.text$mn:00001A0C _text$mn        segment para public 'CODE' use32
.text$mn:00001A0C                 assume cs:_text$mn
.text$mn:00001A0C                 ;org 1A0Ch
.text$mn:00001A0C ; COMDAT (pick any)
.text$mn:00001A0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001A0C
.text$mn:00001A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A0C
.text$mn:00001A0C ; Attributes: bp-based frame
.text$mn:00001A0C
.text$mn:00001A0C ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00001A0C                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001A0C ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001A0C                                         ; DATA XREF: .rdata:0000278Co
.text$mn:00001A0C                                         ; .rdata:000027A8o ...
.text$mn:00001A0C
.text$mn:00001A0C var_4           = dword ptr -4
.text$mn:00001A0C arg_0           = dword ptr  8
.text$mn:00001A0C arg_4           = dword ptr  0Ch
.text$mn:00001A0C
.text$mn:00001A0C                 push    ebp
.text$mn:00001A0D                 mov     ebp, esp
.text$mn:00001A0F                 push    ecx
.text$mn:00001A10                 mov     [ebp+var_4], ecx
.text$mn:00001A13                 mov     eax, [ebp+var_4]
.text$mn:00001A16                 push    eax             ; struct std::error_category *
.text$mn:00001A17                 mov     ecx, [ebp+arg_4]
.text$mn:00001A1A                 push    ecx             ; int
.text$mn:00001A1B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001A1E                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001A23                 mov     eax, [ebp+arg_0]
.text$mn:00001A26                 mov     esp, ebp
.text$mn:00001A28                 pop     ebp
.text$mn:00001A29                 retn    8
.text$mn:00001A29 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001A29
.text$mn:00001A29 _text$mn        ends
.text$mn:00001A29
.text$mn:00001A2C ; ===========================================================================
.text$mn:00001A2C
.text$mn:00001A2C ; Segment type: Pure code
.text$mn:00001A2C ; Segment permissions: Read/Execute
.text$mn:00001A2C _text$mn        segment para public 'CODE' use32
.text$mn:00001A2C                 assume cs:_text$mn
.text$mn:00001A2C                 ;org 1A2Ch
.text$mn:00001A2C ; COMDAT (pick any)
.text$mn:00001A2C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001A2C
.text$mn:00001A2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A2C
.text$mn:00001A2C ; Attributes: bp-based frame
.text$mn:00001A2C
.text$mn:00001A2C ; void __thiscall StaticDialog::destroy(StaticDialog *__hidden this)
.text$mn:00001A2C                 public ?destroy@StaticDialog@@UAEXXZ
.text$mn:00001A2C ?destroy@StaticDialog@@UAEXXZ proc near ; CODE XREF: StaticDialog::~StaticDialog(void)+59p
.text$mn:00001A2C                                         ; DATA XREF: .rdata:000026F4o ...
.text$mn:00001A2C
.text$mn:00001A2C var_4           = dword ptr -4
.text$mn:00001A2C
.text$mn:00001A2C                 push    ebp
.text$mn:00001A2D                 mov     ebp, esp
.text$mn:00001A2F                 push    ecx
.text$mn:00001A30                 mov     [ebp+var_4], ecx
.text$mn:00001A33                 mov     eax, [ebp+var_4]
.text$mn:00001A36                 mov     ecx, [eax+0Ch]
.text$mn:00001A39                 push    ecx             ; lParam
.text$mn:00001A3A                 push    1               ; wParam
.text$mn:00001A3C                 push    7F4h            ; Msg
.text$mn:00001A41                 mov     edx, [ebp+var_4]
.text$mn:00001A44                 mov     eax, [edx+8]
.text$mn:00001A47                 push    eax             ; hWnd
.text$mn:00001A48                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001A4E                 mov     ecx, [ebp+var_4]
.text$mn:00001A51                 mov     edx, [ecx+0Ch]
.text$mn:00001A54                 push    edx             ; hWnd
.text$mn:00001A55                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:00001A5B                 mov     esp, ebp
.text$mn:00001A5D                 pop     ebp
.text$mn:00001A5E                 retn
.text$mn:00001A5E ?destroy@StaticDialog@@UAEXXZ endp
.text$mn:00001A5E
.text$mn:00001A5E ; ---------------------------------------------------------------------------
.text$mn:00001A5F                 align 10h
.text$mn:00001A5F _text$mn        ends
.text$mn:00001A5F
.text$mn:00001A60 ; ===========================================================================
.text$mn:00001A60
.text$mn:00001A60 ; Segment type: Pure code
.text$mn:00001A60 ; Segment permissions: Read/Execute
.text$mn:00001A60 _text$mn        segment para public 'CODE' use32
.text$mn:00001A60                 assume cs:_text$mn
.text$mn:00001A60                 ;org 1A60h
.text$mn:00001A60 ; COMDAT (pick any)
.text$mn:00001A60                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001A60
.text$mn:00001A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A60
.text$mn:00001A60 ; Attributes: bp-based frame
.text$mn:00001A60
.text$mn:00001A60 ; void __thiscall Window::display(Window *this, bool)
.text$mn:00001A60                 public ?display@Window@@UBEX_N@Z
.text$mn:00001A60 ?display@Window@@UBEX_N@Z proc near     ; DATA XREF: .rdata:000026C4o
.text$mn:00001A60
.text$mn:00001A60 var_8           = dword ptr -8
.text$mn:00001A60 nCmdShow        = dword ptr -4
.text$mn:00001A60 arg_0           = byte ptr  8
.text$mn:00001A60
.text$mn:00001A60                 push    ebp
.text$mn:00001A61                 mov     ebp, esp
.text$mn:00001A63                 sub     esp, 8
.text$mn:00001A66                 mov     [ebp+var_8], ecx
.text$mn:00001A69                 movzx   eax, [ebp+arg_0]
.text$mn:00001A6D                 test    eax, eax
.text$mn:00001A6F                 jz      short loc_1A7A
.text$mn:00001A71                 mov     [ebp+nCmdShow], 5
.text$mn:00001A78                 jmp     short loc_1A81
.text$mn:00001A7A ; ---------------------------------------------------------------------------
.text$mn:00001A7A
.text$mn:00001A7A loc_1A7A:                               ; CODE XREF: Window::display(bool)+Fj
.text$mn:00001A7A                 mov     [ebp+nCmdShow], 0
.text$mn:00001A81
.text$mn:00001A81 loc_1A81:                               ; CODE XREF: Window::display(bool)+18j
.text$mn:00001A81                 mov     ecx, [ebp+nCmdShow]
.text$mn:00001A84                 push    ecx             ; nCmdShow
.text$mn:00001A85                 mov     edx, [ebp+var_8]
.text$mn:00001A88                 mov     eax, [edx+0Ch]
.text$mn:00001A8B                 push    eax             ; hWnd
.text$mn:00001A8C                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:00001A92                 mov     esp, ebp
.text$mn:00001A94                 pop     ebp
.text$mn:00001A95                 retn    4
.text$mn:00001A95 ?display@Window@@UBEX_N@Z endp
.text$mn:00001A95
.text$mn:00001A95 _text$mn        ends
.text$mn:00001A95
.text$mn:00001A98 ; ===========================================================================
.text$mn:00001A98
.text$mn:00001A98 ; Segment type: Pure code
.text$mn:00001A98 ; Segment permissions: Read/Execute
.text$mn:00001A98 _text$mn        segment para public 'CODE' use32
.text$mn:00001A98                 assume cs:_text$mn
.text$mn:00001A98                 ;org 1A98h
.text$mn:00001A98 ; COMDAT (pick any)
.text$mn:00001A98                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001A98
.text$mn:00001A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A98
.text$mn:00001A98 ; Attributes: bp-based frame
.text$mn:00001A98
.text$mn:00001A98 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00001A98                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00001A98 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00001A98                                         ; DATA XREF: .rdata:00002790o
.text$mn:00001A98                                         ; .rdata:000027ACo ...
.text$mn:00001A98
.text$mn:00001A98 var_8           = dword ptr -8
.text$mn:00001A98 var_4           = dword ptr -4
.text$mn:00001A98 arg_0           = dword ptr  8
.text$mn:00001A98 arg_4           = dword ptr  0Ch
.text$mn:00001A98
.text$mn:00001A98                 push    ebp
.text$mn:00001A99                 mov     ebp, esp
.text$mn:00001A9B                 sub     esp, 8
.text$mn:00001A9E                 mov     [ebp+var_8], ecx
.text$mn:00001AA1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001AA4                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00001AA9                 push    eax
.text$mn:00001AAA                 mov     ecx, [ebp+var_8]
.text$mn:00001AAD                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001AB2                 movzx   eax, al
.text$mn:00001AB5                 test    eax, eax
.text$mn:00001AB7                 jz      short loc_1ACF
.text$mn:00001AB9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001ABC                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00001AC1                 cmp     eax, [ebp+arg_4]
.text$mn:00001AC4                 jnz     short loc_1ACF
.text$mn:00001AC6                 mov     [ebp+var_4], 1
.text$mn:00001ACD                 jmp     short loc_1AD6
.text$mn:00001ACF ; ---------------------------------------------------------------------------
.text$mn:00001ACF
.text$mn:00001ACF loc_1ACF:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00001ACF                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00001ACF                 mov     [ebp+var_4], 0
.text$mn:00001AD6
.text$mn:00001AD6 loc_1AD6:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00001AD6                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001AD9                 mov     esp, ebp
.text$mn:00001ADB                 pop     ebp
.text$mn:00001ADC                 retn    8
.text$mn:00001ADC ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00001ADC
.text$mn:00001ADC ; ---------------------------------------------------------------------------
.text$mn:00001ADF                 align 10h
.text$mn:00001ADF _text$mn        ends
.text$mn:00001ADF
.text$mn:00001AE0 ; ===========================================================================
.text$mn:00001AE0
.text$mn:00001AE0 ; Segment type: Pure code
.text$mn:00001AE0 ; Segment permissions: Read/Execute
.text$mn:00001AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001AE0                 assume cs:_text$mn
.text$mn:00001AE0                 ;org 1AE0h
.text$mn:00001AE0 ; COMDAT (pick any)
.text$mn:00001AE0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001AE0
.text$mn:00001AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AE0
.text$mn:00001AE0 ; Attributes: bp-based frame
.text$mn:00001AE0
.text$mn:00001AE0 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00001AE0                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00001AE0 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00001AE0                                         ; DATA XREF: .rdata:00002794o
.text$mn:00001AE0                                         ; .rdata:000027B0o ...
.text$mn:00001AE0
.text$mn:00001AE0 var_C           = byte ptr -0Ch
.text$mn:00001AE0 var_4           = dword ptr -4
.text$mn:00001AE0 arg_0           = dword ptr  8
.text$mn:00001AE0 arg_4           = dword ptr  0Ch
.text$mn:00001AE0
.text$mn:00001AE0                 push    ebp
.text$mn:00001AE1                 mov     ebp, esp
.text$mn:00001AE3                 sub     esp, 0Ch
.text$mn:00001AE6                 mov     [ebp+var_4], ecx
.text$mn:00001AE9                 mov     eax, [ebp+arg_4]
.text$mn:00001AEC                 push    eax             ; std::error_condition *
.text$mn:00001AED                 mov     ecx, [ebp+arg_0]
.text$mn:00001AF0                 push    ecx
.text$mn:00001AF1                 lea     edx, [ebp+var_C]
.text$mn:00001AF4                 push    edx
.text$mn:00001AF5                 mov     eax, [ebp+var_4]
.text$mn:00001AF8                 mov     edx, [eax]
.text$mn:00001AFA                 mov     ecx, [ebp+var_4]
.text$mn:00001AFD                 mov     eax, [edx+0Ch]
.text$mn:00001B00                 call    eax
.text$mn:00001B02                 mov     ecx, eax
.text$mn:00001B04                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00001B09                 mov     esp, ebp
.text$mn:00001B0B                 pop     ebp
.text$mn:00001B0C                 retn    8
.text$mn:00001B0C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00001B0C
.text$mn:00001B0C ; ---------------------------------------------------------------------------
.text$mn:00001B0F                 align 10h
.text$mn:00001B0F _text$mn        ends
.text$mn:00001B0F
.text$mn:00001B10 ; ===========================================================================
.text$mn:00001B10
.text$mn:00001B10 ; Segment type: Pure code
.text$mn:00001B10 ; Segment permissions: Read/Execute
.text$mn:00001B10 _text$mn        segment para public 'CODE' use32
.text$mn:00001B10                 assume cs:_text$mn
.text$mn:00001B10                 ;org 1B10h
.text$mn:00001B10 ; COMDAT (pick any)
.text$mn:00001B10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B10
.text$mn:00001B10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B10
.text$mn:00001B10 ; Attributes: bp-based frame
.text$mn:00001B10
.text$mn:00001B10 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00001B10                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00001B10 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00001B10                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00001B10
.text$mn:00001B10 var_4           = dword ptr -4
.text$mn:00001B10 arg_0           = dword ptr  8
.text$mn:00001B10
.text$mn:00001B10                 push    ebp
.text$mn:00001B11                 mov     ebp, esp
.text$mn:00001B13                 push    ecx
.text$mn:00001B14                 mov     [ebp+var_4], ecx
.text$mn:00001B17                 mov     eax, [ebp+var_4]
.text$mn:00001B1A                 mov     ecx, [eax+14h]
.text$mn:00001B1D                 cmp     ecx, [ebp+arg_0]
.text$mn:00001B20                 jnb     short loc_1B2A
.text$mn:00001B22                 mov     ecx, [ebp+var_4]
.text$mn:00001B25                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001B2A
.text$mn:00001B2A loc_1B2A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00001B2A                 mov     edx, [ebp+arg_0]
.text$mn:00001B2D                 push    edx
.text$mn:00001B2E                 mov     ecx, [ebp+var_4]
.text$mn:00001B31                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001B36                 mov     eax, [ebp+var_4]
.text$mn:00001B39                 mov     esp, ebp
.text$mn:00001B3B                 pop     ebp
.text$mn:00001B3C                 retn    4
.text$mn:00001B3C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00001B3C
.text$mn:00001B3C ; ---------------------------------------------------------------------------
.text$mn:00001B3F                 align 10h
.text$mn:00001B3F _text$mn        ends
.text$mn:00001B3F
.text$mn:00001B40 ; ===========================================================================
.text$mn:00001B40
.text$mn:00001B40 ; Segment type: Pure code
.text$mn:00001B40 ; Segment permissions: Read/Execute
.text$mn:00001B40 _text$mn        segment para public 'CODE' use32
.text$mn:00001B40                 assume cs:_text$mn
.text$mn:00001B40                 ;org 1B40h
.text$mn:00001B40 ; COMDAT (pick any)
.text$mn:00001B40                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B40
.text$mn:00001B40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B40
.text$mn:00001B40 ; Attributes: bp-based frame
.text$mn:00001B40
.text$mn:00001B40 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00001B40                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00001B40 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00001B40                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00001B40
.text$mn:00001B40 var_C           = dword ptr -0Ch
.text$mn:00001B40 Dst             = dword ptr -8
.text$mn:00001B40 var_4           = dword ptr -4
.text$mn:00001B40 arg_0           = dword ptr  8
.text$mn:00001B40 arg_4           = dword ptr  0Ch
.text$mn:00001B40
.text$mn:00001B40                 push    ebp
.text$mn:00001B41                 mov     ebp, esp
.text$mn:00001B43                 sub     esp, 0Ch
.text$mn:00001B46                 mov     [ebp+var_4], ecx
.text$mn:00001B49                 mov     eax, [ebp+var_4]
.text$mn:00001B4C                 mov     ecx, [eax+14h]
.text$mn:00001B4F                 cmp     ecx, [ebp+arg_0]
.text$mn:00001B52                 jnb     short loc_1B5C
.text$mn:00001B54                 mov     ecx, [ebp+var_4]
.text$mn:00001B57                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001B5C
.text$mn:00001B5C loc_1B5C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00001B5C                 mov     edx, [ebp+var_4]
.text$mn:00001B5F                 mov     eax, [edx+14h]
.text$mn:00001B62                 sub     eax, [ebp+arg_0]
.text$mn:00001B65                 cmp     eax, [ebp+arg_4]
.text$mn:00001B68                 ja      short loc_1B78
.text$mn:00001B6A                 mov     ecx, [ebp+arg_0]
.text$mn:00001B6D                 push    ecx
.text$mn:00001B6E                 mov     ecx, [ebp+var_4]
.text$mn:00001B71                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001B76                 jmp     short loc_1BBE
.text$mn:00001B78 ; ---------------------------------------------------------------------------
.text$mn:00001B78
.text$mn:00001B78 loc_1B78:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00001B78                 cmp     [ebp+arg_4], 0
.text$mn:00001B7C                 jbe     short loc_1BBE
.text$mn:00001B7E                 mov     ecx, [ebp+var_4]
.text$mn:00001B81                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001B86                 add     eax, [ebp+arg_0]
.text$mn:00001B89                 mov     [ebp+Dst], eax
.text$mn:00001B8C                 mov     edx, [ebp+var_4]
.text$mn:00001B8F                 mov     eax, [edx+14h]
.text$mn:00001B92                 sub     eax, [ebp+arg_4]
.text$mn:00001B95                 mov     [ebp+var_C], eax
.text$mn:00001B98                 mov     ecx, [ebp+var_C]
.text$mn:00001B9B                 sub     ecx, [ebp+arg_0]
.text$mn:00001B9E                 push    ecx             ; Size
.text$mn:00001B9F                 mov     edx, [ebp+Dst]
.text$mn:00001BA2                 add     edx, [ebp+arg_4]
.text$mn:00001BA5                 push    edx             ; Src
.text$mn:00001BA6                 mov     eax, [ebp+Dst]
.text$mn:00001BA9                 push    eax             ; Dst
.text$mn:00001BAA                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00001BAF                 add     esp, 0Ch
.text$mn:00001BB2                 mov     ecx, [ebp+var_C]
.text$mn:00001BB5                 push    ecx
.text$mn:00001BB6                 mov     ecx, [ebp+var_4]
.text$mn:00001BB9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001BBE
.text$mn:00001BBE loc_1BBE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00001BBE                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00001BBE                 mov     eax, [ebp+var_4]
.text$mn:00001BC1                 mov     esp, ebp
.text$mn:00001BC3                 pop     ebp
.text$mn:00001BC4                 retn    8
.text$mn:00001BC4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001BC4
.text$mn:00001BC4 ; ---------------------------------------------------------------------------
.text$mn:00001BC7                 align 4
.text$mn:00001BC7 _text$mn        ends
.text$mn:00001BC7
.text$mn:00001BC8 ; ===========================================================================
.text$mn:00001BC8
.text$mn:00001BC8 ; Segment type: Pure code
.text$mn:00001BC8 ; Segment permissions: Read/Execute
.text$mn:00001BC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BC8                 assume cs:_text$mn
.text$mn:00001BC8                 ;org 1BC8h
.text$mn:00001BC8 ; COMDAT (pick any)
.text$mn:00001BC8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001BC8
.text$mn:00001BC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BC8
.text$mn:00001BC8 ; Attributes: bp-based frame
.text$mn:00001BC8
.text$mn:00001BC8 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00001BC8                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00001BC8 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001BC8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00001BC8                 push    ebp
.text$mn:00001BC9                 mov     ebp, esp
.text$mn:00001BCB                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00001BD0                 pop     ebp
.text$mn:00001BD1                 retn
.text$mn:00001BD1 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001BD1
.text$mn:00001BD1 ; ---------------------------------------------------------------------------
.text$mn:00001BD2                 align 4
.text$mn:00001BD2 _text$mn        ends
.text$mn:00001BD2
.text$mn:00001BD4 ; ===========================================================================
.text$mn:00001BD4
.text$mn:00001BD4 ; Segment type: Pure code
.text$mn:00001BD4 ; Segment permissions: Read/Execute
.text$mn:00001BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00001BD4                 assume cs:_text$mn
.text$mn:00001BD4                 ;org 1BD4h
.text$mn:00001BD4 ; COMDAT (pick any)
.text$mn:00001BD4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001BD4
.text$mn:00001BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BD4
.text$mn:00001BD4 ; Attributes: bp-based frame
.text$mn:00001BD4
.text$mn:00001BD4 ; void __thiscall Window::getClientRect(Window *this, struct tagRECT *)
.text$mn:00001BD4                 public ?getClientRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00001BD4 ?getClientRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00001BD4                                         ; DATA XREF: .rdata:000026D4o
.text$mn:00001BD4                                         ; .rdata:00002708o ...
.text$mn:00001BD4
.text$mn:00001BD4 var_4           = dword ptr -4
.text$mn:00001BD4 lpRect          = dword ptr  8
.text$mn:00001BD4
.text$mn:00001BD4                 push    ebp
.text$mn:00001BD5                 mov     ebp, esp
.text$mn:00001BD7                 push    ecx
.text$mn:00001BD8                 mov     [ebp+var_4], ecx
.text$mn:00001BDB                 mov     eax, [ebp+lpRect]
.text$mn:00001BDE                 push    eax             ; lpRect
.text$mn:00001BDF                 mov     ecx, [ebp+var_4]
.text$mn:00001BE2                 mov     edx, [ecx+0Ch]
.text$mn:00001BE5                 push    edx             ; hWnd
.text$mn:00001BE6                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00001BEC                 mov     esp, ebp
.text$mn:00001BEE                 pop     ebp
.text$mn:00001BEF                 retn    4
.text$mn:00001BEF ?getClientRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:00001BEF
.text$mn:00001BEF ; ---------------------------------------------------------------------------
.text$mn:00001BF2                 align 4
.text$mn:00001BF2 _text$mn        ends
.text$mn:00001BF2
.text$mn:00001BF4 ; ===========================================================================
.text$mn:00001BF4
.text$mn:00001BF4 ; Segment type: Pure code
.text$mn:00001BF4 ; Segment permissions: Read/Execute
.text$mn:00001BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001BF4                 assume cs:_text$mn
.text$mn:00001BF4                 ;org 1BF4h
.text$mn:00001BF4 ; COMDAT (pick any)
.text$mn:00001BF4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001BF4
.text$mn:00001BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BF4
.text$mn:00001BF4 ; Attributes: bp-based frame
.text$mn:00001BF4
.text$mn:00001BF4 ; int __thiscall Window::getHeight(Window *__hidden this)
.text$mn:00001BF4                 public ?getHeight@Window@@UBEHXZ
.text$mn:00001BF4 ?getHeight@Window@@UBEHXZ proc near     ; DATA XREF: .rdata:000026E0o
.text$mn:00001BF4                                         ; .rdata:00002714o ...
.text$mn:00001BF4
.text$mn:00001BF4 var_18          = dword ptr -18h
.text$mn:00001BF4 Rect            = tagRECT ptr -14h
.text$mn:00001BF4 var_4           = dword ptr -4
.text$mn:00001BF4
.text$mn:00001BF4                 push    ebp
.text$mn:00001BF5                 mov     ebp, esp
.text$mn:00001BF7                 sub     esp, 18h
.text$mn:00001BFA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001BFF                 xor     eax, ebp
.text$mn:00001C01                 mov     [ebp+var_4], eax
.text$mn:00001C04                 mov     [ebp+var_18], ecx
.text$mn:00001C07                 lea     eax, [ebp+Rect]
.text$mn:00001C0A                 push    eax             ; lpRect
.text$mn:00001C0B                 mov     ecx, [ebp+var_18]
.text$mn:00001C0E                 mov     edx, [ecx+0Ch]
.text$mn:00001C11                 push    edx             ; hWnd
.text$mn:00001C12                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00001C18                 mov     eax, [ebp+var_18]
.text$mn:00001C1B                 mov     ecx, [eax+0Ch]
.text$mn:00001C1E                 push    ecx             ; hWnd
.text$mn:00001C1F                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:00001C25                 cmp     eax, 1
.text$mn:00001C28                 jnz     short loc_1C32
.text$mn:00001C2A                 mov     eax, [ebp+Rect.bottom]
.text$mn:00001C2D                 sub     eax, [ebp+Rect.top]
.text$mn:00001C30                 jmp     short loc_1C34
.text$mn:00001C32 ; ---------------------------------------------------------------------------
.text$mn:00001C32
.text$mn:00001C32 loc_1C32:                               ; CODE XREF: Window::getHeight(void)+34j
.text$mn:00001C32                 xor     eax, eax
.text$mn:00001C34
.text$mn:00001C34 loc_1C34:                               ; CODE XREF: Window::getHeight(void)+3Cj
.text$mn:00001C34                 mov     ecx, [ebp+var_4]
.text$mn:00001C37                 xor     ecx, ebp
.text$mn:00001C39                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001C3E                 mov     esp, ebp
.text$mn:00001C40                 pop     ebp
.text$mn:00001C41                 retn
.text$mn:00001C41 ?getHeight@Window@@UBEHXZ endp
.text$mn:00001C41
.text$mn:00001C41 ; ---------------------------------------------------------------------------
.text$mn:00001C42                 align 4
.text$mn:00001C42 _text$mn        ends
.text$mn:00001C42
.text$mn:00001C44 ; ===========================================================================
.text$mn:00001C44
.text$mn:00001C44 ; Segment type: Pure code
.text$mn:00001C44 ; Segment permissions: Read/Execute
.text$mn:00001C44 _text$mn        segment para public 'CODE' use32
.text$mn:00001C44                 assume cs:_text$mn
.text$mn:00001C44                 ;org 1C44h
.text$mn:00001C44 ; COMDAT (pick any)
.text$mn:00001C44                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C44
.text$mn:00001C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C44
.text$mn:00001C44 ; Attributes: bp-based frame
.text$mn:00001C44
.text$mn:00001C44 ; int __thiscall Window::getWidth(Window *__hidden this)
.text$mn:00001C44                 public ?getWidth@Window@@UBEHXZ
.text$mn:00001C44 ?getWidth@Window@@UBEHXZ proc near      ; DATA XREF: .rdata:000026DCo
.text$mn:00001C44                                         ; .rdata:00002710o ...
.text$mn:00001C44
.text$mn:00001C44 var_18          = dword ptr -18h
.text$mn:00001C44 Rect            = tagRECT ptr -14h
.text$mn:00001C44 var_4           = dword ptr -4
.text$mn:00001C44
.text$mn:00001C44                 push    ebp
.text$mn:00001C45                 mov     ebp, esp
.text$mn:00001C47                 sub     esp, 18h
.text$mn:00001C4A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C4F                 xor     eax, ebp
.text$mn:00001C51                 mov     [ebp+var_4], eax
.text$mn:00001C54                 mov     [ebp+var_18], ecx
.text$mn:00001C57                 lea     eax, [ebp+Rect]
.text$mn:00001C5A                 push    eax             ; lpRect
.text$mn:00001C5B                 mov     ecx, [ebp+var_18]
.text$mn:00001C5E                 mov     edx, [ecx+0Ch]
.text$mn:00001C61                 push    edx             ; hWnd
.text$mn:00001C62                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00001C68                 mov     eax, [ebp+Rect.right]
.text$mn:00001C6B                 sub     eax, [ebp+Rect.left]
.text$mn:00001C6E                 mov     ecx, [ebp+var_4]
.text$mn:00001C71                 xor     ecx, ebp
.text$mn:00001C73                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001C78                 mov     esp, ebp
.text$mn:00001C7A                 pop     ebp
.text$mn:00001C7B                 retn
.text$mn:00001C7B ?getWidth@Window@@UBEHXZ endp
.text$mn:00001C7B
.text$mn:00001C7B _text$mn        ends
.text$mn:00001C7B
.text$mn:00001C7C ; ===========================================================================
.text$mn:00001C7C
.text$mn:00001C7C ; Segment type: Pure code
.text$mn:00001C7C ; Segment permissions: Read/Execute
.text$mn:00001C7C _text$mn        segment para public 'CODE' use32
.text$mn:00001C7C                 assume cs:_text$mn
.text$mn:00001C7C                 ;org 1C7Ch
.text$mn:00001C7C ; COMDAT (pick any)
.text$mn:00001C7C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C7C
.text$mn:00001C7C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C7C
.text$mn:00001C7C ; Attributes: bp-based frame
.text$mn:00001C7C
.text$mn:00001C7C ; void __thiscall Window::getWindowRect(Window *this, struct tagRECT *)
.text$mn:00001C7C                 public ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00001C7C ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00001C7C                                         ; DATA XREF: .rdata:000026D8o
.text$mn:00001C7C                                         ; .rdata:0000270Co ...
.text$mn:00001C7C
.text$mn:00001C7C var_4           = dword ptr -4
.text$mn:00001C7C lpRect          = dword ptr  8
.text$mn:00001C7C
.text$mn:00001C7C                 push    ebp
.text$mn:00001C7D                 mov     ebp, esp
.text$mn:00001C7F                 push    ecx
.text$mn:00001C80                 mov     [ebp+var_4], ecx
.text$mn:00001C83                 mov     eax, [ebp+lpRect]
.text$mn:00001C86                 push    eax             ; lpRect
.text$mn:00001C87                 mov     ecx, [ebp+var_4]
.text$mn:00001C8A                 mov     edx, [ecx+0Ch]
.text$mn:00001C8D                 push    edx             ; hWnd
.text$mn:00001C8E                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00001C94                 mov     esp, ebp
.text$mn:00001C96                 pop     ebp
.text$mn:00001C97                 retn    4
.text$mn:00001C97 ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:00001C97
.text$mn:00001C97 ; ---------------------------------------------------------------------------
.text$mn:00001C9A                 align 4
.text$mn:00001C9A _text$mn        ends
.text$mn:00001C9A
.text$mn:00001C9C ; ===========================================================================
.text$mn:00001C9C
.text$mn:00001C9C ; Segment type: Pure code
.text$mn:00001C9C ; Segment permissions: Read/Execute
.text$mn:00001C9C _text$mn        segment para public 'CODE' use32
.text$mn:00001C9C                 assume cs:_text$mn
.text$mn:00001C9C                 ;org 1C9Ch
.text$mn:00001C9C ; COMDAT (pick any)
.text$mn:00001C9C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C9C
.text$mn:00001C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C9C
.text$mn:00001C9C ; Attributes: bp-based frame
.text$mn:00001C9C
.text$mn:00001C9C ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00001C9C                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00001C9C ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00001C9C                                         ; DATA XREF: .rdata:000026BCo
.text$mn:00001C9C                                         ; .rdata:000026F0o ...
.text$mn:00001C9C
.text$mn:00001C9C var_4           = dword ptr -4
.text$mn:00001C9C arg_0           = dword ptr  8
.text$mn:00001C9C arg_4           = dword ptr  0Ch
.text$mn:00001C9C
.text$mn:00001C9C                 push    ebp
.text$mn:00001C9D                 mov     ebp, esp
.text$mn:00001C9F                 push    ecx
.text$mn:00001CA0                 mov     [ebp+var_4], ecx
.text$mn:00001CA3                 mov     eax, [ebp+var_4]
.text$mn:00001CA6                 mov     ecx, [ebp+arg_0]
.text$mn:00001CA9                 mov     [eax+4], ecx
.text$mn:00001CAC                 mov     edx, [ebp+var_4]
.text$mn:00001CAF                 mov     eax, [ebp+arg_4]
.text$mn:00001CB2                 mov     [edx+8], eax
.text$mn:00001CB5                 mov     esp, ebp
.text$mn:00001CB7                 pop     ebp
.text$mn:00001CB8                 retn    8
.text$mn:00001CB8 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00001CB8
.text$mn:00001CB8 ; ---------------------------------------------------------------------------
.text$mn:00001CBB                 align 4
.text$mn:00001CBB _text$mn        ends
.text$mn:00001CBB
.text$mn:00001CBC ; ===========================================================================
.text$mn:00001CBC
.text$mn:00001CBC ; Segment type: Pure code
.text$mn:00001CBC ; Segment permissions: Read/Execute
.text$mn:00001CBC _text$mn        segment para public 'CODE' use32
.text$mn:00001CBC                 assume cs:_text$mn
.text$mn:00001CBC                 ;org 1CBCh
.text$mn:00001CBC ; COMDAT (pick any)
.text$mn:00001CBC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001CBC
.text$mn:00001CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00001CBC
.text$mn:00001CBC ; Attributes: bp-based frame
.text$mn:00001CBC
.text$mn:00001CBC ; bool __thiscall StaticDialog::isCreated(StaticDialog *__hidden this)
.text$mn:00001CBC                 public ?isCreated@StaticDialog@@UBE_NXZ
.text$mn:00001CBC ?isCreated@StaticDialog@@UBE_NXZ proc near
.text$mn:00001CBC                                         ; CODE XREF: StaticDialog::~StaticDialog(void)+39p
.text$mn:00001CBC                                         ; DATA XREF: .rdata:00002720o ...
.text$mn:00001CBC
.text$mn:00001CBC var_8           = dword ptr -8
.text$mn:00001CBC var_4           = dword ptr -4
.text$mn:00001CBC
.text$mn:00001CBC                 push    ebp
.text$mn:00001CBD                 mov     ebp, esp
.text$mn:00001CBF                 sub     esp, 8
.text$mn:00001CC2                 mov     [ebp+var_8], ecx
.text$mn:00001CC5                 mov     eax, [ebp+var_8]
.text$mn:00001CC8                 cmp     dword ptr [eax+0Ch], 0
.text$mn:00001CCC                 jz      short loc_1CD7
.text$mn:00001CCE                 mov     [ebp+var_4], 1
.text$mn:00001CD5                 jmp     short loc_1CDE
.text$mn:00001CD7 ; ---------------------------------------------------------------------------
.text$mn:00001CD7
.text$mn:00001CD7 loc_1CD7:                               ; CODE XREF: StaticDialog::isCreated(void)+10j
.text$mn:00001CD7                 mov     [ebp+var_4], 0
.text$mn:00001CDE
.text$mn:00001CDE loc_1CDE:                               ; CODE XREF: StaticDialog::isCreated(void)+19j
.text$mn:00001CDE                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001CE1                 mov     esp, ebp
.text$mn:00001CE3                 pop     ebp
.text$mn:00001CE4                 retn
.text$mn:00001CE4 ?isCreated@StaticDialog@@UBE_NXZ endp
.text$mn:00001CE4
.text$mn:00001CE4 ; ---------------------------------------------------------------------------
.text$mn:00001CE5                 align 4
.text$mn:00001CE5 _text$mn        ends
.text$mn:00001CE5
.text$mn:00001CE8 ; ===========================================================================
.text$mn:00001CE8
.text$mn:00001CE8 ; Segment type: Pure code
.text$mn:00001CE8 ; Segment permissions: Read/Execute
.text$mn:00001CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001CE8                 assume cs:_text$mn
.text$mn:00001CE8                 ;org 1CE8h
.text$mn:00001CE8 ; COMDAT (pick any)
.text$mn:00001CE8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001CE8
.text$mn:00001CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CE8
.text$mn:00001CE8 ; Attributes: bp-based frame
.text$mn:00001CE8
.text$mn:00001CE8 ; bool __thiscall Window::isVisible(Window *__hidden this)
.text$mn:00001CE8                 public ?isVisible@Window@@UBE_NXZ
.text$mn:00001CE8 ?isVisible@Window@@UBE_NXZ proc near    ; DATA XREF: .rdata:000026E4o
.text$mn:00001CE8                                         ; .rdata:00002718o ...
.text$mn:00001CE8
.text$mn:00001CE8 var_8           = dword ptr -8
.text$mn:00001CE8 var_1           = byte ptr -1
.text$mn:00001CE8
.text$mn:00001CE8                 push    ebp
.text$mn:00001CE9                 mov     ebp, esp
.text$mn:00001CEB                 sub     esp, 8
.text$mn:00001CEE                 mov     [ebp+var_8], ecx
.text$mn:00001CF1                 mov     eax, [ebp+var_8]
.text$mn:00001CF4                 mov     ecx, [eax+0Ch]
.text$mn:00001CF7                 push    ecx             ; hWnd
.text$mn:00001CF8                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:00001CFE                 test    eax, eax
.text$mn:00001D00                 jz      short loc_1D08
.text$mn:00001D02                 mov     [ebp+var_1], 1
.text$mn:00001D06                 jmp     short loc_1D0C
.text$mn:00001D08 ; ---------------------------------------------------------------------------
.text$mn:00001D08
.text$mn:00001D08 loc_1D08:                               ; CODE XREF: Window::isVisible(void)+18j
.text$mn:00001D08                 mov     [ebp+var_1], 0
.text$mn:00001D0C
.text$mn:00001D0C loc_1D0C:                               ; CODE XREF: Window::isVisible(void)+1Ej
.text$mn:00001D0C                 mov     al, [ebp+var_1]
.text$mn:00001D0F                 mov     esp, ebp
.text$mn:00001D11                 pop     ebp
.text$mn:00001D12                 retn
.text$mn:00001D12 ?isVisible@Window@@UBE_NXZ endp
.text$mn:00001D12
.text$mn:00001D12 ; ---------------------------------------------------------------------------
.text$mn:00001D13                 align 4
.text$mn:00001D13 _text$mn        ends
.text$mn:00001D13
.text$mn:00001D14 ; ===========================================================================
.text$mn:00001D14
.text$mn:00001D14 ; Segment type: Pure code
.text$mn:00001D14 ; Segment permissions: Read/Execute
.text$mn:00001D14 _text$mn        segment para public 'CODE' use32
.text$mn:00001D14                 assume cs:_text$mn
.text$mn:00001D14                 ;org 1D14h
.text$mn:00001D14 ; COMDAT (pick any)
.text$mn:00001D14                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001D14
.text$mn:00001D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D14
.text$mn:00001D14 ; Attributes: bp-based frame
.text$mn:00001D14
.text$mn:00001D14 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00001D14                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00001D14 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00001D14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00001D14
.text$mn:00001D14 var_4           = dword ptr -4
.text$mn:00001D14 Str             = dword ptr  8
.text$mn:00001D14
.text$mn:00001D14                 push    ebp
.text$mn:00001D15                 mov     ebp, esp
.text$mn:00001D17                 push    ecx
.text$mn:00001D18                 mov     eax, [ebp+Str]
.text$mn:00001D1B                 movsx   ecx, byte ptr [eax]
.text$mn:00001D1E                 test    ecx, ecx
.text$mn:00001D20                 jnz     short loc_1D2B
.text$mn:00001D22                 mov     [ebp+var_4], 0
.text$mn:00001D29                 jmp     short loc_1D3A
.text$mn:00001D2B ; ---------------------------------------------------------------------------
.text$mn:00001D2B
.text$mn:00001D2B loc_1D2B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00001D2B                 mov     edx, [ebp+Str]
.text$mn:00001D2E                 push    edx             ; Str
.text$mn:00001D2F                 call    _strlen
.text$mn:00001D34                 add     esp, 4
.text$mn:00001D37                 mov     [ebp+var_4], eax
.text$mn:00001D3A
.text$mn:00001D3A loc_1D3A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00001D3A                 mov     eax, [ebp+var_4]
.text$mn:00001D3D                 mov     esp, ebp
.text$mn:00001D3F                 pop     ebp
.text$mn:00001D40                 retn
.text$mn:00001D40 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00001D40
.text$mn:00001D40 ; ---------------------------------------------------------------------------
.text$mn:00001D41                 align 4
.text$mn:00001D41 _text$mn        ends
.text$mn:00001D41
.text$mn:00001D44 ; ===========================================================================
.text$mn:00001D44
.text$mn:00001D44 ; Segment type: Pure code
.text$mn:00001D44 ; Segment permissions: Read/Execute
.text$mn:00001D44 _text$mn        segment para public 'CODE' use32
.text$mn:00001D44                 assume cs:_text$mn
.text$mn:00001D44                 ;org 1D44h
.text$mn:00001D44 ; COMDAT (pick any)
.text$mn:00001D44                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001D44
.text$mn:00001D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D44
.text$mn:00001D44 ; Attributes: bp-based frame
.text$mn:00001D44
.text$mn:00001D44 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00001D44                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00001D44 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00001D44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00001D44
.text$mn:00001D44 var_4           = dword ptr -4
.text$mn:00001D44
.text$mn:00001D44                 push    ebp
.text$mn:00001D45                 mov     ebp, esp
.text$mn:00001D47                 push    ecx
.text$mn:00001D48                 mov     [ebp+var_4], ecx
.text$mn:00001D4B                 mov     eax, [ebp+var_4]
.text$mn:00001D4E                 push    eax
.text$mn:00001D4F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00001D54                 add     esp, 4
.text$mn:00001D57                 mov     esp, ebp
.text$mn:00001D59                 pop     ebp
.text$mn:00001D5A                 retn
.text$mn:00001D5A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00001D5A
.text$mn:00001D5A ; ---------------------------------------------------------------------------
.text$mn:00001D5B                 align 4
.text$mn:00001D5B _text$mn        ends
.text$mn:00001D5B
.text$mn:00001D5C ; ===========================================================================
.text$mn:00001D5C
.text$mn:00001D5C ; Segment type: Pure code
.text$mn:00001D5C ; Segment permissions: Read/Execute
.text$mn:00001D5C _text$mn        segment para public 'CODE' use32
.text$mn:00001D5C                 assume cs:_text$mn
.text$mn:00001D5C                 ;org 1D5Ch
.text$mn:00001D5C ; COMDAT (pick any)
.text$mn:00001D5C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001D5C
.text$mn:00001D5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D5C
.text$mn:00001D5C ; Attributes: bp-based frame
.text$mn:00001D5C
.text$mn:00001D5C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00001D5C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00001D5C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00001D5C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00001D5C
.text$mn:00001D5C var_4           = dword ptr -4
.text$mn:00001D5C
.text$mn:00001D5C                 push    ebp
.text$mn:00001D5D                 mov     ebp, esp
.text$mn:00001D5F                 push    ecx
.text$mn:00001D60                 mov     [ebp+var_4], ecx
.text$mn:00001D63                 or      eax, 0FFFFFFFFh
.text$mn:00001D66                 mov     esp, ebp
.text$mn:00001D68                 pop     ebp
.text$mn:00001D69                 retn
.text$mn:00001D69 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00001D69
.text$mn:00001D69 ; ---------------------------------------------------------------------------
.text$mn:00001D6A                 align 4
.text$mn:00001D6A _text$mn        ends
.text$mn:00001D6A
.text$mn:00001D6C ; ===========================================================================
.text$mn:00001D6C
.text$mn:00001D6C ; Segment type: Pure code
.text$mn:00001D6C ; Segment permissions: Read/Execute
.text$mn:00001D6C _text$mn        segment para public 'CODE' use32
.text$mn:00001D6C                 assume cs:_text$mn
.text$mn:00001D6C                 ;org 1D6Ch
.text$mn:00001D6C ; COMDAT (pick any)
.text$mn:00001D6C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001D6C
.text$mn:00001D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D6C
.text$mn:00001D6C ; Attributes: bp-based frame
.text$mn:00001D6C
.text$mn:00001D6C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00001D6C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00001D6C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00001D6C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00001D6C
.text$mn:00001D6C arg_0           = dword ptr  8
.text$mn:00001D6C
.text$mn:00001D6C                 push    ebp
.text$mn:00001D6D                 mov     ebp, esp
.text$mn:00001D6F                 mov     ecx, [ebp+arg_0]
.text$mn:00001D72                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00001D77                 pop     ebp
.text$mn:00001D78                 retn
.text$mn:00001D78 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00001D78
.text$mn:00001D78 ; ---------------------------------------------------------------------------
.text$mn:00001D79                 align 4
.text$mn:00001D79 _text$mn        ends
.text$mn:00001D79
.text$mn:00001D7C ; ===========================================================================
.text$mn:00001D7C
.text$mn:00001D7C ; Segment type: Pure code
.text$mn:00001D7C ; Segment permissions: Read/Execute
.text$mn:00001D7C _text$mn        segment para public 'CODE' use32
.text$mn:00001D7C                 assume cs:_text$mn
.text$mn:00001D7C                 ;org 1D7Ch
.text$mn:00001D7C ; COMDAT (pick any)
.text$mn:00001D7C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001D7C
.text$mn:00001D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D7C
.text$mn:00001D7C ; Attributes: bp-based frame
.text$mn:00001D7C
.text$mn:00001D7C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00001D7C                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001D7C ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001D7C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00001D7C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00001D7C
.text$mn:00001D7C var_10          = dword ptr -10h
.text$mn:00001D7C var_C           = dword ptr -0Ch
.text$mn:00001D7C var_8           = dword ptr -8
.text$mn:00001D7C var_1           = byte ptr -1
.text$mn:00001D7C
.text$mn:00001D7C                 push    ebp
.text$mn:00001D7D                 mov     ebp, esp
.text$mn:00001D7F                 sub     esp, 10h
.text$mn:00001D82                 mov     [ebp+var_10], ecx
.text$mn:00001D85                 lea     eax, [ebp+var_1]
.text$mn:00001D88                 push    eax
.text$mn:00001D89                 mov     ecx, [ebp+var_10]
.text$mn:00001D8C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001D91                 mov     ecx, eax
.text$mn:00001D93                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00001D98                 mov     [ebp+var_8], eax
.text$mn:00001D9B                 cmp     [ebp+var_8], 1
.text$mn:00001D9F                 ja      short loc_1DAA
.text$mn:00001DA1                 mov     [ebp+var_C], 1
.text$mn:00001DA8                 jmp     short loc_1DB3
.text$mn:00001DAA ; ---------------------------------------------------------------------------
.text$mn:00001DAA
.text$mn:00001DAA loc_1DAA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00001DAA                 mov     ecx, [ebp+var_8]
.text$mn:00001DAD                 sub     ecx, 1
.text$mn:00001DB0                 mov     [ebp+var_C], ecx
.text$mn:00001DB3
.text$mn:00001DB3 loc_1DB3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00001DB3                 mov     eax, [ebp+var_C]
.text$mn:00001DB6                 mov     esp, ebp
.text$mn:00001DB8                 pop     ebp
.text$mn:00001DB9                 retn
.text$mn:00001DB9 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001DB9
.text$mn:00001DB9 ; ---------------------------------------------------------------------------
.text$mn:00001DBA                 align 4
.text$mn:00001DBA _text$mn        ends
.text$mn:00001DBA
.text$mn:00001DBC ; ===========================================================================
.text$mn:00001DBC
.text$mn:00001DBC ; Segment type: Pure code
.text$mn:00001DBC ; Segment permissions: Read/Execute
.text$mn:00001DBC _text$mn        segment para public 'CODE' use32
.text$mn:00001DBC                 assume cs:_text$mn
.text$mn:00001DBC                 ;org 1DBCh
.text$mn:00001DBC ; COMDAT (pick any)
.text$mn:00001DBC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001DBC
.text$mn:00001DBC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DBC
.text$mn:00001DBC ; Attributes: bp-based frame
.text$mn:00001DBC
.text$mn:00001DBC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00001DBC                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001DBC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001DBC                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00001DBC                                         ; DATA XREF: .rdata:000027A4o
.text$mn:00001DBC
.text$mn:00001DBC var_1C          = dword ptr -1Ch
.text$mn:00001DBC var_18          = dword ptr -18h
.text$mn:00001DBC Str             = dword ptr -14h
.text$mn:00001DBC var_10          = dword ptr -10h
.text$mn:00001DBC var_C           = dword ptr -0Ch
.text$mn:00001DBC var_4           = dword ptr -4
.text$mn:00001DBC arg_0           = dword ptr  8
.text$mn:00001DBC arg_4           = dword ptr  0Ch
.text$mn:00001DBC
.text$mn:00001DBC                 push    ebp
.text$mn:00001DBD                 mov     ebp, esp
.text$mn:00001DBF                 push    0FFFFFFFFh
.text$mn:00001DC1                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001DC6                 mov     eax, large fs:0
.text$mn:00001DCC                 push    eax
.text$mn:00001DCD                 sub     esp, 10h
.text$mn:00001DD0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001DD5                 xor     eax, ebp
.text$mn:00001DD7                 push    eax
.text$mn:00001DD8                 lea     eax, [ebp+var_C]
.text$mn:00001DDB                 mov     large fs:0, eax
.text$mn:00001DE1                 mov     [ebp+var_1C], ecx
.text$mn:00001DE4                 mov     [ebp+var_18], 0
.text$mn:00001DEB                 mov     eax, [ebp+arg_4]
.text$mn:00001DEE                 push    eax             ; int
.text$mn:00001DEF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001DF4                 add     esp, 4
.text$mn:00001DF7                 mov     [ebp+var_10], eax
.text$mn:00001DFA                 cmp     [ebp+var_10], 0
.text$mn:00001DFE                 jz      short loc_1E08
.text$mn:00001E00                 mov     ecx, [ebp+var_10]
.text$mn:00001E03                 mov     [ebp+Str], ecx
.text$mn:00001E06                 jmp     short loc_1E0F
.text$mn:00001E08 ; ---------------------------------------------------------------------------
.text$mn:00001E08
.text$mn:00001E08 loc_1E08:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00001E08                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001E0F
.text$mn:00001E0F loc_1E0F:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00001E0F                 mov     edx, [ebp+Str]
.text$mn:00001E12                 push    edx             ; Str
.text$mn:00001E13                 mov     ecx, [ebp+arg_0]
.text$mn:00001E16                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001E1B                 mov     [ebp+var_4], 0
.text$mn:00001E22                 mov     eax, [ebp+var_18]
.text$mn:00001E25                 or      eax, 1
.text$mn:00001E28                 mov     [ebp+var_18], eax
.text$mn:00001E2B                 mov     eax, [ebp+arg_0]
.text$mn:00001E2E                 mov     ecx, [ebp+var_C]
.text$mn:00001E31                 mov     large fs:0, ecx
.text$mn:00001E38                 pop     ecx
.text$mn:00001E39                 mov     esp, ebp
.text$mn:00001E3B                 pop     ebp
.text$mn:00001E3C                 retn    8
.text$mn:00001E3C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001E3C
.text$mn:00001E3C ; ---------------------------------------------------------------------------
.text$mn:00001E3F                 align 10h
.text$mn:00001E3F _text$mn        ends
.text$mn:00001E3F
.text$x:00001E40 ; ===========================================================================
.text$x:00001E40
.text$x:00001E40 ; Segment type: Pure code
.text$x:00001E40 ; Segment permissions: Read/Execute
.text$x:00001E40 _text$x         segment para public 'CODE' use32
.text$x:00001E40                 assume cs:_text$x
.text$x:00001E40                 ;org 1E40h
.text$x:00001E40 ; COMDAT (pick associative to section at 1DBC)
.text$x:00001E40                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001E40
.text$x:00001E40 ; =============== S U B R O U T I N E =======================================
.text$x:00001E40
.text$x:00001E40
.text$x:00001E40 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001E40                                         ; DATA XREF: .xdata$x:00002438o
.text$x:00001E40                 mov     eax, [ebp-18h]
.text$x:00001E43                 and     eax, 1
.text$x:00001E46                 jz      $LN6
.text$x:00001E4C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001E50                 mov     ecx, [ebp+8]
.text$x:00001E53                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001E58 ; ---------------------------------------------------------------------------
.text$x:00001E58
.text$x:00001E58 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001E58                 retn
.text$x:00001E58 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001E58
.text$x:00001E59
.text$x:00001E59 ; =============== S U B R O U T I N E =======================================
.text$x:00001E59
.text$x:00001E59
.text$x:00001E59 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001E59                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00001E59
.text$x:00001E59 arg_4           = dword ptr  8
.text$x:00001E59
.text$x:00001E59                 mov     edx, [esp+arg_4]
.text$x:00001E5D                 lea     eax, [edx+0Ch]
.text$x:00001E60                 mov     ecx, [edx-14h]
.text$x:00001E63                 xor     ecx, eax
.text$x:00001E65                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E6A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001E6F                 jmp     ___CxxFrameHandler3
.text$x:00001E6F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001E6F
.text$x:00001E6F _text$x         ends
.text$x:00001E6F
.text$mn:00001E74 ; ===========================================================================
.text$mn:00001E74
.text$mn:00001E74 ; Segment type: Pure code
.text$mn:00001E74 ; Segment permissions: Read/Execute
.text$mn:00001E74 _text$mn        segment para public 'CODE' use32
.text$mn:00001E74                 assume cs:_text$mn
.text$mn:00001E74                 ;org 1E74h
.text$mn:00001E74 ; COMDAT (pick any)
.text$mn:00001E74                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001E74
.text$mn:00001E74 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E74
.text$mn:00001E74 ; Attributes: bp-based frame
.text$mn:00001E74
.text$mn:00001E74 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00001E74                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001E74 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001E74                                         ; DATA XREF: .rdata:000027D8o
.text$mn:00001E74
.text$mn:00001E74 var_14          = dword ptr -14h
.text$mn:00001E74 var_10          = dword ptr -10h
.text$mn:00001E74 var_C           = dword ptr -0Ch
.text$mn:00001E74 var_4           = dword ptr -4
.text$mn:00001E74 arg_0           = dword ptr  8
.text$mn:00001E74 arg_4           = dword ptr  0Ch
.text$mn:00001E74
.text$mn:00001E74                 push    ebp
.text$mn:00001E75                 mov     ebp, esp
.text$mn:00001E77                 push    0FFFFFFFFh
.text$mn:00001E79                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001E7E                 mov     eax, large fs:0
.text$mn:00001E84                 push    eax
.text$mn:00001E85                 sub     esp, 8
.text$mn:00001E88                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001E8D                 xor     eax, ebp
.text$mn:00001E8F                 push    eax
.text$mn:00001E90                 lea     eax, [ebp+var_C]
.text$mn:00001E93                 mov     large fs:0, eax
.text$mn:00001E99                 mov     [ebp+var_14], ecx
.text$mn:00001E9C                 mov     [ebp+var_10], 0
.text$mn:00001EA3                 cmp     [ebp+arg_4], 1
.text$mn:00001EA7                 jnz     short loc_1ECD
.text$mn:00001EA9                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00001EAE                 mov     ecx, [ebp+arg_0]
.text$mn:00001EB1                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001EB6                 mov     [ebp+var_4], 0
.text$mn:00001EBD                 mov     eax, [ebp+var_10]
.text$mn:00001EC0                 or      eax, 1
.text$mn:00001EC3                 mov     [ebp+var_10], eax
.text$mn:00001EC6                 mov     eax, [ebp+arg_0]
.text$mn:00001EC9                 jmp     short loc_1EF0
.text$mn:00001ECB ; ---------------------------------------------------------------------------
.text$mn:00001ECB                 jmp     short loc_1EF0
.text$mn:00001ECD ; ---------------------------------------------------------------------------
.text$mn:00001ECD
.text$mn:00001ECD loc_1ECD:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00001ECD                 mov     ecx, [ebp+arg_4]
.text$mn:00001ED0                 push    ecx
.text$mn:00001ED1                 mov     edx, [ebp+arg_0]
.text$mn:00001ED4                 push    edx
.text$mn:00001ED5                 mov     ecx, [ebp+var_14]
.text$mn:00001ED8                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00001EDD                 mov     [ebp+var_4], 0
.text$mn:00001EE4                 mov     eax, [ebp+var_10]
.text$mn:00001EE7                 or      eax, 1
.text$mn:00001EEA                 mov     [ebp+var_10], eax
.text$mn:00001EED                 mov     eax, [ebp+arg_0]
.text$mn:00001EF0
.text$mn:00001EF0 loc_1EF0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00001EF0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00001EF0                 mov     ecx, [ebp+var_C]
.text$mn:00001EF3                 mov     large fs:0, ecx
.text$mn:00001EFA                 pop     ecx
.text$mn:00001EFB                 mov     esp, ebp
.text$mn:00001EFD                 pop     ebp
.text$mn:00001EFE                 retn    8
.text$mn:00001EFE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001EFE
.text$mn:00001EFE ; ---------------------------------------------------------------------------
.text$mn:00001F01                 align 4
.text$mn:00001F01 _text$mn        ends
.text$mn:00001F01
.text$x:00001F04 ; ===========================================================================
.text$x:00001F04
.text$x:00001F04 ; Segment type: Pure code
.text$x:00001F04 ; Segment permissions: Read/Execute
.text$x:00001F04 _text$x         segment para public 'CODE' use32
.text$x:00001F04                 assume cs:_text$x
.text$x:00001F04                 ;org 1F04h
.text$x:00001F04 ; COMDAT (pick associative to section at 1E74)
.text$x:00001F04                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001F04
.text$x:00001F04 ; =============== S U B R O U T I N E =======================================
.text$x:00001F04
.text$x:00001F04
.text$x:00001F04 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001F04                                         ; DATA XREF: .xdata$x:000024BCo
.text$x:00001F04                 mov     eax, [ebp-10h]
.text$x:00001F07                 and     eax, 1
.text$x:00001F0A                 jz      $LN6_0
.text$x:00001F10                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001F14                 mov     ecx, [ebp+8]
.text$x:00001F17                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001F1C ; ---------------------------------------------------------------------------
.text$x:00001F1C
.text$x:00001F1C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001F1C                 retn
.text$x:00001F1C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001F1C
.text$x:00001F1D
.text$x:00001F1D ; =============== S U B R O U T I N E =======================================
.text$x:00001F1D
.text$x:00001F1D
.text$x:00001F1D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001F1D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00001F1D
.text$x:00001F1D arg_4           = dword ptr  8
.text$x:00001F1D
.text$x:00001F1D                 mov     edx, [esp+arg_4]
.text$x:00001F21                 lea     eax, [edx+0Ch]
.text$x:00001F24                 mov     ecx, [edx-0Ch]
.text$x:00001F27                 xor     ecx, eax
.text$x:00001F29                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001F2E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001F33                 jmp     ___CxxFrameHandler3
.text$x:00001F33 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001F33
.text$x:00001F33 _text$x         ends
.text$x:00001F33
.text$mn:00001F38 ; ===========================================================================
.text$mn:00001F38
.text$mn:00001F38 ; Segment type: Pure code
.text$mn:00001F38 ; Segment permissions: Read/Execute
.text$mn:00001F38 _text$mn        segment para public 'CODE' use32
.text$mn:00001F38                 assume cs:_text$mn
.text$mn:00001F38                 ;org 1F38h
.text$mn:00001F38 ; COMDAT (pick any)
.text$mn:00001F38                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001F38
.text$mn:00001F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F38
.text$mn:00001F38 ; Attributes: bp-based frame
.text$mn:00001F38
.text$mn:00001F38 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00001F38                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001F38 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001F38                                         ; DATA XREF: .rdata:00002818o
.text$mn:00001F38
.text$mn:00001F38 var_1C          = dword ptr -1Ch
.text$mn:00001F38 var_18          = dword ptr -18h
.text$mn:00001F38 Str             = dword ptr -14h
.text$mn:00001F38 var_10          = dword ptr -10h
.text$mn:00001F38 var_C           = dword ptr -0Ch
.text$mn:00001F38 var_4           = dword ptr -4
.text$mn:00001F38 arg_0           = dword ptr  8
.text$mn:00001F38 arg_4           = dword ptr  0Ch
.text$mn:00001F38
.text$mn:00001F38                 push    ebp
.text$mn:00001F39                 mov     ebp, esp
.text$mn:00001F3B                 push    0FFFFFFFFh
.text$mn:00001F3D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001F42                 mov     eax, large fs:0
.text$mn:00001F48                 push    eax
.text$mn:00001F49                 sub     esp, 10h
.text$mn:00001F4C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F51                 xor     eax, ebp
.text$mn:00001F53                 push    eax
.text$mn:00001F54                 lea     eax, [ebp+var_C]
.text$mn:00001F57                 mov     large fs:0, eax
.text$mn:00001F5D                 mov     [ebp+var_1C], ecx
.text$mn:00001F60                 mov     [ebp+var_18], 0
.text$mn:00001F67                 mov     eax, [ebp+arg_4]
.text$mn:00001F6A                 push    eax             ; int
.text$mn:00001F6B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00001F70                 add     esp, 4
.text$mn:00001F73                 mov     [ebp+var_10], eax
.text$mn:00001F76                 cmp     [ebp+var_10], 0
.text$mn:00001F7A                 jz      short loc_1F84
.text$mn:00001F7C                 mov     ecx, [ebp+var_10]
.text$mn:00001F7F                 mov     [ebp+Str], ecx
.text$mn:00001F82                 jmp     short loc_1F8B
.text$mn:00001F84 ; ---------------------------------------------------------------------------
.text$mn:00001F84
.text$mn:00001F84 loc_1F84:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00001F84                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001F8B
.text$mn:00001F8B loc_1F8B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00001F8B                 mov     edx, [ebp+Str]
.text$mn:00001F8E                 push    edx             ; Str
.text$mn:00001F8F                 mov     ecx, [ebp+arg_0]
.text$mn:00001F92                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001F97                 mov     [ebp+var_4], 0
.text$mn:00001F9E                 mov     eax, [ebp+var_18]
.text$mn:00001FA1                 or      eax, 1
.text$mn:00001FA4                 mov     [ebp+var_18], eax
.text$mn:00001FA7                 mov     eax, [ebp+arg_0]
.text$mn:00001FAA                 mov     ecx, [ebp+var_C]
.text$mn:00001FAD                 mov     large fs:0, ecx
.text$mn:00001FB4                 pop     ecx
.text$mn:00001FB5                 mov     esp, ebp
.text$mn:00001FB7                 pop     ebp
.text$mn:00001FB8                 retn    8
.text$mn:00001FB8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001FB8
.text$mn:00001FB8 ; ---------------------------------------------------------------------------
.text$mn:00001FBB                 align 4
.text$mn:00001FBB _text$mn        ends
.text$mn:00001FBB
.text$x:00001FBC ; ===========================================================================
.text$x:00001FBC
.text$x:00001FBC ; Segment type: Pure code
.text$x:00001FBC ; Segment permissions: Read/Execute
.text$x:00001FBC _text$x         segment para public 'CODE' use32
.text$x:00001FBC                 assume cs:_text$x
.text$x:00001FBC                 ;org 1FBCh
.text$x:00001FBC ; COMDAT (pick associative to section at 1F38)
.text$x:00001FBC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001FBC
.text$x:00001FBC ; =============== S U B R O U T I N E =======================================
.text$x:00001FBC
.text$x:00001FBC
.text$x:00001FBC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001FBC                                         ; DATA XREF: .xdata$x:00002540o
.text$x:00001FBC                 mov     eax, [ebp-18h]
.text$x:00001FBF                 and     eax, 1
.text$x:00001FC2                 jz      $LN6_1
.text$x:00001FC8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001FCC                 mov     ecx, [ebp+8]
.text$x:00001FCF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001FD4 ; ---------------------------------------------------------------------------
.text$x:00001FD4
.text$x:00001FD4 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001FD4                 retn
.text$x:00001FD4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001FD4
.text$x:00001FD5
.text$x:00001FD5 ; =============== S U B R O U T I N E =======================================
.text$x:00001FD5
.text$x:00001FD5
.text$x:00001FD5 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001FD5                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00001FD5
.text$x:00001FD5 arg_4           = dword ptr  8
.text$x:00001FD5
.text$x:00001FD5                 mov     edx, [esp+arg_4]
.text$x:00001FD9                 lea     eax, [edx+0Ch]
.text$x:00001FDC                 mov     ecx, [edx-14h]
.text$x:00001FDF                 xor     ecx, eax
.text$x:00001FE1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001FE6                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001FEB                 jmp     ___CxxFrameHandler3
.text$x:00001FEB __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001FEB
.text$x:00001FEB _text$x         ends
.text$x:00001FEB
.text$mn:00001FF0 ; ===========================================================================
.text$mn:00001FF0
.text$mn:00001FF0 ; Segment type: Pure code
.text$mn:00001FF0 ; Segment permissions: Read/Execute
.text$mn:00001FF0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FF0                 assume cs:_text$mn
.text$mn:00001FF0                 ;org 1FF0h
.text$mn:00001FF0 ; COMDAT (pick any)
.text$mn:00001FF0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001FF0
.text$mn:00001FF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FF0
.text$mn:00001FF0 ; Attributes: bp-based frame
.text$mn:00001FF0
.text$mn:00001FF0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00001FF0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001FF0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00001FF0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00001FF0
.text$mn:00001FF0 var_4           = dword ptr -4
.text$mn:00001FF0 Dst             = dword ptr  8
.text$mn:00001FF0 Src             = dword ptr  0Ch
.text$mn:00001FF0 Size            = dword ptr  10h
.text$mn:00001FF0
.text$mn:00001FF0                 push    ebp
.text$mn:00001FF1                 mov     ebp, esp
.text$mn:00001FF3                 push    ecx
.text$mn:00001FF4                 cmp     [ebp+Size], 0
.text$mn:00001FF8                 jnz     short loc_2002
.text$mn:00001FFA                 mov     eax, [ebp+Dst]
.text$mn:00001FFD                 mov     [ebp+var_4], eax
.text$mn:00002000                 jmp     short loc_2019
.text$mn:00002002 ; ---------------------------------------------------------------------------
.text$mn:00002002
.text$mn:00002002 loc_2002:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00002002                 mov     ecx, [ebp+Size]
.text$mn:00002005                 push    ecx             ; Size
.text$mn:00002006                 mov     edx, [ebp+Src]
.text$mn:00002009                 push    edx             ; Src
.text$mn:0000200A                 mov     eax, [ebp+Dst]
.text$mn:0000200D                 push    eax             ; Dst
.text$mn:0000200E                 call    _memmove
.text$mn:00002013                 add     esp, 0Ch
.text$mn:00002016                 mov     [ebp+var_4], eax
.text$mn:00002019
.text$mn:00002019 loc_2019:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002019                 mov     eax, [ebp+var_4]
.text$mn:0000201C                 mov     esp, ebp
.text$mn:0000201E                 pop     ebp
.text$mn:0000201F                 retn
.text$mn:0000201F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000201F
.text$mn:0000201F _text$mn        ends
.text$mn:0000201F
.text$mn:00002020 ; ===========================================================================
.text$mn:00002020
.text$mn:00002020 ; Segment type: Pure code
.text$mn:00002020 ; Segment permissions: Read/Execute
.text$mn:00002020 _text$mn        segment para public 'CODE' use32
.text$mn:00002020                 assume cs:_text$mn
.text$mn:00002020                 ;org 2020h
.text$mn:00002020 ; COMDAT (pick any)
.text$mn:00002020                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002020
.text$mn:00002020 ; =============== S U B R O U T I N E =======================================
.text$mn:00002020
.text$mn:00002020 ; Attributes: bp-based frame
.text$mn:00002020
.text$mn:00002020 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002020                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002020 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002020                                         ; DATA XREF: .rdata:000027A0o
.text$mn:00002020
.text$mn:00002020 var_4           = dword ptr -4
.text$mn:00002020
.text$mn:00002020                 push    ebp
.text$mn:00002021                 mov     ebp, esp
.text$mn:00002023                 push    ecx
.text$mn:00002024                 mov     [ebp+var_4], ecx
.text$mn:00002027                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000202C                 mov     esp, ebp
.text$mn:0000202E                 pop     ebp
.text$mn:0000202F                 retn
.text$mn:0000202F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000202F
.text$mn:0000202F _text$mn        ends
.text$mn:0000202F
.text$mn:00002030 ; ===========================================================================
.text$mn:00002030
.text$mn:00002030 ; Segment type: Pure code
.text$mn:00002030 ; Segment permissions: Read/Execute
.text$mn:00002030 _text$mn        segment para public 'CODE' use32
.text$mn:00002030                 assume cs:_text$mn
.text$mn:00002030                 ;org 2030h
.text$mn:00002030 ; COMDAT (pick any)
.text$mn:00002030                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002030
.text$mn:00002030 ; =============== S U B R O U T I N E =======================================
.text$mn:00002030
.text$mn:00002030 ; Attributes: bp-based frame
.text$mn:00002030
.text$mn:00002030 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002030                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002030 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002030                                         ; DATA XREF: .rdata:000027D4o
.text$mn:00002030
.text$mn:00002030 var_4           = dword ptr -4
.text$mn:00002030
.text$mn:00002030                 push    ebp
.text$mn:00002031                 mov     ebp, esp
.text$mn:00002033                 push    ecx
.text$mn:00002034                 mov     [ebp+var_4], ecx
.text$mn:00002037                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000203C                 mov     esp, ebp
.text$mn:0000203E                 pop     ebp
.text$mn:0000203F                 retn
.text$mn:0000203F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000203F
.text$mn:0000203F _text$mn        ends
.text$mn:0000203F
.text$mn:00002040 ; ===========================================================================
.text$mn:00002040
.text$mn:00002040 ; Segment type: Pure code
.text$mn:00002040 ; Segment permissions: Read/Execute
.text$mn:00002040 _text$mn        segment para public 'CODE' use32
.text$mn:00002040                 assume cs:_text$mn
.text$mn:00002040                 ;org 2040h
.text$mn:00002040 ; COMDAT (pick any)
.text$mn:00002040                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002040
.text$mn:00002040 ; =============== S U B R O U T I N E =======================================
.text$mn:00002040
.text$mn:00002040 ; Attributes: bp-based frame
.text$mn:00002040
.text$mn:00002040 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002040                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002040 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002040                                         ; DATA XREF: .rdata:00002814o
.text$mn:00002040
.text$mn:00002040 var_4           = dword ptr -4
.text$mn:00002040
.text$mn:00002040                 push    ebp
.text$mn:00002041                 mov     ebp, esp
.text$mn:00002043                 push    ecx
.text$mn:00002044                 mov     [ebp+var_4], ecx
.text$mn:00002047                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000204C                 mov     esp, ebp
.text$mn:0000204E                 pop     ebp
.text$mn:0000204F                 retn
.text$mn:0000204F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000204F
.text$mn:0000204F _text$mn        ends
.text$mn:0000204F
.text$mn:00002050 ; ===========================================================================
.text$mn:00002050
.text$mn:00002050 ; Segment type: Pure code
.text$mn:00002050 ; Segment permissions: Read/Execute
.text$mn:00002050 _text$mn        segment para public 'CODE' use32
.text$mn:00002050                 assume cs:_text$mn
.text$mn:00002050                 ;org 2050h
.text$mn:00002050 ; COMDAT (pick any)
.text$mn:00002050                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002050
.text$mn:00002050 ; =============== S U B R O U T I N E =======================================
.text$mn:00002050
.text$mn:00002050 ; Attributes: bp-based frame
.text$mn:00002050
.text$mn:00002050 ; void __thiscall Window::reSizeTo(Window *this, struct tagRECT *)
.text$mn:00002050                 public ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z
.text$mn:00002050 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:00002050                                         ; DATA XREF: .rdata:000026C8o
.text$mn:00002050                                         ; .rdata:000026FCo ...
.text$mn:00002050
.text$mn:00002050 var_4           = dword ptr -4
.text$mn:00002050 arg_0           = dword ptr  8
.text$mn:00002050
.text$mn:00002050                 push    ebp
.text$mn:00002051                 mov     ebp, esp
.text$mn:00002053                 push    ecx
.text$mn:00002054                 mov     [ebp+var_4], ecx
.text$mn:00002057                 push    1               ; bRepaint
.text$mn:00002059                 mov     eax, [ebp+arg_0]
.text$mn:0000205C                 mov     ecx, [eax+0Ch]
.text$mn:0000205F                 push    ecx             ; nHeight
.text$mn:00002060                 mov     edx, [ebp+arg_0]
.text$mn:00002063                 mov     eax, [edx+8]
.text$mn:00002066                 push    eax             ; nWidth
.text$mn:00002067                 mov     ecx, [ebp+arg_0]
.text$mn:0000206A                 mov     edx, [ecx+4]
.text$mn:0000206D                 push    edx             ; Y
.text$mn:0000206E                 mov     eax, [ebp+arg_0]
.text$mn:00002071                 mov     ecx, [eax]
.text$mn:00002073                 push    ecx             ; X
.text$mn:00002074                 mov     edx, [ebp+var_4]
.text$mn:00002077                 mov     eax, [edx+0Ch]
.text$mn:0000207A                 push    eax             ; hWnd
.text$mn:0000207B                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00002081                 push    0
.text$mn:00002083                 mov     ecx, [ebp+var_4]
.text$mn:00002086                 mov     edx, [ecx]
.text$mn:00002088                 mov     ecx, [ebp+var_4]
.text$mn:0000208B                 mov     eax, [edx+18h]
.text$mn:0000208E                 call    eax
.text$mn:00002090                 mov     esp, ebp
.text$mn:00002092                 pop     ebp
.text$mn:00002093                 retn    4
.text$mn:00002093 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:00002093
.text$mn:00002093 ; ---------------------------------------------------------------------------
.text$mn:00002096                 align 4
.text$mn:00002096 _text$mn        ends
.text$mn:00002096
.text$mn:00002098 ; ===========================================================================
.text$mn:00002098
.text$mn:00002098 ; Segment type: Pure code
.text$mn:00002098 ; Segment permissions: Read/Execute
.text$mn:00002098 _text$mn        segment para public 'CODE' use32
.text$mn:00002098                 assume cs:_text$mn
.text$mn:00002098                 ;org 2098h
.text$mn:00002098 ; COMDAT (pick any)
.text$mn:00002098                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002098
.text$mn:00002098 ; =============== S U B R O U T I N E =======================================
.text$mn:00002098
.text$mn:00002098 ; Attributes: bp-based frame
.text$mn:00002098
.text$mn:00002098 ; void __thiscall Window::reSizeToWH(Window *this, struct tagRECT *)
.text$mn:00002098                 public ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z
.text$mn:00002098 ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:00002098                                         ; DATA XREF: .rdata:000026CCo
.text$mn:00002098                                         ; .rdata:00002700o ...
.text$mn:00002098
.text$mn:00002098 var_4           = dword ptr -4
.text$mn:00002098 arg_0           = dword ptr  8
.text$mn:00002098
.text$mn:00002098                 push    ebp
.text$mn:00002099                 mov     ebp, esp
.text$mn:0000209B                 push    ecx
.text$mn:0000209C                 mov     [ebp+var_4], ecx
.text$mn:0000209F                 push    1               ; bRepaint
.text$mn:000020A1                 mov     eax, [ebp+arg_0]
.text$mn:000020A4                 mov     ecx, [ebp+arg_0]
.text$mn:000020A7                 mov     edx, [eax+0Ch]
.text$mn:000020AA                 sub     edx, [ecx+4]
.text$mn:000020AD                 push    edx             ; nHeight
.text$mn:000020AE                 mov     eax, [ebp+arg_0]
.text$mn:000020B1                 mov     ecx, [ebp+arg_0]
.text$mn:000020B4                 mov     edx, [eax+8]
.text$mn:000020B7                 sub     edx, [ecx]
.text$mn:000020B9                 push    edx             ; nWidth
.text$mn:000020BA                 mov     eax, [ebp+arg_0]
.text$mn:000020BD                 mov     ecx, [eax+4]
.text$mn:000020C0                 push    ecx             ; Y
.text$mn:000020C1                 mov     edx, [ebp+arg_0]
.text$mn:000020C4                 mov     eax, [edx]
.text$mn:000020C6                 push    eax             ; X
.text$mn:000020C7                 mov     ecx, [ebp+var_4]
.text$mn:000020CA                 mov     edx, [ecx+0Ch]
.text$mn:000020CD                 push    edx             ; hWnd
.text$mn:000020CE                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:000020D4                 push    0
.text$mn:000020D6                 mov     eax, [ebp+var_4]
.text$mn:000020D9                 mov     edx, [eax]
.text$mn:000020DB                 mov     ecx, [ebp+var_4]
.text$mn:000020DE                 mov     eax, [edx+18h]
.text$mn:000020E1                 call    eax
.text$mn:000020E3                 mov     esp, ebp
.text$mn:000020E5                 pop     ebp
.text$mn:000020E6                 retn    4
.text$mn:000020E6 ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:000020E6
.text$mn:000020E6 ; ---------------------------------------------------------------------------
.text$mn:000020E9                 align 4
.text$mn:000020E9 _text$mn        ends
.text$mn:000020E9
.text$mn:000020EC ; ===========================================================================
.text$mn:000020EC
.text$mn:000020EC ; Segment type: Pure code
.text$mn:000020EC ; Segment permissions: Read/Execute
.text$mn:000020EC _text$mn        segment para public 'CODE' use32
.text$mn:000020EC                 assume cs:_text$mn
.text$mn:000020EC                 ;org 20ECh
.text$mn:000020EC ; COMDAT (pick any)
.text$mn:000020EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000020EC
.text$mn:000020EC ; =============== S U B R O U T I N E =======================================
.text$mn:000020EC
.text$mn:000020EC ; Attributes: bp-based frame
.text$mn:000020EC
.text$mn:000020EC ; void __thiscall Window::redraw(Window *this, bool)
.text$mn:000020EC                 public ?redraw@Window@@UBEX_N@Z
.text$mn:000020EC ?redraw@Window@@UBEX_N@Z proc near      ; DATA XREF: .rdata:000026D0o
.text$mn:000020EC                                         ; .rdata:00002704o ...
.text$mn:000020EC
.text$mn:000020EC var_4           = dword ptr -4
.text$mn:000020EC arg_0           = byte ptr  8
.text$mn:000020EC
.text$mn:000020EC                 push    ebp
.text$mn:000020ED                 mov     ebp, esp
.text$mn:000020EF                 push    ecx
.text$mn:000020F0                 mov     [ebp+var_4], ecx
.text$mn:000020F3                 push    1               ; bErase
.text$mn:000020F5                 push    0               ; lpRect
.text$mn:000020F7                 mov     eax, [ebp+var_4]
.text$mn:000020FA                 mov     ecx, [eax+0Ch]
.text$mn:000020FD                 push    ecx             ; hWnd
.text$mn:000020FE                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00002104                 movzx   edx, [ebp+arg_0]
.text$mn:00002108                 test    edx, edx
.text$mn:0000210A                 jz      short loc_2119
.text$mn:0000210C                 mov     eax, [ebp+var_4]
.text$mn:0000210F                 mov     ecx, [eax+0Ch]
.text$mn:00002112                 push    ecx             ; hWnd
.text$mn:00002113                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:00002119
.text$mn:00002119 loc_2119:                               ; CODE XREF: Window::redraw(bool)+1Ej
.text$mn:00002119                 mov     esp, ebp
.text$mn:0000211B                 pop     ebp
.text$mn:0000211C                 retn    4
.text$mn:0000211C ?redraw@Window@@UBEX_N@Z endp
.text$mn:0000211C
.text$mn:0000211C ; ---------------------------------------------------------------------------
.text$mn:0000211F                 align 10h
.text$mn:0000211F _text$mn        ends
.text$mn:0000211F
.text$mn:00002120 ; ===========================================================================
.text$mn:00002120
.text$mn:00002120 ; Segment type: Pure code
.text$mn:00002120 ; Segment permissions: Read/Execute
.text$mn:00002120 _text$mn        segment para public 'CODE' use32
.text$mn:00002120                 assume cs:_text$mn
.text$mn:00002120                 ;org 2120h
.text$mn:00002120 ; COMDAT (pick any)
.text$mn:00002120                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002120
.text$mn:00002120 ; =============== S U B R O U T I N E =======================================
.text$mn:00002120
.text$mn:00002120 ; Attributes: bp-based frame
.text$mn:00002120
.text$mn:00002120 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002120                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002120 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002120                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002120                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002120
.text$mn:00002120 var_4           = dword ptr -4
.text$mn:00002120
.text$mn:00002120                 push    ebp
.text$mn:00002121                 mov     ebp, esp
.text$mn:00002123                 push    ecx
.text$mn:00002124                 mov     [ebp+var_4], ecx
.text$mn:00002127                 mov     eax, [ebp+var_4]
.text$mn:0000212A                 mov     eax, [eax+14h]
.text$mn:0000212D                 mov     esp, ebp
.text$mn:0000212F                 pop     ebp
.text$mn:00002130                 retn
.text$mn:00002130 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002130
.text$mn:00002130 ; ---------------------------------------------------------------------------
.text$mn:00002131                 align 4
.text$mn:00002131 _text$mn        ends
.text$mn:00002131
.text$mn:00002134 ; ===========================================================================
.text$mn:00002134
.text$mn:00002134 ; Segment type: Pure code
.text$mn:00002134 ; Segment permissions: Read/Execute
.text$mn:00002134 _text$mn        segment para public 'CODE' use32
.text$mn:00002134                 assume cs:_text$mn
.text$mn:00002134                 ;org 2134h
.text$mn:00002134 ; COMDAT (pick any)
.text$mn:00002134                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002134
.text$mn:00002134 ; =============== S U B R O U T I N E =======================================
.text$mn:00002134
.text$mn:00002134 ; Attributes: bp-based frame
.text$mn:00002134
.text$mn:00002134 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002134                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002134 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002134                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_19F0p
.text$mn:00002134                 push    ebp
.text$mn:00002135                 mov     ebp, esp
.text$mn:00002137                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:0000213C                 pop     ebp
.text$mn:0000213D                 retn
.text$mn:0000213D ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000213D
.text$mn:0000213D ; ---------------------------------------------------------------------------
.text$mn:0000213E                 align 10h
.text$mn:0000213E _text$mn        ends
.text$mn:0000213E
.text$mn:00002140 ; ===========================================================================
.text$mn:00002140
.text$mn:00002140 ; Segment type: Pure code
.text$mn:00002140 ; Segment permissions: Read/Execute
.text$mn:00002140 _text$mn        segment para public 'CODE' use32
.text$mn:00002140                 assume cs:_text$mn
.text$mn:00002140                 ;org 2140h
.text$mn:00002140 ; COMDAT (pick any)
.text$mn:00002140                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002140
.text$mn:00002140 ; =============== S U B R O U T I N E =======================================
.text$mn:00002140
.text$mn:00002140 ; Attributes: bp-based frame
.text$mn:00002140
.text$mn:00002140 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002140                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002140 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002140
.text$mn:00002140 var_4           = dword ptr -4
.text$mn:00002140
.text$mn:00002140                 push    ebp
.text$mn:00002141                 mov     ebp, esp
.text$mn:00002143                 push    ecx
.text$mn:00002144                 mov     [ebp+var_4], ecx
.text$mn:00002147                 mov     eax, [ebp+var_4]
.text$mn:0000214A                 mov     eax, [eax]
.text$mn:0000214C                 mov     esp, ebp
.text$mn:0000214E                 pop     ebp
.text$mn:0000214F                 retn
.text$mn:0000214F ?value@error_code@std@@QBEHXZ endp
.text$mn:0000214F
.text$mn:0000214F _text$mn        ends
.text$mn:0000214F
.text$mn:00002150 ; ===========================================================================
.text$mn:00002150
.text$mn:00002150 ; Segment type: Pure code
.text$mn:00002150 ; Segment permissions: Read/Execute
.text$mn:00002150 _text$mn        segment para public 'CODE' use32
.text$mn:00002150                 assume cs:_text$mn
.text$mn:00002150                 ;org 2150h
.text$mn:00002150 ; COMDAT (pick any)
.text$mn:00002150                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002150
.text$mn:00002150 ; =============== S U B R O U T I N E =======================================
.text$mn:00002150
.text$mn:00002150 ; Attributes: bp-based frame
.text$mn:00002150
.text$mn:00002150 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002150                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002150 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002150                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002150                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002150
.text$mn:00002150 var_4           = dword ptr -4
.text$mn:00002150
.text$mn:00002150                 push    ebp
.text$mn:00002151                 mov     ebp, esp
.text$mn:00002153                 push    ecx
.text$mn:00002154                 mov     [ebp+var_4], ecx
.text$mn:00002157                 mov     eax, [ebp+var_4]
.text$mn:0000215A                 mov     eax, [eax]
.text$mn:0000215C                 mov     esp, ebp
.text$mn:0000215E                 pop     ebp
.text$mn:0000215F                 retn
.text$mn:0000215F ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000215F
.text$mn:0000215F _text$mn        ends
.text$mn:0000215F
.text$mn:00002160 ; ===========================================================================
.text$mn:00002160
.text$mn:00002160 ; Segment type: Pure code
.text$mn:00002160 ; Segment permissions: Read/Execute
.text$mn:00002160 _text$mn        segment para public 'CODE' use32
.text$mn:00002160                 assume cs:_text$mn
.text$mn:00002160                 ;org 2160h
.text$mn:00002160 ; COMDAT (pick any)
.text$mn:00002160                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00002160
.text$mn:00002160 ; =============== S U B R O U T I N E =======================================
.text$mn:00002160
.text$mn:00002160 ; Attributes: bp-based frame
.text$mn:00002160
.text$mn:00002160                 public _hypot
.text$mn:00002160 _hypot          proc near
.text$mn:00002160
.text$mn:00002160 var_10          = qword ptr -10h
.text$mn:00002160 var_8           = qword ptr -8
.text$mn:00002160 arg_0           = qword ptr  8
.text$mn:00002160 arg_8           = qword ptr  10h
.text$mn:00002160
.text$mn:00002160                 push    ebp
.text$mn:00002161                 mov     ebp, esp
.text$mn:00002163                 sub     esp, 8
.text$mn:00002166                 movsd   xmm0, [ebp+arg_8]
.text$mn:0000216B                 movsd   [esp+8+var_8], xmm0
.text$mn:00002170                 sub     esp, 8
.text$mn:00002173                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002178                 movsd   [esp+10h+var_10], xmm0
.text$mn:0000217D                 call    __hypot
.text$mn:00002182                 add     esp, 10h
.text$mn:00002185                 pop     ebp
.text$mn:00002186                 retn
.text$mn:00002186 _hypot          endp
.text$mn:00002186
.text$mn:00002186 ; ---------------------------------------------------------------------------
.text$mn:00002187                 align 4
.text$mn:00002187 _text$mn        ends
.text$mn:00002187
.xdata$x:00002188 ; ===========================================================================
.xdata$x:00002188
.xdata$x:00002188 ; Segment type: Pure data
.xdata$x:00002188 ; Segment permissions: Read
.xdata$x:00002188 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002188                 assume cs:_xdata$x
.xdata$x:00002188                 ;org 2188h
.xdata$x:00002188 ; COMDAT (pick associative to section at 6B4)
.xdata$x:00002188 __unwindtable$??0StaticDialog@@QAE@XZ db 0FFh
.xdata$x:00002188                                         ; DATA XREF: .xdata$x:00002198o
.xdata$x:00002189                 db 0FFh
.xdata$x:0000218A                 db 0FFh
.xdata$x:0000218B                 db 0FFh
.xdata$x:0000218C                 dd offset __unwindfunclet$??0StaticDialog@@QAE@XZ$0
.xdata$x:00002190 __ehfuncinfo$??0StaticDialog@@QAE@XZ db  22h ; "
.xdata$x:00002190                                         ; DATA XREF: __ehhandler$??0StaticDialog@@QAE@XZ+11o
.xdata$x:00002191                 db    5
.xdata$x:00002192                 db  93h ; ô
.xdata$x:00002193                 db  19h
.xdata$x:00002194                 db    1
.xdata$x:00002195                 db    0
.xdata$x:00002196                 db    0
.xdata$x:00002197                 db    0
.xdata$x:00002198                 dd offset __unwindtable$??0StaticDialog@@QAE@XZ
.xdata$x:0000219C                 db    0
.xdata$x:0000219D                 db    0
.xdata$x:0000219E                 db    0
.xdata$x:0000219F                 db    0
.xdata$x:000021A0                 db    0
.xdata$x:000021A1                 db    0
.xdata$x:000021A2                 db    0
.xdata$x:000021A3                 db    0
.xdata$x:000021A4                 db    0
.xdata$x:000021A5                 db    0
.xdata$x:000021A6                 db    0
.xdata$x:000021A7                 db    0
.xdata$x:000021A8                 db    0
.xdata$x:000021A9                 db    0
.xdata$x:000021AA                 db    0
.xdata$x:000021AB                 db    0
.xdata$x:000021AC                 db    0
.xdata$x:000021AD                 db    0
.xdata$x:000021AE                 db    0
.xdata$x:000021AF                 db    0
.xdata$x:000021B0                 db    0
.xdata$x:000021B1                 db    0
.xdata$x:000021B2                 db    0
.xdata$x:000021B3                 db    0
.xdata$x:000021B3 _xdata$x        ends
.xdata$x:000021B3
.xdata$x:000021B4 ; ===========================================================================
.xdata$x:000021B4
.xdata$x:000021B4 ; Segment type: Pure data
.xdata$x:000021B4 ; Segment permissions: Read
.xdata$x:000021B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021B4                 assume cs:_xdata$x
.xdata$x:000021B4                 ;org 21B4h
.xdata$x:000021B4 ; COMDAT (pick associative to section at B5C)
.xdata$x:000021B4 __unwindtable$??1StaticDialog@@UAE@XZ db 0FFh
.xdata$x:000021B4                                         ; DATA XREF: .xdata$x:000021C4o
.xdata$x:000021B5                 db 0FFh
.xdata$x:000021B6                 db 0FFh
.xdata$x:000021B7                 db 0FFh
.xdata$x:000021B8                 dd offset __unwindfunclet$??1StaticDialog@@UAE@XZ$0
.xdata$x:000021BC __ehfuncinfo$??1StaticDialog@@UAE@XZ db  22h ; "
.xdata$x:000021BC                                         ; DATA XREF: __ehhandler$??1StaticDialog@@UAE@XZ+11o
.xdata$x:000021BD                 db    5
.xdata$x:000021BE                 db  93h ; ô
.xdata$x:000021BF                 db  19h
.xdata$x:000021C0                 db    1
.xdata$x:000021C1                 db    0
.xdata$x:000021C2                 db    0
.xdata$x:000021C3                 db    0
.xdata$x:000021C4                 dd offset __unwindtable$??1StaticDialog@@UAE@XZ
.xdata$x:000021C8                 align 20h
.xdata$x:000021C8 _xdata$x        ends
.xdata$x:000021C8
.xdata$x:000021E0 ; ===========================================================================
.xdata$x:000021E0
.xdata$x:000021E0 ; Segment type: Pure data
.xdata$x:000021E0 ; Segment permissions: Read
.xdata$x:000021E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021E0                 assume cs:_xdata$x
.xdata$x:000021E0                 ;org 21E0h
.xdata$x:000021E0 __unwindtable$??0SizeableDlg@@QAE@PAVWINRECT@@@Z db 0FFh
.xdata$x:000021E0                                         ; DATA XREF: .xdata$x:000021F8o
.xdata$x:000021E1                 db 0FFh
.xdata$x:000021E2                 db 0FFh
.xdata$x:000021E3                 db 0FFh
.xdata$x:000021E4                 dd offset __unwindfunclet$??0SizeableDlg@@QAE@PAVWINRECT@@@Z$0
.xdata$x:000021E8                 db    0
.xdata$x:000021E9                 db    0
.xdata$x:000021EA                 db    0
.xdata$x:000021EB                 db    0
.xdata$x:000021EC                 dd offset __unwindfunclet$??0SizeableDlg@@QAE@PAVWINRECT@@@Z$1
.xdata$x:000021F0 __ehfuncinfo$??0SizeableDlg@@QAE@PAVWINRECT@@@Z db  22h ; "
.xdata$x:000021F0                                         ; DATA XREF: __ehhandler$??0SizeableDlg@@QAE@PAVWINRECT@@@Z+11o
.xdata$x:000021F1                 db    5
.xdata$x:000021F2                 db  93h ; ô
.xdata$x:000021F3                 db  19h
.xdata$x:000021F4                 db    2
.xdata$x:000021F5                 db    0
.xdata$x:000021F6                 db    0
.xdata$x:000021F7                 db    0
.xdata$x:000021F8                 dd offset __unwindtable$??0SizeableDlg@@QAE@PAVWINRECT@@@Z
.xdata$x:000021FC                 db    0
.xdata$x:000021FD                 db    0
.xdata$x:000021FE                 db    0
.xdata$x:000021FF                 db    0
.xdata$x:00002200                 db    0
.xdata$x:00002201                 db    0
.xdata$x:00002202                 db    0
.xdata$x:00002203                 db    0
.xdata$x:00002204                 db    0
.xdata$x:00002205                 db    0
.xdata$x:00002206                 db    0
.xdata$x:00002207                 db    0
.xdata$x:00002208                 db    0
.xdata$x:00002209                 db    0
.xdata$x:0000220A                 db    0
.xdata$x:0000220B                 db    0
.xdata$x:0000220C                 db    0
.xdata$x:0000220D                 db    0
.xdata$x:0000220E                 db    0
.xdata$x:0000220F                 db    0
.xdata$x:00002210                 db    0
.xdata$x:00002211                 db    0
.xdata$x:00002212                 db    0
.xdata$x:00002213                 db    0
.xdata$x:00002213 _xdata$x        ends
.xdata$x:00002213
.xdata$x:00002214 ; ===========================================================================
.xdata$x:00002214
.xdata$x:00002214 ; Segment type: Pure data
.xdata$x:00002214 ; Segment permissions: Read
.xdata$x:00002214 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002214                 assume cs:_xdata$x
.xdata$x:00002214                 ;org 2214h
.xdata$x:00002214 ; COMDAT (pick associative to section at AD0)
.xdata$x:00002214 __unwindtable$??1SizeableDlg@@UAE@XZ db 0FFh
.xdata$x:00002214                                         ; DATA XREF: .xdata$x:0000222Co
.xdata$x:00002215                 db 0FFh
.xdata$x:00002216                 db 0FFh
.xdata$x:00002217                 db 0FFh
.xdata$x:00002218                 dd offset __unwindfunclet$??1SizeableDlg@@UAE@XZ$0
.xdata$x:0000221C                 align 10h
.xdata$x:00002220                 dd offset __unwindfunclet$??1SizeableDlg@@UAE@XZ$1
.xdata$x:00002224 __ehfuncinfo$??1SizeableDlg@@UAE@XZ db  22h ; "
.xdata$x:00002224                                         ; DATA XREF: __ehhandler$??1SizeableDlg@@UAE@XZ+11o
.xdata$x:00002225                 db    5
.xdata$x:00002226                 db  93h ; ô
.xdata$x:00002227                 db  19h
.xdata$x:00002228                 db    2
.xdata$x:00002229                 db    0
.xdata$x:0000222A                 db    0
.xdata$x:0000222B                 db    0
.xdata$x:0000222C                 dd offset __unwindtable$??1SizeableDlg@@UAE@XZ
.xdata$x:00002230                 db    0
.xdata$x:00002231                 db    0
.xdata$x:00002232                 db    0
.xdata$x:00002233                 db    0
.xdata$x:00002234                 db    0
.xdata$x:00002235                 db    0
.xdata$x:00002236                 db    0
.xdata$x:00002237                 db    0
.xdata$x:00002238                 db    0
.xdata$x:00002239                 db    0
.xdata$x:0000223A                 db    0
.xdata$x:0000223B                 db    0
.xdata$x:0000223C                 db    0
.xdata$x:0000223D                 db    0
.xdata$x:0000223E                 db    0
.xdata$x:0000223F                 db    0
.xdata$x:00002240                 db    0
.xdata$x:00002241                 db    0
.xdata$x:00002242                 db    0
.xdata$x:00002243                 db    0
.xdata$x:00002244                 db    0
.xdata$x:00002245                 db    0
.xdata$x:00002246                 db    0
.xdata$x:00002247                 db    0
.xdata$x:00002247 _xdata$x        ends
.xdata$x:00002247
.xdata$x:00002248 ; ===========================================================================
.xdata$x:00002248
.xdata$x:00002248 ; Segment type: Pure data
.xdata$x:00002248 ; Segment permissions: Read
.xdata$x:00002248 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002248                 assume cs:_xdata$x
.xdata$x:00002248                 ;org 2248h
.xdata$x:00002248 ; COMDAT (pick associative to section at 1594)
.xdata$x:00002248 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002248                                         ; DATA XREF: .xdata$x:00002258o
.xdata$x:00002249                 db 0FFh
.xdata$x:0000224A                 db 0FFh
.xdata$x:0000224B                 db 0FFh
.xdata$x:0000224C                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00002250 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00002250                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00002251                 db    5
.xdata$x:00002252                 db  93h ; ô
.xdata$x:00002253                 db  19h
.xdata$x:00002254                 db    1
.xdata$x:00002255                 db    0
.xdata$x:00002256                 db    0
.xdata$x:00002257                 db    0
.xdata$x:00002258                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:0000225C                 db    0
.xdata$x:0000225D                 db    0
.xdata$x:0000225E                 db    0
.xdata$x:0000225F                 db    0
.xdata$x:00002260                 db    0
.xdata$x:00002261                 db    0
.xdata$x:00002262                 db    0
.xdata$x:00002263                 db    0
.xdata$x:00002264                 db    0
.xdata$x:00002265                 db    0
.xdata$x:00002266                 db    0
.xdata$x:00002267                 db    0
.xdata$x:00002268                 db    0
.xdata$x:00002269                 db    0
.xdata$x:0000226A                 db    0
.xdata$x:0000226B                 db    0
.xdata$x:0000226C                 db    0
.xdata$x:0000226D                 db    0
.xdata$x:0000226E                 db    0
.xdata$x:0000226F                 db    0
.xdata$x:00002270                 db    0
.xdata$x:00002271                 db    0
.xdata$x:00002272                 db    0
.xdata$x:00002273                 db    0
.xdata$x:00002273 _xdata$x        ends
.xdata$x:00002273
.xdata$x:00002274 ; ===========================================================================
.xdata$x:00002274
.xdata$x:00002274 ; Segment type: Pure data
.xdata$x:00002274 ; Segment permissions: Read
.xdata$x:00002274 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002274                 assume cs:_xdata$x
.xdata$x:00002274                 ;org 2274h
.xdata$x:00002274 ; COMDAT (pick associative to section at 55C)
.xdata$x:00002274 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002274                                         ; DATA XREF: .xdata$x:00002284o
.xdata$x:00002275                 db 0FFh
.xdata$x:00002276                 db 0FFh
.xdata$x:00002277                 db 0FFh
.xdata$x:00002278                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000227C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000227C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000227D                 db    5
.xdata$x:0000227E                 db  93h ; ô
.xdata$x:0000227F                 db  19h
.xdata$x:00002280                 db    1
.xdata$x:00002281                 db    0
.xdata$x:00002282                 db    0
.xdata$x:00002283                 db    0
.xdata$x:00002284                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002288                 align 20h
.xdata$x:00002288 _xdata$x        ends
.xdata$x:00002288
.xdata$x:000022A0 ; ===========================================================================
.xdata$x:000022A0
.xdata$x:000022A0 ; Segment type: Pure data
.xdata$x:000022A0 ; Segment permissions: Read
.xdata$x:000022A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000022A0                 assume cs:_xdata$x
.xdata$x:000022A0                 ;org 22A0h
.xdata$x:000022A0 ; COMDAT (pick associative to section at 9E4)
.xdata$x:000022A0 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000022A0                                         ; DATA XREF: .xdata$x:000022B0o
.xdata$x:000022A1                 db 0FFh
.xdata$x:000022A2                 db 0FFh
.xdata$x:000022A3                 db 0FFh
.xdata$x:000022A4                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000022A8 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000022A8                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000022A9                 db    5
.xdata$x:000022AA                 db  93h ; ô
.xdata$x:000022AB                 db  19h
.xdata$x:000022AC                 db    1
.xdata$x:000022AD                 db    0
.xdata$x:000022AE                 db    0
.xdata$x:000022AF                 db    0
.xdata$x:000022B0                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000022B4                 db    0
.xdata$x:000022B5                 db    0
.xdata$x:000022B6                 db    0
.xdata$x:000022B7                 db    0
.xdata$x:000022B8                 db    0
.xdata$x:000022B9                 db    0
.xdata$x:000022BA                 db    0
.xdata$x:000022BB                 db    0
.xdata$x:000022BC                 db    0
.xdata$x:000022BD                 db    0
.xdata$x:000022BE                 db    0
.xdata$x:000022BF                 db    0
.xdata$x:000022C0                 db    0
.xdata$x:000022C1                 db    0
.xdata$x:000022C2                 db    0
.xdata$x:000022C3                 db    0
.xdata$x:000022C4                 db    0
.xdata$x:000022C5                 db    0
.xdata$x:000022C6                 db    0
.xdata$x:000022C7                 db    0
.xdata$x:000022C8                 db    0
.xdata$x:000022C9                 db    0
.xdata$x:000022CA                 db    0
.xdata$x:000022CB                 db    0
.xdata$x:000022CB _xdata$x        ends
.xdata$x:000022CB
.xdata$x:000022CC ; ===========================================================================
.xdata$x:000022CC
.xdata$x:000022CC ; Segment type: Pure data
.xdata$x:000022CC ; Segment permissions: Read
.xdata$x:000022CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000022CC                 assume cs:_xdata$x
.xdata$x:000022CC                 ;org 22CCh
.xdata$x:000022CC ; COMDAT (pick associative to section at 4E0)
.xdata$x:000022CC __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:000022CC                                         ; DATA XREF: .xdata$x:000022DCo
.xdata$x:000022CD                 db 0FFh
.xdata$x:000022CE                 db 0FFh
.xdata$x:000022CF                 db 0FFh
.xdata$x:000022D0                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:000022D4 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:000022D4                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:000022D5                 db    5
.xdata$x:000022D6                 db  93h ; ô
.xdata$x:000022D7                 db  19h
.xdata$x:000022D8                 db    1
.xdata$x:000022D9                 db    0
.xdata$x:000022DA                 db    0
.xdata$x:000022DB                 db    0
.xdata$x:000022DC                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:000022E0                 db    0
.xdata$x:000022E1                 db    0
.xdata$x:000022E2                 db    0
.xdata$x:000022E3                 db    0
.xdata$x:000022E4                 db    0
.xdata$x:000022E5                 db    0
.xdata$x:000022E6                 db    0
.xdata$x:000022E7                 db    0
.xdata$x:000022E8                 db    0
.xdata$x:000022E9                 db    0
.xdata$x:000022EA                 db    0
.xdata$x:000022EB                 db    0
.xdata$x:000022EC                 db    0
.xdata$x:000022ED                 db    0
.xdata$x:000022EE                 db    0
.xdata$x:000022EF                 db    0
.xdata$x:000022F0                 db    0
.xdata$x:000022F1                 db    0
.xdata$x:000022F2                 db    0
.xdata$x:000022F3                 db    0
.xdata$x:000022F4                 db    0
.xdata$x:000022F5                 db    0
.xdata$x:000022F6                 db    0
.xdata$x:000022F7                 db    0
.xdata$x:000022F7 _xdata$x        ends
.xdata$x:000022F7
.xdata$x:000022F8 ; ===========================================================================
.xdata$x:000022F8
.xdata$x:000022F8 ; Segment type: Pure data
.xdata$x:000022F8 ; Segment permissions: Read
.xdata$x:000022F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000022F8                 assume cs:_xdata$x
.xdata$x:000022F8                 ;org 22F8h
.xdata$x:000022F8 ; COMDAT (pick associative to section at 96C)
.xdata$x:000022F8 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000022F8                                         ; DATA XREF: .xdata$x:00002308o
.xdata$x:000022F9                 db 0FFh
.xdata$x:000022FA                 db 0FFh
.xdata$x:000022FB                 db 0FFh
.xdata$x:000022FC                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002300 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002300                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002301                 db    5
.xdata$x:00002302                 db  93h ; ô
.xdata$x:00002303                 db  19h
.xdata$x:00002304                 db    1
.xdata$x:00002305                 db    0
.xdata$x:00002306                 db    0
.xdata$x:00002307                 db    0
.xdata$x:00002308                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000230C                 db    0
.xdata$x:0000230D                 db    0
.xdata$x:0000230E                 db    0
.xdata$x:0000230F                 db    0
.xdata$x:00002310                 db    0
.xdata$x:00002311                 db    0
.xdata$x:00002312                 db    0
.xdata$x:00002313                 db    0
.xdata$x:00002314                 db    0
.xdata$x:00002315                 db    0
.xdata$x:00002316                 db    0
.xdata$x:00002317                 db    0
.xdata$x:00002318                 db    0
.xdata$x:00002319                 db    0
.xdata$x:0000231A                 db    0
.xdata$x:0000231B                 db    0
.xdata$x:0000231C                 db    0
.xdata$x:0000231D                 db    0
.xdata$x:0000231E                 db    0
.xdata$x:0000231F                 db    0
.xdata$x:00002320                 db    0
.xdata$x:00002321                 db    0
.xdata$x:00002322                 db    0
.xdata$x:00002323                 db    0
.xdata$x:00002323 _xdata$x        ends
.xdata$x:00002323
.xdata$x:00002324 ; ===========================================================================
.xdata$x:00002324
.xdata$x:00002324 ; Segment type: Pure data
.xdata$x:00002324 ; Segment permissions: Read
.xdata$x:00002324 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002324                 assume cs:_xdata$x
.xdata$x:00002324                 ;org 2324h
.xdata$x:00002324 ; COMDAT (pick associative to section at 61C)
.xdata$x:00002324 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002324                                         ; DATA XREF: .xdata$x:00002334o
.xdata$x:00002325                 db 0FFh
.xdata$x:00002326                 db 0FFh
.xdata$x:00002327                 db 0FFh
.xdata$x:00002328                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:0000232C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000232C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:0000232D                 db    5
.xdata$x:0000232E                 db  93h ; ô
.xdata$x:0000232F                 db  19h
.xdata$x:00002330                 db    1
.xdata$x:00002331                 db    0
.xdata$x:00002332                 db    0
.xdata$x:00002333                 db    0
.xdata$x:00002334                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002338                 db    0
.xdata$x:00002339                 db    0
.xdata$x:0000233A                 db    0
.xdata$x:0000233B                 db    0
.xdata$x:0000233C                 db    0
.xdata$x:0000233D                 db    0
.xdata$x:0000233E                 db    0
.xdata$x:0000233F                 db    0
.xdata$x:00002340                 db    0
.xdata$x:00002341                 db    0
.xdata$x:00002342                 db    0
.xdata$x:00002343                 db    0
.xdata$x:00002344                 db    0
.xdata$x:00002345                 db    0
.xdata$x:00002346                 db    0
.xdata$x:00002347                 db    0
.xdata$x:00002348                 db    0
.xdata$x:00002349                 db    0
.xdata$x:0000234A                 db    0
.xdata$x:0000234B                 db    0
.xdata$x:0000234C                 db    0
.xdata$x:0000234D                 db    0
.xdata$x:0000234E                 db    0
.xdata$x:0000234F                 db    0
.xdata$x:0000234F _xdata$x        ends
.xdata$x:0000234F
.xdata$x:00002350 ; ===========================================================================
.xdata$x:00002350
.xdata$x:00002350 ; Segment type: Pure data
.xdata$x:00002350 ; Segment permissions: Read
.xdata$x:00002350 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002350                 assume cs:_xdata$x
.xdata$x:00002350                 ;org 2350h
.xdata$x:00002350 ; COMDAT (pick associative to section at A54)
.xdata$x:00002350 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00002350                                         ; DATA XREF: .xdata$x:00002360o
.xdata$x:00002351                 db 0FFh
.xdata$x:00002352                 db 0FFh
.xdata$x:00002353                 db 0FFh
.xdata$x:00002354                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002358 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002358                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002359                 db    5
.xdata$x:0000235A                 db  93h ; ô
.xdata$x:0000235B                 db  19h
.xdata$x:0000235C                 db    1
.xdata$x:0000235D                 db    0
.xdata$x:0000235E                 db    0
.xdata$x:0000235F                 db    0
.xdata$x:00002360                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002364                 db    0
.xdata$x:00002365                 db    0
.xdata$x:00002366                 db    0
.xdata$x:00002367                 db    0
.xdata$x:00002368                 db    0
.xdata$x:00002369                 db    0
.xdata$x:0000236A                 db    0
.xdata$x:0000236B                 db    0
.xdata$x:0000236C                 db    0
.xdata$x:0000236D                 db    0
.xdata$x:0000236E                 db    0
.xdata$x:0000236F                 db    0
.xdata$x:00002370                 db    0
.xdata$x:00002371                 db    0
.xdata$x:00002372                 db    0
.xdata$x:00002373                 db    0
.xdata$x:00002374                 db    0
.xdata$x:00002375                 db    0
.xdata$x:00002376                 db    0
.xdata$x:00002377                 db    0
.xdata$x:00002378                 db    0
.xdata$x:00002379                 db    0
.xdata$x:0000237A                 db    0
.xdata$x:0000237B                 db    0
.xdata$x:0000237B _xdata$x        ends
.xdata$x:0000237B
.xdata$x:0000237C ; ===========================================================================
.xdata$x:0000237C
.xdata$x:0000237C ; Segment type: Pure data
.xdata$x:0000237C ; Segment permissions: Read
.xdata$x:0000237C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000237C                 assume cs:_xdata$x
.xdata$x:0000237C                 ;org 237Ch
.xdata$x:0000237C ; COMDAT (pick associative to section at 11F0)
.xdata$x:0000237C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000237C                                         ; DATA XREF: .xdata$x:00002404o
.xdata$x:0000237D                 db    0
.xdata$x:0000237E                 db    0
.xdata$x:0000237F                 db    0
.xdata$x:00002380                 db    0
.xdata$x:00002381                 db    0
.xdata$x:00002382                 db    0
.xdata$x:00002383                 db    0
.xdata$x:00002384                 db    0
.xdata$x:00002385                 db    0
.xdata$x:00002386                 db    0
.xdata$x:00002387                 db    0
.xdata$x:00002388                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0000238C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000238C                                         ; DATA XREF: .xdata$x:000023F0o
.xdata$x:0000238D                 db    0
.xdata$x:0000238E                 db    0
.xdata$x:0000238F                 db    0
.xdata$x:00002390                 db    0
.xdata$x:00002391                 db    0
.xdata$x:00002392                 db    0
.xdata$x:00002393                 db    0
.xdata$x:00002394                 db    0
.xdata$x:00002395                 db    0
.xdata$x:00002396                 db    0
.xdata$x:00002397                 db    0
.xdata$x:00002398                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000239C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000239C                                         ; DATA XREF: .xdata$x:000023C4o
.xdata$x:0000239D                 db 0FFh
.xdata$x:0000239E                 db 0FFh
.xdata$x:0000239F                 db 0FFh
.xdata$x:000023A0                 db    0
.xdata$x:000023A1                 db    0
.xdata$x:000023A2                 db    0
.xdata$x:000023A3                 db    0
.xdata$x:000023A4                 db 0FFh
.xdata$x:000023A5                 db 0FFh
.xdata$x:000023A6                 db 0FFh
.xdata$x:000023A7                 db 0FFh
.xdata$x:000023A8                 db    0
.xdata$x:000023A9                 db    0
.xdata$x:000023AA                 db    0
.xdata$x:000023AB                 db    0
.xdata$x:000023AC                 db    1
.xdata$x:000023AD                 db    0
.xdata$x:000023AE                 db    0
.xdata$x:000023AF                 db    0
.xdata$x:000023B0                 db    0
.xdata$x:000023B1                 db    0
.xdata$x:000023B2                 db    0
.xdata$x:000023B3                 db    0
.xdata$x:000023B4                 db    1
.xdata$x:000023B5                 db    0
.xdata$x:000023B6                 db    0
.xdata$x:000023B7                 db    0
.xdata$x:000023B8                 db    0
.xdata$x:000023B9                 db    0
.xdata$x:000023BA                 db    0
.xdata$x:000023BB                 db    0
.xdata$x:000023BC __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000023BC                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:000023BD                 db    5
.xdata$x:000023BE                 db  93h ; ô
.xdata$x:000023BF                 db  19h
.xdata$x:000023C0                 db    4
.xdata$x:000023C1                 db    0
.xdata$x:000023C2                 db    0
.xdata$x:000023C3                 db    0
.xdata$x:000023C4                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000023C8                 db    2
.xdata$x:000023C9                 db    0
.xdata$x:000023CA                 db    0
.xdata$x:000023CB                 db    0
.xdata$x:000023CC                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000023D0                 align 20h
.xdata$x:000023E0 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:000023E0                                         ; DATA XREF: .xdata$x:000023CCo
.xdata$x:000023E1                 db    0
.xdata$x:000023E2                 db    0
.xdata$x:000023E3                 db    0
.xdata$x:000023E4                 db    2
.xdata$x:000023E5                 db    0
.xdata$x:000023E6                 db    0
.xdata$x:000023E7                 db    0
.xdata$x:000023E8                 db    3
.xdata$x:000023E9                 db    0
.xdata$x:000023EA                 db    0
.xdata$x:000023EB                 db    0
.xdata$x:000023EC                 db    1
.xdata$x:000023ED                 db    0
.xdata$x:000023EE                 db    0
.xdata$x:000023EF                 db    0
.xdata$x:000023F0                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:000023F4                 db    0
.xdata$x:000023F5                 db    0
.xdata$x:000023F6                 db    0
.xdata$x:000023F7                 db    0
.xdata$x:000023F8                 db    0
.xdata$x:000023F9                 db    0
.xdata$x:000023FA                 db    0
.xdata$x:000023FB                 db    0
.xdata$x:000023FC                 db    3
.xdata$x:000023FD                 db    0
.xdata$x:000023FE                 db    0
.xdata$x:000023FF                 db    0
.xdata$x:00002400                 db    1
.xdata$x:00002401                 db    0
.xdata$x:00002402                 db    0
.xdata$x:00002403                 db    0
.xdata$x:00002404                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002404 _xdata$x        ends
.xdata$x:00002404
.xdata$x:00002408 ; ===========================================================================
.xdata$x:00002408
.xdata$x:00002408 ; Segment type: Pure data
.xdata$x:00002408 ; Segment permissions: Read
.xdata$x:00002408 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002408                 assume cs:_xdata$x
.xdata$x:00002408                 ;org 2408h
.xdata$x:00002408 ; COMDAT (pick associative to section at 7A4)
.xdata$x:00002408 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002408                                         ; DATA XREF: .xdata$x:00002418o
.xdata$x:00002409                 db 0FFh
.xdata$x:0000240A                 db 0FFh
.xdata$x:0000240B                 db 0FFh
.xdata$x:0000240C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00002410 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002410                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00002411                 db    5
.xdata$x:00002412                 db  93h ; ô
.xdata$x:00002413                 db  19h
.xdata$x:00002414                 db    1
.xdata$x:00002415                 db    0
.xdata$x:00002416                 db    0
.xdata$x:00002417                 db    0
.xdata$x:00002418                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000241C                 db    0
.xdata$x:0000241D                 db    0
.xdata$x:0000241E                 db    0
.xdata$x:0000241F                 db    0
.xdata$x:00002420                 db    0
.xdata$x:00002421                 db    0
.xdata$x:00002422                 db    0
.xdata$x:00002423                 db    0
.xdata$x:00002424                 db    0
.xdata$x:00002425                 db    0
.xdata$x:00002426                 db    0
.xdata$x:00002427                 db    0
.xdata$x:00002428                 db    0
.xdata$x:00002429                 db    0
.xdata$x:0000242A                 db    0
.xdata$x:0000242B                 db    0
.xdata$x:0000242C                 db    0
.xdata$x:0000242D                 db    0
.xdata$x:0000242E                 db    0
.xdata$x:0000242F                 db    0
.xdata$x:00002430                 db    0
.xdata$x:00002431                 db    0
.xdata$x:00002432                 db    0
.xdata$x:00002433                 db    0
.xdata$x:00002433 _xdata$x        ends
.xdata$x:00002433
.xdata$x:00002434 ; ===========================================================================
.xdata$x:00002434
.xdata$x:00002434 ; Segment type: Pure data
.xdata$x:00002434 ; Segment permissions: Read
.xdata$x:00002434 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002434                 assume cs:_xdata$x
.xdata$x:00002434                 ;org 2434h
.xdata$x:00002434 ; COMDAT (pick associative to section at 1DBC)
.xdata$x:00002434 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002434                                         ; DATA XREF: .xdata$x:00002444o
.xdata$x:00002435                 db 0FFh
.xdata$x:00002436                 db 0FFh
.xdata$x:00002437                 db 0FFh
.xdata$x:00002438                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000243C __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000243C                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000243D                 db    5
.xdata$x:0000243E                 db  93h ; ô
.xdata$x:0000243F                 db  19h
.xdata$x:00002440                 db    1
.xdata$x:00002441                 db    0
.xdata$x:00002442                 db    0
.xdata$x:00002443                 db    0
.xdata$x:00002444                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002448                 align 20h
.xdata$x:00002448 _xdata$x        ends
.xdata$x:00002448
.xdata$x:00002460 ; ===========================================================================
.xdata$x:00002460
.xdata$x:00002460 ; Segment type: Pure data
.xdata$x:00002460 ; Segment permissions: Read
.xdata$x:00002460 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002460                 assume cs:_xdata$x
.xdata$x:00002460                 ;org 2460h
.xdata$x:00002460 ; COMDAT (pick associative to section at C24)
.xdata$x:00002460 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002460                                         ; DATA XREF: .xdata$x:00002470o
.xdata$x:00002461                 db 0FFh
.xdata$x:00002462                 db 0FFh
.xdata$x:00002463                 db 0FFh
.xdata$x:00002464                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002468 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002468                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002469                 db    5
.xdata$x:0000246A                 db  93h ; ô
.xdata$x:0000246B                 db  19h
.xdata$x:0000246C                 db    1
.xdata$x:0000246D                 db    0
.xdata$x:0000246E                 db    0
.xdata$x:0000246F                 db    0
.xdata$x:00002470                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002474                 db    0
.xdata$x:00002475                 db    0
.xdata$x:00002476                 db    0
.xdata$x:00002477                 db    0
.xdata$x:00002478                 db    0
.xdata$x:00002479                 db    0
.xdata$x:0000247A                 db    0
.xdata$x:0000247B                 db    0
.xdata$x:0000247C                 db    0
.xdata$x:0000247D                 db    0
.xdata$x:0000247E                 db    0
.xdata$x:0000247F                 db    0
.xdata$x:00002480                 db    0
.xdata$x:00002481                 db    0
.xdata$x:00002482                 db    0
.xdata$x:00002483                 db    0
.xdata$x:00002484                 db    0
.xdata$x:00002485                 db    0
.xdata$x:00002486                 db    0
.xdata$x:00002487                 db    0
.xdata$x:00002488                 db    0
.xdata$x:00002489                 db    0
.xdata$x:0000248A                 db    0
.xdata$x:0000248B                 db    0
.xdata$x:0000248B _xdata$x        ends
.xdata$x:0000248B
.xdata$x:0000248C ; ===========================================================================
.xdata$x:0000248C
.xdata$x:0000248C ; Segment type: Pure data
.xdata$x:0000248C ; Segment permissions: Read
.xdata$x:0000248C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000248C                 assume cs:_xdata$x
.xdata$x:0000248C                 ;org 248Ch
.xdata$x:0000248C ; COMDAT (pick associative to section at 820)
.xdata$x:0000248C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000248C                                         ; DATA XREF: .xdata$x:0000249Co
.xdata$x:0000248D                 db 0FFh
.xdata$x:0000248E                 db 0FFh
.xdata$x:0000248F                 db 0FFh
.xdata$x:00002490                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002494 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002494                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002495                 db    5
.xdata$x:00002496                 db  93h ; ô
.xdata$x:00002497                 db  19h
.xdata$x:00002498                 db    1
.xdata$x:00002499                 db    0
.xdata$x:0000249A                 db    0
.xdata$x:0000249B                 db    0
.xdata$x:0000249C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:000024A0                 db    0
.xdata$x:000024A1                 db    0
.xdata$x:000024A2                 db    0
.xdata$x:000024A3                 db    0
.xdata$x:000024A4                 db    0
.xdata$x:000024A5                 db    0
.xdata$x:000024A6                 db    0
.xdata$x:000024A7                 db    0
.xdata$x:000024A8                 db    0
.xdata$x:000024A9                 db    0
.xdata$x:000024AA                 db    0
.xdata$x:000024AB                 db    0
.xdata$x:000024AC                 db    0
.xdata$x:000024AD                 db    0
.xdata$x:000024AE                 db    0
.xdata$x:000024AF                 db    0
.xdata$x:000024B0                 db    0
.xdata$x:000024B1                 db    0
.xdata$x:000024B2                 db    0
.xdata$x:000024B3                 db    0
.xdata$x:000024B4                 db    0
.xdata$x:000024B5                 db    0
.xdata$x:000024B6                 db    0
.xdata$x:000024B7                 db    0
.xdata$x:000024B7 _xdata$x        ends
.xdata$x:000024B7
.xdata$x:000024B8 ; ===========================================================================
.xdata$x:000024B8
.xdata$x:000024B8 ; Segment type: Pure data
.xdata$x:000024B8 ; Segment permissions: Read
.xdata$x:000024B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024B8                 assume cs:_xdata$x
.xdata$x:000024B8                 ;org 24B8h
.xdata$x:000024B8 ; COMDAT (pick associative to section at 1E74)
.xdata$x:000024B8 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000024B8                                         ; DATA XREF: .xdata$x:000024C8o
.xdata$x:000024B9                 db 0FFh
.xdata$x:000024BA                 db 0FFh
.xdata$x:000024BB                 db 0FFh
.xdata$x:000024BC                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000024C0 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000024C0                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000024C1                 db    5
.xdata$x:000024C2                 db  93h ; ô
.xdata$x:000024C3                 db  19h
.xdata$x:000024C4                 db    1
.xdata$x:000024C5                 db    0
.xdata$x:000024C6                 db    0
.xdata$x:000024C7                 db    0
.xdata$x:000024C8                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000024CC                 db    0
.xdata$x:000024CD                 db    0
.xdata$x:000024CE                 db    0
.xdata$x:000024CF                 db    0
.xdata$x:000024D0                 db    0
.xdata$x:000024D1                 db    0
.xdata$x:000024D2                 db    0
.xdata$x:000024D3                 db    0
.xdata$x:000024D4                 db    0
.xdata$x:000024D5                 db    0
.xdata$x:000024D6                 db    0
.xdata$x:000024D7                 db    0
.xdata$x:000024D8                 db    0
.xdata$x:000024D9                 db    0
.xdata$x:000024DA                 db    0
.xdata$x:000024DB                 db    0
.xdata$x:000024DC                 db    0
.xdata$x:000024DD                 db    0
.xdata$x:000024DE                 db    0
.xdata$x:000024DF                 db    0
.xdata$x:000024E0                 db    0
.xdata$x:000024E1                 db    0
.xdata$x:000024E2                 db    0
.xdata$x:000024E3                 db    0
.xdata$x:000024E3 _xdata$x        ends
.xdata$x:000024E3
.xdata$x:000024E4 ; ===========================================================================
.xdata$x:000024E4
.xdata$x:000024E4 ; Segment type: Pure data
.xdata$x:000024E4 ; Segment permissions: Read
.xdata$x:000024E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024E4                 assume cs:_xdata$x
.xdata$x:000024E4                 ;org 24E4h
.xdata$x:000024E4 ; COMDAT (pick associative to section at C94)
.xdata$x:000024E4 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000024E4                                         ; DATA XREF: .xdata$x:000024F4o
.xdata$x:000024E5                 db 0FFh
.xdata$x:000024E6                 db 0FFh
.xdata$x:000024E7                 db 0FFh
.xdata$x:000024E8                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000024EC __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000024EC                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000024ED                 db    5
.xdata$x:000024EE                 db  93h ; ô
.xdata$x:000024EF                 db  19h
.xdata$x:000024F0                 db    1
.xdata$x:000024F1                 db    0
.xdata$x:000024F2                 db    0
.xdata$x:000024F3                 db    0
.xdata$x:000024F4                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000024F8                 db    0
.xdata$x:000024F9                 db    0
.xdata$x:000024FA                 db    0
.xdata$x:000024FB                 db    0
.xdata$x:000024FC                 db    0
.xdata$x:000024FD                 db    0
.xdata$x:000024FE                 db    0
.xdata$x:000024FF                 db    0
.xdata$x:00002500                 db    0
.xdata$x:00002501                 db    0
.xdata$x:00002502                 db    0
.xdata$x:00002503                 db    0
.xdata$x:00002504                 db    0
.xdata$x:00002505                 db    0
.xdata$x:00002506                 db    0
.xdata$x:00002507                 db    0
.xdata$x:00002508                 db    0
.xdata$x:00002509                 db    0
.xdata$x:0000250A                 db    0
.xdata$x:0000250B                 db    0
.xdata$x:0000250C                 db    0
.xdata$x:0000250D                 db    0
.xdata$x:0000250E                 db    0
.xdata$x:0000250F                 db    0
.xdata$x:0000250F _xdata$x        ends
.xdata$x:0000250F
.xdata$x:00002510 ; ===========================================================================
.xdata$x:00002510
.xdata$x:00002510 ; Segment type: Pure data
.xdata$x:00002510 ; Segment permissions: Read
.xdata$x:00002510 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002510                 assume cs:_xdata$x
.xdata$x:00002510                 ;org 2510h
.xdata$x:00002510 ; COMDAT (pick associative to section at 89C)
.xdata$x:00002510 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002510                                         ; DATA XREF: .xdata$x:00002520o
.xdata$x:00002511                 db 0FFh
.xdata$x:00002512                 db 0FFh
.xdata$x:00002513                 db 0FFh
.xdata$x:00002514                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002518 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002518                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002519                 db    5
.xdata$x:0000251A                 db  93h ; ô
.xdata$x:0000251B                 db  19h
.xdata$x:0000251C                 db    1
.xdata$x:0000251D                 db    0
.xdata$x:0000251E                 db    0
.xdata$x:0000251F                 db    0
.xdata$x:00002520                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002524                 db    0
.xdata$x:00002525                 db    0
.xdata$x:00002526                 db    0
.xdata$x:00002527                 db    0
.xdata$x:00002528                 db    0
.xdata$x:00002529                 db    0
.xdata$x:0000252A                 db    0
.xdata$x:0000252B                 db    0
.xdata$x:0000252C                 db    0
.xdata$x:0000252D                 db    0
.xdata$x:0000252E                 db    0
.xdata$x:0000252F                 db    0
.xdata$x:00002530                 db    0
.xdata$x:00002531                 db    0
.xdata$x:00002532                 db    0
.xdata$x:00002533                 db    0
.xdata$x:00002534                 db    0
.xdata$x:00002535                 db    0
.xdata$x:00002536                 db    0
.xdata$x:00002537                 db    0
.xdata$x:00002538                 db    0
.xdata$x:00002539                 db    0
.xdata$x:0000253A                 db    0
.xdata$x:0000253B                 db    0
.xdata$x:0000253B _xdata$x        ends
.xdata$x:0000253B
.xdata$x:0000253C ; ===========================================================================
.xdata$x:0000253C
.xdata$x:0000253C ; Segment type: Pure data
.xdata$x:0000253C ; Segment permissions: Read
.xdata$x:0000253C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000253C                 assume cs:_xdata$x
.xdata$x:0000253C                 ;org 253Ch
.xdata$x:0000253C ; COMDAT (pick associative to section at 1F38)
.xdata$x:0000253C __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000253C                                         ; DATA XREF: .xdata$x:0000254Co
.xdata$x:0000253D                 db 0FFh
.xdata$x:0000253E                 db 0FFh
.xdata$x:0000253F                 db 0FFh
.xdata$x:00002540                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002544 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002544                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002545                 db    5
.xdata$x:00002546                 db  93h ; ô
.xdata$x:00002547                 db  19h
.xdata$x:00002548                 db    1
.xdata$x:00002549                 db    0
.xdata$x:0000254A                 db    0
.xdata$x:0000254B                 db    0
.xdata$x:0000254C                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002550                 db    0
.xdata$x:00002551                 db    0
.xdata$x:00002552                 db    0
.xdata$x:00002553                 db    0
.xdata$x:00002554                 db    0
.xdata$x:00002555                 db    0
.xdata$x:00002556                 db    0
.xdata$x:00002557                 db    0
.xdata$x:00002558                 db    0
.xdata$x:00002559                 db    0
.xdata$x:0000255A                 db    0
.xdata$x:0000255B                 db    0
.xdata$x:0000255C                 db    0
.xdata$x:0000255D                 db    0
.xdata$x:0000255E                 db    0
.xdata$x:0000255F                 db    0
.xdata$x:00002560                 db    0
.xdata$x:00002561                 db    0
.xdata$x:00002562                 db    0
.xdata$x:00002563                 db    0
.xdata$x:00002564                 db    0
.xdata$x:00002565                 db    0
.xdata$x:00002566                 db    0
.xdata$x:00002567                 db    0
.xdata$x:00002567 _xdata$x        ends
.xdata$x:00002567
.xdata$x:00002568 ; ===========================================================================
.xdata$x:00002568
.xdata$x:00002568 ; Segment type: Pure data
.xdata$x:00002568 ; Segment permissions: Read
.xdata$x:00002568 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002568                 assume cs:_xdata$x
.xdata$x:00002568                 ;org 2568h
.xdata$x:00002568 ; COMDAT (pick associative to section at D04)
.xdata$x:00002568 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002568                                         ; DATA XREF: .xdata$x:00002578o
.xdata$x:00002569                 db 0FFh
.xdata$x:0000256A                 db 0FFh
.xdata$x:0000256B                 db 0FFh
.xdata$x:0000256C                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002570 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002570                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002571                 db    5
.xdata$x:00002572                 db  93h ; ô
.xdata$x:00002573                 db  19h
.xdata$x:00002574                 db    1
.xdata$x:00002575                 db    0
.xdata$x:00002576                 db    0
.xdata$x:00002577                 db    0
.xdata$x:00002578                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000257C                 db    0
.xdata$x:0000257D                 db    0
.xdata$x:0000257E                 db    0
.xdata$x:0000257F                 db    0
.xdata$x:00002580                 db    0
.xdata$x:00002581                 db    0
.xdata$x:00002582                 db    0
.xdata$x:00002583                 db    0
.xdata$x:00002584                 db    0
.xdata$x:00002585                 db    0
.xdata$x:00002586                 db    0
.xdata$x:00002587                 db    0
.xdata$x:00002588                 db    0
.xdata$x:00002589                 db    0
.xdata$x:0000258A                 db    0
.xdata$x:0000258B                 db    0
.xdata$x:0000258C                 db    0
.xdata$x:0000258D                 db    0
.xdata$x:0000258E                 db    0
.xdata$x:0000258F                 db    0
.xdata$x:00002590                 db    0
.xdata$x:00002591                 db    0
.xdata$x:00002592                 db    0
.xdata$x:00002593                 db    0
.xdata$x:00002593 _xdata$x        ends
.xdata$x:00002593
.xdata$x:00002594 ; ===========================================================================
.xdata$x:00002594
.xdata$x:00002594 ; Segment type: Pure data
.xdata$x:00002594 ; Segment permissions: Read
.xdata$x:00002594 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002594                 assume cs:_xdata$x
.xdata$x:00002594                 ;org 2594h
.xdata$x:00002594 ; COMDAT (pick associative to section at 3C4)
.xdata$x:00002594 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002594                                         ; DATA XREF: .xdata$x:000025A4o
.xdata$x:00002595                 db 0FFh
.xdata$x:00002596                 db 0FFh
.xdata$x:00002597                 db 0FFh
.xdata$x:00002598                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000259C __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000259C                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000259D                 db    5
.xdata$x:0000259E                 db  93h ; ô
.xdata$x:0000259F                 db  19h
.xdata$x:000025A0                 db    1
.xdata$x:000025A1                 db    0
.xdata$x:000025A2                 db    0
.xdata$x:000025A3                 db    0
.xdata$x:000025A4                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:000025A8                 align 20h
.xdata$x:000025A8 _xdata$x        ends
.xdata$x:000025A8
.xdata$x:000025C0 ; ===========================================================================
.xdata$x:000025C0
.xdata$x:000025C0 ; Segment type: Pure data
.xdata$x:000025C0 ; Segment permissions: Read
.xdata$x:000025C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025C0                 assume cs:_xdata$x
.xdata$x:000025C0                 ;org 25C0h
.xdata$x:000025C0 ; COMDAT (pick associative to section at 2F0)
.xdata$x:000025C0 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000025C0                                         ; DATA XREF: .xdata$x:000025D0o
.xdata$x:000025C1                 db 0FFh
.xdata$x:000025C2                 db 0FFh
.xdata$x:000025C3                 db 0FFh
.xdata$x:000025C4                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000025C8 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000025C8                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000025C9                 db    5
.xdata$x:000025CA                 db  93h ; ô
.xdata$x:000025CB                 db  19h
.xdata$x:000025CC                 db    1
.xdata$x:000025CD                 db    0
.xdata$x:000025CE                 db    0
.xdata$x:000025CF                 db    0
.xdata$x:000025D0                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000025D4                 db    0
.xdata$x:000025D5                 db    0
.xdata$x:000025D6                 db    0
.xdata$x:000025D7                 db    0
.xdata$x:000025D8                 db    0
.xdata$x:000025D9                 db    0
.xdata$x:000025DA                 db    0
.xdata$x:000025DB                 db    0
.xdata$x:000025DC                 db    0
.xdata$x:000025DD                 db    0
.xdata$x:000025DE                 db    0
.xdata$x:000025DF                 db    0
.xdata$x:000025E0                 db    0
.xdata$x:000025E1                 db    0
.xdata$x:000025E2                 db    0
.xdata$x:000025E3                 db    0
.xdata$x:000025E4                 db    0
.xdata$x:000025E5                 db    0
.xdata$x:000025E6                 db    0
.xdata$x:000025E7                 db    0
.xdata$x:000025E8                 db    0
.xdata$x:000025E9                 db    0
.xdata$x:000025EA                 db    0
.xdata$x:000025EB                 db    0
.xdata$x:000025EB _xdata$x        ends
.xdata$x:000025EB
.rdata:000025EC ; ===========================================================================
.rdata:000025EC
.rdata:000025EC ; Segment type: Pure data
.rdata:000025EC ; Segment permissions: Read
.rdata:000025EC ; Segment alignment 'qword' can not be represented in assembly
.rdata:000025EC _rdata          segment para public 'DATA' use32
.rdata:000025EC                 assume cs:_rdata
.rdata:000025EC                 ;org 25ECh
.rdata:000025EC ; COMDAT (pick any)
.rdata:000025EC                 public ??_C@_1KO@LJAFCIDL@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@
.rdata:000025EC ; wchar_t `string'
.rdata:000025EC ??_C@_1KO@LJAFCIDL@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@:
.rdata:000025EC                                         ; DATA XREF: CWinMgr::CalcLayout(HWND__ *)+1Eo
.rdata:000025EC                                         ; CWinMgr::CalcLayout(tagRECT,HWND__ *)+15o
.rdata:000025EC                 unicode 0, <c:\workspace\notepad-plus-plus-6.7.9.2\powereditor\src\wi>
.rdata:000025EC                 unicode 0, <ncontrols\windowsdlg\WinMgr.h>,0
.rdata:0000269A                 align 4
.rdata:0000269A _rdata          ends
.rdata:0000269A
.rdata:0000269C ; ===========================================================================
.rdata:0000269C
.rdata:0000269C ; Segment type: Pure data
.rdata:0000269C ; Segment permissions: Read
.rdata:0000269C _rdata          segment dword public 'DATA' use32
.rdata:0000269C                 assume cs:_rdata
.rdata:0000269C                 ;org 269Ch
.rdata:0000269C ; COMDAT (pick any)
.rdata:0000269C                 public ??_C@_19HBMCHKM@?$AAh?$AAW?$AAn?$AAd?$AA?$AA@
.rdata:0000269C ; wchar_t `string'
.rdata:0000269C ??_C@_19HBMCHKM@?$AAh?$AAW?$AAn?$AAd?$AA?$AA@:
.rdata:0000269C                                         ; DATA XREF: CWinMgr::CalcLayout(HWND__ *)+23o
.rdata:0000269C                 unicode 0, <hWnd>,0
.rdata:000026A6                 align 4
.rdata:000026A6 _rdata          ends
.rdata:000026A6
.rdata:000026A8 ; ===========================================================================
.rdata:000026A8
.rdata:000026A8 ; Segment type: Pure data
.rdata:000026A8 ; Segment permissions: Read
.rdata:000026A8 _rdata          segment dword public 'DATA' use32
.rdata:000026A8                 assume cs:_rdata
.rdata:000026A8                 ;org 26A8h
.rdata:000026A8 ; COMDAT (pick any)
.rdata:000026A8                 public ??_C@_1M@JJLBEALK@?$AAm?$AA_?$AAm?$AAa?$AAp?$AA?$AA@
.rdata:000026A8 ; wchar_t `string'
.rdata:000026A8 ??_C@_1M@JJLBEALK@?$AAm?$AA_?$AAm?$AAa?$AAp?$AA?$AA@:
.rdata:000026A8                                         ; DATA XREF: CWinMgr::CalcLayout(tagRECT,HWND__ *)+1Ao
.rdata:000026A8                 unicode 0, <m_map>,0
.rdata:000026A8 _rdata          ends
.rdata:000026A8
.rdata:000026B4 ; ===========================================================================
.rdata:000026B4
.rdata:000026B4 ; Segment type: Pure data
.rdata:000026B4 ; Segment permissions: Read
.rdata:000026B4 _rdata          segment dword public 'DATA' use32
.rdata:000026B4                 assume cs:_rdata
.rdata:000026B4                 ;org 26B4h
.rdata:000026B4 ; COMDAT (pick largest)
.rdata:000026B4                 dd offset ??_R4Window@@6B@ ; const Window::`RTTI Complete Object Locator'
.rdata:000026B8                 public ??_7Window@@6B@
.rdata:000026B8 ; const Window::`vftable'
.rdata:000026B8 ??_7Window@@6B@ dd offset ??_EWindow@@UAEPAXI@Z
.rdata:000026B8                                         ; DATA XREF: Window::Window(void)+Ao
.rdata:000026B8                                         ; Window::~Window(void)+Ao
.rdata:000026B8                                         ; Window::`vector deleting destructor'(uint)
.rdata:000026BC                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:000026C0                 dd offset __purecall
.rdata:000026C4                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:000026C8                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:000026CC                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:000026D0                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:000026D4                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:000026D8                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:000026DC                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:000026E0                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:000026E4                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:000026E4 _rdata          ends
.rdata:000026E4
.rdata:000026E8 ; ===========================================================================
.rdata:000026E8
.rdata:000026E8 ; Segment type: Pure data
.rdata:000026E8 ; Segment permissions: Read
.rdata:000026E8 _rdata          segment dword public 'DATA' use32
.rdata:000026E8                 assume cs:_rdata
.rdata:000026E8                 ;org 26E8h
.rdata:000026E8 ; COMDAT (pick largest)
.rdata:000026E8                 dd offset ??_R4StaticDialog@@6B@ ; const StaticDialog::`RTTI Complete Object Locator'
.rdata:000026EC                 public ??_7StaticDialog@@6B@
.rdata:000026EC ; const StaticDialog::`vftable'
.rdata:000026EC ??_7StaticDialog@@6B@ dd offset ??_EStaticDialog@@UAEPAXI@Z
.rdata:000026EC                                         ; DATA XREF: StaticDialog::StaticDialog(void)+38o
.rdata:000026EC                                         ; StaticDialog::~StaticDialog(void)+29o
.rdata:000026EC                                         ; StaticDialog::`vector deleting destructor'(uint)
.rdata:000026F0                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:000026F4                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:000026F8                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:000026FC                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:00002700                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:00002704                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00002708                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000270C                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00002710                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:00002714                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00002718                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000271C                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:00002720                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:00002724                 dd offset __purecall
.rdata:00002724 _rdata          ends
.rdata:00002724
.rdata:00002728 ; ===========================================================================
.rdata:00002728
.rdata:00002728 ; Segment type: Pure data
.rdata:00002728 ; Segment permissions: Read
.rdata:00002728 _rdata          segment dword public 'DATA' use32
.rdata:00002728                 assume cs:_rdata
.rdata:00002728                 ;org 2728h
.rdata:00002728 ; COMDAT (pick largest)
.rdata:00002728                 dd offset ??_R4SizeableDlg@@6B@ ; const SizeableDlg::`RTTI Complete Object Locator'
.rdata:0000272C                 public ??_7SizeableDlg@@6B@
.rdata:0000272C ; const SizeableDlg::`vftable'
.rdata:0000272C ??_7SizeableDlg@@6B@ dd offset ??_ESizeableDlg@@UAEPAXI@Z
.rdata:0000272C                                         ; DATA XREF: SizeableDlg::SizeableDlg(WINRECT *)+38o
.rdata:0000272C                                         ; SizeableDlg::`vector deleting destructor'(uint)
.rdata:00002730                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:00002734                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:00002738                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000273C                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:00002740                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:00002744                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00002748                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000274C                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00002750                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:00002754                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00002758                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000275C                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:00002760                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:00002764                 dd offset ?run_dlgProc@SizeableDlg@@MAGHIIJ@Z ; SizeableDlg::run_dlgProc(uint,uint,long)
.rdata:00002768                 dd offset ?onInitDialog@SizeableDlg@@MAEHXZ ; SizeableDlg::onInitDialog(void)
.rdata:0000276C                 dd offset ?onSize@SizeableDlg@@MAEXIHH@Z ; SizeableDlg::onSize(uint,int,int)
.rdata:00002770                 dd offset ?onGetMinMaxInfo@SizeableDlg@@MAEXPAUtagMINMAXINFO@@@Z ; SizeableDlg::onGetMinMaxInfo(tagMINMAXINFO *)
.rdata:00002774                 dd offset ?onWinMgr@SizeableDlg@@MAEJIJ@Z ; SizeableDlg::onWinMgr(uint,long)
.rdata:00002774 _rdata          ends
.rdata:00002774
.bss:00002778 ; ===========================================================================
.bss:00002778
.bss:00002778 ; Segment type: Uninitialized
.bss:00002778 ; Segment permissions: Read/Write
.bss:00002778 _bss            segment byte public 'BSS' use32
.bss:00002778                 assume cs:_bss
.bss:00002778                 ;org 2778h
.bss:00002778                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002778 _allocator_arg  db    ? ;
.bss:00002779 _piecewise_construct db    ? ;
.bss:0000277A                 align 4
.bss:0000277A _bss            ends
.bss:0000277A
.rdata:0000277C ; ===========================================================================
.rdata:0000277C
.rdata:0000277C ; Segment type: Pure data
.rdata:0000277C ; Segment permissions: Read
.rdata:0000277C _rdata          segment dword public 'DATA' use32
.rdata:0000277C                 assume cs:_rdata
.rdata:0000277C                 ;org 277Ch
.rdata:0000277C ; COMDAT (pick largest)
.rdata:0000277C                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002780                 public ??_7error_category@std@@6B@
.rdata:00002780 ; const std::error_category::`vftable'
.rdata:00002780 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002780                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002780                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002780                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002784                 dd offset __purecall
.rdata:00002788                 dd offset __purecall
.rdata:0000278C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002790                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002794                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002794 _rdata          ends
.rdata:00002794
.rdata:00002798 ; ===========================================================================
.rdata:00002798
.rdata:00002798 ; Segment type: Pure data
.rdata:00002798 ; Segment permissions: Read
.rdata:00002798 _rdata          segment dword public 'DATA' use32
.rdata:00002798                 assume cs:_rdata
.rdata:00002798                 ;org 2798h
.rdata:00002798 ; COMDAT (pick largest)
.rdata:00002798                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000279C                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000279C ; const std::_Generic_error_category::`vftable'
.rdata:0000279C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000279C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000279C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:000027A0                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:000027A4                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:000027A8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000027AC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000027B0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000027B0 _rdata          ends
.rdata:000027B0
.rdata:000027B4 ; ===========================================================================
.rdata:000027B4
.rdata:000027B4 ; Segment type: Pure data
.rdata:000027B4 ; Segment permissions: Read
.rdata:000027B4 _rdata          segment dword public 'DATA' use32
.rdata:000027B4                 assume cs:_rdata
.rdata:000027B4                 ;org 27B4h
.rdata:000027B4 ; COMDAT (pick any)
.rdata:000027B4                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:000027B4 ; `string'
.rdata:000027B4 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:000027B4                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:000027B4 _rdata          ends
.rdata:000027B4
.rdata:000027BC ; ===========================================================================
.rdata:000027BC
.rdata:000027BC ; Segment type: Pure data
.rdata:000027BC ; Segment permissions: Read
.rdata:000027BC _rdata          segment dword public 'DATA' use32
.rdata:000027BC                 assume cs:_rdata
.rdata:000027BC                 ;org 27BCh
.rdata:000027BC ; COMDAT (pick any)
.rdata:000027BC                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:000027BC ; `string'
.rdata:000027BC ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:000027BC                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_1E08o
.rdata:000027BC                                         ; std::_System_error_category::message(int):loc_1F84o
.rdata:000027CA                 align 4
.rdata:000027CA _rdata          ends
.rdata:000027CA
.rdata:000027CC ; ===========================================================================
.rdata:000027CC
.rdata:000027CC ; Segment type: Pure data
.rdata:000027CC ; Segment permissions: Read
.rdata:000027CC _rdata          segment dword public 'DATA' use32
.rdata:000027CC                 assume cs:_rdata
.rdata:000027CC                 ;org 27CCh
.rdata:000027CC ; COMDAT (pick largest)
.rdata:000027CC                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:000027D0                 public ??_7_Iostream_error_category@std@@6B@
.rdata:000027D0 ; const std::_Iostream_error_category::`vftable'
.rdata:000027D0 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:000027D0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:000027D0                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:000027D4                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:000027D8                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:000027DC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000027E0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000027E4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000027E4 _rdata          ends
.rdata:000027E4
.rdata:000027E8 ; ===========================================================================
.rdata:000027E8
.rdata:000027E8 ; Segment type: Pure data
.rdata:000027E8 ; Segment permissions: Read
.rdata:000027E8 _rdata          segment dword public 'DATA' use32
.rdata:000027E8                 assume cs:_rdata
.rdata:000027E8                 ;org 27E8h
.rdata:000027E8 ; COMDAT (pick any)
.rdata:000027E8                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:000027E8 ; `string'
.rdata:000027E8 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:000027E8                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:000027F1                 align 4
.rdata:000027F1 _rdata          ends
.rdata:000027F1
.rdata:000027F4 ; ===========================================================================
.rdata:000027F4
.rdata:000027F4 ; Segment type: Pure data
.rdata:000027F4 ; Segment permissions: Read
.rdata:000027F4 _rdata          segment dword public 'DATA' use32
.rdata:000027F4                 assume cs:_rdata
.rdata:000027F4                 ;org 27F4h
.rdata:000027F4 ; COMDAT (pick any)
.rdata:000027F4                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:000027F4 ; char `string'[]
.rdata:000027F4 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:000027F4                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000280A                 align 4
.rdata:0000280A _rdata          ends
.rdata:0000280A
.rdata:0000280C ; ===========================================================================
.rdata:0000280C
.rdata:0000280C ; Segment type: Pure data
.rdata:0000280C ; Segment permissions: Read
.rdata:0000280C _rdata          segment dword public 'DATA' use32
.rdata:0000280C                 assume cs:_rdata
.rdata:0000280C                 ;org 280Ch
.rdata:0000280C ; COMDAT (pick largest)
.rdata:0000280C                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002810                 public ??_7_System_error_category@std@@6B@
.rdata:00002810 ; const std::_System_error_category::`vftable'
.rdata:00002810 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002810                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002810                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002814                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002818                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000281C                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002820                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002824                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002824 _rdata          ends
.rdata:00002824
.rdata:00002828 ; ===========================================================================
.rdata:00002828
.rdata:00002828 ; Segment type: Pure data
.rdata:00002828 ; Segment permissions: Read
.rdata:00002828 _rdata          segment dword public 'DATA' use32
.rdata:00002828                 assume cs:_rdata
.rdata:00002828                 ;org 2828h
.rdata:00002828 ; COMDAT (pick any)
.rdata:00002828                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002828 ; `string'
.rdata:00002828 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002828                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000282F                 align 10h
.rdata:0000282F _rdata          ends
.rdata:0000282F
.bss:00002830 ; ===========================================================================
.bss:00002830
.bss:00002830 ; Segment type: Uninitialized
.bss:00002830 ; Segment permissions: Read/Write
.bss:00002830 _bss            segment dword public 'BSS' use32
.bss:00002830                 assume cs:_bss
.bss:00002830                 ;org 2830h
.bss:00002830 ; COMDAT (pick any)
.bss:00002830                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002830                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002830 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002830 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002830                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002830                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002831                 db    ? ;
.bss:00002832                 db    ? ;
.bss:00002833                 db    ? ;
.bss:00002833 _bss            ends
.bss:00002833
.bss:00002834 ; ===========================================================================
.bss:00002834
.bss:00002834 ; Segment type: Uninitialized
.bss:00002834 ; Segment permissions: Read/Write
.bss:00002834 _bss            segment dword public 'BSS' use32
.bss:00002834                 assume cs:_bss
.bss:00002834                 ;org 2834h
.bss:00002834 ; COMDAT (pick any)
.bss:00002834                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002834                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002834 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002834 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002834                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002834                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002835                 db    ? ;
.bss:00002836                 db    ? ;
.bss:00002837                 db    ? ;
.bss:00002837 _bss            ends
.bss:00002837
.bss:00002838 ; ===========================================================================
.bss:00002838
.bss:00002838 ; Segment type: Uninitialized
.bss:00002838 ; Segment permissions: Read/Write
.bss:00002838 _bss            segment dword public 'BSS' use32
.bss:00002838                 assume cs:_bss
.bss:00002838                 ;org 2838h
.bss:00002838 ; COMDAT (pick any)
.bss:00002838                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002838                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002838 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002838 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002838                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002838                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002839                 db    ? ;
.bss:0000283A                 db    ? ;
.bss:0000283B                 db    ? ;
.bss:0000283B _bss            ends
.bss:0000283B
.bss:0000283C ; ===========================================================================
.bss:0000283C
.bss:0000283C ; Segment type: Uninitialized
.bss:0000283C ; Segment permissions: Read/Write
.bss:0000283C _bss            segment dword public 'BSS' use32
.bss:0000283C                 assume cs:_bss
.bss:0000283C                 ;org 283Ch
.bss:0000283C ; COMDAT (pick any)
.bss:0000283C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:0000283C                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000283C ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000283C ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000283C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000283D                 db    ? ;
.bss:0000283E                 db    ? ;
.bss:0000283F                 db    ? ;
.bss:0000283F _bss            ends
.bss:0000283F
.bss:00002840 ; ===========================================================================
.bss:00002840
.bss:00002840 ; Segment type: Uninitialized
.bss:00002840 ; Segment permissions: Read/Write
.bss:00002840 _bss            segment dword public 'BSS' use32
.bss:00002840                 assume cs:_bss
.bss:00002840                 ;org 2840h
.bss:00002840 ; COMDAT (pick any)
.bss:00002840                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002840                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002840 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00002840 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002840                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00002841                 db    ? ;
.bss:00002842                 db    ? ;
.bss:00002843                 db    ? ;
.bss:00002843 _bss            ends
.bss:00002843
.rdata:00002844 ; ===========================================================================
.rdata:00002844
.rdata:00002844 ; Segment type: Pure data
.rdata:00002844 ; Segment permissions: Read
.rdata:00002844 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002844 _rdata          segment para public 'DATA' use32
.rdata:00002844                 assume cs:_rdata
.rdata:00002844                 ;org 2844h
.rdata:00002844 ; COMDAT (pick any)
.rdata:00002844                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002844 ; wchar_t `string'
.rdata:00002844 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002844                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002844                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00002844                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002844                 unicode 0, <clude\xstring>,0
.rdata:000028D2                 align 4
.rdata:000028D2 _rdata          ends
.rdata:000028D2
.bss:000028D4 ; ===========================================================================
.bss:000028D4
.bss:000028D4 ; Segment type: Uninitialized
.bss:000028D4 ; Segment permissions: Read/Write
.bss:000028D4 _bss            segment dword public 'BSS' use32
.bss:000028D4                 assume cs:_bss
.bss:000028D4                 ;org 28D4h
.bss:000028D4 ; COMDAT (pick any)
.bss:000028D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:000028D4                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:000028D4 ; std::locale::id std::numpunct<char>::id
.bss:000028D4 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:000028D4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:000028D5                 db    ? ;
.bss:000028D6                 db    ? ;
.bss:000028D7                 db    ? ;
.bss:000028D7 _bss            ends
.bss:000028D7
.bss:000028D8 ; ===========================================================================
.bss:000028D8
.bss:000028D8 ; Segment type: Uninitialized
.bss:000028D8 ; Segment permissions: Read/Write
.bss:000028D8 _bss            segment dword public 'BSS' use32
.bss:000028D8                 assume cs:_bss
.bss:000028D8                 ;org 28D8h
.bss:000028D8 ; COMDAT (pick any)
.bss:000028D8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:000028D8                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:000028D8 ; std::locale::id std::numpunct<wchar_t>::id
.bss:000028D8 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:000028D8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:000028D9                 db    ? ;
.bss:000028DA                 db    ? ;
.bss:000028DB                 db    ? ;
.bss:000028DB _bss            ends
.bss:000028DB
.rdata:000028DC ; ===========================================================================
.rdata:000028DC
.rdata:000028DC ; Segment type: Pure data
.rdata:000028DC ; Segment permissions: Read
.rdata:000028DC _rdata          segment dword public 'DATA' use32
.rdata:000028DC                 assume cs:_rdata
.rdata:000028DC                 ;org 28DCh
.rdata:000028DC ; COMDAT (pick any)
.rdata:000028DC                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:000028DC ; char `string'[]
.rdata:000028DC ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:000028DC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:000028DC _rdata          ends
.rdata:000028DC
.rdata:000028EC ; ===========================================================================
.rdata:000028EC
.rdata:000028EC ; Segment type: Pure data
.rdata:000028EC ; Segment permissions: Read
.rdata:000028EC _rdata          segment dword public 'DATA' use32
.rdata:000028EC                 assume cs:_rdata
.rdata:000028EC                 ;org 28ECh
.rdata:000028EC ; COMDAT (pick any)
.rdata:000028EC                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:000028EC ; char `string'[]
.rdata:000028EC ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:000028EC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:000028EC _rdata          ends
.rdata:000028EC
.rdata:00002904 ; ===========================================================================
.rdata:00002904
.rdata:00002904 ; Segment type: Pure data
.rdata:00002904 ; Segment permissions: Read
.rdata:00002904 _rdata          segment dword public 'DATA' use32
.rdata:00002904                 assume cs:_rdata
.rdata:00002904                 ;org 2904h
.rdata:00002904 ; COMDAT (pick any)
.rdata:00002904                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00002904 ; wchar_t `string'
.rdata:00002904 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00002904                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00002904                 unicode 0, <invalid null pointer>,0
.rdata:0000292E                 align 10h
.rdata:0000292E _rdata          ends
.rdata:0000292E
.rdata$r:00002930 ; ===========================================================================
.rdata$r:00002930
.rdata$r:00002930 ; Segment type: Pure data
.rdata$r:00002930 ; Segment permissions: Read
.rdata$r:00002930 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002930                 assume cs:_rdata$r
.rdata$r:00002930                 ;org 2930h
.rdata$r:00002930 ; COMDAT (pick any)
.rdata$r:00002930                 public ??_R4Window@@6B@
.rdata$r:00002930 ; const Window::`RTTI Complete Object Locator'
.rdata$r:00002930 ??_R4Window@@6B@ db    0                ; DATA XREF: .rdata:000026B4o
.rdata$r:00002931                 db    0
.rdata$r:00002932                 db    0
.rdata$r:00002933                 db    0
.rdata$r:00002934                 db    0
.rdata$r:00002935                 db    0
.rdata$r:00002936                 db    0
.rdata$r:00002937                 db    0
.rdata$r:00002938                 db    0
.rdata$r:00002939                 db    0
.rdata$r:0000293A                 db    0
.rdata$r:0000293B                 db    0
.rdata$r:0000293C                 dd offset ??_R0?AVWindow@@@8 ; Window `RTTI Type Descriptor'
.rdata$r:00002940                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002940 _rdata$r        ends
.rdata$r:00002940
.data$r:00002944 ; ===========================================================================
.data$r:00002944
.data$r:00002944 ; Segment type: Pure data
.data$r:00002944 ; Segment permissions: Read/Write
.data$r:00002944 _data$r         segment dword public 'DATA' use32
.data$r:00002944                 assume cs:_data$r
.data$r:00002944                 ;org 2944h
.data$r:00002944 ; COMDAT (pick any)
.data$r:00002944                 public ??_R0?AVWindow@@@8
.data$r:00002944 ; class Window `RTTI Type Descriptor'
.data$r:00002944 ??_R0?AVWindow@@@8 dd offset ??_7type_info@@6B@
.data$r:00002944                                         ; DATA XREF: .rdata$r:0000293Co
.data$r:00002944                                         ; .rdata$r:Window::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002944                                         ; const type_info::`vftable'
.data$r:00002948                 db    0
.data$r:00002949                 db    0
.data$r:0000294A                 db    0
.data$r:0000294B                 db    0
.data$r:0000294C                 db  2Eh ; .
.data$r:0000294D                 db  3Fh ; ?
.data$r:0000294E                 db  41h ; A
.data$r:0000294F                 db  56h ; V
.data$r:00002950                 db  57h ; W
.data$r:00002951                 db  69h ; i
.data$r:00002952                 db  6Eh ; n
.data$r:00002953                 db  64h ; d
.data$r:00002954                 db  6Fh ; o
.data$r:00002955                 db  77h ; w
.data$r:00002956                 db  40h ; @
.data$r:00002957                 db  40h ; @
.data$r:00002958                 db    0
.data$r:00002959                 align 4
.data$r:00002959 _data$r         ends
.data$r:00002959
.rdata$r:0000295C ; ===========================================================================
.rdata$r:0000295C
.rdata$r:0000295C ; Segment type: Pure data
.rdata$r:0000295C ; Segment permissions: Read
.rdata$r:0000295C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000295C                 assume cs:_rdata$r
.rdata$r:0000295C                 ;org 295Ch
.rdata$r:0000295C ; COMDAT (pick any)
.rdata$r:0000295C                 public ??_R3Window@@8
.rdata$r:0000295C ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000295C ??_R3Window@@8  db    0                 ; DATA XREF: .rdata$r:00002940o
.rdata$r:0000295C                                         ; .rdata$r:0000298Co
.rdata$r:0000295D                 db    0
.rdata$r:0000295E                 db    0
.rdata$r:0000295F                 db    0
.rdata$r:00002960                 db    0
.rdata$r:00002961                 db    0
.rdata$r:00002962                 db    0
.rdata$r:00002963                 db    0
.rdata$r:00002964                 db    1
.rdata$r:00002965                 db    0
.rdata$r:00002966                 db    0
.rdata$r:00002967                 db    0
.rdata$r:00002968                 dd offset ??_R2Window@@8 ; Window::`RTTI Base Class Array'
.rdata$r:00002968 _rdata$r        ends
.rdata$r:00002968
.rdata$r:0000296C ; ===========================================================================
.rdata$r:0000296C
.rdata$r:0000296C ; Segment type: Pure data
.rdata$r:0000296C ; Segment permissions: Read
.rdata$r:0000296C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000296C                 assume cs:_rdata$r
.rdata$r:0000296C                 ;org 296Ch
.rdata$r:0000296C ; COMDAT (pick any)
.rdata$r:0000296C                 public ??_R2Window@@8
.rdata$r:0000296C ; Window::`RTTI Base Class Array'
.rdata$r:0000296C ??_R2Window@@8  dd offset ??_R1A@?0A@EA@Window@@8
.rdata$r:0000296C                                         ; DATA XREF: .rdata$r:00002968o
.rdata$r:0000296C                                         ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002970                 db    0
.rdata$r:00002971                 align 4
.rdata$r:00002971 _rdata$r        ends
.rdata$r:00002971
.rdata$r:00002974 ; ===========================================================================
.rdata$r:00002974
.rdata$r:00002974 ; Segment type: Pure data
.rdata$r:00002974 ; Segment permissions: Read
.rdata$r:00002974 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002974                 assume cs:_rdata$r
.rdata$r:00002974                 ;org 2974h
.rdata$r:00002974 ; COMDAT (pick any)
.rdata$r:00002974                 public ??_R1A@?0A@EA@Window@@8
.rdata$r:00002974 ; Window::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002974 ??_R1A@?0A@EA@Window@@8 dd offset ??_R0?AVWindow@@@8
.rdata$r:00002974                                         ; DATA XREF: .rdata$r:Window::`RTTI Base Class Array'o
.rdata$r:00002974                                         ; .rdata$r:000029D4o ...
.rdata$r:00002974                                         ; Window `RTTI Type Descriptor'
.rdata$r:00002978                 align 10h
.rdata$r:00002980                 db 0FFh
.rdata$r:00002981                 db 0FFh
.rdata$r:00002982                 db 0FFh
.rdata$r:00002983                 db 0FFh
.rdata$r:00002984                 db    0
.rdata$r:00002985                 db    0
.rdata$r:00002986                 db    0
.rdata$r:00002987                 db    0
.rdata$r:00002988                 db  40h ; @
.rdata$r:00002989                 db    0
.rdata$r:0000298A                 db    0
.rdata$r:0000298B                 db    0
.rdata$r:0000298C                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000298C _rdata$r        ends
.rdata$r:0000298C
.rdata$r:00002990 ; ===========================================================================
.rdata$r:00002990
.rdata$r:00002990 ; Segment type: Pure data
.rdata$r:00002990 ; Segment permissions: Read
.rdata$r:00002990 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002990                 assume cs:_rdata$r
.rdata$r:00002990                 ;org 2990h
.rdata$r:00002990 ; COMDAT (pick any)
.rdata$r:00002990                 public ??_R4StaticDialog@@6B@
.rdata$r:00002990 ; const StaticDialog::`RTTI Complete Object Locator'
.rdata$r:00002990 ??_R4StaticDialog@@6B@ db    0          ; DATA XREF: .rdata:000026E8o
.rdata$r:00002991                 db    0
.rdata$r:00002992                 db    0
.rdata$r:00002993                 db    0
.rdata$r:00002994                 db    0
.rdata$r:00002995                 db    0
.rdata$r:00002996                 db    0
.rdata$r:00002997                 db    0
.rdata$r:00002998                 db    0
.rdata$r:00002999                 db    0
.rdata$r:0000299A                 db    0
.rdata$r:0000299B                 db    0
.rdata$r:0000299C                 dd offset ??_R0?AVStaticDialog@@@8 ; StaticDialog `RTTI Type Descriptor'
.rdata$r:000029A0                 dd offset ??_R3StaticDialog@@8 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:000029A0 _rdata$r        ends
.rdata$r:000029A0
.data$r:000029A4 ; ===========================================================================
.data$r:000029A4
.data$r:000029A4 ; Segment type: Pure data
.data$r:000029A4 ; Segment permissions: Read/Write
.data$r:000029A4 _data$r         segment dword public 'DATA' use32
.data$r:000029A4                 assume cs:_data$r
.data$r:000029A4                 ;org 29A4h
.data$r:000029A4 ; COMDAT (pick any)
.data$r:000029A4                 public ??_R0?AVStaticDialog@@@8
.data$r:000029A4 ; class StaticDialog `RTTI Type Descriptor'
.data$r:000029A4 ??_R0?AVStaticDialog@@@8 dd offset ??_7type_info@@6B@
.data$r:000029A4                                         ; DATA XREF: .rdata$r:0000299Co
.data$r:000029A4                                         ; .rdata$r:StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000029A4                                         ; const type_info::`vftable'
.data$r:000029A8                 db    0
.data$r:000029A9                 db    0
.data$r:000029AA                 db    0
.data$r:000029AB                 db    0
.data$r:000029AC                 db  2Eh ; .
.data$r:000029AD                 db  3Fh ; ?
.data$r:000029AE                 db  41h ; A
.data$r:000029AF                 db  56h ; V
.data$r:000029B0                 db  53h ; S
.data$r:000029B1                 db  74h ; t
.data$r:000029B2                 db  61h ; a
.data$r:000029B3                 db  74h ; t
.data$r:000029B4                 db  69h ; i
.data$r:000029B5                 db  63h ; c
.data$r:000029B6                 db  44h ; D
.data$r:000029B7                 db  69h ; i
.data$r:000029B8                 db  61h ; a
.data$r:000029B9                 db  6Ch ; l
.data$r:000029BA                 db  6Fh ; o
.data$r:000029BB                 db  67h ; g
.data$r:000029BC                 db  40h ; @
.data$r:000029BD                 db  40h ; @
.data$r:000029BE                 db    0
.data$r:000029BF                 align 10h
.data$r:000029BF _data$r         ends
.data$r:000029BF
.rdata$r:000029C0 ; ===========================================================================
.rdata$r:000029C0
.rdata$r:000029C0 ; Segment type: Pure data
.rdata$r:000029C0 ; Segment permissions: Read
.rdata$r:000029C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000029C0                 assume cs:_rdata$r
.rdata$r:000029C0                 ;org 29C0h
.rdata$r:000029C0 ; COMDAT (pick any)
.rdata$r:000029C0                 public ??_R3StaticDialog@@8
.rdata$r:000029C0 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:000029C0 ??_R3StaticDialog@@8 db    0            ; DATA XREF: .rdata$r:000029A0o
.rdata$r:000029C0                                         ; .rdata$r:000029F4o
.rdata$r:000029C1                 db    0
.rdata$r:000029C2                 db    0
.rdata$r:000029C3                 db    0
.rdata$r:000029C4                 db    0
.rdata$r:000029C5                 db    0
.rdata$r:000029C6                 db    0
.rdata$r:000029C7                 db    0
.rdata$r:000029C8                 db    2
.rdata$r:000029C9                 db    0
.rdata$r:000029CA                 db    0
.rdata$r:000029CB                 db    0
.rdata$r:000029CC                 dd offset ??_R2StaticDialog@@8 ; StaticDialog::`RTTI Base Class Array'
.rdata$r:000029CC _rdata$r        ends
.rdata$r:000029CC
.rdata$r:000029D0 ; ===========================================================================
.rdata$r:000029D0
.rdata$r:000029D0 ; Segment type: Pure data
.rdata$r:000029D0 ; Segment permissions: Read
.rdata$r:000029D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000029D0                 assume cs:_rdata$r
.rdata$r:000029D0                 ;org 29D0h
.rdata$r:000029D0 ; COMDAT (pick any)
.rdata$r:000029D0                 public ??_R2StaticDialog@@8
.rdata$r:000029D0 ; StaticDialog::`RTTI Base Class Array'
.rdata$r:000029D0 ??_R2StaticDialog@@8 dd offset ??_R1A@?0A@EA@StaticDialog@@8
.rdata$r:000029D0                                         ; DATA XREF: .rdata$r:000029CCo
.rdata$r:000029D0                                         ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000029D4                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000029D8                 db    0
.rdata$r:000029D9                 align 4
.rdata$r:000029D9 _rdata$r        ends
.rdata$r:000029D9
.rdata$r:000029DC ; ===========================================================================
.rdata$r:000029DC
.rdata$r:000029DC ; Segment type: Pure data
.rdata$r:000029DC ; Segment permissions: Read
.rdata$r:000029DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000029DC                 assume cs:_rdata$r
.rdata$r:000029DC                 ;org 29DCh
.rdata$r:000029DC ; COMDAT (pick any)
.rdata$r:000029DC                 public ??_R1A@?0A@EA@StaticDialog@@8
.rdata$r:000029DC ; StaticDialog::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000029DC ??_R1A@?0A@EA@StaticDialog@@8 dd offset ??_R0?AVStaticDialog@@@8
.rdata$r:000029DC                                         ; DATA XREF: .rdata$r:StaticDialog::`RTTI Base Class Array'o
.rdata$r:000029DC                                         ; .rdata$r:00002A3Co
.rdata$r:000029DC                                         ; StaticDialog `RTTI Type Descriptor'
.rdata$r:000029E0                 db    1
.rdata$r:000029E1                 db    0
.rdata$r:000029E2                 db    0
.rdata$r:000029E3                 db    0
.rdata$r:000029E4                 db    0
.rdata$r:000029E5                 db    0
.rdata$r:000029E6                 db    0
.rdata$r:000029E7                 db    0
.rdata$r:000029E8                 db 0FFh
.rdata$r:000029E9                 db 0FFh
.rdata$r:000029EA                 db 0FFh
.rdata$r:000029EB                 db 0FFh
.rdata$r:000029EC                 db    0
.rdata$r:000029ED                 db    0
.rdata$r:000029EE                 db    0
.rdata$r:000029EF                 db    0
.rdata$r:000029F0                 db  40h ; @
.rdata$r:000029F1                 db    0
.rdata$r:000029F2                 db    0
.rdata$r:000029F3                 db    0
.rdata$r:000029F4                 dd offset ??_R3StaticDialog@@8 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:000029F4 _rdata$r        ends
.rdata$r:000029F4
.rdata$r:000029F8 ; ===========================================================================
.rdata$r:000029F8
.rdata$r:000029F8 ; Segment type: Pure data
.rdata$r:000029F8 ; Segment permissions: Read
.rdata$r:000029F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000029F8                 assume cs:_rdata$r
.rdata$r:000029F8                 ;org 29F8h
.rdata$r:000029F8 ; COMDAT (pick any)
.rdata$r:000029F8                 public ??_R4SizeableDlg@@6B@
.rdata$r:000029F8 ; const SizeableDlg::`RTTI Complete Object Locator'
.rdata$r:000029F8 ??_R4SizeableDlg@@6B@ db    0           ; DATA XREF: .rdata:00002728o
.rdata$r:000029F9                 db    0
.rdata$r:000029FA                 db    0
.rdata$r:000029FB                 db    0
.rdata$r:000029FC                 db    0
.rdata$r:000029FD                 db    0
.rdata$r:000029FE                 db    0
.rdata$r:000029FF                 db    0
.rdata$r:00002A00                 db    0
.rdata$r:00002A01                 db    0
.rdata$r:00002A02                 db    0
.rdata$r:00002A03                 db    0
.rdata$r:00002A04                 dd offset ??_R0?AVSizeableDlg@@@8 ; SizeableDlg `RTTI Type Descriptor'
.rdata$r:00002A08                 dd offset ??_R3SizeableDlg@@8 ; SizeableDlg::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A08 _rdata$r        ends
.rdata$r:00002A08
.data$r:00002A0C ; ===========================================================================
.data$r:00002A0C
.data$r:00002A0C ; Segment type: Pure data
.data$r:00002A0C ; Segment permissions: Read/Write
.data$r:00002A0C _data$r         segment dword public 'DATA' use32
.data$r:00002A0C                 assume cs:_data$r
.data$r:00002A0C                 ;org 2A0Ch
.data$r:00002A0C ; COMDAT (pick any)
.data$r:00002A0C                 public ??_R0?AVSizeableDlg@@@8
.data$r:00002A0C ; class SizeableDlg `RTTI Type Descriptor'
.data$r:00002A0C ??_R0?AVSizeableDlg@@@8 dd offset ??_7type_info@@6B@
.data$r:00002A0C                                         ; DATA XREF: .rdata$r:00002A04o
.data$r:00002A0C                                         ; .rdata$r:SizeableDlg::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002A0C                                         ; const type_info::`vftable'
.data$r:00002A10                 db    0
.data$r:00002A11                 db    0
.data$r:00002A12                 db    0
.data$r:00002A13                 db    0
.data$r:00002A14                 db  2Eh ; .
.data$r:00002A15                 db  3Fh ; ?
.data$r:00002A16                 db  41h ; A
.data$r:00002A17                 db  56h ; V
.data$r:00002A18                 db  53h ; S
.data$r:00002A19                 db  69h ; i
.data$r:00002A1A                 db  7Ah ; z
.data$r:00002A1B                 db  65h ; e
.data$r:00002A1C                 db  61h ; a
.data$r:00002A1D                 db  62h ; b
.data$r:00002A1E                 db  6Ch ; l
.data$r:00002A1F                 db  65h ; e
.data$r:00002A20                 db  44h ; D
.data$r:00002A21                 db  6Ch ; l
.data$r:00002A22                 db  67h ; g
.data$r:00002A23                 db  40h ; @
.data$r:00002A24                 db  40h ; @
.data$r:00002A25                 db    0
.data$r:00002A26                 align 4
.data$r:00002A26 _data$r         ends
.data$r:00002A26
.rdata$r:00002A28 ; ===========================================================================
.rdata$r:00002A28
.rdata$r:00002A28 ; Segment type: Pure data
.rdata$r:00002A28 ; Segment permissions: Read
.rdata$r:00002A28 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A28                 assume cs:_rdata$r
.rdata$r:00002A28                 ;org 2A28h
.rdata$r:00002A28 ; COMDAT (pick any)
.rdata$r:00002A28                 public ??_R3SizeableDlg@@8
.rdata$r:00002A28 ; SizeableDlg::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A28 ??_R3SizeableDlg@@8 db    0             ; DATA XREF: .rdata$r:00002A08o
.rdata$r:00002A28                                         ; .rdata$r:00002A60o
.rdata$r:00002A29                 db    0
.rdata$r:00002A2A                 db    0
.rdata$r:00002A2B                 db    0
.rdata$r:00002A2C                 db    0
.rdata$r:00002A2D                 db    0
.rdata$r:00002A2E                 db    0
.rdata$r:00002A2F                 db    0
.rdata$r:00002A30                 db    3
.rdata$r:00002A31                 db    0
.rdata$r:00002A32                 db    0
.rdata$r:00002A33                 db    0
.rdata$r:00002A34                 dd offset ??_R2SizeableDlg@@8 ; SizeableDlg::`RTTI Base Class Array'
.rdata$r:00002A34 _rdata$r        ends
.rdata$r:00002A34
.rdata$r:00002A38 ; ===========================================================================
.rdata$r:00002A38
.rdata$r:00002A38 ; Segment type: Pure data
.rdata$r:00002A38 ; Segment permissions: Read
.rdata$r:00002A38 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A38                 assume cs:_rdata$r
.rdata$r:00002A38                 ;org 2A38h
.rdata$r:00002A38 ; COMDAT (pick any)
.rdata$r:00002A38                 public ??_R2SizeableDlg@@8
.rdata$r:00002A38 ; SizeableDlg::`RTTI Base Class Array'
.rdata$r:00002A38 ??_R2SizeableDlg@@8 dd offset ??_R1A@?0A@EA@SizeableDlg@@8
.rdata$r:00002A38                                         ; DATA XREF: .rdata$r:00002A34o
.rdata$r:00002A38                                         ; SizeableDlg::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A3C                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A40                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A44                 db    0
.rdata$r:00002A45                 align 4
.rdata$r:00002A45 _rdata$r        ends
.rdata$r:00002A45
.rdata$r:00002A48 ; ===========================================================================
.rdata$r:00002A48
.rdata$r:00002A48 ; Segment type: Pure data
.rdata$r:00002A48 ; Segment permissions: Read
.rdata$r:00002A48 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A48                 assume cs:_rdata$r
.rdata$r:00002A48                 ;org 2A48h
.rdata$r:00002A48 ; COMDAT (pick any)
.rdata$r:00002A48                 public ??_R1A@?0A@EA@SizeableDlg@@8
.rdata$r:00002A48 ; SizeableDlg::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002A48 ??_R1A@?0A@EA@SizeableDlg@@8 dd offset ??_R0?AVSizeableDlg@@@8
.rdata$r:00002A48                                         ; DATA XREF: .rdata$r:SizeableDlg::`RTTI Base Class Array'o
.rdata$r:00002A48                                         ; SizeableDlg `RTTI Type Descriptor'
.rdata$r:00002A4C                 db    2
.rdata$r:00002A4D                 db    0
.rdata$r:00002A4E                 db    0
.rdata$r:00002A4F                 db    0
.rdata$r:00002A50                 db    0
.rdata$r:00002A51                 db    0
.rdata$r:00002A52                 db    0
.rdata$r:00002A53                 db    0
.rdata$r:00002A54                 db 0FFh
.rdata$r:00002A55                 db 0FFh
.rdata$r:00002A56                 db 0FFh
.rdata$r:00002A57                 db 0FFh
.rdata$r:00002A58                 db    0
.rdata$r:00002A59                 db    0
.rdata$r:00002A5A                 db    0
.rdata$r:00002A5B                 db    0
.rdata$r:00002A5C                 db  40h ; @
.rdata$r:00002A5D                 db    0
.rdata$r:00002A5E                 db    0
.rdata$r:00002A5F                 db    0
.rdata$r:00002A60                 dd offset ??_R3SizeableDlg@@8 ; SizeableDlg::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A60 _rdata$r        ends
.rdata$r:00002A60
.rdata$r:00002A64 ; ===========================================================================
.rdata$r:00002A64
.rdata$r:00002A64 ; Segment type: Pure data
.rdata$r:00002A64 ; Segment permissions: Read
.rdata$r:00002A64 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A64                 assume cs:_rdata$r
.rdata$r:00002A64                 ;org 2A64h
.rdata$r:00002A64 ; COMDAT (pick any)
.rdata$r:00002A64                 public ??_R4error_category@std@@6B@
.rdata$r:00002A64 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002A64 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000277Co
.rdata$r:00002A65                 db    0
.rdata$r:00002A66                 db    0
.rdata$r:00002A67                 db    0
.rdata$r:00002A68                 db    0
.rdata$r:00002A69                 db    0
.rdata$r:00002A6A                 db    0
.rdata$r:00002A6B                 db    0
.rdata$r:00002A6C                 db    0
.rdata$r:00002A6D                 db    0
.rdata$r:00002A6E                 db    0
.rdata$r:00002A6F                 db    0
.rdata$r:00002A70                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002A74                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A74 _rdata$r        ends
.rdata$r:00002A74
.data$r:00002A78 ; ===========================================================================
.data$r:00002A78
.data$r:00002A78 ; Segment type: Pure data
.data$r:00002A78 ; Segment permissions: Read/Write
.data$r:00002A78 _data$r         segment dword public 'DATA' use32
.data$r:00002A78                 assume cs:_data$r
.data$r:00002A78                 ;org 2A78h
.data$r:00002A78 ; COMDAT (pick any)
.data$r:00002A78                 public ??_R0?AVerror_category@std@@@8
.data$r:00002A78 ; class std::error_category `RTTI Type Descriptor'
.data$r:00002A78 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002A78                                         ; DATA XREF: .rdata$r:00002A70o
.data$r:00002A78                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002A78                                         ; const type_info::`vftable'
.data$r:00002A7C                 align 10h
.data$r:00002A80 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00002A99                 align 4
.data$r:00002A99 _data$r         ends
.data$r:00002A99
.rdata$r:00002A9C ; ===========================================================================
.rdata$r:00002A9C
.rdata$r:00002A9C ; Segment type: Pure data
.rdata$r:00002A9C ; Segment permissions: Read
.rdata$r:00002A9C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A9C                 assume cs:_rdata$r
.rdata$r:00002A9C                 ;org 2A9Ch
.rdata$r:00002A9C ; COMDAT (pick any)
.rdata$r:00002A9C                 public ??_R3error_category@std@@8
.rdata$r:00002A9C ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A9C ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00002A74o
.rdata$r:00002A9C                                         ; .rdata$r:00002ACCo
.rdata$r:00002A9D                 db    0
.rdata$r:00002A9E                 db    0
.rdata$r:00002A9F                 db    0
.rdata$r:00002AA0                 db    0
.rdata$r:00002AA1                 db    0
.rdata$r:00002AA2                 db    0
.rdata$r:00002AA3                 db    0
.rdata$r:00002AA4                 db    1
.rdata$r:00002AA5                 db    0
.rdata$r:00002AA6                 db    0
.rdata$r:00002AA7                 db    0
.rdata$r:00002AA8                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002AA8 _rdata$r        ends
.rdata$r:00002AA8
.rdata$r:00002AAC ; ===========================================================================
.rdata$r:00002AAC
.rdata$r:00002AAC ; Segment type: Pure data
.rdata$r:00002AAC ; Segment permissions: Read
.rdata$r:00002AAC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002AAC                 assume cs:_rdata$r
.rdata$r:00002AAC                 ;org 2AACh
.rdata$r:00002AAC ; COMDAT (pick any)
.rdata$r:00002AAC                 public ??_R2error_category@std@@8
.rdata$r:00002AAC ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002AAC ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002AAC                                         ; DATA XREF: .rdata$r:00002AA8o
.rdata$r:00002AAC                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002AB0                 db    0
.rdata$r:00002AB1                 align 4
.rdata$r:00002AB1 _rdata$r        ends
.rdata$r:00002AB1
.rdata$r:00002AB4 ; ===========================================================================
.rdata$r:00002AB4
.rdata$r:00002AB4 ; Segment type: Pure data
.rdata$r:00002AB4 ; Segment permissions: Read
.rdata$r:00002AB4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002AB4                 assume cs:_rdata$r
.rdata$r:00002AB4                 ;org 2AB4h
.rdata$r:00002AB4 ; COMDAT (pick any)
.rdata$r:00002AB4                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002AB4 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002AB4 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00002AB4                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00002AB4                                         ; .rdata$r:00002B24o ...
.rdata$r:00002AB4                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002AB8                 align 10h
.rdata$r:00002AC0                 db 0FFh
.rdata$r:00002AC1                 db 0FFh
.rdata$r:00002AC2                 db 0FFh
.rdata$r:00002AC3                 db 0FFh
.rdata$r:00002AC4                 db    0
.rdata$r:00002AC5                 db    0
.rdata$r:00002AC6                 db    0
.rdata$r:00002AC7                 db    0
.rdata$r:00002AC8                 db  40h ; @
.rdata$r:00002AC9                 db    0
.rdata$r:00002ACA                 db    0
.rdata$r:00002ACB                 db    0
.rdata$r:00002ACC                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002ACC _rdata$r        ends
.rdata$r:00002ACC
.rdata$r:00002AD0 ; ===========================================================================
.rdata$r:00002AD0
.rdata$r:00002AD0 ; Segment type: Pure data
.rdata$r:00002AD0 ; Segment permissions: Read
.rdata$r:00002AD0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002AD0                 assume cs:_rdata$r
.rdata$r:00002AD0                 ;org 2AD0h
.rdata$r:00002AD0 ; COMDAT (pick any)
.rdata$r:00002AD0                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00002AD0 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00002AD0 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00002AD0                                         ; DATA XREF: .rdata:00002798o
.rdata$r:00002AD1                 db    0
.rdata$r:00002AD2                 db    0
.rdata$r:00002AD3                 db    0
.rdata$r:00002AD4                 db    0
.rdata$r:00002AD5                 db    0
.rdata$r:00002AD6                 db    0
.rdata$r:00002AD7                 db    0
.rdata$r:00002AD8                 db    0
.rdata$r:00002AD9                 db    0
.rdata$r:00002ADA                 db    0
.rdata$r:00002ADB                 db    0
.rdata$r:00002ADC                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002AE0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002AE0 _rdata$r        ends
.rdata$r:00002AE0
.data$r:00002AE4 ; ===========================================================================
.data$r:00002AE4
.data$r:00002AE4 ; Segment type: Pure data
.data$r:00002AE4 ; Segment permissions: Read/Write
.data$r:00002AE4 _data$r         segment dword public 'DATA' use32
.data$r:00002AE4                 assume cs:_data$r
.data$r:00002AE4                 ;org 2AE4h
.data$r:00002AE4 ; COMDAT (pick any)
.data$r:00002AE4                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00002AE4 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00002AE4 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002AE4                                         ; DATA XREF: .rdata$r:00002ADCo
.data$r:00002AE4                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002AE4                                         ; const type_info::`vftable'
.data$r:00002AE8                 db    0
.data$r:00002AE9                 db    0
.data$r:00002AEA                 db    0
.data$r:00002AEB                 db    0
.data$r:00002AEC                 db  2Eh ; .
.data$r:00002AED                 db  3Fh ; ?
.data$r:00002AEE                 db  41h ; A
.data$r:00002AEF                 db  56h ; V
.data$r:00002AF0                 db  5Fh ; _
.data$r:00002AF1                 db  47h ; G
.data$r:00002AF2                 db  65h ; e
.data$r:00002AF3                 db  6Eh ; n
.data$r:00002AF4                 db  65h ; e
.data$r:00002AF5                 db  72h ; r
.data$r:00002AF6                 db  69h ; i
.data$r:00002AF7                 db  63h ; c
.data$r:00002AF8                 db  5Fh ; _
.data$r:00002AF9                 db  65h ; e
.data$r:00002AFA                 db  72h ; r
.data$r:00002AFB                 db  72h ; r
.data$r:00002AFC                 db  6Fh ; o
.data$r:00002AFD                 db  72h ; r
.data$r:00002AFE                 db  5Fh ; _
.data$r:00002AFF                 db  63h ; c
.data$r:00002B00                 db  61h ; a
.data$r:00002B01                 db  74h ; t
.data$r:00002B02                 db  65h ; e
.data$r:00002B03                 db  67h ; g
.data$r:00002B04                 db  6Fh ; o
.data$r:00002B05                 db  72h ; r
.data$r:00002B06                 db  79h ; y
.data$r:00002B07                 db  40h ; @
.data$r:00002B08                 db  73h ; s
.data$r:00002B09                 db  74h ; t
.data$r:00002B0A                 db  64h ; d
.data$r:00002B0B                 db  40h ; @
.data$r:00002B0C                 db  40h ; @
.data$r:00002B0D                 db    0
.data$r:00002B0E                 align 10h
.data$r:00002B0E _data$r         ends
.data$r:00002B0E
.rdata$r:00002B10 ; ===========================================================================
.rdata$r:00002B10
.rdata$r:00002B10 ; Segment type: Pure data
.rdata$r:00002B10 ; Segment permissions: Read
.rdata$r:00002B10 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B10                 assume cs:_rdata$r
.rdata$r:00002B10                 ;org 2B10h
.rdata$r:00002B10 ; COMDAT (pick any)
.rdata$r:00002B10                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00002B10 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002B10 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00002B10                                         ; DATA XREF: .rdata$r:00002AE0o
.rdata$r:00002B10                                         ; .rdata$r:00002B44o
.rdata$r:00002B11                 db    0
.rdata$r:00002B12                 db    0
.rdata$r:00002B13                 db    0
.rdata$r:00002B14                 db    0
.rdata$r:00002B15                 db    0
.rdata$r:00002B16                 db    0
.rdata$r:00002B17                 db    0
.rdata$r:00002B18                 db    2
.rdata$r:00002B19                 db    0
.rdata$r:00002B1A                 db    0
.rdata$r:00002B1B                 db    0
.rdata$r:00002B1C                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002B1C _rdata$r        ends
.rdata$r:00002B1C
.rdata$r:00002B20 ; ===========================================================================
.rdata$r:00002B20
.rdata$r:00002B20 ; Segment type: Pure data
.rdata$r:00002B20 ; Segment permissions: Read
.rdata$r:00002B20 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B20                 assume cs:_rdata$r
.rdata$r:00002B20                 ;org 2B20h
.rdata$r:00002B20 ; COMDAT (pick any)
.rdata$r:00002B20                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00002B20 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002B20 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002B20                                         ; DATA XREF: .rdata$r:00002B1Co
.rdata$r:00002B20                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002B24                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002B28                 db    0
.rdata$r:00002B29                 align 4
.rdata$r:00002B29 _rdata$r        ends
.rdata$r:00002B29
.rdata$r:00002B2C ; ===========================================================================
.rdata$r:00002B2C
.rdata$r:00002B2C ; Segment type: Pure data
.rdata$r:00002B2C ; Segment permissions: Read
.rdata$r:00002B2C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B2C                 assume cs:_rdata$r
.rdata$r:00002B2C                 ;org 2B2Ch
.rdata$r:00002B2C ; COMDAT (pick any)
.rdata$r:00002B2C                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002B2C ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002B2C ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00002B2C                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00002B2C                                         ; .rdata$r:00002B9Co ...
.rdata$r:00002B2C                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002B30                 db    1
.rdata$r:00002B31                 db    0
.rdata$r:00002B32                 db    0
.rdata$r:00002B33                 db    0
.rdata$r:00002B34                 db    0
.rdata$r:00002B35                 db    0
.rdata$r:00002B36                 db    0
.rdata$r:00002B37                 db    0
.rdata$r:00002B38                 db 0FFh
.rdata$r:00002B39                 db 0FFh
.rdata$r:00002B3A                 db 0FFh
.rdata$r:00002B3B                 db 0FFh
.rdata$r:00002B3C                 db    0
.rdata$r:00002B3D                 db    0
.rdata$r:00002B3E                 db    0
.rdata$r:00002B3F                 db    0
.rdata$r:00002B40                 db  40h ; @
.rdata$r:00002B41                 db    0
.rdata$r:00002B42                 db    0
.rdata$r:00002B43                 db    0
.rdata$r:00002B44                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002B44 _rdata$r        ends
.rdata$r:00002B44
.rdata$r:00002B48 ; ===========================================================================
.rdata$r:00002B48
.rdata$r:00002B48 ; Segment type: Pure data
.rdata$r:00002B48 ; Segment permissions: Read
.rdata$r:00002B48 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B48                 assume cs:_rdata$r
.rdata$r:00002B48                 ;org 2B48h
.rdata$r:00002B48 ; COMDAT (pick any)
.rdata$r:00002B48                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00002B48 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00002B48 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00002B48                                         ; DATA XREF: .rdata:000027CCo
.rdata$r:00002B49                 db    0
.rdata$r:00002B4A                 db    0
.rdata$r:00002B4B                 db    0
.rdata$r:00002B4C                 db    0
.rdata$r:00002B4D                 db    0
.rdata$r:00002B4E                 db    0
.rdata$r:00002B4F                 db    0
.rdata$r:00002B50                 db    0
.rdata$r:00002B51                 db    0
.rdata$r:00002B52                 db    0
.rdata$r:00002B53                 db    0
.rdata$r:00002B54                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002B58                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002B58 _rdata$r        ends
.rdata$r:00002B58
.data$r:00002B5C ; ===========================================================================
.data$r:00002B5C
.data$r:00002B5C ; Segment type: Pure data
.data$r:00002B5C ; Segment permissions: Read/Write
.data$r:00002B5C _data$r         segment dword public 'DATA' use32
.data$r:00002B5C                 assume cs:_data$r
.data$r:00002B5C                 ;org 2B5Ch
.data$r:00002B5C ; COMDAT (pick any)
.data$r:00002B5C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00002B5C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00002B5C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002B5C                                         ; DATA XREF: .rdata$r:00002B54o
.data$r:00002B5C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002B5C                                         ; const type_info::`vftable'
.data$r:00002B60                 db    0
.data$r:00002B61                 db    0
.data$r:00002B62                 db    0
.data$r:00002B63                 db    0
.data$r:00002B64                 db  2Eh ; .
.data$r:00002B65                 db  3Fh ; ?
.data$r:00002B66                 db  41h ; A
.data$r:00002B67                 db  56h ; V
.data$r:00002B68                 db  5Fh ; _
.data$r:00002B69                 db  49h ; I
.data$r:00002B6A                 db  6Fh ; o
.data$r:00002B6B                 db  73h ; s
.data$r:00002B6C                 db  74h ; t
.data$r:00002B6D                 db  72h ; r
.data$r:00002B6E                 db  65h ; e
.data$r:00002B6F                 db  61h ; a
.data$r:00002B70                 db  6Dh ; m
.data$r:00002B71                 db  5Fh ; _
.data$r:00002B72                 db  65h ; e
.data$r:00002B73                 db  72h ; r
.data$r:00002B74                 db  72h ; r
.data$r:00002B75                 db  6Fh ; o
.data$r:00002B76                 db  72h ; r
.data$r:00002B77                 db  5Fh ; _
.data$r:00002B78                 db  63h ; c
.data$r:00002B79                 db  61h ; a
.data$r:00002B7A                 db  74h ; t
.data$r:00002B7B                 db  65h ; e
.data$r:00002B7C                 db  67h ; g
.data$r:00002B7D                 db  6Fh ; o
.data$r:00002B7E                 db  72h ; r
.data$r:00002B7F                 db  79h ; y
.data$r:00002B80                 db  40h ; @
.data$r:00002B81                 db  73h ; s
.data$r:00002B82                 db  74h ; t
.data$r:00002B83                 db  64h ; d
.data$r:00002B84                 db  40h ; @
.data$r:00002B85                 db  40h ; @
.data$r:00002B86                 db    0
.data$r:00002B87                 align 4
.data$r:00002B87 _data$r         ends
.data$r:00002B87
.rdata$r:00002B88 ; ===========================================================================
.rdata$r:00002B88
.rdata$r:00002B88 ; Segment type: Pure data
.rdata$r:00002B88 ; Segment permissions: Read
.rdata$r:00002B88 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B88                 assume cs:_rdata$r
.rdata$r:00002B88                 ;org 2B88h
.rdata$r:00002B88 ; COMDAT (pick any)
.rdata$r:00002B88                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002B88 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002B88 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002B88                                         ; DATA XREF: .rdata$r:00002B58o
.rdata$r:00002B88                                         ; .rdata$r:00002BC0o
.rdata$r:00002B89                 db    0
.rdata$r:00002B8A                 db    0
.rdata$r:00002B8B                 db    0
.rdata$r:00002B8C                 db    0
.rdata$r:00002B8D                 db    0
.rdata$r:00002B8E                 db    0
.rdata$r:00002B8F                 db    0
.rdata$r:00002B90                 db    3
.rdata$r:00002B91                 db    0
.rdata$r:00002B92                 db    0
.rdata$r:00002B93                 db    0
.rdata$r:00002B94                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002B94 _rdata$r        ends
.rdata$r:00002B94
.rdata$r:00002B98 ; ===========================================================================
.rdata$r:00002B98
.rdata$r:00002B98 ; Segment type: Pure data
.rdata$r:00002B98 ; Segment permissions: Read
.rdata$r:00002B98 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002B98                 assume cs:_rdata$r
.rdata$r:00002B98                 ;org 2B98h
.rdata$r:00002B98 ; COMDAT (pick any)
.rdata$r:00002B98                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002B98 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002B98 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002B98                                         ; DATA XREF: .rdata$r:00002B94o
.rdata$r:00002B98                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002B9C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002BA0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002BA4                 db    0
.rdata$r:00002BA5                 align 4
.rdata$r:00002BA5 _rdata$r        ends
.rdata$r:00002BA5
.rdata$r:00002BA8 ; ===========================================================================
.rdata$r:00002BA8
.rdata$r:00002BA8 ; Segment type: Pure data
.rdata$r:00002BA8 ; Segment permissions: Read
.rdata$r:00002BA8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002BA8                 assume cs:_rdata$r
.rdata$r:00002BA8                 ;org 2BA8h
.rdata$r:00002BA8 ; COMDAT (pick any)
.rdata$r:00002BA8                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002BA8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002BA8 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002BA8                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002BA8                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002BAC                 db    2
.rdata$r:00002BAD                 db    0
.rdata$r:00002BAE                 db    0
.rdata$r:00002BAF                 db    0
.rdata$r:00002BB0                 db    0
.rdata$r:00002BB1                 db    0
.rdata$r:00002BB2                 db    0
.rdata$r:00002BB3                 db    0
.rdata$r:00002BB4                 db 0FFh
.rdata$r:00002BB5                 db 0FFh
.rdata$r:00002BB6                 db 0FFh
.rdata$r:00002BB7                 db 0FFh
.rdata$r:00002BB8                 db    0
.rdata$r:00002BB9                 db    0
.rdata$r:00002BBA                 db    0
.rdata$r:00002BBB                 db    0
.rdata$r:00002BBC                 db  40h ; @
.rdata$r:00002BBD                 db    0
.rdata$r:00002BBE                 db    0
.rdata$r:00002BBF                 db    0
.rdata$r:00002BC0                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002BC0 _rdata$r        ends
.rdata$r:00002BC0
.rdata$r:00002BC4 ; ===========================================================================
.rdata$r:00002BC4
.rdata$r:00002BC4 ; Segment type: Pure data
.rdata$r:00002BC4 ; Segment permissions: Read
.rdata$r:00002BC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002BC4                 assume cs:_rdata$r
.rdata$r:00002BC4                 ;org 2BC4h
.rdata$r:00002BC4 ; COMDAT (pick any)
.rdata$r:00002BC4                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00002BC4 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00002BC4 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000280Co
.rdata$r:00002BC5                 db    0
.rdata$r:00002BC6                 db    0
.rdata$r:00002BC7                 db    0
.rdata$r:00002BC8                 db    0
.rdata$r:00002BC9                 db    0
.rdata$r:00002BCA                 db    0
.rdata$r:00002BCB                 db    0
.rdata$r:00002BCC                 db    0
.rdata$r:00002BCD                 db    0
.rdata$r:00002BCE                 db    0
.rdata$r:00002BCF                 db    0
.rdata$r:00002BD0                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002BD4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002BD4 _rdata$r        ends
.rdata$r:00002BD4
.data$r:00002BD8 ; ===========================================================================
.data$r:00002BD8
.data$r:00002BD8 ; Segment type: Pure data
.data$r:00002BD8 ; Segment permissions: Read/Write
.data$r:00002BD8 _data$r         segment dword public 'DATA' use32
.data$r:00002BD8                 assume cs:_data$r
.data$r:00002BD8                 ;org 2BD8h
.data$r:00002BD8 ; COMDAT (pick any)
.data$r:00002BD8                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002BD8 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002BD8 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002BD8                                         ; DATA XREF: .rdata$r:00002BD0o
.data$r:00002BD8                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002BD8                                         ; const type_info::`vftable'
.data$r:00002BDC                 align 10h
.data$r:00002BE0 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00002C01                 align 4
.data$r:00002C01 _data$r         ends
.data$r:00002C01
.rdata$r:00002C04 ; ===========================================================================
.rdata$r:00002C04
.rdata$r:00002C04 ; Segment type: Pure data
.rdata$r:00002C04 ; Segment permissions: Read
.rdata$r:00002C04 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002C04                 assume cs:_rdata$r
.rdata$r:00002C04                 ;org 2C04h
.rdata$r:00002C04 ; COMDAT (pick any)
.rdata$r:00002C04                 public ??_R3_System_error_category@std@@8
.rdata$r:00002C04 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002C04 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002BD4o
.rdata$r:00002C04                                         ; .rdata$r:00002C3Co
.rdata$r:00002C05                 db    0
.rdata$r:00002C06                 db    0
.rdata$r:00002C07                 db    0
.rdata$r:00002C08                 db    0
.rdata$r:00002C09                 db    0
.rdata$r:00002C0A                 db    0
.rdata$r:00002C0B                 db    0
.rdata$r:00002C0C                 db    3
.rdata$r:00002C0D                 db    0
.rdata$r:00002C0E                 db    0
.rdata$r:00002C0F                 db    0
.rdata$r:00002C10                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002C10 _rdata$r        ends
.rdata$r:00002C10
.rdata$r:00002C14 ; ===========================================================================
.rdata$r:00002C14
.rdata$r:00002C14 ; Segment type: Pure data
.rdata$r:00002C14 ; Segment permissions: Read
.rdata$r:00002C14 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002C14                 assume cs:_rdata$r
.rdata$r:00002C14                 ;org 2C14h
.rdata$r:00002C14 ; COMDAT (pick any)
.rdata$r:00002C14                 public ??_R2_System_error_category@std@@8
.rdata$r:00002C14 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002C14 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002C14                                         ; DATA XREF: .rdata$r:00002C10o
.rdata$r:00002C14                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002C18                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002C1C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002C20                 db    0
.rdata$r:00002C21                 align 4
.rdata$r:00002C21 _rdata$r        ends
.rdata$r:00002C21
.rdata$r:00002C24 ; ===========================================================================
.rdata$r:00002C24
.rdata$r:00002C24 ; Segment type: Pure data
.rdata$r:00002C24 ; Segment permissions: Read
.rdata$r:00002C24 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002C24                 assume cs:_rdata$r
.rdata$r:00002C24                 ;org 2C24h
.rdata$r:00002C24 ; COMDAT (pick any)
.rdata$r:00002C24                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002C24 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002C24 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00002C24                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00002C24                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002C28                 db    2
.rdata$r:00002C29                 db    0
.rdata$r:00002C2A                 db    0
.rdata$r:00002C2B                 db    0
.rdata$r:00002C2C                 db    0
.rdata$r:00002C2D                 db    0
.rdata$r:00002C2E                 db    0
.rdata$r:00002C2F                 db    0
.rdata$r:00002C30                 db 0FFh
.rdata$r:00002C31                 db 0FFh
.rdata$r:00002C32                 db 0FFh
.rdata$r:00002C33                 db 0FFh
.rdata$r:00002C34                 db    0
.rdata$r:00002C35                 db    0
.rdata$r:00002C36                 db    0
.rdata$r:00002C37                 db    0
.rdata$r:00002C38                 db  40h ; @
.rdata$r:00002C39                 db    0
.rdata$r:00002C3A                 db    0
.rdata$r:00002C3B                 db    0
.rdata$r:00002C3C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002C3C _rdata$r        ends
.rdata$r:00002C3C
.CRT$XCU:00002C40 ; ===========================================================================
.CRT$XCU:00002C40
.CRT$XCU:00002C40 ; Segment type: Pure data
.CRT$XCU:00002C40 ; Segment permissions: Read
.CRT$XCU:00002C40 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C40                 assume cs:_CRT$XCU
.CRT$XCU:00002C40                 ;org 2C40h
.CRT$XCU:00002C40 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002C44 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002C44 _CRT$XCU        ends
.CRT$XCU:00002C44
.CRT$XCU:00002C48 ; ===========================================================================
.CRT$XCU:00002C48
.CRT$XCU:00002C48 ; Segment type: Pure data
.CRT$XCU:00002C48 ; Segment permissions: Read
.CRT$XCU:00002C48 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C48                 assume cs:_CRT$XCU
.CRT$XCU:00002C48                 ;org 2C48h
.CRT$XCU:00002C48 ; COMDAT (pick associative to section at 2830)
.CRT$XCU:00002C48 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00002C48 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00002C48 _CRT$XCU        ends
.CRT$XCU:00002C48
.CRT$XCU:00002C4C ; ===========================================================================
.CRT$XCU:00002C4C
.CRT$XCU:00002C4C ; Segment type: Pure data
.CRT$XCU:00002C4C ; Segment permissions: Read
.CRT$XCU:00002C4C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C4C                 assume cs:_CRT$XCU
.CRT$XCU:00002C4C                 ;org 2C4Ch
.CRT$XCU:00002C4C ; COMDAT (pick associative to section at 2834)
.CRT$XCU:00002C4C ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00002C4C ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00002C4C _CRT$XCU        ends
.CRT$XCU:00002C4C
.CRT$XCU:00002C50 ; ===========================================================================
.CRT$XCU:00002C50
.CRT$XCU:00002C50 ; Segment type: Pure data
.CRT$XCU:00002C50 ; Segment permissions: Read
.CRT$XCU:00002C50 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C50                 assume cs:_CRT$XCU
.CRT$XCU:00002C50                 ;org 2C50h
.CRT$XCU:00002C50 ; COMDAT (pick associative to section at 2838)
.CRT$XCU:00002C50 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002C50 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002C50 _CRT$XCU        ends
.CRT$XCU:00002C50
.CRT$XCU:00002C54 ; ===========================================================================
.CRT$XCU:00002C54
.CRT$XCU:00002C54 ; Segment type: Pure data
.CRT$XCU:00002C54 ; Segment permissions: Read
.CRT$XCU:00002C54 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C54                 assume cs:_CRT$XCU
.CRT$XCU:00002C54                 ;org 2C54h
.CRT$XCU:00002C54 ; COMDAT (pick associative to section at 283C)
.CRT$XCU:00002C54 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00002C54 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00002C54 _CRT$XCU        ends
.CRT$XCU:00002C54
.CRT$XCU:00002C58 ; ===========================================================================
.CRT$XCU:00002C58
.CRT$XCU:00002C58 ; Segment type: Pure data
.CRT$XCU:00002C58 ; Segment permissions: Read
.CRT$XCU:00002C58 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C58                 assume cs:_CRT$XCU
.CRT$XCU:00002C58                 ;org 2C58h
.CRT$XCU:00002C58 ; COMDAT (pick associative to section at 2840)
.CRT$XCU:00002C58 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00002C58 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00002C58 _CRT$XCU        ends
.CRT$XCU:00002C58
.CRT$XCU:00002C5C ; ===========================================================================
.CRT$XCU:00002C5C
.CRT$XCU:00002C5C ; Segment type: Pure data
.CRT$XCU:00002C5C ; Segment permissions: Read
.CRT$XCU:00002C5C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C5C                 assume cs:_CRT$XCU
.CRT$XCU:00002C5C                 ;org 2C5Ch
.CRT$XCU:00002C5C ; COMDAT (pick associative to section at 28D4)
.CRT$XCU:00002C5C ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00002C5C ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00002C5C _CRT$XCU        ends
.CRT$XCU:00002C5C
.CRT$XCU:00002C60 ; ===========================================================================
.CRT$XCU:00002C60
.CRT$XCU:00002C60 ; Segment type: Pure data
.CRT$XCU:00002C60 ; Segment permissions: Read
.CRT$XCU:00002C60 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002C60                 assume cs:_CRT$XCU
.CRT$XCU:00002C60                 ;org 2C60h
.CRT$XCU:00002C60 ; COMDAT (pick associative to section at 28D8)
.CRT$XCU:00002C60 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00002C60 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00002C60 _CRT$XCU        ends
.CRT$XCU:00002C60
UNDEF:00002C70 ; ===========================================================================
UNDEF:00002C70
UNDEF:00002C70 ; Segment type: Externs
UNDEF:00002C70 ; UNDEF
UNDEF:00002C70                 extrn __purecall:near   ; DATA XREF: .rdata:000026C0o
UNDEF:00002C70                                         ; .rdata:00002724o ...
UNDEF:00002C74 ; void *__cdecl operator new(unsigned int)
UNDEF:00002C74                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00002C74                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00002C78 ; void __cdecl operator delete(void *)
UNDEF:00002C78                 extrn ??3@YAXPAX@Z:near ; CODE XREF: SizeableDlg::`scalar deleting destructor'(uint)+1Bp
UNDEF:00002C78                                         ; StaticDialog::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:00002C7C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00002C7C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00002C7C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002C80 ; void __cdecl _wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
UNDEF:00002C80                 extrn __wassert:near    ; CODE XREF: CWinMgr::CalcLayout(HWND__ *)+28p
UNDEF:00002C80                                         ; CWinMgr::CalcLayout(tagRECT,HWND__ *)+1Fp
UNDEF:00002C84 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00002C84                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002C88 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002C88                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002C8C ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002C8C                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00002C90 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002C90                 extrn __imp__SendMessageW@16:near
UNDEF:00002C90                                         ; CODE XREF: StaticDialog::destroy(void)+1Cp
UNDEF:00002C90                                         ; DATA XREF: StaticDialog::destroy(void)+1Cr
UNDEF:00002C94 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:00002C94                 extrn __imp__DestroyWindow@4:near
UNDEF:00002C94                                         ; CODE XREF: StaticDialog::destroy(void)+29p
UNDEF:00002C94                                         ; DATA XREF: StaticDialog::destroy(void)+29r
UNDEF:00002C98 ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:00002C98                 extrn __imp__ShowWindow@8:near
UNDEF:00002C98                                         ; CODE XREF: Window::display(bool)+2Cp
UNDEF:00002C98                                         ; DATA XREF: Window::display(bool)+2Cr
UNDEF:00002C9C ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:00002C9C                 extrn __imp__MoveWindow@24:near
UNDEF:00002C9C                                         ; CODE XREF: Window::reSizeTo(tagRECT &)+2Bp
UNDEF:00002C9C                                         ; Window::reSizeToWH(tagRECT &)+36p
UNDEF:00002C9C                                         ; DATA XREF: ...
UNDEF:00002CA0 ; BOOL __stdcall IsWindowVisible(HWND hWnd)
UNDEF:00002CA0                 extrn __imp__IsWindowVisible@4:near
UNDEF:00002CA0                                         ; CODE XREF: Window::getHeight(void)+2Bp
UNDEF:00002CA0                                         ; Window::isVisible(void)+10p
UNDEF:00002CA0                                         ; DATA XREF: ...
UNDEF:00002CA4 ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:00002CA4                 extrn __imp__UpdateWindow@4:near
UNDEF:00002CA4                                         ; CODE XREF: Window::redraw(bool)+27p
UNDEF:00002CA4                                         ; DATA XREF: Window::redraw(bool)+27r
UNDEF:00002CA8 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:00002CA8                 extrn __imp__InvalidateRect@12:near
UNDEF:00002CA8                                         ; CODE XREF: Window::redraw(bool)+12p
UNDEF:00002CA8                                         ; DATA XREF: Window::redraw(bool)+12r
UNDEF:00002CAC ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:00002CAC                 extrn __imp__GetClientRect@8:near
UNDEF:00002CAC                                         ; CODE XREF: CWinMgr::CalcLayout(HWND__ *)+38p
UNDEF:00002CAC                                         ; Window::getClientRect(tagRECT &)+12p ...
UNDEF:00002CB0 ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:00002CB0                 extrn __imp__GetWindowRect@8:near
UNDEF:00002CB0                                         ; CODE XREF: Window::getWindowRect(tagRECT &)+12p
UNDEF:00002CB0                                         ; DATA XREF: Window::getWindowRect(tagRECT &)+12r
UNDEF:00002CB4 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00002CB4                 extrn __imp__SetWindowLongW@12:near
UNDEF:00002CB4                                         ; CODE XREF: StaticDialog::~StaticDialog(void)+50p
UNDEF:00002CB4                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+50r
UNDEF:00002CB8 ; _DWORD __thiscall CWinMgr::CWinMgr(CWinMgr *__hidden this, struct WINRECT *)
UNDEF:00002CB8                 extrn ??0CWinMgr@@QAE@PAVWINRECT@@@Z:near
UNDEF:00002CB8                                         ; CODE XREF: SizeableDlg::SizeableDlg(WINRECT *)+48p
UNDEF:00002CBC ; _DWORD __thiscall CWinMgr::~CWinMgr(CWinMgr *__hidden this)
UNDEF:00002CBC                 extrn ??1CWinMgr@@UAE@XZ:near
UNDEF:00002CBC                                         ; CODE XREF: __unwindfunclet$??0SizeableDlg@@QAE@PAVWINRECT@@@Z$1+6j
UNDEF:00002CBC                                         ; SizeableDlg::~SizeableDlg(void)+37p ...
UNDEF:00002CC0 ; void __thiscall CWinMgr::GetMinMaxInfo(CWinMgr *__hidden this, HWND, struct tagMINMAXINFO *)
UNDEF:00002CC0                 extrn ?GetMinMaxInfo@CWinMgr@@QAEXPAUHWND__@@PAUtagMINMAXINFO@@@Z:near
UNDEF:00002CC0                                         ; CODE XREF: SizeableDlg::onGetMinMaxInfo(tagMINMAXINFO *)+18p
UNDEF:00002CC4 ; void __thiscall CWinMgr::InitToFitSizeFromCurrent(CWinMgr *__hidden this, HWND)
UNDEF:00002CC4                 extrn ?InitToFitSizeFromCurrent@CWinMgr@@QAEXPAUHWND__@@@Z:near
UNDEF:00002CC4                                         ; CODE XREF: SizeableDlg::onInitDialog(void)+14p
UNDEF:00002CC8 ; public: virtual void * __thiscall Window::`vector deleting destructor'(unsigned int)
UNDEF:00002CC8                 extrn ??_EWindow@@UAEPAXI@Z:near ; weak
UNDEF:00002CC8                                         ; DATA XREF: .rdata:const Window::`vftable'o
UNDEF:00002CCC ; public: virtual void __thiscall StaticDialog::create(int, bool, bool)
UNDEF:00002CCC                 extrn ?create@StaticDialog@@UAEXH_N0@Z:near
UNDEF:00002CCC                                         ; DATA XREF: .rdata:0000271Co
UNDEF:00002CCC                                         ; .rdata:0000275Co
UNDEF:00002CD0 ; public: virtual void __thiscall StaticDialog::display(bool)const
UNDEF:00002CD0                 extrn ?display@StaticDialog@@UBEX_N@Z:near
UNDEF:00002CD0                                         ; DATA XREF: .rdata:000026F8o
UNDEF:00002CD0                                         ; .rdata:00002738o
UNDEF:00002CD4 ; public: virtual void * __thiscall StaticDialog::`vector deleting destructor'(unsigned int)
UNDEF:00002CD4                 extrn ??_EStaticDialog@@UAEPAXI@Z:near ; weak
UNDEF:00002CD4                                         ; DATA XREF: .rdata:const StaticDialog::`vftable'o
UNDEF:00002CD8 ; public: virtual void * __thiscall SizeableDlg::`vector deleting destructor'(unsigned int)
UNDEF:00002CD8                 extrn ??_ESizeableDlg@@UAEPAXI@Z:near ; weak
UNDEF:00002CD8                                         ; DATA XREF: .rdata:const SizeableDlg::`vftable'o
UNDEF:00002CDC ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00002CDC                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00002CDC                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002CE0 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002CE0                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002CE0                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002CE0                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00002CE4                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00002CE8 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00002CE8                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00002CE8                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00002CEC ; void __cdecl std::_Xbad_alloc()
UNDEF:00002CEC                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00002CEC                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_24Ep
UNDEF:00002CEC                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_290p
UNDEF:00002CF0 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00002CF0                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00002CF0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00002CF4 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00002CF4                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00002CF4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00002CF8 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002CF8                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002CF8                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00002CFC ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00002CFC                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00002CFC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00002CFC                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00002D00 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00002D00                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00002D00                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00002D04 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002D04                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002D04                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00002D08 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002D08                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002D08                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00002D0C ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002D0C                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002D0C                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00002D10 ; __fastcall __security_check_cookie(x)
UNDEF:00002D10                 extrn @__security_check_cookie@4:near
UNDEF:00002D10                                         ; CODE XREF: __ehhandler$??0SizeableDlg@@QAE@PAVWINRECT@@@Z+Cp
UNDEF:00002D10                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp ...
UNDEF:00002D14 ; __stdcall _CxxThrowException(x, x)
UNDEF:00002D14                 extrn __CxxThrowException@8:near
UNDEF:00002D14                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00002D18                 extrn ___CxxFrameHandler3:near
UNDEF:00002D18                                         ; CODE XREF: __ehhandler$??0SizeableDlg@@QAE@PAVWINRECT@@@Z+16j
UNDEF:00002D18                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j ...
UNDEF:00002D1C ; unsigned int const WM_WINMGR
UNDEF:00002D1C                 extrn ?WM_WINMGR@@3IB:near
UNDEF:00002D1C                                         ; DATA XREF: SizeableDlg::run_dlgProc(uint,uint,long)+7Fr
UNDEF:00002D20 ; const type_info::`vftable'
UNDEF:00002D20                 extrn ??_7type_info@@6B@:near
UNDEF:00002D20                                         ; DATA XREF: .data$r:Window `RTTI Type Descriptor'o
UNDEF:00002D20                                         ; .data$r:StaticDialog `RTTI Type Descriptor'o ...
UNDEF:00002D24                 extrn ___security_cookie:near
UNDEF:00002D24                                         ; DATA XREF: SizeableDlg::SizeableDlg(WINRECT *)+12r
UNDEF:00002D24                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r ...
UNDEF:00002D28                 extrn __fltused:near
UNDEF:00002D28
UNDEF:00002D28
UNDEF:00002D28                 end