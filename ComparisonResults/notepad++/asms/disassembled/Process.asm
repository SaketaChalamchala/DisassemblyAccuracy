.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 7CC3507A50B8AE79207434AFE0D0CF54
.rdata:00000000 ; Input CRC32 : 796C683E
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\Process.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG123059:                              ; DATA XREF: Process::run(void)+9o
.rdata:00000000                 unicode 0, <open>,0
.rdata:0000000A                 align 4
.rdata:0000000A _rdata          ends
.rdata:0000000A
.text$mn:0000000C ; ===========================================================================
.text$mn:0000000C
.text$mn:0000000C ; Segment type: Pure code
.text$mn:0000000C ; Segment permissions: Read/Execute
.text$mn:0000000C _text$mn        segment para public 'CODE' use32
.text$mn:0000000C                 assume cs:_text$mn
.text$mn:0000000C                 ;org 0Ch
.text$mn:0000000C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000000C
.text$mn:0000000C ; =============== S U B R O U T I N E =======================================
.text$mn:0000000C
.text$mn:0000000C ; Attributes: bp-based frame
.text$mn:0000000C
.text$mn:0000000C ; void __thiscall Process::run(Process *__hidden this)
.text$mn:0000000C                 public ?run@Process@@QAEXXZ
.text$mn:0000000C ?run@Process@@QAEXXZ proc near
.text$mn:0000000C
.text$mn:0000000C lpOperation     = dword ptr -8
.text$mn:0000000C var_4           = dword ptr -4
.text$mn:0000000C
.text$mn:0000000C                 push    ebp
.text$mn:0000000D                 mov     ebp, esp
.text$mn:0000000F                 sub     esp, 8
.text$mn:00000012                 mov     [ebp+var_4], ecx
.text$mn:00000015                 mov     [ebp+lpOperation], offset $SG123059 ; "open"
.text$mn:0000001C                 push    1               ; nShowCmd
.text$mn:0000001E                 mov     ecx, [ebp+var_4]
.text$mn:00000021                 add     ecx, 38h ; '8'
.text$mn:00000024                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000029                 push    eax             ; lpDirectory
.text$mn:0000002A                 mov     ecx, [ebp+var_4]
.text$mn:0000002D                 add     ecx, 1Ch
.text$mn:00000030                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000035                 push    eax             ; lpParameters
.text$mn:00000036                 mov     ecx, [ebp+var_4]
.text$mn:00000039                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000003E                 push    eax             ; lpFile
.text$mn:0000003F                 mov     eax, [ebp+lpOperation]
.text$mn:00000042                 push    eax             ; lpOperation
.text$mn:00000043                 push    0               ; hwnd
.text$mn:00000045                 call    dword ptr ds:__imp__ShellExecuteW@24 ; ShellExecuteW(x,x,x,x,x,x)
.text$mn:0000004B                 mov     esp, ebp
.text$mn:0000004D                 pop     ebp
.text$mn:0000004E                 retn
.text$mn:0000004E ?run@Process@@QAEXXZ endp
.text$mn:0000004E
.text$mn:0000004E ; ---------------------------------------------------------------------------
.text$mn:0000004F                 align 10h
.text$mn:0000004F _text$mn        ends
.text$mn:0000004F
.text$mn:00000050 ; ===========================================================================
.text$mn:00000050
.text$mn:00000050 ; Segment type: Pure code
.text$mn:00000050 ; Segment permissions: Read/Execute
.text$mn:00000050 _text$mn        segment para public 'CODE' use32
.text$mn:00000050                 assume cs:_text$mn
.text$mn:00000050                 ;org 50h
.text$mn:00000050 ; COMDAT (pick any)
.text$mn:00000050                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000050
.text$mn:00000050 ; =============== S U B R O U T I N E =======================================
.text$mn:00000050
.text$mn:00000050 ; Attributes: bp-based frame
.text$mn:00000050
.text$mn:00000050 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000050                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000050 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000050                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000050
.text$mn:00000050 var_4           = dword ptr -4
.text$mn:00000050 arg_0           = dword ptr  8
.text$mn:00000050
.text$mn:00000050                 push    ebp
.text$mn:00000051                 mov     ebp, esp
.text$mn:00000053                 push    ecx
.text$mn:00000054                 mov     [ebp+var_4], 0
.text$mn:0000005B                 cmp     [ebp+arg_0], 0
.text$mn:0000005F                 jnz     short loc_63
.text$mn:00000061                 jmp     short loc_83
.text$mn:00000063 ; ---------------------------------------------------------------------------
.text$mn:00000063
.text$mn:00000063 loc_63:                                 ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000063                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00000067                 ja      short loc_7E
.text$mn:00000069                 mov     eax, [ebp+arg_0]
.text$mn:0000006C                 push    eax             ; unsigned int
.text$mn:0000006D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000072                 add     esp, 4
.text$mn:00000075                 mov     [ebp+var_4], eax
.text$mn:00000078                 cmp     [ebp+var_4], 0
.text$mn:0000007C                 jnz     short loc_83
.text$mn:0000007E
.text$mn:0000007E loc_7E:                                 ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000007E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000083
.text$mn:00000083 loc_83:                                 ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000083                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000083                 mov     eax, [ebp+var_4]
.text$mn:00000086                 mov     esp, ebp
.text$mn:00000088                 pop     ebp
.text$mn:00000089                 retn
.text$mn:00000089 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00000089
.text$mn:00000089 ; ---------------------------------------------------------------------------
.text$mn:0000008A                 align 4
.text$mn:0000008A _text$mn        ends
.text$mn:0000008A
.text$mn:0000008C ; ===========================================================================
.text$mn:0000008C
.text$mn:0000008C ; Segment type: Pure code
.text$mn:0000008C ; Segment permissions: Read/Execute
.text$mn:0000008C _text$mn        segment para public 'CODE' use32
.text$mn:0000008C                 assume cs:_text$mn
.text$mn:0000008C                 ;org 8Ch
.text$mn:0000008C ; COMDAT (pick any)
.text$mn:0000008C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000008C
.text$mn:0000008C ; =============== S U B R O U T I N E =======================================
.text$mn:0000008C
.text$mn:0000008C ; Attributes: bp-based frame
.text$mn:0000008C
.text$mn:0000008C ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:0000008C                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:0000008C ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:0000008C                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:0000008C
.text$mn:0000008C var_4           = dword ptr -4
.text$mn:0000008C arg_0           = dword ptr  8
.text$mn:0000008C
.text$mn:0000008C                 push    ebp
.text$mn:0000008D                 mov     ebp, esp
.text$mn:0000008F                 push    ecx
.text$mn:00000090                 mov     [ebp+var_4], 0
.text$mn:00000097                 cmp     [ebp+arg_0], 0
.text$mn:0000009B                 jnz     short loc_9F
.text$mn:0000009D                 jmp     short loc_C5
.text$mn:0000009F ; ---------------------------------------------------------------------------
.text$mn:0000009F
.text$mn:0000009F loc_9F:                                 ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:0000009F                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000000A6                 ja      short loc_C0
.text$mn:000000A8                 mov     eax, [ebp+arg_0]
.text$mn:000000AB                 shl     eax, 3
.text$mn:000000AE                 push    eax             ; unsigned int
.text$mn:000000AF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000000B4                 add     esp, 4
.text$mn:000000B7                 mov     [ebp+var_4], eax
.text$mn:000000BA                 cmp     [ebp+var_4], 0
.text$mn:000000BE                 jnz     short loc_C5
.text$mn:000000C0
.text$mn:000000C0 loc_C0:                                 ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000000C0                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000000C5
.text$mn:000000C5 loc_C5:                                 ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000000C5                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000000C5                 mov     eax, [ebp+var_4]
.text$mn:000000C8                 mov     esp, ebp
.text$mn:000000CA                 pop     ebp
.text$mn:000000CB                 retn
.text$mn:000000CB ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000000CB
.text$mn:000000CB _text$mn        ends
.text$mn:000000CB
.text$mn:000000CC ; ===========================================================================
.text$mn:000000CC
.text$mn:000000CC ; Segment type: Pure code
.text$mn:000000CC ; Segment permissions: Read/Execute
.text$mn:000000CC _text$mn        segment para public 'CODE' use32
.text$mn:000000CC                 assume cs:_text$mn
.text$mn:000000CC                 ;org 0CCh
.text$mn:000000CC ; COMDAT (pick any)
.text$mn:000000CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000000CC
.text$mn:000000CC ; =============== S U B R O U T I N E =======================================
.text$mn:000000CC
.text$mn:000000CC ; Attributes: bp-based frame
.text$mn:000000CC
.text$mn:000000CC ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000000CC                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000000CC ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000000CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000000CC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000000CC
.text$mn:000000CC arg_0           = dword ptr  8
.text$mn:000000CC arg_4           = dword ptr  0Ch
.text$mn:000000CC arg_8           = dword ptr  10h
.text$mn:000000CC
.text$mn:000000CC                 push    ebp
.text$mn:000000CD                 mov     ebp, esp
.text$mn:000000CF                 cmp     [ebp+arg_0], 0
.text$mn:000000D3                 jnz     short loc_EA
.text$mn:000000D5                 mov     eax, [ebp+arg_8]
.text$mn:000000D8                 push    eax             ; unsigned int
.text$mn:000000D9                 mov     ecx, [ebp+arg_4]
.text$mn:000000DC                 push    ecx             ; wchar_t *
.text$mn:000000DD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000000E2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000000E7                 add     esp, 0Ch
.text$mn:000000EA
.text$mn:000000EA loc_EA:                                 ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000000EA                 pop     ebp
.text$mn:000000EB                 retn
.text$mn:000000EB ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000000EB
.text$mn:000000EB _text$mn        ends
.text$mn:000000EB
.text$mn:000000EC ; ===========================================================================
.text$mn:000000EC
.text$mn:000000EC ; Segment type: Pure code
.text$mn:000000EC ; Segment permissions: Read/Execute
.text$mn:000000EC _text$mn        segment para public 'CODE' use32
.text$mn:000000EC                 assume cs:_text$mn
.text$mn:000000EC                 ;org 0ECh
.text$mn:000000EC ; COMDAT (pick any)
.text$mn:000000EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000000EC
.text$mn:000000EC ; =============== S U B R O U T I N E =======================================
.text$mn:000000EC
.text$mn:000000EC ; Attributes: bp-based frame
.text$mn:000000EC
.text$mn:000000EC ; char * __cdecl std::addressof<char>(char &)
.text$mn:000000EC                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000000EC ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000000EC                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000000EC                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000000EC
.text$mn:000000EC arg_0           = dword ptr  8
.text$mn:000000EC
.text$mn:000000EC                 push    ebp
.text$mn:000000ED                 mov     ebp, esp
.text$mn:000000EF                 mov     eax, [ebp+arg_0]
.text$mn:000000F2                 pop     ebp
.text$mn:000000F3                 retn
.text$mn:000000F3 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000000F3
.text$mn:000000F3 _text$mn        ends
.text$mn:000000F3
.text$mn:000000F4 ; ===========================================================================
.text$mn:000000F4
.text$mn:000000F4 ; Segment type: Pure code
.text$mn:000000F4 ; Segment permissions: Read/Execute
.text$mn:000000F4 _text$mn        segment para public 'CODE' use32
.text$mn:000000F4                 assume cs:_text$mn
.text$mn:000000F4                 ;org 0F4h
.text$mn:000000F4 ; COMDAT (pick any)
.text$mn:000000F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000000F4
.text$mn:000000F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000000F4
.text$mn:000000F4 ; Attributes: bp-based frame
.text$mn:000000F4
.text$mn:000000F4 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:000000F4                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:000000F4 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:000000F4                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:000000F4
.text$mn:000000F4 arg_0           = dword ptr  8
.text$mn:000000F4
.text$mn:000000F4                 push    ebp
.text$mn:000000F5                 mov     ebp, esp
.text$mn:000000F7                 mov     eax, [ebp+arg_0]
.text$mn:000000FA                 pop     ebp
.text$mn:000000FB                 retn
.text$mn:000000FB ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:000000FB
.text$mn:000000FB _text$mn        ends
.text$mn:000000FB
.text$mn:000000FC ; ===========================================================================
.text$mn:000000FC
.text$mn:000000FC ; Segment type: Pure code
.text$mn:000000FC ; Segment permissions: Read/Execute
.text$mn:000000FC _text$mn        segment para public 'CODE' use32
.text$mn:000000FC                 assume cs:_text$mn
.text$mn:000000FC                 ;org 0FCh
.text$mn:000000FC ; COMDAT (pick any)
.text$mn:000000FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000000FC
.text$mn:000000FC ; =============== S U B R O U T I N E =======================================
.text$mn:000000FC
.text$mn:000000FC ; Attributes: bp-based frame
.text$mn:000000FC
.text$mn:000000FC ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000000FC                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000000FC ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000000FC                                         ; CODE XREF: $LN19+4Bp
.text$mn:000000FC
.text$mn:000000FC var_4           = dword ptr -4
.text$mn:000000FC arg_0           = dword ptr  8
.text$mn:000000FC arg_4           = dword ptr  0Ch
.text$mn:000000FC
.text$mn:000000FC                 push    ebp
.text$mn:000000FD                 mov     ebp, esp
.text$mn:000000FF                 push    ecx
.text$mn:00000100                 mov     [ebp+var_4], ecx
.text$mn:00000103                 mov     eax, [ebp+arg_4]
.text$mn:00000106                 push    eax
.text$mn:00000107                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000010C                 add     esp, 4
.text$mn:0000010F                 push    eax             ; int
.text$mn:00000110                 mov     ecx, [ebp+arg_0]
.text$mn:00000113                 push    ecx             ; void *
.text$mn:00000114                 mov     edx, [ebp+var_4]
.text$mn:00000117                 push    edx             ; int
.text$mn:00000118                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:0000011D                 add     esp, 0Ch
.text$mn:00000120                 mov     esp, ebp
.text$mn:00000122                 pop     ebp
.text$mn:00000123                 retn    8
.text$mn:00000123 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000123
.text$mn:00000123 ; ---------------------------------------------------------------------------
.text$mn:00000126                 align 4
.text$mn:00000126 _text$mn        ends
.text$mn:00000126
.text$mn:00000128 ; ===========================================================================
.text$mn:00000128
.text$mn:00000128 ; Segment type: Pure code
.text$mn:00000128 ; Segment permissions: Read/Execute
.text$mn:00000128 _text$mn        segment para public 'CODE' use32
.text$mn:00000128                 assume cs:_text$mn
.text$mn:00000128                 ;org 128h
.text$mn:00000128 ; COMDAT (pick any)
.text$mn:00000128                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000128
.text$mn:00000128 ; =============== S U B R O U T I N E =======================================
.text$mn:00000128
.text$mn:00000128 ; Attributes: bp-based frame
.text$mn:00000128
.text$mn:00000128 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00000128                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000128 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000128                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00000128
.text$mn:00000128 var_1C          = dword ptr -1Ch
.text$mn:00000128 var_18          = dword ptr -18h
.text$mn:00000128 var_14          = dword ptr -14h
.text$mn:00000128 var_10          = dword ptr -10h
.text$mn:00000128 var_C           = dword ptr -0Ch
.text$mn:00000128 var_4           = dword ptr -4
.text$mn:00000128 arg_0           = dword ptr  8
.text$mn:00000128 arg_4           = dword ptr  0Ch
.text$mn:00000128
.text$mn:00000128                 push    ebp
.text$mn:00000129                 mov     ebp, esp
.text$mn:0000012B                 push    0FFFFFFFFh
.text$mn:0000012D                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000132                 mov     eax, large fs:0
.text$mn:00000138                 push    eax
.text$mn:00000139                 sub     esp, 10h
.text$mn:0000013C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000141                 xor     eax, ebp
.text$mn:00000143                 push    eax
.text$mn:00000144                 lea     eax, [ebp+var_C]
.text$mn:00000147                 mov     large fs:0, eax
.text$mn:0000014D                 mov     [ebp+var_18], ecx
.text$mn:00000150                 mov     eax, [ebp+arg_0]
.text$mn:00000153                 push    eax             ; void *
.text$mn:00000154                 push    4               ; unsigned int
.text$mn:00000156                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000015B                 add     esp, 8
.text$mn:0000015E                 mov     [ebp+var_10], eax
.text$mn:00000161                 mov     [ebp+var_4], 0
.text$mn:00000168                 cmp     [ebp+var_10], 0
.text$mn:0000016C                 jz      short loc_189
.text$mn:0000016E                 mov     ecx, [ebp+arg_4]
.text$mn:00000171                 push    ecx
.text$mn:00000172                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000177                 add     esp, 4
.text$mn:0000017A                 mov     edx, [ebp+var_10]
.text$mn:0000017D                 mov     eax, [eax]
.text$mn:0000017F                 mov     [edx], eax
.text$mn:00000181                 mov     ecx, [ebp+var_10]
.text$mn:00000184                 mov     [ebp+var_14], ecx
.text$mn:00000187                 jmp     short loc_190
.text$mn:00000189 ; ---------------------------------------------------------------------------
.text$mn:00000189
.text$mn:00000189 loc_189:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000189                 mov     [ebp+var_14], 0
.text$mn:00000190
.text$mn:00000190 loc_190:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000190                 mov     edx, [ebp+var_14]
.text$mn:00000193                 mov     [ebp+var_1C], edx
.text$mn:00000196                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000019D                 mov     ecx, [ebp+var_C]
.text$mn:000001A0                 mov     large fs:0, ecx
.text$mn:000001A7                 pop     ecx
.text$mn:000001A8                 mov     esp, ebp
.text$mn:000001AA                 pop     ebp
.text$mn:000001AB                 retn    8
.text$mn:000001AB ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000001AB
.text$mn:000001AB ; ---------------------------------------------------------------------------
.text$mn:000001AE                 align 10h
.text$mn:000001AE _text$mn        ends
.text$mn:000001AE
.text$x:000001B0 ; ===========================================================================
.text$x:000001B0
.text$x:000001B0 ; Segment type: Pure code
.text$x:000001B0 ; Segment permissions: Read/Execute
.text$x:000001B0 _text$x         segment para public 'CODE' use32
.text$x:000001B0                 assume cs:_text$x
.text$x:000001B0                 ;org 1B0h
.text$x:000001B0 ; COMDAT (pick associative to section at 128)
.text$x:000001B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000001B0
.text$x:000001B0 ; =============== S U B R O U T I N E =======================================
.text$x:000001B0
.text$x:000001B0
.text$x:000001B0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000001B0                                         ; DATA XREF: .xdata$x:00001D34o
.text$x:000001B0                 mov     eax, [ebp+8]
.text$x:000001B3                 push    eax
.text$x:000001B4                 mov     eax, [ebp-10h]
.text$x:000001B7                 push    eax             ; void *
.text$x:000001B8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000001BD                 add     esp, 8
.text$x:000001C0                 retn
.text$x:000001C0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000001C0
.text$x:000001C1
.text$x:000001C1 ; =============== S U B R O U T I N E =======================================
.text$x:000001C1
.text$x:000001C1
.text$x:000001C1 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000001C1                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000001C1
.text$x:000001C1 arg_4           = dword ptr  8
.text$x:000001C1
.text$x:000001C1                 mov     edx, [esp+arg_4]
.text$x:000001C5                 lea     eax, [edx+0Ch]
.text$x:000001C8                 mov     ecx, [edx-14h]
.text$x:000001CB                 xor     ecx, eax
.text$x:000001CD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000001D2                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000001D7                 jmp     ___CxxFrameHandler3
.text$x:000001D7 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000001D7
.text$x:000001D7 _text$x         ends
.text$x:000001D7
.text$mn:000001DC ; ===========================================================================
.text$mn:000001DC
.text$mn:000001DC ; Segment type: Pure code
.text$mn:000001DC ; Segment permissions: Read/Execute
.text$mn:000001DC _text$mn        segment para public 'CODE' use32
.text$mn:000001DC                 assume cs:_text$mn
.text$mn:000001DC                 ;org 1DCh
.text$mn:000001DC ; COMDAT (pick any)
.text$mn:000001DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000001DC
.text$mn:000001DC ; =============== S U B R O U T I N E =======================================
.text$mn:000001DC
.text$mn:000001DC ; Attributes: bp-based frame
.text$mn:000001DC
.text$mn:000001DC ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000001DC                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000001DC ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000001DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000001DC
.text$mn:000001DC arg_0           = dword ptr  8
.text$mn:000001DC arg_4           = dword ptr  0Ch
.text$mn:000001DC arg_8           = dword ptr  10h
.text$mn:000001DC
.text$mn:000001DC                 push    ebp
.text$mn:000001DD                 mov     ebp, esp
.text$mn:000001DF                 mov     eax, [ebp+arg_8]
.text$mn:000001E2                 push    eax
.text$mn:000001E3                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000001E8                 add     esp, 4
.text$mn:000001EB                 push    eax             ; int
.text$mn:000001EC                 mov     ecx, [ebp+arg_4]
.text$mn:000001EF                 push    ecx             ; void *
.text$mn:000001F0                 mov     ecx, [ebp+arg_0]
.text$mn:000001F3                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000001F8                 pop     ebp
.text$mn:000001F9                 retn
.text$mn:000001F9 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000001F9
.text$mn:000001F9 ; ---------------------------------------------------------------------------
.text$mn:000001FA                 align 4
.text$mn:000001FA _text$mn        ends
.text$mn:000001FA
.text$mn:000001FC ; ===========================================================================
.text$mn:000001FC
.text$mn:000001FC ; Segment type: Pure code
.text$mn:000001FC ; Segment permissions: Read/Execute
.text$mn:000001FC _text$mn        segment para public 'CODE' use32
.text$mn:000001FC                 assume cs:_text$mn
.text$mn:000001FC                 ;org 1FCh
.text$mn:000001FC ; COMDAT (pick any)
.text$mn:000001FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000001FC
.text$mn:000001FC ; =============== S U B R O U T I N E =======================================
.text$mn:000001FC
.text$mn:000001FC ; Attributes: bp-based frame
.text$mn:000001FC
.text$mn:000001FC ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000001FC                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000001FC ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000001FC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000001FC
.text$mn:000001FC var_1C          = dword ptr -1Ch
.text$mn:000001FC var_18          = dword ptr -18h
.text$mn:000001FC var_14          = dword ptr -14h
.text$mn:000001FC var_10          = dword ptr -10h
.text$mn:000001FC var_C           = dword ptr -0Ch
.text$mn:000001FC var_4           = dword ptr -4
.text$mn:000001FC arg_0           = dword ptr  8
.text$mn:000001FC arg_4           = dword ptr  0Ch
.text$mn:000001FC
.text$mn:000001FC                 push    ebp
.text$mn:000001FD                 mov     ebp, esp
.text$mn:000001FF                 push    0FFFFFFFFh
.text$mn:00000201                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000206                 mov     eax, large fs:0
.text$mn:0000020C                 push    eax
.text$mn:0000020D                 sub     esp, 10h
.text$mn:00000210                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000215                 xor     eax, ebp
.text$mn:00000217                 push    eax
.text$mn:00000218                 lea     eax, [ebp+var_C]
.text$mn:0000021B                 mov     large fs:0, eax
.text$mn:00000221                 mov     [ebp+var_18], ecx
.text$mn:00000224                 mov     eax, [ebp+arg_0]
.text$mn:00000227                 push    eax             ; void *
.text$mn:00000228                 push    8               ; unsigned int
.text$mn:0000022A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000022F                 add     esp, 8
.text$mn:00000232                 mov     [ebp+var_10], eax
.text$mn:00000235                 mov     [ebp+var_4], 0
.text$mn:0000023C                 cmp     [ebp+var_10], 0
.text$mn:00000240                 jz      short loc_263
.text$mn:00000242                 mov     ecx, [ebp+arg_4]
.text$mn:00000245                 push    ecx
.text$mn:00000246                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000024B                 add     esp, 4
.text$mn:0000024E                 mov     edx, [eax]
.text$mn:00000250                 mov     eax, [eax+4]
.text$mn:00000253                 mov     ecx, [ebp+var_10]
.text$mn:00000256                 mov     [ecx], edx
.text$mn:00000258                 mov     [ecx+4], eax
.text$mn:0000025B                 mov     edx, [ebp+var_10]
.text$mn:0000025E                 mov     [ebp+var_14], edx
.text$mn:00000261                 jmp     short loc_26A
.text$mn:00000263 ; ---------------------------------------------------------------------------
.text$mn:00000263
.text$mn:00000263 loc_263:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000263                 mov     [ebp+var_14], 0
.text$mn:0000026A
.text$mn:0000026A loc_26A:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000026A                 mov     eax, [ebp+var_14]
.text$mn:0000026D                 mov     [ebp+var_1C], eax
.text$mn:00000270                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000277                 mov     ecx, [ebp+var_C]
.text$mn:0000027A                 mov     large fs:0, ecx
.text$mn:00000281                 pop     ecx
.text$mn:00000282                 mov     esp, ebp
.text$mn:00000284                 pop     ebp
.text$mn:00000285                 retn    8
.text$mn:00000285 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00000285
.text$mn:00000285 _text$mn        ends
.text$mn:00000285
.text$x:00000288 ; ===========================================================================
.text$x:00000288
.text$x:00000288 ; Segment type: Pure code
.text$x:00000288 ; Segment permissions: Read/Execute
.text$x:00000288 _text$x         segment para public 'CODE' use32
.text$x:00000288                 assume cs:_text$x
.text$x:00000288                 ;org 288h
.text$x:00000288 ; COMDAT (pick associative to section at 1FC)
.text$x:00000288                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000288
.text$x:00000288 ; =============== S U B R O U T I N E =======================================
.text$x:00000288
.text$x:00000288
.text$x:00000288 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000288                                         ; DATA XREF: .xdata$x:00001D08o
.text$x:00000288                 mov     eax, [ebp+8]
.text$x:0000028B                 push    eax
.text$x:0000028C                 mov     eax, [ebp-10h]
.text$x:0000028F                 push    eax             ; void *
.text$x:00000290                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000295                 add     esp, 8
.text$x:00000298                 retn
.text$x:00000298 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000298
.text$x:00000299
.text$x:00000299 ; =============== S U B R O U T I N E =======================================
.text$x:00000299
.text$x:00000299
.text$x:00000299 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000299                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000299
.text$x:00000299 arg_4           = dword ptr  8
.text$x:00000299
.text$x:00000299                 mov     edx, [esp+arg_4]
.text$x:0000029D                 lea     eax, [edx+0Ch]
.text$x:000002A0                 mov     ecx, [edx-14h]
.text$x:000002A3                 xor     ecx, eax
.text$x:000002A5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000002AA                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000002AF                 jmp     ___CxxFrameHandler3
.text$x:000002AF __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000002AF
.text$x:000002AF _text$x         ends
.text$x:000002AF
.text$mn:000002B4 ; ===========================================================================
.text$mn:000002B4
.text$mn:000002B4 ; Segment type: Pure code
.text$mn:000002B4 ; Segment permissions: Read/Execute
.text$mn:000002B4 _text$mn        segment para public 'CODE' use32
.text$mn:000002B4                 assume cs:_text$mn
.text$mn:000002B4                 ;org 2B4h
.text$mn:000002B4 ; COMDAT (pick any)
.text$mn:000002B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000002B4
.text$mn:000002B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000002B4
.text$mn:000002B4 ; Attributes: bp-based frame
.text$mn:000002B4
.text$mn:000002B4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000002B4                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000002B4 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000002B4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000002B4
.text$mn:000002B4 var_4           = dword ptr -4
.text$mn:000002B4 arg_0           = dword ptr  8
.text$mn:000002B4
.text$mn:000002B4                 push    ebp
.text$mn:000002B5                 mov     ebp, esp
.text$mn:000002B7                 push    ecx
.text$mn:000002B8                 mov     [ebp+var_4], ecx
.text$mn:000002BB                 mov     eax, [ebp+arg_0]
.text$mn:000002BE                 push    eax
.text$mn:000002BF                 mov     ecx, [ebp+var_4]
.text$mn:000002C2                 push    ecx
.text$mn:000002C3                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000002C8                 add     esp, 8
.text$mn:000002CB                 mov     esp, ebp
.text$mn:000002CD                 pop     ebp
.text$mn:000002CE                 retn    4
.text$mn:000002CE ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000002CE
.text$mn:000002CE ; ---------------------------------------------------------------------------
.text$mn:000002D1                 align 4
.text$mn:000002D1 _text$mn        ends
.text$mn:000002D1
.text$mn:000002D4 ; ===========================================================================
.text$mn:000002D4
.text$mn:000002D4 ; Segment type: Pure code
.text$mn:000002D4 ; Segment permissions: Read/Execute
.text$mn:000002D4 _text$mn        segment para public 'CODE' use32
.text$mn:000002D4                 assume cs:_text$mn
.text$mn:000002D4                 ;org 2D4h
.text$mn:000002D4 ; COMDAT (pick any)
.text$mn:000002D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000002D4
.text$mn:000002D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000002D4
.text$mn:000002D4 ; Attributes: bp-based frame
.text$mn:000002D4
.text$mn:000002D4 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000002D4                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000002D4 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000002D4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000002D4
.text$mn:000002D4 var_4           = dword ptr -4
.text$mn:000002D4
.text$mn:000002D4                 push    ebp
.text$mn:000002D5                 mov     ebp, esp
.text$mn:000002D7                 push    ecx
.text$mn:000002D8                 mov     [ebp+var_4], ecx
.text$mn:000002DB                 mov     esp, ebp
.text$mn:000002DD                 pop     ebp
.text$mn:000002DE                 retn    4
.text$mn:000002DE ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000002DE
.text$mn:000002DE ; ---------------------------------------------------------------------------
.text$mn:000002E1                 align 4
.text$mn:000002E1 _text$mn        ends
.text$mn:000002E1
.text$mn:000002E4 ; ===========================================================================
.text$mn:000002E4
.text$mn:000002E4 ; Segment type: Pure code
.text$mn:000002E4 ; Segment permissions: Read/Execute
.text$mn:000002E4 _text$mn        segment para public 'CODE' use32
.text$mn:000002E4                 assume cs:_text$mn
.text$mn:000002E4                 ;org 2E4h
.text$mn:000002E4 ; COMDAT (pick any)
.text$mn:000002E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000002E4
.text$mn:000002E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000002E4
.text$mn:000002E4 ; Attributes: bp-based frame
.text$mn:000002E4
.text$mn:000002E4 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000002E4                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000002E4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000002E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000002E4
.text$mn:000002E4 arg_0           = dword ptr  8
.text$mn:000002E4 arg_4           = dword ptr  0Ch
.text$mn:000002E4
.text$mn:000002E4                 push    ebp
.text$mn:000002E5                 mov     ebp, esp
.text$mn:000002E7                 mov     eax, [ebp+arg_4]
.text$mn:000002EA                 push    eax
.text$mn:000002EB                 mov     ecx, [ebp+arg_0]
.text$mn:000002EE                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000002F3                 pop     ebp
.text$mn:000002F4                 retn
.text$mn:000002F4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000002F4
.text$mn:000002F4 ; ---------------------------------------------------------------------------
.text$mn:000002F5                 align 4
.text$mn:000002F5 _text$mn        ends
.text$mn:000002F5
.text$mn:000002F8 ; ===========================================================================
.text$mn:000002F8
.text$mn:000002F8 ; Segment type: Pure code
.text$mn:000002F8 ; Segment permissions: Read/Execute
.text$mn:000002F8 _text$mn        segment para public 'CODE' use32
.text$mn:000002F8                 assume cs:_text$mn
.text$mn:000002F8                 ;org 2F8h
.text$mn:000002F8 ; COMDAT (pick any)
.text$mn:000002F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000002F8
.text$mn:000002F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000002F8
.text$mn:000002F8 ; Attributes: bp-based frame
.text$mn:000002F8
.text$mn:000002F8 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000002F8                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000002F8 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000002F8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:000002F8
.text$mn:000002F8 var_4           = dword ptr -4
.text$mn:000002F8
.text$mn:000002F8                 push    ebp
.text$mn:000002F9                 mov     ebp, esp
.text$mn:000002FB                 push    ecx
.text$mn:000002FC                 mov     [ebp+var_4], ecx
.text$mn:000002FF                 mov     esp, ebp
.text$mn:00000301                 pop     ebp
.text$mn:00000302                 retn    4
.text$mn:00000302 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000302
.text$mn:00000302 ; ---------------------------------------------------------------------------
.text$mn:00000305                 align 4
.text$mn:00000305 _text$mn        ends
.text$mn:00000305
.text$mn:00000308 ; ===========================================================================
.text$mn:00000308
.text$mn:00000308 ; Segment type: Pure code
.text$mn:00000308 ; Segment permissions: Read/Execute
.text$mn:00000308 _text$mn        segment para public 'CODE' use32
.text$mn:00000308                 assume cs:_text$mn
.text$mn:00000308                 ;org 308h
.text$mn:00000308 ; COMDAT (pick any)
.text$mn:00000308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000308
.text$mn:00000308 ; =============== S U B R O U T I N E =======================================
.text$mn:00000308
.text$mn:00000308 ; Attributes: bp-based frame
.text$mn:00000308
.text$mn:00000308 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000308                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000308 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000308                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000308                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000308
.text$mn:00000308 arg_0           = dword ptr  8
.text$mn:00000308
.text$mn:00000308                 push    ebp
.text$mn:00000309                 mov     ebp, esp
.text$mn:0000030B                 mov     eax, [ebp+arg_0]
.text$mn:0000030E                 pop     ebp
.text$mn:0000030F                 retn
.text$mn:0000030F ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:0000030F
.text$mn:0000030F _text$mn        ends
.text$mn:0000030F
.text$mn:00000310 ; ===========================================================================
.text$mn:00000310
.text$mn:00000310 ; Segment type: Pure code
.text$mn:00000310 ; Segment permissions: Read/Execute
.text$mn:00000310 _text$mn        segment para public 'CODE' use32
.text$mn:00000310                 assume cs:_text$mn
.text$mn:00000310                 ;org 310h
.text$mn:00000310 ; COMDAT (pick any)
.text$mn:00000310                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000310
.text$mn:00000310 ; =============== S U B R O U T I N E =======================================
.text$mn:00000310
.text$mn:00000310 ; Attributes: bp-based frame
.text$mn:00000310
.text$mn:00000310 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000310                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000310 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000310                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000310
.text$mn:00000310 arg_0           = dword ptr  8
.text$mn:00000310
.text$mn:00000310                 push    ebp
.text$mn:00000311                 mov     ebp, esp
.text$mn:00000313                 mov     eax, [ebp+arg_0]
.text$mn:00000316                 pop     ebp
.text$mn:00000317                 retn
.text$mn:00000317 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00000317
.text$mn:00000317 _text$mn        ends
.text$mn:00000317
.text$mn:00000318 ; ===========================================================================
.text$mn:00000318
.text$mn:00000318 ; Segment type: Pure code
.text$mn:00000318 ; Segment permissions: Read/Execute
.text$mn:00000318 _text$mn        segment para public 'CODE' use32
.text$mn:00000318                 assume cs:_text$mn
.text$mn:00000318                 ;org 318h
.text$mn:00000318 ; COMDAT (pick any)
.text$mn:00000318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000318
.text$mn:00000318 ; =============== S U B R O U T I N E =======================================
.text$mn:00000318
.text$mn:00000318 ; Attributes: bp-based frame
.text$mn:00000318
.text$mn:00000318 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000318                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000318 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000318                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000318
.text$mn:00000318 var_10          = dword ptr -10h
.text$mn:00000318 var_C           = dword ptr -0Ch
.text$mn:00000318 var_4           = dword ptr -4
.text$mn:00000318
.text$mn:00000318                 push    ebp
.text$mn:00000319                 mov     ebp, esp
.text$mn:0000031B                 push    0FFFFFFFFh
.text$mn:0000031D                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000322                 mov     eax, large fs:0
.text$mn:00000328                 push    eax
.text$mn:00000329                 push    ecx
.text$mn:0000032A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000032F                 xor     eax, ebp
.text$mn:00000331                 push    eax
.text$mn:00000332                 lea     eax, [ebp+var_C]
.text$mn:00000335                 mov     large fs:0, eax
.text$mn:0000033B                 mov     [ebp+var_10], ecx
.text$mn:0000033E                 mov     ecx, [ebp+var_10]
.text$mn:00000341                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00000346                 mov     [ebp+var_4], 0
.text$mn:0000034D                 mov     ecx, [ebp+var_10]
.text$mn:00000350                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000355                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000035C                 mov     eax, [ebp+var_10]
.text$mn:0000035F                 mov     ecx, [ebp+var_C]
.text$mn:00000362                 mov     large fs:0, ecx
.text$mn:00000369                 pop     ecx
.text$mn:0000036A                 mov     esp, ebp
.text$mn:0000036C                 pop     ebp
.text$mn:0000036D                 retn    4
.text$mn:0000036D ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:0000036D
.text$mn:0000036D _text$mn        ends
.text$mn:0000036D
.text$x:00000370 ; ===========================================================================
.text$x:00000370
.text$x:00000370 ; Segment type: Pure code
.text$x:00000370 ; Segment permissions: Read/Execute
.text$x:00000370 _text$x         segment para public 'CODE' use32
.text$x:00000370                 assume cs:_text$x
.text$x:00000370                 ;org 370h
.text$x:00000370 ; COMDAT (pick associative to section at 318)
.text$x:00000370                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000370
.text$x:00000370 ; =============== S U B R O U T I N E =======================================
.text$x:00000370
.text$x:00000370
.text$x:00000370 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000370                                         ; DATA XREF: .xdata$x:00001A40o
.text$x:00000370                 mov     ecx, [ebp-10h]
.text$x:00000373                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000373 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000373
.text$x:00000378
.text$x:00000378 ; =============== S U B R O U T I N E =======================================
.text$x:00000378
.text$x:00000378
.text$x:00000378 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000378                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000378
.text$x:00000378 arg_4           = dword ptr  8
.text$x:00000378
.text$x:00000378                 mov     edx, [esp+arg_4]
.text$x:0000037C                 lea     eax, [edx+0Ch]
.text$x:0000037F                 mov     ecx, [edx-8]
.text$x:00000382                 xor     ecx, eax
.text$x:00000384                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000389                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000038E                 jmp     ___CxxFrameHandler3
.text$x:0000038E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000038E
.text$x:0000038E ; ---------------------------------------------------------------------------
.text$x:00000393                 align 4
.text$x:00000393 _text$x         ends
.text$x:00000393
.text$mn:00000394 ; ===========================================================================
.text$mn:00000394
.text$mn:00000394 ; Segment type: Pure code
.text$mn:00000394 ; Segment permissions: Read/Execute
.text$mn:00000394 _text$mn        segment para public 'CODE' use32
.text$mn:00000394                 assume cs:_text$mn
.text$mn:00000394                 ;org 394h
.text$mn:00000394 ; COMDAT (pick any)
.text$mn:00000394                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000394
.text$mn:00000394 ; =============== S U B R O U T I N E =======================================
.text$mn:00000394
.text$mn:00000394 ; Attributes: bp-based frame
.text$mn:00000394
.text$mn:00000394 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000394                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000394 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000394                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00000394
.text$mn:00000394 var_10          = dword ptr -10h
.text$mn:00000394 var_C           = dword ptr -0Ch
.text$mn:00000394 var_4           = dword ptr -4
.text$mn:00000394
.text$mn:00000394                 push    ebp
.text$mn:00000395                 mov     ebp, esp
.text$mn:00000397                 push    0FFFFFFFFh
.text$mn:00000399                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000039E                 mov     eax, large fs:0
.text$mn:000003A4                 push    eax
.text$mn:000003A5                 push    ecx
.text$mn:000003A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000003AB                 xor     eax, ebp
.text$mn:000003AD                 push    eax
.text$mn:000003AE                 lea     eax, [ebp+var_C]
.text$mn:000003B1                 mov     large fs:0, eax
.text$mn:000003B7                 mov     [ebp+var_10], ecx
.text$mn:000003BA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000003BD                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000003C2                 mov     [ebp+var_4], 0
.text$mn:000003C9                 mov     eax, [ebp+var_10]
.text$mn:000003CC                 mov     dword ptr [eax+14h], 0
.text$mn:000003D3                 mov     ecx, [ebp+var_10]
.text$mn:000003D6                 mov     dword ptr [ecx+18h], 0
.text$mn:000003DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000003E4                 mov     eax, [ebp+var_10]
.text$mn:000003E7                 mov     ecx, [ebp+var_C]
.text$mn:000003EA                 mov     large fs:0, ecx
.text$mn:000003F1                 pop     ecx
.text$mn:000003F2                 mov     esp, ebp
.text$mn:000003F4                 pop     ebp
.text$mn:000003F5                 retn
.text$mn:000003F5 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000003F5
.text$mn:000003F5 ; ---------------------------------------------------------------------------
.text$mn:000003F6                 align 4
.text$mn:000003F6 _text$mn        ends
.text$mn:000003F6
.text$x:000003F8 ; ===========================================================================
.text$x:000003F8
.text$x:000003F8 ; Segment type: Pure code
.text$x:000003F8 ; Segment permissions: Read/Execute
.text$x:000003F8 _text$x         segment para public 'CODE' use32
.text$x:000003F8                 assume cs:_text$x
.text$x:000003F8                 ;org 3F8h
.text$x:000003F8 ; COMDAT (pick associative to section at 394)
.text$x:000003F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000003F8
.text$x:000003F8 ; =============== S U B R O U T I N E =======================================
.text$x:000003F8
.text$x:000003F8
.text$x:000003F8 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000003F8                                         ; DATA XREF: .xdata$x:000019E8o
.text$x:000003F8                 mov     ecx, [ebp-10h]  ; this
.text$x:000003FB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000003FB __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000003FB
.text$x:00000400
.text$x:00000400 ; =============== S U B R O U T I N E =======================================
.text$x:00000400
.text$x:00000400
.text$x:00000400 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000400                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000400
.text$x:00000400 arg_4           = dword ptr  8
.text$x:00000400
.text$x:00000400                 mov     edx, [esp+arg_4]
.text$x:00000404                 lea     eax, [edx+0Ch]
.text$x:00000407                 mov     ecx, [edx-8]
.text$x:0000040A                 xor     ecx, eax
.text$x:0000040C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000411                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000416                 jmp     ___CxxFrameHandler3
.text$x:00000416 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000416
.text$x:00000416 ; ---------------------------------------------------------------------------
.text$x:0000041B                 align 4
.text$x:0000041B _text$x         ends
.text$x:0000041B
.text$mn:0000041C ; ===========================================================================
.text$mn:0000041C
.text$mn:0000041C ; Segment type: Pure code
.text$mn:0000041C ; Segment permissions: Read/Execute
.text$mn:0000041C _text$mn        segment para public 'CODE' use32
.text$mn:0000041C                 assume cs:_text$mn
.text$mn:0000041C                 ;org 41Ch
.text$mn:0000041C ; COMDAT (pick any)
.text$mn:0000041C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000041C
.text$mn:0000041C ; =============== S U B R O U T I N E =======================================
.text$mn:0000041C
.text$mn:0000041C ; Attributes: bp-based frame
.text$mn:0000041C
.text$mn:0000041C ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:0000041C                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:0000041C ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:0000041C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:0000041C
.text$mn:0000041C var_4           = dword ptr -4
.text$mn:0000041C
.text$mn:0000041C                 push    ebp
.text$mn:0000041D                 mov     ebp, esp
.text$mn:0000041F                 push    ecx
.text$mn:00000420                 mov     [ebp+var_4], ecx
.text$mn:00000423                 mov     ecx, [ebp+var_4]
.text$mn:00000426                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000042B                 mov     eax, [ebp+var_4]
.text$mn:0000042E                 mov     esp, ebp
.text$mn:00000430                 pop     ebp
.text$mn:00000431                 retn
.text$mn:00000431 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000431
.text$mn:00000431 ; ---------------------------------------------------------------------------
.text$mn:00000432                 align 4
.text$mn:00000432 _text$mn        ends
.text$mn:00000432
.text$mn:00000434 ; ===========================================================================
.text$mn:00000434
.text$mn:00000434 ; Segment type: Pure code
.text$mn:00000434 ; Segment permissions: Read/Execute
.text$mn:00000434 _text$mn        segment para public 'CODE' use32
.text$mn:00000434                 assume cs:_text$mn
.text$mn:00000434                 ;org 434h
.text$mn:00000434 ; COMDAT (pick any)
.text$mn:00000434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000434
.text$mn:00000434 ; =============== S U B R O U T I N E =======================================
.text$mn:00000434
.text$mn:00000434 ; Attributes: bp-based frame
.text$mn:00000434
.text$mn:00000434 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000434                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000434 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000434                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000434
.text$mn:00000434 var_4           = dword ptr -4
.text$mn:00000434
.text$mn:00000434                 push    ebp
.text$mn:00000435                 mov     ebp, esp
.text$mn:00000437                 push    ecx
.text$mn:00000438                 mov     [ebp+var_4], ecx
.text$mn:0000043B                 mov     eax, [ebp+var_4]
.text$mn:0000043E                 mov     esp, ebp
.text$mn:00000440                 pop     ebp
.text$mn:00000441                 retn
.text$mn:00000441 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000441
.text$mn:00000441 ; ---------------------------------------------------------------------------
.text$mn:00000442                 align 4
.text$mn:00000442 _text$mn        ends
.text$mn:00000442
.text$mn:00000444 ; ===========================================================================
.text$mn:00000444
.text$mn:00000444 ; Segment type: Pure code
.text$mn:00000444 ; Segment permissions: Read/Execute
.text$mn:00000444 _text$mn        segment para public 'CODE' use32
.text$mn:00000444                 assume cs:_text$mn
.text$mn:00000444                 ;org 444h
.text$mn:00000444 ; COMDAT (pick any)
.text$mn:00000444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000444
.text$mn:00000444 ; =============== S U B R O U T I N E =======================================
.text$mn:00000444
.text$mn:00000444 ; Attributes: bp-based frame
.text$mn:00000444
.text$mn:00000444 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000444                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000444 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000444                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000444                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00000444
.text$mn:00000444 var_4           = dword ptr -4
.text$mn:00000444
.text$mn:00000444                 push    ebp
.text$mn:00000445                 mov     ebp, esp
.text$mn:00000447                 push    ecx
.text$mn:00000448                 mov     [ebp+var_4], ecx
.text$mn:0000044B                 mov     eax, [ebp+var_4]
.text$mn:0000044E                 mov     esp, ebp
.text$mn:00000450                 pop     ebp
.text$mn:00000451                 retn
.text$mn:00000451 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000451
.text$mn:00000451 ; ---------------------------------------------------------------------------
.text$mn:00000452                 align 4
.text$mn:00000452 _text$mn        ends
.text$mn:00000452
.text$mn:00000454 ; ===========================================================================
.text$mn:00000454
.text$mn:00000454 ; Segment type: Pure code
.text$mn:00000454 ; Segment permissions: Read/Execute
.text$mn:00000454 _text$mn        segment para public 'CODE' use32
.text$mn:00000454                 assume cs:_text$mn
.text$mn:00000454                 ;org 454h
.text$mn:00000454 ; COMDAT (pick any)
.text$mn:00000454                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000454
.text$mn:00000454 ; =============== S U B R O U T I N E =======================================
.text$mn:00000454
.text$mn:00000454 ; Attributes: bp-based frame
.text$mn:00000454
.text$mn:00000454 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000454                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000454 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000454                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000454                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000454
.text$mn:00000454 var_14          = dword ptr -14h
.text$mn:00000454 var_D           = byte ptr -0Dh
.text$mn:00000454 var_C           = dword ptr -0Ch
.text$mn:00000454 var_4           = dword ptr -4
.text$mn:00000454 Str             = dword ptr  8
.text$mn:00000454
.text$mn:00000454                 push    ebp
.text$mn:00000455                 mov     ebp, esp
.text$mn:00000457                 push    0FFFFFFFFh
.text$mn:00000459                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000045E                 mov     eax, large fs:0
.text$mn:00000464                 push    eax
.text$mn:00000465                 sub     esp, 8
.text$mn:00000468                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000046D                 xor     eax, ebp
.text$mn:0000046F                 push    eax
.text$mn:00000470                 lea     eax, [ebp+var_C]
.text$mn:00000473                 mov     large fs:0, eax
.text$mn:00000479                 mov     [ebp+var_14], ecx
.text$mn:0000047C                 lea     ecx, [ebp+var_D]
.text$mn:0000047F                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000484                 push    eax
.text$mn:00000485                 mov     ecx, [ebp+var_14]
.text$mn:00000488                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:0000048D                 mov     [ebp+var_4], 0
.text$mn:00000494                 push    0               ; Size
.text$mn:00000496                 push    0               ; char
.text$mn:00000498                 mov     ecx, [ebp+var_14]
.text$mn:0000049B                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000004A0                 mov     eax, [ebp+Str]
.text$mn:000004A3                 push    eax             ; Str
.text$mn:000004A4                 mov     ecx, [ebp+var_14]
.text$mn:000004A7                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000004AC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000004B3                 mov     eax, [ebp+var_14]
.text$mn:000004B6                 mov     ecx, [ebp+var_C]
.text$mn:000004B9                 mov     large fs:0, ecx
.text$mn:000004C0                 pop     ecx
.text$mn:000004C1                 mov     esp, ebp
.text$mn:000004C3                 pop     ebp
.text$mn:000004C4                 retn    4
.text$mn:000004C4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000004C4
.text$mn:000004C4 ; ---------------------------------------------------------------------------
.text$mn:000004C7                 align 4
.text$mn:000004C7 _text$mn        ends
.text$mn:000004C7
.text$x:000004C8 ; ===========================================================================
.text$x:000004C8
.text$x:000004C8 ; Segment type: Pure code
.text$x:000004C8 ; Segment permissions: Read/Execute
.text$x:000004C8 _text$x         segment para public 'CODE' use32
.text$x:000004C8                 assume cs:_text$x
.text$x:000004C8                 ;org 4C8h
.text$x:000004C8 ; COMDAT (pick associative to section at 454)
.text$x:000004C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000004C8
.text$x:000004C8 ; =============== S U B R O U T I N E =======================================
.text$x:000004C8
.text$x:000004C8
.text$x:000004C8 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000004C8                                         ; DATA XREF: .xdata$x:00001A98o
.text$x:000004C8                 mov     ecx, [ebp-14h]
.text$x:000004CB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000004CB __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000004CB
.text$x:000004D0
.text$x:000004D0 ; =============== S U B R O U T I N E =======================================
.text$x:000004D0
.text$x:000004D0
.text$x:000004D0 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000004D0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000004D0
.text$x:000004D0 arg_4           = dword ptr  8
.text$x:000004D0
.text$x:000004D0                 mov     edx, [esp+arg_4]
.text$x:000004D4                 lea     eax, [edx+0Ch]
.text$x:000004D7                 mov     ecx, [edx-0Ch]
.text$x:000004DA                 xor     ecx, eax
.text$x:000004DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000004E1                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000004E6                 jmp     ___CxxFrameHandler3
.text$x:000004E6 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000004E6
.text$x:000004E6 ; ---------------------------------------------------------------------------
.text$x:000004EB                 align 4
.text$x:000004EB _text$x         ends
.text$x:000004EB
.text$mn:000004EC ; ===========================================================================
.text$mn:000004EC
.text$mn:000004EC ; Segment type: Pure code
.text$mn:000004EC ; Segment permissions: Read/Execute
.text$mn:000004EC _text$mn        segment para public 'CODE' use32
.text$mn:000004EC                 assume cs:_text$mn
.text$mn:000004EC                 ;org 4ECh
.text$mn:000004EC ; COMDAT (pick any)
.text$mn:000004EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000004EC
.text$mn:000004EC ; =============== S U B R O U T I N E =======================================
.text$mn:000004EC
.text$mn:000004EC ; Attributes: bp-based frame
.text$mn:000004EC
.text$mn:000004EC ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000004EC                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:000004EC ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:000004EC                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:000004EC
.text$mn:000004EC var_4           = dword ptr -4
.text$mn:000004EC
.text$mn:000004EC                 push    ebp
.text$mn:000004ED                 mov     ebp, esp
.text$mn:000004EF                 push    ecx
.text$mn:000004F0                 mov     [ebp+var_4], ecx
.text$mn:000004F3                 mov     eax, [ebp+var_4]
.text$mn:000004F6                 mov     dword ptr [eax], 0
.text$mn:000004FC                 mov     eax, [ebp+var_4]
.text$mn:000004FF                 mov     esp, ebp
.text$mn:00000501                 pop     ebp
.text$mn:00000502                 retn
.text$mn:00000502 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000502
.text$mn:00000502 ; ---------------------------------------------------------------------------
.text$mn:00000503                 align 4
.text$mn:00000503 _text$mn        ends
.text$mn:00000503
.text$mn:00000504 ; ===========================================================================
.text$mn:00000504
.text$mn:00000504 ; Segment type: Pure code
.text$mn:00000504 ; Segment permissions: Read/Execute
.text$mn:00000504 _text$mn        segment para public 'CODE' use32
.text$mn:00000504                 assume cs:_text$mn
.text$mn:00000504                 ;org 504h
.text$mn:00000504 ; COMDAT (pick any)
.text$mn:00000504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000504
.text$mn:00000504 ; =============== S U B R O U T I N E =======================================
.text$mn:00000504
.text$mn:00000504 ; Attributes: bp-based frame
.text$mn:00000504
.text$mn:00000504 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000504                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000504 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000504                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000504
.text$mn:00000504 var_4           = dword ptr -4
.text$mn:00000504
.text$mn:00000504                 push    ebp
.text$mn:00000505                 mov     ebp, esp
.text$mn:00000507                 push    ecx
.text$mn:00000508                 mov     [ebp+var_4], ecx
.text$mn:0000050B                 mov     eax, [ebp+var_4]
.text$mn:0000050E                 mov     dword ptr [eax], 0
.text$mn:00000514                 mov     ecx, [ebp+var_4]
.text$mn:00000517                 mov     dword ptr [ecx+4], 0
.text$mn:0000051E                 mov     eax, [ebp+var_4]
.text$mn:00000521                 mov     esp, ebp
.text$mn:00000523                 pop     ebp
.text$mn:00000524                 retn
.text$mn:00000524 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000524
.text$mn:00000524 ; ---------------------------------------------------------------------------
.text$mn:00000525                 align 4
.text$mn:00000525 _text$mn        ends
.text$mn:00000525
.text$mn:00000528 ; ===========================================================================
.text$mn:00000528
.text$mn:00000528 ; Segment type: Pure code
.text$mn:00000528 ; Segment permissions: Read/Execute
.text$mn:00000528 _text$mn        segment para public 'CODE' use32
.text$mn:00000528                 assume cs:_text$mn
.text$mn:00000528                 ;org 528h
.text$mn:00000528 ; COMDAT (pick any)
.text$mn:00000528                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000528
.text$mn:00000528 ; =============== S U B R O U T I N E =======================================
.text$mn:00000528
.text$mn:00000528 ; Attributes: bp-based frame
.text$mn:00000528
.text$mn:00000528 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000528                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000528 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00000528                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00000528                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00000528
.text$mn:00000528 var_10          = dword ptr -10h
.text$mn:00000528 var_C           = dword ptr -0Ch
.text$mn:00000528 var_4           = dword ptr -4
.text$mn:00000528
.text$mn:00000528                 push    ebp
.text$mn:00000529                 mov     ebp, esp
.text$mn:0000052B                 push    0FFFFFFFFh
.text$mn:0000052D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000532                 mov     eax, large fs:0
.text$mn:00000538                 push    eax
.text$mn:00000539                 push    ecx
.text$mn:0000053A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000053F                 xor     eax, ebp
.text$mn:00000541                 push    eax
.text$mn:00000542                 lea     eax, [ebp+var_C]
.text$mn:00000545                 mov     large fs:0, eax
.text$mn:0000054B                 mov     [ebp+var_10], ecx
.text$mn:0000054E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000551                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00000556                 mov     [ebp+var_4], 0
.text$mn:0000055D                 mov     eax, [ebp+var_10]
.text$mn:00000560                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00000566                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000056D                 mov     eax, [ebp+var_10]
.text$mn:00000570                 mov     ecx, [ebp+var_C]
.text$mn:00000573                 mov     large fs:0, ecx
.text$mn:0000057A                 pop     ecx
.text$mn:0000057B                 mov     esp, ebp
.text$mn:0000057D                 pop     ebp
.text$mn:0000057E                 retn
.text$mn:0000057E ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:0000057E
.text$mn:0000057E ; ---------------------------------------------------------------------------
.text$mn:0000057F                 align 10h
.text$mn:0000057F _text$mn        ends
.text$mn:0000057F
.text$x:00000580 ; ===========================================================================
.text$x:00000580
.text$x:00000580 ; Segment type: Pure code
.text$x:00000580 ; Segment permissions: Read/Execute
.text$x:00000580 _text$x         segment para public 'CODE' use32
.text$x:00000580                 assume cs:_text$x
.text$x:00000580                 ;org 580h
.text$x:00000580 ; COMDAT (pick associative to section at 528)
.text$x:00000580                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000580
.text$x:00000580 ; =============== S U B R O U T I N E =======================================
.text$x:00000580
.text$x:00000580
.text$x:00000580 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00000580                                         ; DATA XREF: .xdata$x:00001B7Co
.text$x:00000580                 mov     ecx, [ebp-10h]  ; this
.text$x:00000583                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000583 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00000583
.text$x:00000588
.text$x:00000588 ; =============== S U B R O U T I N E =======================================
.text$x:00000588
.text$x:00000588
.text$x:00000588 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00000588                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00000588
.text$x:00000588 arg_4           = dword ptr  8
.text$x:00000588
.text$x:00000588                 mov     edx, [esp+arg_4]
.text$x:0000058C                 lea     eax, [edx+0Ch]
.text$x:0000058F                 mov     ecx, [edx-8]
.text$x:00000592                 xor     ecx, eax
.text$x:00000594                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000599                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:0000059E                 jmp     ___CxxFrameHandler3
.text$x:0000059E __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:0000059E
.text$x:0000059E ; ---------------------------------------------------------------------------
.text$x:000005A3                 align 4
.text$x:000005A3 _text$x         ends
.text$x:000005A3
.text$mn:000005A4 ; ===========================================================================
.text$mn:000005A4
.text$mn:000005A4 ; Segment type: Pure code
.text$mn:000005A4 ; Segment permissions: Read/Execute
.text$mn:000005A4 _text$mn        segment para public 'CODE' use32
.text$mn:000005A4                 assume cs:_text$mn
.text$mn:000005A4                 ;org 5A4h
.text$mn:000005A4 ; COMDAT (pick any)
.text$mn:000005A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000005A4
.text$mn:000005A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000005A4
.text$mn:000005A4 ; Attributes: bp-based frame
.text$mn:000005A4
.text$mn:000005A4 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000005A4                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000005A4 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000005A4                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000005A4
.text$mn:000005A4 var_10          = dword ptr -10h
.text$mn:000005A4 var_C           = dword ptr -0Ch
.text$mn:000005A4 var_4           = dword ptr -4
.text$mn:000005A4
.text$mn:000005A4                 push    ebp
.text$mn:000005A5                 mov     ebp, esp
.text$mn:000005A7                 push    0FFFFFFFFh
.text$mn:000005A9                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000005AE                 mov     eax, large fs:0
.text$mn:000005B4                 push    eax
.text$mn:000005B5                 push    ecx
.text$mn:000005B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000005BB                 xor     eax, ebp
.text$mn:000005BD                 push    eax
.text$mn:000005BE                 lea     eax, [ebp+var_C]
.text$mn:000005C1                 mov     large fs:0, eax
.text$mn:000005C7                 mov     [ebp+var_10], ecx
.text$mn:000005CA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000005CD                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000005D2                 mov     [ebp+var_4], 0
.text$mn:000005D9                 mov     eax, [ebp+var_10]
.text$mn:000005DC                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:000005E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000005E9                 mov     eax, [ebp+var_10]
.text$mn:000005EC                 mov     ecx, [ebp+var_C]
.text$mn:000005EF                 mov     large fs:0, ecx
.text$mn:000005F6                 pop     ecx
.text$mn:000005F7                 mov     esp, ebp
.text$mn:000005F9                 pop     ebp
.text$mn:000005FA                 retn
.text$mn:000005FA ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:000005FA
.text$mn:000005FA ; ---------------------------------------------------------------------------
.text$mn:000005FB                 align 4
.text$mn:000005FB _text$mn        ends
.text$mn:000005FB
.text$x:000005FC ; ===========================================================================
.text$x:000005FC
.text$x:000005FC ; Segment type: Pure code
.text$x:000005FC ; Segment permissions: Read/Execute
.text$x:000005FC _text$x         segment para public 'CODE' use32
.text$x:000005FC                 assume cs:_text$x
.text$x:000005FC                 ;org 5FCh
.text$x:000005FC ; COMDAT (pick associative to section at 5A4)
.text$x:000005FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000005FC
.text$x:000005FC ; =============== S U B R O U T I N E =======================================
.text$x:000005FC
.text$x:000005FC
.text$x:000005FC __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:000005FC                                         ; DATA XREF: .xdata$x:00001C00o
.text$x:000005FC                 mov     ecx, [ebp-10h]  ; this
.text$x:000005FF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000005FF __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:000005FF
.text$x:00000604
.text$x:00000604 ; =============== S U B R O U T I N E =======================================
.text$x:00000604
.text$x:00000604
.text$x:00000604 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000604                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000604
.text$x:00000604 arg_4           = dword ptr  8
.text$x:00000604
.text$x:00000604                 mov     edx, [esp+arg_4]
.text$x:00000608                 lea     eax, [edx+0Ch]
.text$x:0000060B                 mov     ecx, [edx-8]
.text$x:0000060E                 xor     ecx, eax
.text$x:00000610                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000615                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000061A                 jmp     ___CxxFrameHandler3
.text$x:0000061A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000061A
.text$x:0000061A ; ---------------------------------------------------------------------------
.text$x:0000061F                 align 10h
.text$x:0000061F _text$x         ends
.text$x:0000061F
.text$mn:00000620 ; ===========================================================================
.text$mn:00000620
.text$mn:00000620 ; Segment type: Pure code
.text$mn:00000620 ; Segment permissions: Read/Execute
.text$mn:00000620 _text$mn        segment para public 'CODE' use32
.text$mn:00000620                 assume cs:_text$mn
.text$mn:00000620                 ;org 620h
.text$mn:00000620 ; COMDAT (pick any)
.text$mn:00000620                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000620
.text$mn:00000620 ; =============== S U B R O U T I N E =======================================
.text$mn:00000620
.text$mn:00000620 ; Attributes: bp-based frame
.text$mn:00000620
.text$mn:00000620 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000620                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000620 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000620                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000620
.text$mn:00000620 var_10          = dword ptr -10h
.text$mn:00000620 var_C           = dword ptr -0Ch
.text$mn:00000620 var_4           = dword ptr -4
.text$mn:00000620
.text$mn:00000620                 push    ebp
.text$mn:00000621                 mov     ebp, esp
.text$mn:00000623                 push    0FFFFFFFFh
.text$mn:00000625                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000062A                 mov     eax, large fs:0
.text$mn:00000630                 push    eax
.text$mn:00000631                 push    ecx
.text$mn:00000632                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000637                 xor     eax, ebp
.text$mn:00000639                 push    eax
.text$mn:0000063A                 lea     eax, [ebp+var_C]
.text$mn:0000063D                 mov     large fs:0, eax
.text$mn:00000643                 mov     [ebp+var_10], ecx
.text$mn:00000646                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000649                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000064E                 mov     [ebp+var_4], 0
.text$mn:00000655                 mov     eax, [ebp+var_10]
.text$mn:00000658                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:0000065E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000665                 mov     eax, [ebp+var_10]
.text$mn:00000668                 mov     ecx, [ebp+var_C]
.text$mn:0000066B                 mov     large fs:0, ecx
.text$mn:00000672                 pop     ecx
.text$mn:00000673                 mov     esp, ebp
.text$mn:00000675                 pop     ebp
.text$mn:00000676                 retn
.text$mn:00000676 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00000676
.text$mn:00000676 ; ---------------------------------------------------------------------------
.text$mn:00000677                 align 4
.text$mn:00000677 _text$mn        ends
.text$mn:00000677
.text$x:00000678 ; ===========================================================================
.text$x:00000678
.text$x:00000678 ; Segment type: Pure code
.text$x:00000678 ; Segment permissions: Read/Execute
.text$x:00000678 _text$x         segment para public 'CODE' use32
.text$x:00000678                 assume cs:_text$x
.text$x:00000678                 ;org 678h
.text$x:00000678 ; COMDAT (pick associative to section at 620)
.text$x:00000678                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000678
.text$x:00000678 ; =============== S U B R O U T I N E =======================================
.text$x:00000678
.text$x:00000678
.text$x:00000678 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00000678                                         ; DATA XREF: .xdata$x:00001C84o
.text$x:00000678                 mov     ecx, [ebp-10h]  ; this
.text$x:0000067B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000067B __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:0000067B
.text$x:00000680
.text$x:00000680 ; =============== S U B R O U T I N E =======================================
.text$x:00000680
.text$x:00000680
.text$x:00000680 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00000680                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00000680
.text$x:00000680 arg_4           = dword ptr  8
.text$x:00000680
.text$x:00000680                 mov     edx, [esp+arg_4]
.text$x:00000684                 lea     eax, [edx+0Ch]
.text$x:00000687                 mov     ecx, [edx-8]
.text$x:0000068A                 xor     ecx, eax
.text$x:0000068C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000691                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00000696                 jmp     ___CxxFrameHandler3
.text$x:00000696 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00000696
.text$x:00000696 ; ---------------------------------------------------------------------------
.text$x:0000069B                 align 4
.text$x:0000069B _text$x         ends
.text$x:0000069B
.text$mn:0000069C ; ===========================================================================
.text$mn:0000069C
.text$mn:0000069C ; Segment type: Pure code
.text$mn:0000069C ; Segment permissions: Read/Execute
.text$mn:0000069C _text$mn        segment para public 'CODE' use32
.text$mn:0000069C                 assume cs:_text$mn
.text$mn:0000069C                 ;org 69Ch
.text$mn:0000069C ; COMDAT (pick any)
.text$mn:0000069C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000069C
.text$mn:0000069C ; =============== S U B R O U T I N E =======================================
.text$mn:0000069C
.text$mn:0000069C ; Attributes: bp-based frame
.text$mn:0000069C
.text$mn:0000069C ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:0000069C                 public ??0error_category@std@@QAE@XZ
.text$mn:0000069C ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:0000069C
.text$mn:0000069C var_4           = dword ptr -4
.text$mn:0000069C
.text$mn:0000069C                 push    ebp
.text$mn:0000069D                 mov     ebp, esp
.text$mn:0000069F                 push    ecx
.text$mn:000006A0                 mov     [ebp+var_4], ecx
.text$mn:000006A3                 mov     eax, [ebp+var_4]
.text$mn:000006A6                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000006AC                 mov     eax, [ebp+var_4]
.text$mn:000006AF                 mov     esp, ebp
.text$mn:000006B1                 pop     ebp
.text$mn:000006B2                 retn
.text$mn:000006B2 ??0error_category@std@@QAE@XZ endp
.text$mn:000006B2
.text$mn:000006B2 ; ---------------------------------------------------------------------------
.text$mn:000006B3                 align 4
.text$mn:000006B3 _text$mn        ends
.text$mn:000006B3
.text$mn:000006B4 ; ===========================================================================
.text$mn:000006B4
.text$mn:000006B4 ; Segment type: Pure code
.text$mn:000006B4 ; Segment permissions: Read/Execute
.text$mn:000006B4 _text$mn        segment para public 'CODE' use32
.text$mn:000006B4                 assume cs:_text$mn
.text$mn:000006B4                 ;org 6B4h
.text$mn:000006B4 ; COMDAT (pick any)
.text$mn:000006B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006B4
.text$mn:000006B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000006B4
.text$mn:000006B4 ; Attributes: bp-based frame
.text$mn:000006B4
.text$mn:000006B4 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000006B4                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000006B4 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000006B4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000006B4                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000006B4
.text$mn:000006B4 var_4           = dword ptr -4
.text$mn:000006B4 arg_0           = dword ptr  8
.text$mn:000006B4 arg_4           = dword ptr  0Ch
.text$mn:000006B4
.text$mn:000006B4                 push    ebp
.text$mn:000006B5                 mov     ebp, esp
.text$mn:000006B7                 push    ecx
.text$mn:000006B8                 mov     [ebp+var_4], ecx
.text$mn:000006BB                 mov     eax, [ebp+var_4]
.text$mn:000006BE                 mov     ecx, [ebp+arg_0]
.text$mn:000006C1                 mov     [eax], ecx
.text$mn:000006C3                 mov     edx, [ebp+var_4]
.text$mn:000006C6                 mov     eax, [ebp+arg_4]
.text$mn:000006C9                 mov     [edx+4], eax
.text$mn:000006CC                 mov     eax, [ebp+var_4]
.text$mn:000006CF                 mov     esp, ebp
.text$mn:000006D1                 pop     ebp
.text$mn:000006D2                 retn    8
.text$mn:000006D2 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000006D2
.text$mn:000006D2 ; ---------------------------------------------------------------------------
.text$mn:000006D5                 align 4
.text$mn:000006D5 _text$mn        ends
.text$mn:000006D5
.text$mn:000006D8 ; ===========================================================================
.text$mn:000006D8
.text$mn:000006D8 ; Segment type: Pure code
.text$mn:000006D8 ; Segment permissions: Read/Execute
.text$mn:000006D8 _text$mn        segment para public 'CODE' use32
.text$mn:000006D8                 assume cs:_text$mn
.text$mn:000006D8                 ;org 6D8h
.text$mn:000006D8 ; COMDAT (pick any)
.text$mn:000006D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006D8
.text$mn:000006D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000006D8
.text$mn:000006D8 ; Attributes: bp-based frame
.text$mn:000006D8
.text$mn:000006D8 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:000006D8                 public ??0id@locale@std@@QAE@I@Z
.text$mn:000006D8 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:000006D8                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:000006D8
.text$mn:000006D8 var_4           = dword ptr -4
.text$mn:000006D8 arg_0           = dword ptr  8
.text$mn:000006D8
.text$mn:000006D8                 push    ebp
.text$mn:000006D9                 mov     ebp, esp
.text$mn:000006DB                 push    ecx
.text$mn:000006DC                 mov     [ebp+var_4], ecx
.text$mn:000006DF                 mov     eax, [ebp+var_4]
.text$mn:000006E2                 mov     ecx, [ebp+arg_0]
.text$mn:000006E5                 mov     [eax], ecx
.text$mn:000006E7                 mov     eax, [ebp+var_4]
.text$mn:000006EA                 mov     esp, ebp
.text$mn:000006EC                 pop     ebp
.text$mn:000006ED                 retn    4
.text$mn:000006ED ??0id@locale@std@@QAE@I@Z endp
.text$mn:000006ED
.text$mn:000006ED _text$mn        ends
.text$mn:000006ED
.text$mn:000006F0 ; ===========================================================================
.text$mn:000006F0
.text$mn:000006F0 ; Segment type: Pure code
.text$mn:000006F0 ; Segment permissions: Read/Execute
.text$mn:000006F0 _text$mn        segment para public 'CODE' use32
.text$mn:000006F0                 assume cs:_text$mn
.text$mn:000006F0                 ;org 6F0h
.text$mn:000006F0 ; COMDAT (pick any)
.text$mn:000006F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006F0
.text$mn:000006F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000006F0
.text$mn:000006F0 ; Attributes: bp-based frame
.text$mn:000006F0
.text$mn:000006F0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:000006F0                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000006F0 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000006F0                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:000006F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:000006F0
.text$mn:000006F0 var_10          = dword ptr -10h
.text$mn:000006F0 var_C           = dword ptr -0Ch
.text$mn:000006F0 var_4           = dword ptr -4
.text$mn:000006F0
.text$mn:000006F0                 push    ebp
.text$mn:000006F1                 mov     ebp, esp
.text$mn:000006F3                 push    0FFFFFFFFh
.text$mn:000006F5                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000006FA                 mov     eax, large fs:0
.text$mn:00000700                 push    eax
.text$mn:00000701                 push    ecx
.text$mn:00000702                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000707                 xor     eax, ebp
.text$mn:00000709                 push    eax
.text$mn:0000070A                 lea     eax, [ebp+var_C]
.text$mn:0000070D                 mov     large fs:0, eax
.text$mn:00000713                 mov     [ebp+var_10], ecx
.text$mn:00000716                 mov     [ebp+var_4], 0
.text$mn:0000071D                 mov     ecx, [ebp+var_10]
.text$mn:00000720                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000725                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000072C                 mov     ecx, [ebp+var_10]
.text$mn:0000072F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00000734                 mov     ecx, [ebp+var_C]
.text$mn:00000737                 mov     large fs:0, ecx
.text$mn:0000073E                 pop     ecx
.text$mn:0000073F                 mov     esp, ebp
.text$mn:00000741                 pop     ebp
.text$mn:00000742                 retn
.text$mn:00000742 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00000742
.text$mn:00000742 ; ---------------------------------------------------------------------------
.text$mn:00000743                 align 4
.text$mn:00000743 _text$mn        ends
.text$mn:00000743
.text$x:00000744 ; ===========================================================================
.text$x:00000744
.text$x:00000744 ; Segment type: Pure code
.text$x:00000744 ; Segment permissions: Read/Execute
.text$x:00000744 _text$x         segment para public 'CODE' use32
.text$x:00000744                 assume cs:_text$x
.text$x:00000744                 ;org 744h
.text$x:00000744 ; COMDAT (pick associative to section at 6F0)
.text$x:00000744                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000744
.text$x:00000744 ; =============== S U B R O U T I N E =======================================
.text$x:00000744
.text$x:00000744
.text$x:00000744 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00000744                                         ; DATA XREF: .xdata$x:00001A6Co
.text$x:00000744                 mov     ecx, [ebp-10h]
.text$x:00000747                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000747 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00000747
.text$x:0000074C
.text$x:0000074C ; =============== S U B R O U T I N E =======================================
.text$x:0000074C
.text$x:0000074C
.text$x:0000074C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000074C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:0000074C
.text$x:0000074C arg_4           = dword ptr  8
.text$x:0000074C
.text$x:0000074C                 mov     edx, [esp+arg_4]
.text$x:00000750                 lea     eax, [edx+0Ch]
.text$x:00000753                 mov     ecx, [edx-8]
.text$x:00000756                 xor     ecx, eax
.text$x:00000758                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000075D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00000762                 jmp     ___CxxFrameHandler3
.text$x:00000762 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00000762
.text$x:00000762 ; ---------------------------------------------------------------------------
.text$x:00000767                 align 4
.text$x:00000767 _text$x         ends
.text$x:00000767
.text$mn:00000768 ; ===========================================================================
.text$mn:00000768
.text$mn:00000768 ; Segment type: Pure code
.text$mn:00000768 ; Segment permissions: Read/Execute
.text$mn:00000768 _text$mn        segment para public 'CODE' use32
.text$mn:00000768                 assume cs:_text$mn
.text$mn:00000768                 ;org 768h
.text$mn:00000768 ; COMDAT (pick any)
.text$mn:00000768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000768
.text$mn:00000768 ; =============== S U B R O U T I N E =======================================
.text$mn:00000768
.text$mn:00000768 ; Attributes: bp-based frame
.text$mn:00000768
.text$mn:00000768 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000768                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000768 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000768                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00000768                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00000768
.text$mn:00000768 var_10          = dword ptr -10h
.text$mn:00000768 var_C           = dword ptr -0Ch
.text$mn:00000768 var_4           = dword ptr -4
.text$mn:00000768
.text$mn:00000768                 push    ebp
.text$mn:00000769                 mov     ebp, esp
.text$mn:0000076B                 push    0FFFFFFFFh
.text$mn:0000076D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000772                 mov     eax, large fs:0
.text$mn:00000778                 push    eax
.text$mn:00000779                 push    ecx
.text$mn:0000077A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000077F                 xor     eax, ebp
.text$mn:00000781                 push    eax
.text$mn:00000782                 lea     eax, [ebp+var_C]
.text$mn:00000785                 mov     large fs:0, eax
.text$mn:0000078B                 mov     [ebp+var_10], ecx
.text$mn:0000078E                 mov     [ebp+var_4], 0
.text$mn:00000795                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000079C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000079F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000007A4                 mov     ecx, [ebp+var_C]
.text$mn:000007A7                 mov     large fs:0, ecx
.text$mn:000007AE                 pop     ecx
.text$mn:000007AF                 mov     esp, ebp
.text$mn:000007B1                 pop     ebp
.text$mn:000007B2                 retn
.text$mn:000007B2 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000007B2
.text$mn:000007B2 ; ---------------------------------------------------------------------------
.text$mn:000007B3                 align 4
.text$mn:000007B3 _text$mn        ends
.text$mn:000007B3
.text$x:000007B4 ; ===========================================================================
.text$x:000007B4
.text$x:000007B4 ; Segment type: Pure code
.text$x:000007B4 ; Segment permissions: Read/Execute
.text$x:000007B4 _text$x         segment para public 'CODE' use32
.text$x:000007B4                 assume cs:_text$x
.text$x:000007B4                 ;org 7B4h
.text$x:000007B4 ; COMDAT (pick associative to section at 768)
.text$x:000007B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000007B4
.text$x:000007B4 ; =============== S U B R O U T I N E =======================================
.text$x:000007B4
.text$x:000007B4
.text$x:000007B4 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000007B4                                         ; DATA XREF: .xdata$x:00001A14o
.text$x:000007B4                 mov     ecx, [ebp-10h]  ; this
.text$x:000007B7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000007B7 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000007B7
.text$x:000007BC
.text$x:000007BC ; =============== S U B R O U T I N E =======================================
.text$x:000007BC
.text$x:000007BC
.text$x:000007BC __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000007BC                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000007BC
.text$x:000007BC arg_4           = dword ptr  8
.text$x:000007BC
.text$x:000007BC                 mov     edx, [esp+arg_4]
.text$x:000007C0                 lea     eax, [edx+0Ch]
.text$x:000007C3                 mov     ecx, [edx-8]
.text$x:000007C6                 xor     ecx, eax
.text$x:000007C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000007CD                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000007D2                 jmp     ___CxxFrameHandler3
.text$x:000007D2 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000007D2
.text$x:000007D2 ; ---------------------------------------------------------------------------
.text$x:000007D7                 align 4
.text$x:000007D7 _text$x         ends
.text$x:000007D7
.text$mn:000007D8 ; ===========================================================================
.text$mn:000007D8
.text$mn:000007D8 ; Segment type: Pure code
.text$mn:000007D8 ; Segment permissions: Read/Execute
.text$mn:000007D8 _text$mn        segment para public 'CODE' use32
.text$mn:000007D8                 assume cs:_text$mn
.text$mn:000007D8                 ;org 7D8h
.text$mn:000007D8 ; COMDAT (pick any)
.text$mn:000007D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000007D8
.text$mn:000007D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000007D8
.text$mn:000007D8 ; Attributes: bp-based frame
.text$mn:000007D8
.text$mn:000007D8 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000007D8                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000007D8 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000007D8                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:000007D8                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:000007D8
.text$mn:000007D8 var_10          = dword ptr -10h
.text$mn:000007D8 var_C           = dword ptr -0Ch
.text$mn:000007D8 var_4           = dword ptr -4
.text$mn:000007D8
.text$mn:000007D8                 push    ebp
.text$mn:000007D9                 mov     ebp, esp
.text$mn:000007DB                 push    0FFFFFFFFh
.text$mn:000007DD                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000007E2                 mov     eax, large fs:0
.text$mn:000007E8                 push    eax
.text$mn:000007E9                 push    ecx
.text$mn:000007EA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000007EF                 xor     eax, ebp
.text$mn:000007F1                 push    eax
.text$mn:000007F2                 lea     eax, [ebp+var_C]
.text$mn:000007F5                 mov     large fs:0, eax
.text$mn:000007FB                 mov     [ebp+var_10], ecx
.text$mn:000007FE                 mov     [ebp+var_4], 0
.text$mn:00000805                 push    0               ; Size
.text$mn:00000807                 push    1               ; char
.text$mn:00000809                 mov     ecx, [ebp+var_10]
.text$mn:0000080C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000811                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000818                 mov     ecx, [ebp+var_10]
.text$mn:0000081B                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000820                 mov     ecx, [ebp+var_C]
.text$mn:00000823                 mov     large fs:0, ecx
.text$mn:0000082A                 pop     ecx
.text$mn:0000082B                 mov     esp, ebp
.text$mn:0000082D                 pop     ebp
.text$mn:0000082E                 retn
.text$mn:0000082E ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:0000082E
.text$mn:0000082E ; ---------------------------------------------------------------------------
.text$mn:0000082F                 align 10h
.text$mn:0000082F _text$mn        ends
.text$mn:0000082F
.text$x:00000830 ; ===========================================================================
.text$x:00000830
.text$x:00000830 ; Segment type: Pure code
.text$x:00000830 ; Segment permissions: Read/Execute
.text$x:00000830 _text$x         segment para public 'CODE' use32
.text$x:00000830                 assume cs:_text$x
.text$x:00000830                 ;org 830h
.text$x:00000830 ; COMDAT (pick associative to section at 7D8)
.text$x:00000830                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000830
.text$x:00000830 ; =============== S U B R O U T I N E =======================================
.text$x:00000830
.text$x:00000830
.text$x:00000830 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000830                                         ; DATA XREF: .xdata$x:00001AC4o
.text$x:00000830                 mov     ecx, [ebp-10h]
.text$x:00000833                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000833 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000833
.text$x:00000838
.text$x:00000838 ; =============== S U B R O U T I N E =======================================
.text$x:00000838
.text$x:00000838
.text$x:00000838 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00000838                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00000838
.text$x:00000838 arg_4           = dword ptr  8
.text$x:00000838
.text$x:00000838                 mov     edx, [esp+arg_4]
.text$x:0000083C                 lea     eax, [edx+0Ch]
.text$x:0000083F                 mov     ecx, [edx-8]
.text$x:00000842                 xor     ecx, eax
.text$x:00000844                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000849                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:0000084E                 jmp     ___CxxFrameHandler3
.text$x:0000084E __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:0000084E
.text$x:0000084E ; ---------------------------------------------------------------------------
.text$x:00000853                 align 4
.text$x:00000853 _text$x         ends
.text$x:00000853
.text$mn:00000854 ; ===========================================================================
.text$mn:00000854
.text$mn:00000854 ; Segment type: Pure code
.text$mn:00000854 ; Segment permissions: Read/Execute
.text$mn:00000854 _text$mn        segment para public 'CODE' use32
.text$mn:00000854                 assume cs:_text$mn
.text$mn:00000854                 ;org 854h
.text$mn:00000854 ; COMDAT (pick any)
.text$mn:00000854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000854
.text$mn:00000854 ; =============== S U B R O U T I N E =======================================
.text$mn:00000854
.text$mn:00000854 ; Attributes: bp-based frame
.text$mn:00000854
.text$mn:00000854 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000854                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000854 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000854                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000854                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000854
.text$mn:00000854 var_4           = dword ptr -4
.text$mn:00000854
.text$mn:00000854                 push    ebp
.text$mn:00000855                 mov     ebp, esp
.text$mn:00000857                 push    ecx
.text$mn:00000858                 mov     [ebp+var_4], ecx
.text$mn:0000085B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000085E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000863                 mov     esp, ebp
.text$mn:00000865                 pop     ebp
.text$mn:00000866                 retn
.text$mn:00000866 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00000866
.text$mn:00000866 ; ---------------------------------------------------------------------------
.text$mn:00000867                 align 4
.text$mn:00000867 _text$mn        ends
.text$mn:00000867
.text$mn:00000868 ; ===========================================================================
.text$mn:00000868
.text$mn:00000868 ; Segment type: Pure code
.text$mn:00000868 ; Segment permissions: Read/Execute
.text$mn:00000868 _text$mn        segment para public 'CODE' use32
.text$mn:00000868                 assume cs:_text$mn
.text$mn:00000868                 ;org 868h
.text$mn:00000868 ; COMDAT (pick any)
.text$mn:00000868                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000868
.text$mn:00000868 ; =============== S U B R O U T I N E =======================================
.text$mn:00000868
.text$mn:00000868 ; Attributes: bp-based frame
.text$mn:00000868
.text$mn:00000868 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000868                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000868 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000868                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000868                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000868
.text$mn:00000868 var_10          = dword ptr -10h
.text$mn:00000868 var_C           = dword ptr -0Ch
.text$mn:00000868 var_4           = dword ptr -4
.text$mn:00000868
.text$mn:00000868                 push    ebp
.text$mn:00000869                 mov     ebp, esp
.text$mn:0000086B                 push    0FFFFFFFFh
.text$mn:0000086D                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000872                 mov     eax, large fs:0
.text$mn:00000878                 push    eax
.text$mn:00000879                 push    ecx
.text$mn:0000087A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000087F                 xor     eax, ebp
.text$mn:00000881                 push    eax
.text$mn:00000882                 lea     eax, [ebp+var_C]
.text$mn:00000885                 mov     large fs:0, eax
.text$mn:0000088B                 mov     [ebp+var_10], ecx
.text$mn:0000088E                 mov     [ebp+var_4], 0
.text$mn:00000895                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000089C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000089F                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000008A4                 mov     ecx, [ebp+var_C]
.text$mn:000008A7                 mov     large fs:0, ecx
.text$mn:000008AE                 pop     ecx
.text$mn:000008AF                 mov     esp, ebp
.text$mn:000008B1                 pop     ebp
.text$mn:000008B2                 retn
.text$mn:000008B2 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:000008B2
.text$mn:000008B2 ; ---------------------------------------------------------------------------
.text$mn:000008B3                 align 4
.text$mn:000008B3 _text$mn        ends
.text$mn:000008B3
.text$x:000008B4 ; ===========================================================================
.text$x:000008B4
.text$x:000008B4 ; Segment type: Pure code
.text$x:000008B4 ; Segment permissions: Read/Execute
.text$x:000008B4 _text$x         segment para public 'CODE' use32
.text$x:000008B4                 assume cs:_text$x
.text$x:000008B4                 ;org 8B4h
.text$x:000008B4 ; COMDAT (pick associative to section at 868)
.text$x:000008B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000008B4
.text$x:000008B4 ; =============== S U B R O U T I N E =======================================
.text$x:000008B4
.text$x:000008B4
.text$x:000008B4 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:000008B4                                         ; DATA XREF: .xdata$x:00001BD4o
.text$x:000008B4                 mov     ecx, [ebp-10h]  ; this
.text$x:000008B7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000008B7 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:000008B7
.text$x:000008BC
.text$x:000008BC ; =============== S U B R O U T I N E =======================================
.text$x:000008BC
.text$x:000008BC
.text$x:000008BC __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000008BC                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000008BC
.text$x:000008BC arg_4           = dword ptr  8
.text$x:000008BC
.text$x:000008BC                 mov     edx, [esp+arg_4]
.text$x:000008C0                 lea     eax, [edx+0Ch]
.text$x:000008C3                 mov     ecx, [edx-8]
.text$x:000008C6                 xor     ecx, eax
.text$x:000008C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008CD                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000008D2                 jmp     ___CxxFrameHandler3
.text$x:000008D2 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000008D2
.text$x:000008D2 ; ---------------------------------------------------------------------------
.text$x:000008D7                 align 4
.text$x:000008D7 _text$x         ends
.text$x:000008D7
.text$mn:000008D8 ; ===========================================================================
.text$mn:000008D8
.text$mn:000008D8 ; Segment type: Pure code
.text$mn:000008D8 ; Segment permissions: Read/Execute
.text$mn:000008D8 _text$mn        segment para public 'CODE' use32
.text$mn:000008D8                 assume cs:_text$mn
.text$mn:000008D8                 ;org 8D8h
.text$mn:000008D8 ; COMDAT (pick any)
.text$mn:000008D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008D8
.text$mn:000008D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000008D8
.text$mn:000008D8 ; Attributes: bp-based frame
.text$mn:000008D8
.text$mn:000008D8 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000008D8                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000008D8 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000008D8                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000008D8                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000008D8
.text$mn:000008D8 var_10          = dword ptr -10h
.text$mn:000008D8 var_C           = dword ptr -0Ch
.text$mn:000008D8 var_4           = dword ptr -4
.text$mn:000008D8
.text$mn:000008D8                 push    ebp
.text$mn:000008D9                 mov     ebp, esp
.text$mn:000008DB                 push    0FFFFFFFFh
.text$mn:000008DD                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000008E2                 mov     eax, large fs:0
.text$mn:000008E8                 push    eax
.text$mn:000008E9                 push    ecx
.text$mn:000008EA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000008EF                 xor     eax, ebp
.text$mn:000008F1                 push    eax
.text$mn:000008F2                 lea     eax, [ebp+var_C]
.text$mn:000008F5                 mov     large fs:0, eax
.text$mn:000008FB                 mov     [ebp+var_10], ecx
.text$mn:000008FE                 mov     [ebp+var_4], 0
.text$mn:00000905                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000090C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000090F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000914                 mov     ecx, [ebp+var_C]
.text$mn:00000917                 mov     large fs:0, ecx
.text$mn:0000091E                 pop     ecx
.text$mn:0000091F                 mov     esp, ebp
.text$mn:00000921                 pop     ebp
.text$mn:00000922                 retn
.text$mn:00000922 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00000922
.text$mn:00000922 ; ---------------------------------------------------------------------------
.text$mn:00000923                 align 4
.text$mn:00000923 _text$mn        ends
.text$mn:00000923
.text$x:00000924 ; ===========================================================================
.text$x:00000924
.text$x:00000924 ; Segment type: Pure code
.text$x:00000924 ; Segment permissions: Read/Execute
.text$x:00000924 _text$x         segment para public 'CODE' use32
.text$x:00000924                 assume cs:_text$x
.text$x:00000924                 ;org 924h
.text$x:00000924 ; COMDAT (pick associative to section at 8D8)
.text$x:00000924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000924
.text$x:00000924 ; =============== S U B R O U T I N E =======================================
.text$x:00000924
.text$x:00000924
.text$x:00000924 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00000924                                         ; DATA XREF: .xdata$x:00001C58o
.text$x:00000924                 mov     ecx, [ebp-10h]  ; this
.text$x:00000927                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000927 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00000927
.text$x:0000092C
.text$x:0000092C ; =============== S U B R O U T I N E =======================================
.text$x:0000092C
.text$x:0000092C
.text$x:0000092C __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:0000092C                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:0000092C
.text$x:0000092C arg_4           = dword ptr  8
.text$x:0000092C
.text$x:0000092C                 mov     edx, [esp+arg_4]
.text$x:00000930                 lea     eax, [edx+0Ch]
.text$x:00000933                 mov     ecx, [edx-8]
.text$x:00000936                 xor     ecx, eax
.text$x:00000938                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000093D                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00000942                 jmp     ___CxxFrameHandler3
.text$x:00000942 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00000942
.text$x:00000942 ; ---------------------------------------------------------------------------
.text$x:00000947                 align 4
.text$x:00000947 _text$x         ends
.text$x:00000947
.text$mn:00000948 ; ===========================================================================
.text$mn:00000948
.text$mn:00000948 ; Segment type: Pure code
.text$mn:00000948 ; Segment permissions: Read/Execute
.text$mn:00000948 _text$mn        segment para public 'CODE' use32
.text$mn:00000948                 assume cs:_text$mn
.text$mn:00000948                 ;org 948h
.text$mn:00000948 ; COMDAT (pick any)
.text$mn:00000948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000948
.text$mn:00000948 ; =============== S U B R O U T I N E =======================================
.text$mn:00000948
.text$mn:00000948 ; Attributes: bp-based frame
.text$mn:00000948
.text$mn:00000948 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000948                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00000948 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00000948                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000948                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000948
.text$mn:00000948 var_10          = dword ptr -10h
.text$mn:00000948 var_C           = dword ptr -0Ch
.text$mn:00000948 var_4           = dword ptr -4
.text$mn:00000948
.text$mn:00000948                 push    ebp
.text$mn:00000949                 mov     ebp, esp
.text$mn:0000094B                 push    0FFFFFFFFh
.text$mn:0000094D                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00000952                 mov     eax, large fs:0
.text$mn:00000958                 push    eax
.text$mn:00000959                 push    ecx
.text$mn:0000095A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000095F                 xor     eax, ebp
.text$mn:00000961                 push    eax
.text$mn:00000962                 lea     eax, [ebp+var_C]
.text$mn:00000965                 mov     large fs:0, eax
.text$mn:0000096B                 mov     [ebp+var_10], ecx
.text$mn:0000096E                 mov     [ebp+var_4], 0
.text$mn:00000975                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000097C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000097F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000984                 mov     ecx, [ebp+var_C]
.text$mn:00000987                 mov     large fs:0, ecx
.text$mn:0000098E                 pop     ecx
.text$mn:0000098F                 mov     esp, ebp
.text$mn:00000991                 pop     ebp
.text$mn:00000992                 retn
.text$mn:00000992 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00000992
.text$mn:00000992 ; ---------------------------------------------------------------------------
.text$mn:00000993                 align 4
.text$mn:00000993 _text$mn        ends
.text$mn:00000993
.text$x:00000994 ; ===========================================================================
.text$x:00000994
.text$x:00000994 ; Segment type: Pure code
.text$x:00000994 ; Segment permissions: Read/Execute
.text$x:00000994 _text$x         segment para public 'CODE' use32
.text$x:00000994                 assume cs:_text$x
.text$x:00000994                 ;org 994h
.text$x:00000994 ; COMDAT (pick associative to section at 948)
.text$x:00000994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000994
.text$x:00000994 ; =============== S U B R O U T I N E =======================================
.text$x:00000994
.text$x:00000994
.text$x:00000994 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00000994                                         ; DATA XREF: .xdata$x:00001CDCo
.text$x:00000994                 mov     ecx, [ebp-10h]  ; this
.text$x:00000997                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000997 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00000997
.text$x:0000099C
.text$x:0000099C ; =============== S U B R O U T I N E =======================================
.text$x:0000099C
.text$x:0000099C
.text$x:0000099C __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:0000099C                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:0000099C
.text$x:0000099C arg_4           = dword ptr  8
.text$x:0000099C
.text$x:0000099C                 mov     edx, [esp+arg_4]
.text$x:000009A0                 lea     eax, [edx+0Ch]
.text$x:000009A3                 mov     ecx, [edx-8]
.text$x:000009A6                 xor     ecx, eax
.text$x:000009A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000009AD                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:000009B2                 jmp     ___CxxFrameHandler3
.text$x:000009B2 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:000009B2
.text$x:000009B2 ; ---------------------------------------------------------------------------
.text$x:000009B7                 align 4
.text$x:000009B7 _text$x         ends
.text$x:000009B7
.text$mn:000009B8 ; ===========================================================================
.text$mn:000009B8
.text$mn:000009B8 ; Segment type: Pure code
.text$mn:000009B8 ; Segment permissions: Read/Execute
.text$mn:000009B8 _text$mn        segment para public 'CODE' use32
.text$mn:000009B8                 assume cs:_text$mn
.text$mn:000009B8                 ;org 9B8h
.text$mn:000009B8 ; COMDAT (pick any)
.text$mn:000009B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009B8
.text$mn:000009B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000009B8
.text$mn:000009B8 ; Attributes: bp-based frame
.text$mn:000009B8
.text$mn:000009B8 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:000009B8                 public ??1error_category@std@@UAE@XZ
.text$mn:000009B8 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:000009B8                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:000009B8
.text$mn:000009B8 var_4           = dword ptr -4
.text$mn:000009B8
.text$mn:000009B8                 push    ebp
.text$mn:000009B9                 mov     ebp, esp
.text$mn:000009BB                 push    ecx
.text$mn:000009BC                 mov     [ebp+var_4], ecx
.text$mn:000009BF                 mov     eax, [ebp+var_4]
.text$mn:000009C2                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000009C8                 mov     esp, ebp
.text$mn:000009CA                 pop     ebp
.text$mn:000009CB                 retn
.text$mn:000009CB ??1error_category@std@@UAE@XZ endp
.text$mn:000009CB
.text$mn:000009CB _text$mn        ends
.text$mn:000009CB
.text$mn:000009CC ; ===========================================================================
.text$mn:000009CC
.text$mn:000009CC ; Segment type: Pure code
.text$mn:000009CC ; Segment permissions: Read/Execute
.text$mn:000009CC _text$mn        segment para public 'CODE' use32
.text$mn:000009CC                 assume cs:_text$mn
.text$mn:000009CC                 ;org 9CCh
.text$mn:000009CC ; COMDAT (pick any)
.text$mn:000009CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009CC
.text$mn:000009CC ; =============== S U B R O U T I N E =======================================
.text$mn:000009CC
.text$mn:000009CC ; Attributes: bp-based frame
.text$mn:000009CC
.text$mn:000009CC ; void *__cdecl operator new(unsigned int, void *)
.text$mn:000009CC                 public ??2@YAPAXIPAX@Z
.text$mn:000009CC ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:000009CC                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:000009CC
.text$mn:000009CC arg_4           = dword ptr  0Ch
.text$mn:000009CC
.text$mn:000009CC                 push    ebp
.text$mn:000009CD                 mov     ebp, esp
.text$mn:000009CF                 mov     eax, [ebp+arg_4]
.text$mn:000009D2                 pop     ebp
.text$mn:000009D3                 retn
.text$mn:000009D3 ??2@YAPAXIPAX@Z endp
.text$mn:000009D3
.text$mn:000009D3 _text$mn        ends
.text$mn:000009D3
.text$mn:000009D4 ; ===========================================================================
.text$mn:000009D4
.text$mn:000009D4 ; Segment type: Pure code
.text$mn:000009D4 ; Segment permissions: Read/Execute
.text$mn:000009D4 _text$mn        segment para public 'CODE' use32
.text$mn:000009D4                 assume cs:_text$mn
.text$mn:000009D4                 ;org 9D4h
.text$mn:000009D4 ; COMDAT (pick any)
.text$mn:000009D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009D4
.text$mn:000009D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000009D4
.text$mn:000009D4 ; Attributes: bp-based frame
.text$mn:000009D4
.text$mn:000009D4 ; void __cdecl operator delete(void *)
.text$mn:000009D4                 public ??3@YAXPAX0@Z
.text$mn:000009D4 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:000009D4                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:000009D4                 push    ebp
.text$mn:000009D5                 mov     ebp, esp
.text$mn:000009D7                 pop     ebp
.text$mn:000009D8                 retn
.text$mn:000009D8 ??3@YAXPAX0@Z   endp
.text$mn:000009D8
.text$mn:000009D8 ; ---------------------------------------------------------------------------
.text$mn:000009D9                 align 4
.text$mn:000009D9 _text$mn        ends
.text$mn:000009D9
.text$mn:000009DC ; ===========================================================================
.text$mn:000009DC
.text$mn:000009DC ; Segment type: Pure code
.text$mn:000009DC ; Segment permissions: Read/Execute
.text$mn:000009DC _text$mn        segment para public 'CODE' use32
.text$mn:000009DC                 assume cs:_text$mn
.text$mn:000009DC                 ;org 9DCh
.text$mn:000009DC ; COMDAT (pick any)
.text$mn:000009DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009DC
.text$mn:000009DC ; =============== S U B R O U T I N E =======================================
.text$mn:000009DC
.text$mn:000009DC ; Attributes: bp-based frame
.text$mn:000009DC
.text$mn:000009DC ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:000009DC                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:000009DC ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:000009DC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:000009DC                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:000009DC
.text$mn:000009DC var_8           = dword ptr -8
.text$mn:000009DC var_4           = dword ptr -4
.text$mn:000009DC arg_0           = dword ptr  8
.text$mn:000009DC
.text$mn:000009DC                 push    ebp
.text$mn:000009DD                 mov     ebp, esp
.text$mn:000009DF                 sub     esp, 8
.text$mn:000009E2                 mov     [ebp+var_8], ecx
.text$mn:000009E5                 mov     eax, [ebp+var_8]
.text$mn:000009E8                 cmp     eax, [ebp+arg_0]
.text$mn:000009EB                 jnz     short loc_9F6
.text$mn:000009ED                 mov     [ebp+var_4], 1
.text$mn:000009F4                 jmp     short loc_9FD
.text$mn:000009F6 ; ---------------------------------------------------------------------------
.text$mn:000009F6
.text$mn:000009F6 loc_9F6:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:000009F6                 mov     [ebp+var_4], 0
.text$mn:000009FD
.text$mn:000009FD loc_9FD:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:000009FD                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000A00                 mov     esp, ebp
.text$mn:00000A02                 pop     ebp
.text$mn:00000A03                 retn    4
.text$mn:00000A03 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00000A03
.text$mn:00000A03 ; ---------------------------------------------------------------------------
.text$mn:00000A06                 align 4
.text$mn:00000A06 _text$mn        ends
.text$mn:00000A06
.text$mn:00000A08 ; ===========================================================================
.text$mn:00000A08
.text$mn:00000A08 ; Segment type: Pure code
.text$mn:00000A08 ; Segment permissions: Read/Execute
.text$mn:00000A08 _text$mn        segment para public 'CODE' use32
.text$mn:00000A08                 assume cs:_text$mn
.text$mn:00000A08                 ;org 0A08h
.text$mn:00000A08 ; COMDAT (pick any)
.text$mn:00000A08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A08
.text$mn:00000A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A08
.text$mn:00000A08 ; Attributes: bp-based frame
.text$mn:00000A08
.text$mn:00000A08 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00000A08                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00000A08 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00000A08                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00000A08
.text$mn:00000A08 var_8           = dword ptr -8
.text$mn:00000A08 var_4           = dword ptr -4
.text$mn:00000A08 arg_0           = dword ptr  8
.text$mn:00000A08
.text$mn:00000A08                 push    ebp
.text$mn:00000A09                 mov     ebp, esp
.text$mn:00000A0B                 sub     esp, 8
.text$mn:00000A0E                 push    esi
.text$mn:00000A0F                 mov     [ebp+var_4], ecx
.text$mn:00000A12                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000A15                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000A1A                 push    eax
.text$mn:00000A1B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000A1E                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000A23                 mov     ecx, eax
.text$mn:00000A25                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00000A2A                 movzx   eax, al
.text$mn:00000A2D                 test    eax, eax
.text$mn:00000A2F                 jz      short loc_A50
.text$mn:00000A31                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000A34                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000A39                 mov     esi, eax
.text$mn:00000A3B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000A3E                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000A43                 cmp     esi, eax
.text$mn:00000A45                 jnz     short loc_A50
.text$mn:00000A47                 mov     [ebp+var_8], 1
.text$mn:00000A4E                 jmp     short loc_A57
.text$mn:00000A50 ; ---------------------------------------------------------------------------
.text$mn:00000A50
.text$mn:00000A50 loc_A50:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00000A50                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00000A50                 mov     [ebp+var_8], 0
.text$mn:00000A57
.text$mn:00000A57 loc_A57:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00000A57                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000A5A                 pop     esi
.text$mn:00000A5B                 mov     esp, ebp
.text$mn:00000A5D                 pop     ebp
.text$mn:00000A5E                 retn    4
.text$mn:00000A5E ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00000A5E
.text$mn:00000A5E ; ---------------------------------------------------------------------------
.text$mn:00000A61                 align 4
.text$mn:00000A61 _text$mn        ends
.text$mn:00000A61
.text$mn:00000A64 ; ===========================================================================
.text$mn:00000A64
.text$mn:00000A64 ; Segment type: Pure code
.text$mn:00000A64 ; Segment permissions: Read/Execute
.text$mn:00000A64 _text$mn        segment para public 'CODE' use32
.text$mn:00000A64                 assume cs:_text$mn
.text$mn:00000A64                 ;org 0A64h
.text$mn:00000A64 ; COMDAT (pick any)
.text$mn:00000A64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A64
.text$mn:00000A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A64
.text$mn:00000A64 ; Attributes: bp-based frame
.text$mn:00000A64
.text$mn:00000A64 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000A64                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00000A64 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000A64
.text$mn:00000A64 var_4           = dword ptr -4
.text$mn:00000A64 arg_0           = dword ptr  8
.text$mn:00000A64
.text$mn:00000A64                 push    ebp
.text$mn:00000A65                 mov     ebp, esp
.text$mn:00000A67                 push    ecx
.text$mn:00000A68                 mov     [ebp+var_4], ecx
.text$mn:00000A6B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000A6E                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000A73                 mov     eax, [ebp+arg_0]
.text$mn:00000A76                 and     eax, 1
.text$mn:00000A79                 jz      short loc_A87
.text$mn:00000A7B                 mov     ecx, [ebp+var_4]
.text$mn:00000A7E                 push    ecx             ; void *
.text$mn:00000A7F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000A84                 add     esp, 4
.text$mn:00000A87
.text$mn:00000A87 loc_A87:                                ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000A87                 mov     eax, [ebp+var_4]
.text$mn:00000A8A                 mov     esp, ebp
.text$mn:00000A8C                 pop     ebp
.text$mn:00000A8D                 retn    4
.text$mn:00000A8D ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00000A8D
.text$mn:00000A8D _text$mn        ends
.text$mn:00000A8D
.text$mn:00000A90 ; ===========================================================================
.text$mn:00000A90
.text$mn:00000A90 ; Segment type: Pure code
.text$mn:00000A90 ; Segment permissions: Read/Execute
.text$mn:00000A90 _text$mn        segment para public 'CODE' use32
.text$mn:00000A90                 assume cs:_text$mn
.text$mn:00000A90                 ;org 0A90h
.text$mn:00000A90 ; COMDAT (pick any)
.text$mn:00000A90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A90
.text$mn:00000A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A90
.text$mn:00000A90 ; Attributes: bp-based frame
.text$mn:00000A90
.text$mn:00000A90 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000A90                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00000A90 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000A90
.text$mn:00000A90 var_4           = dword ptr -4
.text$mn:00000A90 arg_0           = dword ptr  8
.text$mn:00000A90
.text$mn:00000A90                 push    ebp
.text$mn:00000A91                 mov     ebp, esp
.text$mn:00000A93                 push    ecx
.text$mn:00000A94                 mov     [ebp+var_4], ecx
.text$mn:00000A97                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000A9A                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00000A9F                 mov     eax, [ebp+arg_0]
.text$mn:00000AA2                 and     eax, 1
.text$mn:00000AA5                 jz      short loc_AB3
.text$mn:00000AA7                 mov     ecx, [ebp+var_4]
.text$mn:00000AAA                 push    ecx             ; void *
.text$mn:00000AAB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000AB0                 add     esp, 4
.text$mn:00000AB3
.text$mn:00000AB3 loc_AB3:                                ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000AB3                 mov     eax, [ebp+var_4]
.text$mn:00000AB6                 mov     esp, ebp
.text$mn:00000AB8                 pop     ebp
.text$mn:00000AB9                 retn    4
.text$mn:00000AB9 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00000AB9
.text$mn:00000AB9 _text$mn        ends
.text$mn:00000AB9
.text$mn:00000ABC ; ===========================================================================
.text$mn:00000ABC
.text$mn:00000ABC ; Segment type: Pure code
.text$mn:00000ABC ; Segment permissions: Read/Execute
.text$mn:00000ABC _text$mn        segment para public 'CODE' use32
.text$mn:00000ABC                 assume cs:_text$mn
.text$mn:00000ABC                 ;org 0ABCh
.text$mn:00000ABC ; COMDAT (pick any)
.text$mn:00000ABC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000ABC
.text$mn:00000ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00000ABC
.text$mn:00000ABC ; Attributes: bp-based frame
.text$mn:00000ABC
.text$mn:00000ABC ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000ABC                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00000ABC ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000ABC
.text$mn:00000ABC var_4           = dword ptr -4
.text$mn:00000ABC arg_0           = dword ptr  8
.text$mn:00000ABC
.text$mn:00000ABC                 push    ebp
.text$mn:00000ABD                 mov     ebp, esp
.text$mn:00000ABF                 push    ecx
.text$mn:00000AC0                 mov     [ebp+var_4], ecx
.text$mn:00000AC3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000AC6                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00000ACB                 mov     eax, [ebp+arg_0]
.text$mn:00000ACE                 and     eax, 1
.text$mn:00000AD1                 jz      short loc_ADF
.text$mn:00000AD3                 mov     ecx, [ebp+var_4]
.text$mn:00000AD6                 push    ecx             ; void *
.text$mn:00000AD7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000ADC                 add     esp, 4
.text$mn:00000ADF
.text$mn:00000ADF loc_ADF:                                ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000ADF                 mov     eax, [ebp+var_4]
.text$mn:00000AE2                 mov     esp, ebp
.text$mn:00000AE4                 pop     ebp
.text$mn:00000AE5                 retn    4
.text$mn:00000AE5 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00000AE5
.text$mn:00000AE5 _text$mn        ends
.text$mn:00000AE5
.text$mn:00000AE8 ; ===========================================================================
.text$mn:00000AE8
.text$mn:00000AE8 ; Segment type: Pure code
.text$mn:00000AE8 ; Segment permissions: Read/Execute
.text$mn:00000AE8 _text$mn        segment para public 'CODE' use32
.text$mn:00000AE8                 assume cs:_text$mn
.text$mn:00000AE8                 ;org 0AE8h
.text$mn:00000AE8 ; COMDAT (pick any)
.text$mn:00000AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000AE8
.text$mn:00000AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AE8
.text$mn:00000AE8 ; Attributes: bp-based frame
.text$mn:00000AE8
.text$mn:00000AE8 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000AE8                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00000AE8 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00000AE8
.text$mn:00000AE8 var_4           = dword ptr -4
.text$mn:00000AE8 arg_0           = dword ptr  8
.text$mn:00000AE8
.text$mn:00000AE8                 push    ebp
.text$mn:00000AE9                 mov     ebp, esp
.text$mn:00000AEB                 push    ecx
.text$mn:00000AEC                 mov     [ebp+var_4], ecx
.text$mn:00000AEF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000AF2                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000AF7                 mov     eax, [ebp+arg_0]
.text$mn:00000AFA                 and     eax, 1
.text$mn:00000AFD                 jz      short loc_B0B
.text$mn:00000AFF                 mov     ecx, [ebp+var_4]
.text$mn:00000B02                 push    ecx             ; void *
.text$mn:00000B03                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000B08                 add     esp, 4
.text$mn:00000B0B
.text$mn:00000B0B loc_B0B:                                ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000B0B                 mov     eax, [ebp+var_4]
.text$mn:00000B0E                 mov     esp, ebp
.text$mn:00000B10                 pop     ebp
.text$mn:00000B11                 retn    4
.text$mn:00000B11 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00000B11
.text$mn:00000B11 _text$mn        ends
.text$mn:00000B11
.text$di:00000B14 ; ===========================================================================
.text$di:00000B14
.text$di:00000B14 ; Segment type: Pure code
.text$di:00000B14 ; Segment permissions: Read/Execute
.text$di:00000B14 _text$di        segment para public 'CODE' use32
.text$di:00000B14                 assume cs:_text$di
.text$di:00000B14                 ;org 0B14h
.text$di:00000B14 ; COMDAT (pick any)
.text$di:00000B14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000B14
.text$di:00000B14 ; =============== S U B R O U T I N E =======================================
.text$di:00000B14
.text$di:00000B14 ; Attributes: bp-based frame
.text$di:00000B14
.text$di:00000B14 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00000B14 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00000B14                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00000B14                 push    ebp
.text$di:00000B15                 mov     ebp, esp
.text$di:00000B17                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00000B1C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00000B21                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000B26                 call    _atexit
.text$di:00000B2B                 add     esp, 4
.text$di:00000B2E                 pop     ebp
.text$di:00000B2F                 retn
.text$di:00000B2F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00000B2F
.text$di:00000B2F _text$di        ends
.text$di:00000B2F
.text$di:00000B30 ; ===========================================================================
.text$di:00000B30
.text$di:00000B30 ; Segment type: Pure code
.text$di:00000B30 ; Segment permissions: Read/Execute
.text$di:00000B30 _text$di        segment para public 'CODE' use32
.text$di:00000B30                 assume cs:_text$di
.text$di:00000B30                 ;org 0B30h
.text$di:00000B30 ; COMDAT (pick any)
.text$di:00000B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000B30
.text$di:00000B30 ; =============== S U B R O U T I N E =======================================
.text$di:00000B30
.text$di:00000B30 ; Attributes: bp-based frame
.text$di:00000B30
.text$di:00000B30 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00000B30 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00000B30                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00000B30                 push    ebp
.text$di:00000B31                 mov     ebp, esp
.text$di:00000B33                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00000B38                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00000B3D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000B42                 call    _atexit
.text$di:00000B47                 add     esp, 4
.text$di:00000B4A                 pop     ebp
.text$di:00000B4B                 retn
.text$di:00000B4B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00000B4B
.text$di:00000B4B _text$di        ends
.text$di:00000B4B
.text$di:00000B4C ; ===========================================================================
.text$di:00000B4C
.text$di:00000B4C ; Segment type: Pure code
.text$di:00000B4C ; Segment permissions: Read/Execute
.text$di:00000B4C _text$di        segment para public 'CODE' use32
.text$di:00000B4C                 assume cs:_text$di
.text$di:00000B4C                 ;org 0B4Ch
.text$di:00000B4C ; COMDAT (pick any)
.text$di:00000B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000B4C
.text$di:00000B4C ; =============== S U B R O U T I N E =======================================
.text$di:00000B4C
.text$di:00000B4C ; Attributes: bp-based frame
.text$di:00000B4C
.text$di:00000B4C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00000B4C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00000B4C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00000B4C                 push    ebp
.text$di:00000B4D                 mov     ebp, esp
.text$di:00000B4F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00000B54                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00000B59                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000B5E                 call    _atexit
.text$di:00000B63                 add     esp, 4
.text$di:00000B66                 pop     ebp
.text$di:00000B67                 retn
.text$di:00000B67 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00000B67
.text$di:00000B67 _text$di        ends
.text$di:00000B67
.text$di:00000B68 ; ===========================================================================
.text$di:00000B68
.text$di:00000B68 ; Segment type: Pure code
.text$di:00000B68 ; Segment permissions: Read/Execute
.text$di:00000B68 _text$di        segment para public 'CODE' use32
.text$di:00000B68                 assume cs:_text$di
.text$di:00000B68                 ;org 0B68h
.text$di:00000B68 ; COMDAT (pick any)
.text$di:00000B68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000B68
.text$di:00000B68 ; =============== S U B R O U T I N E =======================================
.text$di:00000B68
.text$di:00000B68 ; Attributes: bp-based frame
.text$di:00000B68
.text$di:00000B68 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00000B68 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000B68                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00000B68                 push    ebp
.text$di:00000B69                 mov     ebp, esp
.text$di:00000B6B                 push    0               ; unsigned int
.text$di:00000B6D                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000B72                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000B77                 pop     ebp
.text$di:00000B78                 retn
.text$di:00000B78 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000B78
.text$di:00000B78 ; ---------------------------------------------------------------------------
.text$di:00000B79                 align 4
.text$di:00000B79 _text$di        ends
.text$di:00000B79
.text$di:00000B7C ; ===========================================================================
.text$di:00000B7C
.text$di:00000B7C ; Segment type: Pure code
.text$di:00000B7C ; Segment permissions: Read/Execute
.text$di:00000B7C _text$di        segment para public 'CODE' use32
.text$di:00000B7C                 assume cs:_text$di
.text$di:00000B7C                 ;org 0B7Ch
.text$di:00000B7C ; COMDAT (pick any)
.text$di:00000B7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000B7C
.text$di:00000B7C ; =============== S U B R O U T I N E =======================================
.text$di:00000B7C
.text$di:00000B7C ; Attributes: bp-based frame
.text$di:00000B7C
.text$di:00000B7C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00000B7C ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000B7C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00000B7C                 push    ebp
.text$di:00000B7D                 mov     ebp, esp
.text$di:00000B7F                 push    0               ; unsigned int
.text$di:00000B81                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000B86                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000B8B                 pop     ebp
.text$di:00000B8C                 retn
.text$di:00000B8C ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000B8C
.text$di:00000B8C ; ---------------------------------------------------------------------------
.text$di:00000B8D                 align 10h
.text$di:00000B8D _text$di        ends
.text$di:00000B8D
.text$di:00000B90 ; ===========================================================================
.text$di:00000B90
.text$di:00000B90 ; Segment type: Pure code
.text$di:00000B90 ; Segment permissions: Read/Execute
.text$di:00000B90 _text$di        segment para public 'CODE' use32
.text$di:00000B90                 assume cs:_text$di
.text$di:00000B90                 ;org 0B90h
.text$di:00000B90 ; COMDAT (pick any)
.text$di:00000B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000B90
.text$di:00000B90 ; =============== S U B R O U T I N E =======================================
.text$di:00000B90
.text$di:00000B90 ; Attributes: bp-based frame
.text$di:00000B90
.text$di:00000B90 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00000B90 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000B90                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00000B90                 push    ebp
.text$di:00000B91                 mov     ebp, esp
.text$di:00000B93                 push    0               ; unsigned int
.text$di:00000B95                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00000B9A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000B9F                 pop     ebp
.text$di:00000BA0                 retn
.text$di:00000BA0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000BA0
.text$di:00000BA0 ; ---------------------------------------------------------------------------
.text$di:00000BA1                 align 4
.text$di:00000BA1 _text$di        ends
.text$di:00000BA1
.text$di:00000BA4 ; ===========================================================================
.text$di:00000BA4
.text$di:00000BA4 ; Segment type: Pure code
.text$di:00000BA4 ; Segment permissions: Read/Execute
.text$di:00000BA4 _text$di        segment para public 'CODE' use32
.text$di:00000BA4                 assume cs:_text$di
.text$di:00000BA4                 ;org 0BA4h
.text$di:00000BA4 ; COMDAT (pick any)
.text$di:00000BA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000BA4
.text$di:00000BA4 ; =============== S U B R O U T I N E =======================================
.text$di:00000BA4
.text$di:00000BA4 ; Attributes: bp-based frame
.text$di:00000BA4
.text$di:00000BA4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00000BA4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000BA4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00000BA4                 push    ebp
.text$di:00000BA5                 mov     ebp, esp
.text$di:00000BA7                 push    0               ; unsigned int
.text$di:00000BA9                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00000BAE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000BB3                 pop     ebp
.text$di:00000BB4                 retn
.text$di:00000BB4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000BB4
.text$di:00000BB4 ; ---------------------------------------------------------------------------
.text$di:00000BB5                 align 4
.text$di:00000BB5 _text$di        ends
.text$di:00000BB5
.text$di:00000BB8 ; ===========================================================================
.text$di:00000BB8
.text$di:00000BB8 ; Segment type: Pure code
.text$di:00000BB8 ; Segment permissions: Read/Execute
.text$di:00000BB8 _text$di        segment para public 'CODE' use32
.text$di:00000BB8                 assume cs:_text$di
.text$di:00000BB8                 ;org 0BB8h
.text$di:00000BB8 ; COMDAT (pick any)
.text$di:00000BB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000BB8
.text$di:00000BB8 ; =============== S U B R O U T I N E =======================================
.text$di:00000BB8
.text$di:00000BB8 ; Attributes: bp-based frame
.text$di:00000BB8
.text$di:00000BB8 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00000BB8 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00000BB8
.text$di:00000BB8 var_1           = byte ptr -1
.text$di:00000BB8
.text$di:00000BB8                 push    ebp
.text$di:00000BB9                 mov     ebp, esp
.text$di:00000BBB                 push    ecx
.text$di:00000BBC                 xor     eax, eax
.text$di:00000BBE                 mov     [ebp+var_1], al
.text$di:00000BC1                 mov     esp, ebp
.text$di:00000BC3                 pop     ebp
.text$di:00000BC4                 retn
.text$di:00000BC4 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00000BC4
.text$di:00000BC4 ; ---------------------------------------------------------------------------
.text$di:00000BC5                 align 4
.text$di:00000BC5 _text$di        ends
.text$di:00000BC5
.text$di:00000BC8 ; ===========================================================================
.text$di:00000BC8
.text$di:00000BC8 ; Segment type: Pure code
.text$di:00000BC8 ; Segment permissions: Read/Execute
.text$di:00000BC8 _text$di        segment para public 'CODE' use32
.text$di:00000BC8                 assume cs:_text$di
.text$di:00000BC8                 ;org 0BC8h
.text$di:00000BC8 ; COMDAT (pick any)
.text$di:00000BC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000BC8
.text$di:00000BC8 ; =============== S U B R O U T I N E =======================================
.text$di:00000BC8
.text$di:00000BC8 ; Attributes: bp-based frame
.text$di:00000BC8
.text$di:00000BC8 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00000BC8 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00000BC8                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00000BC8
.text$di:00000BC8 var_1           = byte ptr -1
.text$di:00000BC8
.text$di:00000BC8                 push    ebp
.text$di:00000BC9                 mov     ebp, esp
.text$di:00000BCB                 push    ecx
.text$di:00000BCC                 xor     eax, eax
.text$di:00000BCE                 mov     [ebp+var_1], al
.text$di:00000BD1                 mov     esp, ebp
.text$di:00000BD3                 pop     ebp
.text$di:00000BD4                 retn
.text$di:00000BD4 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00000BD4
.text$di:00000BD4 ; ---------------------------------------------------------------------------
.text$di:00000BD5                 align 4
.text$di:00000BD5 _text$di        ends
.text$di:00000BD5
.text$yd:00000BD8 ; ===========================================================================
.text$yd:00000BD8
.text$yd:00000BD8 ; Segment type: Pure code
.text$yd:00000BD8 ; Segment permissions: Read/Execute
.text$yd:00000BD8 _text$yd        segment para public 'CODE' use32
.text$yd:00000BD8                 assume cs:_text$yd
.text$yd:00000BD8                 ;org 0BD8h
.text$yd:00000BD8 ; COMDAT (pick any)
.text$yd:00000BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000BD8
.text$yd:00000BD8 ; =============== S U B R O U T I N E =======================================
.text$yd:00000BD8
.text$yd:00000BD8 ; Attributes: bp-based frame
.text$yd:00000BD8
.text$yd:00000BD8 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00000BD8 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00000BD8                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00000BD8                 push    ebp
.text$yd:00000BD9                 mov     ebp, esp
.text$yd:00000BDB                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00000BE0                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00000BE5                 pop     ebp
.text$yd:00000BE6                 retn
.text$yd:00000BE6 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00000BE6
.text$yd:00000BE6 ; ---------------------------------------------------------------------------
.text$yd:00000BE7                 align 4
.text$yd:00000BE7 _text$yd        ends
.text$yd:00000BE7
.text$yd:00000BE8 ; ===========================================================================
.text$yd:00000BE8
.text$yd:00000BE8 ; Segment type: Pure code
.text$yd:00000BE8 ; Segment permissions: Read/Execute
.text$yd:00000BE8 _text$yd        segment para public 'CODE' use32
.text$yd:00000BE8                 assume cs:_text$yd
.text$yd:00000BE8                 ;org 0BE8h
.text$yd:00000BE8 ; COMDAT (pick any)
.text$yd:00000BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000BE8
.text$yd:00000BE8 ; =============== S U B R O U T I N E =======================================
.text$yd:00000BE8
.text$yd:00000BE8 ; Attributes: bp-based frame
.text$yd:00000BE8
.text$yd:00000BE8 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00000BE8 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00000BE8                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00000BE8                 push    ebp
.text$yd:00000BE9                 mov     ebp, esp
.text$yd:00000BEB                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00000BF0                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00000BF5                 pop     ebp
.text$yd:00000BF6                 retn
.text$yd:00000BF6 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00000BF6
.text$yd:00000BF6 ; ---------------------------------------------------------------------------
.text$yd:00000BF7                 align 4
.text$yd:00000BF7 _text$yd        ends
.text$yd:00000BF7
.text$yd:00000BF8 ; ===========================================================================
.text$yd:00000BF8
.text$yd:00000BF8 ; Segment type: Pure code
.text$yd:00000BF8 ; Segment permissions: Read/Execute
.text$yd:00000BF8 _text$yd        segment para public 'CODE' use32
.text$yd:00000BF8                 assume cs:_text$yd
.text$yd:00000BF8                 ;org 0BF8h
.text$yd:00000BF8 ; COMDAT (pick any)
.text$yd:00000BF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000BF8
.text$yd:00000BF8 ; =============== S U B R O U T I N E =======================================
.text$yd:00000BF8
.text$yd:00000BF8 ; Attributes: bp-based frame
.text$yd:00000BF8
.text$yd:00000BF8 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00000BF8 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00000BF8                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00000BF8                 push    ebp
.text$yd:00000BF9                 mov     ebp, esp
.text$yd:00000BFB                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00000C00                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00000C05                 pop     ebp
.text$yd:00000C06                 retn
.text$yd:00000C06 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00000C06
.text$yd:00000C06 ; ---------------------------------------------------------------------------
.text$yd:00000C07                 align 4
.text$yd:00000C07 _text$yd        ends
.text$yd:00000C07
.text$mn:00000C08 ; ===========================================================================
.text$mn:00000C08
.text$mn:00000C08 ; Segment type: Pure code
.text$mn:00000C08 ; Segment permissions: Read/Execute
.text$mn:00000C08 _text$mn        segment para public 'CODE' use32
.text$mn:00000C08                 assume cs:_text$mn
.text$mn:00000C08                 ;org 0C08h
.text$mn:00000C08 ; COMDAT (pick any)
.text$mn:00000C08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C08
.text$mn:00000C08 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C08
.text$mn:00000C08 ; Attributes: bp-based frame
.text$mn:00000C08
.text$mn:00000C08 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000C08                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00000C08 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00000C08                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00000C08
.text$mn:00000C08 var_10          = byte ptr -10h
.text$mn:00000C08 var_8           = dword ptr -8
.text$mn:00000C08 var_1           = byte ptr -1
.text$mn:00000C08
.text$mn:00000C08                 push    ebp
.text$mn:00000C09                 mov     ebp, esp
.text$mn:00000C0B                 sub     esp, 10h
.text$mn:00000C0E                 mov     [ebp+var_8], ecx
.text$mn:00000C11                 lea     ecx, [ebp+var_1]
.text$mn:00000C14                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00000C19                 push    1
.text$mn:00000C1B                 lea     ecx, [ebp+var_1]
.text$mn:00000C1E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00000C23                 mov     ecx, [ebp+var_8]
.text$mn:00000C26                 mov     [ecx], eax
.text$mn:00000C28                 lea     ecx, [ebp+var_10] ; this
.text$mn:00000C2B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00000C30                 push    eax             ; int
.text$mn:00000C31                 mov     edx, [ebp+var_8]
.text$mn:00000C34                 mov     eax, [edx]
.text$mn:00000C36                 push    eax             ; void *
.text$mn:00000C37                 lea     ecx, [ebp+var_1]
.text$mn:00000C3A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00000C3F                 mov     ecx, [ebp+var_8]
.text$mn:00000C42                 mov     edx, [ecx]
.text$mn:00000C44                 mov     eax, [ebp+var_8]
.text$mn:00000C47                 mov     [edx], eax
.text$mn:00000C49                 mov     esp, ebp
.text$mn:00000C4B                 pop     ebp
.text$mn:00000C4C                 retn
.text$mn:00000C4C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00000C4C
.text$mn:00000C4C ; ---------------------------------------------------------------------------
.text$mn:00000C4D                 align 10h
.text$mn:00000C4D _text$mn        ends
.text$mn:00000C4D
.text$mn:00000C50 ; ===========================================================================
.text$mn:00000C50
.text$mn:00000C50 ; Segment type: Pure code
.text$mn:00000C50 ; Segment permissions: Read/Execute
.text$mn:00000C50 _text$mn        segment para public 'CODE' use32
.text$mn:00000C50                 assume cs:_text$mn
.text$mn:00000C50                 ;org 0C50h
.text$mn:00000C50 ; COMDAT (pick any)
.text$mn:00000C50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C50
.text$mn:00000C50 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C50
.text$mn:00000C50 ; Attributes: bp-based frame
.text$mn:00000C50
.text$mn:00000C50 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00000C50                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000C50 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00000C50                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00000C50
.text$mn:00000C50 var_20          = dword ptr -20h
.text$mn:00000C50 var_1C          = dword ptr -1Ch
.text$mn:00000C50 var_18          = dword ptr -18h
.text$mn:00000C50 var_11          = byte ptr -11h
.text$mn:00000C50 var_10          = dword ptr -10h
.text$mn:00000C50 var_C           = byte ptr -0Ch
.text$mn:00000C50 var_4           = dword ptr -4
.text$mn:00000C50 arg_0           = dword ptr  8
.text$mn:00000C50
.text$mn:00000C50 ; FUNCTION CHUNK AT .text$mn:00000D72 SIZE 00000009 BYTES
.text$mn:00000C50
.text$mn:00000C50                 push    ebp
.text$mn:00000C51                 mov     ebp, esp
.text$mn:00000C53                 push    0FFFFFFFFh
.text$mn:00000C55                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000C5A                 mov     eax, large fs:0
.text$mn:00000C60                 push    eax
.text$mn:00000C61                 push    ecx
.text$mn:00000C62                 sub     esp, 10h
.text$mn:00000C65                 push    ebx
.text$mn:00000C66                 push    esi
.text$mn:00000C67                 push    edi
.text$mn:00000C68                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C6D                 xor     eax, ebp
.text$mn:00000C6F                 push    eax
.text$mn:00000C70                 lea     eax, [ebp+var_C]
.text$mn:00000C73                 mov     large fs:0, eax
.text$mn:00000C79                 mov     [ebp+var_10], esp
.text$mn:00000C7C                 mov     [ebp+var_18], ecx
.text$mn:00000C7F                 mov     eax, [ebp+arg_0]
.text$mn:00000C82                 or      eax, 0Fh
.text$mn:00000C85                 mov     [ebp+var_1C], eax
.text$mn:00000C88                 mov     ecx, [ebp+var_18]
.text$mn:00000C8B                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000C90                 cmp     eax, [ebp+var_1C]
.text$mn:00000C93                 jnb     short loc_C9D
.text$mn:00000C95                 mov     ecx, [ebp+arg_0]
.text$mn:00000C98                 mov     [ebp+var_1C], ecx
.text$mn:00000C9B                 jmp     short loc_CEF
.text$mn:00000C9D ; ---------------------------------------------------------------------------
.text$mn:00000C9D
.text$mn:00000C9D loc_C9D:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00000C9D                 mov     edx, [ebp+var_18]
.text$mn:00000CA0                 mov     ecx, [edx+18h]
.text$mn:00000CA3                 shr     ecx, 1
.text$mn:00000CA5                 mov     eax, [ebp+var_1C]
.text$mn:00000CA8                 xor     edx, edx
.text$mn:00000CAA                 mov     esi, 3
.text$mn:00000CAF                 div     esi
.text$mn:00000CB1                 cmp     ecx, eax
.text$mn:00000CB3                 ja      short loc_CB7
.text$mn:00000CB5                 jmp     short loc_CEF
.text$mn:00000CB7 ; ---------------------------------------------------------------------------
.text$mn:00000CB7
.text$mn:00000CB7 loc_CB7:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00000CB7                 mov     ecx, [ebp+var_18]
.text$mn:00000CBA                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000CBF                 mov     edx, [ebp+var_18]
.text$mn:00000CC2                 mov     ecx, [edx+18h]
.text$mn:00000CC5                 shr     ecx, 1
.text$mn:00000CC7                 sub     eax, ecx
.text$mn:00000CC9                 mov     edx, [ebp+var_18]
.text$mn:00000CCC                 cmp     [edx+18h], eax
.text$mn:00000CCF                 ja      short loc_CE4
.text$mn:00000CD1                 mov     eax, [ebp+var_18]
.text$mn:00000CD4                 mov     ecx, [eax+18h]
.text$mn:00000CD7                 shr     ecx, 1
.text$mn:00000CD9                 mov     edx, [ebp+var_18]
.text$mn:00000CDC                 add     ecx, [edx+18h]
.text$mn:00000CDF                 mov     [ebp+var_1C], ecx
.text$mn:00000CE2                 jmp     short loc_CEF
.text$mn:00000CE4 ; ---------------------------------------------------------------------------
.text$mn:00000CE4
.text$mn:00000CE4 loc_CE4:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00000CE4                 mov     ecx, [ebp+var_18]
.text$mn:00000CE7                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000CEC                 mov     [ebp+var_1C], eax
.text$mn:00000CEF
.text$mn:00000CEF loc_CEF:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00000CEF                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00000CEF                 mov     [ebp+var_4], 0
.text$mn:00000CF6                 mov     eax, [ebp+var_1C]
.text$mn:00000CF9                 add     eax, 1
.text$mn:00000CFC                 push    eax
.text$mn:00000CFD                 lea     ecx, [ebp+var_11]
.text$mn:00000D00                 push    ecx
.text$mn:00000D01                 mov     ecx, [ebp+var_18]
.text$mn:00000D04                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000D09                 mov     ecx, eax
.text$mn:00000D0B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00000D10                 mov     [ebp+var_20], eax
.text$mn:00000D13                 jmp     short loc_D72
.text$mn:00000D13 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00000D13
.text$mn:00000D15
.text$mn:00000D15 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D15
.text$mn:00000D15
.text$mn:00000D15 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00000D15                                         ; DATA XREF: .xdata$x:00001AF8o
.text$mn:00000D15
.text$mn:00000D15 ; FUNCTION CHUNK AT .text$mn:00000D5C SIZE 00000009 BYTES
.text$mn:00000D15 ; FUNCTION CHUNK AT .text$mn:00000D6C SIZE 00000006 BYTES
.text$mn:00000D15
.text$mn:00000D15                 mov     [ebp-10h], esp
.text$mn:00000D18                 mov     edx, [ebp+8]
.text$mn:00000D1B                 mov     [ebp-1Ch], edx
.text$mn:00000D1E                 mov     byte ptr [ebp-4], 2
.text$mn:00000D22                 mov     eax, [ebp-1Ch]
.text$mn:00000D25                 add     eax, 1
.text$mn:00000D28                 push    eax
.text$mn:00000D29                 lea     ecx, [ebp-12h]
.text$mn:00000D2C                 push    ecx
.text$mn:00000D2D                 mov     ecx, [ebp-18h]
.text$mn:00000D30                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000D35                 mov     ecx, eax
.text$mn:00000D37                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00000D3C                 mov     [ebp-20h], eax
.text$mn:00000D3F                 jmp     short loc_D5C
.text$mn:00000D3F __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00000D3F
.text$mn:00000D41
.text$mn:00000D41 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D41
.text$mn:00000D41 ; Attributes: noreturn
.text$mn:00000D41
.text$mn:00000D41 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00000D41                                         ; DATA XREF: .xdata$x:00001B08o
.text$mn:00000D41                 push    0               ; Size
.text$mn:00000D43                 push    1               ; char
.text$mn:00000D45                 mov     ecx, [ebp-18h]
.text$mn:00000D48                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000D4D                 push    0
.text$mn:00000D4F                 push    0
.text$mn:00000D51                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000D51 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00000D51
.text$mn:00000D56 ; ---------------------------------------------------------------------------
.text$mn:00000D56                 mov     eax, offset $LN17
.text$mn:00000D5B                 retn
.text$mn:00000D5C ; ---------------------------------------------------------------------------
.text$mn:00000D5C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000D5C
.text$mn:00000D5C loc_D5C:                                ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00000D5C                 mov     dword ptr [ebp-4], 1
.text$mn:00000D63                 jmp     short loc_D6C
.text$mn:00000D63 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000D65
.text$mn:00000D65 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D65
.text$mn:00000D65
.text$mn:00000D65 $LN17           proc near               ; DATA XREF: .text$mn:00000D56o
.text$mn:00000D65                 mov     dword ptr [ebp-4], 1
.text$mn:00000D65 $LN17           endp ; sp-analysis failed
.text$mn:00000D65
.text$mn:00000D6C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000D6C
.text$mn:00000D6C loc_D6C:                                ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00000D6C                 mov     eax, offset $LN19
.text$mn:00000D71                 retn
.text$mn:00000D71 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000D72 ; ---------------------------------------------------------------------------
.text$mn:00000D72 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000D72
.text$mn:00000D72 loc_D72:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00000D72                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D79                 jmp     short loc_D82
.text$mn:00000D79 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000D7B
.text$mn:00000D7B ; =============== S U B R O U T I N E =======================================
.text$mn:00000D7B
.text$mn:00000D7B
.text$mn:00000D7B $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_D6Co
.text$mn:00000D7B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00000D82
.text$mn:00000D82 loc_D82:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00000D82                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00000D86                 jbe     short loc_DA1
.text$mn:00000D88                 mov     edx, [ebp+0Ch]
.text$mn:00000D8B                 push    edx             ; Size
.text$mn:00000D8C                 mov     ecx, [ebp-18h]
.text$mn:00000D8F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000D94                 push    eax             ; Src
.text$mn:00000D95                 mov     eax, [ebp-20h]
.text$mn:00000D98                 push    eax             ; Dst
.text$mn:00000D99                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00000D9E                 add     esp, 0Ch
.text$mn:00000DA1
.text$mn:00000DA1 loc_DA1:                                ; CODE XREF: $LN19+Bj
.text$mn:00000DA1                 push    0               ; Size
.text$mn:00000DA3                 push    1               ; char
.text$mn:00000DA5                 mov     ecx, [ebp-18h]
.text$mn:00000DA8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000DAD                 lea     ecx, [ebp-20h]
.text$mn:00000DB0                 push    ecx             ; int
.text$mn:00000DB1                 mov     edx, [ebp-18h]
.text$mn:00000DB4                 add     edx, 4
.text$mn:00000DB7                 push    edx             ; void *
.text$mn:00000DB8                 lea     eax, [ebp-13h]
.text$mn:00000DBB                 push    eax
.text$mn:00000DBC                 mov     ecx, [ebp-18h]
.text$mn:00000DBF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000DC4                 mov     ecx, eax
.text$mn:00000DC6                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000DCB                 mov     ecx, [ebp-18h]
.text$mn:00000DCE                 mov     edx, [ebp-1Ch]
.text$mn:00000DD1                 mov     [ecx+18h], edx
.text$mn:00000DD4                 mov     eax, [ebp+0Ch]
.text$mn:00000DD7                 push    eax
.text$mn:00000DD8                 mov     ecx, [ebp-18h]
.text$mn:00000DDB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00000DE0                 mov     ecx, [ebp-0Ch]
.text$mn:00000DE3                 mov     large fs:0, ecx
.text$mn:00000DEA                 pop     ecx
.text$mn:00000DEB                 pop     edi
.text$mn:00000DEC                 pop     esi
.text$mn:00000DED                 pop     ebx
.text$mn:00000DEE                 mov     esp, ebp
.text$mn:00000DF0                 pop     ebp
.text$mn:00000DF1                 retn    8
.text$mn:00000DF1 $LN19           endp ; sp-analysis failed
.text$mn:00000DF1
.text$mn:00000DF1 _text$mn        ends
.text$mn:00000DF1
.text$x:00000DF4 ; ===========================================================================
.text$x:00000DF4
.text$x:00000DF4 ; Segment type: Pure code
.text$x:00000DF4 ; Segment permissions: Read/Execute
.text$x:00000DF4 _text$x         segment para public 'CODE' use32
.text$x:00000DF4                 assume cs:_text$x
.text$x:00000DF4                 ;org 0DF4h
.text$x:00000DF4 ; COMDAT (pick associative to section at C50)
.text$x:00000DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000DF4
.text$x:00000DF4 ; =============== S U B R O U T I N E =======================================
.text$x:00000DF4
.text$x:00000DF4
.text$x:00000DF4 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00000DF4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00000DF4
.text$x:00000DF4 arg_4           = dword ptr  8
.text$x:00000DF4
.text$x:00000DF4                 mov     edx, [esp+arg_4]
.text$x:00000DF8                 lea     eax, [edx+0Ch]
.text$x:00000DFB                 mov     ecx, [edx-24h]
.text$x:00000DFE                 xor     ecx, eax
.text$x:00000E00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E05                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00000E0A                 jmp     ___CxxFrameHandler3
.text$x:00000E0A __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00000E0A
.text$x:00000E0A ; ---------------------------------------------------------------------------
.text$x:00000E0F                 align 10h
.text$x:00000E0F _text$x         ends
.text$x:00000E0F
.text$mn:00000E10 ; ===========================================================================
.text$mn:00000E10
.text$mn:00000E10 ; Segment type: Pure code
.text$mn:00000E10 ; Segment permissions: Read/Execute
.text$mn:00000E10 _text$mn        segment para public 'CODE' use32
.text$mn:00000E10                 assume cs:_text$mn
.text$mn:00000E10                 ;org 0E10h
.text$mn:00000E10 ; COMDAT (pick any)
.text$mn:00000E10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E10
.text$mn:00000E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E10
.text$mn:00000E10 ; Attributes: bp-based frame
.text$mn:00000E10
.text$mn:00000E10 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00000E10                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00000E10 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00000E10                                         ; CODE XREF: $LN19+60p
.text$mn:00000E10                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00000E10
.text$mn:00000E10 var_8           = dword ptr -8
.text$mn:00000E10 var_1           = byte ptr -1
.text$mn:00000E10 arg_0           = dword ptr  8
.text$mn:00000E10
.text$mn:00000E10                 push    ebp
.text$mn:00000E11                 mov     ebp, esp
.text$mn:00000E13                 sub     esp, 8
.text$mn:00000E16                 mov     [ebp+var_8], ecx
.text$mn:00000E19                 mov     [ebp+var_1], 0
.text$mn:00000E1D                 mov     eax, [ebp+var_8]
.text$mn:00000E20                 mov     ecx, [ebp+arg_0]
.text$mn:00000E23                 mov     [eax+14h], ecx
.text$mn:00000E26                 lea     edx, [ebp+var_1]
.text$mn:00000E29                 push    edx
.text$mn:00000E2A                 mov     ecx, [ebp+var_8]
.text$mn:00000E2D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000E32                 add     eax, [ebp+arg_0]
.text$mn:00000E35                 push    eax
.text$mn:00000E36                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00000E3B                 add     esp, 8
.text$mn:00000E3E                 mov     esp, ebp
.text$mn:00000E40                 pop     ebp
.text$mn:00000E41                 retn    4
.text$mn:00000E41 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00000E41
.text$mn:00000E41 _text$mn        ends
.text$mn:00000E41
.text$mn:00000E44 ; ===========================================================================
.text$mn:00000E44
.text$mn:00000E44 ; Segment type: Pure code
.text$mn:00000E44 ; Segment permissions: Read/Execute
.text$mn:00000E44 _text$mn        segment para public 'CODE' use32
.text$mn:00000E44                 assume cs:_text$mn
.text$mn:00000E44                 ;org 0E44h
.text$mn:00000E44 ; COMDAT (pick any)
.text$mn:00000E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E44
.text$mn:00000E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E44
.text$mn:00000E44 ; Attributes: bp-based frame
.text$mn:00000E44
.text$mn:00000E44 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000E44                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00000E44 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00000E44                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00000E44
.text$mn:00000E44 var_8           = dword ptr -8
.text$mn:00000E44 var_1           = byte ptr -1
.text$mn:00000E44
.text$mn:00000E44                 push    ebp
.text$mn:00000E45                 mov     ebp, esp
.text$mn:00000E47                 sub     esp, 8
.text$mn:00000E4A                 mov     [ebp+var_8], ecx
.text$mn:00000E4D                 lea     ecx, [ebp+var_1]
.text$mn:00000E50                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00000E55                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000E58                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000E5D                 mov     eax, [ebp+var_8]
.text$mn:00000E60                 mov     ecx, [eax]
.text$mn:00000E62                 push    ecx
.text$mn:00000E63                 lea     ecx, [ebp+var_1]
.text$mn:00000E66                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00000E6B                 push    1               ; int
.text$mn:00000E6D                 mov     edx, [ebp+var_8]
.text$mn:00000E70                 mov     eax, [edx]
.text$mn:00000E72                 push    eax             ; void *
.text$mn:00000E73                 lea     ecx, [ebp+var_1]
.text$mn:00000E76                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00000E7B                 mov     ecx, [ebp+var_8]
.text$mn:00000E7E                 mov     dword ptr [ecx], 0
.text$mn:00000E84                 mov     esp, ebp
.text$mn:00000E86                 pop     ebp
.text$mn:00000E87                 retn
.text$mn:00000E87 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00000E87
.text$mn:00000E87 _text$mn        ends
.text$mn:00000E87
.text$mn:00000E88 ; ===========================================================================
.text$mn:00000E88
.text$mn:00000E88 ; Segment type: Pure code
.text$mn:00000E88 ; Segment permissions: Read/Execute
.text$mn:00000E88 _text$mn        segment para public 'CODE' use32
.text$mn:00000E88                 assume cs:_text$mn
.text$mn:00000E88                 ;org 0E88h
.text$mn:00000E88 ; COMDAT (pick any)
.text$mn:00000E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E88
.text$mn:00000E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E88
.text$mn:00000E88 ; Attributes: bp-based frame
.text$mn:00000E88
.text$mn:00000E88 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00000E88                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00000E88 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00000E88                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00000E88                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00000E88
.text$mn:00000E88 var_4           = dword ptr -4
.text$mn:00000E88 arg_0           = dword ptr  8
.text$mn:00000E88
.text$mn:00000E88                 push    ebp
.text$mn:00000E89                 mov     ebp, esp
.text$mn:00000E8B                 push    ecx
.text$mn:00000E8C                 mov     [ebp+var_4], ecx
.text$mn:00000E8F                 mov     ecx, [ebp+arg_0]
.text$mn:00000E92                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00000E97                 mov     eax, [ebp+arg_0]
.text$mn:00000E9A                 mov     esp, ebp
.text$mn:00000E9C                 pop     ebp
.text$mn:00000E9D                 retn    4
.text$mn:00000E9D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00000E9D
.text$mn:00000E9D _text$mn        ends
.text$mn:00000E9D
.text$mn:00000EA0 ; ===========================================================================
.text$mn:00000EA0
.text$mn:00000EA0 ; Segment type: Pure code
.text$mn:00000EA0 ; Segment permissions: Read/Execute
.text$mn:00000EA0 _text$mn        segment para public 'CODE' use32
.text$mn:00000EA0                 assume cs:_text$mn
.text$mn:00000EA0                 ;org 0EA0h
.text$mn:00000EA0 ; COMDAT (pick any)
.text$mn:00000EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000EA0
.text$mn:00000EA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EA0
.text$mn:00000EA0 ; Attributes: bp-based frame
.text$mn:00000EA0
.text$mn:00000EA0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00000EA0                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00000EA0 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00000EA0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00000EA0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00000EA0
.text$mn:00000EA0 var_C           = dword ptr -0Ch
.text$mn:00000EA0 Size            = dword ptr -8
.text$mn:00000EA0 var_4           = dword ptr -4
.text$mn:00000EA0 arg_0           = dword ptr  8
.text$mn:00000EA0 arg_4           = byte ptr  0Ch
.text$mn:00000EA0
.text$mn:00000EA0                 push    ebp
.text$mn:00000EA1                 mov     ebp, esp
.text$mn:00000EA3                 sub     esp, 0Ch
.text$mn:00000EA6                 mov     [ebp+var_4], ecx
.text$mn:00000EA9                 mov     ecx, [ebp+var_4]
.text$mn:00000EAC                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000EB1                 cmp     eax, [ebp+arg_0]
.text$mn:00000EB4                 jnb     short loc_EBE
.text$mn:00000EB6                 mov     ecx, [ebp+var_4]
.text$mn:00000EB9                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00000EBE
.text$mn:00000EBE loc_EBE:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00000EBE                 mov     eax, [ebp+var_4]
.text$mn:00000EC1                 mov     ecx, [eax+18h]
.text$mn:00000EC4                 cmp     ecx, [ebp+arg_0]
.text$mn:00000EC7                 jnb     short loc_EDE
.text$mn:00000EC9                 mov     edx, [ebp+var_4]
.text$mn:00000ECC                 mov     eax, [edx+14h]
.text$mn:00000ECF                 push    eax
.text$mn:00000ED0                 mov     ecx, [ebp+arg_0]
.text$mn:00000ED3                 push    ecx
.text$mn:00000ED4                 mov     ecx, [ebp+var_4]
.text$mn:00000ED7                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00000EDC                 jmp     short loc_F28
.text$mn:00000EDE ; ---------------------------------------------------------------------------
.text$mn:00000EDE
.text$mn:00000EDE loc_EDE:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00000EDE                 movzx   edx, [ebp+arg_4]
.text$mn:00000EE2                 test    edx, edx
.text$mn:00000EE4                 jz      short loc_F18
.text$mn:00000EE6                 cmp     [ebp+arg_0], 10h
.text$mn:00000EEA                 jnb     short loc_F18
.text$mn:00000EEC                 mov     eax, [ebp+var_4]
.text$mn:00000EEF                 mov     ecx, [ebp+arg_0]
.text$mn:00000EF2                 cmp     ecx, [eax+14h]
.text$mn:00000EF5                 jnb     short loc_EFF
.text$mn:00000EF7                 mov     edx, [ebp+arg_0]
.text$mn:00000EFA                 mov     [ebp+Size], edx
.text$mn:00000EFD                 jmp     short loc_F08
.text$mn:00000EFF ; ---------------------------------------------------------------------------
.text$mn:00000EFF
.text$mn:00000EFF loc_EFF:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00000EFF                 mov     eax, [ebp+var_4]
.text$mn:00000F02                 mov     ecx, [eax+14h]
.text$mn:00000F05                 mov     [ebp+Size], ecx
.text$mn:00000F08
.text$mn:00000F08 loc_F08:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00000F08                 mov     edx, [ebp+Size]
.text$mn:00000F0B                 push    edx             ; Size
.text$mn:00000F0C                 push    1               ; char
.text$mn:00000F0E                 mov     ecx, [ebp+var_4]
.text$mn:00000F11                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000F16                 jmp     short loc_F28
.text$mn:00000F18 ; ---------------------------------------------------------------------------
.text$mn:00000F18
.text$mn:00000F18 loc_F18:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00000F18                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00000F18                 cmp     [ebp+arg_0], 0
.text$mn:00000F1C                 jnz     short loc_F28
.text$mn:00000F1E                 push    0
.text$mn:00000F20                 mov     ecx, [ebp+var_4]
.text$mn:00000F23                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00000F28
.text$mn:00000F28 loc_F28:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00000F28                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00000F28                 cmp     [ebp+arg_0], 0
.text$mn:00000F2C                 jbe     short loc_F37
.text$mn:00000F2E                 mov     [ebp+var_C], 1
.text$mn:00000F35                 jmp     short loc_F3E
.text$mn:00000F37 ; ---------------------------------------------------------------------------
.text$mn:00000F37
.text$mn:00000F37 loc_F37:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00000F37                 mov     [ebp+var_C], 0
.text$mn:00000F3E
.text$mn:00000F3E loc_F3E:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00000F3E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00000F41                 mov     esp, ebp
.text$mn:00000F43                 pop     ebp
.text$mn:00000F44                 retn    8
.text$mn:00000F44 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00000F44
.text$mn:00000F44 ; ---------------------------------------------------------------------------
.text$mn:00000F47                 align 4
.text$mn:00000F47 _text$mn        ends
.text$mn:00000F47
.text$mn:00000F48 ; ===========================================================================
.text$mn:00000F48
.text$mn:00000F48 ; Segment type: Pure code
.text$mn:00000F48 ; Segment permissions: Read/Execute
.text$mn:00000F48 _text$mn        segment para public 'CODE' use32
.text$mn:00000F48                 assume cs:_text$mn
.text$mn:00000F48                 ;org 0F48h
.text$mn:00000F48 ; COMDAT (pick any)
.text$mn:00000F48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F48
.text$mn:00000F48 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F48
.text$mn:00000F48 ; Attributes: bp-based frame
.text$mn:00000F48
.text$mn:00000F48 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00000F48                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00000F48 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00000F48                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00000F48
.text$mn:00000F48 var_4           = dword ptr -4
.text$mn:00000F48 arg_0           = dword ptr  8
.text$mn:00000F48
.text$mn:00000F48                 push    ebp
.text$mn:00000F49                 mov     ebp, esp
.text$mn:00000F4B                 push    ecx
.text$mn:00000F4C                 mov     [ebp+var_4], ecx
.text$mn:00000F4F                 cmp     [ebp+arg_0], 0
.text$mn:00000F53                 jz      short loc_F75
.text$mn:00000F55                 mov     ecx, [ebp+var_4]
.text$mn:00000F58                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000F5D                 cmp     [ebp+arg_0], eax
.text$mn:00000F60                 jb      short loc_F75
.text$mn:00000F62                 mov     ecx, [ebp+var_4]
.text$mn:00000F65                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000F6A                 mov     ecx, [ebp+var_4]
.text$mn:00000F6D                 add     eax, [ecx+14h]
.text$mn:00000F70                 cmp     eax, [ebp+arg_0]
.text$mn:00000F73                 ja      short loc_F7B
.text$mn:00000F75
.text$mn:00000F75 loc_F75:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00000F75                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00000F75                 xor     al, al
.text$mn:00000F77                 jmp     short loc_F7D
.text$mn:00000F79 ; ---------------------------------------------------------------------------
.text$mn:00000F79                 jmp     short loc_F7D
.text$mn:00000F7B ; ---------------------------------------------------------------------------
.text$mn:00000F7B
.text$mn:00000F7B loc_F7B:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00000F7B                 mov     al, 1
.text$mn:00000F7D
.text$mn:00000F7D loc_F7D:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00000F7D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00000F7D                 mov     esp, ebp
.text$mn:00000F7F                 pop     ebp
.text$mn:00000F80                 retn    4
.text$mn:00000F80 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00000F80
.text$mn:00000F80 ; ---------------------------------------------------------------------------
.text$mn:00000F83                 align 4
.text$mn:00000F83 _text$mn        ends
.text$mn:00000F83
.text$mn:00000F84 ; ===========================================================================
.text$mn:00000F84
.text$mn:00000F84 ; Segment type: Pure code
.text$mn:00000F84 ; Segment permissions: Read/Execute
.text$mn:00000F84 _text$mn        segment para public 'CODE' use32
.text$mn:00000F84                 assume cs:_text$mn
.text$mn:00000F84                 ;org 0F84h
.text$mn:00000F84 ; COMDAT (pick any)
.text$mn:00000F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F84
.text$mn:00000F84 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F84
.text$mn:00000F84 ; Attributes: bp-based frame
.text$mn:00000F84
.text$mn:00000F84 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000F84                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00000F84 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00000F84                                         ; CODE XREF: $LN19+14p
.text$mn:00000F84                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00000F84
.text$mn:00000F84 var_8           = dword ptr -8
.text$mn:00000F84 var_4           = dword ptr -4
.text$mn:00000F84
.text$mn:00000F84                 push    ebp
.text$mn:00000F85                 mov     ebp, esp
.text$mn:00000F87                 sub     esp, 8
.text$mn:00000F8A                 mov     [ebp+var_4], ecx
.text$mn:00000F8D                 mov     eax, [ebp+var_4]
.text$mn:00000F90                 cmp     dword ptr [eax+18h], 10h
.text$mn:00000F94                 jb      short loc_FAA
.text$mn:00000F96                 mov     ecx, [ebp+var_4]
.text$mn:00000F99                 mov     edx, [ecx+4]
.text$mn:00000F9C                 push    edx
.text$mn:00000F9D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00000FA2                 add     esp, 4
.text$mn:00000FA5                 mov     [ebp+var_8], eax
.text$mn:00000FA8                 jmp     short loc_FB3
.text$mn:00000FAA ; ---------------------------------------------------------------------------
.text$mn:00000FAA
.text$mn:00000FAA loc_FAA:                                ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00000FAA                 mov     eax, [ebp+var_4]
.text$mn:00000FAD                 add     eax, 4
.text$mn:00000FB0                 mov     [ebp+var_8], eax
.text$mn:00000FB3
.text$mn:00000FB3 loc_FB3:                                ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00000FB3                 mov     eax, [ebp+var_8]
.text$mn:00000FB6                 mov     esp, ebp
.text$mn:00000FB8                 pop     ebp
.text$mn:00000FB9                 retn
.text$mn:00000FB9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00000FB9
.text$mn:00000FB9 ; ---------------------------------------------------------------------------
.text$mn:00000FBA                 align 4
.text$mn:00000FBA _text$mn        ends
.text$mn:00000FBA
.text$mn:00000FBC ; ===========================================================================
.text$mn:00000FBC
.text$mn:00000FBC ; Segment type: Pure code
.text$mn:00000FBC ; Segment permissions: Read/Execute
.text$mn:00000FBC _text$mn        segment para public 'CODE' use32
.text$mn:00000FBC                 assume cs:_text$mn
.text$mn:00000FBC                 ;org 0FBCh
.text$mn:00000FBC ; COMDAT (pick any)
.text$mn:00000FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FBC
.text$mn:00000FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00000FBC
.text$mn:00000FBC ; Attributes: bp-based frame
.text$mn:00000FBC
.text$mn:00000FBC ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00000FBC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00000FBC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00000FBC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00000FBC
.text$mn:00000FBC var_8           = dword ptr -8
.text$mn:00000FBC var_4           = dword ptr -4
.text$mn:00000FBC
.text$mn:00000FBC                 push    ebp
.text$mn:00000FBD                 mov     ebp, esp
.text$mn:00000FBF                 sub     esp, 8
.text$mn:00000FC2                 mov     [ebp+var_4], ecx
.text$mn:00000FC5                 mov     eax, [ebp+var_4]
.text$mn:00000FC8                 cmp     dword ptr [eax+18h], 10h
.text$mn:00000FCC                 jb      short loc_FE2
.text$mn:00000FCE                 mov     ecx, [ebp+var_4]
.text$mn:00000FD1                 mov     edx, [ecx+4]
.text$mn:00000FD4                 push    edx
.text$mn:00000FD5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00000FDA                 add     esp, 4
.text$mn:00000FDD                 mov     [ebp+var_8], eax
.text$mn:00000FE0                 jmp     short loc_FEB
.text$mn:00000FE2 ; ---------------------------------------------------------------------------
.text$mn:00000FE2
.text$mn:00000FE2 loc_FE2:                                ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00000FE2                 mov     eax, [ebp+var_4]
.text$mn:00000FE5                 add     eax, 4
.text$mn:00000FE8                 mov     [ebp+var_8], eax
.text$mn:00000FEB
.text$mn:00000FEB loc_FEB:                                ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00000FEB                 mov     eax, [ebp+var_8]
.text$mn:00000FEE                 mov     esp, ebp
.text$mn:00000FF0                 pop     ebp
.text$mn:00000FF1                 retn
.text$mn:00000FF1 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00000FF1
.text$mn:00000FF1 ; ---------------------------------------------------------------------------
.text$mn:00000FF2                 align 4
.text$mn:00000FF2 _text$mn        ends
.text$mn:00000FF2
.text$mn:00000FF4 ; ===========================================================================
.text$mn:00000FF4
.text$mn:00000FF4 ; Segment type: Pure code
.text$mn:00000FF4 ; Segment permissions: Read/Execute
.text$mn:00000FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00000FF4                 assume cs:_text$mn
.text$mn:00000FF4                 ;org 0FF4h
.text$mn:00000FF4 ; COMDAT (pick any)
.text$mn:00000FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FF4
.text$mn:00000FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FF4
.text$mn:00000FF4 ; Attributes: bp-based frame
.text$mn:00000FF4
.text$mn:00000FF4 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00000FF4                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00000FF4 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00000FF4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap
.text$mn:00000FF4
.text$mn:00000FF4 var_8           = dword ptr -8
.text$mn:00000FF4 var_4           = dword ptr -4
.text$mn:00000FF4
.text$mn:00000FF4                 push    ebp
.text$mn:00000FF5                 mov     ebp, esp
.text$mn:00000FF7                 sub     esp, 8
.text$mn:00000FFA                 mov     [ebp+var_4], ecx
.text$mn:00000FFD                 mov     eax, [ebp+var_4]
.text$mn:00001000                 cmp     dword ptr [eax+18h], 8
.text$mn:00001004                 jb      short loc_101A
.text$mn:00001006                 mov     ecx, [ebp+var_4]
.text$mn:00001009                 mov     edx, [ecx+4]
.text$mn:0000100C                 push    edx
.text$mn:0000100D                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001012                 add     esp, 4
.text$mn:00001015                 mov     [ebp+var_8], eax
.text$mn:00001018                 jmp     short loc_1023
.text$mn:0000101A ; ---------------------------------------------------------------------------
.text$mn:0000101A
.text$mn:0000101A loc_101A:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000101A                 mov     eax, [ebp+var_4]
.text$mn:0000101D                 add     eax, 4
.text$mn:00001020                 mov     [ebp+var_8], eax
.text$mn:00001023
.text$mn:00001023 loc_1023:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00001023                 mov     eax, [ebp+var_8]
.text$mn:00001026                 mov     esp, ebp
.text$mn:00001028                 pop     ebp
.text$mn:00001029                 retn
.text$mn:00001029 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00001029
.text$mn:00001029 ; ---------------------------------------------------------------------------
.text$mn:0000102A                 align 4
.text$mn:0000102A _text$mn        ends
.text$mn:0000102A
.text$mn:0000102C ; ===========================================================================
.text$mn:0000102C
.text$mn:0000102C ; Segment type: Pure code
.text$mn:0000102C ; Segment permissions: Read/Execute
.text$mn:0000102C _text$mn        segment para public 'CODE' use32
.text$mn:0000102C                 assume cs:_text$mn
.text$mn:0000102C                 ;org 102Ch
.text$mn:0000102C ; COMDAT (pick any)
.text$mn:0000102C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000102C
.text$mn:0000102C ; =============== S U B R O U T I N E =======================================
.text$mn:0000102C
.text$mn:0000102C ; Attributes: bp-based frame
.text$mn:0000102C
.text$mn:0000102C ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:0000102C                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000102C ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:0000102C                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:0000102C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:0000102C
.text$mn:0000102C var_18          = byte ptr -18h
.text$mn:0000102C var_14          = dword ptr -14h
.text$mn:0000102C var_10          = dword ptr -10h
.text$mn:0000102C var_C           = dword ptr -0Ch
.text$mn:0000102C var_4           = dword ptr -4
.text$mn:0000102C
.text$mn:0000102C                 push    ebp
.text$mn:0000102D                 mov     ebp, esp
.text$mn:0000102F                 push    0FFFFFFFFh
.text$mn:00001031                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001036                 mov     eax, large fs:0
.text$mn:0000103C                 push    eax
.text$mn:0000103D                 sub     esp, 0Ch
.text$mn:00001040                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001045                 xor     eax, ebp
.text$mn:00001047                 push    eax
.text$mn:00001048                 lea     eax, [ebp+var_C]
.text$mn:0000104B                 mov     large fs:0, eax
.text$mn:00001051                 mov     [ebp+var_14], ecx
.text$mn:00001054                 mov     eax, [ebp+var_14]
.text$mn:00001057                 cmp     dword ptr [eax], 0
.text$mn:0000105A                 jz      short loc_10B7
.text$mn:0000105C                 push    3               ; int
.text$mn:0000105E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001061                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00001066                 mov     [ebp+var_4], 0
.text$mn:0000106D                 mov     ecx, [ebp+var_14]
.text$mn:00001070                 mov     edx, [ecx]
.text$mn:00001072                 add     edx, 4
.text$mn:00001075                 mov     [ebp+var_10], edx
.text$mn:00001078                 jmp     short loc_1087
.text$mn:0000107A ; ---------------------------------------------------------------------------
.text$mn:0000107A
.text$mn:0000107A loc_107A:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000107A                 mov     eax, [ebp+var_10]
.text$mn:0000107D                 mov     ecx, [eax]
.text$mn:0000107F                 mov     edx, [ebp+var_10]
.text$mn:00001082                 mov     eax, [ecx+4]
.text$mn:00001085                 mov     [edx], eax
.text$mn:00001087
.text$mn:00001087 loc_1087:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00001087                 mov     ecx, [ebp+var_10]
.text$mn:0000108A                 cmp     dword ptr [ecx], 0
.text$mn:0000108D                 jz      short loc_109C
.text$mn:0000108F                 mov     edx, [ebp+var_10]
.text$mn:00001092                 mov     eax, [edx]
.text$mn:00001094                 mov     dword ptr [eax], 0
.text$mn:0000109A                 jmp     short loc_107A
.text$mn:0000109C ; ---------------------------------------------------------------------------
.text$mn:0000109C
.text$mn:0000109C loc_109C:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000109C                 mov     ecx, [ebp+var_14]
.text$mn:0000109F                 mov     edx, [ecx]
.text$mn:000010A1                 mov     dword ptr [edx+4], 0
.text$mn:000010A8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000010AF                 lea     ecx, [ebp+var_18] ; this
.text$mn:000010B2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000010B7
.text$mn:000010B7 loc_10B7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000010B7                 mov     ecx, [ebp+var_C]
.text$mn:000010BA                 mov     large fs:0, ecx
.text$mn:000010C1                 pop     ecx
.text$mn:000010C2                 mov     esp, ebp
.text$mn:000010C4                 pop     ebp
.text$mn:000010C5                 retn
.text$mn:000010C5 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000010C5
.text$mn:000010C5 ; ---------------------------------------------------------------------------
.text$mn:000010C6                 align 4
.text$mn:000010C6 _text$mn        ends
.text$mn:000010C6
.text$x:000010C8 ; ===========================================================================
.text$x:000010C8
.text$x:000010C8 ; Segment type: Pure code
.text$x:000010C8 ; Segment permissions: Read/Execute
.text$x:000010C8 _text$x         segment para public 'CODE' use32
.text$x:000010C8                 assume cs:_text$x
.text$x:000010C8                 ;org 10C8h
.text$x:000010C8 ; COMDAT (pick associative to section at 102C)
.text$x:000010C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000010C8
.text$x:000010C8 ; =============== S U B R O U T I N E =======================================
.text$x:000010C8
.text$x:000010C8
.text$x:000010C8 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000010C8                                         ; DATA XREF: .xdata$x:000019BCo
.text$x:000010C8                 lea     ecx, [ebp-18h]  ; this
.text$x:000010CB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000010CB __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000010CB
.text$x:000010D0
.text$x:000010D0 ; =============== S U B R O U T I N E =======================================
.text$x:000010D0
.text$x:000010D0
.text$x:000010D0 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000010D0                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000010D0
.text$x:000010D0 arg_4           = dword ptr  8
.text$x:000010D0
.text$x:000010D0                 mov     edx, [esp+arg_4]
.text$x:000010D4                 lea     eax, [edx+0Ch]
.text$x:000010D7                 mov     ecx, [edx-10h]
.text$x:000010DA                 xor     ecx, eax
.text$x:000010DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000010E1                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000010E6                 jmp     ___CxxFrameHandler3
.text$x:000010E6 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000010E6
.text$x:000010E6 ; ---------------------------------------------------------------------------
.text$x:000010EB                 align 4
.text$x:000010EB _text$x         ends
.text$x:000010EB
.text$mn:000010EC ; ===========================================================================
.text$mn:000010EC
.text$mn:000010EC ; Segment type: Pure code
.text$mn:000010EC ; Segment permissions: Read/Execute
.text$mn:000010EC _text$mn        segment para public 'CODE' use32
.text$mn:000010EC                 assume cs:_text$mn
.text$mn:000010EC                 ;org 10ECh
.text$mn:000010EC ; COMDAT (pick any)
.text$mn:000010EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010EC
.text$mn:000010EC ; =============== S U B R O U T I N E =======================================
.text$mn:000010EC
.text$mn:000010EC ; Attributes: bp-based frame
.text$mn:000010EC
.text$mn:000010EC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000010EC                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000010EC ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000010EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000010EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000010EC
.text$mn:000010EC var_C           = dword ptr -0Ch
.text$mn:000010EC var_8           = dword ptr -8
.text$mn:000010EC var_2           = byte ptr -2
.text$mn:000010EC var_1           = byte ptr -1
.text$mn:000010EC arg_0           = byte ptr  8
.text$mn:000010EC Size            = dword ptr  0Ch
.text$mn:000010EC
.text$mn:000010EC                 push    ebp
.text$mn:000010ED                 mov     ebp, esp
.text$mn:000010EF                 sub     esp, 0Ch
.text$mn:000010F2                 mov     [ebp+var_8], ecx
.text$mn:000010F5                 movzx   eax, [ebp+arg_0]
.text$mn:000010F9                 test    eax, eax
.text$mn:000010FB                 jnz     short loc_10FF
.text$mn:000010FD                 jmp     short loc_1172
.text$mn:000010FF ; ---------------------------------------------------------------------------
.text$mn:000010FF
.text$mn:000010FF loc_10FF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:000010FF                 mov     ecx, [ebp+var_8]
.text$mn:00001102                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001106                 jb      short loc_1172
.text$mn:00001108                 mov     edx, [ebp+var_8]
.text$mn:0000110B                 mov     eax, [edx+4]
.text$mn:0000110E                 mov     [ebp+var_C], eax
.text$mn:00001111                 mov     ecx, [ebp+var_8]
.text$mn:00001114                 add     ecx, 4
.text$mn:00001117                 push    ecx
.text$mn:00001118                 lea     edx, [ebp+var_1]
.text$mn:0000111B                 push    edx
.text$mn:0000111C                 mov     ecx, [ebp+var_8]
.text$mn:0000111F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001124                 mov     ecx, eax
.text$mn:00001126                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000112B                 cmp     [ebp+Size], 0
.text$mn:0000112F                 jbe     short loc_1151
.text$mn:00001131                 mov     eax, [ebp+Size]
.text$mn:00001134                 push    eax             ; Size
.text$mn:00001135                 mov     ecx, [ebp+var_C]
.text$mn:00001138                 push    ecx
.text$mn:00001139                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000113E                 add     esp, 4
.text$mn:00001141                 push    eax             ; Src
.text$mn:00001142                 mov     edx, [ebp+var_8]
.text$mn:00001145                 add     edx, 4
.text$mn:00001148                 push    edx             ; Dst
.text$mn:00001149                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000114E                 add     esp, 0Ch
.text$mn:00001151
.text$mn:00001151 loc_1151:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001151                 mov     eax, [ebp+var_8]
.text$mn:00001154                 mov     ecx, [eax+18h]
.text$mn:00001157                 add     ecx, 1
.text$mn:0000115A                 push    ecx             ; int
.text$mn:0000115B                 mov     edx, [ebp+var_C]
.text$mn:0000115E                 push    edx             ; void *
.text$mn:0000115F                 lea     eax, [ebp+var_2]
.text$mn:00001162                 push    eax
.text$mn:00001163                 mov     ecx, [ebp+var_8]
.text$mn:00001166                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000116B                 mov     ecx, eax
.text$mn:0000116D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00001172
.text$mn:00001172 loc_1172:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00001172                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00001172                 mov     ecx, [ebp+var_8]
.text$mn:00001175                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:0000117C                 mov     edx, [ebp+Size]
.text$mn:0000117F                 push    edx
.text$mn:00001180                 mov     ecx, [ebp+var_8]
.text$mn:00001183                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001188                 mov     esp, ebp
.text$mn:0000118A                 pop     ebp
.text$mn:0000118B                 retn    8
.text$mn:0000118B ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000118B
.text$mn:0000118B ; ---------------------------------------------------------------------------
.text$mn:0000118E                 align 10h
.text$mn:0000118E _text$mn        ends
.text$mn:0000118E
.text$mn:00001190 ; ===========================================================================
.text$mn:00001190
.text$mn:00001190 ; Segment type: Pure code
.text$mn:00001190 ; Segment permissions: Read/Execute
.text$mn:00001190 _text$mn        segment para public 'CODE' use32
.text$mn:00001190                 assume cs:_text$mn
.text$mn:00001190                 ;org 1190h
.text$mn:00001190 ; COMDAT (pick any)
.text$mn:00001190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001190
.text$mn:00001190 ; =============== S U B R O U T I N E =======================================
.text$mn:00001190
.text$mn:00001190 ; Attributes: bp-based frame
.text$mn:00001190
.text$mn:00001190 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00001190                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001190 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001190                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00001190
.text$mn:00001190 var_4           = dword ptr -4
.text$mn:00001190
.text$mn:00001190                 push    ebp
.text$mn:00001191                 mov     ebp, esp
.text$mn:00001193                 push    ecx
.text$mn:00001194                 mov     [ebp+var_4], ecx
.text$mn:00001197                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000119C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000011A1                 mov     esp, ebp
.text$mn:000011A3                 pop     ebp
.text$mn:000011A4                 retn
.text$mn:000011A4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000011A4
.text$mn:000011A4 ; ---------------------------------------------------------------------------
.text$mn:000011A5                 align 4
.text$mn:000011A5 _text$mn        ends
.text$mn:000011A5
.text$mn:000011A8 ; ===========================================================================
.text$mn:000011A8
.text$mn:000011A8 ; Segment type: Pure code
.text$mn:000011A8 ; Segment permissions: Read/Execute
.text$mn:000011A8 _text$mn        segment para public 'CODE' use32
.text$mn:000011A8                 assume cs:_text$mn
.text$mn:000011A8                 ;org 11A8h
.text$mn:000011A8 ; COMDAT (pick any)
.text$mn:000011A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011A8
.text$mn:000011A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000011A8
.text$mn:000011A8 ; Attributes: bp-based frame
.text$mn:000011A8
.text$mn:000011A8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000011A8                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000011A8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000011A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000011A8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000011A8
.text$mn:000011A8 var_4           = dword ptr -4
.text$mn:000011A8
.text$mn:000011A8                 push    ebp
.text$mn:000011A9                 mov     ebp, esp
.text$mn:000011AB                 push    ecx
.text$mn:000011AC                 mov     [ebp+var_4], ecx
.text$mn:000011AF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000011B4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000011B9                 mov     esp, ebp
.text$mn:000011BB                 pop     ebp
.text$mn:000011BC                 retn
.text$mn:000011BC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000011BC
.text$mn:000011BC ; ---------------------------------------------------------------------------
.text$mn:000011BD                 align 10h
.text$mn:000011BD _text$mn        ends
.text$mn:000011BD
.text$mn:000011C0 ; ===========================================================================
.text$mn:000011C0
.text$mn:000011C0 ; Segment type: Pure code
.text$mn:000011C0 ; Segment permissions: Read/Execute
.text$mn:000011C0 _text$mn        segment para public 'CODE' use32
.text$mn:000011C0                 assume cs:_text$mn
.text$mn:000011C0                 ;org 11C0h
.text$mn:000011C0 ; COMDAT (pick any)
.text$mn:000011C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011C0
.text$mn:000011C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011C0
.text$mn:000011C0 ; Attributes: bp-based frame
.text$mn:000011C0
.text$mn:000011C0 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000011C0                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000011C0 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000011C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000011C0                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000011C0
.text$mn:000011C0 var_4           = dword ptr -4
.text$mn:000011C0 arg_0           = dword ptr  8
.text$mn:000011C0
.text$mn:000011C0                 push    ebp
.text$mn:000011C1                 mov     ebp, esp
.text$mn:000011C3                 push    ecx
.text$mn:000011C4                 mov     [ebp+var_4], ecx
.text$mn:000011C7                 mov     eax, [ebp+arg_0]
.text$mn:000011CA                 push    eax
.text$mn:000011CB                 mov     ecx, [ebp+var_4]
.text$mn:000011CE                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000011D3                 mov     esp, ebp
.text$mn:000011D5                 pop     ebp
.text$mn:000011D6                 retn    4
.text$mn:000011D6 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000011D6
.text$mn:000011D6 ; ---------------------------------------------------------------------------
.text$mn:000011D9                 align 4
.text$mn:000011D9 _text$mn        ends
.text$mn:000011D9
.text$mn:000011DC ; ===========================================================================
.text$mn:000011DC
.text$mn:000011DC ; Segment type: Pure code
.text$mn:000011DC ; Segment permissions: Read/Execute
.text$mn:000011DC _text$mn        segment para public 'CODE' use32
.text$mn:000011DC                 assume cs:_text$mn
.text$mn:000011DC                 ;org 11DCh
.text$mn:000011DC ; COMDAT (pick any)
.text$mn:000011DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011DC
.text$mn:000011DC ; =============== S U B R O U T I N E =======================================
.text$mn:000011DC
.text$mn:000011DC ; Attributes: bp-based frame
.text$mn:000011DC
.text$mn:000011DC ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000011DC                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000011DC ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000011DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000011DC
.text$mn:000011DC var_4           = dword ptr -4
.text$mn:000011DC arg_0           = dword ptr  8
.text$mn:000011DC
.text$mn:000011DC                 push    ebp
.text$mn:000011DD                 mov     ebp, esp
.text$mn:000011DF                 push    ecx
.text$mn:000011E0                 mov     [ebp+var_4], ecx
.text$mn:000011E3                 push    0
.text$mn:000011E5                 mov     eax, [ebp+arg_0]
.text$mn:000011E8                 push    eax
.text$mn:000011E9                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000011EE                 add     esp, 8
.text$mn:000011F1                 mov     esp, ebp
.text$mn:000011F3                 pop     ebp
.text$mn:000011F4                 retn    4
.text$mn:000011F4 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000011F4
.text$mn:000011F4 ; ---------------------------------------------------------------------------
.text$mn:000011F7                 align 4
.text$mn:000011F7 _text$mn        ends
.text$mn:000011F7
.text$mn:000011F8 ; ===========================================================================
.text$mn:000011F8
.text$mn:000011F8 ; Segment type: Pure code
.text$mn:000011F8 ; Segment permissions: Read/Execute
.text$mn:000011F8 _text$mn        segment para public 'CODE' use32
.text$mn:000011F8                 assume cs:_text$mn
.text$mn:000011F8                 ;org 11F8h
.text$mn:000011F8 ; COMDAT (pick any)
.text$mn:000011F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011F8
.text$mn:000011F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000011F8
.text$mn:000011F8 ; Attributes: bp-based frame
.text$mn:000011F8
.text$mn:000011F8 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000011F8                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000011F8 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000011F8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000011F8
.text$mn:000011F8 var_4           = dword ptr -4
.text$mn:000011F8 arg_0           = dword ptr  8
.text$mn:000011F8
.text$mn:000011F8                 push    ebp
.text$mn:000011F9                 mov     ebp, esp
.text$mn:000011FB                 push    ecx
.text$mn:000011FC                 mov     [ebp+var_4], ecx
.text$mn:000011FF                 push    0
.text$mn:00001201                 mov     eax, [ebp+arg_0]
.text$mn:00001204                 push    eax
.text$mn:00001205                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000120A                 add     esp, 8
.text$mn:0000120D                 mov     esp, ebp
.text$mn:0000120F                 pop     ebp
.text$mn:00001210                 retn    4
.text$mn:00001210 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001210
.text$mn:00001210 ; ---------------------------------------------------------------------------
.text$mn:00001213                 align 4
.text$mn:00001213 _text$mn        ends
.text$mn:00001213
.text$mn:00001214 ; ===========================================================================
.text$mn:00001214
.text$mn:00001214 ; Segment type: Pure code
.text$mn:00001214 ; Segment permissions: Read/Execute
.text$mn:00001214 _text$mn        segment para public 'CODE' use32
.text$mn:00001214                 assume cs:_text$mn
.text$mn:00001214                 ;org 1214h
.text$mn:00001214 ; COMDAT (pick any)
.text$mn:00001214                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001214
.text$mn:00001214 ; =============== S U B R O U T I N E =======================================
.text$mn:00001214
.text$mn:00001214 ; Attributes: bp-based frame
.text$mn:00001214
.text$mn:00001214 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001214                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001214 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001214                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001214
.text$mn:00001214 Size            = dword ptr -8
.text$mn:00001214 var_4           = dword ptr -4
.text$mn:00001214 arg_0           = dword ptr  8
.text$mn:00001214 arg_4           = dword ptr  0Ch
.text$mn:00001214 arg_8           = dword ptr  10h
.text$mn:00001214
.text$mn:00001214                 push    ebp
.text$mn:00001215                 mov     ebp, esp
.text$mn:00001217                 sub     esp, 8
.text$mn:0000121A                 mov     [ebp+var_4], ecx
.text$mn:0000121D                 mov     ecx, [ebp+arg_0]
.text$mn:00001220                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001225                 cmp     eax, [ebp+arg_4]
.text$mn:00001228                 jnb     short loc_1232
.text$mn:0000122A                 mov     ecx, [ebp+var_4]
.text$mn:0000122D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001232
.text$mn:00001232 loc_1232:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00001232                 mov     ecx, [ebp+arg_0]
.text$mn:00001235                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000123A                 sub     eax, [ebp+arg_4]
.text$mn:0000123D                 mov     [ebp+Size], eax
.text$mn:00001240                 mov     eax, [ebp+arg_8]
.text$mn:00001243                 cmp     eax, [ebp+Size]
.text$mn:00001246                 jnb     short loc_124E
.text$mn:00001248                 mov     ecx, [ebp+arg_8]
.text$mn:0000124B                 mov     [ebp+Size], ecx
.text$mn:0000124E
.text$mn:0000124E loc_124E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000124E                 mov     edx, [ebp+var_4]
.text$mn:00001251                 cmp     edx, [ebp+arg_0]
.text$mn:00001254                 jnz     short loc_1275
.text$mn:00001256                 mov     eax, [ebp+arg_4]
.text$mn:00001259                 add     eax, [ebp+Size]
.text$mn:0000125C                 push    eax
.text$mn:0000125D                 mov     ecx, [ebp+var_4]
.text$mn:00001260                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00001265                 mov     ecx, [ebp+arg_4]
.text$mn:00001268                 push    ecx
.text$mn:00001269                 push    0
.text$mn:0000126B                 mov     ecx, [ebp+var_4]
.text$mn:0000126E                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00001273                 jmp     short loc_12B7
.text$mn:00001275 ; ---------------------------------------------------------------------------
.text$mn:00001275
.text$mn:00001275 loc_1275:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00001275                 push    0
.text$mn:00001277                 mov     edx, [ebp+Size]
.text$mn:0000127A                 push    edx
.text$mn:0000127B                 mov     ecx, [ebp+var_4]
.text$mn:0000127E                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001283                 movzx   eax, al
.text$mn:00001286                 test    eax, eax
.text$mn:00001288                 jz      short loc_12B7
.text$mn:0000128A                 mov     ecx, [ebp+Size]
.text$mn:0000128D                 push    ecx             ; Size
.text$mn:0000128E                 mov     ecx, [ebp+arg_0]
.text$mn:00001291                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001296                 add     eax, [ebp+arg_4]
.text$mn:00001299                 push    eax             ; Src
.text$mn:0000129A                 mov     ecx, [ebp+var_4]
.text$mn:0000129D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000012A2                 push    eax             ; Dst
.text$mn:000012A3                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000012A8                 add     esp, 0Ch
.text$mn:000012AB                 mov     edx, [ebp+Size]
.text$mn:000012AE                 push    edx
.text$mn:000012AF                 mov     ecx, [ebp+var_4]
.text$mn:000012B2                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000012B7
.text$mn:000012B7 loc_12B7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000012B7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000012B7                 mov     eax, [ebp+var_4]
.text$mn:000012BA                 mov     esp, ebp
.text$mn:000012BC                 pop     ebp
.text$mn:000012BD                 retn    0Ch
.text$mn:000012BD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000012BD
.text$mn:000012BD _text$mn        ends
.text$mn:000012BD
.text$mn:000012C0 ; ===========================================================================
.text$mn:000012C0
.text$mn:000012C0 ; Segment type: Pure code
.text$mn:000012C0 ; Segment permissions: Read/Execute
.text$mn:000012C0 _text$mn        segment para public 'CODE' use32
.text$mn:000012C0                 assume cs:_text$mn
.text$mn:000012C0                 ;org 12C0h
.text$mn:000012C0 ; COMDAT (pick any)
.text$mn:000012C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012C0
.text$mn:000012C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000012C0
.text$mn:000012C0 ; Attributes: bp-based frame
.text$mn:000012C0
.text$mn:000012C0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000012C0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000012C0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000012C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000012C0
.text$mn:000012C0 var_4           = dword ptr -4
.text$mn:000012C0 Str             = dword ptr  8
.text$mn:000012C0
.text$mn:000012C0                 push    ebp
.text$mn:000012C1                 mov     ebp, esp
.text$mn:000012C3                 push    ecx
.text$mn:000012C4                 mov     [ebp+var_4], ecx
.text$mn:000012C7                 push    490h            ; unsigned int
.text$mn:000012CC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000012D1                 mov     eax, [ebp+Str]
.text$mn:000012D4                 push    eax             ; int
.text$mn:000012D5                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000012DA                 add     esp, 0Ch
.text$mn:000012DD                 mov     ecx, [ebp+Str]
.text$mn:000012E0                 push    ecx             ; Str
.text$mn:000012E1                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000012E6                 add     esp, 4
.text$mn:000012E9                 push    eax             ; Size
.text$mn:000012EA                 mov     edx, [ebp+Str]
.text$mn:000012ED                 push    edx             ; Src
.text$mn:000012EE                 mov     ecx, [ebp+var_4]
.text$mn:000012F1                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:000012F6                 mov     esp, ebp
.text$mn:000012F8                 pop     ebp
.text$mn:000012F9                 retn    4
.text$mn:000012F9 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000012F9
.text$mn:000012F9 _text$mn        ends
.text$mn:000012F9
.text$mn:000012FC ; ===========================================================================
.text$mn:000012FC
.text$mn:000012FC ; Segment type: Pure code
.text$mn:000012FC ; Segment permissions: Read/Execute
.text$mn:000012FC _text$mn        segment para public 'CODE' use32
.text$mn:000012FC                 assume cs:_text$mn
.text$mn:000012FC                 ;org 12FCh
.text$mn:000012FC ; COMDAT (pick any)
.text$mn:000012FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012FC
.text$mn:000012FC ; =============== S U B R O U T I N E =======================================
.text$mn:000012FC
.text$mn:000012FC ; Attributes: bp-based frame
.text$mn:000012FC
.text$mn:000012FC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:000012FC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:000012FC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:000012FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:000012FC
.text$mn:000012FC var_4           = dword ptr -4
.text$mn:000012FC Src             = dword ptr  8
.text$mn:000012FC Size            = dword ptr  0Ch
.text$mn:000012FC
.text$mn:000012FC                 push    ebp
.text$mn:000012FD                 mov     ebp, esp
.text$mn:000012FF                 push    ecx
.text$mn:00001300                 mov     [ebp+var_4], ecx
.text$mn:00001303                 cmp     [ebp+Size], 0
.text$mn:00001307                 jz      short loc_131F
.text$mn:00001309                 push    47Fh            ; unsigned int
.text$mn:0000130E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001313                 mov     eax, [ebp+Src]
.text$mn:00001316                 push    eax             ; int
.text$mn:00001317                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000131C                 add     esp, 0Ch
.text$mn:0000131F
.text$mn:0000131F loc_131F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000131F                 mov     ecx, [ebp+Src]
.text$mn:00001322                 push    ecx
.text$mn:00001323                 mov     ecx, [ebp+var_4]
.text$mn:00001326                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000132B                 movzx   edx, al
.text$mn:0000132E                 test    edx, edx
.text$mn:00001330                 jz      short loc_1352
.text$mn:00001332                 mov     eax, [ebp+Size]
.text$mn:00001335                 push    eax
.text$mn:00001336                 mov     ecx, [ebp+var_4]
.text$mn:00001339                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000133E                 mov     ecx, [ebp+Src]
.text$mn:00001341                 sub     ecx, eax
.text$mn:00001343                 push    ecx
.text$mn:00001344                 mov     edx, [ebp+var_4]
.text$mn:00001347                 push    edx
.text$mn:00001348                 mov     ecx, [ebp+var_4]
.text$mn:0000134B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001350                 jmp     short loc_138F
.text$mn:00001352 ; ---------------------------------------------------------------------------
.text$mn:00001352
.text$mn:00001352 loc_1352:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00001352                 push    0
.text$mn:00001354                 mov     eax, [ebp+Size]
.text$mn:00001357                 push    eax
.text$mn:00001358                 mov     ecx, [ebp+var_4]
.text$mn:0000135B                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001360                 movzx   ecx, al
.text$mn:00001363                 test    ecx, ecx
.text$mn:00001365                 jz      short loc_138C
.text$mn:00001367                 mov     edx, [ebp+Size]
.text$mn:0000136A                 push    edx             ; Size
.text$mn:0000136B                 mov     eax, [ebp+Src]
.text$mn:0000136E                 push    eax             ; Src
.text$mn:0000136F                 mov     ecx, [ebp+var_4]
.text$mn:00001372                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001377                 push    eax             ; Dst
.text$mn:00001378                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000137D                 add     esp, 0Ch
.text$mn:00001380                 mov     ecx, [ebp+Size]
.text$mn:00001383                 push    ecx
.text$mn:00001384                 mov     ecx, [ebp+var_4]
.text$mn:00001387                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000138C
.text$mn:0000138C loc_138C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:0000138C                 mov     eax, [ebp+var_4]
.text$mn:0000138F
.text$mn:0000138F loc_138F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000138F                 mov     esp, ebp
.text$mn:00001391                 pop     ebp
.text$mn:00001392                 retn    8
.text$mn:00001392 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00001392
.text$mn:00001392 ; ---------------------------------------------------------------------------
.text$mn:00001395                 align 4
.text$mn:00001395 _text$mn        ends
.text$mn:00001395
.text$mn:00001398 ; ===========================================================================
.text$mn:00001398
.text$mn:00001398 ; Segment type: Pure code
.text$mn:00001398 ; Segment permissions: Read/Execute
.text$mn:00001398 _text$mn        segment para public 'CODE' use32
.text$mn:00001398                 assume cs:_text$mn
.text$mn:00001398                 ;org 1398h
.text$mn:00001398 ; COMDAT (pick any)
.text$mn:00001398                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001398
.text$mn:00001398 ; =============== S U B R O U T I N E =======================================
.text$mn:00001398
.text$mn:00001398 ; Attributes: bp-based frame
.text$mn:00001398
.text$mn:00001398 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00001398                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00001398 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00001398                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00001398
.text$mn:00001398 arg_0           = dword ptr  8
.text$mn:00001398 arg_4           = dword ptr  0Ch
.text$mn:00001398
.text$mn:00001398                 push    ebp
.text$mn:00001399                 mov     ebp, esp
.text$mn:0000139B                 mov     eax, [ebp+arg_0]
.text$mn:0000139E                 mov     ecx, [ebp+arg_4]
.text$mn:000013A1                 mov     dl, [ecx]
.text$mn:000013A3                 mov     [eax], dl
.text$mn:000013A5                 pop     ebp
.text$mn:000013A6                 retn
.text$mn:000013A6 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000013A6
.text$mn:000013A6 ; ---------------------------------------------------------------------------
.text$mn:000013A7                 align 4
.text$mn:000013A7 _text$mn        ends
.text$mn:000013A7
.text$mn:000013A8 ; ===========================================================================
.text$mn:000013A8
.text$mn:000013A8 ; Segment type: Pure code
.text$mn:000013A8 ; Segment permissions: Read/Execute
.text$mn:000013A8 _text$mn        segment para public 'CODE' use32
.text$mn:000013A8                 assume cs:_text$mn
.text$mn:000013A8                 ;org 13A8h
.text$mn:000013A8 ; COMDAT (pick any)
.text$mn:000013A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013A8
.text$mn:000013A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013A8
.text$mn:000013A8 ; Attributes: bp-based frame
.text$mn:000013A8
.text$mn:000013A8 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:000013A8                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:000013A8 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:000013A8                                         ; CODE XREF: Process::run(void)+18p
.text$mn:000013A8                                         ; Process::run(void)+24p ...
.text$mn:000013A8
.text$mn:000013A8 var_4           = dword ptr -4
.text$mn:000013A8
.text$mn:000013A8                 push    ebp
.text$mn:000013A9                 mov     ebp, esp
.text$mn:000013AB                 push    ecx
.text$mn:000013AC                 mov     [ebp+var_4], ecx
.text$mn:000013AF                 mov     ecx, [ebp+var_4]
.text$mn:000013B2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000013B7                 mov     esp, ebp
.text$mn:000013B9                 pop     ebp
.text$mn:000013BA                 retn
.text$mn:000013BA ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:000013BA
.text$mn:000013BA ; ---------------------------------------------------------------------------
.text$mn:000013BB                 align 4
.text$mn:000013BB _text$mn        ends
.text$mn:000013BB
.text$mn:000013BC ; ===========================================================================
.text$mn:000013BC
.text$mn:000013BC ; Segment type: Pure code
.text$mn:000013BC ; Segment permissions: Read/Execute
.text$mn:000013BC _text$mn        segment para public 'CODE' use32
.text$mn:000013BC                 assume cs:_text$mn
.text$mn:000013BC                 ;org 13BCh
.text$mn:000013BC ; COMDAT (pick any)
.text$mn:000013BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013BC
.text$mn:000013BC ; =============== S U B R O U T I N E =======================================
.text$mn:000013BC
.text$mn:000013BC ; Attributes: bp-based frame
.text$mn:000013BC
.text$mn:000013BC ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000013BC                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000013BC ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000013BC                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000013BC
.text$mn:000013BC var_4           = dword ptr -4
.text$mn:000013BC
.text$mn:000013BC                 push    ebp
.text$mn:000013BD                 mov     ebp, esp
.text$mn:000013BF                 push    ecx
.text$mn:000013C0                 mov     [ebp+var_4], ecx
.text$mn:000013C3                 mov     eax, [ebp+var_4]
.text$mn:000013C6                 mov     eax, [eax+4]
.text$mn:000013C9                 mov     esp, ebp
.text$mn:000013CB                 pop     ebp
.text$mn:000013CC                 retn
.text$mn:000013CC ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000013CC
.text$mn:000013CC ; ---------------------------------------------------------------------------
.text$mn:000013CD                 align 10h
.text$mn:000013CD _text$mn        ends
.text$mn:000013CD
.text$mn:000013D0 ; ===========================================================================
.text$mn:000013D0
.text$mn:000013D0 ; Segment type: Pure code
.text$mn:000013D0 ; Segment permissions: Read/Execute
.text$mn:000013D0 _text$mn        segment para public 'CODE' use32
.text$mn:000013D0                 assume cs:_text$mn
.text$mn:000013D0                 ;org 13D0h
.text$mn:000013D0 ; COMDAT (pick any)
.text$mn:000013D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013D0
.text$mn:000013D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000013D0
.text$mn:000013D0 ; Attributes: bp-based frame
.text$mn:000013D0
.text$mn:000013D0 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000013D0                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000013D0 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000013D0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000013D0                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000013D0
.text$mn:000013D0 var_4           = dword ptr -4
.text$mn:000013D0
.text$mn:000013D0                 push    ebp
.text$mn:000013D1                 mov     ebp, esp
.text$mn:000013D3                 push    ecx
.text$mn:000013D4                 mov     [ebp+var_4], ecx
.text$mn:000013D7                 mov     eax, [ebp+var_4]
.text$mn:000013DA                 mov     eax, [eax+4]
.text$mn:000013DD                 mov     esp, ebp
.text$mn:000013DF                 pop     ebp
.text$mn:000013E0                 retn
.text$mn:000013E0 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000013E0
.text$mn:000013E0 ; ---------------------------------------------------------------------------
.text$mn:000013E1                 align 4
.text$mn:000013E1 _text$mn        ends
.text$mn:000013E1
.text$mn:000013E4 ; ===========================================================================
.text$mn:000013E4
.text$mn:000013E4 ; Segment type: Pure code
.text$mn:000013E4 ; Segment permissions: Read/Execute
.text$mn:000013E4 _text$mn        segment para public 'CODE' use32
.text$mn:000013E4                 assume cs:_text$mn
.text$mn:000013E4                 ;org 13E4h
.text$mn:000013E4 ; COMDAT (pick any)
.text$mn:000013E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013E4
.text$mn:000013E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013E4
.text$mn:000013E4 ; Attributes: bp-based frame
.text$mn:000013E4
.text$mn:000013E4 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000013E4                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000013E4 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000013E4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000013E4
.text$mn:000013E4 var_4           = dword ptr -4
.text$mn:000013E4 Dst             = dword ptr  8
.text$mn:000013E4 Src             = dword ptr  0Ch
.text$mn:000013E4 Size            = dword ptr  10h
.text$mn:000013E4
.text$mn:000013E4                 push    ebp
.text$mn:000013E5                 mov     ebp, esp
.text$mn:000013E7                 push    ecx
.text$mn:000013E8                 cmp     [ebp+Size], 0
.text$mn:000013EC                 jnz     short loc_13F6
.text$mn:000013EE                 mov     eax, [ebp+Dst]
.text$mn:000013F1                 mov     [ebp+var_4], eax
.text$mn:000013F4                 jmp     short loc_140D
.text$mn:000013F6 ; ---------------------------------------------------------------------------
.text$mn:000013F6
.text$mn:000013F6 loc_13F6:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000013F6                 mov     ecx, [ebp+Size]
.text$mn:000013F9                 push    ecx             ; Size
.text$mn:000013FA                 mov     edx, [ebp+Src]
.text$mn:000013FD                 push    edx             ; Src
.text$mn:000013FE                 mov     eax, [ebp+Dst]
.text$mn:00001401                 push    eax             ; Dst
.text$mn:00001402                 call    _memcpy
.text$mn:00001407                 add     esp, 0Ch
.text$mn:0000140A                 mov     [ebp+var_4], eax
.text$mn:0000140D
.text$mn:0000140D loc_140D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000140D                 mov     eax, [ebp+var_4]
.text$mn:00001410                 mov     esp, ebp
.text$mn:00001412                 pop     ebp
.text$mn:00001413                 retn
.text$mn:00001413 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001413
.text$mn:00001413 _text$mn        ends
.text$mn:00001413
.text$mn:00001414 ; ===========================================================================
.text$mn:00001414
.text$mn:00001414 ; Segment type: Pure code
.text$mn:00001414 ; Segment permissions: Read/Execute
.text$mn:00001414 _text$mn        segment para public 'CODE' use32
.text$mn:00001414                 assume cs:_text$mn
.text$mn:00001414                 ;org 1414h
.text$mn:00001414 ; COMDAT (pick any)
.text$mn:00001414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001414
.text$mn:00001414 ; =============== S U B R O U T I N E =======================================
.text$mn:00001414
.text$mn:00001414 ; Attributes: bp-based frame
.text$mn:00001414
.text$mn:00001414 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001414                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001414 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001414                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001414
.text$mn:00001414 var_4           = dword ptr -4
.text$mn:00001414 arg_0           = dword ptr  8
.text$mn:00001414 arg_4           = dword ptr  0Ch
.text$mn:00001414
.text$mn:00001414                 push    ebp
.text$mn:00001415                 mov     ebp, esp
.text$mn:00001417                 push    ecx
.text$mn:00001418                 mov     [ebp+var_4], ecx
.text$mn:0000141B                 mov     eax, [ebp+arg_4]
.text$mn:0000141E                 push    eax             ; int
.text$mn:0000141F                 mov     ecx, [ebp+arg_0]
.text$mn:00001422                 push    ecx             ; void *
.text$mn:00001423                 mov     ecx, [ebp+var_4]
.text$mn:00001426                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000142B                 mov     esp, ebp
.text$mn:0000142D                 pop     ebp
.text$mn:0000142E                 retn    8
.text$mn:0000142E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000142E
.text$mn:0000142E ; ---------------------------------------------------------------------------
.text$mn:00001431                 align 4
.text$mn:00001431 _text$mn        ends
.text$mn:00001431
.text$mn:00001434 ; ===========================================================================
.text$mn:00001434
.text$mn:00001434 ; Segment type: Pure code
.text$mn:00001434 ; Segment permissions: Read/Execute
.text$mn:00001434 _text$mn        segment para public 'CODE' use32
.text$mn:00001434                 assume cs:_text$mn
.text$mn:00001434                 ;org 1434h
.text$mn:00001434 ; COMDAT (pick any)
.text$mn:00001434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001434
.text$mn:00001434 ; =============== S U B R O U T I N E =======================================
.text$mn:00001434
.text$mn:00001434 ; Attributes: bp-based frame
.text$mn:00001434
.text$mn:00001434 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00001434                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00001434 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00001434                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00001434
.text$mn:00001434 var_4           = dword ptr -4
.text$mn:00001434 arg_0           = dword ptr  8
.text$mn:00001434
.text$mn:00001434                 push    ebp
.text$mn:00001435                 mov     ebp, esp
.text$mn:00001437                 push    ecx
.text$mn:00001438                 mov     [ebp+var_4], ecx
.text$mn:0000143B                 mov     eax, [ebp+arg_0]
.text$mn:0000143E                 push    eax             ; void *
.text$mn:0000143F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001444                 add     esp, 4
.text$mn:00001447                 mov     esp, ebp
.text$mn:00001449                 pop     ebp
.text$mn:0000144A                 retn    8
.text$mn:0000144A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000144A
.text$mn:0000144A ; ---------------------------------------------------------------------------
.text$mn:0000144D                 align 10h
.text$mn:0000144D _text$mn        ends
.text$mn:0000144D
.text$mn:00001450 ; ===========================================================================
.text$mn:00001450
.text$mn:00001450 ; Segment type: Pure code
.text$mn:00001450 ; Segment permissions: Read/Execute
.text$mn:00001450 _text$mn        segment para public 'CODE' use32
.text$mn:00001450                 assume cs:_text$mn
.text$mn:00001450                 ;org 1450h
.text$mn:00001450 ; COMDAT (pick any)
.text$mn:00001450                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001450
.text$mn:00001450 ; =============== S U B R O U T I N E =======================================
.text$mn:00001450
.text$mn:00001450 ; Attributes: bp-based frame
.text$mn:00001450
.text$mn:00001450 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00001450                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00001450 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00001450                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00001450
.text$mn:00001450 var_4           = dword ptr -4
.text$mn:00001450 arg_0           = dword ptr  8
.text$mn:00001450
.text$mn:00001450                 push    ebp
.text$mn:00001451                 mov     ebp, esp
.text$mn:00001453                 push    ecx
.text$mn:00001454                 mov     [ebp+var_4], ecx
.text$mn:00001457                 mov     eax, [ebp+arg_0]
.text$mn:0000145A                 push    eax             ; void *
.text$mn:0000145B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001460                 add     esp, 4
.text$mn:00001463                 mov     esp, ebp
.text$mn:00001465                 pop     ebp
.text$mn:00001466                 retn    8
.text$mn:00001466 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00001466
.text$mn:00001466 ; ---------------------------------------------------------------------------
.text$mn:00001469                 align 4
.text$mn:00001469 _text$mn        ends
.text$mn:00001469
.text$mn:0000146C ; ===========================================================================
.text$mn:0000146C
.text$mn:0000146C ; Segment type: Pure code
.text$mn:0000146C ; Segment permissions: Read/Execute
.text$mn:0000146C _text$mn        segment para public 'CODE' use32
.text$mn:0000146C                 assume cs:_text$mn
.text$mn:0000146C                 ;org 146Ch
.text$mn:0000146C ; COMDAT (pick any)
.text$mn:0000146C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000146C
.text$mn:0000146C ; =============== S U B R O U T I N E =======================================
.text$mn:0000146C
.text$mn:0000146C ; Attributes: bp-based frame
.text$mn:0000146C
.text$mn:0000146C ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:0000146C                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000146C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000146C                                         ; DATA XREF: .rdata:00001E00o
.text$mn:0000146C
.text$mn:0000146C var_4           = dword ptr -4
.text$mn:0000146C arg_0           = dword ptr  8
.text$mn:0000146C arg_4           = dword ptr  0Ch
.text$mn:0000146C
.text$mn:0000146C                 push    ebp
.text$mn:0000146D                 mov     ebp, esp
.text$mn:0000146F                 push    ecx
.text$mn:00001470                 mov     [ebp+var_4], ecx
.text$mn:00001473                 mov     eax, [ebp+arg_4]
.text$mn:00001476                 push    eax             ; int
.text$mn:00001477                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000147C                 add     esp, 4
.text$mn:0000147F                 test    eax, eax
.text$mn:00001481                 jz      short loc_149C
.text$mn:00001483                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00001488                 push    eax             ; struct std::error_category *
.text$mn:00001489                 mov     ecx, [ebp+arg_4]
.text$mn:0000148C                 push    ecx             ; int
.text$mn:0000148D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001490                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001495                 mov     eax, [ebp+arg_0]
.text$mn:00001498                 jmp     short loc_14B1
.text$mn:0000149A ; ---------------------------------------------------------------------------
.text$mn:0000149A                 jmp     short loc_14B1
.text$mn:0000149C ; ---------------------------------------------------------------------------
.text$mn:0000149C
.text$mn:0000149C loc_149C:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:0000149C                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000014A1                 push    eax             ; struct std::error_category *
.text$mn:000014A2                 mov     edx, [ebp+arg_4]
.text$mn:000014A5                 push    edx             ; int
.text$mn:000014A6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000014A9                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000014AE                 mov     eax, [ebp+arg_0]
.text$mn:000014B1
.text$mn:000014B1 loc_14B1:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000014B1                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000014B1                 mov     esp, ebp
.text$mn:000014B3                 pop     ebp
.text$mn:000014B4                 retn    8
.text$mn:000014B4 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000014B4
.text$mn:000014B4 ; ---------------------------------------------------------------------------
.text$mn:000014B7                 align 4
.text$mn:000014B7 _text$mn        ends
.text$mn:000014B7
.text$mn:000014B8 ; ===========================================================================
.text$mn:000014B8
.text$mn:000014B8 ; Segment type: Pure code
.text$mn:000014B8 ; Segment permissions: Read/Execute
.text$mn:000014B8 _text$mn        segment para public 'CODE' use32
.text$mn:000014B8                 assume cs:_text$mn
.text$mn:000014B8                 ;org 14B8h
.text$mn:000014B8 ; COMDAT (pick any)
.text$mn:000014B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014B8
.text$mn:000014B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014B8
.text$mn:000014B8 ; Attributes: bp-based frame
.text$mn:000014B8
.text$mn:000014B8 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000014B8                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000014B8 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000014B8                                         ; DATA XREF: .rdata:00001D70o
.text$mn:000014B8                                         ; .rdata:00001D8Co ...
.text$mn:000014B8
.text$mn:000014B8 var_4           = dword ptr -4
.text$mn:000014B8 arg_0           = dword ptr  8
.text$mn:000014B8 arg_4           = dword ptr  0Ch
.text$mn:000014B8
.text$mn:000014B8                 push    ebp
.text$mn:000014B9                 mov     ebp, esp
.text$mn:000014BB                 push    ecx
.text$mn:000014BC                 mov     [ebp+var_4], ecx
.text$mn:000014BF                 mov     eax, [ebp+var_4]
.text$mn:000014C2                 push    eax             ; struct std::error_category *
.text$mn:000014C3                 mov     ecx, [ebp+arg_4]
.text$mn:000014C6                 push    ecx             ; int
.text$mn:000014C7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000014CA                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000014CF                 mov     eax, [ebp+arg_0]
.text$mn:000014D2                 mov     esp, ebp
.text$mn:000014D4                 pop     ebp
.text$mn:000014D5                 retn    8
.text$mn:000014D5 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000014D5
.text$mn:000014D5 _text$mn        ends
.text$mn:000014D5
.text$mn:000014D8 ; ===========================================================================
.text$mn:000014D8
.text$mn:000014D8 ; Segment type: Pure code
.text$mn:000014D8 ; Segment permissions: Read/Execute
.text$mn:000014D8 _text$mn        segment para public 'CODE' use32
.text$mn:000014D8                 assume cs:_text$mn
.text$mn:000014D8                 ;org 14D8h
.text$mn:000014D8 ; COMDAT (pick any)
.text$mn:000014D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014D8
.text$mn:000014D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014D8
.text$mn:000014D8 ; Attributes: bp-based frame
.text$mn:000014D8
.text$mn:000014D8 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000014D8                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000014D8 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000014D8                                         ; DATA XREF: .rdata:00001D74o
.text$mn:000014D8                                         ; .rdata:00001D90o ...
.text$mn:000014D8
.text$mn:000014D8 var_8           = dword ptr -8
.text$mn:000014D8 var_4           = dword ptr -4
.text$mn:000014D8 arg_0           = dword ptr  8
.text$mn:000014D8 arg_4           = dword ptr  0Ch
.text$mn:000014D8
.text$mn:000014D8                 push    ebp
.text$mn:000014D9                 mov     ebp, esp
.text$mn:000014DB                 sub     esp, 8
.text$mn:000014DE                 mov     [ebp+var_8], ecx
.text$mn:000014E1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000014E4                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:000014E9                 push    eax
.text$mn:000014EA                 mov     ecx, [ebp+var_8]
.text$mn:000014ED                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000014F2                 movzx   eax, al
.text$mn:000014F5                 test    eax, eax
.text$mn:000014F7                 jz      short loc_150F
.text$mn:000014F9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000014FC                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00001501                 cmp     eax, [ebp+arg_4]
.text$mn:00001504                 jnz     short loc_150F
.text$mn:00001506                 mov     [ebp+var_4], 1
.text$mn:0000150D                 jmp     short loc_1516
.text$mn:0000150F ; ---------------------------------------------------------------------------
.text$mn:0000150F
.text$mn:0000150F loc_150F:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000150F                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000150F                 mov     [ebp+var_4], 0
.text$mn:00001516
.text$mn:00001516 loc_1516:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00001516                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001519                 mov     esp, ebp
.text$mn:0000151B                 pop     ebp
.text$mn:0000151C                 retn    8
.text$mn:0000151C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000151C
.text$mn:0000151C ; ---------------------------------------------------------------------------
.text$mn:0000151F                 align 10h
.text$mn:0000151F _text$mn        ends
.text$mn:0000151F
.text$mn:00001520 ; ===========================================================================
.text$mn:00001520
.text$mn:00001520 ; Segment type: Pure code
.text$mn:00001520 ; Segment permissions: Read/Execute
.text$mn:00001520 _text$mn        segment para public 'CODE' use32
.text$mn:00001520                 assume cs:_text$mn
.text$mn:00001520                 ;org 1520h
.text$mn:00001520 ; COMDAT (pick any)
.text$mn:00001520                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001520
.text$mn:00001520 ; =============== S U B R O U T I N E =======================================
.text$mn:00001520
.text$mn:00001520 ; Attributes: bp-based frame
.text$mn:00001520
.text$mn:00001520 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00001520                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00001520 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00001520                                         ; DATA XREF: .rdata:00001D78o
.text$mn:00001520                                         ; .rdata:00001D94o ...
.text$mn:00001520
.text$mn:00001520 var_C           = byte ptr -0Ch
.text$mn:00001520 var_4           = dword ptr -4
.text$mn:00001520 arg_0           = dword ptr  8
.text$mn:00001520 arg_4           = dword ptr  0Ch
.text$mn:00001520
.text$mn:00001520                 push    ebp
.text$mn:00001521                 mov     ebp, esp
.text$mn:00001523                 sub     esp, 0Ch
.text$mn:00001526                 mov     [ebp+var_4], ecx
.text$mn:00001529                 mov     eax, [ebp+arg_4]
.text$mn:0000152C                 push    eax             ; std::error_condition *
.text$mn:0000152D                 mov     ecx, [ebp+arg_0]
.text$mn:00001530                 push    ecx
.text$mn:00001531                 lea     edx, [ebp+var_C]
.text$mn:00001534                 push    edx
.text$mn:00001535                 mov     eax, [ebp+var_4]
.text$mn:00001538                 mov     edx, [eax]
.text$mn:0000153A                 mov     ecx, [ebp+var_4]
.text$mn:0000153D                 mov     eax, [edx+0Ch]
.text$mn:00001540                 call    eax
.text$mn:00001542                 mov     ecx, eax
.text$mn:00001544                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00001549                 mov     esp, ebp
.text$mn:0000154B                 pop     ebp
.text$mn:0000154C                 retn    8
.text$mn:0000154C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000154C
.text$mn:0000154C ; ---------------------------------------------------------------------------
.text$mn:0000154F                 align 10h
.text$mn:0000154F _text$mn        ends
.text$mn:0000154F
.text$mn:00001550 ; ===========================================================================
.text$mn:00001550
.text$mn:00001550 ; Segment type: Pure code
.text$mn:00001550 ; Segment permissions: Read/Execute
.text$mn:00001550 _text$mn        segment para public 'CODE' use32
.text$mn:00001550                 assume cs:_text$mn
.text$mn:00001550                 ;org 1550h
.text$mn:00001550 ; COMDAT (pick any)
.text$mn:00001550                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001550
.text$mn:00001550 ; =============== S U B R O U T I N E =======================================
.text$mn:00001550
.text$mn:00001550 ; Attributes: bp-based frame
.text$mn:00001550
.text$mn:00001550 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00001550                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00001550 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00001550                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00001550
.text$mn:00001550 var_4           = dword ptr -4
.text$mn:00001550 arg_0           = dword ptr  8
.text$mn:00001550
.text$mn:00001550                 push    ebp
.text$mn:00001551                 mov     ebp, esp
.text$mn:00001553                 push    ecx
.text$mn:00001554                 mov     [ebp+var_4], ecx
.text$mn:00001557                 mov     eax, [ebp+var_4]
.text$mn:0000155A                 mov     ecx, [eax+14h]
.text$mn:0000155D                 cmp     ecx, [ebp+arg_0]
.text$mn:00001560                 jnb     short loc_156A
.text$mn:00001562                 mov     ecx, [ebp+var_4]
.text$mn:00001565                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000156A
.text$mn:0000156A loc_156A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000156A                 mov     edx, [ebp+arg_0]
.text$mn:0000156D                 push    edx
.text$mn:0000156E                 mov     ecx, [ebp+var_4]
.text$mn:00001571                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001576                 mov     eax, [ebp+var_4]
.text$mn:00001579                 mov     esp, ebp
.text$mn:0000157B                 pop     ebp
.text$mn:0000157C                 retn    4
.text$mn:0000157C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000157C
.text$mn:0000157C ; ---------------------------------------------------------------------------
.text$mn:0000157F                 align 10h
.text$mn:0000157F _text$mn        ends
.text$mn:0000157F
.text$mn:00001580 ; ===========================================================================
.text$mn:00001580
.text$mn:00001580 ; Segment type: Pure code
.text$mn:00001580 ; Segment permissions: Read/Execute
.text$mn:00001580 _text$mn        segment para public 'CODE' use32
.text$mn:00001580                 assume cs:_text$mn
.text$mn:00001580                 ;org 1580h
.text$mn:00001580 ; COMDAT (pick any)
.text$mn:00001580                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001580
.text$mn:00001580 ; =============== S U B R O U T I N E =======================================
.text$mn:00001580
.text$mn:00001580 ; Attributes: bp-based frame
.text$mn:00001580
.text$mn:00001580 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00001580                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00001580 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00001580                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00001580
.text$mn:00001580 var_C           = dword ptr -0Ch
.text$mn:00001580 Dst             = dword ptr -8
.text$mn:00001580 var_4           = dword ptr -4
.text$mn:00001580 arg_0           = dword ptr  8
.text$mn:00001580 arg_4           = dword ptr  0Ch
.text$mn:00001580
.text$mn:00001580                 push    ebp
.text$mn:00001581                 mov     ebp, esp
.text$mn:00001583                 sub     esp, 0Ch
.text$mn:00001586                 mov     [ebp+var_4], ecx
.text$mn:00001589                 mov     eax, [ebp+var_4]
.text$mn:0000158C                 mov     ecx, [eax+14h]
.text$mn:0000158F                 cmp     ecx, [ebp+arg_0]
.text$mn:00001592                 jnb     short loc_159C
.text$mn:00001594                 mov     ecx, [ebp+var_4]
.text$mn:00001597                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000159C
.text$mn:0000159C loc_159C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:0000159C                 mov     edx, [ebp+var_4]
.text$mn:0000159F                 mov     eax, [edx+14h]
.text$mn:000015A2                 sub     eax, [ebp+arg_0]
.text$mn:000015A5                 cmp     eax, [ebp+arg_4]
.text$mn:000015A8                 ja      short loc_15B8
.text$mn:000015AA                 mov     ecx, [ebp+arg_0]
.text$mn:000015AD                 push    ecx
.text$mn:000015AE                 mov     ecx, [ebp+var_4]
.text$mn:000015B1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000015B6                 jmp     short loc_15FE
.text$mn:000015B8 ; ---------------------------------------------------------------------------
.text$mn:000015B8
.text$mn:000015B8 loc_15B8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:000015B8                 cmp     [ebp+arg_4], 0
.text$mn:000015BC                 jbe     short loc_15FE
.text$mn:000015BE                 mov     ecx, [ebp+var_4]
.text$mn:000015C1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000015C6                 add     eax, [ebp+arg_0]
.text$mn:000015C9                 mov     [ebp+Dst], eax
.text$mn:000015CC                 mov     edx, [ebp+var_4]
.text$mn:000015CF                 mov     eax, [edx+14h]
.text$mn:000015D2                 sub     eax, [ebp+arg_4]
.text$mn:000015D5                 mov     [ebp+var_C], eax
.text$mn:000015D8                 mov     ecx, [ebp+var_C]
.text$mn:000015DB                 sub     ecx, [ebp+arg_0]
.text$mn:000015DE                 push    ecx             ; Size
.text$mn:000015DF                 mov     edx, [ebp+Dst]
.text$mn:000015E2                 add     edx, [ebp+arg_4]
.text$mn:000015E5                 push    edx             ; Src
.text$mn:000015E6                 mov     eax, [ebp+Dst]
.text$mn:000015E9                 push    eax             ; Dst
.text$mn:000015EA                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:000015EF                 add     esp, 0Ch
.text$mn:000015F2                 mov     ecx, [ebp+var_C]
.text$mn:000015F5                 push    ecx
.text$mn:000015F6                 mov     ecx, [ebp+var_4]
.text$mn:000015F9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000015FE
.text$mn:000015FE loc_15FE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000015FE                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000015FE                 mov     eax, [ebp+var_4]
.text$mn:00001601                 mov     esp, ebp
.text$mn:00001603                 pop     ebp
.text$mn:00001604                 retn    8
.text$mn:00001604 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001604
.text$mn:00001604 ; ---------------------------------------------------------------------------
.text$mn:00001607                 align 4
.text$mn:00001607 _text$mn        ends
.text$mn:00001607
.text$mn:00001608 ; ===========================================================================
.text$mn:00001608
.text$mn:00001608 ; Segment type: Pure code
.text$mn:00001608 ; Segment permissions: Read/Execute
.text$mn:00001608 _text$mn        segment para public 'CODE' use32
.text$mn:00001608                 assume cs:_text$mn
.text$mn:00001608                 ;org 1608h
.text$mn:00001608 ; COMDAT (pick any)
.text$mn:00001608                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001608
.text$mn:00001608 ; =============== S U B R O U T I N E =======================================
.text$mn:00001608
.text$mn:00001608 ; Attributes: bp-based frame
.text$mn:00001608
.text$mn:00001608 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00001608                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00001608 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001608                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00001608                 push    ebp
.text$mn:00001609                 mov     ebp, esp
.text$mn:0000160B                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00001610                 pop     ebp
.text$mn:00001611                 retn
.text$mn:00001611 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001611
.text$mn:00001611 ; ---------------------------------------------------------------------------
.text$mn:00001612                 align 4
.text$mn:00001612 _text$mn        ends
.text$mn:00001612
.text$mn:00001614 ; ===========================================================================
.text$mn:00001614
.text$mn:00001614 ; Segment type: Pure code
.text$mn:00001614 ; Segment permissions: Read/Execute
.text$mn:00001614 _text$mn        segment para public 'CODE' use32
.text$mn:00001614                 assume cs:_text$mn
.text$mn:00001614                 ;org 1614h
.text$mn:00001614 ; COMDAT (pick any)
.text$mn:00001614                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001614
.text$mn:00001614 ; =============== S U B R O U T I N E =======================================
.text$mn:00001614
.text$mn:00001614 ; Attributes: bp-based frame
.text$mn:00001614
.text$mn:00001614 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00001614                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00001614 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00001614                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00001614
.text$mn:00001614 var_4           = dword ptr -4
.text$mn:00001614 Str             = dword ptr  8
.text$mn:00001614
.text$mn:00001614                 push    ebp
.text$mn:00001615                 mov     ebp, esp
.text$mn:00001617                 push    ecx
.text$mn:00001618                 mov     eax, [ebp+Str]
.text$mn:0000161B                 movsx   ecx, byte ptr [eax]
.text$mn:0000161E                 test    ecx, ecx
.text$mn:00001620                 jnz     short loc_162B
.text$mn:00001622                 mov     [ebp+var_4], 0
.text$mn:00001629                 jmp     short loc_163A
.text$mn:0000162B ; ---------------------------------------------------------------------------
.text$mn:0000162B
.text$mn:0000162B loc_162B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000162B                 mov     edx, [ebp+Str]
.text$mn:0000162E                 push    edx             ; Str
.text$mn:0000162F                 call    _strlen
.text$mn:00001634                 add     esp, 4
.text$mn:00001637                 mov     [ebp+var_4], eax
.text$mn:0000163A
.text$mn:0000163A loc_163A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000163A                 mov     eax, [ebp+var_4]
.text$mn:0000163D                 mov     esp, ebp
.text$mn:0000163F                 pop     ebp
.text$mn:00001640                 retn
.text$mn:00001640 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00001640
.text$mn:00001640 ; ---------------------------------------------------------------------------
.text$mn:00001641                 align 4
.text$mn:00001641 _text$mn        ends
.text$mn:00001641
.text$mn:00001644 ; ===========================================================================
.text$mn:00001644
.text$mn:00001644 ; Segment type: Pure code
.text$mn:00001644 ; Segment permissions: Read/Execute
.text$mn:00001644 _text$mn        segment para public 'CODE' use32
.text$mn:00001644                 assume cs:_text$mn
.text$mn:00001644                 ;org 1644h
.text$mn:00001644 ; COMDAT (pick any)
.text$mn:00001644                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001644
.text$mn:00001644 ; =============== S U B R O U T I N E =======================================
.text$mn:00001644
.text$mn:00001644 ; Attributes: bp-based frame
.text$mn:00001644
.text$mn:00001644 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00001644                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00001644 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00001644                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00001644
.text$mn:00001644 var_4           = dword ptr -4
.text$mn:00001644
.text$mn:00001644                 push    ebp
.text$mn:00001645                 mov     ebp, esp
.text$mn:00001647                 push    ecx
.text$mn:00001648                 mov     [ebp+var_4], ecx
.text$mn:0000164B                 mov     eax, [ebp+var_4]
.text$mn:0000164E                 push    eax
.text$mn:0000164F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00001654                 add     esp, 4
.text$mn:00001657                 mov     esp, ebp
.text$mn:00001659                 pop     ebp
.text$mn:0000165A                 retn
.text$mn:0000165A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000165A
.text$mn:0000165A ; ---------------------------------------------------------------------------
.text$mn:0000165B                 align 4
.text$mn:0000165B _text$mn        ends
.text$mn:0000165B
.text$mn:0000165C ; ===========================================================================
.text$mn:0000165C
.text$mn:0000165C ; Segment type: Pure code
.text$mn:0000165C ; Segment permissions: Read/Execute
.text$mn:0000165C _text$mn        segment para public 'CODE' use32
.text$mn:0000165C                 assume cs:_text$mn
.text$mn:0000165C                 ;org 165Ch
.text$mn:0000165C ; COMDAT (pick any)
.text$mn:0000165C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000165C
.text$mn:0000165C ; =============== S U B R O U T I N E =======================================
.text$mn:0000165C
.text$mn:0000165C ; Attributes: bp-based frame
.text$mn:0000165C
.text$mn:0000165C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000165C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000165C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000165C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000165C
.text$mn:0000165C var_4           = dword ptr -4
.text$mn:0000165C
.text$mn:0000165C                 push    ebp
.text$mn:0000165D                 mov     ebp, esp
.text$mn:0000165F                 push    ecx
.text$mn:00001660                 mov     [ebp+var_4], ecx
.text$mn:00001663                 or      eax, 0FFFFFFFFh
.text$mn:00001666                 mov     esp, ebp
.text$mn:00001668                 pop     ebp
.text$mn:00001669                 retn
.text$mn:00001669 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00001669
.text$mn:00001669 ; ---------------------------------------------------------------------------
.text$mn:0000166A                 align 4
.text$mn:0000166A _text$mn        ends
.text$mn:0000166A
.text$mn:0000166C ; ===========================================================================
.text$mn:0000166C
.text$mn:0000166C ; Segment type: Pure code
.text$mn:0000166C ; Segment permissions: Read/Execute
.text$mn:0000166C _text$mn        segment para public 'CODE' use32
.text$mn:0000166C                 assume cs:_text$mn
.text$mn:0000166C                 ;org 166Ch
.text$mn:0000166C ; COMDAT (pick any)
.text$mn:0000166C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000166C
.text$mn:0000166C ; =============== S U B R O U T I N E =======================================
.text$mn:0000166C
.text$mn:0000166C ; Attributes: bp-based frame
.text$mn:0000166C
.text$mn:0000166C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000166C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000166C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000166C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000166C
.text$mn:0000166C arg_0           = dword ptr  8
.text$mn:0000166C
.text$mn:0000166C                 push    ebp
.text$mn:0000166D                 mov     ebp, esp
.text$mn:0000166F                 mov     ecx, [ebp+arg_0]
.text$mn:00001672                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00001677                 pop     ebp
.text$mn:00001678                 retn
.text$mn:00001678 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00001678
.text$mn:00001678 ; ---------------------------------------------------------------------------
.text$mn:00001679                 align 4
.text$mn:00001679 _text$mn        ends
.text$mn:00001679
.text$mn:0000167C ; ===========================================================================
.text$mn:0000167C
.text$mn:0000167C ; Segment type: Pure code
.text$mn:0000167C ; Segment permissions: Read/Execute
.text$mn:0000167C _text$mn        segment para public 'CODE' use32
.text$mn:0000167C                 assume cs:_text$mn
.text$mn:0000167C                 ;org 167Ch
.text$mn:0000167C ; COMDAT (pick any)
.text$mn:0000167C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000167C
.text$mn:0000167C ; =============== S U B R O U T I N E =======================================
.text$mn:0000167C
.text$mn:0000167C ; Attributes: bp-based frame
.text$mn:0000167C
.text$mn:0000167C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:0000167C                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000167C ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000167C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:0000167C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000167C
.text$mn:0000167C var_10          = dword ptr -10h
.text$mn:0000167C var_C           = dword ptr -0Ch
.text$mn:0000167C var_8           = dword ptr -8
.text$mn:0000167C var_1           = byte ptr -1
.text$mn:0000167C
.text$mn:0000167C                 push    ebp
.text$mn:0000167D                 mov     ebp, esp
.text$mn:0000167F                 sub     esp, 10h
.text$mn:00001682                 mov     [ebp+var_10], ecx
.text$mn:00001685                 lea     eax, [ebp+var_1]
.text$mn:00001688                 push    eax
.text$mn:00001689                 mov     ecx, [ebp+var_10]
.text$mn:0000168C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001691                 mov     ecx, eax
.text$mn:00001693                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00001698                 mov     [ebp+var_8], eax
.text$mn:0000169B                 cmp     [ebp+var_8], 1
.text$mn:0000169F                 ja      short loc_16AA
.text$mn:000016A1                 mov     [ebp+var_C], 1
.text$mn:000016A8                 jmp     short loc_16B3
.text$mn:000016AA ; ---------------------------------------------------------------------------
.text$mn:000016AA
.text$mn:000016AA loc_16AA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000016AA                 mov     ecx, [ebp+var_8]
.text$mn:000016AD                 sub     ecx, 1
.text$mn:000016B0                 mov     [ebp+var_C], ecx
.text$mn:000016B3
.text$mn:000016B3 loc_16B3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000016B3                 mov     eax, [ebp+var_C]
.text$mn:000016B6                 mov     esp, ebp
.text$mn:000016B8                 pop     ebp
.text$mn:000016B9                 retn
.text$mn:000016B9 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000016B9
.text$mn:000016B9 ; ---------------------------------------------------------------------------
.text$mn:000016BA                 align 4
.text$mn:000016BA _text$mn        ends
.text$mn:000016BA
.text$mn:000016BC ; ===========================================================================
.text$mn:000016BC
.text$mn:000016BC ; Segment type: Pure code
.text$mn:000016BC ; Segment permissions: Read/Execute
.text$mn:000016BC _text$mn        segment para public 'CODE' use32
.text$mn:000016BC                 assume cs:_text$mn
.text$mn:000016BC                 ;org 16BCh
.text$mn:000016BC ; COMDAT (pick any)
.text$mn:000016BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016BC
.text$mn:000016BC ; =============== S U B R O U T I N E =======================================
.text$mn:000016BC
.text$mn:000016BC ; Attributes: bp-based frame
.text$mn:000016BC
.text$mn:000016BC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000016BC                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000016BC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000016BC                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000016BC                                         ; DATA XREF: .rdata:00001D88o
.text$mn:000016BC
.text$mn:000016BC var_1C          = dword ptr -1Ch
.text$mn:000016BC var_18          = dword ptr -18h
.text$mn:000016BC Str             = dword ptr -14h
.text$mn:000016BC var_10          = dword ptr -10h
.text$mn:000016BC var_C           = dword ptr -0Ch
.text$mn:000016BC var_4           = dword ptr -4
.text$mn:000016BC arg_0           = dword ptr  8
.text$mn:000016BC arg_4           = dword ptr  0Ch
.text$mn:000016BC
.text$mn:000016BC                 push    ebp
.text$mn:000016BD                 mov     ebp, esp
.text$mn:000016BF                 push    0FFFFFFFFh
.text$mn:000016C1                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000016C6                 mov     eax, large fs:0
.text$mn:000016CC                 push    eax
.text$mn:000016CD                 sub     esp, 10h
.text$mn:000016D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016D5                 xor     eax, ebp
.text$mn:000016D7                 push    eax
.text$mn:000016D8                 lea     eax, [ebp+var_C]
.text$mn:000016DB                 mov     large fs:0, eax
.text$mn:000016E1                 mov     [ebp+var_1C], ecx
.text$mn:000016E4                 mov     [ebp+var_18], 0
.text$mn:000016EB                 mov     eax, [ebp+arg_4]
.text$mn:000016EE                 push    eax             ; int
.text$mn:000016EF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000016F4                 add     esp, 4
.text$mn:000016F7                 mov     [ebp+var_10], eax
.text$mn:000016FA                 cmp     [ebp+var_10], 0
.text$mn:000016FE                 jz      short loc_1708
.text$mn:00001700                 mov     ecx, [ebp+var_10]
.text$mn:00001703                 mov     [ebp+Str], ecx
.text$mn:00001706                 jmp     short loc_170F
.text$mn:00001708 ; ---------------------------------------------------------------------------
.text$mn:00001708
.text$mn:00001708 loc_1708:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00001708                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000170F
.text$mn:0000170F loc_170F:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000170F                 mov     edx, [ebp+Str]
.text$mn:00001712                 push    edx             ; Str
.text$mn:00001713                 mov     ecx, [ebp+arg_0]
.text$mn:00001716                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000171B                 mov     [ebp+var_4], 0
.text$mn:00001722                 mov     eax, [ebp+var_18]
.text$mn:00001725                 or      eax, 1
.text$mn:00001728                 mov     [ebp+var_18], eax
.text$mn:0000172B                 mov     eax, [ebp+arg_0]
.text$mn:0000172E                 mov     ecx, [ebp+var_C]
.text$mn:00001731                 mov     large fs:0, ecx
.text$mn:00001738                 pop     ecx
.text$mn:00001739                 mov     esp, ebp
.text$mn:0000173B                 pop     ebp
.text$mn:0000173C                 retn    8
.text$mn:0000173C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000173C
.text$mn:0000173C ; ---------------------------------------------------------------------------
.text$mn:0000173F                 align 10h
.text$mn:0000173F _text$mn        ends
.text$mn:0000173F
.text$x:00001740 ; ===========================================================================
.text$x:00001740
.text$x:00001740 ; Segment type: Pure code
.text$x:00001740 ; Segment permissions: Read/Execute
.text$x:00001740 _text$x         segment para public 'CODE' use32
.text$x:00001740                 assume cs:_text$x
.text$x:00001740                 ;org 1740h
.text$x:00001740 ; COMDAT (pick associative to section at 16BC)
.text$x:00001740                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001740
.text$x:00001740 ; =============== S U B R O U T I N E =======================================
.text$x:00001740
.text$x:00001740
.text$x:00001740 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001740                                         ; DATA XREF: .xdata$x:00001BA8o
.text$x:00001740                 mov     eax, [ebp-18h]
.text$x:00001743                 and     eax, 1
.text$x:00001746                 jz      $LN6
.text$x:0000174C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001750                 mov     ecx, [ebp+8]
.text$x:00001753                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001758 ; ---------------------------------------------------------------------------
.text$x:00001758
.text$x:00001758 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001758                 retn
.text$x:00001758 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001758
.text$x:00001759
.text$x:00001759 ; =============== S U B R O U T I N E =======================================
.text$x:00001759
.text$x:00001759
.text$x:00001759 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001759                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00001759
.text$x:00001759 arg_4           = dword ptr  8
.text$x:00001759
.text$x:00001759                 mov     edx, [esp+arg_4]
.text$x:0000175D                 lea     eax, [edx+0Ch]
.text$x:00001760                 mov     ecx, [edx-14h]
.text$x:00001763                 xor     ecx, eax
.text$x:00001765                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000176A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000176F                 jmp     ___CxxFrameHandler3
.text$x:0000176F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000176F
.text$x:0000176F _text$x         ends
.text$x:0000176F
.text$mn:00001774 ; ===========================================================================
.text$mn:00001774
.text$mn:00001774 ; Segment type: Pure code
.text$mn:00001774 ; Segment permissions: Read/Execute
.text$mn:00001774 _text$mn        segment para public 'CODE' use32
.text$mn:00001774                 assume cs:_text$mn
.text$mn:00001774                 ;org 1774h
.text$mn:00001774 ; COMDAT (pick any)
.text$mn:00001774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001774
.text$mn:00001774 ; =============== S U B R O U T I N E =======================================
.text$mn:00001774
.text$mn:00001774 ; Attributes: bp-based frame
.text$mn:00001774
.text$mn:00001774 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00001774                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001774 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001774                                         ; DATA XREF: .rdata:00001DBCo
.text$mn:00001774
.text$mn:00001774 var_14          = dword ptr -14h
.text$mn:00001774 var_10          = dword ptr -10h
.text$mn:00001774 var_C           = dword ptr -0Ch
.text$mn:00001774 var_4           = dword ptr -4
.text$mn:00001774 arg_0           = dword ptr  8
.text$mn:00001774 arg_4           = dword ptr  0Ch
.text$mn:00001774
.text$mn:00001774                 push    ebp
.text$mn:00001775                 mov     ebp, esp
.text$mn:00001777                 push    0FFFFFFFFh
.text$mn:00001779                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000177E                 mov     eax, large fs:0
.text$mn:00001784                 push    eax
.text$mn:00001785                 sub     esp, 8
.text$mn:00001788                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000178D                 xor     eax, ebp
.text$mn:0000178F                 push    eax
.text$mn:00001790                 lea     eax, [ebp+var_C]
.text$mn:00001793                 mov     large fs:0, eax
.text$mn:00001799                 mov     [ebp+var_14], ecx
.text$mn:0000179C                 mov     [ebp+var_10], 0
.text$mn:000017A3                 cmp     [ebp+arg_4], 1
.text$mn:000017A7                 jnz     short loc_17CD
.text$mn:000017A9                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000017AE                 mov     ecx, [ebp+arg_0]
.text$mn:000017B1                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000017B6                 mov     [ebp+var_4], 0
.text$mn:000017BD                 mov     eax, [ebp+var_10]
.text$mn:000017C0                 or      eax, 1
.text$mn:000017C3                 mov     [ebp+var_10], eax
.text$mn:000017C6                 mov     eax, [ebp+arg_0]
.text$mn:000017C9                 jmp     short loc_17F0
.text$mn:000017CB ; ---------------------------------------------------------------------------
.text$mn:000017CB                 jmp     short loc_17F0
.text$mn:000017CD ; ---------------------------------------------------------------------------
.text$mn:000017CD
.text$mn:000017CD loc_17CD:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:000017CD                 mov     ecx, [ebp+arg_4]
.text$mn:000017D0                 push    ecx
.text$mn:000017D1                 mov     edx, [ebp+arg_0]
.text$mn:000017D4                 push    edx
.text$mn:000017D5                 mov     ecx, [ebp+var_14]
.text$mn:000017D8                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000017DD                 mov     [ebp+var_4], 0
.text$mn:000017E4                 mov     eax, [ebp+var_10]
.text$mn:000017E7                 or      eax, 1
.text$mn:000017EA                 mov     [ebp+var_10], eax
.text$mn:000017ED                 mov     eax, [ebp+arg_0]
.text$mn:000017F0
.text$mn:000017F0 loc_17F0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000017F0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000017F0                 mov     ecx, [ebp+var_C]
.text$mn:000017F3                 mov     large fs:0, ecx
.text$mn:000017FA                 pop     ecx
.text$mn:000017FB                 mov     esp, ebp
.text$mn:000017FD                 pop     ebp
.text$mn:000017FE                 retn    8
.text$mn:000017FE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000017FE
.text$mn:000017FE ; ---------------------------------------------------------------------------
.text$mn:00001801                 align 4
.text$mn:00001801 _text$mn        ends
.text$mn:00001801
.text$x:00001804 ; ===========================================================================
.text$x:00001804
.text$x:00001804 ; Segment type: Pure code
.text$x:00001804 ; Segment permissions: Read/Execute
.text$x:00001804 _text$x         segment para public 'CODE' use32
.text$x:00001804                 assume cs:_text$x
.text$x:00001804                 ;org 1804h
.text$x:00001804 ; COMDAT (pick associative to section at 1774)
.text$x:00001804                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001804
.text$x:00001804 ; =============== S U B R O U T I N E =======================================
.text$x:00001804
.text$x:00001804
.text$x:00001804 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001804                                         ; DATA XREF: .xdata$x:00001C2Co
.text$x:00001804                 mov     eax, [ebp-10h]
.text$x:00001807                 and     eax, 1
.text$x:0000180A                 jz      $LN6_0
.text$x:00001810                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001814                 mov     ecx, [ebp+8]
.text$x:00001817                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000181C ; ---------------------------------------------------------------------------
.text$x:0000181C
.text$x:0000181C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000181C                 retn
.text$x:0000181C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000181C
.text$x:0000181D
.text$x:0000181D ; =============== S U B R O U T I N E =======================================
.text$x:0000181D
.text$x:0000181D
.text$x:0000181D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000181D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:0000181D
.text$x:0000181D arg_4           = dword ptr  8
.text$x:0000181D
.text$x:0000181D                 mov     edx, [esp+arg_4]
.text$x:00001821                 lea     eax, [edx+0Ch]
.text$x:00001824                 mov     ecx, [edx-0Ch]
.text$x:00001827                 xor     ecx, eax
.text$x:00001829                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000182E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001833                 jmp     ___CxxFrameHandler3
.text$x:00001833 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001833
.text$x:00001833 _text$x         ends
.text$x:00001833
.text$mn:00001838 ; ===========================================================================
.text$mn:00001838
.text$mn:00001838 ; Segment type: Pure code
.text$mn:00001838 ; Segment permissions: Read/Execute
.text$mn:00001838 _text$mn        segment para public 'CODE' use32
.text$mn:00001838                 assume cs:_text$mn
.text$mn:00001838                 ;org 1838h
.text$mn:00001838 ; COMDAT (pick any)
.text$mn:00001838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001838
.text$mn:00001838 ; =============== S U B R O U T I N E =======================================
.text$mn:00001838
.text$mn:00001838 ; Attributes: bp-based frame
.text$mn:00001838
.text$mn:00001838 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00001838                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001838 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001838                                         ; DATA XREF: .rdata:00001DFCo
.text$mn:00001838
.text$mn:00001838 var_1C          = dword ptr -1Ch
.text$mn:00001838 var_18          = dword ptr -18h
.text$mn:00001838 Str             = dword ptr -14h
.text$mn:00001838 var_10          = dword ptr -10h
.text$mn:00001838 var_C           = dword ptr -0Ch
.text$mn:00001838 var_4           = dword ptr -4
.text$mn:00001838 arg_0           = dword ptr  8
.text$mn:00001838 arg_4           = dword ptr  0Ch
.text$mn:00001838
.text$mn:00001838                 push    ebp
.text$mn:00001839                 mov     ebp, esp
.text$mn:0000183B                 push    0FFFFFFFFh
.text$mn:0000183D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001842                 mov     eax, large fs:0
.text$mn:00001848                 push    eax
.text$mn:00001849                 sub     esp, 10h
.text$mn:0000184C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001851                 xor     eax, ebp
.text$mn:00001853                 push    eax
.text$mn:00001854                 lea     eax, [ebp+var_C]
.text$mn:00001857                 mov     large fs:0, eax
.text$mn:0000185D                 mov     [ebp+var_1C], ecx
.text$mn:00001860                 mov     [ebp+var_18], 0
.text$mn:00001867                 mov     eax, [ebp+arg_4]
.text$mn:0000186A                 push    eax             ; int
.text$mn:0000186B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00001870                 add     esp, 4
.text$mn:00001873                 mov     [ebp+var_10], eax
.text$mn:00001876                 cmp     [ebp+var_10], 0
.text$mn:0000187A                 jz      short loc_1884
.text$mn:0000187C                 mov     ecx, [ebp+var_10]
.text$mn:0000187F                 mov     [ebp+Str], ecx
.text$mn:00001882                 jmp     short loc_188B
.text$mn:00001884 ; ---------------------------------------------------------------------------
.text$mn:00001884
.text$mn:00001884 loc_1884:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00001884                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000188B
.text$mn:0000188B loc_188B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000188B                 mov     edx, [ebp+Str]
.text$mn:0000188E                 push    edx             ; Str
.text$mn:0000188F                 mov     ecx, [ebp+arg_0]
.text$mn:00001892                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001897                 mov     [ebp+var_4], 0
.text$mn:0000189E                 mov     eax, [ebp+var_18]
.text$mn:000018A1                 or      eax, 1
.text$mn:000018A4                 mov     [ebp+var_18], eax
.text$mn:000018A7                 mov     eax, [ebp+arg_0]
.text$mn:000018AA                 mov     ecx, [ebp+var_C]
.text$mn:000018AD                 mov     large fs:0, ecx
.text$mn:000018B4                 pop     ecx
.text$mn:000018B5                 mov     esp, ebp
.text$mn:000018B7                 pop     ebp
.text$mn:000018B8                 retn    8
.text$mn:000018B8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000018B8
.text$mn:000018B8 ; ---------------------------------------------------------------------------
.text$mn:000018BB                 align 4
.text$mn:000018BB _text$mn        ends
.text$mn:000018BB
.text$x:000018BC ; ===========================================================================
.text$x:000018BC
.text$x:000018BC ; Segment type: Pure code
.text$x:000018BC ; Segment permissions: Read/Execute
.text$x:000018BC _text$x         segment para public 'CODE' use32
.text$x:000018BC                 assume cs:_text$x
.text$x:000018BC                 ;org 18BCh
.text$x:000018BC ; COMDAT (pick associative to section at 1838)
.text$x:000018BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000018BC
.text$x:000018BC ; =============== S U B R O U T I N E =======================================
.text$x:000018BC
.text$x:000018BC
.text$x:000018BC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000018BC                                         ; DATA XREF: .xdata$x:00001CB0o
.text$x:000018BC                 mov     eax, [ebp-18h]
.text$x:000018BF                 and     eax, 1
.text$x:000018C2                 jz      $LN6_1
.text$x:000018C8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000018CC                 mov     ecx, [ebp+8]
.text$x:000018CF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000018D4 ; ---------------------------------------------------------------------------
.text$x:000018D4
.text$x:000018D4 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000018D4                 retn
.text$x:000018D4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000018D4
.text$x:000018D5
.text$x:000018D5 ; =============== S U B R O U T I N E =======================================
.text$x:000018D5
.text$x:000018D5
.text$x:000018D5 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000018D5                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000018D5
.text$x:000018D5 arg_4           = dword ptr  8
.text$x:000018D5
.text$x:000018D5                 mov     edx, [esp+arg_4]
.text$x:000018D9                 lea     eax, [edx+0Ch]
.text$x:000018DC                 mov     ecx, [edx-14h]
.text$x:000018DF                 xor     ecx, eax
.text$x:000018E1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018E6                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000018EB                 jmp     ___CxxFrameHandler3
.text$x:000018EB __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000018EB
.text$x:000018EB _text$x         ends
.text$x:000018EB
.text$mn:000018F0 ; ===========================================================================
.text$mn:000018F0
.text$mn:000018F0 ; Segment type: Pure code
.text$mn:000018F0 ; Segment permissions: Read/Execute
.text$mn:000018F0 _text$mn        segment para public 'CODE' use32
.text$mn:000018F0                 assume cs:_text$mn
.text$mn:000018F0                 ;org 18F0h
.text$mn:000018F0 ; COMDAT (pick any)
.text$mn:000018F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018F0
.text$mn:000018F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018F0
.text$mn:000018F0 ; Attributes: bp-based frame
.text$mn:000018F0
.text$mn:000018F0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000018F0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000018F0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000018F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000018F0
.text$mn:000018F0 var_4           = dword ptr -4
.text$mn:000018F0 Dst             = dword ptr  8
.text$mn:000018F0 Src             = dword ptr  0Ch
.text$mn:000018F0 Size            = dword ptr  10h
.text$mn:000018F0
.text$mn:000018F0                 push    ebp
.text$mn:000018F1                 mov     ebp, esp
.text$mn:000018F3                 push    ecx
.text$mn:000018F4                 cmp     [ebp+Size], 0
.text$mn:000018F8                 jnz     short loc_1902
.text$mn:000018FA                 mov     eax, [ebp+Dst]
.text$mn:000018FD                 mov     [ebp+var_4], eax
.text$mn:00001900                 jmp     short loc_1919
.text$mn:00001902 ; ---------------------------------------------------------------------------
.text$mn:00001902
.text$mn:00001902 loc_1902:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00001902                 mov     ecx, [ebp+Size]
.text$mn:00001905                 push    ecx             ; Size
.text$mn:00001906                 mov     edx, [ebp+Src]
.text$mn:00001909                 push    edx             ; Src
.text$mn:0000190A                 mov     eax, [ebp+Dst]
.text$mn:0000190D                 push    eax             ; Dst
.text$mn:0000190E                 call    _memmove
.text$mn:00001913                 add     esp, 0Ch
.text$mn:00001916                 mov     [ebp+var_4], eax
.text$mn:00001919
.text$mn:00001919 loc_1919:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00001919                 mov     eax, [ebp+var_4]
.text$mn:0000191C                 mov     esp, ebp
.text$mn:0000191E                 pop     ebp
.text$mn:0000191F                 retn
.text$mn:0000191F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000191F
.text$mn:0000191F _text$mn        ends
.text$mn:0000191F
.text$mn:00001920 ; ===========================================================================
.text$mn:00001920
.text$mn:00001920 ; Segment type: Pure code
.text$mn:00001920 ; Segment permissions: Read/Execute
.text$mn:00001920 _text$mn        segment para public 'CODE' use32
.text$mn:00001920                 assume cs:_text$mn
.text$mn:00001920                 ;org 1920h
.text$mn:00001920 ; COMDAT (pick any)
.text$mn:00001920                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001920
.text$mn:00001920 ; =============== S U B R O U T I N E =======================================
.text$mn:00001920
.text$mn:00001920 ; Attributes: bp-based frame
.text$mn:00001920
.text$mn:00001920 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00001920                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00001920 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00001920                                         ; DATA XREF: .rdata:00001D84o
.text$mn:00001920
.text$mn:00001920 var_4           = dword ptr -4
.text$mn:00001920
.text$mn:00001920                 push    ebp
.text$mn:00001921                 mov     ebp, esp
.text$mn:00001923                 push    ecx
.text$mn:00001924                 mov     [ebp+var_4], ecx
.text$mn:00001927                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000192C                 mov     esp, ebp
.text$mn:0000192E                 pop     ebp
.text$mn:0000192F                 retn
.text$mn:0000192F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000192F
.text$mn:0000192F _text$mn        ends
.text$mn:0000192F
.text$mn:00001930 ; ===========================================================================
.text$mn:00001930
.text$mn:00001930 ; Segment type: Pure code
.text$mn:00001930 ; Segment permissions: Read/Execute
.text$mn:00001930 _text$mn        segment para public 'CODE' use32
.text$mn:00001930                 assume cs:_text$mn
.text$mn:00001930                 ;org 1930h
.text$mn:00001930 ; COMDAT (pick any)
.text$mn:00001930                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001930
.text$mn:00001930 ; =============== S U B R O U T I N E =======================================
.text$mn:00001930
.text$mn:00001930 ; Attributes: bp-based frame
.text$mn:00001930
.text$mn:00001930 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00001930                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00001930 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00001930                                         ; DATA XREF: .rdata:00001DB8o
.text$mn:00001930
.text$mn:00001930 var_4           = dword ptr -4
.text$mn:00001930
.text$mn:00001930                 push    ebp
.text$mn:00001931                 mov     ebp, esp
.text$mn:00001933                 push    ecx
.text$mn:00001934                 mov     [ebp+var_4], ecx
.text$mn:00001937                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000193C                 mov     esp, ebp
.text$mn:0000193E                 pop     ebp
.text$mn:0000193F                 retn
.text$mn:0000193F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000193F
.text$mn:0000193F _text$mn        ends
.text$mn:0000193F
.text$mn:00001940 ; ===========================================================================
.text$mn:00001940
.text$mn:00001940 ; Segment type: Pure code
.text$mn:00001940 ; Segment permissions: Read/Execute
.text$mn:00001940 _text$mn        segment para public 'CODE' use32
.text$mn:00001940                 assume cs:_text$mn
.text$mn:00001940                 ;org 1940h
.text$mn:00001940 ; COMDAT (pick any)
.text$mn:00001940                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001940
.text$mn:00001940 ; =============== S U B R O U T I N E =======================================
.text$mn:00001940
.text$mn:00001940 ; Attributes: bp-based frame
.text$mn:00001940
.text$mn:00001940 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00001940                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00001940 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00001940                                         ; DATA XREF: .rdata:00001DF8o
.text$mn:00001940
.text$mn:00001940 var_4           = dword ptr -4
.text$mn:00001940
.text$mn:00001940                 push    ebp
.text$mn:00001941                 mov     ebp, esp
.text$mn:00001943                 push    ecx
.text$mn:00001944                 mov     [ebp+var_4], ecx
.text$mn:00001947                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000194C                 mov     esp, ebp
.text$mn:0000194E                 pop     ebp
.text$mn:0000194F                 retn
.text$mn:0000194F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000194F
.text$mn:0000194F _text$mn        ends
.text$mn:0000194F
.text$mn:00001950 ; ===========================================================================
.text$mn:00001950
.text$mn:00001950 ; Segment type: Pure code
.text$mn:00001950 ; Segment permissions: Read/Execute
.text$mn:00001950 _text$mn        segment para public 'CODE' use32
.text$mn:00001950                 assume cs:_text$mn
.text$mn:00001950                 ;org 1950h
.text$mn:00001950 ; COMDAT (pick any)
.text$mn:00001950                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001950
.text$mn:00001950 ; =============== S U B R O U T I N E =======================================
.text$mn:00001950
.text$mn:00001950 ; Attributes: bp-based frame
.text$mn:00001950
.text$mn:00001950 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00001950                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001950 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001950                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00001950                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00001950
.text$mn:00001950 var_4           = dword ptr -4
.text$mn:00001950
.text$mn:00001950                 push    ebp
.text$mn:00001951                 mov     ebp, esp
.text$mn:00001953                 push    ecx
.text$mn:00001954                 mov     [ebp+var_4], ecx
.text$mn:00001957                 mov     eax, [ebp+var_4]
.text$mn:0000195A                 mov     eax, [eax+14h]
.text$mn:0000195D                 mov     esp, ebp
.text$mn:0000195F                 pop     ebp
.text$mn:00001960                 retn
.text$mn:00001960 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001960
.text$mn:00001960 ; ---------------------------------------------------------------------------
.text$mn:00001961                 align 4
.text$mn:00001961 _text$mn        ends
.text$mn:00001961
.text$mn:00001964 ; ===========================================================================
.text$mn:00001964
.text$mn:00001964 ; Segment type: Pure code
.text$mn:00001964 ; Segment permissions: Read/Execute
.text$mn:00001964 _text$mn        segment para public 'CODE' use32
.text$mn:00001964                 assume cs:_text$mn
.text$mn:00001964                 ;org 1964h
.text$mn:00001964 ; COMDAT (pick any)
.text$mn:00001964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001964
.text$mn:00001964 ; =============== S U B R O U T I N E =======================================
.text$mn:00001964
.text$mn:00001964 ; Attributes: bp-based frame
.text$mn:00001964
.text$mn:00001964 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00001964                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00001964 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001964                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_149Cp
.text$mn:00001964                 push    ebp
.text$mn:00001965                 mov     ebp, esp
.text$mn:00001967                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:0000196C                 pop     ebp
.text$mn:0000196D                 retn
.text$mn:0000196D ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000196D
.text$mn:0000196D ; ---------------------------------------------------------------------------
.text$mn:0000196E                 align 10h
.text$mn:0000196E _text$mn        ends
.text$mn:0000196E
.text$mn:00001970 ; ===========================================================================
.text$mn:00001970
.text$mn:00001970 ; Segment type: Pure code
.text$mn:00001970 ; Segment permissions: Read/Execute
.text$mn:00001970 _text$mn        segment para public 'CODE' use32
.text$mn:00001970                 assume cs:_text$mn
.text$mn:00001970                 ;org 1970h
.text$mn:00001970 ; COMDAT (pick any)
.text$mn:00001970                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001970
.text$mn:00001970 ; =============== S U B R O U T I N E =======================================
.text$mn:00001970
.text$mn:00001970 ; Attributes: bp-based frame
.text$mn:00001970
.text$mn:00001970 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00001970                 public ?value@error_code@std@@QBEHXZ
.text$mn:00001970 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00001970
.text$mn:00001970 var_4           = dword ptr -4
.text$mn:00001970
.text$mn:00001970                 push    ebp
.text$mn:00001971                 mov     ebp, esp
.text$mn:00001973                 push    ecx
.text$mn:00001974                 mov     [ebp+var_4], ecx
.text$mn:00001977                 mov     eax, [ebp+var_4]
.text$mn:0000197A                 mov     eax, [eax]
.text$mn:0000197C                 mov     esp, ebp
.text$mn:0000197E                 pop     ebp
.text$mn:0000197F                 retn
.text$mn:0000197F ?value@error_code@std@@QBEHXZ endp
.text$mn:0000197F
.text$mn:0000197F _text$mn        ends
.text$mn:0000197F
.text$mn:00001980 ; ===========================================================================
.text$mn:00001980
.text$mn:00001980 ; Segment type: Pure code
.text$mn:00001980 ; Segment permissions: Read/Execute
.text$mn:00001980 _text$mn        segment para public 'CODE' use32
.text$mn:00001980                 assume cs:_text$mn
.text$mn:00001980                 ;org 1980h
.text$mn:00001980 ; COMDAT (pick any)
.text$mn:00001980                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001980
.text$mn:00001980 ; =============== S U B R O U T I N E =======================================
.text$mn:00001980
.text$mn:00001980 ; Attributes: bp-based frame
.text$mn:00001980
.text$mn:00001980 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00001980                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00001980 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00001980                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00001980                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00001980
.text$mn:00001980 var_4           = dword ptr -4
.text$mn:00001980
.text$mn:00001980                 push    ebp
.text$mn:00001981                 mov     ebp, esp
.text$mn:00001983                 push    ecx
.text$mn:00001984                 mov     [ebp+var_4], ecx
.text$mn:00001987                 mov     eax, [ebp+var_4]
.text$mn:0000198A                 mov     eax, [eax]
.text$mn:0000198C                 mov     esp, ebp
.text$mn:0000198E                 pop     ebp
.text$mn:0000198F                 retn
.text$mn:0000198F ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000198F
.text$mn:0000198F _text$mn        ends
.text$mn:0000198F
.text$mn:00001990 ; ===========================================================================
.text$mn:00001990
.text$mn:00001990 ; Segment type: Pure code
.text$mn:00001990 ; Segment permissions: Read/Execute
.text$mn:00001990 _text$mn        segment para public 'CODE' use32
.text$mn:00001990                 assume cs:_text$mn
.text$mn:00001990                 ;org 1990h
.text$mn:00001990 ; COMDAT (pick any)
.text$mn:00001990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001990
.text$mn:00001990 ; =============== S U B R O U T I N E =======================================
.text$mn:00001990
.text$mn:00001990 ; Attributes: bp-based frame
.text$mn:00001990
.text$mn:00001990                 public _hypot
.text$mn:00001990 _hypot          proc near
.text$mn:00001990
.text$mn:00001990 var_10          = qword ptr -10h
.text$mn:00001990 var_8           = qword ptr -8
.text$mn:00001990 arg_0           = qword ptr  8
.text$mn:00001990 arg_8           = qword ptr  10h
.text$mn:00001990
.text$mn:00001990                 push    ebp
.text$mn:00001991                 mov     ebp, esp
.text$mn:00001993                 sub     esp, 8
.text$mn:00001996                 movsd   xmm0, [ebp+arg_8]
.text$mn:0000199B                 movsd   [esp+8+var_8], xmm0
.text$mn:000019A0                 sub     esp, 8
.text$mn:000019A3                 movsd   xmm0, [ebp+arg_0]
.text$mn:000019A8                 movsd   [esp+10h+var_10], xmm0
.text$mn:000019AD                 call    __hypot
.text$mn:000019B2                 add     esp, 10h
.text$mn:000019B5                 pop     ebp
.text$mn:000019B6                 retn
.text$mn:000019B6 _hypot          endp
.text$mn:000019B6
.text$mn:000019B6 ; ---------------------------------------------------------------------------
.text$mn:000019B7                 align 4
.text$mn:000019B7 _text$mn        ends
.text$mn:000019B7
.xdata$x:000019B8 ; ===========================================================================
.xdata$x:000019B8
.xdata$x:000019B8 ; Segment type: Pure data
.xdata$x:000019B8 ; Segment permissions: Read
.xdata$x:000019B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000019B8                 assume cs:_xdata$x
.xdata$x:000019B8                 ;org 19B8h
.xdata$x:000019B8 ; COMDAT (pick associative to section at 102C)
.xdata$x:000019B8 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:000019B8                                         ; DATA XREF: .xdata$x:000019C8o
.xdata$x:000019B9                 db 0FFh
.xdata$x:000019BA                 db 0FFh
.xdata$x:000019BB                 db 0FFh
.xdata$x:000019BC                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:000019C0 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:000019C0                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:000019C1                 db    5
.xdata$x:000019C2                 db  93h ; 
.xdata$x:000019C3                 db  19h
.xdata$x:000019C4                 db    1
.xdata$x:000019C5                 db    0
.xdata$x:000019C6                 db    0
.xdata$x:000019C7                 db    0
.xdata$x:000019C8                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:000019CC                 db    0
.xdata$x:000019CD                 db    0
.xdata$x:000019CE                 db    0
.xdata$x:000019CF                 db    0
.xdata$x:000019D0                 db    0
.xdata$x:000019D1                 db    0
.xdata$x:000019D2                 db    0
.xdata$x:000019D3                 db    0
.xdata$x:000019D4                 db    0
.xdata$x:000019D5                 db    0
.xdata$x:000019D6                 db    0
.xdata$x:000019D7                 db    0
.xdata$x:000019D8                 db    0
.xdata$x:000019D9                 db    0
.xdata$x:000019DA                 db    0
.xdata$x:000019DB                 db    0
.xdata$x:000019DC                 db    0
.xdata$x:000019DD                 db    0
.xdata$x:000019DE                 db    0
.xdata$x:000019DF                 db    0
.xdata$x:000019E0                 db    0
.xdata$x:000019E1                 db    0
.xdata$x:000019E2                 db    0
.xdata$x:000019E3                 db    0
.xdata$x:000019E3 _xdata$x        ends
.xdata$x:000019E3
.xdata$x:000019E4 ; ===========================================================================
.xdata$x:000019E4
.xdata$x:000019E4 ; Segment type: Pure data
.xdata$x:000019E4 ; Segment permissions: Read
.xdata$x:000019E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000019E4                 assume cs:_xdata$x
.xdata$x:000019E4                 ;org 19E4h
.xdata$x:000019E4 ; COMDAT (pick associative to section at 394)
.xdata$x:000019E4 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000019E4                                         ; DATA XREF: .xdata$x:000019F4o
.xdata$x:000019E5                 db 0FFh
.xdata$x:000019E6                 db 0FFh
.xdata$x:000019E7                 db 0FFh
.xdata$x:000019E8                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000019EC __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000019EC                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000019ED                 db    5
.xdata$x:000019EE                 db  93h ; 
.xdata$x:000019EF                 db  19h
.xdata$x:000019F0                 db    1
.xdata$x:000019F1                 db    0
.xdata$x:000019F2                 db    0
.xdata$x:000019F3                 db    0
.xdata$x:000019F4                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000019F8                 db    0
.xdata$x:000019F9                 db    0
.xdata$x:000019FA                 db    0
.xdata$x:000019FB                 db    0
.xdata$x:000019FC                 db    0
.xdata$x:000019FD                 db    0
.xdata$x:000019FE                 db    0
.xdata$x:000019FF                 db    0
.xdata$x:00001A00                 db    0
.xdata$x:00001A01                 db    0
.xdata$x:00001A02                 db    0
.xdata$x:00001A03                 db    0
.xdata$x:00001A04                 db    0
.xdata$x:00001A05                 db    0
.xdata$x:00001A06                 db    0
.xdata$x:00001A07                 db    0
.xdata$x:00001A08                 db    0
.xdata$x:00001A09                 db    0
.xdata$x:00001A0A                 db    0
.xdata$x:00001A0B                 db    0
.xdata$x:00001A0C                 db    0
.xdata$x:00001A0D                 db    0
.xdata$x:00001A0E                 db    0
.xdata$x:00001A0F                 db    0
.xdata$x:00001A0F _xdata$x        ends
.xdata$x:00001A0F
.xdata$x:00001A10 ; ===========================================================================
.xdata$x:00001A10
.xdata$x:00001A10 ; Segment type: Pure data
.xdata$x:00001A10 ; Segment permissions: Read
.xdata$x:00001A10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001A10                 assume cs:_xdata$x
.xdata$x:00001A10                 ;org 1A10h
.xdata$x:00001A10 ; COMDAT (pick associative to section at 768)
.xdata$x:00001A10 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001A10                                         ; DATA XREF: .xdata$x:00001A20o
.xdata$x:00001A11                 db 0FFh
.xdata$x:00001A12                 db 0FFh
.xdata$x:00001A13                 db 0FFh
.xdata$x:00001A14                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001A18 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001A18                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001A19                 db    5
.xdata$x:00001A1A                 db  93h ; 
.xdata$x:00001A1B                 db  19h
.xdata$x:00001A1C                 db    1
.xdata$x:00001A1D                 db    0
.xdata$x:00001A1E                 db    0
.xdata$x:00001A1F                 db    0
.xdata$x:00001A20                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001A24                 db    0
.xdata$x:00001A25                 db    0
.xdata$x:00001A26                 db    0
.xdata$x:00001A27                 db    0
.xdata$x:00001A28                 db    0
.xdata$x:00001A29                 db    0
.xdata$x:00001A2A                 db    0
.xdata$x:00001A2B                 db    0
.xdata$x:00001A2C                 db    0
.xdata$x:00001A2D                 db    0
.xdata$x:00001A2E                 db    0
.xdata$x:00001A2F                 db    0
.xdata$x:00001A30                 db    0
.xdata$x:00001A31                 db    0
.xdata$x:00001A32                 db    0
.xdata$x:00001A33                 db    0
.xdata$x:00001A34                 db    0
.xdata$x:00001A35                 db    0
.xdata$x:00001A36                 db    0
.xdata$x:00001A37                 db    0
.xdata$x:00001A38                 db    0
.xdata$x:00001A39                 db    0
.xdata$x:00001A3A                 db    0
.xdata$x:00001A3B                 db    0
.xdata$x:00001A3B _xdata$x        ends
.xdata$x:00001A3B
.xdata$x:00001A3C ; ===========================================================================
.xdata$x:00001A3C
.xdata$x:00001A3C ; Segment type: Pure data
.xdata$x:00001A3C ; Segment permissions: Read
.xdata$x:00001A3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001A3C                 assume cs:_xdata$x
.xdata$x:00001A3C                 ;org 1A3Ch
.xdata$x:00001A3C ; COMDAT (pick associative to section at 318)
.xdata$x:00001A3C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00001A3C                                         ; DATA XREF: .xdata$x:00001A4Co
.xdata$x:00001A3D                 db 0FFh
.xdata$x:00001A3E                 db 0FFh
.xdata$x:00001A3F                 db 0FFh
.xdata$x:00001A40                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00001A44 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00001A44                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00001A45                 db    5
.xdata$x:00001A46                 db  93h ; 
.xdata$x:00001A47                 db  19h
.xdata$x:00001A48                 db    1
.xdata$x:00001A49                 db    0
.xdata$x:00001A4A                 db    0
.xdata$x:00001A4B                 db    0
.xdata$x:00001A4C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00001A50                 db    0
.xdata$x:00001A51                 db    0
.xdata$x:00001A52                 db    0
.xdata$x:00001A53                 db    0
.xdata$x:00001A54                 db    0
.xdata$x:00001A55                 db    0
.xdata$x:00001A56                 db    0
.xdata$x:00001A57                 db    0
.xdata$x:00001A58                 db    0
.xdata$x:00001A59                 db    0
.xdata$x:00001A5A                 db    0
.xdata$x:00001A5B                 db    0
.xdata$x:00001A5C                 db    0
.xdata$x:00001A5D                 db    0
.xdata$x:00001A5E                 db    0
.xdata$x:00001A5F                 db    0
.xdata$x:00001A60                 db    0
.xdata$x:00001A61                 db    0
.xdata$x:00001A62                 db    0
.xdata$x:00001A63                 db    0
.xdata$x:00001A64                 db    0
.xdata$x:00001A65                 db    0
.xdata$x:00001A66                 db    0
.xdata$x:00001A67                 db    0
.xdata$x:00001A67 _xdata$x        ends
.xdata$x:00001A67
.xdata$x:00001A68 ; ===========================================================================
.xdata$x:00001A68
.xdata$x:00001A68 ; Segment type: Pure data
.xdata$x:00001A68 ; Segment permissions: Read
.xdata$x:00001A68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001A68                 assume cs:_xdata$x
.xdata$x:00001A68                 ;org 1A68h
.xdata$x:00001A68 ; COMDAT (pick associative to section at 6F0)
.xdata$x:00001A68 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001A68                                         ; DATA XREF: .xdata$x:00001A78o
.xdata$x:00001A69                 db 0FFh
.xdata$x:00001A6A                 db 0FFh
.xdata$x:00001A6B                 db 0FFh
.xdata$x:00001A6C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00001A70 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001A70                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00001A71                 db    5
.xdata$x:00001A72                 db  93h ; 
.xdata$x:00001A73                 db  19h
.xdata$x:00001A74                 db    1
.xdata$x:00001A75                 db    0
.xdata$x:00001A76                 db    0
.xdata$x:00001A77                 db    0
.xdata$x:00001A78                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00001A7C                 db    0
.xdata$x:00001A7D                 db    0
.xdata$x:00001A7E                 db    0
.xdata$x:00001A7F                 db    0
.xdata$x:00001A80                 db    0
.xdata$x:00001A81                 db    0
.xdata$x:00001A82                 db    0
.xdata$x:00001A83                 db    0
.xdata$x:00001A84                 db    0
.xdata$x:00001A85                 db    0
.xdata$x:00001A86                 db    0
.xdata$x:00001A87                 db    0
.xdata$x:00001A88                 db    0
.xdata$x:00001A89                 db    0
.xdata$x:00001A8A                 db    0
.xdata$x:00001A8B                 db    0
.xdata$x:00001A8C                 db    0
.xdata$x:00001A8D                 db    0
.xdata$x:00001A8E                 db    0
.xdata$x:00001A8F                 db    0
.xdata$x:00001A90                 db    0
.xdata$x:00001A91                 db    0
.xdata$x:00001A92                 db    0
.xdata$x:00001A93                 db    0
.xdata$x:00001A93 _xdata$x        ends
.xdata$x:00001A93
.xdata$x:00001A94 ; ===========================================================================
.xdata$x:00001A94
.xdata$x:00001A94 ; Segment type: Pure data
.xdata$x:00001A94 ; Segment permissions: Read
.xdata$x:00001A94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001A94                 assume cs:_xdata$x
.xdata$x:00001A94                 ;org 1A94h
.xdata$x:00001A94 ; COMDAT (pick associative to section at 454)
.xdata$x:00001A94 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00001A94                                         ; DATA XREF: .xdata$x:00001AA4o
.xdata$x:00001A95                 db 0FFh
.xdata$x:00001A96                 db 0FFh
.xdata$x:00001A97                 db 0FFh
.xdata$x:00001A98                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00001A9C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00001A9C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00001A9D                 db    5
.xdata$x:00001A9E                 db  93h ; 
.xdata$x:00001A9F                 db  19h
.xdata$x:00001AA0                 db    1
.xdata$x:00001AA1                 db    0
.xdata$x:00001AA2                 db    0
.xdata$x:00001AA3                 db    0
.xdata$x:00001AA4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00001AA8                 align 20h
.xdata$x:00001AA8 _xdata$x        ends
.xdata$x:00001AA8
.xdata$x:00001AC0 ; ===========================================================================
.xdata$x:00001AC0
.xdata$x:00001AC0 ; Segment type: Pure data
.xdata$x:00001AC0 ; Segment permissions: Read
.xdata$x:00001AC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001AC0                 assume cs:_xdata$x
.xdata$x:00001AC0                 ;org 1AC0h
.xdata$x:00001AC0 ; COMDAT (pick associative to section at 7D8)
.xdata$x:00001AC0 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00001AC0                                         ; DATA XREF: .xdata$x:00001AD0o
.xdata$x:00001AC1                 db 0FFh
.xdata$x:00001AC2                 db 0FFh
.xdata$x:00001AC3                 db 0FFh
.xdata$x:00001AC4                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00001AC8 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00001AC8                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00001AC9                 db    5
.xdata$x:00001ACA                 db  93h ; 
.xdata$x:00001ACB                 db  19h
.xdata$x:00001ACC                 db    1
.xdata$x:00001ACD                 db    0
.xdata$x:00001ACE                 db    0
.xdata$x:00001ACF                 db    0
.xdata$x:00001AD0                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00001AD4                 db    0
.xdata$x:00001AD5                 db    0
.xdata$x:00001AD6                 db    0
.xdata$x:00001AD7                 db    0
.xdata$x:00001AD8                 db    0
.xdata$x:00001AD9                 db    0
.xdata$x:00001ADA                 db    0
.xdata$x:00001ADB                 db    0
.xdata$x:00001ADC                 db    0
.xdata$x:00001ADD                 db    0
.xdata$x:00001ADE                 db    0
.xdata$x:00001ADF                 db    0
.xdata$x:00001AE0                 db    0
.xdata$x:00001AE1                 db    0
.xdata$x:00001AE2                 db    0
.xdata$x:00001AE3                 db    0
.xdata$x:00001AE4                 db    0
.xdata$x:00001AE5                 db    0
.xdata$x:00001AE6                 db    0
.xdata$x:00001AE7                 db    0
.xdata$x:00001AE8                 db    0
.xdata$x:00001AE9                 db    0
.xdata$x:00001AEA                 db    0
.xdata$x:00001AEB                 db    0
.xdata$x:00001AEB _xdata$x        ends
.xdata$x:00001AEB
.xdata$x:00001AEC ; ===========================================================================
.xdata$x:00001AEC
.xdata$x:00001AEC ; Segment type: Pure data
.xdata$x:00001AEC ; Segment permissions: Read
.xdata$x:00001AEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001AEC                 assume cs:_xdata$x
.xdata$x:00001AEC                 ;org 1AECh
.xdata$x:00001AEC ; COMDAT (pick associative to section at C50)
.xdata$x:00001AEC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00001AEC                                         ; DATA XREF: .xdata$x:00001B74o
.xdata$x:00001AED                 db    0
.xdata$x:00001AEE                 db    0
.xdata$x:00001AEF                 db    0
.xdata$x:00001AF0                 db    0
.xdata$x:00001AF1                 db    0
.xdata$x:00001AF2                 db    0
.xdata$x:00001AF3                 db    0
.xdata$x:00001AF4                 db    0
.xdata$x:00001AF5                 db    0
.xdata$x:00001AF6                 db    0
.xdata$x:00001AF7                 db    0
.xdata$x:00001AF8                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00001AFC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00001AFC                                         ; DATA XREF: .xdata$x:00001B60o
.xdata$x:00001AFD                 db    0
.xdata$x:00001AFE                 db    0
.xdata$x:00001AFF                 db    0
.xdata$x:00001B00                 db    0
.xdata$x:00001B01                 db    0
.xdata$x:00001B02                 db    0
.xdata$x:00001B03                 db    0
.xdata$x:00001B04                 db    0
.xdata$x:00001B05                 db    0
.xdata$x:00001B06                 db    0
.xdata$x:00001B07                 db    0
.xdata$x:00001B08                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00001B0C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00001B0C                                         ; DATA XREF: .xdata$x:00001B34o
.xdata$x:00001B0D                 db 0FFh
.xdata$x:00001B0E                 db 0FFh
.xdata$x:00001B0F                 db 0FFh
.xdata$x:00001B10                 db    0
.xdata$x:00001B11                 db    0
.xdata$x:00001B12                 db    0
.xdata$x:00001B13                 db    0
.xdata$x:00001B14                 db 0FFh
.xdata$x:00001B15                 db 0FFh
.xdata$x:00001B16                 db 0FFh
.xdata$x:00001B17                 db 0FFh
.xdata$x:00001B18                 db    0
.xdata$x:00001B19                 db    0
.xdata$x:00001B1A                 db    0
.xdata$x:00001B1B                 db    0
.xdata$x:00001B1C                 db    1
.xdata$x:00001B1D                 db    0
.xdata$x:00001B1E                 db    0
.xdata$x:00001B1F                 db    0
.xdata$x:00001B20                 db    0
.xdata$x:00001B21                 db    0
.xdata$x:00001B22                 db    0
.xdata$x:00001B23                 db    0
.xdata$x:00001B24                 db    1
.xdata$x:00001B25                 db    0
.xdata$x:00001B26                 db    0
.xdata$x:00001B27                 db    0
.xdata$x:00001B28                 db    0
.xdata$x:00001B29                 db    0
.xdata$x:00001B2A                 db    0
.xdata$x:00001B2B                 db    0
.xdata$x:00001B2C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00001B2C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00001B2D                 db    5
.xdata$x:00001B2E                 db  93h ; 
.xdata$x:00001B2F                 db  19h
.xdata$x:00001B30                 db    4
.xdata$x:00001B31                 db    0
.xdata$x:00001B32                 db    0
.xdata$x:00001B33                 db    0
.xdata$x:00001B34                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001B38                 db    2
.xdata$x:00001B39                 db    0
.xdata$x:00001B3A                 db    0
.xdata$x:00001B3B                 db    0
.xdata$x:00001B3C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001B40                 db    0
.xdata$x:00001B41                 db    0
.xdata$x:00001B42                 db    0
.xdata$x:00001B43                 db    0
.xdata$x:00001B44                 db    0
.xdata$x:00001B45                 db    0
.xdata$x:00001B46                 db    0
.xdata$x:00001B47                 db    0
.xdata$x:00001B48                 db    0
.xdata$x:00001B49                 db    0
.xdata$x:00001B4A                 db    0
.xdata$x:00001B4B                 db    0
.xdata$x:00001B4C                 db    0
.xdata$x:00001B4D                 db    0
.xdata$x:00001B4E                 db    0
.xdata$x:00001B4F                 db    0
.xdata$x:00001B50 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00001B50                                         ; DATA XREF: .xdata$x:00001B3Co
.xdata$x:00001B51                 db    0
.xdata$x:00001B52                 db    0
.xdata$x:00001B53                 db    0
.xdata$x:00001B54                 db    2
.xdata$x:00001B55                 db    0
.xdata$x:00001B56                 db    0
.xdata$x:00001B57                 db    0
.xdata$x:00001B58                 db    3
.xdata$x:00001B59                 db    0
.xdata$x:00001B5A                 db    0
.xdata$x:00001B5B                 db    0
.xdata$x:00001B5C                 db    1
.xdata$x:00001B5D                 db    0
.xdata$x:00001B5E                 db    0
.xdata$x:00001B5F                 db    0
.xdata$x:00001B60                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00001B64                 db    0
.xdata$x:00001B65                 db    0
.xdata$x:00001B66                 db    0
.xdata$x:00001B67                 db    0
.xdata$x:00001B68                 db    0
.xdata$x:00001B69                 db    0
.xdata$x:00001B6A                 db    0
.xdata$x:00001B6B                 db    0
.xdata$x:00001B6C                 db    3
.xdata$x:00001B6D                 db    0
.xdata$x:00001B6E                 db    0
.xdata$x:00001B6F                 db    0
.xdata$x:00001B70                 db    1
.xdata$x:00001B71                 db    0
.xdata$x:00001B72                 db    0
.xdata$x:00001B73                 db    0
.xdata$x:00001B74                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00001B74 _xdata$x        ends
.xdata$x:00001B74
.xdata$x:00001B78 ; ===========================================================================
.xdata$x:00001B78
.xdata$x:00001B78 ; Segment type: Pure data
.xdata$x:00001B78 ; Segment permissions: Read
.xdata$x:00001B78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001B78                 assume cs:_xdata$x
.xdata$x:00001B78                 ;org 1B78h
.xdata$x:00001B78 ; COMDAT (pick associative to section at 528)
.xdata$x:00001B78 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001B78                                         ; DATA XREF: .xdata$x:00001B88o
.xdata$x:00001B79                 db 0FFh
.xdata$x:00001B7A                 db 0FFh
.xdata$x:00001B7B                 db 0FFh
.xdata$x:00001B7C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00001B80 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001B80                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00001B81                 db    5
.xdata$x:00001B82                 db  93h ; 
.xdata$x:00001B83                 db  19h
.xdata$x:00001B84                 db    1
.xdata$x:00001B85                 db    0
.xdata$x:00001B86                 db    0
.xdata$x:00001B87                 db    0
.xdata$x:00001B88                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00001B8C                 db    0
.xdata$x:00001B8D                 db    0
.xdata$x:00001B8E                 db    0
.xdata$x:00001B8F                 db    0
.xdata$x:00001B90                 db    0
.xdata$x:00001B91                 db    0
.xdata$x:00001B92                 db    0
.xdata$x:00001B93                 db    0
.xdata$x:00001B94                 db    0
.xdata$x:00001B95                 db    0
.xdata$x:00001B96                 db    0
.xdata$x:00001B97                 db    0
.xdata$x:00001B98                 db    0
.xdata$x:00001B99                 db    0
.xdata$x:00001B9A                 db    0
.xdata$x:00001B9B                 db    0
.xdata$x:00001B9C                 db    0
.xdata$x:00001B9D                 db    0
.xdata$x:00001B9E                 db    0
.xdata$x:00001B9F                 db    0
.xdata$x:00001BA0                 db    0
.xdata$x:00001BA1                 db    0
.xdata$x:00001BA2                 db    0
.xdata$x:00001BA3                 db    0
.xdata$x:00001BA3 _xdata$x        ends
.xdata$x:00001BA3
.xdata$x:00001BA4 ; ===========================================================================
.xdata$x:00001BA4
.xdata$x:00001BA4 ; Segment type: Pure data
.xdata$x:00001BA4 ; Segment permissions: Read
.xdata$x:00001BA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001BA4                 assume cs:_xdata$x
.xdata$x:00001BA4                 ;org 1BA4h
.xdata$x:00001BA4 ; COMDAT (pick associative to section at 16BC)
.xdata$x:00001BA4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001BA4                                         ; DATA XREF: .xdata$x:00001BB4o
.xdata$x:00001BA5                 db 0FFh
.xdata$x:00001BA6                 db 0FFh
.xdata$x:00001BA7                 db 0FFh
.xdata$x:00001BA8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001BAC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001BAC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001BAD                 db    5
.xdata$x:00001BAE                 db  93h ; 
.xdata$x:00001BAF                 db  19h
.xdata$x:00001BB0                 db    1
.xdata$x:00001BB1                 db    0
.xdata$x:00001BB2                 db    0
.xdata$x:00001BB3                 db    0
.xdata$x:00001BB4                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001BB8                 db    0
.xdata$x:00001BB9                 db    0
.xdata$x:00001BBA                 db    0
.xdata$x:00001BBB                 db    0
.xdata$x:00001BBC                 db    0
.xdata$x:00001BBD                 db    0
.xdata$x:00001BBE                 db    0
.xdata$x:00001BBF                 db    0
.xdata$x:00001BC0                 db    0
.xdata$x:00001BC1                 db    0
.xdata$x:00001BC2                 db    0
.xdata$x:00001BC3                 db    0
.xdata$x:00001BC4                 db    0
.xdata$x:00001BC5                 db    0
.xdata$x:00001BC6                 db    0
.xdata$x:00001BC7                 db    0
.xdata$x:00001BC8                 db    0
.xdata$x:00001BC9                 db    0
.xdata$x:00001BCA                 db    0
.xdata$x:00001BCB                 db    0
.xdata$x:00001BCC                 db    0
.xdata$x:00001BCD                 db    0
.xdata$x:00001BCE                 db    0
.xdata$x:00001BCF                 db    0
.xdata$x:00001BCF _xdata$x        ends
.xdata$x:00001BCF
.xdata$x:00001BD0 ; ===========================================================================
.xdata$x:00001BD0
.xdata$x:00001BD0 ; Segment type: Pure data
.xdata$x:00001BD0 ; Segment permissions: Read
.xdata$x:00001BD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001BD0                 assume cs:_xdata$x
.xdata$x:00001BD0                 ;org 1BD0h
.xdata$x:00001BD0 ; COMDAT (pick associative to section at 868)
.xdata$x:00001BD0 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001BD0                                         ; DATA XREF: .xdata$x:00001BE0o
.xdata$x:00001BD1                 db 0FFh
.xdata$x:00001BD2                 db 0FFh
.xdata$x:00001BD3                 db 0FFh
.xdata$x:00001BD4                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00001BD8 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001BD8                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00001BD9                 db    5
.xdata$x:00001BDA                 db  93h ; 
.xdata$x:00001BDB                 db  19h
.xdata$x:00001BDC                 db    1
.xdata$x:00001BDD                 db    0
.xdata$x:00001BDE                 db    0
.xdata$x:00001BDF                 db    0
.xdata$x:00001BE0                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00001BE4                 db    0
.xdata$x:00001BE5                 db    0
.xdata$x:00001BE6                 db    0
.xdata$x:00001BE7                 db    0
.xdata$x:00001BE8                 db    0
.xdata$x:00001BE9                 db    0
.xdata$x:00001BEA                 db    0
.xdata$x:00001BEB                 db    0
.xdata$x:00001BEC                 db    0
.xdata$x:00001BED                 db    0
.xdata$x:00001BEE                 db    0
.xdata$x:00001BEF                 db    0
.xdata$x:00001BF0                 db    0
.xdata$x:00001BF1                 db    0
.xdata$x:00001BF2                 db    0
.xdata$x:00001BF3                 db    0
.xdata$x:00001BF4                 db    0
.xdata$x:00001BF5                 db    0
.xdata$x:00001BF6                 db    0
.xdata$x:00001BF7                 db    0
.xdata$x:00001BF8                 db    0
.xdata$x:00001BF9                 db    0
.xdata$x:00001BFA                 db    0
.xdata$x:00001BFB                 db    0
.xdata$x:00001BFB _xdata$x        ends
.xdata$x:00001BFB
.xdata$x:00001BFC ; ===========================================================================
.xdata$x:00001BFC
.xdata$x:00001BFC ; Segment type: Pure data
.xdata$x:00001BFC ; Segment permissions: Read
.xdata$x:00001BFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001BFC                 assume cs:_xdata$x
.xdata$x:00001BFC                 ;org 1BFCh
.xdata$x:00001BFC ; COMDAT (pick associative to section at 5A4)
.xdata$x:00001BFC __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001BFC                                         ; DATA XREF: .xdata$x:00001C0Co
.xdata$x:00001BFD                 db 0FFh
.xdata$x:00001BFE                 db 0FFh
.xdata$x:00001BFF                 db 0FFh
.xdata$x:00001C00                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00001C04 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001C04                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00001C05                 db    5
.xdata$x:00001C06                 db  93h ; 
.xdata$x:00001C07                 db  19h
.xdata$x:00001C08                 db    1
.xdata$x:00001C09                 db    0
.xdata$x:00001C0A                 db    0
.xdata$x:00001C0B                 db    0
.xdata$x:00001C0C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00001C10                 db    0
.xdata$x:00001C11                 db    0
.xdata$x:00001C12                 db    0
.xdata$x:00001C13                 db    0
.xdata$x:00001C14                 db    0
.xdata$x:00001C15                 db    0
.xdata$x:00001C16                 db    0
.xdata$x:00001C17                 db    0
.xdata$x:00001C18                 db    0
.xdata$x:00001C19                 db    0
.xdata$x:00001C1A                 db    0
.xdata$x:00001C1B                 db    0
.xdata$x:00001C1C                 db    0
.xdata$x:00001C1D                 db    0
.xdata$x:00001C1E                 db    0
.xdata$x:00001C1F                 db    0
.xdata$x:00001C20                 db    0
.xdata$x:00001C21                 db    0
.xdata$x:00001C22                 db    0
.xdata$x:00001C23                 db    0
.xdata$x:00001C24                 db    0
.xdata$x:00001C25                 db    0
.xdata$x:00001C26                 db    0
.xdata$x:00001C27                 db    0
.xdata$x:00001C27 _xdata$x        ends
.xdata$x:00001C27
.xdata$x:00001C28 ; ===========================================================================
.xdata$x:00001C28
.xdata$x:00001C28 ; Segment type: Pure data
.xdata$x:00001C28 ; Segment permissions: Read
.xdata$x:00001C28 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C28                 assume cs:_xdata$x
.xdata$x:00001C28                 ;org 1C28h
.xdata$x:00001C28 ; COMDAT (pick associative to section at 1774)
.xdata$x:00001C28 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001C28                                         ; DATA XREF: .xdata$x:00001C38o
.xdata$x:00001C29                 db 0FFh
.xdata$x:00001C2A                 db 0FFh
.xdata$x:00001C2B                 db 0FFh
.xdata$x:00001C2C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001C30 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001C30                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001C31                 db    5
.xdata$x:00001C32                 db  93h ; 
.xdata$x:00001C33                 db  19h
.xdata$x:00001C34                 db    1
.xdata$x:00001C35                 db    0
.xdata$x:00001C36                 db    0
.xdata$x:00001C37                 db    0
.xdata$x:00001C38                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001C3C                 db    0
.xdata$x:00001C3D                 db    0
.xdata$x:00001C3E                 db    0
.xdata$x:00001C3F                 db    0
.xdata$x:00001C40                 db    0
.xdata$x:00001C41                 db    0
.xdata$x:00001C42                 db    0
.xdata$x:00001C43                 db    0
.xdata$x:00001C44                 db    0
.xdata$x:00001C45                 db    0
.xdata$x:00001C46                 db    0
.xdata$x:00001C47                 db    0
.xdata$x:00001C48                 db    0
.xdata$x:00001C49                 db    0
.xdata$x:00001C4A                 db    0
.xdata$x:00001C4B                 db    0
.xdata$x:00001C4C                 db    0
.xdata$x:00001C4D                 db    0
.xdata$x:00001C4E                 db    0
.xdata$x:00001C4F                 db    0
.xdata$x:00001C50                 db    0
.xdata$x:00001C51                 db    0
.xdata$x:00001C52                 db    0
.xdata$x:00001C53                 db    0
.xdata$x:00001C53 _xdata$x        ends
.xdata$x:00001C53
.xdata$x:00001C54 ; ===========================================================================
.xdata$x:00001C54
.xdata$x:00001C54 ; Segment type: Pure data
.xdata$x:00001C54 ; Segment permissions: Read
.xdata$x:00001C54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C54                 assume cs:_xdata$x
.xdata$x:00001C54                 ;org 1C54h
.xdata$x:00001C54 ; COMDAT (pick associative to section at 8D8)
.xdata$x:00001C54 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001C54                                         ; DATA XREF: .xdata$x:00001C64o
.xdata$x:00001C55                 db 0FFh
.xdata$x:00001C56                 db 0FFh
.xdata$x:00001C57                 db 0FFh
.xdata$x:00001C58                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00001C5C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001C5C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00001C5D                 db    5
.xdata$x:00001C5E                 db  93h ; 
.xdata$x:00001C5F                 db  19h
.xdata$x:00001C60                 db    1
.xdata$x:00001C61                 db    0
.xdata$x:00001C62                 db    0
.xdata$x:00001C63                 db    0
.xdata$x:00001C64                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00001C68                 align 20h
.xdata$x:00001C68 _xdata$x        ends
.xdata$x:00001C68
.xdata$x:00001C80 ; ===========================================================================
.xdata$x:00001C80
.xdata$x:00001C80 ; Segment type: Pure data
.xdata$x:00001C80 ; Segment permissions: Read
.xdata$x:00001C80 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C80                 assume cs:_xdata$x
.xdata$x:00001C80                 ;org 1C80h
.xdata$x:00001C80 ; COMDAT (pick associative to section at 620)
.xdata$x:00001C80 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001C80                                         ; DATA XREF: .xdata$x:00001C90o
.xdata$x:00001C81                 db 0FFh
.xdata$x:00001C82                 db 0FFh
.xdata$x:00001C83                 db 0FFh
.xdata$x:00001C84                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00001C88 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001C88                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00001C89                 db    5
.xdata$x:00001C8A                 db  93h ; 
.xdata$x:00001C8B                 db  19h
.xdata$x:00001C8C                 db    1
.xdata$x:00001C8D                 db    0
.xdata$x:00001C8E                 db    0
.xdata$x:00001C8F                 db    0
.xdata$x:00001C90                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00001C94                 db    0
.xdata$x:00001C95                 db    0
.xdata$x:00001C96                 db    0
.xdata$x:00001C97                 db    0
.xdata$x:00001C98                 db    0
.xdata$x:00001C99                 db    0
.xdata$x:00001C9A                 db    0
.xdata$x:00001C9B                 db    0
.xdata$x:00001C9C                 db    0
.xdata$x:00001C9D                 db    0
.xdata$x:00001C9E                 db    0
.xdata$x:00001C9F                 db    0
.xdata$x:00001CA0                 db    0
.xdata$x:00001CA1                 db    0
.xdata$x:00001CA2                 db    0
.xdata$x:00001CA3                 db    0
.xdata$x:00001CA4                 db    0
.xdata$x:00001CA5                 db    0
.xdata$x:00001CA6                 db    0
.xdata$x:00001CA7                 db    0
.xdata$x:00001CA8                 db    0
.xdata$x:00001CA9                 db    0
.xdata$x:00001CAA                 db    0
.xdata$x:00001CAB                 db    0
.xdata$x:00001CAB _xdata$x        ends
.xdata$x:00001CAB
.xdata$x:00001CAC ; ===========================================================================
.xdata$x:00001CAC
.xdata$x:00001CAC ; Segment type: Pure data
.xdata$x:00001CAC ; Segment permissions: Read
.xdata$x:00001CAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001CAC                 assume cs:_xdata$x
.xdata$x:00001CAC                 ;org 1CACh
.xdata$x:00001CAC ; COMDAT (pick associative to section at 1838)
.xdata$x:00001CAC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001CAC                                         ; DATA XREF: .xdata$x:00001CBCo
.xdata$x:00001CAD                 db 0FFh
.xdata$x:00001CAE                 db 0FFh
.xdata$x:00001CAF                 db 0FFh
.xdata$x:00001CB0                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001CB4 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001CB4                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001CB5                 db    5
.xdata$x:00001CB6                 db  93h ; 
.xdata$x:00001CB7                 db  19h
.xdata$x:00001CB8                 db    1
.xdata$x:00001CB9                 db    0
.xdata$x:00001CBA                 db    0
.xdata$x:00001CBB                 db    0
.xdata$x:00001CBC                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001CC0                 db    0
.xdata$x:00001CC1                 db    0
.xdata$x:00001CC2                 db    0
.xdata$x:00001CC3                 db    0
.xdata$x:00001CC4                 db    0
.xdata$x:00001CC5                 db    0
.xdata$x:00001CC6                 db    0
.xdata$x:00001CC7                 db    0
.xdata$x:00001CC8                 db    0
.xdata$x:00001CC9                 db    0
.xdata$x:00001CCA                 db    0
.xdata$x:00001CCB                 db    0
.xdata$x:00001CCC                 db    0
.xdata$x:00001CCD                 db    0
.xdata$x:00001CCE                 db    0
.xdata$x:00001CCF                 db    0
.xdata$x:00001CD0                 db    0
.xdata$x:00001CD1                 db    0
.xdata$x:00001CD2                 db    0
.xdata$x:00001CD3                 db    0
.xdata$x:00001CD4                 db    0
.xdata$x:00001CD5                 db    0
.xdata$x:00001CD6                 db    0
.xdata$x:00001CD7                 db    0
.xdata$x:00001CD7 _xdata$x        ends
.xdata$x:00001CD7
.xdata$x:00001CD8 ; ===========================================================================
.xdata$x:00001CD8
.xdata$x:00001CD8 ; Segment type: Pure data
.xdata$x:00001CD8 ; Segment permissions: Read
.xdata$x:00001CD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001CD8                 assume cs:_xdata$x
.xdata$x:00001CD8                 ;org 1CD8h
.xdata$x:00001CD8 ; COMDAT (pick associative to section at 948)
.xdata$x:00001CD8 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001CD8                                         ; DATA XREF: .xdata$x:00001CE8o
.xdata$x:00001CD9                 db 0FFh
.xdata$x:00001CDA                 db 0FFh
.xdata$x:00001CDB                 db 0FFh
.xdata$x:00001CDC                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00001CE0 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001CE0                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00001CE1                 db    5
.xdata$x:00001CE2                 db  93h ; 
.xdata$x:00001CE3                 db  19h
.xdata$x:00001CE4                 db    1
.xdata$x:00001CE5                 db    0
.xdata$x:00001CE6                 db    0
.xdata$x:00001CE7                 db    0
.xdata$x:00001CE8                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00001CEC                 db    0
.xdata$x:00001CED                 db    0
.xdata$x:00001CEE                 db    0
.xdata$x:00001CEF                 db    0
.xdata$x:00001CF0                 db    0
.xdata$x:00001CF1                 db    0
.xdata$x:00001CF2                 db    0
.xdata$x:00001CF3                 db    0
.xdata$x:00001CF4                 db    0
.xdata$x:00001CF5                 db    0
.xdata$x:00001CF6                 db    0
.xdata$x:00001CF7                 db    0
.xdata$x:00001CF8                 db    0
.xdata$x:00001CF9                 db    0
.xdata$x:00001CFA                 db    0
.xdata$x:00001CFB                 db    0
.xdata$x:00001CFC                 db    0
.xdata$x:00001CFD                 db    0
.xdata$x:00001CFE                 db    0
.xdata$x:00001CFF                 db    0
.xdata$x:00001D00                 db    0
.xdata$x:00001D01                 db    0
.xdata$x:00001D02                 db    0
.xdata$x:00001D03                 db    0
.xdata$x:00001D03 _xdata$x        ends
.xdata$x:00001D03
.xdata$x:00001D04 ; ===========================================================================
.xdata$x:00001D04
.xdata$x:00001D04 ; Segment type: Pure data
.xdata$x:00001D04 ; Segment permissions: Read
.xdata$x:00001D04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D04                 assume cs:_xdata$x
.xdata$x:00001D04                 ;org 1D04h
.xdata$x:00001D04 ; COMDAT (pick associative to section at 1FC)
.xdata$x:00001D04 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00001D04                                         ; DATA XREF: .xdata$x:00001D14o
.xdata$x:00001D05                 db 0FFh
.xdata$x:00001D06                 db 0FFh
.xdata$x:00001D07                 db 0FFh
.xdata$x:00001D08                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00001D0C __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00001D0C                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00001D0D                 db    5
.xdata$x:00001D0E                 db  93h ; 
.xdata$x:00001D0F                 db  19h
.xdata$x:00001D10                 db    1
.xdata$x:00001D11                 db    0
.xdata$x:00001D12                 db    0
.xdata$x:00001D13                 db    0
.xdata$x:00001D14                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00001D18                 db    0
.xdata$x:00001D19                 db    0
.xdata$x:00001D1A                 db    0
.xdata$x:00001D1B                 db    0
.xdata$x:00001D1C                 db    0
.xdata$x:00001D1D                 db    0
.xdata$x:00001D1E                 db    0
.xdata$x:00001D1F                 db    0
.xdata$x:00001D20                 db    0
.xdata$x:00001D21                 db    0
.xdata$x:00001D22                 db    0
.xdata$x:00001D23                 db    0
.xdata$x:00001D24                 db    0
.xdata$x:00001D25                 db    0
.xdata$x:00001D26                 db    0
.xdata$x:00001D27                 db    0
.xdata$x:00001D28                 db    0
.xdata$x:00001D29                 db    0
.xdata$x:00001D2A                 db    0
.xdata$x:00001D2B                 db    0
.xdata$x:00001D2C                 db    0
.xdata$x:00001D2D                 db    0
.xdata$x:00001D2E                 db    0
.xdata$x:00001D2F                 db    0
.xdata$x:00001D2F _xdata$x        ends
.xdata$x:00001D2F
.xdata$x:00001D30 ; ===========================================================================
.xdata$x:00001D30
.xdata$x:00001D30 ; Segment type: Pure data
.xdata$x:00001D30 ; Segment permissions: Read
.xdata$x:00001D30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D30                 assume cs:_xdata$x
.xdata$x:00001D30                 ;org 1D30h
.xdata$x:00001D30 ; COMDAT (pick associative to section at 128)
.xdata$x:00001D30 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00001D30                                         ; DATA XREF: .xdata$x:00001D40o
.xdata$x:00001D31                 db 0FFh
.xdata$x:00001D32                 db 0FFh
.xdata$x:00001D33                 db 0FFh
.xdata$x:00001D34                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00001D38 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00001D38                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00001D39                 db    5
.xdata$x:00001D3A                 db  93h ; 
.xdata$x:00001D3B                 db  19h
.xdata$x:00001D3C                 db    1
.xdata$x:00001D3D                 db    0
.xdata$x:00001D3E                 db    0
.xdata$x:00001D3F                 db    0
.xdata$x:00001D40                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00001D44                 db    0
.xdata$x:00001D45                 db    0
.xdata$x:00001D46                 db    0
.xdata$x:00001D47                 db    0
.xdata$x:00001D48                 db    0
.xdata$x:00001D49                 db    0
.xdata$x:00001D4A                 db    0
.xdata$x:00001D4B                 db    0
.xdata$x:00001D4C                 db    0
.xdata$x:00001D4D                 db    0
.xdata$x:00001D4E                 db    0
.xdata$x:00001D4F                 db    0
.xdata$x:00001D50                 db    0
.xdata$x:00001D51                 db    0
.xdata$x:00001D52                 db    0
.xdata$x:00001D53                 db    0
.xdata$x:00001D54                 db    0
.xdata$x:00001D55                 db    0
.xdata$x:00001D56                 db    0
.xdata$x:00001D57                 db    0
.xdata$x:00001D58                 db    0
.xdata$x:00001D59                 db    0
.xdata$x:00001D5A                 db    0
.xdata$x:00001D5B                 db    0
.xdata$x:00001D5B _xdata$x        ends
.xdata$x:00001D5B
.bss:00001D5C ; ===========================================================================
.bss:00001D5C
.bss:00001D5C ; Segment type: Uninitialized
.bss:00001D5C ; Segment permissions: Read/Write
.bss:00001D5C _bss            segment byte public 'BSS' use32
.bss:00001D5C                 assume cs:_bss
.bss:00001D5C                 ;org 1D5Ch
.bss:00001D5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001D5C _allocator_arg  db    ? ;
.bss:00001D5D _piecewise_construct db    ? ;
.bss:00001D5E                 align 10h
.bss:00001D5E _bss            ends
.bss:00001D5E
.rdata:00001D60 ; ===========================================================================
.rdata:00001D60
.rdata:00001D60 ; Segment type: Pure data
.rdata:00001D60 ; Segment permissions: Read
.rdata:00001D60 _rdata          segment dword public 'DATA' use32
.rdata:00001D60                 assume cs:_rdata
.rdata:00001D60                 ;org 1D60h
.rdata:00001D60 ; COMDAT (pick largest)
.rdata:00001D60                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00001D64                 public ??_7error_category@std@@6B@
.rdata:00001D64 ; const std::error_category::`vftable'
.rdata:00001D64 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00001D64                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00001D64                                         ; std::error_category::~error_category(void)+Ao
.rdata:00001D64                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00001D68                 dd offset __purecall
.rdata:00001D6C                 dd offset __purecall
.rdata:00001D70                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001D74                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001D78                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001D78 _rdata          ends
.rdata:00001D78
.rdata:00001D7C ; ===========================================================================
.rdata:00001D7C
.rdata:00001D7C ; Segment type: Pure data
.rdata:00001D7C ; Segment permissions: Read
.rdata:00001D7C _rdata          segment dword public 'DATA' use32
.rdata:00001D7C                 assume cs:_rdata
.rdata:00001D7C                 ;org 1D7Ch
.rdata:00001D7C ; COMDAT (pick largest)
.rdata:00001D7C                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00001D80                 public ??_7_Generic_error_category@std@@6B@
.rdata:00001D80 ; const std::_Generic_error_category::`vftable'
.rdata:00001D80 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00001D80                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00001D80                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00001D84                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00001D88                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00001D8C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001D90                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001D94                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001D94 _rdata          ends
.rdata:00001D94
.rdata:00001D98 ; ===========================================================================
.rdata:00001D98
.rdata:00001D98 ; Segment type: Pure data
.rdata:00001D98 ; Segment permissions: Read
.rdata:00001D98 _rdata          segment dword public 'DATA' use32
.rdata:00001D98                 assume cs:_rdata
.rdata:00001D98                 ;org 1D98h
.rdata:00001D98 ; COMDAT (pick any)
.rdata:00001D98                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00001D98 ; `string'
.rdata:00001D98 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00001D98                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00001D98 _rdata          ends
.rdata:00001D98
.rdata:00001DA0 ; ===========================================================================
.rdata:00001DA0
.rdata:00001DA0 ; Segment type: Pure data
.rdata:00001DA0 ; Segment permissions: Read
.rdata:00001DA0 _rdata          segment dword public 'DATA' use32
.rdata:00001DA0                 assume cs:_rdata
.rdata:00001DA0                 ;org 1DA0h
.rdata:00001DA0 ; COMDAT (pick any)
.rdata:00001DA0                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00001DA0 ; `string'
.rdata:00001DA0 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00001DA0                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_1708o
.rdata:00001DA0                                         ; std::_System_error_category::message(int):loc_1884o
.rdata:00001DAE                 align 10h
.rdata:00001DAE _rdata          ends
.rdata:00001DAE
.rdata:00001DB0 ; ===========================================================================
.rdata:00001DB0
.rdata:00001DB0 ; Segment type: Pure data
.rdata:00001DB0 ; Segment permissions: Read
.rdata:00001DB0 _rdata          segment dword public 'DATA' use32
.rdata:00001DB0                 assume cs:_rdata
.rdata:00001DB0                 ;org 1DB0h
.rdata:00001DB0 ; COMDAT (pick largest)
.rdata:00001DB0                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00001DB4                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00001DB4 ; const std::_Iostream_error_category::`vftable'
.rdata:00001DB4 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00001DB4                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00001DB4                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00001DB8                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00001DBC                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00001DC0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001DC4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001DC8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001DC8 _rdata          ends
.rdata:00001DC8
.rdata:00001DCC ; ===========================================================================
.rdata:00001DCC
.rdata:00001DCC ; Segment type: Pure data
.rdata:00001DCC ; Segment permissions: Read
.rdata:00001DCC _rdata          segment dword public 'DATA' use32
.rdata:00001DCC                 assume cs:_rdata
.rdata:00001DCC                 ;org 1DCCh
.rdata:00001DCC ; COMDAT (pick any)
.rdata:00001DCC                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00001DCC ; `string'
.rdata:00001DCC ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00001DCC                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00001DD5                 align 4
.rdata:00001DD5 _rdata          ends
.rdata:00001DD5
.rdata:00001DD8 ; ===========================================================================
.rdata:00001DD8
.rdata:00001DD8 ; Segment type: Pure data
.rdata:00001DD8 ; Segment permissions: Read
.rdata:00001DD8 _rdata          segment dword public 'DATA' use32
.rdata:00001DD8                 assume cs:_rdata
.rdata:00001DD8                 ;org 1DD8h
.rdata:00001DD8 ; COMDAT (pick any)
.rdata:00001DD8                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00001DD8 ; char `string'[]
.rdata:00001DD8 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00001DD8                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00001DEE                 align 10h
.rdata:00001DEE _rdata          ends
.rdata:00001DEE
.rdata:00001DF0 ; ===========================================================================
.rdata:00001DF0
.rdata:00001DF0 ; Segment type: Pure data
.rdata:00001DF0 ; Segment permissions: Read
.rdata:00001DF0 _rdata          segment dword public 'DATA' use32
.rdata:00001DF0                 assume cs:_rdata
.rdata:00001DF0                 ;org 1DF0h
.rdata:00001DF0 ; COMDAT (pick largest)
.rdata:00001DF0                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00001DF4                 public ??_7_System_error_category@std@@6B@
.rdata:00001DF4 ; const std::_System_error_category::`vftable'
.rdata:00001DF4 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00001DF4                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00001DF4                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00001DF8                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00001DFC                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00001E00                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00001E04                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001E08                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001E08 _rdata          ends
.rdata:00001E08
.rdata:00001E0C ; ===========================================================================
.rdata:00001E0C
.rdata:00001E0C ; Segment type: Pure data
.rdata:00001E0C ; Segment permissions: Read
.rdata:00001E0C _rdata          segment dword public 'DATA' use32
.rdata:00001E0C                 assume cs:_rdata
.rdata:00001E0C                 ;org 1E0Ch
.rdata:00001E0C ; COMDAT (pick any)
.rdata:00001E0C                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00001E0C ; `string'
.rdata:00001E0C ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00001E0C                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00001E13                 align 4
.rdata:00001E13 _rdata          ends
.rdata:00001E13
.bss:00001E14 ; ===========================================================================
.bss:00001E14
.bss:00001E14 ; Segment type: Uninitialized
.bss:00001E14 ; Segment permissions: Read/Write
.bss:00001E14 _bss            segment dword public 'BSS' use32
.bss:00001E14                 assume cs:_bss
.bss:00001E14                 ;org 1E14h
.bss:00001E14 ; COMDAT (pick any)
.bss:00001E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001E14                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00001E14 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00001E14 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00001E14                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00001E14                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00001E15                 db    ? ;
.bss:00001E16                 db    ? ;
.bss:00001E17                 db    ? ;
.bss:00001E17 _bss            ends
.bss:00001E17
.bss:00001E18 ; ===========================================================================
.bss:00001E18
.bss:00001E18 ; Segment type: Uninitialized
.bss:00001E18 ; Segment permissions: Read/Write
.bss:00001E18 _bss            segment dword public 'BSS' use32
.bss:00001E18                 assume cs:_bss
.bss:00001E18                 ;org 1E18h
.bss:00001E18 ; COMDAT (pick any)
.bss:00001E18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001E18                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00001E18 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00001E18 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00001E18                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00001E18                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00001E19                 db    ? ;
.bss:00001E1A                 db    ? ;
.bss:00001E1B                 db    ? ;
.bss:00001E1B _bss            ends
.bss:00001E1B
.bss:00001E1C ; ===========================================================================
.bss:00001E1C
.bss:00001E1C ; Segment type: Uninitialized
.bss:00001E1C ; Segment permissions: Read/Write
.bss:00001E1C _bss            segment dword public 'BSS' use32
.bss:00001E1C                 assume cs:_bss
.bss:00001E1C                 ;org 1E1Ch
.bss:00001E1C ; COMDAT (pick any)
.bss:00001E1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001E1C                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00001E1C ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00001E1C ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00001E1C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00001E1C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00001E1D                 db    ? ;
.bss:00001E1E                 db    ? ;
.bss:00001E1F                 db    ? ;
.bss:00001E1F _bss            ends
.bss:00001E1F
.bss:00001E20 ; ===========================================================================
.bss:00001E20
.bss:00001E20 ; Segment type: Uninitialized
.bss:00001E20 ; Segment permissions: Read/Write
.bss:00001E20 _bss            segment dword public 'BSS' use32
.bss:00001E20                 assume cs:_bss
.bss:00001E20                 ;org 1E20h
.bss:00001E20 ; COMDAT (pick any)
.bss:00001E20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001E20                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00001E20 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00001E20 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00001E20                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00001E21                 db    ? ;
.bss:00001E22                 db    ? ;
.bss:00001E23                 db    ? ;
.bss:00001E23 _bss            ends
.bss:00001E23
.bss:00001E24 ; ===========================================================================
.bss:00001E24
.bss:00001E24 ; Segment type: Uninitialized
.bss:00001E24 ; Segment permissions: Read/Write
.bss:00001E24 _bss            segment dword public 'BSS' use32
.bss:00001E24                 assume cs:_bss
.bss:00001E24                 ;org 1E24h
.bss:00001E24 ; COMDAT (pick any)
.bss:00001E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001E24                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00001E24 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00001E24 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00001E24                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00001E25                 db    ? ;
.bss:00001E26                 db    ? ;
.bss:00001E27                 db    ? ;
.bss:00001E27 _bss            ends
.bss:00001E27
.rdata:00001E28 ; ===========================================================================
.rdata:00001E28
.rdata:00001E28 ; Segment type: Pure data
.rdata:00001E28 ; Segment permissions: Read
.rdata:00001E28 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00001E28 _rdata          segment para public 'DATA' use32
.rdata:00001E28                 assume cs:_rdata
.rdata:00001E28                 ;org 1E28h
.rdata:00001E28 ; COMDAT (pick any)
.rdata:00001E28                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00001E28 ; wchar_t `string'
.rdata:00001E28 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00001E28                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00001E28                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00001E28                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00001E28                 unicode 0, <clude\xstring>,0
.rdata:00001EB6                 align 4
.rdata:00001EB6 _rdata          ends
.rdata:00001EB6
.bss:00001EB8 ; ===========================================================================
.bss:00001EB8
.bss:00001EB8 ; Segment type: Uninitialized
.bss:00001EB8 ; Segment permissions: Read/Write
.bss:00001EB8 _bss            segment dword public 'BSS' use32
.bss:00001EB8                 assume cs:_bss
.bss:00001EB8                 ;org 1EB8h
.bss:00001EB8 ; COMDAT (pick any)
.bss:00001EB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001EB8                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00001EB8 ; std::locale::id std::numpunct<char>::id
.bss:00001EB8 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00001EB8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00001EB9                 db    ? ;
.bss:00001EBA                 db    ? ;
.bss:00001EBB                 db    ? ;
.bss:00001EBB _bss            ends
.bss:00001EBB
.bss:00001EBC ; ===========================================================================
.bss:00001EBC
.bss:00001EBC ; Segment type: Uninitialized
.bss:00001EBC ; Segment permissions: Read/Write
.bss:00001EBC _bss            segment dword public 'BSS' use32
.bss:00001EBC                 assume cs:_bss
.bss:00001EBC                 ;org 1EBCh
.bss:00001EBC ; COMDAT (pick any)
.bss:00001EBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001EBC                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00001EBC ; std::locale::id std::numpunct<wchar_t>::id
.bss:00001EBC ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00001EBC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00001EBD                 db    ? ;
.bss:00001EBE                 db    ? ;
.bss:00001EBF                 db    ? ;
.bss:00001EBF _bss            ends
.bss:00001EBF
.rdata:00001EC0 ; ===========================================================================
.rdata:00001EC0
.rdata:00001EC0 ; Segment type: Pure data
.rdata:00001EC0 ; Segment permissions: Read
.rdata:00001EC0 _rdata          segment dword public 'DATA' use32
.rdata:00001EC0                 assume cs:_rdata
.rdata:00001EC0                 ;org 1EC0h
.rdata:00001EC0 ; COMDAT (pick any)
.rdata:00001EC0                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00001EC0 ; char `string'[]
.rdata:00001EC0 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00001EC0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00001EC0 _rdata          ends
.rdata:00001EC0
.rdata:00001ED0 ; ===========================================================================
.rdata:00001ED0
.rdata:00001ED0 ; Segment type: Pure data
.rdata:00001ED0 ; Segment permissions: Read
.rdata:00001ED0 _rdata          segment dword public 'DATA' use32
.rdata:00001ED0                 assume cs:_rdata
.rdata:00001ED0                 ;org 1ED0h
.rdata:00001ED0 ; COMDAT (pick any)
.rdata:00001ED0                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00001ED0 ; char `string'[]
.rdata:00001ED0 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00001ED0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00001ED0 _rdata          ends
.rdata:00001ED0
.rdata:00001EE8 ; ===========================================================================
.rdata:00001EE8
.rdata:00001EE8 ; Segment type: Pure data
.rdata:00001EE8 ; Segment permissions: Read
.rdata:00001EE8 _rdata          segment dword public 'DATA' use32
.rdata:00001EE8                 assume cs:_rdata
.rdata:00001EE8                 ;org 1EE8h
.rdata:00001EE8 ; COMDAT (pick any)
.rdata:00001EE8                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00001EE8 ; wchar_t `string'
.rdata:00001EE8 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00001EE8                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00001EE8                 unicode 0, <invalid null pointer>,0
.rdata:00001F12                 align 4
.rdata:00001F12 _rdata          ends
.rdata:00001F12
.rdata$r:00001F14 ; ===========================================================================
.rdata$r:00001F14
.rdata$r:00001F14 ; Segment type: Pure data
.rdata$r:00001F14 ; Segment permissions: Read
.rdata$r:00001F14 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F14                 assume cs:_rdata$r
.rdata$r:00001F14                 ;org 1F14h
.rdata$r:00001F14 ; COMDAT (pick any)
.rdata$r:00001F14                 public ??_R4error_category@std@@6B@
.rdata$r:00001F14 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00001F14 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00001D60o
.rdata$r:00001F15                 db    0
.rdata$r:00001F16                 db    0
.rdata$r:00001F17                 db    0
.rdata$r:00001F18                 db    0
.rdata$r:00001F19                 db    0
.rdata$r:00001F1A                 db    0
.rdata$r:00001F1B                 db    0
.rdata$r:00001F1C                 db    0
.rdata$r:00001F1D                 db    0
.rdata$r:00001F1E                 db    0
.rdata$r:00001F1F                 db    0
.rdata$r:00001F20                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00001F24                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F24 _rdata$r        ends
.rdata$r:00001F24
.data$r:00001F28 ; ===========================================================================
.data$r:00001F28
.data$r:00001F28 ; Segment type: Pure data
.data$r:00001F28 ; Segment permissions: Read/Write
.data$r:00001F28 _data$r         segment dword public 'DATA' use32
.data$r:00001F28                 assume cs:_data$r
.data$r:00001F28                 ;org 1F28h
.data$r:00001F28 ; COMDAT (pick any)
.data$r:00001F28                 public ??_R0?AVerror_category@std@@@8
.data$r:00001F28 ; class std::error_category `RTTI Type Descriptor'
.data$r:00001F28 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00001F28                                         ; DATA XREF: .rdata$r:00001F20o
.data$r:00001F28                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00001F28                                         ; const type_info::`vftable'
.data$r:00001F2C                 align 10h
.data$r:00001F30 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00001F49                 align 4
.data$r:00001F49 _data$r         ends
.data$r:00001F49
.rdata$r:00001F4C ; ===========================================================================
.rdata$r:00001F4C
.rdata$r:00001F4C ; Segment type: Pure data
.rdata$r:00001F4C ; Segment permissions: Read
.rdata$r:00001F4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F4C                 assume cs:_rdata$r
.rdata$r:00001F4C                 ;org 1F4Ch
.rdata$r:00001F4C ; COMDAT (pick any)
.rdata$r:00001F4C                 public ??_R3error_category@std@@8
.rdata$r:00001F4C ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F4C ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00001F24o
.rdata$r:00001F4C                                         ; .rdata$r:00001F7Co
.rdata$r:00001F4D                 db    0
.rdata$r:00001F4E                 db    0
.rdata$r:00001F4F                 db    0
.rdata$r:00001F50                 db    0
.rdata$r:00001F51                 db    0
.rdata$r:00001F52                 db    0
.rdata$r:00001F53                 db    0
.rdata$r:00001F54                 db    1
.rdata$r:00001F55                 db    0
.rdata$r:00001F56                 db    0
.rdata$r:00001F57                 db    0
.rdata$r:00001F58                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00001F58 _rdata$r        ends
.rdata$r:00001F58
.rdata$r:00001F5C ; ===========================================================================
.rdata$r:00001F5C
.rdata$r:00001F5C ; Segment type: Pure data
.rdata$r:00001F5C ; Segment permissions: Read
.rdata$r:00001F5C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F5C                 assume cs:_rdata$r
.rdata$r:00001F5C                 ;org 1F5Ch
.rdata$r:00001F5C ; COMDAT (pick any)
.rdata$r:00001F5C                 public ??_R2error_category@std@@8
.rdata$r:00001F5C ; std::error_category::`RTTI Base Class Array'
.rdata$r:00001F5C ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00001F5C                                         ; DATA XREF: .rdata$r:00001F58o
.rdata$r:00001F5C                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001F60                 db    0
.rdata$r:00001F61                 align 4
.rdata$r:00001F61 _rdata$r        ends
.rdata$r:00001F61
.rdata$r:00001F64 ; ===========================================================================
.rdata$r:00001F64
.rdata$r:00001F64 ; Segment type: Pure data
.rdata$r:00001F64 ; Segment permissions: Read
.rdata$r:00001F64 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F64                 assume cs:_rdata$r
.rdata$r:00001F64                 ;org 1F64h
.rdata$r:00001F64 ; COMDAT (pick any)
.rdata$r:00001F64                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00001F64 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001F64 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00001F64                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00001F64                                         ; .rdata$r:00001FD4o ...
.rdata$r:00001F64                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00001F68                 align 10h
.rdata$r:00001F70                 db 0FFh
.rdata$r:00001F71                 db 0FFh
.rdata$r:00001F72                 db 0FFh
.rdata$r:00001F73                 db 0FFh
.rdata$r:00001F74                 db    0
.rdata$r:00001F75                 db    0
.rdata$r:00001F76                 db    0
.rdata$r:00001F77                 db    0
.rdata$r:00001F78                 db  40h ; @
.rdata$r:00001F79                 db    0
.rdata$r:00001F7A                 db    0
.rdata$r:00001F7B                 db    0
.rdata$r:00001F7C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F7C _rdata$r        ends
.rdata$r:00001F7C
.rdata$r:00001F80 ; ===========================================================================
.rdata$r:00001F80
.rdata$r:00001F80 ; Segment type: Pure data
.rdata$r:00001F80 ; Segment permissions: Read
.rdata$r:00001F80 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F80                 assume cs:_rdata$r
.rdata$r:00001F80                 ;org 1F80h
.rdata$r:00001F80 ; COMDAT (pick any)
.rdata$r:00001F80                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00001F80 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00001F80 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00001F80                                         ; DATA XREF: .rdata:00001D7Co
.rdata$r:00001F81                 db    0
.rdata$r:00001F82                 db    0
.rdata$r:00001F83                 db    0
.rdata$r:00001F84                 db    0
.rdata$r:00001F85                 db    0
.rdata$r:00001F86                 db    0
.rdata$r:00001F87                 db    0
.rdata$r:00001F88                 db    0
.rdata$r:00001F89                 db    0
.rdata$r:00001F8A                 db    0
.rdata$r:00001F8B                 db    0
.rdata$r:00001F8C                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00001F90                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F90 _rdata$r        ends
.rdata$r:00001F90
.data$r:00001F94 ; ===========================================================================
.data$r:00001F94
.data$r:00001F94 ; Segment type: Pure data
.data$r:00001F94 ; Segment permissions: Read/Write
.data$r:00001F94 _data$r         segment dword public 'DATA' use32
.data$r:00001F94                 assume cs:_data$r
.data$r:00001F94                 ;org 1F94h
.data$r:00001F94 ; COMDAT (pick any)
.data$r:00001F94                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00001F94 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00001F94 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00001F94                                         ; DATA XREF: .rdata$r:00001F8Co
.data$r:00001F94                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00001F94                                         ; const type_info::`vftable'
.data$r:00001F98                 db    0
.data$r:00001F99                 db    0
.data$r:00001F9A                 db    0
.data$r:00001F9B                 db    0
.data$r:00001F9C                 db  2Eh ; .
.data$r:00001F9D                 db  3Fh ; ?
.data$r:00001F9E                 db  41h ; A
.data$r:00001F9F                 db  56h ; V
.data$r:00001FA0                 db  5Fh ; _
.data$r:00001FA1                 db  47h ; G
.data$r:00001FA2                 db  65h ; e
.data$r:00001FA3                 db  6Eh ; n
.data$r:00001FA4                 db  65h ; e
.data$r:00001FA5                 db  72h ; r
.data$r:00001FA6                 db  69h ; i
.data$r:00001FA7                 db  63h ; c
.data$r:00001FA8                 db  5Fh ; _
.data$r:00001FA9                 db  65h ; e
.data$r:00001FAA                 db  72h ; r
.data$r:00001FAB                 db  72h ; r
.data$r:00001FAC                 db  6Fh ; o
.data$r:00001FAD                 db  72h ; r
.data$r:00001FAE                 db  5Fh ; _
.data$r:00001FAF                 db  63h ; c
.data$r:00001FB0                 db  61h ; a
.data$r:00001FB1                 db  74h ; t
.data$r:00001FB2                 db  65h ; e
.data$r:00001FB3                 db  67h ; g
.data$r:00001FB4                 db  6Fh ; o
.data$r:00001FB5                 db  72h ; r
.data$r:00001FB6                 db  79h ; y
.data$r:00001FB7                 db  40h ; @
.data$r:00001FB8                 db  73h ; s
.data$r:00001FB9                 db  74h ; t
.data$r:00001FBA                 db  64h ; d
.data$r:00001FBB                 db  40h ; @
.data$r:00001FBC                 db  40h ; @
.data$r:00001FBD                 db    0
.data$r:00001FBE                 align 10h
.data$r:00001FBE _data$r         ends
.data$r:00001FBE
.rdata$r:00001FC0 ; ===========================================================================
.rdata$r:00001FC0
.rdata$r:00001FC0 ; Segment type: Pure data
.rdata$r:00001FC0 ; Segment permissions: Read
.rdata$r:00001FC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FC0                 assume cs:_rdata$r
.rdata$r:00001FC0                 ;org 1FC0h
.rdata$r:00001FC0 ; COMDAT (pick any)
.rdata$r:00001FC0                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00001FC0 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001FC0 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00001FC0                                         ; DATA XREF: .rdata$r:00001F90o
.rdata$r:00001FC0                                         ; .rdata$r:00001FF4o
.rdata$r:00001FC1                 db    0
.rdata$r:00001FC2                 db    0
.rdata$r:00001FC3                 db    0
.rdata$r:00001FC4                 db    0
.rdata$r:00001FC5                 db    0
.rdata$r:00001FC6                 db    0
.rdata$r:00001FC7                 db    0
.rdata$r:00001FC8                 db    2
.rdata$r:00001FC9                 db    0
.rdata$r:00001FCA                 db    0
.rdata$r:00001FCB                 db    0
.rdata$r:00001FCC                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00001FCC _rdata$r        ends
.rdata$r:00001FCC
.rdata$r:00001FD0 ; ===========================================================================
.rdata$r:00001FD0
.rdata$r:00001FD0 ; Segment type: Pure data
.rdata$r:00001FD0 ; Segment permissions: Read
.rdata$r:00001FD0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FD0                 assume cs:_rdata$r
.rdata$r:00001FD0                 ;org 1FD0h
.rdata$r:00001FD0 ; COMDAT (pick any)
.rdata$r:00001FD0                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00001FD0 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00001FD0 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00001FD0                                         ; DATA XREF: .rdata$r:00001FCCo
.rdata$r:00001FD0                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001FD4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001FD8                 db    0
.rdata$r:00001FD9                 align 4
.rdata$r:00001FD9 _rdata$r        ends
.rdata$r:00001FD9
.rdata$r:00001FDC ; ===========================================================================
.rdata$r:00001FDC
.rdata$r:00001FDC ; Segment type: Pure data
.rdata$r:00001FDC ; Segment permissions: Read
.rdata$r:00001FDC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FDC                 assume cs:_rdata$r
.rdata$r:00001FDC                 ;org 1FDCh
.rdata$r:00001FDC ; COMDAT (pick any)
.rdata$r:00001FDC                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00001FDC ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001FDC ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00001FDC                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00001FDC                                         ; .rdata$r:0000204Co ...
.rdata$r:00001FDC                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00001FE0                 db    1
.rdata$r:00001FE1                 db    0
.rdata$r:00001FE2                 db    0
.rdata$r:00001FE3                 db    0
.rdata$r:00001FE4                 db    0
.rdata$r:00001FE5                 db    0
.rdata$r:00001FE6                 db    0
.rdata$r:00001FE7                 db    0
.rdata$r:00001FE8                 db 0FFh
.rdata$r:00001FE9                 db 0FFh
.rdata$r:00001FEA                 db 0FFh
.rdata$r:00001FEB                 db 0FFh
.rdata$r:00001FEC                 db    0
.rdata$r:00001FED                 db    0
.rdata$r:00001FEE                 db    0
.rdata$r:00001FEF                 db    0
.rdata$r:00001FF0                 db  40h ; @
.rdata$r:00001FF1                 db    0
.rdata$r:00001FF2                 db    0
.rdata$r:00001FF3                 db    0
.rdata$r:00001FF4                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001FF4 _rdata$r        ends
.rdata$r:00001FF4
.rdata$r:00001FF8 ; ===========================================================================
.rdata$r:00001FF8
.rdata$r:00001FF8 ; Segment type: Pure data
.rdata$r:00001FF8 ; Segment permissions: Read
.rdata$r:00001FF8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FF8                 assume cs:_rdata$r
.rdata$r:00001FF8                 ;org 1FF8h
.rdata$r:00001FF8 ; COMDAT (pick any)
.rdata$r:00001FF8                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00001FF8 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00001FF8 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00001FF8                                         ; DATA XREF: .rdata:00001DB0o
.rdata$r:00001FF9                 db    0
.rdata$r:00001FFA                 db    0
.rdata$r:00001FFB                 db    0
.rdata$r:00001FFC                 db    0
.rdata$r:00001FFD                 db    0
.rdata$r:00001FFE                 db    0
.rdata$r:00001FFF                 db    0
.rdata$r:00002000                 db    0
.rdata$r:00002001                 db    0
.rdata$r:00002002                 db    0
.rdata$r:00002003                 db    0
.rdata$r:00002004                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002008                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002008 _rdata$r        ends
.rdata$r:00002008
.data$r:0000200C ; ===========================================================================
.data$r:0000200C
.data$r:0000200C ; Segment type: Pure data
.data$r:0000200C ; Segment permissions: Read/Write
.data$r:0000200C _data$r         segment dword public 'DATA' use32
.data$r:0000200C                 assume cs:_data$r
.data$r:0000200C                 ;org 200Ch
.data$r:0000200C ; COMDAT (pick any)
.data$r:0000200C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000200C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000200C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000200C                                         ; DATA XREF: .rdata$r:00002004o
.data$r:0000200C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000200C                                         ; const type_info::`vftable'
.data$r:00002010                 db    0
.data$r:00002011                 db    0
.data$r:00002012                 db    0
.data$r:00002013                 db    0
.data$r:00002014                 db  2Eh ; .
.data$r:00002015                 db  3Fh ; ?
.data$r:00002016                 db  41h ; A
.data$r:00002017                 db  56h ; V
.data$r:00002018                 db  5Fh ; _
.data$r:00002019                 db  49h ; I
.data$r:0000201A                 db  6Fh ; o
.data$r:0000201B                 db  73h ; s
.data$r:0000201C                 db  74h ; t
.data$r:0000201D                 db  72h ; r
.data$r:0000201E                 db  65h ; e
.data$r:0000201F                 db  61h ; a
.data$r:00002020                 db  6Dh ; m
.data$r:00002021                 db  5Fh ; _
.data$r:00002022                 db  65h ; e
.data$r:00002023                 db  72h ; r
.data$r:00002024                 db  72h ; r
.data$r:00002025                 db  6Fh ; o
.data$r:00002026                 db  72h ; r
.data$r:00002027                 db  5Fh ; _
.data$r:00002028                 db  63h ; c
.data$r:00002029                 db  61h ; a
.data$r:0000202A                 db  74h ; t
.data$r:0000202B                 db  65h ; e
.data$r:0000202C                 db  67h ; g
.data$r:0000202D                 db  6Fh ; o
.data$r:0000202E                 db  72h ; r
.data$r:0000202F                 db  79h ; y
.data$r:00002030                 db  40h ; @
.data$r:00002031                 db  73h ; s
.data$r:00002032                 db  74h ; t
.data$r:00002033                 db  64h ; d
.data$r:00002034                 db  40h ; @
.data$r:00002035                 db  40h ; @
.data$r:00002036                 db    0
.data$r:00002037                 align 4
.data$r:00002037 _data$r         ends
.data$r:00002037
.rdata$r:00002038 ; ===========================================================================
.rdata$r:00002038
.rdata$r:00002038 ; Segment type: Pure data
.rdata$r:00002038 ; Segment permissions: Read
.rdata$r:00002038 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002038                 assume cs:_rdata$r
.rdata$r:00002038                 ;org 2038h
.rdata$r:00002038 ; COMDAT (pick any)
.rdata$r:00002038                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002038 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002038 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002038                                         ; DATA XREF: .rdata$r:00002008o
.rdata$r:00002038                                         ; .rdata$r:00002070o
.rdata$r:00002039                 db    0
.rdata$r:0000203A                 db    0
.rdata$r:0000203B                 db    0
.rdata$r:0000203C                 db    0
.rdata$r:0000203D                 db    0
.rdata$r:0000203E                 db    0
.rdata$r:0000203F                 db    0
.rdata$r:00002040                 db    3
.rdata$r:00002041                 db    0
.rdata$r:00002042                 db    0
.rdata$r:00002043                 db    0
.rdata$r:00002044                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002044 _rdata$r        ends
.rdata$r:00002044
.rdata$r:00002048 ; ===========================================================================
.rdata$r:00002048
.rdata$r:00002048 ; Segment type: Pure data
.rdata$r:00002048 ; Segment permissions: Read
.rdata$r:00002048 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002048                 assume cs:_rdata$r
.rdata$r:00002048                 ;org 2048h
.rdata$r:00002048 ; COMDAT (pick any)
.rdata$r:00002048                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002048 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002048 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002048                                         ; DATA XREF: .rdata$r:00002044o
.rdata$r:00002048                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000204C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002050                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002054                 db    0
.rdata$r:00002055                 align 4
.rdata$r:00002055 _rdata$r        ends
.rdata$r:00002055
.rdata$r:00002058 ; ===========================================================================
.rdata$r:00002058
.rdata$r:00002058 ; Segment type: Pure data
.rdata$r:00002058 ; Segment permissions: Read
.rdata$r:00002058 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002058                 assume cs:_rdata$r
.rdata$r:00002058                 ;org 2058h
.rdata$r:00002058 ; COMDAT (pick any)
.rdata$r:00002058                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002058 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002058 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002058                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002058                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000205C                 db    2
.rdata$r:0000205D                 db    0
.rdata$r:0000205E                 db    0
.rdata$r:0000205F                 db    0
.rdata$r:00002060                 db    0
.rdata$r:00002061                 db    0
.rdata$r:00002062                 db    0
.rdata$r:00002063                 db    0
.rdata$r:00002064                 db 0FFh
.rdata$r:00002065                 db 0FFh
.rdata$r:00002066                 db 0FFh
.rdata$r:00002067                 db 0FFh
.rdata$r:00002068                 db    0
.rdata$r:00002069                 db    0
.rdata$r:0000206A                 db    0
.rdata$r:0000206B                 db    0
.rdata$r:0000206C                 db  40h ; @
.rdata$r:0000206D                 db    0
.rdata$r:0000206E                 db    0
.rdata$r:0000206F                 db    0
.rdata$r:00002070                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002070 _rdata$r        ends
.rdata$r:00002070
.rdata$r:00002074 ; ===========================================================================
.rdata$r:00002074
.rdata$r:00002074 ; Segment type: Pure data
.rdata$r:00002074 ; Segment permissions: Read
.rdata$r:00002074 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002074                 assume cs:_rdata$r
.rdata$r:00002074                 ;org 2074h
.rdata$r:00002074 ; COMDAT (pick any)
.rdata$r:00002074                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00002074 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00002074 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00001DF0o
.rdata$r:00002075                 db    0
.rdata$r:00002076                 db    0
.rdata$r:00002077                 db    0
.rdata$r:00002078                 db    0
.rdata$r:00002079                 db    0
.rdata$r:0000207A                 db    0
.rdata$r:0000207B                 db    0
.rdata$r:0000207C                 db    0
.rdata$r:0000207D                 db    0
.rdata$r:0000207E                 db    0
.rdata$r:0000207F                 db    0
.rdata$r:00002080                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002084                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002084 _rdata$r        ends
.rdata$r:00002084
.data$r:00002088 ; ===========================================================================
.data$r:00002088
.data$r:00002088 ; Segment type: Pure data
.data$r:00002088 ; Segment permissions: Read/Write
.data$r:00002088 _data$r         segment dword public 'DATA' use32
.data$r:00002088                 assume cs:_data$r
.data$r:00002088                 ;org 2088h
.data$r:00002088 ; COMDAT (pick any)
.data$r:00002088                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002088 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002088 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002088                                         ; DATA XREF: .rdata$r:00002080o
.data$r:00002088                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002088                                         ; const type_info::`vftable'
.data$r:0000208C                 align 10h
.data$r:00002090 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:000020B1                 align 4
.data$r:000020B1 _data$r         ends
.data$r:000020B1
.rdata$r:000020B4 ; ===========================================================================
.rdata$r:000020B4
.rdata$r:000020B4 ; Segment type: Pure data
.rdata$r:000020B4 ; Segment permissions: Read
.rdata$r:000020B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000020B4                 assume cs:_rdata$r
.rdata$r:000020B4                 ;org 20B4h
.rdata$r:000020B4 ; COMDAT (pick any)
.rdata$r:000020B4                 public ??_R3_System_error_category@std@@8
.rdata$r:000020B4 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000020B4 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002084o
.rdata$r:000020B4                                         ; .rdata$r:000020ECo
.rdata$r:000020B5                 db    0
.rdata$r:000020B6                 db    0
.rdata$r:000020B7                 db    0
.rdata$r:000020B8                 db    0
.rdata$r:000020B9                 db    0
.rdata$r:000020BA                 db    0
.rdata$r:000020BB                 db    0
.rdata$r:000020BC                 db    3
.rdata$r:000020BD                 db    0
.rdata$r:000020BE                 db    0
.rdata$r:000020BF                 db    0
.rdata$r:000020C0                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000020C0 _rdata$r        ends
.rdata$r:000020C0
.rdata$r:000020C4 ; ===========================================================================
.rdata$r:000020C4
.rdata$r:000020C4 ; Segment type: Pure data
.rdata$r:000020C4 ; Segment permissions: Read
.rdata$r:000020C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000020C4                 assume cs:_rdata$r
.rdata$r:000020C4                 ;org 20C4h
.rdata$r:000020C4 ; COMDAT (pick any)
.rdata$r:000020C4                 public ??_R2_System_error_category@std@@8
.rdata$r:000020C4 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000020C4 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000020C4                                         ; DATA XREF: .rdata$r:000020C0o
.rdata$r:000020C4                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000020C8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000020CC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000020D0                 db    0
.rdata$r:000020D1                 align 4
.rdata$r:000020D1 _rdata$r        ends
.rdata$r:000020D1
.rdata$r:000020D4 ; ===========================================================================
.rdata$r:000020D4
.rdata$r:000020D4 ; Segment type: Pure data
.rdata$r:000020D4 ; Segment permissions: Read
.rdata$r:000020D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000020D4                 assume cs:_rdata$r
.rdata$r:000020D4                 ;org 20D4h
.rdata$r:000020D4 ; COMDAT (pick any)
.rdata$r:000020D4                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000020D4 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000020D4 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000020D4                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000020D4                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000020D8                 db    2
.rdata$r:000020D9                 db    0
.rdata$r:000020DA                 db    0
.rdata$r:000020DB                 db    0
.rdata$r:000020DC                 db    0
.rdata$r:000020DD                 db    0
.rdata$r:000020DE                 db    0
.rdata$r:000020DF                 db    0
.rdata$r:000020E0                 db 0FFh
.rdata$r:000020E1                 db 0FFh
.rdata$r:000020E2                 db 0FFh
.rdata$r:000020E3                 db 0FFh
.rdata$r:000020E4                 db    0
.rdata$r:000020E5                 db    0
.rdata$r:000020E6                 db    0
.rdata$r:000020E7                 db    0
.rdata$r:000020E8                 db  40h ; @
.rdata$r:000020E9                 db    0
.rdata$r:000020EA                 db    0
.rdata$r:000020EB                 db    0
.rdata$r:000020EC                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000020EC _rdata$r        ends
.rdata$r:000020EC
.CRT$XCU:000020F0 ; ===========================================================================
.CRT$XCU:000020F0
.CRT$XCU:000020F0 ; Segment type: Pure data
.CRT$XCU:000020F0 ; Segment permissions: Read
.CRT$XCU:000020F0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000020F0                 assume cs:_CRT$XCU
.CRT$XCU:000020F0                 ;org 20F0h
.CRT$XCU:000020F0 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000020F4 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000020F4 _CRT$XCU        ends
.CRT$XCU:000020F4
.CRT$XCU:000020F8 ; ===========================================================================
.CRT$XCU:000020F8
.CRT$XCU:000020F8 ; Segment type: Pure data
.CRT$XCU:000020F8 ; Segment permissions: Read
.CRT$XCU:000020F8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000020F8                 assume cs:_CRT$XCU
.CRT$XCU:000020F8                 ;org 20F8h
.CRT$XCU:000020F8 ; COMDAT (pick associative to section at 1E14)
.CRT$XCU:000020F8 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000020F8 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000020F8 _CRT$XCU        ends
.CRT$XCU:000020F8
.CRT$XCU:000020FC ; ===========================================================================
.CRT$XCU:000020FC
.CRT$XCU:000020FC ; Segment type: Pure data
.CRT$XCU:000020FC ; Segment permissions: Read
.CRT$XCU:000020FC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000020FC                 assume cs:_CRT$XCU
.CRT$XCU:000020FC                 ;org 20FCh
.CRT$XCU:000020FC ; COMDAT (pick associative to section at 1E18)
.CRT$XCU:000020FC ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000020FC ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000020FC _CRT$XCU        ends
.CRT$XCU:000020FC
.CRT$XCU:00002100 ; ===========================================================================
.CRT$XCU:00002100
.CRT$XCU:00002100 ; Segment type: Pure data
.CRT$XCU:00002100 ; Segment permissions: Read
.CRT$XCU:00002100 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002100                 assume cs:_CRT$XCU
.CRT$XCU:00002100                 ;org 2100h
.CRT$XCU:00002100 ; COMDAT (pick associative to section at 1E1C)
.CRT$XCU:00002100 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002100 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002100 _CRT$XCU        ends
.CRT$XCU:00002100
.CRT$XCU:00002104 ; ===========================================================================
.CRT$XCU:00002104
.CRT$XCU:00002104 ; Segment type: Pure data
.CRT$XCU:00002104 ; Segment permissions: Read
.CRT$XCU:00002104 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002104                 assume cs:_CRT$XCU
.CRT$XCU:00002104                 ;org 2104h
.CRT$XCU:00002104 ; COMDAT (pick associative to section at 1E20)
.CRT$XCU:00002104 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00002104 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00002104 _CRT$XCU        ends
.CRT$XCU:00002104
.CRT$XCU:00002108 ; ===========================================================================
.CRT$XCU:00002108
.CRT$XCU:00002108 ; Segment type: Pure data
.CRT$XCU:00002108 ; Segment permissions: Read
.CRT$XCU:00002108 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002108                 assume cs:_CRT$XCU
.CRT$XCU:00002108                 ;org 2108h
.CRT$XCU:00002108 ; COMDAT (pick associative to section at 1E24)
.CRT$XCU:00002108 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00002108 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00002108 _CRT$XCU        ends
.CRT$XCU:00002108
.CRT$XCU:0000210C ; ===========================================================================
.CRT$XCU:0000210C
.CRT$XCU:0000210C ; Segment type: Pure data
.CRT$XCU:0000210C ; Segment permissions: Read
.CRT$XCU:0000210C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000210C                 assume cs:_CRT$XCU
.CRT$XCU:0000210C                 ;org 210Ch
.CRT$XCU:0000210C ; COMDAT (pick associative to section at 1EB8)
.CRT$XCU:0000210C ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000210C ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000210C _CRT$XCU        ends
.CRT$XCU:0000210C
.CRT$XCU:00002110 ; ===========================================================================
.CRT$XCU:00002110
.CRT$XCU:00002110 ; Segment type: Pure data
.CRT$XCU:00002110 ; Segment permissions: Read
.CRT$XCU:00002110 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002110                 assume cs:_CRT$XCU
.CRT$XCU:00002110                 ;org 2110h
.CRT$XCU:00002110 ; COMDAT (pick associative to section at 1EBC)
.CRT$XCU:00002110 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00002110 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00002110 _CRT$XCU        ends
.CRT$XCU:00002110
UNDEF:00002120 ; ===========================================================================
UNDEF:00002120
UNDEF:00002120 ; Segment type: Externs
UNDEF:00002120 ; UNDEF
UNDEF:00002120                 extrn __purecall:near   ; DATA XREF: .rdata:00001D68o
UNDEF:00002120                                         ; .rdata:00001D6Co
UNDEF:00002124 ; void *__cdecl operator new(unsigned int)
UNDEF:00002124                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00002124                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00002128 ; void __cdecl operator delete(void *)
UNDEF:00002128                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00002128                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000212C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000212C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000212C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002130 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00002130                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002134 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002134                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002138 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002138                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:0000213C ; HINSTANCE __stdcall ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
UNDEF:0000213C                 extrn __imp__ShellExecuteW@24:near
UNDEF:0000213C                                         ; CODE XREF: Process::run(void)+39p
UNDEF:0000213C                                         ; DATA XREF: Process::run(void)+39r
UNDEF:00002140 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00002140                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00002140                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002144 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002144                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002144                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002144                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00002148                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000214C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000214C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000214C                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00002150 ; void __cdecl std::_Xbad_alloc()
UNDEF:00002150                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00002150                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_7Ep
UNDEF:00002150                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_C0p
UNDEF:00002154 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00002154                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00002154                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00002158 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00002158                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00002158                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000215C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000215C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000215C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00002160 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00002160                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00002160                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00002160                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00002164 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00002164                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00002164                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00002168 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002168                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002168                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000216C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000216C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000216C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00002170 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002170                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002170                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00002174 ; __fastcall __security_check_cookie(x)
UNDEF:00002174                 extrn @__security_check_cookie@4:near
UNDEF:00002174                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp
UNDEF:00002174                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+Cp ...
UNDEF:00002178 ; __stdcall _CxxThrowException(x, x)
UNDEF:00002178                 extrn __CxxThrowException@8:near
UNDEF:00002178                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:0000217C                 extrn ___CxxFrameHandler3:near
UNDEF:0000217C                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:0000217C                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:00002180 ; const type_info::`vftable'
UNDEF:00002180                 extrn ??_7type_info@@6B@:near
UNDEF:00002180                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00002180                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00002184                 extrn ___security_cookie:near
UNDEF:00002184                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r
UNDEF:00002184                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+14r ...
UNDEF:00002188                 extrn __fltused:near
UNDEF:00002188
UNDEF:00002188
UNDEF:00002188                 end