.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 4E25DD592C4EEF55DAA2442DE64E5C9B
.rdata:00000000 ; Input CRC32 : 3C81433F
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\tinyxmlerrorA.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG94430        db 'No error',0         ; DATA XREF: .data:char const * * TiXmlBaseA::errorStringo
.rdata:00000009                 align 4
.rdata:0000000C $SG94431        db 'Error',0            ; DATA XREF: .data:00000148o
.rdata:00000012                 align 4
.rdata:00000014 $SG94432        db 'Failed to open file',0 ; DATA XREF: .data:0000014Co
.rdata:00000028 $SG94433        db 'Memory allocation failed.',0
.rdata:00000028                                         ; DATA XREF: .data:00000150o
.rdata:00000042                 align 4
.rdata:00000044 $SG94434        db 'Error parsing Element.',0 ; DATA XREF: .data:00000154o
.rdata:0000005B                 align 4
.rdata:0000005C $SG94435        db 'Failed to read Element name',0
.rdata:0000005C                                         ; DATA XREF: .data:00000158o
.rdata:00000078 $SG94436        db 'Error reading Element value.',0
.rdata:00000078                                         ; DATA XREF: .data:0000015Co
.rdata:00000095                 align 4
.rdata:00000098 $SG94437        db 'Error reading Attributes.',0
.rdata:00000098                                         ; DATA XREF: .data:00000160o
.rdata:000000B2                 align 4
.rdata:000000B4 $SG94438        db 'Error: empty tag.',0 ; DATA XREF: .data:00000164o
.rdata:000000C6                 align 4
.rdata:000000C8 $SG94439        db 'Error reading end tag.',0 ; DATA XREF: .data:00000168o
.rdata:000000DF                 align 10h
.rdata:000000E0 $SG94440        db 'Error parsing Unknown.',0 ; DATA XREF: .data:0000016Co
.rdata:000000F7                 align 4
.rdata:000000F8 $SG94441        db 'Error parsing Comment.',0 ; DATA XREF: .data:00000170o
.rdata:0000010F                 align 10h
.rdata:00000110 $SG94442        db 'Error parsing Declaration.',0
.rdata:00000110                                         ; DATA XREF: .data:00000174o
.rdata:0000012B                 align 4
.rdata:0000012C $SG94443        db 'Error document empty.',0 ; DATA XREF: .data:00000178o
.rdata:00000142                 align 4
.rdata:00000142 _rdata          ends
.rdata:00000142
.data:00000144 ; ===========================================================================
.data:00000144
.data:00000144 ; Segment type: Pure data
.data:00000144 ; Segment permissions: Read/Write
.data:00000144 _data           segment dword public 'DATA' use32
.data:00000144                 assume cs:_data
.data:00000144                 ;org 144h
.data:00000144                 public ?errorString@TiXmlBaseA@@1PAPBDA
.data:00000144 ; protected: static char const * * TiXmlBaseA::errorString
.data:00000144 ?errorString@TiXmlBaseA@@1PAPBDA dd offset $SG94430 ; "No error"
.data:00000148                 dd offset $SG94431      ; "Error"
.data:0000014C                 dd offset $SG94432      ; "Failed to open file"
.data:00000150                 dd offset $SG94433      ; "Memory allocation failed."
.data:00000154                 dd offset $SG94434      ; "Error parsing Element."
.data:00000158                 dd offset $SG94435      ; "Failed to read Element name"
.data:0000015C                 dd offset $SG94436      ; "Error reading Element value."
.data:00000160                 dd offset $SG94437      ; "Error reading Attributes."
.data:00000164                 dd offset $SG94438      ; "Error: empty tag."
.data:00000168                 dd offset $SG94439      ; "Error reading end tag."
.data:0000016C                 dd offset $SG94440      ; "Error parsing Unknown."
.data:00000170                 dd offset $SG94441      ; "Error parsing Comment."
.data:00000174                 dd offset $SG94442      ; "Error parsing Declaration."
.data:00000178                 dd offset $SG94443      ; "Error document empty."
.data:00000178 _data           ends
.data:00000178
.text$mn:0000017C ; ===========================================================================
.text$mn:0000017C
.text$mn:0000017C ; Segment type: Pure code
.text$mn:0000017C ; Segment permissions: Read/Execute
.text$mn:0000017C _text$mn        segment para public 'CODE' use32
.text$mn:0000017C                 assume cs:_text$mn
.text$mn:0000017C                 ;org 17Ch
.text$mn:0000017C ; COMDAT (pick any)
.text$mn:0000017C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000017C
.text$mn:0000017C ; =============== S U B R O U T I N E =======================================
.text$mn:0000017C
.text$mn:0000017C ; Attributes: bp-based frame
.text$mn:0000017C
.text$mn:0000017C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:0000017C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:0000017C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:0000017C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:0000017C
.text$mn:0000017C var_4           = dword ptr -4
.text$mn:0000017C arg_0           = dword ptr  8
.text$mn:0000017C
.text$mn:0000017C                 push    ebp
.text$mn:0000017D                 mov     ebp, esp
.text$mn:0000017F                 push    ecx
.text$mn:00000180                 mov     [ebp+var_4], 0
.text$mn:00000187                 cmp     [ebp+arg_0], 0
.text$mn:0000018B                 jnz     short loc_18F
.text$mn:0000018D                 jmp     short loc_1AF
.text$mn:0000018F ; ---------------------------------------------------------------------------
.text$mn:0000018F
.text$mn:0000018F loc_18F:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000018F                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00000193                 ja      short loc_1AA
.text$mn:00000195                 mov     eax, [ebp+arg_0]
.text$mn:00000198                 push    eax             ; unsigned int
.text$mn:00000199                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000019E                 add     esp, 4
.text$mn:000001A1                 mov     [ebp+var_4], eax
.text$mn:000001A4                 cmp     [ebp+var_4], 0
.text$mn:000001A8                 jnz     short loc_1AF
.text$mn:000001AA
.text$mn:000001AA loc_1AA:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000001AA                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000001AF
.text$mn:000001AF loc_1AF:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000001AF                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000001AF                 mov     eax, [ebp+var_4]
.text$mn:000001B2                 mov     esp, ebp
.text$mn:000001B4                 pop     ebp
.text$mn:000001B5                 retn
.text$mn:000001B5 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000001B5
.text$mn:000001B5 ; ---------------------------------------------------------------------------
.text$mn:000001B6                 align 4
.text$mn:000001B6 _text$mn        ends
.text$mn:000001B6
.text$mn:000001B8 ; ===========================================================================
.text$mn:000001B8
.text$mn:000001B8 ; Segment type: Pure code
.text$mn:000001B8 ; Segment permissions: Read/Execute
.text$mn:000001B8 _text$mn        segment para public 'CODE' use32
.text$mn:000001B8                 assume cs:_text$mn
.text$mn:000001B8                 ;org 1B8h
.text$mn:000001B8 ; COMDAT (pick any)
.text$mn:000001B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000001B8
.text$mn:000001B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000001B8
.text$mn:000001B8 ; Attributes: bp-based frame
.text$mn:000001B8
.text$mn:000001B8 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000001B8                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000001B8 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000001B8                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000001B8
.text$mn:000001B8 var_4           = dword ptr -4
.text$mn:000001B8 arg_0           = dword ptr  8
.text$mn:000001B8
.text$mn:000001B8                 push    ebp
.text$mn:000001B9                 mov     ebp, esp
.text$mn:000001BB                 push    ecx
.text$mn:000001BC                 mov     [ebp+var_4], 0
.text$mn:000001C3                 cmp     [ebp+arg_0], 0
.text$mn:000001C7                 jnz     short loc_1CB
.text$mn:000001C9                 jmp     short loc_1F1
.text$mn:000001CB ; ---------------------------------------------------------------------------
.text$mn:000001CB
.text$mn:000001CB loc_1CB:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000001CB                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000001D2                 ja      short loc_1EC
.text$mn:000001D4                 mov     eax, [ebp+arg_0]
.text$mn:000001D7                 shl     eax, 3
.text$mn:000001DA                 push    eax             ; unsigned int
.text$mn:000001DB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000001E0                 add     esp, 4
.text$mn:000001E3                 mov     [ebp+var_4], eax
.text$mn:000001E6                 cmp     [ebp+var_4], 0
.text$mn:000001EA                 jnz     short loc_1F1
.text$mn:000001EC
.text$mn:000001EC loc_1EC:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000001EC                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000001F1
.text$mn:000001F1 loc_1F1:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000001F1                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000001F1                 mov     eax, [ebp+var_4]
.text$mn:000001F4                 mov     esp, ebp
.text$mn:000001F6                 pop     ebp
.text$mn:000001F7                 retn
.text$mn:000001F7 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000001F7
.text$mn:000001F7 _text$mn        ends
.text$mn:000001F7
.text$mn:000001F8 ; ===========================================================================
.text$mn:000001F8
.text$mn:000001F8 ; Segment type: Pure code
.text$mn:000001F8 ; Segment permissions: Read/Execute
.text$mn:000001F8 _text$mn        segment para public 'CODE' use32
.text$mn:000001F8                 assume cs:_text$mn
.text$mn:000001F8                 ;org 1F8h
.text$mn:000001F8 ; COMDAT (pick any)
.text$mn:000001F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000001F8
.text$mn:000001F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000001F8
.text$mn:000001F8 ; Attributes: bp-based frame
.text$mn:000001F8
.text$mn:000001F8 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000001F8                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000001F8 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000001F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000001F8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000001F8
.text$mn:000001F8 arg_0           = dword ptr  8
.text$mn:000001F8 arg_4           = dword ptr  0Ch
.text$mn:000001F8 arg_8           = dword ptr  10h
.text$mn:000001F8
.text$mn:000001F8                 push    ebp
.text$mn:000001F9                 mov     ebp, esp
.text$mn:000001FB                 cmp     [ebp+arg_0], 0
.text$mn:000001FF                 jnz     short loc_216
.text$mn:00000201                 mov     eax, [ebp+arg_8]
.text$mn:00000204                 push    eax             ; unsigned int
.text$mn:00000205                 mov     ecx, [ebp+arg_4]
.text$mn:00000208                 push    ecx             ; wchar_t *
.text$mn:00000209                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000020E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000213                 add     esp, 0Ch
.text$mn:00000216
.text$mn:00000216 loc_216:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00000216                 pop     ebp
.text$mn:00000217                 retn
.text$mn:00000217 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00000217
.text$mn:00000217 _text$mn        ends
.text$mn:00000217
.text$mn:00000218 ; ===========================================================================
.text$mn:00000218
.text$mn:00000218 ; Segment type: Pure code
.text$mn:00000218 ; Segment permissions: Read/Execute
.text$mn:00000218 _text$mn        segment para public 'CODE' use32
.text$mn:00000218                 assume cs:_text$mn
.text$mn:00000218                 ;org 218h
.text$mn:00000218 ; COMDAT (pick any)
.text$mn:00000218                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000218
.text$mn:00000218 ; =============== S U B R O U T I N E =======================================
.text$mn:00000218
.text$mn:00000218 ; Attributes: bp-based frame
.text$mn:00000218
.text$mn:00000218 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000218                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000218 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000218                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000218                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000218
.text$mn:00000218 arg_0           = dword ptr  8
.text$mn:00000218
.text$mn:00000218                 push    ebp
.text$mn:00000219                 mov     ebp, esp
.text$mn:0000021B                 mov     eax, [ebp+arg_0]
.text$mn:0000021E                 pop     ebp
.text$mn:0000021F                 retn
.text$mn:0000021F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000021F
.text$mn:0000021F _text$mn        ends
.text$mn:0000021F
.text$mn:00000220 ; ===========================================================================
.text$mn:00000220
.text$mn:00000220 ; Segment type: Pure code
.text$mn:00000220 ; Segment permissions: Read/Execute
.text$mn:00000220 _text$mn        segment para public 'CODE' use32
.text$mn:00000220                 assume cs:_text$mn
.text$mn:00000220                 ;org 220h
.text$mn:00000220 ; COMDAT (pick any)
.text$mn:00000220                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000220
.text$mn:00000220 ; =============== S U B R O U T I N E =======================================
.text$mn:00000220
.text$mn:00000220 ; Attributes: bp-based frame
.text$mn:00000220
.text$mn:00000220 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00000220                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00000220 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000220                                         ; CODE XREF: $LN19+4Bp
.text$mn:00000220
.text$mn:00000220 var_4           = dword ptr -4
.text$mn:00000220 arg_0           = dword ptr  8
.text$mn:00000220 arg_4           = dword ptr  0Ch
.text$mn:00000220
.text$mn:00000220                 push    ebp
.text$mn:00000221                 mov     ebp, esp
.text$mn:00000223                 push    ecx
.text$mn:00000224                 mov     [ebp+var_4], ecx
.text$mn:00000227                 mov     eax, [ebp+arg_4]
.text$mn:0000022A                 push    eax
.text$mn:0000022B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000230                 add     esp, 4
.text$mn:00000233                 push    eax             ; int
.text$mn:00000234                 mov     ecx, [ebp+arg_0]
.text$mn:00000237                 push    ecx             ; void *
.text$mn:00000238                 mov     edx, [ebp+var_4]
.text$mn:0000023B                 push    edx             ; int
.text$mn:0000023C                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000241                 add     esp, 0Ch
.text$mn:00000244                 mov     esp, ebp
.text$mn:00000246                 pop     ebp
.text$mn:00000247                 retn    8
.text$mn:00000247 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000247
.text$mn:00000247 ; ---------------------------------------------------------------------------
.text$mn:0000024A                 align 4
.text$mn:0000024A _text$mn        ends
.text$mn:0000024A
.text$mn:0000024C ; ===========================================================================
.text$mn:0000024C
.text$mn:0000024C ; Segment type: Pure code
.text$mn:0000024C ; Segment permissions: Read/Execute
.text$mn:0000024C _text$mn        segment para public 'CODE' use32
.text$mn:0000024C                 assume cs:_text$mn
.text$mn:0000024C                 ;org 24Ch
.text$mn:0000024C ; COMDAT (pick any)
.text$mn:0000024C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000024C
.text$mn:0000024C ; =============== S U B R O U T I N E =======================================
.text$mn:0000024C
.text$mn:0000024C ; Attributes: bp-based frame
.text$mn:0000024C
.text$mn:0000024C ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:0000024C                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000024C ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000024C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:0000024C
.text$mn:0000024C var_1C          = dword ptr -1Ch
.text$mn:0000024C var_18          = dword ptr -18h
.text$mn:0000024C var_14          = dword ptr -14h
.text$mn:0000024C var_10          = dword ptr -10h
.text$mn:0000024C var_C           = dword ptr -0Ch
.text$mn:0000024C var_4           = dword ptr -4
.text$mn:0000024C arg_0           = dword ptr  8
.text$mn:0000024C arg_4           = dword ptr  0Ch
.text$mn:0000024C
.text$mn:0000024C                 push    ebp
.text$mn:0000024D                 mov     ebp, esp
.text$mn:0000024F                 push    0FFFFFFFFh
.text$mn:00000251                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000256                 mov     eax, large fs:0
.text$mn:0000025C                 push    eax
.text$mn:0000025D                 sub     esp, 10h
.text$mn:00000260                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000265                 xor     eax, ebp
.text$mn:00000267                 push    eax
.text$mn:00000268                 lea     eax, [ebp+var_C]
.text$mn:0000026B                 mov     large fs:0, eax
.text$mn:00000271                 mov     [ebp+var_18], ecx
.text$mn:00000274                 mov     eax, [ebp+arg_0]
.text$mn:00000277                 push    eax             ; void *
.text$mn:00000278                 push    4               ; unsigned int
.text$mn:0000027A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000027F                 add     esp, 8
.text$mn:00000282                 mov     [ebp+var_10], eax
.text$mn:00000285                 mov     [ebp+var_4], 0
.text$mn:0000028C                 cmp     [ebp+var_10], 0
.text$mn:00000290                 jz      short loc_2AD
.text$mn:00000292                 mov     ecx, [ebp+arg_4]
.text$mn:00000295                 push    ecx
.text$mn:00000296                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000029B                 add     esp, 4
.text$mn:0000029E                 mov     edx, [ebp+var_10]
.text$mn:000002A1                 mov     eax, [eax]
.text$mn:000002A3                 mov     [edx], eax
.text$mn:000002A5                 mov     ecx, [ebp+var_10]
.text$mn:000002A8                 mov     [ebp+var_14], ecx
.text$mn:000002AB                 jmp     short loc_2B4
.text$mn:000002AD ; ---------------------------------------------------------------------------
.text$mn:000002AD
.text$mn:000002AD loc_2AD:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000002AD                 mov     [ebp+var_14], 0
.text$mn:000002B4
.text$mn:000002B4 loc_2B4:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000002B4                 mov     edx, [ebp+var_14]
.text$mn:000002B7                 mov     [ebp+var_1C], edx
.text$mn:000002BA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000002C1                 mov     ecx, [ebp+var_C]
.text$mn:000002C4                 mov     large fs:0, ecx
.text$mn:000002CB                 pop     ecx
.text$mn:000002CC                 mov     esp, ebp
.text$mn:000002CE                 pop     ebp
.text$mn:000002CF                 retn    8
.text$mn:000002CF ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000002CF
.text$mn:000002CF ; ---------------------------------------------------------------------------
.text$mn:000002D2                 align 4
.text$mn:000002D2 _text$mn        ends
.text$mn:000002D2
.text$x:000002D4 ; ===========================================================================
.text$x:000002D4
.text$x:000002D4 ; Segment type: Pure code
.text$x:000002D4 ; Segment permissions: Read/Execute
.text$x:000002D4 _text$x         segment para public 'CODE' use32
.text$x:000002D4                 assume cs:_text$x
.text$x:000002D4                 ;org 2D4h
.text$x:000002D4 ; COMDAT (pick associative to section at 24C)
.text$x:000002D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000002D4
.text$x:000002D4 ; =============== S U B R O U T I N E =======================================
.text$x:000002D4
.text$x:000002D4
.text$x:000002D4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000002D4                                         ; DATA XREF: .xdata$x:00001E0Co
.text$x:000002D4                 mov     eax, [ebp+8]
.text$x:000002D7                 push    eax
.text$x:000002D8                 mov     eax, [ebp-10h]
.text$x:000002DB                 push    eax             ; void *
.text$x:000002DC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000002E1                 add     esp, 8
.text$x:000002E4                 retn
.text$x:000002E4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000002E4
.text$x:000002E5
.text$x:000002E5 ; =============== S U B R O U T I N E =======================================
.text$x:000002E5
.text$x:000002E5
.text$x:000002E5 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000002E5                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000002E5
.text$x:000002E5 arg_4           = dword ptr  8
.text$x:000002E5
.text$x:000002E5                 mov     edx, [esp+arg_4]
.text$x:000002E9                 lea     eax, [edx+0Ch]
.text$x:000002EC                 mov     ecx, [edx-14h]
.text$x:000002EF                 xor     ecx, eax
.text$x:000002F1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000002F6                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000002FB                 jmp     ___CxxFrameHandler3
.text$x:000002FB __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000002FB
.text$x:000002FB _text$x         ends
.text$x:000002FB
.text$mn:00000300 ; ===========================================================================
.text$mn:00000300
.text$mn:00000300 ; Segment type: Pure code
.text$mn:00000300 ; Segment permissions: Read/Execute
.text$mn:00000300 _text$mn        segment para public 'CODE' use32
.text$mn:00000300                 assume cs:_text$mn
.text$mn:00000300                 ;org 300h
.text$mn:00000300 ; COMDAT (pick any)
.text$mn:00000300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000300
.text$mn:00000300 ; =============== S U B R O U T I N E =======================================
.text$mn:00000300
.text$mn:00000300 ; Attributes: bp-based frame
.text$mn:00000300
.text$mn:00000300 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000300                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000300 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000300                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000300
.text$mn:00000300 arg_0           = dword ptr  8
.text$mn:00000300 arg_4           = dword ptr  0Ch
.text$mn:00000300 arg_8           = dword ptr  10h
.text$mn:00000300
.text$mn:00000300                 push    ebp
.text$mn:00000301                 mov     ebp, esp
.text$mn:00000303                 mov     eax, [ebp+arg_8]
.text$mn:00000306                 push    eax
.text$mn:00000307                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000030C                 add     esp, 4
.text$mn:0000030F                 push    eax             ; int
.text$mn:00000310                 mov     ecx, [ebp+arg_4]
.text$mn:00000313                 push    ecx             ; void *
.text$mn:00000314                 mov     ecx, [ebp+arg_0]
.text$mn:00000317                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000031C                 pop     ebp
.text$mn:0000031D                 retn
.text$mn:0000031D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:0000031D
.text$mn:0000031D ; ---------------------------------------------------------------------------
.text$mn:0000031E                 align 10h
.text$mn:0000031E _text$mn        ends
.text$mn:0000031E
.text$mn:00000320 ; ===========================================================================
.text$mn:00000320
.text$mn:00000320 ; Segment type: Pure code
.text$mn:00000320 ; Segment permissions: Read/Execute
.text$mn:00000320 _text$mn        segment para public 'CODE' use32
.text$mn:00000320                 assume cs:_text$mn
.text$mn:00000320                 ;org 320h
.text$mn:00000320 ; COMDAT (pick any)
.text$mn:00000320                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000320
.text$mn:00000320 ; =============== S U B R O U T I N E =======================================
.text$mn:00000320
.text$mn:00000320 ; Attributes: bp-based frame
.text$mn:00000320
.text$mn:00000320 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000320                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000320 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000320                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000320
.text$mn:00000320 var_1C          = dword ptr -1Ch
.text$mn:00000320 var_18          = dword ptr -18h
.text$mn:00000320 var_14          = dword ptr -14h
.text$mn:00000320 var_10          = dword ptr -10h
.text$mn:00000320 var_C           = dword ptr -0Ch
.text$mn:00000320 var_4           = dword ptr -4
.text$mn:00000320 arg_0           = dword ptr  8
.text$mn:00000320 arg_4           = dword ptr  0Ch
.text$mn:00000320
.text$mn:00000320                 push    ebp
.text$mn:00000321                 mov     ebp, esp
.text$mn:00000323                 push    0FFFFFFFFh
.text$mn:00000325                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000032A                 mov     eax, large fs:0
.text$mn:00000330                 push    eax
.text$mn:00000331                 sub     esp, 10h
.text$mn:00000334                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000339                 xor     eax, ebp
.text$mn:0000033B                 push    eax
.text$mn:0000033C                 lea     eax, [ebp+var_C]
.text$mn:0000033F                 mov     large fs:0, eax
.text$mn:00000345                 mov     [ebp+var_18], ecx
.text$mn:00000348                 mov     eax, [ebp+arg_0]
.text$mn:0000034B                 push    eax             ; void *
.text$mn:0000034C                 push    8               ; unsigned int
.text$mn:0000034E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000353                 add     esp, 8
.text$mn:00000356                 mov     [ebp+var_10], eax
.text$mn:00000359                 mov     [ebp+var_4], 0
.text$mn:00000360                 cmp     [ebp+var_10], 0
.text$mn:00000364                 jz      short loc_387
.text$mn:00000366                 mov     ecx, [ebp+arg_4]
.text$mn:00000369                 push    ecx
.text$mn:0000036A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000036F                 add     esp, 4
.text$mn:00000372                 mov     edx, [eax]
.text$mn:00000374                 mov     eax, [eax+4]
.text$mn:00000377                 mov     ecx, [ebp+var_10]
.text$mn:0000037A                 mov     [ecx], edx
.text$mn:0000037C                 mov     [ecx+4], eax
.text$mn:0000037F                 mov     edx, [ebp+var_10]
.text$mn:00000382                 mov     [ebp+var_14], edx
.text$mn:00000385                 jmp     short loc_38E
.text$mn:00000387 ; ---------------------------------------------------------------------------
.text$mn:00000387
.text$mn:00000387 loc_387:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000387                 mov     [ebp+var_14], 0
.text$mn:0000038E
.text$mn:0000038E loc_38E:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000038E                 mov     eax, [ebp+var_14]
.text$mn:00000391                 mov     [ebp+var_1C], eax
.text$mn:00000394                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000039B                 mov     ecx, [ebp+var_C]
.text$mn:0000039E                 mov     large fs:0, ecx
.text$mn:000003A5                 pop     ecx
.text$mn:000003A6                 mov     esp, ebp
.text$mn:000003A8                 pop     ebp
.text$mn:000003A9                 retn    8
.text$mn:000003A9 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000003A9
.text$mn:000003A9 _text$mn        ends
.text$mn:000003A9
.text$x:000003AC ; ===========================================================================
.text$x:000003AC
.text$x:000003AC ; Segment type: Pure code
.text$x:000003AC ; Segment permissions: Read/Execute
.text$x:000003AC _text$x         segment para public 'CODE' use32
.text$x:000003AC                 assume cs:_text$x
.text$x:000003AC                 ;org 3ACh
.text$x:000003AC ; COMDAT (pick associative to section at 320)
.text$x:000003AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000003AC
.text$x:000003AC ; =============== S U B R O U T I N E =======================================
.text$x:000003AC
.text$x:000003AC
.text$x:000003AC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000003AC                                         ; DATA XREF: .xdata$x:00001DE0o
.text$x:000003AC                 mov     eax, [ebp+8]
.text$x:000003AF                 push    eax
.text$x:000003B0                 mov     eax, [ebp-10h]
.text$x:000003B3                 push    eax             ; void *
.text$x:000003B4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000003B9                 add     esp, 8
.text$x:000003BC                 retn
.text$x:000003BC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000003BC
.text$x:000003BD
.text$x:000003BD ; =============== S U B R O U T I N E =======================================
.text$x:000003BD
.text$x:000003BD
.text$x:000003BD __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000003BD                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000003BD
.text$x:000003BD arg_4           = dword ptr  8
.text$x:000003BD
.text$x:000003BD                 mov     edx, [esp+arg_4]
.text$x:000003C1                 lea     eax, [edx+0Ch]
.text$x:000003C4                 mov     ecx, [edx-14h]
.text$x:000003C7                 xor     ecx, eax
.text$x:000003C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000003CE                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000003D3                 jmp     ___CxxFrameHandler3
.text$x:000003D3 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000003D3
.text$x:000003D3 _text$x         ends
.text$x:000003D3
.text$mn:000003D8 ; ===========================================================================
.text$mn:000003D8
.text$mn:000003D8 ; Segment type: Pure code
.text$mn:000003D8 ; Segment permissions: Read/Execute
.text$mn:000003D8 _text$mn        segment para public 'CODE' use32
.text$mn:000003D8                 assume cs:_text$mn
.text$mn:000003D8                 ;org 3D8h
.text$mn:000003D8 ; COMDAT (pick any)
.text$mn:000003D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000003D8
.text$mn:000003D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000003D8
.text$mn:000003D8 ; Attributes: bp-based frame
.text$mn:000003D8
.text$mn:000003D8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000003D8                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000003D8 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000003D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000003D8
.text$mn:000003D8 var_4           = dword ptr -4
.text$mn:000003D8 arg_0           = dword ptr  8
.text$mn:000003D8
.text$mn:000003D8                 push    ebp
.text$mn:000003D9                 mov     ebp, esp
.text$mn:000003DB                 push    ecx
.text$mn:000003DC                 mov     [ebp+var_4], ecx
.text$mn:000003DF                 mov     eax, [ebp+arg_0]
.text$mn:000003E2                 push    eax
.text$mn:000003E3                 mov     ecx, [ebp+var_4]
.text$mn:000003E6                 push    ecx
.text$mn:000003E7                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000003EC                 add     esp, 8
.text$mn:000003EF                 mov     esp, ebp
.text$mn:000003F1                 pop     ebp
.text$mn:000003F2                 retn    4
.text$mn:000003F2 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000003F2
.text$mn:000003F2 ; ---------------------------------------------------------------------------
.text$mn:000003F5                 align 4
.text$mn:000003F5 _text$mn        ends
.text$mn:000003F5
.text$mn:000003F8 ; ===========================================================================
.text$mn:000003F8
.text$mn:000003F8 ; Segment type: Pure code
.text$mn:000003F8 ; Segment permissions: Read/Execute
.text$mn:000003F8 _text$mn        segment para public 'CODE' use32
.text$mn:000003F8                 assume cs:_text$mn
.text$mn:000003F8                 ;org 3F8h
.text$mn:000003F8 ; COMDAT (pick any)
.text$mn:000003F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000003F8
.text$mn:000003F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000003F8
.text$mn:000003F8 ; Attributes: bp-based frame
.text$mn:000003F8
.text$mn:000003F8 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000003F8                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000003F8 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000003F8                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000003F8
.text$mn:000003F8 var_4           = dword ptr -4
.text$mn:000003F8
.text$mn:000003F8                 push    ebp
.text$mn:000003F9                 mov     ebp, esp
.text$mn:000003FB                 push    ecx
.text$mn:000003FC                 mov     [ebp+var_4], ecx
.text$mn:000003FF                 mov     esp, ebp
.text$mn:00000401                 pop     ebp
.text$mn:00000402                 retn    4
.text$mn:00000402 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000402
.text$mn:00000402 ; ---------------------------------------------------------------------------
.text$mn:00000405                 align 4
.text$mn:00000405 _text$mn        ends
.text$mn:00000405
.text$mn:00000408 ; ===========================================================================
.text$mn:00000408
.text$mn:00000408 ; Segment type: Pure code
.text$mn:00000408 ; Segment permissions: Read/Execute
.text$mn:00000408 _text$mn        segment para public 'CODE' use32
.text$mn:00000408                 assume cs:_text$mn
.text$mn:00000408                 ;org 408h
.text$mn:00000408 ; COMDAT (pick any)
.text$mn:00000408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000408
.text$mn:00000408 ; =============== S U B R O U T I N E =======================================
.text$mn:00000408
.text$mn:00000408 ; Attributes: bp-based frame
.text$mn:00000408
.text$mn:00000408 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000408                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000408 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000408                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000408
.text$mn:00000408 arg_0           = dword ptr  8
.text$mn:00000408 arg_4           = dword ptr  0Ch
.text$mn:00000408
.text$mn:00000408                 push    ebp
.text$mn:00000409                 mov     ebp, esp
.text$mn:0000040B                 mov     eax, [ebp+arg_4]
.text$mn:0000040E                 push    eax
.text$mn:0000040F                 mov     ecx, [ebp+arg_0]
.text$mn:00000412                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000417                 pop     ebp
.text$mn:00000418                 retn
.text$mn:00000418 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000418
.text$mn:00000418 ; ---------------------------------------------------------------------------
.text$mn:00000419                 align 4
.text$mn:00000419 _text$mn        ends
.text$mn:00000419
.text$mn:0000041C ; ===========================================================================
.text$mn:0000041C
.text$mn:0000041C ; Segment type: Pure code
.text$mn:0000041C ; Segment permissions: Read/Execute
.text$mn:0000041C _text$mn        segment para public 'CODE' use32
.text$mn:0000041C                 assume cs:_text$mn
.text$mn:0000041C                 ;org 41Ch
.text$mn:0000041C ; COMDAT (pick any)
.text$mn:0000041C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000041C
.text$mn:0000041C ; =============== S U B R O U T I N E =======================================
.text$mn:0000041C
.text$mn:0000041C ; Attributes: bp-based frame
.text$mn:0000041C
.text$mn:0000041C ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:0000041C                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:0000041C ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:0000041C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:0000041C
.text$mn:0000041C var_4           = dword ptr -4
.text$mn:0000041C
.text$mn:0000041C                 push    ebp
.text$mn:0000041D                 mov     ebp, esp
.text$mn:0000041F                 push    ecx
.text$mn:00000420                 mov     [ebp+var_4], ecx
.text$mn:00000423                 mov     esp, ebp
.text$mn:00000425                 pop     ebp
.text$mn:00000426                 retn    4
.text$mn:00000426 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000426
.text$mn:00000426 ; ---------------------------------------------------------------------------
.text$mn:00000429                 align 4
.text$mn:00000429 _text$mn        ends
.text$mn:00000429
.text$mn:0000042C ; ===========================================================================
.text$mn:0000042C
.text$mn:0000042C ; Segment type: Pure code
.text$mn:0000042C ; Segment permissions: Read/Execute
.text$mn:0000042C _text$mn        segment para public 'CODE' use32
.text$mn:0000042C                 assume cs:_text$mn
.text$mn:0000042C                 ;org 42Ch
.text$mn:0000042C ; COMDAT (pick any)
.text$mn:0000042C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000042C
.text$mn:0000042C ; =============== S U B R O U T I N E =======================================
.text$mn:0000042C
.text$mn:0000042C ; Attributes: bp-based frame
.text$mn:0000042C
.text$mn:0000042C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:0000042C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:0000042C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:0000042C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:0000042C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:0000042C
.text$mn:0000042C arg_0           = dword ptr  8
.text$mn:0000042C
.text$mn:0000042C                 push    ebp
.text$mn:0000042D                 mov     ebp, esp
.text$mn:0000042F                 mov     eax, [ebp+arg_0]
.text$mn:00000432                 pop     ebp
.text$mn:00000433                 retn
.text$mn:00000433 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000433
.text$mn:00000433 _text$mn        ends
.text$mn:00000433
.text$mn:00000434 ; ===========================================================================
.text$mn:00000434
.text$mn:00000434 ; Segment type: Pure code
.text$mn:00000434 ; Segment permissions: Read/Execute
.text$mn:00000434 _text$mn        segment para public 'CODE' use32
.text$mn:00000434                 assume cs:_text$mn
.text$mn:00000434                 ;org 434h
.text$mn:00000434 ; COMDAT (pick any)
.text$mn:00000434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000434
.text$mn:00000434 ; =============== S U B R O U T I N E =======================================
.text$mn:00000434
.text$mn:00000434 ; Attributes: bp-based frame
.text$mn:00000434
.text$mn:00000434 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000434                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000434 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000434                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000434
.text$mn:00000434 arg_0           = dword ptr  8
.text$mn:00000434
.text$mn:00000434                 push    ebp
.text$mn:00000435                 mov     ebp, esp
.text$mn:00000437                 mov     eax, [ebp+arg_0]
.text$mn:0000043A                 pop     ebp
.text$mn:0000043B                 retn
.text$mn:0000043B ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000043B
.text$mn:0000043B _text$mn        ends
.text$mn:0000043B
.text$mn:0000043C ; ===========================================================================
.text$mn:0000043C
.text$mn:0000043C ; Segment type: Pure code
.text$mn:0000043C ; Segment permissions: Read/Execute
.text$mn:0000043C _text$mn        segment para public 'CODE' use32
.text$mn:0000043C                 assume cs:_text$mn
.text$mn:0000043C                 ;org 43Ch
.text$mn:0000043C ; COMDAT (pick any)
.text$mn:0000043C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000043C
.text$mn:0000043C ; =============== S U B R O U T I N E =======================================
.text$mn:0000043C
.text$mn:0000043C ; Attributes: bp-based frame
.text$mn:0000043C
.text$mn:0000043C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:0000043C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000043C ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:0000043C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:0000043C
.text$mn:0000043C var_10          = dword ptr -10h
.text$mn:0000043C var_C           = dword ptr -0Ch
.text$mn:0000043C var_4           = dword ptr -4
.text$mn:0000043C
.text$mn:0000043C                 push    ebp
.text$mn:0000043D                 mov     ebp, esp
.text$mn:0000043F                 push    0FFFFFFFFh
.text$mn:00000441                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000446                 mov     eax, large fs:0
.text$mn:0000044C                 push    eax
.text$mn:0000044D                 push    ecx
.text$mn:0000044E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000453                 xor     eax, ebp
.text$mn:00000455                 push    eax
.text$mn:00000456                 lea     eax, [ebp+var_C]
.text$mn:00000459                 mov     large fs:0, eax
.text$mn:0000045F                 mov     [ebp+var_10], ecx
.text$mn:00000462                 mov     ecx, [ebp+var_10]
.text$mn:00000465                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:0000046A                 mov     [ebp+var_4], 0
.text$mn:00000471                 mov     ecx, [ebp+var_10]
.text$mn:00000474                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000479                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000480                 mov     eax, [ebp+var_10]
.text$mn:00000483                 mov     ecx, [ebp+var_C]
.text$mn:00000486                 mov     large fs:0, ecx
.text$mn:0000048D                 pop     ecx
.text$mn:0000048E                 mov     esp, ebp
.text$mn:00000490                 pop     ebp
.text$mn:00000491                 retn    4
.text$mn:00000491 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000491
.text$mn:00000491 _text$mn        ends
.text$mn:00000491
.text$x:00000494 ; ===========================================================================
.text$x:00000494
.text$x:00000494 ; Segment type: Pure code
.text$x:00000494 ; Segment permissions: Read/Execute
.text$x:00000494 _text$x         segment para public 'CODE' use32
.text$x:00000494                 assume cs:_text$x
.text$x:00000494                 ;org 494h
.text$x:00000494 ; COMDAT (pick associative to section at 43C)
.text$x:00000494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000494
.text$x:00000494 ; =============== S U B R O U T I N E =======================================
.text$x:00000494
.text$x:00000494
.text$x:00000494 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000494                                         ; DATA XREF: .xdata$x:00001B18o
.text$x:00000494                 mov     ecx, [ebp-10h]
.text$x:00000497                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000497 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000497
.text$x:0000049C
.text$x:0000049C ; =============== S U B R O U T I N E =======================================
.text$x:0000049C
.text$x:0000049C
.text$x:0000049C __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:0000049C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:0000049C
.text$x:0000049C arg_4           = dword ptr  8
.text$x:0000049C
.text$x:0000049C                 mov     edx, [esp+arg_4]
.text$x:000004A0                 lea     eax, [edx+0Ch]
.text$x:000004A3                 mov     ecx, [edx-8]
.text$x:000004A6                 xor     ecx, eax
.text$x:000004A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000004AD                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000004B2                 jmp     ___CxxFrameHandler3
.text$x:000004B2 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000004B2
.text$x:000004B2 ; ---------------------------------------------------------------------------
.text$x:000004B7                 align 4
.text$x:000004B7 _text$x         ends
.text$x:000004B7
.text$mn:000004B8 ; ===========================================================================
.text$mn:000004B8
.text$mn:000004B8 ; Segment type: Pure code
.text$mn:000004B8 ; Segment permissions: Read/Execute
.text$mn:000004B8 _text$mn        segment para public 'CODE' use32
.text$mn:000004B8                 assume cs:_text$mn
.text$mn:000004B8                 ;org 4B8h
.text$mn:000004B8 ; COMDAT (pick any)
.text$mn:000004B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000004B8
.text$mn:000004B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000004B8
.text$mn:000004B8 ; Attributes: bp-based frame
.text$mn:000004B8
.text$mn:000004B8 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000004B8                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000004B8 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000004B8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000004B8
.text$mn:000004B8 var_10          = dword ptr -10h
.text$mn:000004B8 var_C           = dword ptr -0Ch
.text$mn:000004B8 var_4           = dword ptr -4
.text$mn:000004B8
.text$mn:000004B8                 push    ebp
.text$mn:000004B9                 mov     ebp, esp
.text$mn:000004BB                 push    0FFFFFFFFh
.text$mn:000004BD                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000004C2                 mov     eax, large fs:0
.text$mn:000004C8                 push    eax
.text$mn:000004C9                 push    ecx
.text$mn:000004CA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000004CF                 xor     eax, ebp
.text$mn:000004D1                 push    eax
.text$mn:000004D2                 lea     eax, [ebp+var_C]
.text$mn:000004D5                 mov     large fs:0, eax
.text$mn:000004DB                 mov     [ebp+var_10], ecx
.text$mn:000004DE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000004E1                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000004E6                 mov     [ebp+var_4], 0
.text$mn:000004ED                 mov     eax, [ebp+var_10]
.text$mn:000004F0                 mov     dword ptr [eax+14h], 0
.text$mn:000004F7                 mov     ecx, [ebp+var_10]
.text$mn:000004FA                 mov     dword ptr [ecx+18h], 0
.text$mn:00000501                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000508                 mov     eax, [ebp+var_10]
.text$mn:0000050B                 mov     ecx, [ebp+var_C]
.text$mn:0000050E                 mov     large fs:0, ecx
.text$mn:00000515                 pop     ecx
.text$mn:00000516                 mov     esp, ebp
.text$mn:00000518                 pop     ebp
.text$mn:00000519                 retn
.text$mn:00000519 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000519
.text$mn:00000519 ; ---------------------------------------------------------------------------
.text$mn:0000051A                 align 4
.text$mn:0000051A _text$mn        ends
.text$mn:0000051A
.text$x:0000051C ; ===========================================================================
.text$x:0000051C
.text$x:0000051C ; Segment type: Pure code
.text$x:0000051C ; Segment permissions: Read/Execute
.text$x:0000051C _text$x         segment para public 'CODE' use32
.text$x:0000051C                 assume cs:_text$x
.text$x:0000051C                 ;org 51Ch
.text$x:0000051C ; COMDAT (pick associative to section at 4B8)
.text$x:0000051C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000051C
.text$x:0000051C ; =============== S U B R O U T I N E =======================================
.text$x:0000051C
.text$x:0000051C
.text$x:0000051C __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000051C                                         ; DATA XREF: .xdata$x:00001AC0o
.text$x:0000051C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000051F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000051F __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000051F
.text$x:00000524
.text$x:00000524 ; =============== S U B R O U T I N E =======================================
.text$x:00000524
.text$x:00000524
.text$x:00000524 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000524                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000524
.text$x:00000524 arg_4           = dword ptr  8
.text$x:00000524
.text$x:00000524                 mov     edx, [esp+arg_4]
.text$x:00000528                 lea     eax, [edx+0Ch]
.text$x:0000052B                 mov     ecx, [edx-8]
.text$x:0000052E                 xor     ecx, eax
.text$x:00000530                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000535                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000053A                 jmp     ___CxxFrameHandler3
.text$x:0000053A __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000053A
.text$x:0000053A ; ---------------------------------------------------------------------------
.text$x:0000053F                 align 10h
.text$x:0000053F _text$x         ends
.text$x:0000053F
.text$mn:00000540 ; ===========================================================================
.text$mn:00000540
.text$mn:00000540 ; Segment type: Pure code
.text$mn:00000540 ; Segment permissions: Read/Execute
.text$mn:00000540 _text$mn        segment para public 'CODE' use32
.text$mn:00000540                 assume cs:_text$mn
.text$mn:00000540                 ;org 540h
.text$mn:00000540 ; COMDAT (pick any)
.text$mn:00000540                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000540
.text$mn:00000540 ; =============== S U B R O U T I N E =======================================
.text$mn:00000540
.text$mn:00000540 ; Attributes: bp-based frame
.text$mn:00000540
.text$mn:00000540 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000540                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000540 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000540                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000540
.text$mn:00000540 var_4           = dword ptr -4
.text$mn:00000540
.text$mn:00000540                 push    ebp
.text$mn:00000541                 mov     ebp, esp
.text$mn:00000543                 push    ecx
.text$mn:00000544                 mov     [ebp+var_4], ecx
.text$mn:00000547                 mov     ecx, [ebp+var_4]
.text$mn:0000054A                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000054F                 mov     eax, [ebp+var_4]
.text$mn:00000552                 mov     esp, ebp
.text$mn:00000554                 pop     ebp
.text$mn:00000555                 retn
.text$mn:00000555 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000555
.text$mn:00000555 ; ---------------------------------------------------------------------------
.text$mn:00000556                 align 4
.text$mn:00000556 _text$mn        ends
.text$mn:00000556
.text$mn:00000558 ; ===========================================================================
.text$mn:00000558
.text$mn:00000558 ; Segment type: Pure code
.text$mn:00000558 ; Segment permissions: Read/Execute
.text$mn:00000558 _text$mn        segment para public 'CODE' use32
.text$mn:00000558                 assume cs:_text$mn
.text$mn:00000558                 ;org 558h
.text$mn:00000558 ; COMDAT (pick any)
.text$mn:00000558                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000558
.text$mn:00000558 ; =============== S U B R O U T I N E =======================================
.text$mn:00000558
.text$mn:00000558 ; Attributes: bp-based frame
.text$mn:00000558
.text$mn:00000558 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000558                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000558 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000558                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000558
.text$mn:00000558 var_4           = dword ptr -4
.text$mn:00000558
.text$mn:00000558                 push    ebp
.text$mn:00000559                 mov     ebp, esp
.text$mn:0000055B                 push    ecx
.text$mn:0000055C                 mov     [ebp+var_4], ecx
.text$mn:0000055F                 mov     eax, [ebp+var_4]
.text$mn:00000562                 mov     esp, ebp
.text$mn:00000564                 pop     ebp
.text$mn:00000565                 retn
.text$mn:00000565 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000565
.text$mn:00000565 ; ---------------------------------------------------------------------------
.text$mn:00000566                 align 4
.text$mn:00000566 _text$mn        ends
.text$mn:00000566
.text$mn:00000568 ; ===========================================================================
.text$mn:00000568
.text$mn:00000568 ; Segment type: Pure code
.text$mn:00000568 ; Segment permissions: Read/Execute
.text$mn:00000568 _text$mn        segment para public 'CODE' use32
.text$mn:00000568                 assume cs:_text$mn
.text$mn:00000568                 ;org 568h
.text$mn:00000568 ; COMDAT (pick any)
.text$mn:00000568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000568
.text$mn:00000568 ; =============== S U B R O U T I N E =======================================
.text$mn:00000568
.text$mn:00000568 ; Attributes: bp-based frame
.text$mn:00000568
.text$mn:00000568 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000568                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000568 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000568                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000568                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00000568
.text$mn:00000568 var_4           = dword ptr -4
.text$mn:00000568
.text$mn:00000568                 push    ebp
.text$mn:00000569                 mov     ebp, esp
.text$mn:0000056B                 push    ecx
.text$mn:0000056C                 mov     [ebp+var_4], ecx
.text$mn:0000056F                 mov     eax, [ebp+var_4]
.text$mn:00000572                 mov     esp, ebp
.text$mn:00000574                 pop     ebp
.text$mn:00000575                 retn
.text$mn:00000575 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000575
.text$mn:00000575 ; ---------------------------------------------------------------------------
.text$mn:00000576                 align 4
.text$mn:00000576 _text$mn        ends
.text$mn:00000576
.text$mn:00000578 ; ===========================================================================
.text$mn:00000578
.text$mn:00000578 ; Segment type: Pure code
.text$mn:00000578 ; Segment permissions: Read/Execute
.text$mn:00000578 _text$mn        segment para public 'CODE' use32
.text$mn:00000578                 assume cs:_text$mn
.text$mn:00000578                 ;org 578h
.text$mn:00000578 ; COMDAT (pick any)
.text$mn:00000578                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000578
.text$mn:00000578 ; =============== S U B R O U T I N E =======================================
.text$mn:00000578
.text$mn:00000578 ; Attributes: bp-based frame
.text$mn:00000578
.text$mn:00000578 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000578                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000578 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000578                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000578                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000578
.text$mn:00000578 var_14          = dword ptr -14h
.text$mn:00000578 var_D           = byte ptr -0Dh
.text$mn:00000578 var_C           = dword ptr -0Ch
.text$mn:00000578 var_4           = dword ptr -4
.text$mn:00000578 Str             = dword ptr  8
.text$mn:00000578
.text$mn:00000578                 push    ebp
.text$mn:00000579                 mov     ebp, esp
.text$mn:0000057B                 push    0FFFFFFFFh
.text$mn:0000057D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000582                 mov     eax, large fs:0
.text$mn:00000588                 push    eax
.text$mn:00000589                 sub     esp, 8
.text$mn:0000058C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000591                 xor     eax, ebp
.text$mn:00000593                 push    eax
.text$mn:00000594                 lea     eax, [ebp+var_C]
.text$mn:00000597                 mov     large fs:0, eax
.text$mn:0000059D                 mov     [ebp+var_14], ecx
.text$mn:000005A0                 lea     ecx, [ebp+var_D]
.text$mn:000005A3                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000005A8                 push    eax
.text$mn:000005A9                 mov     ecx, [ebp+var_14]
.text$mn:000005AC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000005B1                 mov     [ebp+var_4], 0
.text$mn:000005B8                 push    0               ; Size
.text$mn:000005BA                 push    0               ; char
.text$mn:000005BC                 mov     ecx, [ebp+var_14]
.text$mn:000005BF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000005C4                 mov     eax, [ebp+Str]
.text$mn:000005C7                 push    eax             ; Str
.text$mn:000005C8                 mov     ecx, [ebp+var_14]
.text$mn:000005CB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000005D0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000005D7                 mov     eax, [ebp+var_14]
.text$mn:000005DA                 mov     ecx, [ebp+var_C]
.text$mn:000005DD                 mov     large fs:0, ecx
.text$mn:000005E4                 pop     ecx
.text$mn:000005E5                 mov     esp, ebp
.text$mn:000005E7                 pop     ebp
.text$mn:000005E8                 retn    4
.text$mn:000005E8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000005E8
.text$mn:000005E8 ; ---------------------------------------------------------------------------
.text$mn:000005EB                 align 4
.text$mn:000005EB _text$mn        ends
.text$mn:000005EB
.text$x:000005EC ; ===========================================================================
.text$x:000005EC
.text$x:000005EC ; Segment type: Pure code
.text$x:000005EC ; Segment permissions: Read/Execute
.text$x:000005EC _text$x         segment para public 'CODE' use32
.text$x:000005EC                 assume cs:_text$x
.text$x:000005EC                 ;org 5ECh
.text$x:000005EC ; COMDAT (pick associative to section at 578)
.text$x:000005EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000005EC
.text$x:000005EC ; =============== S U B R O U T I N E =======================================
.text$x:000005EC
.text$x:000005EC
.text$x:000005EC __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000005EC                                         ; DATA XREF: .xdata$x:00001B70o
.text$x:000005EC                 mov     ecx, [ebp-14h]
.text$x:000005EF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000005EF __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000005EF
.text$x:000005F4
.text$x:000005F4 ; =============== S U B R O U T I N E =======================================
.text$x:000005F4
.text$x:000005F4
.text$x:000005F4 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000005F4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000005F4
.text$x:000005F4 arg_4           = dword ptr  8
.text$x:000005F4
.text$x:000005F4                 mov     edx, [esp+arg_4]
.text$x:000005F8                 lea     eax, [edx+0Ch]
.text$x:000005FB                 mov     ecx, [edx-0Ch]
.text$x:000005FE                 xor     ecx, eax
.text$x:00000600                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000605                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000060A                 jmp     ___CxxFrameHandler3
.text$x:0000060A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000060A
.text$x:0000060A ; ---------------------------------------------------------------------------
.text$x:0000060F                 align 10h
.text$x:0000060F _text$x         ends
.text$x:0000060F
.text$mn:00000610 ; ===========================================================================
.text$mn:00000610
.text$mn:00000610 ; Segment type: Pure code
.text$mn:00000610 ; Segment permissions: Read/Execute
.text$mn:00000610 _text$mn        segment para public 'CODE' use32
.text$mn:00000610                 assume cs:_text$mn
.text$mn:00000610                 ;org 610h
.text$mn:00000610 ; COMDAT (pick any)
.text$mn:00000610                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000610
.text$mn:00000610 ; =============== S U B R O U T I N E =======================================
.text$mn:00000610
.text$mn:00000610 ; Attributes: bp-based frame
.text$mn:00000610
.text$mn:00000610 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000610                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000610 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000610                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000610
.text$mn:00000610 var_4           = dword ptr -4
.text$mn:00000610
.text$mn:00000610                 push    ebp
.text$mn:00000611                 mov     ebp, esp
.text$mn:00000613                 push    ecx
.text$mn:00000614                 mov     [ebp+var_4], ecx
.text$mn:00000617                 mov     eax, [ebp+var_4]
.text$mn:0000061A                 mov     dword ptr [eax], 0
.text$mn:00000620                 mov     eax, [ebp+var_4]
.text$mn:00000623                 mov     esp, ebp
.text$mn:00000625                 pop     ebp
.text$mn:00000626                 retn
.text$mn:00000626 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000626
.text$mn:00000626 ; ---------------------------------------------------------------------------
.text$mn:00000627                 align 4
.text$mn:00000627 _text$mn        ends
.text$mn:00000627
.text$mn:00000628 ; ===========================================================================
.text$mn:00000628
.text$mn:00000628 ; Segment type: Pure code
.text$mn:00000628 ; Segment permissions: Read/Execute
.text$mn:00000628 _text$mn        segment para public 'CODE' use32
.text$mn:00000628                 assume cs:_text$mn
.text$mn:00000628                 ;org 628h
.text$mn:00000628 ; COMDAT (pick any)
.text$mn:00000628                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000628
.text$mn:00000628 ; =============== S U B R O U T I N E =======================================
.text$mn:00000628
.text$mn:00000628 ; Attributes: bp-based frame
.text$mn:00000628
.text$mn:00000628 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000628                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000628 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000628                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000628
.text$mn:00000628 var_4           = dword ptr -4
.text$mn:00000628
.text$mn:00000628                 push    ebp
.text$mn:00000629                 mov     ebp, esp
.text$mn:0000062B                 push    ecx
.text$mn:0000062C                 mov     [ebp+var_4], ecx
.text$mn:0000062F                 mov     eax, [ebp+var_4]
.text$mn:00000632                 mov     dword ptr [eax], 0
.text$mn:00000638                 mov     ecx, [ebp+var_4]
.text$mn:0000063B                 mov     dword ptr [ecx+4], 0
.text$mn:00000642                 mov     eax, [ebp+var_4]
.text$mn:00000645                 mov     esp, ebp
.text$mn:00000647                 pop     ebp
.text$mn:00000648                 retn
.text$mn:00000648 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000648
.text$mn:00000648 ; ---------------------------------------------------------------------------
.text$mn:00000649                 align 4
.text$mn:00000649 _text$mn        ends
.text$mn:00000649
.text$mn:0000064C ; ===========================================================================
.text$mn:0000064C
.text$mn:0000064C ; Segment type: Pure code
.text$mn:0000064C ; Segment permissions: Read/Execute
.text$mn:0000064C _text$mn        segment para public 'CODE' use32
.text$mn:0000064C                 assume cs:_text$mn
.text$mn:0000064C                 ;org 64Ch
.text$mn:0000064C ; COMDAT (pick any)
.text$mn:0000064C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000064C
.text$mn:0000064C ; =============== S U B R O U T I N E =======================================
.text$mn:0000064C
.text$mn:0000064C ; Attributes: bp-based frame
.text$mn:0000064C
.text$mn:0000064C ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000064C                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000064C ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:0000064C                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:0000064C                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:0000064C
.text$mn:0000064C var_10          = dword ptr -10h
.text$mn:0000064C var_C           = dword ptr -0Ch
.text$mn:0000064C var_4           = dword ptr -4
.text$mn:0000064C
.text$mn:0000064C                 push    ebp
.text$mn:0000064D                 mov     ebp, esp
.text$mn:0000064F                 push    0FFFFFFFFh
.text$mn:00000651                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000656                 mov     eax, large fs:0
.text$mn:0000065C                 push    eax
.text$mn:0000065D                 push    ecx
.text$mn:0000065E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000663                 xor     eax, ebp
.text$mn:00000665                 push    eax
.text$mn:00000666                 lea     eax, [ebp+var_C]
.text$mn:00000669                 mov     large fs:0, eax
.text$mn:0000066F                 mov     [ebp+var_10], ecx
.text$mn:00000672                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000675                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:0000067A                 mov     [ebp+var_4], 0
.text$mn:00000681                 mov     eax, [ebp+var_10]
.text$mn:00000684                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:0000068A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000691                 mov     eax, [ebp+var_10]
.text$mn:00000694                 mov     ecx, [ebp+var_C]
.text$mn:00000697                 mov     large fs:0, ecx
.text$mn:0000069E                 pop     ecx
.text$mn:0000069F                 mov     esp, ebp
.text$mn:000006A1                 pop     ebp
.text$mn:000006A2                 retn
.text$mn:000006A2 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000006A2
.text$mn:000006A2 ; ---------------------------------------------------------------------------
.text$mn:000006A3                 align 4
.text$mn:000006A3 _text$mn        ends
.text$mn:000006A3
.text$x:000006A4 ; ===========================================================================
.text$x:000006A4
.text$x:000006A4 ; Segment type: Pure code
.text$x:000006A4 ; Segment permissions: Read/Execute
.text$x:000006A4 _text$x         segment para public 'CODE' use32
.text$x:000006A4                 assume cs:_text$x
.text$x:000006A4                 ;org 6A4h
.text$x:000006A4 ; COMDAT (pick associative to section at 64C)
.text$x:000006A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000006A4
.text$x:000006A4 ; =============== S U B R O U T I N E =======================================
.text$x:000006A4
.text$x:000006A4
.text$x:000006A4 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000006A4                                         ; DATA XREF: .xdata$x:00001C54o
.text$x:000006A4                 mov     ecx, [ebp-10h]  ; this
.text$x:000006A7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000006A7 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000006A7
.text$x:000006AC
.text$x:000006AC ; =============== S U B R O U T I N E =======================================
.text$x:000006AC
.text$x:000006AC
.text$x:000006AC __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000006AC                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000006AC
.text$x:000006AC arg_4           = dword ptr  8
.text$x:000006AC
.text$x:000006AC                 mov     edx, [esp+arg_4]
.text$x:000006B0                 lea     eax, [edx+0Ch]
.text$x:000006B3                 mov     ecx, [edx-8]
.text$x:000006B6                 xor     ecx, eax
.text$x:000006B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000006BD                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000006C2                 jmp     ___CxxFrameHandler3
.text$x:000006C2 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000006C2
.text$x:000006C2 ; ---------------------------------------------------------------------------
.text$x:000006C7                 align 4
.text$x:000006C7 _text$x         ends
.text$x:000006C7
.text$mn:000006C8 ; ===========================================================================
.text$mn:000006C8
.text$mn:000006C8 ; Segment type: Pure code
.text$mn:000006C8 ; Segment permissions: Read/Execute
.text$mn:000006C8 _text$mn        segment para public 'CODE' use32
.text$mn:000006C8                 assume cs:_text$mn
.text$mn:000006C8                 ;org 6C8h
.text$mn:000006C8 ; COMDAT (pick any)
.text$mn:000006C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000006C8
.text$mn:000006C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000006C8
.text$mn:000006C8 ; Attributes: bp-based frame
.text$mn:000006C8
.text$mn:000006C8 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000006C8                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000006C8 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000006C8                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000006C8
.text$mn:000006C8 var_10          = dword ptr -10h
.text$mn:000006C8 var_C           = dword ptr -0Ch
.text$mn:000006C8 var_4           = dword ptr -4
.text$mn:000006C8
.text$mn:000006C8                 push    ebp
.text$mn:000006C9                 mov     ebp, esp
.text$mn:000006CB                 push    0FFFFFFFFh
.text$mn:000006CD                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000006D2                 mov     eax, large fs:0
.text$mn:000006D8                 push    eax
.text$mn:000006D9                 push    ecx
.text$mn:000006DA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000006DF                 xor     eax, ebp
.text$mn:000006E1                 push    eax
.text$mn:000006E2                 lea     eax, [ebp+var_C]
.text$mn:000006E5                 mov     large fs:0, eax
.text$mn:000006EB                 mov     [ebp+var_10], ecx
.text$mn:000006EE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000006F1                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000006F6                 mov     [ebp+var_4], 0
.text$mn:000006FD                 mov     eax, [ebp+var_10]
.text$mn:00000700                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000706                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000070D                 mov     eax, [ebp+var_10]
.text$mn:00000710                 mov     ecx, [ebp+var_C]
.text$mn:00000713                 mov     large fs:0, ecx
.text$mn:0000071A                 pop     ecx
.text$mn:0000071B                 mov     esp, ebp
.text$mn:0000071D                 pop     ebp
.text$mn:0000071E                 retn
.text$mn:0000071E ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:0000071E
.text$mn:0000071E ; ---------------------------------------------------------------------------
.text$mn:0000071F                 align 10h
.text$mn:0000071F _text$mn        ends
.text$mn:0000071F
.text$x:00000720 ; ===========================================================================
.text$x:00000720
.text$x:00000720 ; Segment type: Pure code
.text$x:00000720 ; Segment permissions: Read/Execute
.text$x:00000720 _text$x         segment para public 'CODE' use32
.text$x:00000720                 assume cs:_text$x
.text$x:00000720                 ;org 720h
.text$x:00000720 ; COMDAT (pick associative to section at 6C8)
.text$x:00000720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000720
.text$x:00000720 ; =============== S U B R O U T I N E =======================================
.text$x:00000720
.text$x:00000720
.text$x:00000720 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000720                                         ; DATA XREF: .xdata$x:00001CD8o
.text$x:00000720                 mov     ecx, [ebp-10h]  ; this
.text$x:00000723                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000723 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00000723
.text$x:00000728
.text$x:00000728 ; =============== S U B R O U T I N E =======================================
.text$x:00000728
.text$x:00000728
.text$x:00000728 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000728                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000728
.text$x:00000728 arg_4           = dword ptr  8
.text$x:00000728
.text$x:00000728                 mov     edx, [esp+arg_4]
.text$x:0000072C                 lea     eax, [edx+0Ch]
.text$x:0000072F                 mov     ecx, [edx-8]
.text$x:00000732                 xor     ecx, eax
.text$x:00000734                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000739                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000073E                 jmp     ___CxxFrameHandler3
.text$x:0000073E __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000073E
.text$x:0000073E ; ---------------------------------------------------------------------------
.text$x:00000743                 align 4
.text$x:00000743 _text$x         ends
.text$x:00000743
.text$mn:00000744 ; ===========================================================================
.text$mn:00000744
.text$mn:00000744 ; Segment type: Pure code
.text$mn:00000744 ; Segment permissions: Read/Execute
.text$mn:00000744 _text$mn        segment para public 'CODE' use32
.text$mn:00000744                 assume cs:_text$mn
.text$mn:00000744                 ;org 744h
.text$mn:00000744 ; COMDAT (pick any)
.text$mn:00000744                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000744
.text$mn:00000744 ; =============== S U B R O U T I N E =======================================
.text$mn:00000744
.text$mn:00000744 ; Attributes: bp-based frame
.text$mn:00000744
.text$mn:00000744 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000744                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000744 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000744                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000744
.text$mn:00000744 var_10          = dword ptr -10h
.text$mn:00000744 var_C           = dword ptr -0Ch
.text$mn:00000744 var_4           = dword ptr -4
.text$mn:00000744
.text$mn:00000744                 push    ebp
.text$mn:00000745                 mov     ebp, esp
.text$mn:00000747                 push    0FFFFFFFFh
.text$mn:00000749                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000074E                 mov     eax, large fs:0
.text$mn:00000754                 push    eax
.text$mn:00000755                 push    ecx
.text$mn:00000756                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000075B                 xor     eax, ebp
.text$mn:0000075D                 push    eax
.text$mn:0000075E                 lea     eax, [ebp+var_C]
.text$mn:00000761                 mov     large fs:0, eax
.text$mn:00000767                 mov     [ebp+var_10], ecx
.text$mn:0000076A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000076D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000772                 mov     [ebp+var_4], 0
.text$mn:00000779                 mov     eax, [ebp+var_10]
.text$mn:0000077C                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00000782                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000789                 mov     eax, [ebp+var_10]
.text$mn:0000078C                 mov     ecx, [ebp+var_C]
.text$mn:0000078F                 mov     large fs:0, ecx
.text$mn:00000796                 pop     ecx
.text$mn:00000797                 mov     esp, ebp
.text$mn:00000799                 pop     ebp
.text$mn:0000079A                 retn
.text$mn:0000079A ??0_System_error_category@std@@QAE@XZ endp
.text$mn:0000079A
.text$mn:0000079A ; ---------------------------------------------------------------------------
.text$mn:0000079B                 align 4
.text$mn:0000079B _text$mn        ends
.text$mn:0000079B
.text$x:0000079C ; ===========================================================================
.text$x:0000079C
.text$x:0000079C ; Segment type: Pure code
.text$x:0000079C ; Segment permissions: Read/Execute
.text$x:0000079C _text$x         segment para public 'CODE' use32
.text$x:0000079C                 assume cs:_text$x
.text$x:0000079C                 ;org 79Ch
.text$x:0000079C ; COMDAT (pick associative to section at 744)
.text$x:0000079C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000079C
.text$x:0000079C ; =============== S U B R O U T I N E =======================================
.text$x:0000079C
.text$x:0000079C
.text$x:0000079C __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:0000079C                                         ; DATA XREF: .xdata$x:00001D5Co
.text$x:0000079C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000079F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000079F __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:0000079F
.text$x:000007A4
.text$x:000007A4 ; =============== S U B R O U T I N E =======================================
.text$x:000007A4
.text$x:000007A4
.text$x:000007A4 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000007A4                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000007A4
.text$x:000007A4 arg_4           = dword ptr  8
.text$x:000007A4
.text$x:000007A4                 mov     edx, [esp+arg_4]
.text$x:000007A8                 lea     eax, [edx+0Ch]
.text$x:000007AB                 mov     ecx, [edx-8]
.text$x:000007AE                 xor     ecx, eax
.text$x:000007B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000007B5                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000007BA                 jmp     ___CxxFrameHandler3
.text$x:000007BA __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000007BA
.text$x:000007BA ; ---------------------------------------------------------------------------
.text$x:000007BF                 align 10h
.text$x:000007BF _text$x         ends
.text$x:000007BF
.text$mn:000007C0 ; ===========================================================================
.text$mn:000007C0
.text$mn:000007C0 ; Segment type: Pure code
.text$mn:000007C0 ; Segment permissions: Read/Execute
.text$mn:000007C0 _text$mn        segment para public 'CODE' use32
.text$mn:000007C0                 assume cs:_text$mn
.text$mn:000007C0                 ;org 7C0h
.text$mn:000007C0 ; COMDAT (pick any)
.text$mn:000007C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000007C0
.text$mn:000007C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000007C0
.text$mn:000007C0 ; Attributes: bp-based frame
.text$mn:000007C0
.text$mn:000007C0 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000007C0                 public ??0error_category@std@@QAE@XZ
.text$mn:000007C0 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000007C0
.text$mn:000007C0 var_4           = dword ptr -4
.text$mn:000007C0
.text$mn:000007C0                 push    ebp
.text$mn:000007C1                 mov     ebp, esp
.text$mn:000007C3                 push    ecx
.text$mn:000007C4                 mov     [ebp+var_4], ecx
.text$mn:000007C7                 mov     eax, [ebp+var_4]
.text$mn:000007CA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000007D0                 mov     eax, [ebp+var_4]
.text$mn:000007D3                 mov     esp, ebp
.text$mn:000007D5                 pop     ebp
.text$mn:000007D6                 retn
.text$mn:000007D6 ??0error_category@std@@QAE@XZ endp
.text$mn:000007D6
.text$mn:000007D6 ; ---------------------------------------------------------------------------
.text$mn:000007D7                 align 4
.text$mn:000007D7 _text$mn        ends
.text$mn:000007D7
.text$mn:000007D8 ; ===========================================================================
.text$mn:000007D8
.text$mn:000007D8 ; Segment type: Pure code
.text$mn:000007D8 ; Segment permissions: Read/Execute
.text$mn:000007D8 _text$mn        segment para public 'CODE' use32
.text$mn:000007D8                 assume cs:_text$mn
.text$mn:000007D8                 ;org 7D8h
.text$mn:000007D8 ; COMDAT (pick any)
.text$mn:000007D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000007D8
.text$mn:000007D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000007D8
.text$mn:000007D8 ; Attributes: bp-based frame
.text$mn:000007D8
.text$mn:000007D8 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000007D8                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000007D8 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000007D8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000007D8                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000007D8
.text$mn:000007D8 var_4           = dword ptr -4
.text$mn:000007D8 arg_0           = dword ptr  8
.text$mn:000007D8 arg_4           = dword ptr  0Ch
.text$mn:000007D8
.text$mn:000007D8                 push    ebp
.text$mn:000007D9                 mov     ebp, esp
.text$mn:000007DB                 push    ecx
.text$mn:000007DC                 mov     [ebp+var_4], ecx
.text$mn:000007DF                 mov     eax, [ebp+var_4]
.text$mn:000007E2                 mov     ecx, [ebp+arg_0]
.text$mn:000007E5                 mov     [eax], ecx
.text$mn:000007E7                 mov     edx, [ebp+var_4]
.text$mn:000007EA                 mov     eax, [ebp+arg_4]
.text$mn:000007ED                 mov     [edx+4], eax
.text$mn:000007F0                 mov     eax, [ebp+var_4]
.text$mn:000007F3                 mov     esp, ebp
.text$mn:000007F5                 pop     ebp
.text$mn:000007F6                 retn    8
.text$mn:000007F6 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000007F6
.text$mn:000007F6 ; ---------------------------------------------------------------------------
.text$mn:000007F9                 align 4
.text$mn:000007F9 _text$mn        ends
.text$mn:000007F9
.text$mn:000007FC ; ===========================================================================
.text$mn:000007FC
.text$mn:000007FC ; Segment type: Pure code
.text$mn:000007FC ; Segment permissions: Read/Execute
.text$mn:000007FC _text$mn        segment para public 'CODE' use32
.text$mn:000007FC                 assume cs:_text$mn
.text$mn:000007FC                 ;org 7FCh
.text$mn:000007FC ; COMDAT (pick any)
.text$mn:000007FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000007FC
.text$mn:000007FC ; =============== S U B R O U T I N E =======================================
.text$mn:000007FC
.text$mn:000007FC ; Attributes: bp-based frame
.text$mn:000007FC
.text$mn:000007FC ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:000007FC                 public ??0id@locale@std@@QAE@I@Z
.text$mn:000007FC ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:000007FC                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:000007FC
.text$mn:000007FC var_4           = dword ptr -4
.text$mn:000007FC arg_0           = dword ptr  8
.text$mn:000007FC
.text$mn:000007FC                 push    ebp
.text$mn:000007FD                 mov     ebp, esp
.text$mn:000007FF                 push    ecx
.text$mn:00000800                 mov     [ebp+var_4], ecx
.text$mn:00000803                 mov     eax, [ebp+var_4]
.text$mn:00000806                 mov     ecx, [ebp+arg_0]
.text$mn:00000809                 mov     [eax], ecx
.text$mn:0000080B                 mov     eax, [ebp+var_4]
.text$mn:0000080E                 mov     esp, ebp
.text$mn:00000810                 pop     ebp
.text$mn:00000811                 retn    4
.text$mn:00000811 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00000811
.text$mn:00000811 _text$mn        ends
.text$mn:00000811
.text$mn:00000814 ; ===========================================================================
.text$mn:00000814
.text$mn:00000814 ; Segment type: Pure code
.text$mn:00000814 ; Segment permissions: Read/Execute
.text$mn:00000814 _text$mn        segment para public 'CODE' use32
.text$mn:00000814                 assume cs:_text$mn
.text$mn:00000814                 ;org 814h
.text$mn:00000814 ; COMDAT (pick any)
.text$mn:00000814                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000814
.text$mn:00000814 ; =============== S U B R O U T I N E =======================================
.text$mn:00000814
.text$mn:00000814 ; Attributes: bp-based frame
.text$mn:00000814
.text$mn:00000814 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00000814                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000814 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00000814                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00000814                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00000814
.text$mn:00000814 var_10          = dword ptr -10h
.text$mn:00000814 var_C           = dword ptr -0Ch
.text$mn:00000814 var_4           = dword ptr -4
.text$mn:00000814
.text$mn:00000814                 push    ebp
.text$mn:00000815                 mov     ebp, esp
.text$mn:00000817                 push    0FFFFFFFFh
.text$mn:00000819                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000081E                 mov     eax, large fs:0
.text$mn:00000824                 push    eax
.text$mn:00000825                 push    ecx
.text$mn:00000826                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000082B                 xor     eax, ebp
.text$mn:0000082D                 push    eax
.text$mn:0000082E                 lea     eax, [ebp+var_C]
.text$mn:00000831                 mov     large fs:0, eax
.text$mn:00000837                 mov     [ebp+var_10], ecx
.text$mn:0000083A                 mov     [ebp+var_4], 0
.text$mn:00000841                 mov     ecx, [ebp+var_10]
.text$mn:00000844                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000849                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000850                 mov     ecx, [ebp+var_10]
.text$mn:00000853                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00000858                 mov     ecx, [ebp+var_C]
.text$mn:0000085B                 mov     large fs:0, ecx
.text$mn:00000862                 pop     ecx
.text$mn:00000863                 mov     esp, ebp
.text$mn:00000865                 pop     ebp
.text$mn:00000866                 retn
.text$mn:00000866 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00000866
.text$mn:00000866 ; ---------------------------------------------------------------------------
.text$mn:00000867                 align 4
.text$mn:00000867 _text$mn        ends
.text$mn:00000867
.text$x:00000868 ; ===========================================================================
.text$x:00000868
.text$x:00000868 ; Segment type: Pure code
.text$x:00000868 ; Segment permissions: Read/Execute
.text$x:00000868 _text$x         segment para public 'CODE' use32
.text$x:00000868                 assume cs:_text$x
.text$x:00000868                 ;org 868h
.text$x:00000868 ; COMDAT (pick associative to section at 814)
.text$x:00000868                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000868
.text$x:00000868 ; =============== S U B R O U T I N E =======================================
.text$x:00000868
.text$x:00000868
.text$x:00000868 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00000868                                         ; DATA XREF: .xdata$x:00001B44o
.text$x:00000868                 mov     ecx, [ebp-10h]
.text$x:0000086B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000086B __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000086B
.text$x:00000870
.text$x:00000870 ; =============== S U B R O U T I N E =======================================
.text$x:00000870
.text$x:00000870
.text$x:00000870 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00000870                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00000870
.text$x:00000870 arg_4           = dword ptr  8
.text$x:00000870
.text$x:00000870                 mov     edx, [esp+arg_4]
.text$x:00000874                 lea     eax, [edx+0Ch]
.text$x:00000877                 mov     ecx, [edx-8]
.text$x:0000087A                 xor     ecx, eax
.text$x:0000087C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000881                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00000886                 jmp     ___CxxFrameHandler3
.text$x:00000886 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00000886
.text$x:00000886 ; ---------------------------------------------------------------------------
.text$x:0000088B                 align 4
.text$x:0000088B _text$x         ends
.text$x:0000088B
.text$mn:0000088C ; ===========================================================================
.text$mn:0000088C
.text$mn:0000088C ; Segment type: Pure code
.text$mn:0000088C ; Segment permissions: Read/Execute
.text$mn:0000088C _text$mn        segment para public 'CODE' use32
.text$mn:0000088C                 assume cs:_text$mn
.text$mn:0000088C                 ;org 88Ch
.text$mn:0000088C ; COMDAT (pick any)
.text$mn:0000088C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000088C
.text$mn:0000088C ; =============== S U B R O U T I N E =======================================
.text$mn:0000088C
.text$mn:0000088C ; Attributes: bp-based frame
.text$mn:0000088C
.text$mn:0000088C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:0000088C                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000088C ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:0000088C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:0000088C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:0000088C
.text$mn:0000088C var_10          = dword ptr -10h
.text$mn:0000088C var_C           = dword ptr -0Ch
.text$mn:0000088C var_4           = dword ptr -4
.text$mn:0000088C
.text$mn:0000088C                 push    ebp
.text$mn:0000088D                 mov     ebp, esp
.text$mn:0000088F                 push    0FFFFFFFFh
.text$mn:00000891                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000896                 mov     eax, large fs:0
.text$mn:0000089C                 push    eax
.text$mn:0000089D                 push    ecx
.text$mn:0000089E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000008A3                 xor     eax, ebp
.text$mn:000008A5                 push    eax
.text$mn:000008A6                 lea     eax, [ebp+var_C]
.text$mn:000008A9                 mov     large fs:0, eax
.text$mn:000008AF                 mov     [ebp+var_10], ecx
.text$mn:000008B2                 mov     [ebp+var_4], 0
.text$mn:000008B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000008C0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000008C3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000008C8                 mov     ecx, [ebp+var_C]
.text$mn:000008CB                 mov     large fs:0, ecx
.text$mn:000008D2                 pop     ecx
.text$mn:000008D3                 mov     esp, ebp
.text$mn:000008D5                 pop     ebp
.text$mn:000008D6                 retn
.text$mn:000008D6 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000008D6
.text$mn:000008D6 ; ---------------------------------------------------------------------------
.text$mn:000008D7                 align 4
.text$mn:000008D7 _text$mn        ends
.text$mn:000008D7
.text$x:000008D8 ; ===========================================================================
.text$x:000008D8
.text$x:000008D8 ; Segment type: Pure code
.text$x:000008D8 ; Segment permissions: Read/Execute
.text$x:000008D8 _text$x         segment para public 'CODE' use32
.text$x:000008D8                 assume cs:_text$x
.text$x:000008D8                 ;org 8D8h
.text$x:000008D8 ; COMDAT (pick associative to section at 88C)
.text$x:000008D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000008D8
.text$x:000008D8 ; =============== S U B R O U T I N E =======================================
.text$x:000008D8
.text$x:000008D8
.text$x:000008D8 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000008D8                                         ; DATA XREF: .xdata$x:00001AECo
.text$x:000008D8                 mov     ecx, [ebp-10h]  ; this
.text$x:000008DB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000008DB __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000008DB
.text$x:000008E0
.text$x:000008E0 ; =============== S U B R O U T I N E =======================================
.text$x:000008E0
.text$x:000008E0
.text$x:000008E0 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000008E0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000008E0
.text$x:000008E0 arg_4           = dword ptr  8
.text$x:000008E0
.text$x:000008E0                 mov     edx, [esp+arg_4]
.text$x:000008E4                 lea     eax, [edx+0Ch]
.text$x:000008E7                 mov     ecx, [edx-8]
.text$x:000008EA                 xor     ecx, eax
.text$x:000008EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008F1                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000008F6                 jmp     ___CxxFrameHandler3
.text$x:000008F6 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000008F6
.text$x:000008F6 ; ---------------------------------------------------------------------------
.text$x:000008FB                 align 4
.text$x:000008FB _text$x         ends
.text$x:000008FB
.text$mn:000008FC ; ===========================================================================
.text$mn:000008FC
.text$mn:000008FC ; Segment type: Pure code
.text$mn:000008FC ; Segment permissions: Read/Execute
.text$mn:000008FC _text$mn        segment para public 'CODE' use32
.text$mn:000008FC                 assume cs:_text$mn
.text$mn:000008FC                 ;org 8FCh
.text$mn:000008FC ; COMDAT (pick any)
.text$mn:000008FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008FC
.text$mn:000008FC ; =============== S U B R O U T I N E =======================================
.text$mn:000008FC
.text$mn:000008FC ; Attributes: bp-based frame
.text$mn:000008FC
.text$mn:000008FC ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000008FC                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000008FC ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000008FC                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:000008FC                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:000008FC
.text$mn:000008FC var_10          = dword ptr -10h
.text$mn:000008FC var_C           = dword ptr -0Ch
.text$mn:000008FC var_4           = dword ptr -4
.text$mn:000008FC
.text$mn:000008FC                 push    ebp
.text$mn:000008FD                 mov     ebp, esp
.text$mn:000008FF                 push    0FFFFFFFFh
.text$mn:00000901                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000906                 mov     eax, large fs:0
.text$mn:0000090C                 push    eax
.text$mn:0000090D                 push    ecx
.text$mn:0000090E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000913                 xor     eax, ebp
.text$mn:00000915                 push    eax
.text$mn:00000916                 lea     eax, [ebp+var_C]
.text$mn:00000919                 mov     large fs:0, eax
.text$mn:0000091F                 mov     [ebp+var_10], ecx
.text$mn:00000922                 mov     [ebp+var_4], 0
.text$mn:00000929                 push    0               ; Size
.text$mn:0000092B                 push    1               ; char
.text$mn:0000092D                 mov     ecx, [ebp+var_10]
.text$mn:00000930                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000935                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000093C                 mov     ecx, [ebp+var_10]
.text$mn:0000093F                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000944                 mov     ecx, [ebp+var_C]
.text$mn:00000947                 mov     large fs:0, ecx
.text$mn:0000094E                 pop     ecx
.text$mn:0000094F                 mov     esp, ebp
.text$mn:00000951                 pop     ebp
.text$mn:00000952                 retn
.text$mn:00000952 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000952
.text$mn:00000952 ; ---------------------------------------------------------------------------
.text$mn:00000953                 align 4
.text$mn:00000953 _text$mn        ends
.text$mn:00000953
.text$x:00000954 ; ===========================================================================
.text$x:00000954
.text$x:00000954 ; Segment type: Pure code
.text$x:00000954 ; Segment permissions: Read/Execute
.text$x:00000954 _text$x         segment para public 'CODE' use32
.text$x:00000954                 assume cs:_text$x
.text$x:00000954                 ;org 954h
.text$x:00000954 ; COMDAT (pick associative to section at 8FC)
.text$x:00000954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000954
.text$x:00000954 ; =============== S U B R O U T I N E =======================================
.text$x:00000954
.text$x:00000954
.text$x:00000954 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000954                                         ; DATA XREF: .xdata$x:00001B9Co
.text$x:00000954                 mov     ecx, [ebp-10h]
.text$x:00000957                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000957 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000957
.text$x:0000095C
.text$x:0000095C ; =============== S U B R O U T I N E =======================================
.text$x:0000095C
.text$x:0000095C
.text$x:0000095C __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:0000095C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:0000095C
.text$x:0000095C arg_4           = dword ptr  8
.text$x:0000095C
.text$x:0000095C                 mov     edx, [esp+arg_4]
.text$x:00000960                 lea     eax, [edx+0Ch]
.text$x:00000963                 mov     ecx, [edx-8]
.text$x:00000966                 xor     ecx, eax
.text$x:00000968                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000096D                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000972                 jmp     ___CxxFrameHandler3
.text$x:00000972 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000972
.text$x:00000972 ; ---------------------------------------------------------------------------
.text$x:00000977                 align 4
.text$x:00000977 _text$x         ends
.text$x:00000977
.text$mn:00000978 ; ===========================================================================
.text$mn:00000978
.text$mn:00000978 ; Segment type: Pure code
.text$mn:00000978 ; Segment permissions: Read/Execute
.text$mn:00000978 _text$mn        segment para public 'CODE' use32
.text$mn:00000978                 assume cs:_text$mn
.text$mn:00000978                 ;org 978h
.text$mn:00000978 ; COMDAT (pick any)
.text$mn:00000978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000978
.text$mn:00000978 ; =============== S U B R O U T I N E =======================================
.text$mn:00000978
.text$mn:00000978 ; Attributes: bp-based frame
.text$mn:00000978
.text$mn:00000978 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000978                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000978 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000978                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000978                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000978
.text$mn:00000978 var_4           = dword ptr -4
.text$mn:00000978
.text$mn:00000978                 push    ebp
.text$mn:00000979                 mov     ebp, esp
.text$mn:0000097B                 push    ecx
.text$mn:0000097C                 mov     [ebp+var_4], ecx
.text$mn:0000097F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000982                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000987                 mov     esp, ebp
.text$mn:00000989                 pop     ebp
.text$mn:0000098A                 retn
.text$mn:0000098A ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000098A
.text$mn:0000098A ; ---------------------------------------------------------------------------
.text$mn:0000098B                 align 4
.text$mn:0000098B _text$mn        ends
.text$mn:0000098B
.text$mn:0000098C ; ===========================================================================
.text$mn:0000098C
.text$mn:0000098C ; Segment type: Pure code
.text$mn:0000098C ; Segment permissions: Read/Execute
.text$mn:0000098C _text$mn        segment para public 'CODE' use32
.text$mn:0000098C                 assume cs:_text$mn
.text$mn:0000098C                 ;org 98Ch
.text$mn:0000098C ; COMDAT (pick any)
.text$mn:0000098C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000098C
.text$mn:0000098C ; =============== S U B R O U T I N E =======================================
.text$mn:0000098C
.text$mn:0000098C ; Attributes: bp-based frame
.text$mn:0000098C
.text$mn:0000098C ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000098C                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000098C ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:0000098C                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:0000098C                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:0000098C
.text$mn:0000098C var_10          = dword ptr -10h
.text$mn:0000098C var_C           = dword ptr -0Ch
.text$mn:0000098C var_4           = dword ptr -4
.text$mn:0000098C
.text$mn:0000098C                 push    ebp
.text$mn:0000098D                 mov     ebp, esp
.text$mn:0000098F                 push    0FFFFFFFFh
.text$mn:00000991                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000996                 mov     eax, large fs:0
.text$mn:0000099C                 push    eax
.text$mn:0000099D                 push    ecx
.text$mn:0000099E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009A3                 xor     eax, ebp
.text$mn:000009A5                 push    eax
.text$mn:000009A6                 lea     eax, [ebp+var_C]
.text$mn:000009A9                 mov     large fs:0, eax
.text$mn:000009AF                 mov     [ebp+var_10], ecx
.text$mn:000009B2                 mov     [ebp+var_4], 0
.text$mn:000009B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000009C0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000009C3                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000009C8                 mov     ecx, [ebp+var_C]
.text$mn:000009CB                 mov     large fs:0, ecx
.text$mn:000009D2                 pop     ecx
.text$mn:000009D3                 mov     esp, ebp
.text$mn:000009D5                 pop     ebp
.text$mn:000009D6                 retn
.text$mn:000009D6 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:000009D6
.text$mn:000009D6 ; ---------------------------------------------------------------------------
.text$mn:000009D7                 align 4
.text$mn:000009D7 _text$mn        ends
.text$mn:000009D7
.text$x:000009D8 ; ===========================================================================
.text$x:000009D8
.text$x:000009D8 ; Segment type: Pure code
.text$x:000009D8 ; Segment permissions: Read/Execute
.text$x:000009D8 _text$x         segment para public 'CODE' use32
.text$x:000009D8                 assume cs:_text$x
.text$x:000009D8                 ;org 9D8h
.text$x:000009D8 ; COMDAT (pick associative to section at 98C)
.text$x:000009D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000009D8
.text$x:000009D8 ; =============== S U B R O U T I N E =======================================
.text$x:000009D8
.text$x:000009D8
.text$x:000009D8 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:000009D8                                         ; DATA XREF: .xdata$x:00001CACo
.text$x:000009D8                 mov     ecx, [ebp-10h]  ; this
.text$x:000009DB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000009DB __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:000009DB
.text$x:000009E0
.text$x:000009E0 ; =============== S U B R O U T I N E =======================================
.text$x:000009E0
.text$x:000009E0
.text$x:000009E0 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000009E0                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000009E0
.text$x:000009E0 arg_4           = dword ptr  8
.text$x:000009E0
.text$x:000009E0                 mov     edx, [esp+arg_4]
.text$x:000009E4                 lea     eax, [edx+0Ch]
.text$x:000009E7                 mov     ecx, [edx-8]
.text$x:000009EA                 xor     ecx, eax
.text$x:000009EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000009F1                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000009F6                 jmp     ___CxxFrameHandler3
.text$x:000009F6 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000009F6
.text$x:000009F6 ; ---------------------------------------------------------------------------
.text$x:000009FB                 align 4
.text$x:000009FB _text$x         ends
.text$x:000009FB
.text$mn:000009FC ; ===========================================================================
.text$mn:000009FC
.text$mn:000009FC ; Segment type: Pure code
.text$mn:000009FC ; Segment permissions: Read/Execute
.text$mn:000009FC _text$mn        segment para public 'CODE' use32
.text$mn:000009FC                 assume cs:_text$mn
.text$mn:000009FC                 ;org 9FCh
.text$mn:000009FC ; COMDAT (pick any)
.text$mn:000009FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009FC
.text$mn:000009FC ; =============== S U B R O U T I N E =======================================
.text$mn:000009FC
.text$mn:000009FC ; Attributes: bp-based frame
.text$mn:000009FC
.text$mn:000009FC ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000009FC                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000009FC ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000009FC                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000009FC                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000009FC
.text$mn:000009FC var_10          = dword ptr -10h
.text$mn:000009FC var_C           = dword ptr -0Ch
.text$mn:000009FC var_4           = dword ptr -4
.text$mn:000009FC
.text$mn:000009FC                 push    ebp
.text$mn:000009FD                 mov     ebp, esp
.text$mn:000009FF                 push    0FFFFFFFFh
.text$mn:00000A01                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000A06                 mov     eax, large fs:0
.text$mn:00000A0C                 push    eax
.text$mn:00000A0D                 push    ecx
.text$mn:00000A0E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A13                 xor     eax, ebp
.text$mn:00000A15                 push    eax
.text$mn:00000A16                 lea     eax, [ebp+var_C]
.text$mn:00000A19                 mov     large fs:0, eax
.text$mn:00000A1F                 mov     [ebp+var_10], ecx
.text$mn:00000A22                 mov     [ebp+var_4], 0
.text$mn:00000A29                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A30                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000A33                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000A38                 mov     ecx, [ebp+var_C]
.text$mn:00000A3B                 mov     large fs:0, ecx
.text$mn:00000A42                 pop     ecx
.text$mn:00000A43                 mov     esp, ebp
.text$mn:00000A45                 pop     ebp
.text$mn:00000A46                 retn
.text$mn:00000A46 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00000A46
.text$mn:00000A46 ; ---------------------------------------------------------------------------
.text$mn:00000A47                 align 4
.text$mn:00000A47 _text$mn        ends
.text$mn:00000A47
.text$x:00000A48 ; ===========================================================================
.text$x:00000A48
.text$x:00000A48 ; Segment type: Pure code
.text$x:00000A48 ; Segment permissions: Read/Execute
.text$x:00000A48 _text$x         segment para public 'CODE' use32
.text$x:00000A48                 assume cs:_text$x
.text$x:00000A48                 ;org 0A48h
.text$x:00000A48 ; COMDAT (pick associative to section at 9FC)
.text$x:00000A48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A48
.text$x:00000A48 ; =============== S U B R O U T I N E =======================================
.text$x:00000A48
.text$x:00000A48
.text$x:00000A48 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00000A48                                         ; DATA XREF: .xdata$x:00001D30o
.text$x:00000A48                 mov     ecx, [ebp-10h]  ; this
.text$x:00000A4B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000A4B __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00000A4B
.text$x:00000A50
.text$x:00000A50 ; =============== S U B R O U T I N E =======================================
.text$x:00000A50
.text$x:00000A50
.text$x:00000A50 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00000A50                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00000A50
.text$x:00000A50 arg_4           = dword ptr  8
.text$x:00000A50
.text$x:00000A50                 mov     edx, [esp+arg_4]
.text$x:00000A54                 lea     eax, [edx+0Ch]
.text$x:00000A57                 mov     ecx, [edx-8]
.text$x:00000A5A                 xor     ecx, eax
.text$x:00000A5C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A61                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00000A66                 jmp     ___CxxFrameHandler3
.text$x:00000A66 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00000A66
.text$x:00000A66 ; ---------------------------------------------------------------------------
.text$x:00000A6B                 align 4
.text$x:00000A6B _text$x         ends
.text$x:00000A6B
.text$mn:00000A6C ; ===========================================================================
.text$mn:00000A6C
.text$mn:00000A6C ; Segment type: Pure code
.text$mn:00000A6C ; Segment permissions: Read/Execute
.text$mn:00000A6C _text$mn        segment para public 'CODE' use32
.text$mn:00000A6C                 assume cs:_text$mn
.text$mn:00000A6C                 ;org 0A6Ch
.text$mn:00000A6C ; COMDAT (pick any)
.text$mn:00000A6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A6C
.text$mn:00000A6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A6C
.text$mn:00000A6C ; Attributes: bp-based frame
.text$mn:00000A6C
.text$mn:00000A6C ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000A6C                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00000A6C ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00000A6C                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000A6C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000A6C
.text$mn:00000A6C var_10          = dword ptr -10h
.text$mn:00000A6C var_C           = dword ptr -0Ch
.text$mn:00000A6C var_4           = dword ptr -4
.text$mn:00000A6C
.text$mn:00000A6C                 push    ebp
.text$mn:00000A6D                 mov     ebp, esp
.text$mn:00000A6F                 push    0FFFFFFFFh
.text$mn:00000A71                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00000A76                 mov     eax, large fs:0
.text$mn:00000A7C                 push    eax
.text$mn:00000A7D                 push    ecx
.text$mn:00000A7E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A83                 xor     eax, ebp
.text$mn:00000A85                 push    eax
.text$mn:00000A86                 lea     eax, [ebp+var_C]
.text$mn:00000A89                 mov     large fs:0, eax
.text$mn:00000A8F                 mov     [ebp+var_10], ecx
.text$mn:00000A92                 mov     [ebp+var_4], 0
.text$mn:00000A99                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000AA0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000AA3                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000AA8                 mov     ecx, [ebp+var_C]
.text$mn:00000AAB                 mov     large fs:0, ecx
.text$mn:00000AB2                 pop     ecx
.text$mn:00000AB3                 mov     esp, ebp
.text$mn:00000AB5                 pop     ebp
.text$mn:00000AB6                 retn
.text$mn:00000AB6 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00000AB6
.text$mn:00000AB6 ; ---------------------------------------------------------------------------
.text$mn:00000AB7                 align 4
.text$mn:00000AB7 _text$mn        ends
.text$mn:00000AB7
.text$x:00000AB8 ; ===========================================================================
.text$x:00000AB8
.text$x:00000AB8 ; Segment type: Pure code
.text$x:00000AB8 ; Segment permissions: Read/Execute
.text$x:00000AB8 _text$x         segment para public 'CODE' use32
.text$x:00000AB8                 assume cs:_text$x
.text$x:00000AB8                 ;org 0AB8h
.text$x:00000AB8 ; COMDAT (pick associative to section at A6C)
.text$x:00000AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000AB8
.text$x:00000AB8 ; =============== S U B R O U T I N E =======================================
.text$x:00000AB8
.text$x:00000AB8
.text$x:00000AB8 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00000AB8                                         ; DATA XREF: .xdata$x:00001DB4o
.text$x:00000AB8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000ABB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000ABB __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00000ABB
.text$x:00000AC0
.text$x:00000AC0 ; =============== S U B R O U T I N E =======================================
.text$x:00000AC0
.text$x:00000AC0
.text$x:00000AC0 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00000AC0                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00000AC0
.text$x:00000AC0 arg_4           = dword ptr  8
.text$x:00000AC0
.text$x:00000AC0                 mov     edx, [esp+arg_4]
.text$x:00000AC4                 lea     eax, [edx+0Ch]
.text$x:00000AC7                 mov     ecx, [edx-8]
.text$x:00000ACA                 xor     ecx, eax
.text$x:00000ACC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000AD1                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00000AD6                 jmp     ___CxxFrameHandler3
.text$x:00000AD6 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00000AD6
.text$x:00000AD6 ; ---------------------------------------------------------------------------
.text$x:00000ADB                 align 4
.text$x:00000ADB _text$x         ends
.text$x:00000ADB
.text$mn:00000ADC ; ===========================================================================
.text$mn:00000ADC
.text$mn:00000ADC ; Segment type: Pure code
.text$mn:00000ADC ; Segment permissions: Read/Execute
.text$mn:00000ADC _text$mn        segment para public 'CODE' use32
.text$mn:00000ADC                 assume cs:_text$mn
.text$mn:00000ADC                 ;org 0ADCh
.text$mn:00000ADC ; COMDAT (pick any)
.text$mn:00000ADC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000ADC
.text$mn:00000ADC ; =============== S U B R O U T I N E =======================================
.text$mn:00000ADC
.text$mn:00000ADC ; Attributes: bp-based frame
.text$mn:00000ADC
.text$mn:00000ADC ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00000ADC                 public ??1error_category@std@@UAE@XZ
.text$mn:00000ADC ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00000ADC                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00000ADC
.text$mn:00000ADC var_4           = dword ptr -4
.text$mn:00000ADC
.text$mn:00000ADC                 push    ebp
.text$mn:00000ADD                 mov     ebp, esp
.text$mn:00000ADF                 push    ecx
.text$mn:00000AE0                 mov     [ebp+var_4], ecx
.text$mn:00000AE3                 mov     eax, [ebp+var_4]
.text$mn:00000AE6                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000AEC                 mov     esp, ebp
.text$mn:00000AEE                 pop     ebp
.text$mn:00000AEF                 retn
.text$mn:00000AEF ??1error_category@std@@UAE@XZ endp
.text$mn:00000AEF
.text$mn:00000AEF _text$mn        ends
.text$mn:00000AEF
.text$mn:00000AF0 ; ===========================================================================
.text$mn:00000AF0
.text$mn:00000AF0 ; Segment type: Pure code
.text$mn:00000AF0 ; Segment permissions: Read/Execute
.text$mn:00000AF0 _text$mn        segment para public 'CODE' use32
.text$mn:00000AF0                 assume cs:_text$mn
.text$mn:00000AF0                 ;org 0AF0h
.text$mn:00000AF0 ; COMDAT (pick any)
.text$mn:00000AF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000AF0
.text$mn:00000AF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AF0
.text$mn:00000AF0 ; Attributes: bp-based frame
.text$mn:00000AF0
.text$mn:00000AF0 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00000AF0                 public ??2@YAPAXIPAX@Z
.text$mn:00000AF0 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00000AF0                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00000AF0
.text$mn:00000AF0 arg_4           = dword ptr  0Ch
.text$mn:00000AF0
.text$mn:00000AF0                 push    ebp
.text$mn:00000AF1                 mov     ebp, esp
.text$mn:00000AF3                 mov     eax, [ebp+arg_4]
.text$mn:00000AF6                 pop     ebp
.text$mn:00000AF7                 retn
.text$mn:00000AF7 ??2@YAPAXIPAX@Z endp
.text$mn:00000AF7
.text$mn:00000AF7 _text$mn        ends
.text$mn:00000AF7
.text$mn:00000AF8 ; ===========================================================================
.text$mn:00000AF8
.text$mn:00000AF8 ; Segment type: Pure code
.text$mn:00000AF8 ; Segment permissions: Read/Execute
.text$mn:00000AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00000AF8                 assume cs:_text$mn
.text$mn:00000AF8                 ;org 0AF8h
.text$mn:00000AF8 ; COMDAT (pick any)
.text$mn:00000AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000AF8
.text$mn:00000AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AF8
.text$mn:00000AF8 ; Attributes: bp-based frame
.text$mn:00000AF8
.text$mn:00000AF8 ; void __cdecl operator delete(void *)
.text$mn:00000AF8                 public ??3@YAXPAX0@Z
.text$mn:00000AF8 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00000AF8                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00000AF8                 push    ebp
.text$mn:00000AF9                 mov     ebp, esp
.text$mn:00000AFB                 pop     ebp
.text$mn:00000AFC                 retn
.text$mn:00000AFC ??3@YAXPAX0@Z   endp
.text$mn:00000AFC
.text$mn:00000AFC ; ---------------------------------------------------------------------------
.text$mn:00000AFD                 align 10h
.text$mn:00000AFD _text$mn        ends
.text$mn:00000AFD
.text$mn:00000B00 ; ===========================================================================
.text$mn:00000B00
.text$mn:00000B00 ; Segment type: Pure code
.text$mn:00000B00 ; Segment permissions: Read/Execute
.text$mn:00000B00 _text$mn        segment para public 'CODE' use32
.text$mn:00000B00                 assume cs:_text$mn
.text$mn:00000B00                 ;org 0B00h
.text$mn:00000B00 ; COMDAT (pick any)
.text$mn:00000B00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B00
.text$mn:00000B00 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B00
.text$mn:00000B00 ; Attributes: bp-based frame
.text$mn:00000B00
.text$mn:00000B00 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00000B00                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00000B00 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00000B00                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00000B00                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00000B00
.text$mn:00000B00 var_8           = dword ptr -8
.text$mn:00000B00 var_4           = dword ptr -4
.text$mn:00000B00 arg_0           = dword ptr  8
.text$mn:00000B00
.text$mn:00000B00                 push    ebp
.text$mn:00000B01                 mov     ebp, esp
.text$mn:00000B03                 sub     esp, 8
.text$mn:00000B06                 mov     [ebp+var_8], ecx
.text$mn:00000B09                 mov     eax, [ebp+var_8]
.text$mn:00000B0C                 cmp     eax, [ebp+arg_0]
.text$mn:00000B0F                 jnz     short loc_B1A
.text$mn:00000B11                 mov     [ebp+var_4], 1
.text$mn:00000B18                 jmp     short loc_B21
.text$mn:00000B1A ; ---------------------------------------------------------------------------
.text$mn:00000B1A
.text$mn:00000B1A loc_B1A:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00000B1A                 mov     [ebp+var_4], 0
.text$mn:00000B21
.text$mn:00000B21 loc_B21:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00000B21                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000B24                 mov     esp, ebp
.text$mn:00000B26                 pop     ebp
.text$mn:00000B27                 retn    4
.text$mn:00000B27 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00000B27
.text$mn:00000B27 ; ---------------------------------------------------------------------------
.text$mn:00000B2A                 align 4
.text$mn:00000B2A _text$mn        ends
.text$mn:00000B2A
.text$mn:00000B2C ; ===========================================================================
.text$mn:00000B2C
.text$mn:00000B2C ; Segment type: Pure code
.text$mn:00000B2C ; Segment permissions: Read/Execute
.text$mn:00000B2C _text$mn        segment para public 'CODE' use32
.text$mn:00000B2C                 assume cs:_text$mn
.text$mn:00000B2C                 ;org 0B2Ch
.text$mn:00000B2C ; COMDAT (pick any)
.text$mn:00000B2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B2C
.text$mn:00000B2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B2C
.text$mn:00000B2C ; Attributes: bp-based frame
.text$mn:00000B2C
.text$mn:00000B2C ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00000B2C                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00000B2C ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00000B2C                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00000B2C
.text$mn:00000B2C var_8           = dword ptr -8
.text$mn:00000B2C var_4           = dword ptr -4
.text$mn:00000B2C arg_0           = dword ptr  8
.text$mn:00000B2C
.text$mn:00000B2C                 push    ebp
.text$mn:00000B2D                 mov     ebp, esp
.text$mn:00000B2F                 sub     esp, 8
.text$mn:00000B32                 push    esi
.text$mn:00000B33                 mov     [ebp+var_4], ecx
.text$mn:00000B36                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000B39                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000B3E                 push    eax
.text$mn:00000B3F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000B42                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000B47                 mov     ecx, eax
.text$mn:00000B49                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00000B4E                 movzx   eax, al
.text$mn:00000B51                 test    eax, eax
.text$mn:00000B53                 jz      short loc_B74
.text$mn:00000B55                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000B58                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000B5D                 mov     esi, eax
.text$mn:00000B5F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000B62                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000B67                 cmp     esi, eax
.text$mn:00000B69                 jnz     short loc_B74
.text$mn:00000B6B                 mov     [ebp+var_8], 1
.text$mn:00000B72                 jmp     short loc_B7B
.text$mn:00000B74 ; ---------------------------------------------------------------------------
.text$mn:00000B74
.text$mn:00000B74 loc_B74:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00000B74                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00000B74                 mov     [ebp+var_8], 0
.text$mn:00000B7B
.text$mn:00000B7B loc_B7B:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00000B7B                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000B7E                 pop     esi
.text$mn:00000B7F                 mov     esp, ebp
.text$mn:00000B81                 pop     ebp
.text$mn:00000B82                 retn    4
.text$mn:00000B82 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00000B82
.text$mn:00000B82 ; ---------------------------------------------------------------------------
.text$mn:00000B85                 align 4
.text$mn:00000B85 _text$mn        ends
.text$mn:00000B85
.text$mn:00000B88 ; ===========================================================================
.text$mn:00000B88
.text$mn:00000B88 ; Segment type: Pure code
.text$mn:00000B88 ; Segment permissions: Read/Execute
.text$mn:00000B88 _text$mn        segment para public 'CODE' use32
.text$mn:00000B88                 assume cs:_text$mn
.text$mn:00000B88                 ;org 0B88h
.text$mn:00000B88 ; COMDAT (pick any)
.text$mn:00000B88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B88
.text$mn:00000B88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B88
.text$mn:00000B88 ; Attributes: bp-based frame
.text$mn:00000B88
.text$mn:00000B88 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000B88                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00000B88 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000B88
.text$mn:00000B88 var_4           = dword ptr -4
.text$mn:00000B88 arg_0           = dword ptr  8
.text$mn:00000B88
.text$mn:00000B88                 push    ebp
.text$mn:00000B89                 mov     ebp, esp
.text$mn:00000B8B                 push    ecx
.text$mn:00000B8C                 mov     [ebp+var_4], ecx
.text$mn:00000B8F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000B92                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000B97                 mov     eax, [ebp+arg_0]
.text$mn:00000B9A                 and     eax, 1
.text$mn:00000B9D                 jz      short loc_BAB
.text$mn:00000B9F                 mov     ecx, [ebp+var_4]
.text$mn:00000BA2                 push    ecx             ; void *
.text$mn:00000BA3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000BA8                 add     esp, 4
.text$mn:00000BAB
.text$mn:00000BAB loc_BAB:                                ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000BAB                 mov     eax, [ebp+var_4]
.text$mn:00000BAE                 mov     esp, ebp
.text$mn:00000BB0                 pop     ebp
.text$mn:00000BB1                 retn    4
.text$mn:00000BB1 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00000BB1
.text$mn:00000BB1 _text$mn        ends
.text$mn:00000BB1
.text$mn:00000BB4 ; ===========================================================================
.text$mn:00000BB4
.text$mn:00000BB4 ; Segment type: Pure code
.text$mn:00000BB4 ; Segment permissions: Read/Execute
.text$mn:00000BB4 _text$mn        segment para public 'CODE' use32
.text$mn:00000BB4                 assume cs:_text$mn
.text$mn:00000BB4                 ;org 0BB4h
.text$mn:00000BB4 ; COMDAT (pick any)
.text$mn:00000BB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BB4
.text$mn:00000BB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BB4
.text$mn:00000BB4 ; Attributes: bp-based frame
.text$mn:00000BB4
.text$mn:00000BB4 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000BB4                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00000BB4 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000BB4
.text$mn:00000BB4 var_4           = dword ptr -4
.text$mn:00000BB4 arg_0           = dword ptr  8
.text$mn:00000BB4
.text$mn:00000BB4                 push    ebp
.text$mn:00000BB5                 mov     ebp, esp
.text$mn:00000BB7                 push    ecx
.text$mn:00000BB8                 mov     [ebp+var_4], ecx
.text$mn:00000BBB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000BBE                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00000BC3                 mov     eax, [ebp+arg_0]
.text$mn:00000BC6                 and     eax, 1
.text$mn:00000BC9                 jz      short loc_BD7
.text$mn:00000BCB                 mov     ecx, [ebp+var_4]
.text$mn:00000BCE                 push    ecx             ; void *
.text$mn:00000BCF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000BD4                 add     esp, 4
.text$mn:00000BD7
.text$mn:00000BD7 loc_BD7:                                ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000BD7                 mov     eax, [ebp+var_4]
.text$mn:00000BDA                 mov     esp, ebp
.text$mn:00000BDC                 pop     ebp
.text$mn:00000BDD                 retn    4
.text$mn:00000BDD ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00000BDD
.text$mn:00000BDD _text$mn        ends
.text$mn:00000BDD
.text$mn:00000BE0 ; ===========================================================================
.text$mn:00000BE0
.text$mn:00000BE0 ; Segment type: Pure code
.text$mn:00000BE0 ; Segment permissions: Read/Execute
.text$mn:00000BE0 _text$mn        segment para public 'CODE' use32
.text$mn:00000BE0                 assume cs:_text$mn
.text$mn:00000BE0                 ;org 0BE0h
.text$mn:00000BE0 ; COMDAT (pick any)
.text$mn:00000BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000BE0
.text$mn:00000BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BE0
.text$mn:00000BE0 ; Attributes: bp-based frame
.text$mn:00000BE0
.text$mn:00000BE0 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000BE0                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00000BE0 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000BE0
.text$mn:00000BE0 var_4           = dword ptr -4
.text$mn:00000BE0 arg_0           = dword ptr  8
.text$mn:00000BE0
.text$mn:00000BE0                 push    ebp
.text$mn:00000BE1                 mov     ebp, esp
.text$mn:00000BE3                 push    ecx
.text$mn:00000BE4                 mov     [ebp+var_4], ecx
.text$mn:00000BE7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000BEA                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00000BEF                 mov     eax, [ebp+arg_0]
.text$mn:00000BF2                 and     eax, 1
.text$mn:00000BF5                 jz      short loc_C03
.text$mn:00000BF7                 mov     ecx, [ebp+var_4]
.text$mn:00000BFA                 push    ecx             ; void *
.text$mn:00000BFB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000C00                 add     esp, 4
.text$mn:00000C03
.text$mn:00000C03 loc_C03:                                ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000C03                 mov     eax, [ebp+var_4]
.text$mn:00000C06                 mov     esp, ebp
.text$mn:00000C08                 pop     ebp
.text$mn:00000C09                 retn    4
.text$mn:00000C09 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00000C09
.text$mn:00000C09 _text$mn        ends
.text$mn:00000C09
.text$mn:00000C0C ; ===========================================================================
.text$mn:00000C0C
.text$mn:00000C0C ; Segment type: Pure code
.text$mn:00000C0C ; Segment permissions: Read/Execute
.text$mn:00000C0C _text$mn        segment para public 'CODE' use32
.text$mn:00000C0C                 assume cs:_text$mn
.text$mn:00000C0C                 ;org 0C0Ch
.text$mn:00000C0C ; COMDAT (pick any)
.text$mn:00000C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C0C
.text$mn:00000C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C0C
.text$mn:00000C0C ; Attributes: bp-based frame
.text$mn:00000C0C
.text$mn:00000C0C ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000C0C                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00000C0C ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00000C0C
.text$mn:00000C0C var_4           = dword ptr -4
.text$mn:00000C0C arg_0           = dword ptr  8
.text$mn:00000C0C
.text$mn:00000C0C                 push    ebp
.text$mn:00000C0D                 mov     ebp, esp
.text$mn:00000C0F                 push    ecx
.text$mn:00000C10                 mov     [ebp+var_4], ecx
.text$mn:00000C13                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000C16                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000C1B                 mov     eax, [ebp+arg_0]
.text$mn:00000C1E                 and     eax, 1
.text$mn:00000C21                 jz      short loc_C2F
.text$mn:00000C23                 mov     ecx, [ebp+var_4]
.text$mn:00000C26                 push    ecx             ; void *
.text$mn:00000C27                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000C2C                 add     esp, 4
.text$mn:00000C2F
.text$mn:00000C2F loc_C2F:                                ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000C2F                 mov     eax, [ebp+var_4]
.text$mn:00000C32                 mov     esp, ebp
.text$mn:00000C34                 pop     ebp
.text$mn:00000C35                 retn    4
.text$mn:00000C35 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00000C35
.text$mn:00000C35 _text$mn        ends
.text$mn:00000C35
.text$di:00000C38 ; ===========================================================================
.text$di:00000C38
.text$di:00000C38 ; Segment type: Pure code
.text$di:00000C38 ; Segment permissions: Read/Execute
.text$di:00000C38 _text$di        segment para public 'CODE' use32
.text$di:00000C38                 assume cs:_text$di
.text$di:00000C38                 ;org 0C38h
.text$di:00000C38 ; COMDAT (pick any)
.text$di:00000C38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000C38
.text$di:00000C38 ; =============== S U B R O U T I N E =======================================
.text$di:00000C38
.text$di:00000C38 ; Attributes: bp-based frame
.text$di:00000C38
.text$di:00000C38 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00000C38 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00000C38                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00000C38                 push    ebp
.text$di:00000C39                 mov     ebp, esp
.text$di:00000C3B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00000C40                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00000C45                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000C4A                 call    _atexit
.text$di:00000C4F                 add     esp, 4
.text$di:00000C52                 pop     ebp
.text$di:00000C53                 retn
.text$di:00000C53 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00000C53
.text$di:00000C53 _text$di        ends
.text$di:00000C53
.text$di:00000C54 ; ===========================================================================
.text$di:00000C54
.text$di:00000C54 ; Segment type: Pure code
.text$di:00000C54 ; Segment permissions: Read/Execute
.text$di:00000C54 _text$di        segment para public 'CODE' use32
.text$di:00000C54                 assume cs:_text$di
.text$di:00000C54                 ;org 0C54h
.text$di:00000C54 ; COMDAT (pick any)
.text$di:00000C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000C54
.text$di:00000C54 ; =============== S U B R O U T I N E =======================================
.text$di:00000C54
.text$di:00000C54 ; Attributes: bp-based frame
.text$di:00000C54
.text$di:00000C54 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00000C54 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00000C54                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00000C54                 push    ebp
.text$di:00000C55                 mov     ebp, esp
.text$di:00000C57                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00000C5C                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00000C61                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000C66                 call    _atexit
.text$di:00000C6B                 add     esp, 4
.text$di:00000C6E                 pop     ebp
.text$di:00000C6F                 retn
.text$di:00000C6F ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00000C6F
.text$di:00000C6F _text$di        ends
.text$di:00000C6F
.text$di:00000C70 ; ===========================================================================
.text$di:00000C70
.text$di:00000C70 ; Segment type: Pure code
.text$di:00000C70 ; Segment permissions: Read/Execute
.text$di:00000C70 _text$di        segment para public 'CODE' use32
.text$di:00000C70                 assume cs:_text$di
.text$di:00000C70                 ;org 0C70h
.text$di:00000C70 ; COMDAT (pick any)
.text$di:00000C70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000C70
.text$di:00000C70 ; =============== S U B R O U T I N E =======================================
.text$di:00000C70
.text$di:00000C70 ; Attributes: bp-based frame
.text$di:00000C70
.text$di:00000C70 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00000C70 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00000C70                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00000C70                 push    ebp
.text$di:00000C71                 mov     ebp, esp
.text$di:00000C73                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00000C78                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00000C7D                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000C82                 call    _atexit
.text$di:00000C87                 add     esp, 4
.text$di:00000C8A                 pop     ebp
.text$di:00000C8B                 retn
.text$di:00000C8B ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00000C8B
.text$di:00000C8B _text$di        ends
.text$di:00000C8B
.text$di:00000C8C ; ===========================================================================
.text$di:00000C8C
.text$di:00000C8C ; Segment type: Pure code
.text$di:00000C8C ; Segment permissions: Read/Execute
.text$di:00000C8C _text$di        segment para public 'CODE' use32
.text$di:00000C8C                 assume cs:_text$di
.text$di:00000C8C                 ;org 0C8Ch
.text$di:00000C8C ; COMDAT (pick any)
.text$di:00000C8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000C8C
.text$di:00000C8C ; =============== S U B R O U T I N E =======================================
.text$di:00000C8C
.text$di:00000C8C ; Attributes: bp-based frame
.text$di:00000C8C
.text$di:00000C8C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00000C8C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000C8C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00000C8C                 push    ebp
.text$di:00000C8D                 mov     ebp, esp
.text$di:00000C8F                 push    0               ; unsigned int
.text$di:00000C91                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000C96                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000C9B                 pop     ebp
.text$di:00000C9C                 retn
.text$di:00000C9C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000C9C
.text$di:00000C9C ; ---------------------------------------------------------------------------
.text$di:00000C9D                 align 10h
.text$di:00000C9D _text$di        ends
.text$di:00000C9D
.text$di:00000CA0 ; ===========================================================================
.text$di:00000CA0
.text$di:00000CA0 ; Segment type: Pure code
.text$di:00000CA0 ; Segment permissions: Read/Execute
.text$di:00000CA0 _text$di        segment para public 'CODE' use32
.text$di:00000CA0                 assume cs:_text$di
.text$di:00000CA0                 ;org 0CA0h
.text$di:00000CA0 ; COMDAT (pick any)
.text$di:00000CA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000CA0
.text$di:00000CA0 ; =============== S U B R O U T I N E =======================================
.text$di:00000CA0
.text$di:00000CA0 ; Attributes: bp-based frame
.text$di:00000CA0
.text$di:00000CA0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00000CA0 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000CA0                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00000CA0                 push    ebp
.text$di:00000CA1                 mov     ebp, esp
.text$di:00000CA3                 push    0               ; unsigned int
.text$di:00000CA5                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000CAA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000CAF                 pop     ebp
.text$di:00000CB0                 retn
.text$di:00000CB0 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000CB0
.text$di:00000CB0 ; ---------------------------------------------------------------------------
.text$di:00000CB1                 align 4
.text$di:00000CB1 _text$di        ends
.text$di:00000CB1
.text$di:00000CB4 ; ===========================================================================
.text$di:00000CB4
.text$di:00000CB4 ; Segment type: Pure code
.text$di:00000CB4 ; Segment permissions: Read/Execute
.text$di:00000CB4 _text$di        segment para public 'CODE' use32
.text$di:00000CB4                 assume cs:_text$di
.text$di:00000CB4                 ;org 0CB4h
.text$di:00000CB4 ; COMDAT (pick any)
.text$di:00000CB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000CB4
.text$di:00000CB4 ; =============== S U B R O U T I N E =======================================
.text$di:00000CB4
.text$di:00000CB4 ; Attributes: bp-based frame
.text$di:00000CB4
.text$di:00000CB4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00000CB4 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000CB4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00000CB4                 push    ebp
.text$di:00000CB5                 mov     ebp, esp
.text$di:00000CB7                 push    0               ; unsigned int
.text$di:00000CB9                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00000CBE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000CC3                 pop     ebp
.text$di:00000CC4                 retn
.text$di:00000CC4 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000CC4
.text$di:00000CC4 ; ---------------------------------------------------------------------------
.text$di:00000CC5                 align 4
.text$di:00000CC5 _text$di        ends
.text$di:00000CC5
.text$di:00000CC8 ; ===========================================================================
.text$di:00000CC8
.text$di:00000CC8 ; Segment type: Pure code
.text$di:00000CC8 ; Segment permissions: Read/Execute
.text$di:00000CC8 _text$di        segment para public 'CODE' use32
.text$di:00000CC8                 assume cs:_text$di
.text$di:00000CC8                 ;org 0CC8h
.text$di:00000CC8 ; COMDAT (pick any)
.text$di:00000CC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000CC8
.text$di:00000CC8 ; =============== S U B R O U T I N E =======================================
.text$di:00000CC8
.text$di:00000CC8 ; Attributes: bp-based frame
.text$di:00000CC8
.text$di:00000CC8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00000CC8 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000CC8                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00000CC8                 push    ebp
.text$di:00000CC9                 mov     ebp, esp
.text$di:00000CCB                 push    0               ; unsigned int
.text$di:00000CCD                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00000CD2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000CD7                 pop     ebp
.text$di:00000CD8                 retn
.text$di:00000CD8 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000CD8
.text$di:00000CD8 ; ---------------------------------------------------------------------------
.text$di:00000CD9                 align 4
.text$di:00000CD9 _text$di        ends
.text$di:00000CD9
.text$di:00000CDC ; ===========================================================================
.text$di:00000CDC
.text$di:00000CDC ; Segment type: Pure code
.text$di:00000CDC ; Segment permissions: Read/Execute
.text$di:00000CDC _text$di        segment para public 'CODE' use32
.text$di:00000CDC                 assume cs:_text$di
.text$di:00000CDC                 ;org 0CDCh
.text$di:00000CDC ; COMDAT (pick any)
.text$di:00000CDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000CDC
.text$di:00000CDC ; =============== S U B R O U T I N E =======================================
.text$di:00000CDC
.text$di:00000CDC ; Attributes: bp-based frame
.text$di:00000CDC
.text$di:00000CDC ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00000CDC ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00000CDC
.text$di:00000CDC var_1           = byte ptr -1
.text$di:00000CDC
.text$di:00000CDC                 push    ebp
.text$di:00000CDD                 mov     ebp, esp
.text$di:00000CDF                 push    ecx
.text$di:00000CE0                 xor     eax, eax
.text$di:00000CE2                 mov     [ebp+var_1], al
.text$di:00000CE5                 mov     esp, ebp
.text$di:00000CE7                 pop     ebp
.text$di:00000CE8                 retn
.text$di:00000CE8 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00000CE8
.text$di:00000CE8 ; ---------------------------------------------------------------------------
.text$di:00000CE9                 align 4
.text$di:00000CE9 _text$di        ends
.text$di:00000CE9
.text$di:00000CEC ; ===========================================================================
.text$di:00000CEC
.text$di:00000CEC ; Segment type: Pure code
.text$di:00000CEC ; Segment permissions: Read/Execute
.text$di:00000CEC _text$di        segment para public 'CODE' use32
.text$di:00000CEC                 assume cs:_text$di
.text$di:00000CEC                 ;org 0CECh
.text$di:00000CEC ; COMDAT (pick any)
.text$di:00000CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00000CEC
.text$di:00000CEC ; =============== S U B R O U T I N E =======================================
.text$di:00000CEC
.text$di:00000CEC ; Attributes: bp-based frame
.text$di:00000CEC
.text$di:00000CEC ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00000CEC ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00000CEC                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00000CEC
.text$di:00000CEC var_1           = byte ptr -1
.text$di:00000CEC
.text$di:00000CEC                 push    ebp
.text$di:00000CED                 mov     ebp, esp
.text$di:00000CEF                 push    ecx
.text$di:00000CF0                 xor     eax, eax
.text$di:00000CF2                 mov     [ebp+var_1], al
.text$di:00000CF5                 mov     esp, ebp
.text$di:00000CF7                 pop     ebp
.text$di:00000CF8                 retn
.text$di:00000CF8 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00000CF8
.text$di:00000CF8 ; ---------------------------------------------------------------------------
.text$di:00000CF9                 align 4
.text$di:00000CF9 _text$di        ends
.text$di:00000CF9
.text$yd:00000CFC ; ===========================================================================
.text$yd:00000CFC
.text$yd:00000CFC ; Segment type: Pure code
.text$yd:00000CFC ; Segment permissions: Read/Execute
.text$yd:00000CFC _text$yd        segment para public 'CODE' use32
.text$yd:00000CFC                 assume cs:_text$yd
.text$yd:00000CFC                 ;org 0CFCh
.text$yd:00000CFC ; COMDAT (pick any)
.text$yd:00000CFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000CFC
.text$yd:00000CFC ; =============== S U B R O U T I N E =======================================
.text$yd:00000CFC
.text$yd:00000CFC ; Attributes: bp-based frame
.text$yd:00000CFC
.text$yd:00000CFC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00000CFC ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00000CFC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00000CFC                 push    ebp
.text$yd:00000CFD                 mov     ebp, esp
.text$yd:00000CFF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00000D04                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00000D09                 pop     ebp
.text$yd:00000D0A                 retn
.text$yd:00000D0A ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00000D0A
.text$yd:00000D0A ; ---------------------------------------------------------------------------
.text$yd:00000D0B                 align 4
.text$yd:00000D0B _text$yd        ends
.text$yd:00000D0B
.text$yd:00000D0C ; ===========================================================================
.text$yd:00000D0C
.text$yd:00000D0C ; Segment type: Pure code
.text$yd:00000D0C ; Segment permissions: Read/Execute
.text$yd:00000D0C _text$yd        segment para public 'CODE' use32
.text$yd:00000D0C                 assume cs:_text$yd
.text$yd:00000D0C                 ;org 0D0Ch
.text$yd:00000D0C ; COMDAT (pick any)
.text$yd:00000D0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000D0C
.text$yd:00000D0C ; =============== S U B R O U T I N E =======================================
.text$yd:00000D0C
.text$yd:00000D0C ; Attributes: bp-based frame
.text$yd:00000D0C
.text$yd:00000D0C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00000D0C ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00000D0C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00000D0C                 push    ebp
.text$yd:00000D0D                 mov     ebp, esp
.text$yd:00000D0F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00000D14                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00000D19                 pop     ebp
.text$yd:00000D1A                 retn
.text$yd:00000D1A ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00000D1A
.text$yd:00000D1A ; ---------------------------------------------------------------------------
.text$yd:00000D1B                 align 4
.text$yd:00000D1B _text$yd        ends
.text$yd:00000D1B
.text$yd:00000D1C ; ===========================================================================
.text$yd:00000D1C
.text$yd:00000D1C ; Segment type: Pure code
.text$yd:00000D1C ; Segment permissions: Read/Execute
.text$yd:00000D1C _text$yd        segment para public 'CODE' use32
.text$yd:00000D1C                 assume cs:_text$yd
.text$yd:00000D1C                 ;org 0D1Ch
.text$yd:00000D1C ; COMDAT (pick any)
.text$yd:00000D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00000D1C
.text$yd:00000D1C ; =============== S U B R O U T I N E =======================================
.text$yd:00000D1C
.text$yd:00000D1C ; Attributes: bp-based frame
.text$yd:00000D1C
.text$yd:00000D1C ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00000D1C ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00000D1C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00000D1C                 push    ebp
.text$yd:00000D1D                 mov     ebp, esp
.text$yd:00000D1F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00000D24                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00000D29                 pop     ebp
.text$yd:00000D2A                 retn
.text$yd:00000D2A ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00000D2A
.text$yd:00000D2A ; ---------------------------------------------------------------------------
.text$yd:00000D2B                 align 4
.text$yd:00000D2B _text$yd        ends
.text$yd:00000D2B
.text$mn:00000D2C ; ===========================================================================
.text$mn:00000D2C
.text$mn:00000D2C ; Segment type: Pure code
.text$mn:00000D2C ; Segment permissions: Read/Execute
.text$mn:00000D2C _text$mn        segment para public 'CODE' use32
.text$mn:00000D2C                 assume cs:_text$mn
.text$mn:00000D2C                 ;org 0D2Ch
.text$mn:00000D2C ; COMDAT (pick any)
.text$mn:00000D2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D2C
.text$mn:00000D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D2C
.text$mn:00000D2C ; Attributes: bp-based frame
.text$mn:00000D2C
.text$mn:00000D2C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000D2C                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00000D2C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00000D2C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00000D2C
.text$mn:00000D2C var_10          = byte ptr -10h
.text$mn:00000D2C var_8           = dword ptr -8
.text$mn:00000D2C var_1           = byte ptr -1
.text$mn:00000D2C
.text$mn:00000D2C                 push    ebp
.text$mn:00000D2D                 mov     ebp, esp
.text$mn:00000D2F                 sub     esp, 10h
.text$mn:00000D32                 mov     [ebp+var_8], ecx
.text$mn:00000D35                 lea     ecx, [ebp+var_1]
.text$mn:00000D38                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00000D3D                 push    1
.text$mn:00000D3F                 lea     ecx, [ebp+var_1]
.text$mn:00000D42                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00000D47                 mov     ecx, [ebp+var_8]
.text$mn:00000D4A                 mov     [ecx], eax
.text$mn:00000D4C                 lea     ecx, [ebp+var_10] ; this
.text$mn:00000D4F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00000D54                 push    eax             ; int
.text$mn:00000D55                 mov     edx, [ebp+var_8]
.text$mn:00000D58                 mov     eax, [edx]
.text$mn:00000D5A                 push    eax             ; void *
.text$mn:00000D5B                 lea     ecx, [ebp+var_1]
.text$mn:00000D5E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00000D63                 mov     ecx, [ebp+var_8]
.text$mn:00000D66                 mov     edx, [ecx]
.text$mn:00000D68                 mov     eax, [ebp+var_8]
.text$mn:00000D6B                 mov     [edx], eax
.text$mn:00000D6D                 mov     esp, ebp
.text$mn:00000D6F                 pop     ebp
.text$mn:00000D70                 retn
.text$mn:00000D70 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00000D70
.text$mn:00000D70 ; ---------------------------------------------------------------------------
.text$mn:00000D71                 align 4
.text$mn:00000D71 _text$mn        ends
.text$mn:00000D71
.text$mn:00000D74 ; ===========================================================================
.text$mn:00000D74
.text$mn:00000D74 ; Segment type: Pure code
.text$mn:00000D74 ; Segment permissions: Read/Execute
.text$mn:00000D74 _text$mn        segment para public 'CODE' use32
.text$mn:00000D74                 assume cs:_text$mn
.text$mn:00000D74                 ;org 0D74h
.text$mn:00000D74 ; COMDAT (pick any)
.text$mn:00000D74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D74
.text$mn:00000D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D74
.text$mn:00000D74 ; Attributes: bp-based frame
.text$mn:00000D74
.text$mn:00000D74 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00000D74                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000D74 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00000D74                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00000D74
.text$mn:00000D74 var_20          = dword ptr -20h
.text$mn:00000D74 var_1C          = dword ptr -1Ch
.text$mn:00000D74 var_18          = dword ptr -18h
.text$mn:00000D74 var_11          = byte ptr -11h
.text$mn:00000D74 var_10          = dword ptr -10h
.text$mn:00000D74 var_C           = byte ptr -0Ch
.text$mn:00000D74 var_4           = dword ptr -4
.text$mn:00000D74 arg_0           = dword ptr  8
.text$mn:00000D74
.text$mn:00000D74 ; FUNCTION CHUNK AT .text$mn:00000E96 SIZE 00000009 BYTES
.text$mn:00000D74
.text$mn:00000D74                 push    ebp
.text$mn:00000D75                 mov     ebp, esp
.text$mn:00000D77                 push    0FFFFFFFFh
.text$mn:00000D79                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000D7E                 mov     eax, large fs:0
.text$mn:00000D84                 push    eax
.text$mn:00000D85                 push    ecx
.text$mn:00000D86                 sub     esp, 10h
.text$mn:00000D89                 push    ebx
.text$mn:00000D8A                 push    esi
.text$mn:00000D8B                 push    edi
.text$mn:00000D8C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D91                 xor     eax, ebp
.text$mn:00000D93                 push    eax
.text$mn:00000D94                 lea     eax, [ebp+var_C]
.text$mn:00000D97                 mov     large fs:0, eax
.text$mn:00000D9D                 mov     [ebp+var_10], esp
.text$mn:00000DA0                 mov     [ebp+var_18], ecx
.text$mn:00000DA3                 mov     eax, [ebp+arg_0]
.text$mn:00000DA6                 or      eax, 0Fh
.text$mn:00000DA9                 mov     [ebp+var_1C], eax
.text$mn:00000DAC                 mov     ecx, [ebp+var_18]
.text$mn:00000DAF                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000DB4                 cmp     eax, [ebp+var_1C]
.text$mn:00000DB7                 jnb     short loc_DC1
.text$mn:00000DB9                 mov     ecx, [ebp+arg_0]
.text$mn:00000DBC                 mov     [ebp+var_1C], ecx
.text$mn:00000DBF                 jmp     short loc_E13
.text$mn:00000DC1 ; ---------------------------------------------------------------------------
.text$mn:00000DC1
.text$mn:00000DC1 loc_DC1:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00000DC1                 mov     edx, [ebp+var_18]
.text$mn:00000DC4                 mov     ecx, [edx+18h]
.text$mn:00000DC7                 shr     ecx, 1
.text$mn:00000DC9                 mov     eax, [ebp+var_1C]
.text$mn:00000DCC                 xor     edx, edx
.text$mn:00000DCE                 mov     esi, 3
.text$mn:00000DD3                 div     esi
.text$mn:00000DD5                 cmp     ecx, eax
.text$mn:00000DD7                 ja      short loc_DDB
.text$mn:00000DD9                 jmp     short loc_E13
.text$mn:00000DDB ; ---------------------------------------------------------------------------
.text$mn:00000DDB
.text$mn:00000DDB loc_DDB:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00000DDB                 mov     ecx, [ebp+var_18]
.text$mn:00000DDE                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000DE3                 mov     edx, [ebp+var_18]
.text$mn:00000DE6                 mov     ecx, [edx+18h]
.text$mn:00000DE9                 shr     ecx, 1
.text$mn:00000DEB                 sub     eax, ecx
.text$mn:00000DED                 mov     edx, [ebp+var_18]
.text$mn:00000DF0                 cmp     [edx+18h], eax
.text$mn:00000DF3                 ja      short loc_E08
.text$mn:00000DF5                 mov     eax, [ebp+var_18]
.text$mn:00000DF8                 mov     ecx, [eax+18h]
.text$mn:00000DFB                 shr     ecx, 1
.text$mn:00000DFD                 mov     edx, [ebp+var_18]
.text$mn:00000E00                 add     ecx, [edx+18h]
.text$mn:00000E03                 mov     [ebp+var_1C], ecx
.text$mn:00000E06                 jmp     short loc_E13
.text$mn:00000E08 ; ---------------------------------------------------------------------------
.text$mn:00000E08
.text$mn:00000E08 loc_E08:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00000E08                 mov     ecx, [ebp+var_18]
.text$mn:00000E0B                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000E10                 mov     [ebp+var_1C], eax
.text$mn:00000E13
.text$mn:00000E13 loc_E13:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00000E13                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00000E13                 mov     [ebp+var_4], 0
.text$mn:00000E1A                 mov     eax, [ebp+var_1C]
.text$mn:00000E1D                 add     eax, 1
.text$mn:00000E20                 push    eax
.text$mn:00000E21                 lea     ecx, [ebp+var_11]
.text$mn:00000E24                 push    ecx
.text$mn:00000E25                 mov     ecx, [ebp+var_18]
.text$mn:00000E28                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000E2D                 mov     ecx, eax
.text$mn:00000E2F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00000E34                 mov     [ebp+var_20], eax
.text$mn:00000E37                 jmp     short loc_E96
.text$mn:00000E37 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00000E37
.text$mn:00000E39
.text$mn:00000E39 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E39
.text$mn:00000E39
.text$mn:00000E39 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00000E39                                         ; DATA XREF: .xdata$x:00001BD0o
.text$mn:00000E39
.text$mn:00000E39 ; FUNCTION CHUNK AT .text$mn:00000E80 SIZE 00000009 BYTES
.text$mn:00000E39 ; FUNCTION CHUNK AT .text$mn:00000E90 SIZE 00000006 BYTES
.text$mn:00000E39
.text$mn:00000E39                 mov     [ebp-10h], esp
.text$mn:00000E3C                 mov     edx, [ebp+8]
.text$mn:00000E3F                 mov     [ebp-1Ch], edx
.text$mn:00000E42                 mov     byte ptr [ebp-4], 2
.text$mn:00000E46                 mov     eax, [ebp-1Ch]
.text$mn:00000E49                 add     eax, 1
.text$mn:00000E4C                 push    eax
.text$mn:00000E4D                 lea     ecx, [ebp-12h]
.text$mn:00000E50                 push    ecx
.text$mn:00000E51                 mov     ecx, [ebp-18h]
.text$mn:00000E54                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000E59                 mov     ecx, eax
.text$mn:00000E5B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00000E60                 mov     [ebp-20h], eax
.text$mn:00000E63                 jmp     short loc_E80
.text$mn:00000E63 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00000E63
.text$mn:00000E65
.text$mn:00000E65 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E65
.text$mn:00000E65 ; Attributes: noreturn
.text$mn:00000E65
.text$mn:00000E65 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00000E65                                         ; DATA XREF: .xdata$x:00001BE0o
.text$mn:00000E65                 push    0               ; Size
.text$mn:00000E67                 push    1               ; char
.text$mn:00000E69                 mov     ecx, [ebp-18h]
.text$mn:00000E6C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000E71                 push    0
.text$mn:00000E73                 push    0
.text$mn:00000E75                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000E75 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00000E75
.text$mn:00000E7A ; ---------------------------------------------------------------------------
.text$mn:00000E7A                 mov     eax, offset $LN17
.text$mn:00000E7F                 retn
.text$mn:00000E80 ; ---------------------------------------------------------------------------
.text$mn:00000E80 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000E80
.text$mn:00000E80 loc_E80:                                ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00000E80                 mov     dword ptr [ebp-4], 1
.text$mn:00000E87                 jmp     short loc_E90
.text$mn:00000E87 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000E89
.text$mn:00000E89 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E89
.text$mn:00000E89
.text$mn:00000E89 $LN17           proc near               ; DATA XREF: .text$mn:00000E7Ao
.text$mn:00000E89                 mov     dword ptr [ebp-4], 1
.text$mn:00000E89 $LN17           endp ; sp-analysis failed
.text$mn:00000E89
.text$mn:00000E90 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000E90
.text$mn:00000E90 loc_E90:                                ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00000E90                 mov     eax, offset $LN19
.text$mn:00000E95                 retn
.text$mn:00000E95 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000E96 ; ---------------------------------------------------------------------------
.text$mn:00000E96 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000E96
.text$mn:00000E96 loc_E96:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00000E96                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E9D                 jmp     short loc_EA6
.text$mn:00000E9D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000E9F
.text$mn:00000E9F ; =============== S U B R O U T I N E =======================================
.text$mn:00000E9F
.text$mn:00000E9F
.text$mn:00000E9F $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_E90o
.text$mn:00000E9F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00000EA6
.text$mn:00000EA6 loc_EA6:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00000EA6                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00000EAA                 jbe     short loc_EC5
.text$mn:00000EAC                 mov     edx, [ebp+0Ch]
.text$mn:00000EAF                 push    edx             ; Size
.text$mn:00000EB0                 mov     ecx, [ebp-18h]
.text$mn:00000EB3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000EB8                 push    eax             ; Src
.text$mn:00000EB9                 mov     eax, [ebp-20h]
.text$mn:00000EBC                 push    eax             ; Dst
.text$mn:00000EBD                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00000EC2                 add     esp, 0Ch
.text$mn:00000EC5
.text$mn:00000EC5 loc_EC5:                                ; CODE XREF: $LN19+Bj
.text$mn:00000EC5                 push    0               ; Size
.text$mn:00000EC7                 push    1               ; char
.text$mn:00000EC9                 mov     ecx, [ebp-18h]
.text$mn:00000ECC                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000ED1                 lea     ecx, [ebp-20h]
.text$mn:00000ED4                 push    ecx             ; int
.text$mn:00000ED5                 mov     edx, [ebp-18h]
.text$mn:00000ED8                 add     edx, 4
.text$mn:00000EDB                 push    edx             ; void *
.text$mn:00000EDC                 lea     eax, [ebp-13h]
.text$mn:00000EDF                 push    eax
.text$mn:00000EE0                 mov     ecx, [ebp-18h]
.text$mn:00000EE3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000EE8                 mov     ecx, eax
.text$mn:00000EEA                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000EEF                 mov     ecx, [ebp-18h]
.text$mn:00000EF2                 mov     edx, [ebp-1Ch]
.text$mn:00000EF5                 mov     [ecx+18h], edx
.text$mn:00000EF8                 mov     eax, [ebp+0Ch]
.text$mn:00000EFB                 push    eax
.text$mn:00000EFC                 mov     ecx, [ebp-18h]
.text$mn:00000EFF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00000F04                 mov     ecx, [ebp-0Ch]
.text$mn:00000F07                 mov     large fs:0, ecx
.text$mn:00000F0E                 pop     ecx
.text$mn:00000F0F                 pop     edi
.text$mn:00000F10                 pop     esi
.text$mn:00000F11                 pop     ebx
.text$mn:00000F12                 mov     esp, ebp
.text$mn:00000F14                 pop     ebp
.text$mn:00000F15                 retn    8
.text$mn:00000F15 $LN19           endp ; sp-analysis failed
.text$mn:00000F15
.text$mn:00000F15 _text$mn        ends
.text$mn:00000F15
.text$x:00000F18 ; ===========================================================================
.text$x:00000F18
.text$x:00000F18 ; Segment type: Pure code
.text$x:00000F18 ; Segment permissions: Read/Execute
.text$x:00000F18 _text$x         segment para public 'CODE' use32
.text$x:00000F18                 assume cs:_text$x
.text$x:00000F18                 ;org 0F18h
.text$x:00000F18 ; COMDAT (pick associative to section at D74)
.text$x:00000F18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000F18
.text$x:00000F18 ; =============== S U B R O U T I N E =======================================
.text$x:00000F18
.text$x:00000F18
.text$x:00000F18 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00000F18                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00000F18
.text$x:00000F18 arg_4           = dword ptr  8
.text$x:00000F18
.text$x:00000F18                 mov     edx, [esp+arg_4]
.text$x:00000F1C                 lea     eax, [edx+0Ch]
.text$x:00000F1F                 mov     ecx, [edx-24h]
.text$x:00000F22                 xor     ecx, eax
.text$x:00000F24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F29                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00000F2E                 jmp     ___CxxFrameHandler3
.text$x:00000F2E __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00000F2E
.text$x:00000F2E ; ---------------------------------------------------------------------------
.text$x:00000F33                 align 4
.text$x:00000F33 _text$x         ends
.text$x:00000F33
.text$mn:00000F34 ; ===========================================================================
.text$mn:00000F34
.text$mn:00000F34 ; Segment type: Pure code
.text$mn:00000F34 ; Segment permissions: Read/Execute
.text$mn:00000F34 _text$mn        segment para public 'CODE' use32
.text$mn:00000F34                 assume cs:_text$mn
.text$mn:00000F34                 ;org 0F34h
.text$mn:00000F34 ; COMDAT (pick any)
.text$mn:00000F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F34
.text$mn:00000F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F34
.text$mn:00000F34 ; Attributes: bp-based frame
.text$mn:00000F34
.text$mn:00000F34 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00000F34                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00000F34 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00000F34                                         ; CODE XREF: $LN19+60p
.text$mn:00000F34                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00000F34
.text$mn:00000F34 var_8           = dword ptr -8
.text$mn:00000F34 var_1           = byte ptr -1
.text$mn:00000F34 arg_0           = dword ptr  8
.text$mn:00000F34
.text$mn:00000F34                 push    ebp
.text$mn:00000F35                 mov     ebp, esp
.text$mn:00000F37                 sub     esp, 8
.text$mn:00000F3A                 mov     [ebp+var_8], ecx
.text$mn:00000F3D                 mov     [ebp+var_1], 0
.text$mn:00000F41                 mov     eax, [ebp+var_8]
.text$mn:00000F44                 mov     ecx, [ebp+arg_0]
.text$mn:00000F47                 mov     [eax+14h], ecx
.text$mn:00000F4A                 lea     edx, [ebp+var_1]
.text$mn:00000F4D                 push    edx
.text$mn:00000F4E                 mov     ecx, [ebp+var_8]
.text$mn:00000F51                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000F56                 add     eax, [ebp+arg_0]
.text$mn:00000F59                 push    eax
.text$mn:00000F5A                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00000F5F                 add     esp, 8
.text$mn:00000F62                 mov     esp, ebp
.text$mn:00000F64                 pop     ebp
.text$mn:00000F65                 retn    4
.text$mn:00000F65 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00000F65
.text$mn:00000F65 _text$mn        ends
.text$mn:00000F65
.text$mn:00000F68 ; ===========================================================================
.text$mn:00000F68
.text$mn:00000F68 ; Segment type: Pure code
.text$mn:00000F68 ; Segment permissions: Read/Execute
.text$mn:00000F68 _text$mn        segment para public 'CODE' use32
.text$mn:00000F68                 assume cs:_text$mn
.text$mn:00000F68                 ;org 0F68h
.text$mn:00000F68 ; COMDAT (pick any)
.text$mn:00000F68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F68
.text$mn:00000F68 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F68
.text$mn:00000F68 ; Attributes: bp-based frame
.text$mn:00000F68
.text$mn:00000F68 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000F68                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00000F68 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00000F68                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00000F68
.text$mn:00000F68 var_8           = dword ptr -8
.text$mn:00000F68 var_1           = byte ptr -1
.text$mn:00000F68
.text$mn:00000F68                 push    ebp
.text$mn:00000F69                 mov     ebp, esp
.text$mn:00000F6B                 sub     esp, 8
.text$mn:00000F6E                 mov     [ebp+var_8], ecx
.text$mn:00000F71                 lea     ecx, [ebp+var_1]
.text$mn:00000F74                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00000F79                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000F7C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000F81                 mov     eax, [ebp+var_8]
.text$mn:00000F84                 mov     ecx, [eax]
.text$mn:00000F86                 push    ecx
.text$mn:00000F87                 lea     ecx, [ebp+var_1]
.text$mn:00000F8A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00000F8F                 push    1               ; int
.text$mn:00000F91                 mov     edx, [ebp+var_8]
.text$mn:00000F94                 mov     eax, [edx]
.text$mn:00000F96                 push    eax             ; void *
.text$mn:00000F97                 lea     ecx, [ebp+var_1]
.text$mn:00000F9A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00000F9F                 mov     ecx, [ebp+var_8]
.text$mn:00000FA2                 mov     dword ptr [ecx], 0
.text$mn:00000FA8                 mov     esp, ebp
.text$mn:00000FAA                 pop     ebp
.text$mn:00000FAB                 retn
.text$mn:00000FAB ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00000FAB
.text$mn:00000FAB _text$mn        ends
.text$mn:00000FAB
.text$mn:00000FAC ; ===========================================================================
.text$mn:00000FAC
.text$mn:00000FAC ; Segment type: Pure code
.text$mn:00000FAC ; Segment permissions: Read/Execute
.text$mn:00000FAC _text$mn        segment para public 'CODE' use32
.text$mn:00000FAC                 assume cs:_text$mn
.text$mn:00000FAC                 ;org 0FACh
.text$mn:00000FAC ; COMDAT (pick any)
.text$mn:00000FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FAC
.text$mn:00000FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000FAC
.text$mn:00000FAC ; Attributes: bp-based frame
.text$mn:00000FAC
.text$mn:00000FAC ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00000FAC                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00000FAC ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00000FAC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00000FAC                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00000FAC
.text$mn:00000FAC var_4           = dword ptr -4
.text$mn:00000FAC arg_0           = dword ptr  8
.text$mn:00000FAC
.text$mn:00000FAC                 push    ebp
.text$mn:00000FAD                 mov     ebp, esp
.text$mn:00000FAF                 push    ecx
.text$mn:00000FB0                 mov     [ebp+var_4], ecx
.text$mn:00000FB3                 mov     ecx, [ebp+arg_0]
.text$mn:00000FB6                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00000FBB                 mov     eax, [ebp+arg_0]
.text$mn:00000FBE                 mov     esp, ebp
.text$mn:00000FC0                 pop     ebp
.text$mn:00000FC1                 retn    4
.text$mn:00000FC1 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00000FC1
.text$mn:00000FC1 _text$mn        ends
.text$mn:00000FC1
.text$mn:00000FC4 ; ===========================================================================
.text$mn:00000FC4
.text$mn:00000FC4 ; Segment type: Pure code
.text$mn:00000FC4 ; Segment permissions: Read/Execute
.text$mn:00000FC4 _text$mn        segment para public 'CODE' use32
.text$mn:00000FC4                 assume cs:_text$mn
.text$mn:00000FC4                 ;org 0FC4h
.text$mn:00000FC4 ; COMDAT (pick any)
.text$mn:00000FC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FC4
.text$mn:00000FC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FC4
.text$mn:00000FC4 ; Attributes: bp-based frame
.text$mn:00000FC4
.text$mn:00000FC4 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00000FC4                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00000FC4 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00000FC4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00000FC4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00000FC4
.text$mn:00000FC4 var_C           = dword ptr -0Ch
.text$mn:00000FC4 Size            = dword ptr -8
.text$mn:00000FC4 var_4           = dword ptr -4
.text$mn:00000FC4 arg_0           = dword ptr  8
.text$mn:00000FC4 arg_4           = byte ptr  0Ch
.text$mn:00000FC4
.text$mn:00000FC4                 push    ebp
.text$mn:00000FC5                 mov     ebp, esp
.text$mn:00000FC7                 sub     esp, 0Ch
.text$mn:00000FCA                 mov     [ebp+var_4], ecx
.text$mn:00000FCD                 mov     ecx, [ebp+var_4]
.text$mn:00000FD0                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000FD5                 cmp     eax, [ebp+arg_0]
.text$mn:00000FD8                 jnb     short loc_FE2
.text$mn:00000FDA                 mov     ecx, [ebp+var_4]
.text$mn:00000FDD                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00000FE2
.text$mn:00000FE2 loc_FE2:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00000FE2                 mov     eax, [ebp+var_4]
.text$mn:00000FE5                 mov     ecx, [eax+18h]
.text$mn:00000FE8                 cmp     ecx, [ebp+arg_0]
.text$mn:00000FEB                 jnb     short loc_1002
.text$mn:00000FED                 mov     edx, [ebp+var_4]
.text$mn:00000FF0                 mov     eax, [edx+14h]
.text$mn:00000FF3                 push    eax
.text$mn:00000FF4                 mov     ecx, [ebp+arg_0]
.text$mn:00000FF7                 push    ecx
.text$mn:00000FF8                 mov     ecx, [ebp+var_4]
.text$mn:00000FFB                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001000                 jmp     short loc_104C
.text$mn:00001002 ; ---------------------------------------------------------------------------
.text$mn:00001002
.text$mn:00001002 loc_1002:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001002                 movzx   edx, [ebp+arg_4]
.text$mn:00001006                 test    edx, edx
.text$mn:00001008                 jz      short loc_103C
.text$mn:0000100A                 cmp     [ebp+arg_0], 10h
.text$mn:0000100E                 jnb     short loc_103C
.text$mn:00001010                 mov     eax, [ebp+var_4]
.text$mn:00001013                 mov     ecx, [ebp+arg_0]
.text$mn:00001016                 cmp     ecx, [eax+14h]
.text$mn:00001019                 jnb     short loc_1023
.text$mn:0000101B                 mov     edx, [ebp+arg_0]
.text$mn:0000101E                 mov     [ebp+Size], edx
.text$mn:00001021                 jmp     short loc_102C
.text$mn:00001023 ; ---------------------------------------------------------------------------
.text$mn:00001023
.text$mn:00001023 loc_1023:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001023                 mov     eax, [ebp+var_4]
.text$mn:00001026                 mov     ecx, [eax+14h]
.text$mn:00001029                 mov     [ebp+Size], ecx
.text$mn:0000102C
.text$mn:0000102C loc_102C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:0000102C                 mov     edx, [ebp+Size]
.text$mn:0000102F                 push    edx             ; Size
.text$mn:00001030                 push    1               ; char
.text$mn:00001032                 mov     ecx, [ebp+var_4]
.text$mn:00001035                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000103A                 jmp     short loc_104C
.text$mn:0000103C ; ---------------------------------------------------------------------------
.text$mn:0000103C
.text$mn:0000103C loc_103C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:0000103C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:0000103C                 cmp     [ebp+arg_0], 0
.text$mn:00001040                 jnz     short loc_104C
.text$mn:00001042                 push    0
.text$mn:00001044                 mov     ecx, [ebp+var_4]
.text$mn:00001047                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000104C
.text$mn:0000104C loc_104C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:0000104C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:0000104C                 cmp     [ebp+arg_0], 0
.text$mn:00001050                 jbe     short loc_105B
.text$mn:00001052                 mov     [ebp+var_C], 1
.text$mn:00001059                 jmp     short loc_1062
.text$mn:0000105B ; ---------------------------------------------------------------------------
.text$mn:0000105B
.text$mn:0000105B loc_105B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000105B                 mov     [ebp+var_C], 0
.text$mn:00001062
.text$mn:00001062 loc_1062:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001062                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001065                 mov     esp, ebp
.text$mn:00001067                 pop     ebp
.text$mn:00001068                 retn    8
.text$mn:00001068 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001068
.text$mn:00001068 ; ---------------------------------------------------------------------------
.text$mn:0000106B                 align 4
.text$mn:0000106B _text$mn        ends
.text$mn:0000106B
.text$mn:0000106C ; ===========================================================================
.text$mn:0000106C
.text$mn:0000106C ; Segment type: Pure code
.text$mn:0000106C ; Segment permissions: Read/Execute
.text$mn:0000106C _text$mn        segment para public 'CODE' use32
.text$mn:0000106C                 assume cs:_text$mn
.text$mn:0000106C                 ;org 106Ch
.text$mn:0000106C ; COMDAT (pick any)
.text$mn:0000106C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000106C
.text$mn:0000106C ; =============== S U B R O U T I N E =======================================
.text$mn:0000106C
.text$mn:0000106C ; Attributes: bp-based frame
.text$mn:0000106C
.text$mn:0000106C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:0000106C                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:0000106C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:0000106C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:0000106C
.text$mn:0000106C var_4           = dword ptr -4
.text$mn:0000106C arg_0           = dword ptr  8
.text$mn:0000106C
.text$mn:0000106C                 push    ebp
.text$mn:0000106D                 mov     ebp, esp
.text$mn:0000106F                 push    ecx
.text$mn:00001070                 mov     [ebp+var_4], ecx
.text$mn:00001073                 cmp     [ebp+arg_0], 0
.text$mn:00001077                 jz      short loc_1099
.text$mn:00001079                 mov     ecx, [ebp+var_4]
.text$mn:0000107C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001081                 cmp     [ebp+arg_0], eax
.text$mn:00001084                 jb      short loc_1099
.text$mn:00001086                 mov     ecx, [ebp+var_4]
.text$mn:00001089                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000108E                 mov     ecx, [ebp+var_4]
.text$mn:00001091                 add     eax, [ecx+14h]
.text$mn:00001094                 cmp     eax, [ebp+arg_0]
.text$mn:00001097                 ja      short loc_109F
.text$mn:00001099
.text$mn:00001099 loc_1099:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001099                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001099                 xor     al, al
.text$mn:0000109B                 jmp     short loc_10A1
.text$mn:0000109D ; ---------------------------------------------------------------------------
.text$mn:0000109D                 jmp     short loc_10A1
.text$mn:0000109F ; ---------------------------------------------------------------------------
.text$mn:0000109F
.text$mn:0000109F loc_109F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000109F                 mov     al, 1
.text$mn:000010A1
.text$mn:000010A1 loc_10A1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000010A1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000010A1                 mov     esp, ebp
.text$mn:000010A3                 pop     ebp
.text$mn:000010A4                 retn    4
.text$mn:000010A4 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000010A4
.text$mn:000010A4 ; ---------------------------------------------------------------------------
.text$mn:000010A7                 align 4
.text$mn:000010A7 _text$mn        ends
.text$mn:000010A7
.text$mn:000010A8 ; ===========================================================================
.text$mn:000010A8
.text$mn:000010A8 ; Segment type: Pure code
.text$mn:000010A8 ; Segment permissions: Read/Execute
.text$mn:000010A8 _text$mn        segment para public 'CODE' use32
.text$mn:000010A8                 assume cs:_text$mn
.text$mn:000010A8                 ;org 10A8h
.text$mn:000010A8 ; COMDAT (pick any)
.text$mn:000010A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010A8
.text$mn:000010A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010A8
.text$mn:000010A8 ; Attributes: bp-based frame
.text$mn:000010A8
.text$mn:000010A8 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000010A8                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000010A8 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000010A8                                         ; CODE XREF: $LN19+14p
.text$mn:000010A8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000010A8
.text$mn:000010A8 var_8           = dword ptr -8
.text$mn:000010A8 var_4           = dword ptr -4
.text$mn:000010A8
.text$mn:000010A8                 push    ebp
.text$mn:000010A9                 mov     ebp, esp
.text$mn:000010AB                 sub     esp, 8
.text$mn:000010AE                 mov     [ebp+var_4], ecx
.text$mn:000010B1                 mov     eax, [ebp+var_4]
.text$mn:000010B4                 cmp     dword ptr [eax+18h], 10h
.text$mn:000010B8                 jb      short loc_10CE
.text$mn:000010BA                 mov     ecx, [ebp+var_4]
.text$mn:000010BD                 mov     edx, [ecx+4]
.text$mn:000010C0                 push    edx
.text$mn:000010C1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000010C6                 add     esp, 4
.text$mn:000010C9                 mov     [ebp+var_8], eax
.text$mn:000010CC                 jmp     short loc_10D7
.text$mn:000010CE ; ---------------------------------------------------------------------------
.text$mn:000010CE
.text$mn:000010CE loc_10CE:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000010CE                 mov     eax, [ebp+var_4]
.text$mn:000010D1                 add     eax, 4
.text$mn:000010D4                 mov     [ebp+var_8], eax
.text$mn:000010D7
.text$mn:000010D7 loc_10D7:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000010D7                 mov     eax, [ebp+var_8]
.text$mn:000010DA                 mov     esp, ebp
.text$mn:000010DC                 pop     ebp
.text$mn:000010DD                 retn
.text$mn:000010DD ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000010DD
.text$mn:000010DD ; ---------------------------------------------------------------------------
.text$mn:000010DE                 align 10h
.text$mn:000010DE _text$mn        ends
.text$mn:000010DE
.text$mn:000010E0 ; ===========================================================================
.text$mn:000010E0
.text$mn:000010E0 ; Segment type: Pure code
.text$mn:000010E0 ; Segment permissions: Read/Execute
.text$mn:000010E0 _text$mn        segment para public 'CODE' use32
.text$mn:000010E0                 assume cs:_text$mn
.text$mn:000010E0                 ;org 10E0h
.text$mn:000010E0 ; COMDAT (pick any)
.text$mn:000010E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010E0
.text$mn:000010E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000010E0
.text$mn:000010E0 ; Attributes: bp-based frame
.text$mn:000010E0
.text$mn:000010E0 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000010E0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000010E0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000010E0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000010E0
.text$mn:000010E0 var_8           = dword ptr -8
.text$mn:000010E0 var_4           = dword ptr -4
.text$mn:000010E0
.text$mn:000010E0                 push    ebp
.text$mn:000010E1                 mov     ebp, esp
.text$mn:000010E3                 sub     esp, 8
.text$mn:000010E6                 mov     [ebp+var_4], ecx
.text$mn:000010E9                 mov     eax, [ebp+var_4]
.text$mn:000010EC                 cmp     dword ptr [eax+18h], 10h
.text$mn:000010F0                 jb      short loc_1106
.text$mn:000010F2                 mov     ecx, [ebp+var_4]
.text$mn:000010F5                 mov     edx, [ecx+4]
.text$mn:000010F8                 push    edx
.text$mn:000010F9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000010FE                 add     esp, 4
.text$mn:00001101                 mov     [ebp+var_8], eax
.text$mn:00001104                 jmp     short loc_110F
.text$mn:00001106 ; ---------------------------------------------------------------------------
.text$mn:00001106
.text$mn:00001106 loc_1106:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001106                 mov     eax, [ebp+var_4]
.text$mn:00001109                 add     eax, 4
.text$mn:0000110C                 mov     [ebp+var_8], eax
.text$mn:0000110F
.text$mn:0000110F loc_110F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000110F                 mov     eax, [ebp+var_8]
.text$mn:00001112                 mov     esp, ebp
.text$mn:00001114                 pop     ebp
.text$mn:00001115                 retn
.text$mn:00001115 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00001115
.text$mn:00001115 ; ---------------------------------------------------------------------------
.text$mn:00001116                 align 4
.text$mn:00001116 _text$mn        ends
.text$mn:00001116
.text$mn:00001118 ; ===========================================================================
.text$mn:00001118
.text$mn:00001118 ; Segment type: Pure code
.text$mn:00001118 ; Segment permissions: Read/Execute
.text$mn:00001118 _text$mn        segment para public 'CODE' use32
.text$mn:00001118                 assume cs:_text$mn
.text$mn:00001118                 ;org 1118h
.text$mn:00001118 ; COMDAT (pick any)
.text$mn:00001118                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001118
.text$mn:00001118 ; =============== S U B R O U T I N E =======================================
.text$mn:00001118
.text$mn:00001118 ; Attributes: bp-based frame
.text$mn:00001118
.text$mn:00001118 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001118                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001118 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001118                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001118                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00001118
.text$mn:00001118 var_18          = byte ptr -18h
.text$mn:00001118 var_14          = dword ptr -14h
.text$mn:00001118 var_10          = dword ptr -10h
.text$mn:00001118 var_C           = dword ptr -0Ch
.text$mn:00001118 var_4           = dword ptr -4
.text$mn:00001118
.text$mn:00001118                 push    ebp
.text$mn:00001119                 mov     ebp, esp
.text$mn:0000111B                 push    0FFFFFFFFh
.text$mn:0000111D                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001122                 mov     eax, large fs:0
.text$mn:00001128                 push    eax
.text$mn:00001129                 sub     esp, 0Ch
.text$mn:0000112C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001131                 xor     eax, ebp
.text$mn:00001133                 push    eax
.text$mn:00001134                 lea     eax, [ebp+var_C]
.text$mn:00001137                 mov     large fs:0, eax
.text$mn:0000113D                 mov     [ebp+var_14], ecx
.text$mn:00001140                 mov     eax, [ebp+var_14]
.text$mn:00001143                 cmp     dword ptr [eax], 0
.text$mn:00001146                 jz      short loc_11A3
.text$mn:00001148                 push    3               ; int
.text$mn:0000114A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000114D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00001152                 mov     [ebp+var_4], 0
.text$mn:00001159                 mov     ecx, [ebp+var_14]
.text$mn:0000115C                 mov     edx, [ecx]
.text$mn:0000115E                 add     edx, 4
.text$mn:00001161                 mov     [ebp+var_10], edx
.text$mn:00001164                 jmp     short loc_1173
.text$mn:00001166 ; ---------------------------------------------------------------------------
.text$mn:00001166
.text$mn:00001166 loc_1166:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00001166                 mov     eax, [ebp+var_10]
.text$mn:00001169                 mov     ecx, [eax]
.text$mn:0000116B                 mov     edx, [ebp+var_10]
.text$mn:0000116E                 mov     eax, [ecx+4]
.text$mn:00001171                 mov     [edx], eax
.text$mn:00001173
.text$mn:00001173 loc_1173:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00001173                 mov     ecx, [ebp+var_10]
.text$mn:00001176                 cmp     dword ptr [ecx], 0
.text$mn:00001179                 jz      short loc_1188
.text$mn:0000117B                 mov     edx, [ebp+var_10]
.text$mn:0000117E                 mov     eax, [edx]
.text$mn:00001180                 mov     dword ptr [eax], 0
.text$mn:00001186                 jmp     short loc_1166
.text$mn:00001188 ; ---------------------------------------------------------------------------
.text$mn:00001188
.text$mn:00001188 loc_1188:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00001188                 mov     ecx, [ebp+var_14]
.text$mn:0000118B                 mov     edx, [ecx]
.text$mn:0000118D                 mov     dword ptr [edx+4], 0
.text$mn:00001194                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000119B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000119E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000011A3
.text$mn:000011A3 loc_11A3:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000011A3                 mov     ecx, [ebp+var_C]
.text$mn:000011A6                 mov     large fs:0, ecx
.text$mn:000011AD                 pop     ecx
.text$mn:000011AE                 mov     esp, ebp
.text$mn:000011B0                 pop     ebp
.text$mn:000011B1                 retn
.text$mn:000011B1 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000011B1
.text$mn:000011B1 ; ---------------------------------------------------------------------------
.text$mn:000011B2                 align 4
.text$mn:000011B2 _text$mn        ends
.text$mn:000011B2
.text$x:000011B4 ; ===========================================================================
.text$x:000011B4
.text$x:000011B4 ; Segment type: Pure code
.text$x:000011B4 ; Segment permissions: Read/Execute
.text$x:000011B4 _text$x         segment para public 'CODE' use32
.text$x:000011B4                 assume cs:_text$x
.text$x:000011B4                 ;org 11B4h
.text$x:000011B4 ; COMDAT (pick associative to section at 1118)
.text$x:000011B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000011B4
.text$x:000011B4 ; =============== S U B R O U T I N E =======================================
.text$x:000011B4
.text$x:000011B4
.text$x:000011B4 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000011B4                                         ; DATA XREF: .xdata$x:00001A94o
.text$x:000011B4                 lea     ecx, [ebp-18h]  ; this
.text$x:000011B7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000011B7 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000011B7
.text$x:000011BC
.text$x:000011BC ; =============== S U B R O U T I N E =======================================
.text$x:000011BC
.text$x:000011BC
.text$x:000011BC __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000011BC                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000011BC
.text$x:000011BC arg_4           = dword ptr  8
.text$x:000011BC
.text$x:000011BC                 mov     edx, [esp+arg_4]
.text$x:000011C0                 lea     eax, [edx+0Ch]
.text$x:000011C3                 mov     ecx, [edx-10h]
.text$x:000011C6                 xor     ecx, eax
.text$x:000011C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000011CD                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000011D2                 jmp     ___CxxFrameHandler3
.text$x:000011D2 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000011D2
.text$x:000011D2 ; ---------------------------------------------------------------------------
.text$x:000011D7                 align 4
.text$x:000011D7 _text$x         ends
.text$x:000011D7
.text$mn:000011D8 ; ===========================================================================
.text$mn:000011D8
.text$mn:000011D8 ; Segment type: Pure code
.text$mn:000011D8 ; Segment permissions: Read/Execute
.text$mn:000011D8 _text$mn        segment para public 'CODE' use32
.text$mn:000011D8                 assume cs:_text$mn
.text$mn:000011D8                 ;org 11D8h
.text$mn:000011D8 ; COMDAT (pick any)
.text$mn:000011D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011D8
.text$mn:000011D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000011D8
.text$mn:000011D8 ; Attributes: bp-based frame
.text$mn:000011D8
.text$mn:000011D8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000011D8                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000011D8 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000011D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000011D8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000011D8
.text$mn:000011D8 var_C           = dword ptr -0Ch
.text$mn:000011D8 var_8           = dword ptr -8
.text$mn:000011D8 var_2           = byte ptr -2
.text$mn:000011D8 var_1           = byte ptr -1
.text$mn:000011D8 arg_0           = byte ptr  8
.text$mn:000011D8 Size            = dword ptr  0Ch
.text$mn:000011D8
.text$mn:000011D8                 push    ebp
.text$mn:000011D9                 mov     ebp, esp
.text$mn:000011DB                 sub     esp, 0Ch
.text$mn:000011DE                 mov     [ebp+var_8], ecx
.text$mn:000011E1                 movzx   eax, [ebp+arg_0]
.text$mn:000011E5                 test    eax, eax
.text$mn:000011E7                 jnz     short loc_11EB
.text$mn:000011E9                 jmp     short loc_125E
.text$mn:000011EB ; ---------------------------------------------------------------------------
.text$mn:000011EB
.text$mn:000011EB loc_11EB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:000011EB                 mov     ecx, [ebp+var_8]
.text$mn:000011EE                 cmp     dword ptr [ecx+18h], 10h
.text$mn:000011F2                 jb      short loc_125E
.text$mn:000011F4                 mov     edx, [ebp+var_8]
.text$mn:000011F7                 mov     eax, [edx+4]
.text$mn:000011FA                 mov     [ebp+var_C], eax
.text$mn:000011FD                 mov     ecx, [ebp+var_8]
.text$mn:00001200                 add     ecx, 4
.text$mn:00001203                 push    ecx
.text$mn:00001204                 lea     edx, [ebp+var_1]
.text$mn:00001207                 push    edx
.text$mn:00001208                 mov     ecx, [ebp+var_8]
.text$mn:0000120B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001210                 mov     ecx, eax
.text$mn:00001212                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001217                 cmp     [ebp+Size], 0
.text$mn:0000121B                 jbe     short loc_123D
.text$mn:0000121D                 mov     eax, [ebp+Size]
.text$mn:00001220                 push    eax             ; Size
.text$mn:00001221                 mov     ecx, [ebp+var_C]
.text$mn:00001224                 push    ecx
.text$mn:00001225                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000122A                 add     esp, 4
.text$mn:0000122D                 push    eax             ; Src
.text$mn:0000122E                 mov     edx, [ebp+var_8]
.text$mn:00001231                 add     edx, 4
.text$mn:00001234                 push    edx             ; Dst
.text$mn:00001235                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000123A                 add     esp, 0Ch
.text$mn:0000123D
.text$mn:0000123D loc_123D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:0000123D                 mov     eax, [ebp+var_8]
.text$mn:00001240                 mov     ecx, [eax+18h]
.text$mn:00001243                 add     ecx, 1
.text$mn:00001246                 push    ecx             ; int
.text$mn:00001247                 mov     edx, [ebp+var_C]
.text$mn:0000124A                 push    edx             ; void *
.text$mn:0000124B                 lea     eax, [ebp+var_2]
.text$mn:0000124E                 push    eax
.text$mn:0000124F                 mov     ecx, [ebp+var_8]
.text$mn:00001252                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001257                 mov     ecx, eax
.text$mn:00001259                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000125E
.text$mn:0000125E loc_125E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000125E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000125E                 mov     ecx, [ebp+var_8]
.text$mn:00001261                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00001268                 mov     edx, [ebp+Size]
.text$mn:0000126B                 push    edx
.text$mn:0000126C                 mov     ecx, [ebp+var_8]
.text$mn:0000126F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001274                 mov     esp, ebp
.text$mn:00001276                 pop     ebp
.text$mn:00001277                 retn    8
.text$mn:00001277 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00001277
.text$mn:00001277 ; ---------------------------------------------------------------------------
.text$mn:0000127A                 align 4
.text$mn:0000127A _text$mn        ends
.text$mn:0000127A
.text$mn:0000127C ; ===========================================================================
.text$mn:0000127C
.text$mn:0000127C ; Segment type: Pure code
.text$mn:0000127C ; Segment permissions: Read/Execute
.text$mn:0000127C _text$mn        segment para public 'CODE' use32
.text$mn:0000127C                 assume cs:_text$mn
.text$mn:0000127C                 ;org 127Ch
.text$mn:0000127C ; COMDAT (pick any)
.text$mn:0000127C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000127C
.text$mn:0000127C ; =============== S U B R O U T I N E =======================================
.text$mn:0000127C
.text$mn:0000127C ; Attributes: bp-based frame
.text$mn:0000127C
.text$mn:0000127C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:0000127C                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000127C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000127C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:0000127C
.text$mn:0000127C var_4           = dword ptr -4
.text$mn:0000127C
.text$mn:0000127C                 push    ebp
.text$mn:0000127D                 mov     ebp, esp
.text$mn:0000127F                 push    ecx
.text$mn:00001280                 mov     [ebp+var_4], ecx
.text$mn:00001283                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001288                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000128D                 mov     esp, ebp
.text$mn:0000128F                 pop     ebp
.text$mn:00001290                 retn
.text$mn:00001290 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001290
.text$mn:00001290 ; ---------------------------------------------------------------------------
.text$mn:00001291                 align 4
.text$mn:00001291 _text$mn        ends
.text$mn:00001291
.text$mn:00001294 ; ===========================================================================
.text$mn:00001294
.text$mn:00001294 ; Segment type: Pure code
.text$mn:00001294 ; Segment permissions: Read/Execute
.text$mn:00001294 _text$mn        segment para public 'CODE' use32
.text$mn:00001294                 assume cs:_text$mn
.text$mn:00001294                 ;org 1294h
.text$mn:00001294 ; COMDAT (pick any)
.text$mn:00001294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001294
.text$mn:00001294 ; =============== S U B R O U T I N E =======================================
.text$mn:00001294
.text$mn:00001294 ; Attributes: bp-based frame
.text$mn:00001294
.text$mn:00001294 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001294                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001294 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001294                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001294                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001294
.text$mn:00001294 var_4           = dword ptr -4
.text$mn:00001294
.text$mn:00001294                 push    ebp
.text$mn:00001295                 mov     ebp, esp
.text$mn:00001297                 push    ecx
.text$mn:00001298                 mov     [ebp+var_4], ecx
.text$mn:0000129B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000012A0                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000012A5                 mov     esp, ebp
.text$mn:000012A7                 pop     ebp
.text$mn:000012A8                 retn
.text$mn:000012A8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000012A8
.text$mn:000012A8 ; ---------------------------------------------------------------------------
.text$mn:000012A9                 align 4
.text$mn:000012A9 _text$mn        ends
.text$mn:000012A9
.text$mn:000012AC ; ===========================================================================
.text$mn:000012AC
.text$mn:000012AC ; Segment type: Pure code
.text$mn:000012AC ; Segment permissions: Read/Execute
.text$mn:000012AC _text$mn        segment para public 'CODE' use32
.text$mn:000012AC                 assume cs:_text$mn
.text$mn:000012AC                 ;org 12ACh
.text$mn:000012AC ; COMDAT (pick any)
.text$mn:000012AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012AC
.text$mn:000012AC ; =============== S U B R O U T I N E =======================================
.text$mn:000012AC
.text$mn:000012AC ; Attributes: bp-based frame
.text$mn:000012AC
.text$mn:000012AC ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000012AC                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000012AC ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000012AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000012AC                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000012AC
.text$mn:000012AC var_4           = dword ptr -4
.text$mn:000012AC arg_0           = dword ptr  8
.text$mn:000012AC
.text$mn:000012AC                 push    ebp
.text$mn:000012AD                 mov     ebp, esp
.text$mn:000012AF                 push    ecx
.text$mn:000012B0                 mov     [ebp+var_4], ecx
.text$mn:000012B3                 mov     eax, [ebp+arg_0]
.text$mn:000012B6                 push    eax
.text$mn:000012B7                 mov     ecx, [ebp+var_4]
.text$mn:000012BA                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000012BF                 mov     esp, ebp
.text$mn:000012C1                 pop     ebp
.text$mn:000012C2                 retn    4
.text$mn:000012C2 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000012C2
.text$mn:000012C2 ; ---------------------------------------------------------------------------
.text$mn:000012C5                 align 4
.text$mn:000012C5 _text$mn        ends
.text$mn:000012C5
.text$mn:000012C8 ; ===========================================================================
.text$mn:000012C8
.text$mn:000012C8 ; Segment type: Pure code
.text$mn:000012C8 ; Segment permissions: Read/Execute
.text$mn:000012C8 _text$mn        segment para public 'CODE' use32
.text$mn:000012C8                 assume cs:_text$mn
.text$mn:000012C8                 ;org 12C8h
.text$mn:000012C8 ; COMDAT (pick any)
.text$mn:000012C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012C8
.text$mn:000012C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000012C8
.text$mn:000012C8 ; Attributes: bp-based frame
.text$mn:000012C8
.text$mn:000012C8 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000012C8                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000012C8 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000012C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000012C8
.text$mn:000012C8 var_4           = dword ptr -4
.text$mn:000012C8 arg_0           = dword ptr  8
.text$mn:000012C8
.text$mn:000012C8                 push    ebp
.text$mn:000012C9                 mov     ebp, esp
.text$mn:000012CB                 push    ecx
.text$mn:000012CC                 mov     [ebp+var_4], ecx
.text$mn:000012CF                 push    0
.text$mn:000012D1                 mov     eax, [ebp+arg_0]
.text$mn:000012D4                 push    eax
.text$mn:000012D5                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000012DA                 add     esp, 8
.text$mn:000012DD                 mov     esp, ebp
.text$mn:000012DF                 pop     ebp
.text$mn:000012E0                 retn    4
.text$mn:000012E0 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000012E0
.text$mn:000012E0 ; ---------------------------------------------------------------------------
.text$mn:000012E3                 align 4
.text$mn:000012E3 _text$mn        ends
.text$mn:000012E3
.text$mn:000012E4 ; ===========================================================================
.text$mn:000012E4
.text$mn:000012E4 ; Segment type: Pure code
.text$mn:000012E4 ; Segment permissions: Read/Execute
.text$mn:000012E4 _text$mn        segment para public 'CODE' use32
.text$mn:000012E4                 assume cs:_text$mn
.text$mn:000012E4                 ;org 12E4h
.text$mn:000012E4 ; COMDAT (pick any)
.text$mn:000012E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012E4
.text$mn:000012E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000012E4
.text$mn:000012E4 ; Attributes: bp-based frame
.text$mn:000012E4
.text$mn:000012E4 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000012E4                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000012E4 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000012E4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000012E4
.text$mn:000012E4 var_4           = dword ptr -4
.text$mn:000012E4 arg_0           = dword ptr  8
.text$mn:000012E4
.text$mn:000012E4                 push    ebp
.text$mn:000012E5                 mov     ebp, esp
.text$mn:000012E7                 push    ecx
.text$mn:000012E8                 mov     [ebp+var_4], ecx
.text$mn:000012EB                 push    0
.text$mn:000012ED                 mov     eax, [ebp+arg_0]
.text$mn:000012F0                 push    eax
.text$mn:000012F1                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:000012F6                 add     esp, 8
.text$mn:000012F9                 mov     esp, ebp
.text$mn:000012FB                 pop     ebp
.text$mn:000012FC                 retn    4
.text$mn:000012FC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000012FC
.text$mn:000012FC ; ---------------------------------------------------------------------------
.text$mn:000012FF                 align 10h
.text$mn:000012FF _text$mn        ends
.text$mn:000012FF
.text$mn:00001300 ; ===========================================================================
.text$mn:00001300
.text$mn:00001300 ; Segment type: Pure code
.text$mn:00001300 ; Segment permissions: Read/Execute
.text$mn:00001300 _text$mn        segment para public 'CODE' use32
.text$mn:00001300                 assume cs:_text$mn
.text$mn:00001300                 ;org 1300h
.text$mn:00001300 ; COMDAT (pick any)
.text$mn:00001300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001300
.text$mn:00001300 ; =============== S U B R O U T I N E =======================================
.text$mn:00001300
.text$mn:00001300 ; Attributes: bp-based frame
.text$mn:00001300
.text$mn:00001300 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001300                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001300 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001300                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001300
.text$mn:00001300 Size            = dword ptr -8
.text$mn:00001300 var_4           = dword ptr -4
.text$mn:00001300 arg_0           = dword ptr  8
.text$mn:00001300 arg_4           = dword ptr  0Ch
.text$mn:00001300 arg_8           = dword ptr  10h
.text$mn:00001300
.text$mn:00001300                 push    ebp
.text$mn:00001301                 mov     ebp, esp
.text$mn:00001303                 sub     esp, 8
.text$mn:00001306                 mov     [ebp+var_4], ecx
.text$mn:00001309                 mov     ecx, [ebp+arg_0]
.text$mn:0000130C                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001311                 cmp     eax, [ebp+arg_4]
.text$mn:00001314                 jnb     short loc_131E
.text$mn:00001316                 mov     ecx, [ebp+var_4]
.text$mn:00001319                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000131E
.text$mn:0000131E loc_131E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000131E                 mov     ecx, [ebp+arg_0]
.text$mn:00001321                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001326                 sub     eax, [ebp+arg_4]
.text$mn:00001329                 mov     [ebp+Size], eax
.text$mn:0000132C                 mov     eax, [ebp+arg_8]
.text$mn:0000132F                 cmp     eax, [ebp+Size]
.text$mn:00001332                 jnb     short loc_133A
.text$mn:00001334                 mov     ecx, [ebp+arg_8]
.text$mn:00001337                 mov     [ebp+Size], ecx
.text$mn:0000133A
.text$mn:0000133A loc_133A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000133A                 mov     edx, [ebp+var_4]
.text$mn:0000133D                 cmp     edx, [ebp+arg_0]
.text$mn:00001340                 jnz     short loc_1361
.text$mn:00001342                 mov     eax, [ebp+arg_4]
.text$mn:00001345                 add     eax, [ebp+Size]
.text$mn:00001348                 push    eax
.text$mn:00001349                 mov     ecx, [ebp+var_4]
.text$mn:0000134C                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00001351                 mov     ecx, [ebp+arg_4]
.text$mn:00001354                 push    ecx
.text$mn:00001355                 push    0
.text$mn:00001357                 mov     ecx, [ebp+var_4]
.text$mn:0000135A                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000135F                 jmp     short loc_13A3
.text$mn:00001361 ; ---------------------------------------------------------------------------
.text$mn:00001361
.text$mn:00001361 loc_1361:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00001361                 push    0
.text$mn:00001363                 mov     edx, [ebp+Size]
.text$mn:00001366                 push    edx
.text$mn:00001367                 mov     ecx, [ebp+var_4]
.text$mn:0000136A                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000136F                 movzx   eax, al
.text$mn:00001372                 test    eax, eax
.text$mn:00001374                 jz      short loc_13A3
.text$mn:00001376                 mov     ecx, [ebp+Size]
.text$mn:00001379                 push    ecx             ; Size
.text$mn:0000137A                 mov     ecx, [ebp+arg_0]
.text$mn:0000137D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001382                 add     eax, [ebp+arg_4]
.text$mn:00001385                 push    eax             ; Src
.text$mn:00001386                 mov     ecx, [ebp+var_4]
.text$mn:00001389                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000138E                 push    eax             ; Dst
.text$mn:0000138F                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001394                 add     esp, 0Ch
.text$mn:00001397                 mov     edx, [ebp+Size]
.text$mn:0000139A                 push    edx
.text$mn:0000139B                 mov     ecx, [ebp+var_4]
.text$mn:0000139E                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000013A3
.text$mn:000013A3 loc_13A3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000013A3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000013A3                 mov     eax, [ebp+var_4]
.text$mn:000013A6                 mov     esp, ebp
.text$mn:000013A8                 pop     ebp
.text$mn:000013A9                 retn    0Ch
.text$mn:000013A9 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000013A9
.text$mn:000013A9 _text$mn        ends
.text$mn:000013A9
.text$mn:000013AC ; ===========================================================================
.text$mn:000013AC
.text$mn:000013AC ; Segment type: Pure code
.text$mn:000013AC ; Segment permissions: Read/Execute
.text$mn:000013AC _text$mn        segment para public 'CODE' use32
.text$mn:000013AC                 assume cs:_text$mn
.text$mn:000013AC                 ;org 13ACh
.text$mn:000013AC ; COMDAT (pick any)
.text$mn:000013AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013AC
.text$mn:000013AC ; =============== S U B R O U T I N E =======================================
.text$mn:000013AC
.text$mn:000013AC ; Attributes: bp-based frame
.text$mn:000013AC
.text$mn:000013AC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000013AC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000013AC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000013AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000013AC
.text$mn:000013AC var_4           = dword ptr -4
.text$mn:000013AC Str             = dword ptr  8
.text$mn:000013AC
.text$mn:000013AC                 push    ebp
.text$mn:000013AD                 mov     ebp, esp
.text$mn:000013AF                 push    ecx
.text$mn:000013B0                 mov     [ebp+var_4], ecx
.text$mn:000013B3                 push    490h            ; unsigned int
.text$mn:000013B8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000013BD                 mov     eax, [ebp+Str]
.text$mn:000013C0                 push    eax             ; int
.text$mn:000013C1                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000013C6                 add     esp, 0Ch
.text$mn:000013C9                 mov     ecx, [ebp+Str]
.text$mn:000013CC                 push    ecx             ; Str
.text$mn:000013CD                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000013D2                 add     esp, 4
.text$mn:000013D5                 push    eax             ; Size
.text$mn:000013D6                 mov     edx, [ebp+Str]
.text$mn:000013D9                 push    edx             ; Src
.text$mn:000013DA                 mov     ecx, [ebp+var_4]
.text$mn:000013DD                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:000013E2                 mov     esp, ebp
.text$mn:000013E4                 pop     ebp
.text$mn:000013E5                 retn    4
.text$mn:000013E5 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000013E5
.text$mn:000013E5 _text$mn        ends
.text$mn:000013E5
.text$mn:000013E8 ; ===========================================================================
.text$mn:000013E8
.text$mn:000013E8 ; Segment type: Pure code
.text$mn:000013E8 ; Segment permissions: Read/Execute
.text$mn:000013E8 _text$mn        segment para public 'CODE' use32
.text$mn:000013E8                 assume cs:_text$mn
.text$mn:000013E8                 ;org 13E8h
.text$mn:000013E8 ; COMDAT (pick any)
.text$mn:000013E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013E8
.text$mn:000013E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013E8
.text$mn:000013E8 ; Attributes: bp-based frame
.text$mn:000013E8
.text$mn:000013E8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:000013E8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:000013E8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:000013E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:000013E8
.text$mn:000013E8 var_4           = dword ptr -4
.text$mn:000013E8 Src             = dword ptr  8
.text$mn:000013E8 Size            = dword ptr  0Ch
.text$mn:000013E8
.text$mn:000013E8                 push    ebp
.text$mn:000013E9                 mov     ebp, esp
.text$mn:000013EB                 push    ecx
.text$mn:000013EC                 mov     [ebp+var_4], ecx
.text$mn:000013EF                 cmp     [ebp+Size], 0
.text$mn:000013F3                 jz      short loc_140B
.text$mn:000013F5                 push    47Fh            ; unsigned int
.text$mn:000013FA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000013FF                 mov     eax, [ebp+Src]
.text$mn:00001402                 push    eax             ; int
.text$mn:00001403                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001408                 add     esp, 0Ch
.text$mn:0000140B
.text$mn:0000140B loc_140B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000140B                 mov     ecx, [ebp+Src]
.text$mn:0000140E                 push    ecx
.text$mn:0000140F                 mov     ecx, [ebp+var_4]
.text$mn:00001412                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001417                 movzx   edx, al
.text$mn:0000141A                 test    edx, edx
.text$mn:0000141C                 jz      short loc_143E
.text$mn:0000141E                 mov     eax, [ebp+Size]
.text$mn:00001421                 push    eax
.text$mn:00001422                 mov     ecx, [ebp+var_4]
.text$mn:00001425                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000142A                 mov     ecx, [ebp+Src]
.text$mn:0000142D                 sub     ecx, eax
.text$mn:0000142F                 push    ecx
.text$mn:00001430                 mov     edx, [ebp+var_4]
.text$mn:00001433                 push    edx
.text$mn:00001434                 mov     ecx, [ebp+var_4]
.text$mn:00001437                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:0000143C                 jmp     short loc_147B
.text$mn:0000143E ; ---------------------------------------------------------------------------
.text$mn:0000143E
.text$mn:0000143E loc_143E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000143E                 push    0
.text$mn:00001440                 mov     eax, [ebp+Size]
.text$mn:00001443                 push    eax
.text$mn:00001444                 mov     ecx, [ebp+var_4]
.text$mn:00001447                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000144C                 movzx   ecx, al
.text$mn:0000144F                 test    ecx, ecx
.text$mn:00001451                 jz      short loc_1478
.text$mn:00001453                 mov     edx, [ebp+Size]
.text$mn:00001456                 push    edx             ; Size
.text$mn:00001457                 mov     eax, [ebp+Src]
.text$mn:0000145A                 push    eax             ; Src
.text$mn:0000145B                 mov     ecx, [ebp+var_4]
.text$mn:0000145E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001463                 push    eax             ; Dst
.text$mn:00001464                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001469                 add     esp, 0Ch
.text$mn:0000146C                 mov     ecx, [ebp+Size]
.text$mn:0000146F                 push    ecx
.text$mn:00001470                 mov     ecx, [ebp+var_4]
.text$mn:00001473                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001478
.text$mn:00001478 loc_1478:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00001478                 mov     eax, [ebp+var_4]
.text$mn:0000147B
.text$mn:0000147B loc_147B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000147B                 mov     esp, ebp
.text$mn:0000147D                 pop     ebp
.text$mn:0000147E                 retn    8
.text$mn:0000147E ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000147E
.text$mn:0000147E ; ---------------------------------------------------------------------------
.text$mn:00001481                 align 4
.text$mn:00001481 _text$mn        ends
.text$mn:00001481
.text$mn:00001484 ; ===========================================================================
.text$mn:00001484
.text$mn:00001484 ; Segment type: Pure code
.text$mn:00001484 ; Segment permissions: Read/Execute
.text$mn:00001484 _text$mn        segment para public 'CODE' use32
.text$mn:00001484                 assume cs:_text$mn
.text$mn:00001484                 ;org 1484h
.text$mn:00001484 ; COMDAT (pick any)
.text$mn:00001484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001484
.text$mn:00001484 ; =============== S U B R O U T I N E =======================================
.text$mn:00001484
.text$mn:00001484 ; Attributes: bp-based frame
.text$mn:00001484
.text$mn:00001484 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00001484                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00001484 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00001484                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00001484
.text$mn:00001484 arg_0           = dword ptr  8
.text$mn:00001484 arg_4           = dword ptr  0Ch
.text$mn:00001484
.text$mn:00001484                 push    ebp
.text$mn:00001485                 mov     ebp, esp
.text$mn:00001487                 mov     eax, [ebp+arg_0]
.text$mn:0000148A                 mov     ecx, [ebp+arg_4]
.text$mn:0000148D                 mov     dl, [ecx]
.text$mn:0000148F                 mov     [eax], dl
.text$mn:00001491                 pop     ebp
.text$mn:00001492                 retn
.text$mn:00001492 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00001492
.text$mn:00001492 ; ---------------------------------------------------------------------------
.text$mn:00001493                 align 4
.text$mn:00001493 _text$mn        ends
.text$mn:00001493
.text$mn:00001494 ; ===========================================================================
.text$mn:00001494
.text$mn:00001494 ; Segment type: Pure code
.text$mn:00001494 ; Segment permissions: Read/Execute
.text$mn:00001494 _text$mn        segment para public 'CODE' use32
.text$mn:00001494                 assume cs:_text$mn
.text$mn:00001494                 ;org 1494h
.text$mn:00001494 ; COMDAT (pick any)
.text$mn:00001494                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001494
.text$mn:00001494 ; =============== S U B R O U T I N E =======================================
.text$mn:00001494
.text$mn:00001494 ; Attributes: bp-based frame
.text$mn:00001494
.text$mn:00001494 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00001494                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00001494 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001494                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00001494
.text$mn:00001494 var_4           = dword ptr -4
.text$mn:00001494
.text$mn:00001494                 push    ebp
.text$mn:00001495                 mov     ebp, esp
.text$mn:00001497                 push    ecx
.text$mn:00001498                 mov     [ebp+var_4], ecx
.text$mn:0000149B                 mov     eax, [ebp+var_4]
.text$mn:0000149E                 mov     eax, [eax+4]
.text$mn:000014A1                 mov     esp, ebp
.text$mn:000014A3                 pop     ebp
.text$mn:000014A4                 retn
.text$mn:000014A4 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000014A4
.text$mn:000014A4 ; ---------------------------------------------------------------------------
.text$mn:000014A5                 align 4
.text$mn:000014A5 _text$mn        ends
.text$mn:000014A5
.text$mn:000014A8 ; ===========================================================================
.text$mn:000014A8
.text$mn:000014A8 ; Segment type: Pure code
.text$mn:000014A8 ; Segment permissions: Read/Execute
.text$mn:000014A8 _text$mn        segment para public 'CODE' use32
.text$mn:000014A8                 assume cs:_text$mn
.text$mn:000014A8                 ;org 14A8h
.text$mn:000014A8 ; COMDAT (pick any)
.text$mn:000014A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014A8
.text$mn:000014A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014A8
.text$mn:000014A8 ; Attributes: bp-based frame
.text$mn:000014A8
.text$mn:000014A8 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000014A8                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000014A8 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000014A8                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000014A8                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000014A8
.text$mn:000014A8 var_4           = dword ptr -4
.text$mn:000014A8
.text$mn:000014A8                 push    ebp
.text$mn:000014A9                 mov     ebp, esp
.text$mn:000014AB                 push    ecx
.text$mn:000014AC                 mov     [ebp+var_4], ecx
.text$mn:000014AF                 mov     eax, [ebp+var_4]
.text$mn:000014B2                 mov     eax, [eax+4]
.text$mn:000014B5                 mov     esp, ebp
.text$mn:000014B7                 pop     ebp
.text$mn:000014B8                 retn
.text$mn:000014B8 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000014B8
.text$mn:000014B8 ; ---------------------------------------------------------------------------
.text$mn:000014B9                 align 4
.text$mn:000014B9 _text$mn        ends
.text$mn:000014B9
.text$mn:000014BC ; ===========================================================================
.text$mn:000014BC
.text$mn:000014BC ; Segment type: Pure code
.text$mn:000014BC ; Segment permissions: Read/Execute
.text$mn:000014BC _text$mn        segment para public 'CODE' use32
.text$mn:000014BC                 assume cs:_text$mn
.text$mn:000014BC                 ;org 14BCh
.text$mn:000014BC ; COMDAT (pick any)
.text$mn:000014BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014BC
.text$mn:000014BC ; =============== S U B R O U T I N E =======================================
.text$mn:000014BC
.text$mn:000014BC ; Attributes: bp-based frame
.text$mn:000014BC
.text$mn:000014BC ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000014BC                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000014BC ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000014BC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000014BC
.text$mn:000014BC var_4           = dword ptr -4
.text$mn:000014BC Dst             = dword ptr  8
.text$mn:000014BC Src             = dword ptr  0Ch
.text$mn:000014BC Size            = dword ptr  10h
.text$mn:000014BC
.text$mn:000014BC                 push    ebp
.text$mn:000014BD                 mov     ebp, esp
.text$mn:000014BF                 push    ecx
.text$mn:000014C0                 cmp     [ebp+Size], 0
.text$mn:000014C4                 jnz     short loc_14CE
.text$mn:000014C6                 mov     eax, [ebp+Dst]
.text$mn:000014C9                 mov     [ebp+var_4], eax
.text$mn:000014CC                 jmp     short loc_14E5
.text$mn:000014CE ; ---------------------------------------------------------------------------
.text$mn:000014CE
.text$mn:000014CE loc_14CE:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000014CE                 mov     ecx, [ebp+Size]
.text$mn:000014D1                 push    ecx             ; Size
.text$mn:000014D2                 mov     edx, [ebp+Src]
.text$mn:000014D5                 push    edx             ; Src
.text$mn:000014D6                 mov     eax, [ebp+Dst]
.text$mn:000014D9                 push    eax             ; Dst
.text$mn:000014DA                 call    _memcpy
.text$mn:000014DF                 add     esp, 0Ch
.text$mn:000014E2                 mov     [ebp+var_4], eax
.text$mn:000014E5
.text$mn:000014E5 loc_14E5:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:000014E5                 mov     eax, [ebp+var_4]
.text$mn:000014E8                 mov     esp, ebp
.text$mn:000014EA                 pop     ebp
.text$mn:000014EB                 retn
.text$mn:000014EB ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000014EB
.text$mn:000014EB _text$mn        ends
.text$mn:000014EB
.text$mn:000014EC ; ===========================================================================
.text$mn:000014EC
.text$mn:000014EC ; Segment type: Pure code
.text$mn:000014EC ; Segment permissions: Read/Execute
.text$mn:000014EC _text$mn        segment para public 'CODE' use32
.text$mn:000014EC                 assume cs:_text$mn
.text$mn:000014EC                 ;org 14ECh
.text$mn:000014EC ; COMDAT (pick any)
.text$mn:000014EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014EC
.text$mn:000014EC ; =============== S U B R O U T I N E =======================================
.text$mn:000014EC
.text$mn:000014EC ; Attributes: bp-based frame
.text$mn:000014EC
.text$mn:000014EC ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:000014EC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:000014EC ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:000014EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:000014EC
.text$mn:000014EC var_4           = dword ptr -4
.text$mn:000014EC arg_0           = dword ptr  8
.text$mn:000014EC arg_4           = dword ptr  0Ch
.text$mn:000014EC
.text$mn:000014EC                 push    ebp
.text$mn:000014ED                 mov     ebp, esp
.text$mn:000014EF                 push    ecx
.text$mn:000014F0                 mov     [ebp+var_4], ecx
.text$mn:000014F3                 mov     eax, [ebp+arg_4]
.text$mn:000014F6                 push    eax             ; int
.text$mn:000014F7                 mov     ecx, [ebp+arg_0]
.text$mn:000014FA                 push    ecx             ; void *
.text$mn:000014FB                 mov     ecx, [ebp+var_4]
.text$mn:000014FE                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00001503                 mov     esp, ebp
.text$mn:00001505                 pop     ebp
.text$mn:00001506                 retn    8
.text$mn:00001506 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00001506
.text$mn:00001506 ; ---------------------------------------------------------------------------
.text$mn:00001509                 align 4
.text$mn:00001509 _text$mn        ends
.text$mn:00001509
.text$mn:0000150C ; ===========================================================================
.text$mn:0000150C
.text$mn:0000150C ; Segment type: Pure code
.text$mn:0000150C ; Segment permissions: Read/Execute
.text$mn:0000150C _text$mn        segment para public 'CODE' use32
.text$mn:0000150C                 assume cs:_text$mn
.text$mn:0000150C                 ;org 150Ch
.text$mn:0000150C ; COMDAT (pick any)
.text$mn:0000150C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000150C
.text$mn:0000150C ; =============== S U B R O U T I N E =======================================
.text$mn:0000150C
.text$mn:0000150C ; Attributes: bp-based frame
.text$mn:0000150C
.text$mn:0000150C ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:0000150C                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:0000150C ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:0000150C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:0000150C
.text$mn:0000150C var_4           = dword ptr -4
.text$mn:0000150C arg_0           = dword ptr  8
.text$mn:0000150C
.text$mn:0000150C                 push    ebp
.text$mn:0000150D                 mov     ebp, esp
.text$mn:0000150F                 push    ecx
.text$mn:00001510                 mov     [ebp+var_4], ecx
.text$mn:00001513                 mov     eax, [ebp+arg_0]
.text$mn:00001516                 push    eax             ; void *
.text$mn:00001517                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000151C                 add     esp, 4
.text$mn:0000151F                 mov     esp, ebp
.text$mn:00001521                 pop     ebp
.text$mn:00001522                 retn    8
.text$mn:00001522 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00001522
.text$mn:00001522 ; ---------------------------------------------------------------------------
.text$mn:00001525                 align 4
.text$mn:00001525 _text$mn        ends
.text$mn:00001525
.text$mn:00001528 ; ===========================================================================
.text$mn:00001528
.text$mn:00001528 ; Segment type: Pure code
.text$mn:00001528 ; Segment permissions: Read/Execute
.text$mn:00001528 _text$mn        segment para public 'CODE' use32
.text$mn:00001528                 assume cs:_text$mn
.text$mn:00001528                 ;org 1528h
.text$mn:00001528 ; COMDAT (pick any)
.text$mn:00001528                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001528
.text$mn:00001528 ; =============== S U B R O U T I N E =======================================
.text$mn:00001528
.text$mn:00001528 ; Attributes: bp-based frame
.text$mn:00001528
.text$mn:00001528 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00001528                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00001528 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00001528                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00001528
.text$mn:00001528 var_4           = dword ptr -4
.text$mn:00001528 arg_0           = dword ptr  8
.text$mn:00001528
.text$mn:00001528                 push    ebp
.text$mn:00001529                 mov     ebp, esp
.text$mn:0000152B                 push    ecx
.text$mn:0000152C                 mov     [ebp+var_4], ecx
.text$mn:0000152F                 mov     eax, [ebp+arg_0]
.text$mn:00001532                 push    eax             ; void *
.text$mn:00001533                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001538                 add     esp, 4
.text$mn:0000153B                 mov     esp, ebp
.text$mn:0000153D                 pop     ebp
.text$mn:0000153E                 retn    8
.text$mn:0000153E ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000153E
.text$mn:0000153E ; ---------------------------------------------------------------------------
.text$mn:00001541                 align 4
.text$mn:00001541 _text$mn        ends
.text$mn:00001541
.text$mn:00001544 ; ===========================================================================
.text$mn:00001544
.text$mn:00001544 ; Segment type: Pure code
.text$mn:00001544 ; Segment permissions: Read/Execute
.text$mn:00001544 _text$mn        segment para public 'CODE' use32
.text$mn:00001544                 assume cs:_text$mn
.text$mn:00001544                 ;org 1544h
.text$mn:00001544 ; COMDAT (pick any)
.text$mn:00001544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001544
.text$mn:00001544 ; =============== S U B R O U T I N E =======================================
.text$mn:00001544
.text$mn:00001544 ; Attributes: bp-based frame
.text$mn:00001544
.text$mn:00001544 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00001544                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001544 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001544                                         ; DATA XREF: .rdata:00001ED8o
.text$mn:00001544
.text$mn:00001544 var_4           = dword ptr -4
.text$mn:00001544 arg_0           = dword ptr  8
.text$mn:00001544 arg_4           = dword ptr  0Ch
.text$mn:00001544
.text$mn:00001544                 push    ebp
.text$mn:00001545                 mov     ebp, esp
.text$mn:00001547                 push    ecx
.text$mn:00001548                 mov     [ebp+var_4], ecx
.text$mn:0000154B                 mov     eax, [ebp+arg_4]
.text$mn:0000154E                 push    eax             ; int
.text$mn:0000154F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001554                 add     esp, 4
.text$mn:00001557                 test    eax, eax
.text$mn:00001559                 jz      short loc_1574
.text$mn:0000155B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00001560                 push    eax             ; struct std::error_category *
.text$mn:00001561                 mov     ecx, [ebp+arg_4]
.text$mn:00001564                 push    ecx             ; int
.text$mn:00001565                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001568                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000156D                 mov     eax, [ebp+arg_0]
.text$mn:00001570                 jmp     short loc_1589
.text$mn:00001572 ; ---------------------------------------------------------------------------
.text$mn:00001572                 jmp     short loc_1589
.text$mn:00001574 ; ---------------------------------------------------------------------------
.text$mn:00001574
.text$mn:00001574 loc_1574:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00001574                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00001579                 push    eax             ; struct std::error_category *
.text$mn:0000157A                 mov     edx, [ebp+arg_4]
.text$mn:0000157D                 push    edx             ; int
.text$mn:0000157E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001581                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001586                 mov     eax, [ebp+arg_0]
.text$mn:00001589
.text$mn:00001589 loc_1589:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00001589                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00001589                 mov     esp, ebp
.text$mn:0000158B                 pop     ebp
.text$mn:0000158C                 retn    8
.text$mn:0000158C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000158C
.text$mn:0000158C ; ---------------------------------------------------------------------------
.text$mn:0000158F                 align 10h
.text$mn:0000158F _text$mn        ends
.text$mn:0000158F
.text$mn:00001590 ; ===========================================================================
.text$mn:00001590
.text$mn:00001590 ; Segment type: Pure code
.text$mn:00001590 ; Segment permissions: Read/Execute
.text$mn:00001590 _text$mn        segment para public 'CODE' use32
.text$mn:00001590                 assume cs:_text$mn
.text$mn:00001590                 ;org 1590h
.text$mn:00001590 ; COMDAT (pick any)
.text$mn:00001590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001590
.text$mn:00001590 ; =============== S U B R O U T I N E =======================================
.text$mn:00001590
.text$mn:00001590 ; Attributes: bp-based frame
.text$mn:00001590
.text$mn:00001590 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00001590                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001590 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001590                                         ; DATA XREF: .rdata:00001E48o
.text$mn:00001590                                         ; .rdata:00001E64o ...
.text$mn:00001590
.text$mn:00001590 var_4           = dword ptr -4
.text$mn:00001590 arg_0           = dword ptr  8
.text$mn:00001590 arg_4           = dword ptr  0Ch
.text$mn:00001590
.text$mn:00001590                 push    ebp
.text$mn:00001591                 mov     ebp, esp
.text$mn:00001593                 push    ecx
.text$mn:00001594                 mov     [ebp+var_4], ecx
.text$mn:00001597                 mov     eax, [ebp+var_4]
.text$mn:0000159A                 push    eax             ; struct std::error_category *
.text$mn:0000159B                 mov     ecx, [ebp+arg_4]
.text$mn:0000159E                 push    ecx             ; int
.text$mn:0000159F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000015A2                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000015A7                 mov     eax, [ebp+arg_0]
.text$mn:000015AA                 mov     esp, ebp
.text$mn:000015AC                 pop     ebp
.text$mn:000015AD                 retn    8
.text$mn:000015AD ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000015AD
.text$mn:000015AD _text$mn        ends
.text$mn:000015AD
.text$mn:000015B0 ; ===========================================================================
.text$mn:000015B0
.text$mn:000015B0 ; Segment type: Pure code
.text$mn:000015B0 ; Segment permissions: Read/Execute
.text$mn:000015B0 _text$mn        segment para public 'CODE' use32
.text$mn:000015B0                 assume cs:_text$mn
.text$mn:000015B0                 ;org 15B0h
.text$mn:000015B0 ; COMDAT (pick any)
.text$mn:000015B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015B0
.text$mn:000015B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000015B0
.text$mn:000015B0 ; Attributes: bp-based frame
.text$mn:000015B0
.text$mn:000015B0 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000015B0                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000015B0 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000015B0                                         ; DATA XREF: .rdata:00001E4Co
.text$mn:000015B0                                         ; .rdata:00001E68o ...
.text$mn:000015B0
.text$mn:000015B0 var_8           = dword ptr -8
.text$mn:000015B0 var_4           = dword ptr -4
.text$mn:000015B0 arg_0           = dword ptr  8
.text$mn:000015B0 arg_4           = dword ptr  0Ch
.text$mn:000015B0
.text$mn:000015B0                 push    ebp
.text$mn:000015B1                 mov     ebp, esp
.text$mn:000015B3                 sub     esp, 8
.text$mn:000015B6                 mov     [ebp+var_8], ecx
.text$mn:000015B9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000015BC                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:000015C1                 push    eax
.text$mn:000015C2                 mov     ecx, [ebp+var_8]
.text$mn:000015C5                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000015CA                 movzx   eax, al
.text$mn:000015CD                 test    eax, eax
.text$mn:000015CF                 jz      short loc_15E7
.text$mn:000015D1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000015D4                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:000015D9                 cmp     eax, [ebp+arg_4]
.text$mn:000015DC                 jnz     short loc_15E7
.text$mn:000015DE                 mov     [ebp+var_4], 1
.text$mn:000015E5                 jmp     short loc_15EE
.text$mn:000015E7 ; ---------------------------------------------------------------------------
.text$mn:000015E7
.text$mn:000015E7 loc_15E7:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000015E7                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000015E7                 mov     [ebp+var_4], 0
.text$mn:000015EE
.text$mn:000015EE loc_15EE:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000015EE                 mov     al, byte ptr [ebp+var_4]
.text$mn:000015F1                 mov     esp, ebp
.text$mn:000015F3                 pop     ebp
.text$mn:000015F4                 retn    8
.text$mn:000015F4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000015F4
.text$mn:000015F4 ; ---------------------------------------------------------------------------
.text$mn:000015F7                 align 4
.text$mn:000015F7 _text$mn        ends
.text$mn:000015F7
.text$mn:000015F8 ; ===========================================================================
.text$mn:000015F8
.text$mn:000015F8 ; Segment type: Pure code
.text$mn:000015F8 ; Segment permissions: Read/Execute
.text$mn:000015F8 _text$mn        segment para public 'CODE' use32
.text$mn:000015F8                 assume cs:_text$mn
.text$mn:000015F8                 ;org 15F8h
.text$mn:000015F8 ; COMDAT (pick any)
.text$mn:000015F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015F8
.text$mn:000015F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015F8
.text$mn:000015F8 ; Attributes: bp-based frame
.text$mn:000015F8
.text$mn:000015F8 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000015F8                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000015F8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000015F8                                         ; DATA XREF: .rdata:00001E50o
.text$mn:000015F8                                         ; .rdata:00001E6Co ...
.text$mn:000015F8
.text$mn:000015F8 var_C           = byte ptr -0Ch
.text$mn:000015F8 var_4           = dword ptr -4
.text$mn:000015F8 arg_0           = dword ptr  8
.text$mn:000015F8 arg_4           = dword ptr  0Ch
.text$mn:000015F8
.text$mn:000015F8                 push    ebp
.text$mn:000015F9                 mov     ebp, esp
.text$mn:000015FB                 sub     esp, 0Ch
.text$mn:000015FE                 mov     [ebp+var_4], ecx
.text$mn:00001601                 mov     eax, [ebp+arg_4]
.text$mn:00001604                 push    eax             ; std::error_condition *
.text$mn:00001605                 mov     ecx, [ebp+arg_0]
.text$mn:00001608                 push    ecx
.text$mn:00001609                 lea     edx, [ebp+var_C]
.text$mn:0000160C                 push    edx
.text$mn:0000160D                 mov     eax, [ebp+var_4]
.text$mn:00001610                 mov     edx, [eax]
.text$mn:00001612                 mov     ecx, [ebp+var_4]
.text$mn:00001615                 mov     eax, [edx+0Ch]
.text$mn:00001618                 call    eax
.text$mn:0000161A                 mov     ecx, eax
.text$mn:0000161C                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00001621                 mov     esp, ebp
.text$mn:00001623                 pop     ebp
.text$mn:00001624                 retn    8
.text$mn:00001624 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00001624
.text$mn:00001624 ; ---------------------------------------------------------------------------
.text$mn:00001627                 align 4
.text$mn:00001627 _text$mn        ends
.text$mn:00001627
.text$mn:00001628 ; ===========================================================================
.text$mn:00001628
.text$mn:00001628 ; Segment type: Pure code
.text$mn:00001628 ; Segment permissions: Read/Execute
.text$mn:00001628 _text$mn        segment para public 'CODE' use32
.text$mn:00001628                 assume cs:_text$mn
.text$mn:00001628                 ;org 1628h
.text$mn:00001628 ; COMDAT (pick any)
.text$mn:00001628                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001628
.text$mn:00001628 ; =============== S U B R O U T I N E =======================================
.text$mn:00001628
.text$mn:00001628 ; Attributes: bp-based frame
.text$mn:00001628
.text$mn:00001628 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00001628                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00001628 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00001628                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00001628
.text$mn:00001628 var_4           = dword ptr -4
.text$mn:00001628 arg_0           = dword ptr  8
.text$mn:00001628
.text$mn:00001628                 push    ebp
.text$mn:00001629                 mov     ebp, esp
.text$mn:0000162B                 push    ecx
.text$mn:0000162C                 mov     [ebp+var_4], ecx
.text$mn:0000162F                 mov     eax, [ebp+var_4]
.text$mn:00001632                 mov     ecx, [eax+14h]
.text$mn:00001635                 cmp     ecx, [ebp+arg_0]
.text$mn:00001638                 jnb     short loc_1642
.text$mn:0000163A                 mov     ecx, [ebp+var_4]
.text$mn:0000163D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001642
.text$mn:00001642 loc_1642:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00001642                 mov     edx, [ebp+arg_0]
.text$mn:00001645                 push    edx
.text$mn:00001646                 mov     ecx, [ebp+var_4]
.text$mn:00001649                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000164E                 mov     eax, [ebp+var_4]
.text$mn:00001651                 mov     esp, ebp
.text$mn:00001653                 pop     ebp
.text$mn:00001654                 retn    4
.text$mn:00001654 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00001654
.text$mn:00001654 ; ---------------------------------------------------------------------------
.text$mn:00001657                 align 4
.text$mn:00001657 _text$mn        ends
.text$mn:00001657
.text$mn:00001658 ; ===========================================================================
.text$mn:00001658
.text$mn:00001658 ; Segment type: Pure code
.text$mn:00001658 ; Segment permissions: Read/Execute
.text$mn:00001658 _text$mn        segment para public 'CODE' use32
.text$mn:00001658                 assume cs:_text$mn
.text$mn:00001658                 ;org 1658h
.text$mn:00001658 ; COMDAT (pick any)
.text$mn:00001658                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001658
.text$mn:00001658 ; =============== S U B R O U T I N E =======================================
.text$mn:00001658
.text$mn:00001658 ; Attributes: bp-based frame
.text$mn:00001658
.text$mn:00001658 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00001658                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00001658 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00001658                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00001658
.text$mn:00001658 var_C           = dword ptr -0Ch
.text$mn:00001658 Dst             = dword ptr -8
.text$mn:00001658 var_4           = dword ptr -4
.text$mn:00001658 arg_0           = dword ptr  8
.text$mn:00001658 arg_4           = dword ptr  0Ch
.text$mn:00001658
.text$mn:00001658                 push    ebp
.text$mn:00001659                 mov     ebp, esp
.text$mn:0000165B                 sub     esp, 0Ch
.text$mn:0000165E                 mov     [ebp+var_4], ecx
.text$mn:00001661                 mov     eax, [ebp+var_4]
.text$mn:00001664                 mov     ecx, [eax+14h]
.text$mn:00001667                 cmp     ecx, [ebp+arg_0]
.text$mn:0000166A                 jnb     short loc_1674
.text$mn:0000166C                 mov     ecx, [ebp+var_4]
.text$mn:0000166F                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001674
.text$mn:00001674 loc_1674:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00001674                 mov     edx, [ebp+var_4]
.text$mn:00001677                 mov     eax, [edx+14h]
.text$mn:0000167A                 sub     eax, [ebp+arg_0]
.text$mn:0000167D                 cmp     eax, [ebp+arg_4]
.text$mn:00001680                 ja      short loc_1690
.text$mn:00001682                 mov     ecx, [ebp+arg_0]
.text$mn:00001685                 push    ecx
.text$mn:00001686                 mov     ecx, [ebp+var_4]
.text$mn:00001689                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000168E                 jmp     short loc_16D6
.text$mn:00001690 ; ---------------------------------------------------------------------------
.text$mn:00001690
.text$mn:00001690 loc_1690:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00001690                 cmp     [ebp+arg_4], 0
.text$mn:00001694                 jbe     short loc_16D6
.text$mn:00001696                 mov     ecx, [ebp+var_4]
.text$mn:00001699                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000169E                 add     eax, [ebp+arg_0]
.text$mn:000016A1                 mov     [ebp+Dst], eax
.text$mn:000016A4                 mov     edx, [ebp+var_4]
.text$mn:000016A7                 mov     eax, [edx+14h]
.text$mn:000016AA                 sub     eax, [ebp+arg_4]
.text$mn:000016AD                 mov     [ebp+var_C], eax
.text$mn:000016B0                 mov     ecx, [ebp+var_C]
.text$mn:000016B3                 sub     ecx, [ebp+arg_0]
.text$mn:000016B6                 push    ecx             ; Size
.text$mn:000016B7                 mov     edx, [ebp+Dst]
.text$mn:000016BA                 add     edx, [ebp+arg_4]
.text$mn:000016BD                 push    edx             ; Src
.text$mn:000016BE                 mov     eax, [ebp+Dst]
.text$mn:000016C1                 push    eax             ; Dst
.text$mn:000016C2                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:000016C7                 add     esp, 0Ch
.text$mn:000016CA                 mov     ecx, [ebp+var_C]
.text$mn:000016CD                 push    ecx
.text$mn:000016CE                 mov     ecx, [ebp+var_4]
.text$mn:000016D1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000016D6
.text$mn:000016D6 loc_16D6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000016D6                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000016D6                 mov     eax, [ebp+var_4]
.text$mn:000016D9                 mov     esp, ebp
.text$mn:000016DB                 pop     ebp
.text$mn:000016DC                 retn    8
.text$mn:000016DC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:000016DC
.text$mn:000016DC ; ---------------------------------------------------------------------------
.text$mn:000016DF                 align 10h
.text$mn:000016DF _text$mn        ends
.text$mn:000016DF
.text$mn:000016E0 ; ===========================================================================
.text$mn:000016E0
.text$mn:000016E0 ; Segment type: Pure code
.text$mn:000016E0 ; Segment permissions: Read/Execute
.text$mn:000016E0 _text$mn        segment para public 'CODE' use32
.text$mn:000016E0                 assume cs:_text$mn
.text$mn:000016E0                 ;org 16E0h
.text$mn:000016E0 ; COMDAT (pick any)
.text$mn:000016E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016E0
.text$mn:000016E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016E0
.text$mn:000016E0 ; Attributes: bp-based frame
.text$mn:000016E0
.text$mn:000016E0 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000016E0                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000016E0 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000016E0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000016E0                 push    ebp
.text$mn:000016E1                 mov     ebp, esp
.text$mn:000016E3                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000016E8                 pop     ebp
.text$mn:000016E9                 retn
.text$mn:000016E9 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000016E9
.text$mn:000016E9 ; ---------------------------------------------------------------------------
.text$mn:000016EA                 align 4
.text$mn:000016EA _text$mn        ends
.text$mn:000016EA
.text$mn:000016EC ; ===========================================================================
.text$mn:000016EC
.text$mn:000016EC ; Segment type: Pure code
.text$mn:000016EC ; Segment permissions: Read/Execute
.text$mn:000016EC _text$mn        segment para public 'CODE' use32
.text$mn:000016EC                 assume cs:_text$mn
.text$mn:000016EC                 ;org 16ECh
.text$mn:000016EC ; COMDAT (pick any)
.text$mn:000016EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016EC
.text$mn:000016EC ; =============== S U B R O U T I N E =======================================
.text$mn:000016EC
.text$mn:000016EC ; Attributes: bp-based frame
.text$mn:000016EC
.text$mn:000016EC ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:000016EC                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:000016EC ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:000016EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:000016EC
.text$mn:000016EC var_4           = dword ptr -4
.text$mn:000016EC Str             = dword ptr  8
.text$mn:000016EC
.text$mn:000016EC                 push    ebp
.text$mn:000016ED                 mov     ebp, esp
.text$mn:000016EF                 push    ecx
.text$mn:000016F0                 mov     eax, [ebp+Str]
.text$mn:000016F3                 movsx   ecx, byte ptr [eax]
.text$mn:000016F6                 test    ecx, ecx
.text$mn:000016F8                 jnz     short loc_1703
.text$mn:000016FA                 mov     [ebp+var_4], 0
.text$mn:00001701                 jmp     short loc_1712
.text$mn:00001703 ; ---------------------------------------------------------------------------
.text$mn:00001703
.text$mn:00001703 loc_1703:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00001703                 mov     edx, [ebp+Str]
.text$mn:00001706                 push    edx             ; Str
.text$mn:00001707                 call    _strlen
.text$mn:0000170C                 add     esp, 4
.text$mn:0000170F                 mov     [ebp+var_4], eax
.text$mn:00001712
.text$mn:00001712 loc_1712:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00001712                 mov     eax, [ebp+var_4]
.text$mn:00001715                 mov     esp, ebp
.text$mn:00001717                 pop     ebp
.text$mn:00001718                 retn
.text$mn:00001718 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00001718
.text$mn:00001718 ; ---------------------------------------------------------------------------
.text$mn:00001719                 align 4
.text$mn:00001719 _text$mn        ends
.text$mn:00001719
.text$mn:0000171C ; ===========================================================================
.text$mn:0000171C
.text$mn:0000171C ; Segment type: Pure code
.text$mn:0000171C ; Segment permissions: Read/Execute
.text$mn:0000171C _text$mn        segment para public 'CODE' use32
.text$mn:0000171C                 assume cs:_text$mn
.text$mn:0000171C                 ;org 171Ch
.text$mn:0000171C ; COMDAT (pick any)
.text$mn:0000171C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000171C
.text$mn:0000171C ; =============== S U B R O U T I N E =======================================
.text$mn:0000171C
.text$mn:0000171C ; Attributes: bp-based frame
.text$mn:0000171C
.text$mn:0000171C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:0000171C                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000171C ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000171C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:0000171C
.text$mn:0000171C var_4           = dword ptr -4
.text$mn:0000171C
.text$mn:0000171C                 push    ebp
.text$mn:0000171D                 mov     ebp, esp
.text$mn:0000171F                 push    ecx
.text$mn:00001720                 mov     [ebp+var_4], ecx
.text$mn:00001723                 mov     eax, [ebp+var_4]
.text$mn:00001726                 push    eax
.text$mn:00001727                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:0000172C                 add     esp, 4
.text$mn:0000172F                 mov     esp, ebp
.text$mn:00001731                 pop     ebp
.text$mn:00001732                 retn
.text$mn:00001732 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00001732
.text$mn:00001732 ; ---------------------------------------------------------------------------
.text$mn:00001733                 align 4
.text$mn:00001733 _text$mn        ends
.text$mn:00001733
.text$mn:00001734 ; ===========================================================================
.text$mn:00001734
.text$mn:00001734 ; Segment type: Pure code
.text$mn:00001734 ; Segment permissions: Read/Execute
.text$mn:00001734 _text$mn        segment para public 'CODE' use32
.text$mn:00001734                 assume cs:_text$mn
.text$mn:00001734                 ;org 1734h
.text$mn:00001734 ; COMDAT (pick any)
.text$mn:00001734                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001734
.text$mn:00001734 ; =============== S U B R O U T I N E =======================================
.text$mn:00001734
.text$mn:00001734 ; Attributes: bp-based frame
.text$mn:00001734
.text$mn:00001734 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00001734                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00001734 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00001734                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00001734
.text$mn:00001734 var_4           = dword ptr -4
.text$mn:00001734
.text$mn:00001734                 push    ebp
.text$mn:00001735                 mov     ebp, esp
.text$mn:00001737                 push    ecx
.text$mn:00001738                 mov     [ebp+var_4], ecx
.text$mn:0000173B                 or      eax, 0FFFFFFFFh
.text$mn:0000173E                 mov     esp, ebp
.text$mn:00001740                 pop     ebp
.text$mn:00001741                 retn
.text$mn:00001741 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00001741
.text$mn:00001741 ; ---------------------------------------------------------------------------
.text$mn:00001742                 align 4
.text$mn:00001742 _text$mn        ends
.text$mn:00001742
.text$mn:00001744 ; ===========================================================================
.text$mn:00001744
.text$mn:00001744 ; Segment type: Pure code
.text$mn:00001744 ; Segment permissions: Read/Execute
.text$mn:00001744 _text$mn        segment para public 'CODE' use32
.text$mn:00001744                 assume cs:_text$mn
.text$mn:00001744                 ;org 1744h
.text$mn:00001744 ; COMDAT (pick any)
.text$mn:00001744                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001744
.text$mn:00001744 ; =============== S U B R O U T I N E =======================================
.text$mn:00001744
.text$mn:00001744 ; Attributes: bp-based frame
.text$mn:00001744
.text$mn:00001744 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00001744                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00001744 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00001744                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00001744
.text$mn:00001744 arg_0           = dword ptr  8
.text$mn:00001744
.text$mn:00001744                 push    ebp
.text$mn:00001745                 mov     ebp, esp
.text$mn:00001747                 mov     ecx, [ebp+arg_0]
.text$mn:0000174A                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000174F                 pop     ebp
.text$mn:00001750                 retn
.text$mn:00001750 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00001750
.text$mn:00001750 ; ---------------------------------------------------------------------------
.text$mn:00001751                 align 4
.text$mn:00001751 _text$mn        ends
.text$mn:00001751
.text$mn:00001754 ; ===========================================================================
.text$mn:00001754
.text$mn:00001754 ; Segment type: Pure code
.text$mn:00001754 ; Segment permissions: Read/Execute
.text$mn:00001754 _text$mn        segment para public 'CODE' use32
.text$mn:00001754                 assume cs:_text$mn
.text$mn:00001754                 ;org 1754h
.text$mn:00001754 ; COMDAT (pick any)
.text$mn:00001754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001754
.text$mn:00001754 ; =============== S U B R O U T I N E =======================================
.text$mn:00001754
.text$mn:00001754 ; Attributes: bp-based frame
.text$mn:00001754
.text$mn:00001754 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00001754                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001754 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001754                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00001754                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00001754
.text$mn:00001754 var_10          = dword ptr -10h
.text$mn:00001754 var_C           = dword ptr -0Ch
.text$mn:00001754 var_8           = dword ptr -8
.text$mn:00001754 var_1           = byte ptr -1
.text$mn:00001754
.text$mn:00001754                 push    ebp
.text$mn:00001755                 mov     ebp, esp
.text$mn:00001757                 sub     esp, 10h
.text$mn:0000175A                 mov     [ebp+var_10], ecx
.text$mn:0000175D                 lea     eax, [ebp+var_1]
.text$mn:00001760                 push    eax
.text$mn:00001761                 mov     ecx, [ebp+var_10]
.text$mn:00001764                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001769                 mov     ecx, eax
.text$mn:0000176B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00001770                 mov     [ebp+var_8], eax
.text$mn:00001773                 cmp     [ebp+var_8], 1
.text$mn:00001777                 ja      short loc_1782
.text$mn:00001779                 mov     [ebp+var_C], 1
.text$mn:00001780                 jmp     short loc_178B
.text$mn:00001782 ; ---------------------------------------------------------------------------
.text$mn:00001782
.text$mn:00001782 loc_1782:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00001782                 mov     ecx, [ebp+var_8]
.text$mn:00001785                 sub     ecx, 1
.text$mn:00001788                 mov     [ebp+var_C], ecx
.text$mn:0000178B
.text$mn:0000178B loc_178B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000178B                 mov     eax, [ebp+var_C]
.text$mn:0000178E                 mov     esp, ebp
.text$mn:00001790                 pop     ebp
.text$mn:00001791                 retn
.text$mn:00001791 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001791
.text$mn:00001791 ; ---------------------------------------------------------------------------
.text$mn:00001792                 align 4
.text$mn:00001792 _text$mn        ends
.text$mn:00001792
.text$mn:00001794 ; ===========================================================================
.text$mn:00001794
.text$mn:00001794 ; Segment type: Pure code
.text$mn:00001794 ; Segment permissions: Read/Execute
.text$mn:00001794 _text$mn        segment para public 'CODE' use32
.text$mn:00001794                 assume cs:_text$mn
.text$mn:00001794                 ;org 1794h
.text$mn:00001794 ; COMDAT (pick any)
.text$mn:00001794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001794
.text$mn:00001794 ; =============== S U B R O U T I N E =======================================
.text$mn:00001794
.text$mn:00001794 ; Attributes: bp-based frame
.text$mn:00001794
.text$mn:00001794 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00001794                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001794 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001794                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00001794                                         ; DATA XREF: .rdata:00001E60o
.text$mn:00001794
.text$mn:00001794 var_1C          = dword ptr -1Ch
.text$mn:00001794 var_18          = dword ptr -18h
.text$mn:00001794 Str             = dword ptr -14h
.text$mn:00001794 var_10          = dword ptr -10h
.text$mn:00001794 var_C           = dword ptr -0Ch
.text$mn:00001794 var_4           = dword ptr -4
.text$mn:00001794 arg_0           = dword ptr  8
.text$mn:00001794 arg_4           = dword ptr  0Ch
.text$mn:00001794
.text$mn:00001794                 push    ebp
.text$mn:00001795                 mov     ebp, esp
.text$mn:00001797                 push    0FFFFFFFFh
.text$mn:00001799                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000179E                 mov     eax, large fs:0
.text$mn:000017A4                 push    eax
.text$mn:000017A5                 sub     esp, 10h
.text$mn:000017A8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017AD                 xor     eax, ebp
.text$mn:000017AF                 push    eax
.text$mn:000017B0                 lea     eax, [ebp+var_C]
.text$mn:000017B3                 mov     large fs:0, eax
.text$mn:000017B9                 mov     [ebp+var_1C], ecx
.text$mn:000017BC                 mov     [ebp+var_18], 0
.text$mn:000017C3                 mov     eax, [ebp+arg_4]
.text$mn:000017C6                 push    eax             ; int
.text$mn:000017C7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000017CC                 add     esp, 4
.text$mn:000017CF                 mov     [ebp+var_10], eax
.text$mn:000017D2                 cmp     [ebp+var_10], 0
.text$mn:000017D6                 jz      short loc_17E0
.text$mn:000017D8                 mov     ecx, [ebp+var_10]
.text$mn:000017DB                 mov     [ebp+Str], ecx
.text$mn:000017DE                 jmp     short loc_17E7
.text$mn:000017E0 ; ---------------------------------------------------------------------------
.text$mn:000017E0
.text$mn:000017E0 loc_17E0:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000017E0                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000017E7
.text$mn:000017E7 loc_17E7:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000017E7                 mov     edx, [ebp+Str]
.text$mn:000017EA                 push    edx             ; Str
.text$mn:000017EB                 mov     ecx, [ebp+arg_0]
.text$mn:000017EE                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000017F3                 mov     [ebp+var_4], 0
.text$mn:000017FA                 mov     eax, [ebp+var_18]
.text$mn:000017FD                 or      eax, 1
.text$mn:00001800                 mov     [ebp+var_18], eax
.text$mn:00001803                 mov     eax, [ebp+arg_0]
.text$mn:00001806                 mov     ecx, [ebp+var_C]
.text$mn:00001809                 mov     large fs:0, ecx
.text$mn:00001810                 pop     ecx
.text$mn:00001811                 mov     esp, ebp
.text$mn:00001813                 pop     ebp
.text$mn:00001814                 retn    8
.text$mn:00001814 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001814
.text$mn:00001814 ; ---------------------------------------------------------------------------
.text$mn:00001817                 align 4
.text$mn:00001817 _text$mn        ends
.text$mn:00001817
.text$x:00001818 ; ===========================================================================
.text$x:00001818
.text$x:00001818 ; Segment type: Pure code
.text$x:00001818 ; Segment permissions: Read/Execute
.text$x:00001818 _text$x         segment para public 'CODE' use32
.text$x:00001818                 assume cs:_text$x
.text$x:00001818                 ;org 1818h
.text$x:00001818 ; COMDAT (pick associative to section at 1794)
.text$x:00001818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001818
.text$x:00001818 ; =============== S U B R O U T I N E =======================================
.text$x:00001818
.text$x:00001818
.text$x:00001818 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001818                                         ; DATA XREF: .xdata$x:00001C80o
.text$x:00001818                 mov     eax, [ebp-18h]
.text$x:0000181B                 and     eax, 1
.text$x:0000181E                 jz      $LN6
.text$x:00001824                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001828                 mov     ecx, [ebp+8]
.text$x:0000182B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001830 ; ---------------------------------------------------------------------------
.text$x:00001830
.text$x:00001830 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001830                 retn
.text$x:00001830 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001830
.text$x:00001831
.text$x:00001831 ; =============== S U B R O U T I N E =======================================
.text$x:00001831
.text$x:00001831
.text$x:00001831 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001831                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00001831
.text$x:00001831 arg_4           = dword ptr  8
.text$x:00001831
.text$x:00001831                 mov     edx, [esp+arg_4]
.text$x:00001835                 lea     eax, [edx+0Ch]
.text$x:00001838                 mov     ecx, [edx-14h]
.text$x:0000183B                 xor     ecx, eax
.text$x:0000183D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001842                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001847                 jmp     ___CxxFrameHandler3
.text$x:00001847 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001847
.text$x:00001847 _text$x         ends
.text$x:00001847
.text$mn:0000184C ; ===========================================================================
.text$mn:0000184C
.text$mn:0000184C ; Segment type: Pure code
.text$mn:0000184C ; Segment permissions: Read/Execute
.text$mn:0000184C _text$mn        segment para public 'CODE' use32
.text$mn:0000184C                 assume cs:_text$mn
.text$mn:0000184C                 ;org 184Ch
.text$mn:0000184C ; COMDAT (pick any)
.text$mn:0000184C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000184C
.text$mn:0000184C ; =============== S U B R O U T I N E =======================================
.text$mn:0000184C
.text$mn:0000184C ; Attributes: bp-based frame
.text$mn:0000184C
.text$mn:0000184C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:0000184C                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000184C ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000184C                                         ; DATA XREF: .rdata:00001E94o
.text$mn:0000184C
.text$mn:0000184C var_14          = dword ptr -14h
.text$mn:0000184C var_10          = dword ptr -10h
.text$mn:0000184C var_C           = dword ptr -0Ch
.text$mn:0000184C var_4           = dword ptr -4
.text$mn:0000184C arg_0           = dword ptr  8
.text$mn:0000184C arg_4           = dword ptr  0Ch
.text$mn:0000184C
.text$mn:0000184C                 push    ebp
.text$mn:0000184D                 mov     ebp, esp
.text$mn:0000184F                 push    0FFFFFFFFh
.text$mn:00001851                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001856                 mov     eax, large fs:0
.text$mn:0000185C                 push    eax
.text$mn:0000185D                 sub     esp, 8
.text$mn:00001860                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001865                 xor     eax, ebp
.text$mn:00001867                 push    eax
.text$mn:00001868                 lea     eax, [ebp+var_C]
.text$mn:0000186B                 mov     large fs:0, eax
.text$mn:00001871                 mov     [ebp+var_14], ecx
.text$mn:00001874                 mov     [ebp+var_10], 0
.text$mn:0000187B                 cmp     [ebp+arg_4], 1
.text$mn:0000187F                 jnz     short loc_18A5
.text$mn:00001881                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00001886                 mov     ecx, [ebp+arg_0]
.text$mn:00001889                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000188E                 mov     [ebp+var_4], 0
.text$mn:00001895                 mov     eax, [ebp+var_10]
.text$mn:00001898                 or      eax, 1
.text$mn:0000189B                 mov     [ebp+var_10], eax
.text$mn:0000189E                 mov     eax, [ebp+arg_0]
.text$mn:000018A1                 jmp     short loc_18C8
.text$mn:000018A3 ; ---------------------------------------------------------------------------
.text$mn:000018A3                 jmp     short loc_18C8
.text$mn:000018A5 ; ---------------------------------------------------------------------------
.text$mn:000018A5
.text$mn:000018A5 loc_18A5:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:000018A5                 mov     ecx, [ebp+arg_4]
.text$mn:000018A8                 push    ecx
.text$mn:000018A9                 mov     edx, [ebp+arg_0]
.text$mn:000018AC                 push    edx
.text$mn:000018AD                 mov     ecx, [ebp+var_14]
.text$mn:000018B0                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000018B5                 mov     [ebp+var_4], 0
.text$mn:000018BC                 mov     eax, [ebp+var_10]
.text$mn:000018BF                 or      eax, 1
.text$mn:000018C2                 mov     [ebp+var_10], eax
.text$mn:000018C5                 mov     eax, [ebp+arg_0]
.text$mn:000018C8
.text$mn:000018C8 loc_18C8:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000018C8                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000018C8                 mov     ecx, [ebp+var_C]
.text$mn:000018CB                 mov     large fs:0, ecx
.text$mn:000018D2                 pop     ecx
.text$mn:000018D3                 mov     esp, ebp
.text$mn:000018D5                 pop     ebp
.text$mn:000018D6                 retn    8
.text$mn:000018D6 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000018D6
.text$mn:000018D6 ; ---------------------------------------------------------------------------
.text$mn:000018D9                 align 4
.text$mn:000018D9 _text$mn        ends
.text$mn:000018D9
.text$x:000018DC ; ===========================================================================
.text$x:000018DC
.text$x:000018DC ; Segment type: Pure code
.text$x:000018DC ; Segment permissions: Read/Execute
.text$x:000018DC _text$x         segment para public 'CODE' use32
.text$x:000018DC                 assume cs:_text$x
.text$x:000018DC                 ;org 18DCh
.text$x:000018DC ; COMDAT (pick associative to section at 184C)
.text$x:000018DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000018DC
.text$x:000018DC ; =============== S U B R O U T I N E =======================================
.text$x:000018DC
.text$x:000018DC
.text$x:000018DC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000018DC                                         ; DATA XREF: .xdata$x:00001D04o
.text$x:000018DC                 mov     eax, [ebp-10h]
.text$x:000018DF                 and     eax, 1
.text$x:000018E2                 jz      $LN6_0
.text$x:000018E8                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000018EC                 mov     ecx, [ebp+8]
.text$x:000018EF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000018F4 ; ---------------------------------------------------------------------------
.text$x:000018F4
.text$x:000018F4 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000018F4                 retn
.text$x:000018F4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000018F4
.text$x:000018F5
.text$x:000018F5 ; =============== S U B R O U T I N E =======================================
.text$x:000018F5
.text$x:000018F5
.text$x:000018F5 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000018F5                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:000018F5
.text$x:000018F5 arg_4           = dword ptr  8
.text$x:000018F5
.text$x:000018F5                 mov     edx, [esp+arg_4]
.text$x:000018F9                 lea     eax, [edx+0Ch]
.text$x:000018FC                 mov     ecx, [edx-0Ch]
.text$x:000018FF                 xor     ecx, eax
.text$x:00001901                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001906                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000190B                 jmp     ___CxxFrameHandler3
.text$x:0000190B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000190B
.text$x:0000190B _text$x         ends
.text$x:0000190B
.text$mn:00001910 ; ===========================================================================
.text$mn:00001910
.text$mn:00001910 ; Segment type: Pure code
.text$mn:00001910 ; Segment permissions: Read/Execute
.text$mn:00001910 _text$mn        segment para public 'CODE' use32
.text$mn:00001910                 assume cs:_text$mn
.text$mn:00001910                 ;org 1910h
.text$mn:00001910 ; COMDAT (pick any)
.text$mn:00001910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001910
.text$mn:00001910 ; =============== S U B R O U T I N E =======================================
.text$mn:00001910
.text$mn:00001910 ; Attributes: bp-based frame
.text$mn:00001910
.text$mn:00001910 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00001910                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001910 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001910                                         ; DATA XREF: .rdata:00001ED4o
.text$mn:00001910
.text$mn:00001910 var_1C          = dword ptr -1Ch
.text$mn:00001910 var_18          = dword ptr -18h
.text$mn:00001910 Str             = dword ptr -14h
.text$mn:00001910 var_10          = dword ptr -10h
.text$mn:00001910 var_C           = dword ptr -0Ch
.text$mn:00001910 var_4           = dword ptr -4
.text$mn:00001910 arg_0           = dword ptr  8
.text$mn:00001910 arg_4           = dword ptr  0Ch
.text$mn:00001910
.text$mn:00001910                 push    ebp
.text$mn:00001911                 mov     ebp, esp
.text$mn:00001913                 push    0FFFFFFFFh
.text$mn:00001915                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000191A                 mov     eax, large fs:0
.text$mn:00001920                 push    eax
.text$mn:00001921                 sub     esp, 10h
.text$mn:00001924                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001929                 xor     eax, ebp
.text$mn:0000192B                 push    eax
.text$mn:0000192C                 lea     eax, [ebp+var_C]
.text$mn:0000192F                 mov     large fs:0, eax
.text$mn:00001935                 mov     [ebp+var_1C], ecx
.text$mn:00001938                 mov     [ebp+var_18], 0
.text$mn:0000193F                 mov     eax, [ebp+arg_4]
.text$mn:00001942                 push    eax             ; int
.text$mn:00001943                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00001948                 add     esp, 4
.text$mn:0000194B                 mov     [ebp+var_10], eax
.text$mn:0000194E                 cmp     [ebp+var_10], 0
.text$mn:00001952                 jz      short loc_195C
.text$mn:00001954                 mov     ecx, [ebp+var_10]
.text$mn:00001957                 mov     [ebp+Str], ecx
.text$mn:0000195A                 jmp     short loc_1963
.text$mn:0000195C ; ---------------------------------------------------------------------------
.text$mn:0000195C
.text$mn:0000195C loc_195C:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:0000195C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001963
.text$mn:00001963 loc_1963:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00001963                 mov     edx, [ebp+Str]
.text$mn:00001966                 push    edx             ; Str
.text$mn:00001967                 mov     ecx, [ebp+arg_0]
.text$mn:0000196A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000196F                 mov     [ebp+var_4], 0
.text$mn:00001976                 mov     eax, [ebp+var_18]
.text$mn:00001979                 or      eax, 1
.text$mn:0000197C                 mov     [ebp+var_18], eax
.text$mn:0000197F                 mov     eax, [ebp+arg_0]
.text$mn:00001982                 mov     ecx, [ebp+var_C]
.text$mn:00001985                 mov     large fs:0, ecx
.text$mn:0000198C                 pop     ecx
.text$mn:0000198D                 mov     esp, ebp
.text$mn:0000198F                 pop     ebp
.text$mn:00001990                 retn    8
.text$mn:00001990 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001990
.text$mn:00001990 ; ---------------------------------------------------------------------------
.text$mn:00001993                 align 4
.text$mn:00001993 _text$mn        ends
.text$mn:00001993
.text$x:00001994 ; ===========================================================================
.text$x:00001994
.text$x:00001994 ; Segment type: Pure code
.text$x:00001994 ; Segment permissions: Read/Execute
.text$x:00001994 _text$x         segment para public 'CODE' use32
.text$x:00001994                 assume cs:_text$x
.text$x:00001994                 ;org 1994h
.text$x:00001994 ; COMDAT (pick associative to section at 1910)
.text$x:00001994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001994
.text$x:00001994 ; =============== S U B R O U T I N E =======================================
.text$x:00001994
.text$x:00001994
.text$x:00001994 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001994                                         ; DATA XREF: .xdata$x:00001D88o
.text$x:00001994                 mov     eax, [ebp-18h]
.text$x:00001997                 and     eax, 1
.text$x:0000199A                 jz      $LN6_1
.text$x:000019A0                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000019A4                 mov     ecx, [ebp+8]
.text$x:000019A7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000019AC ; ---------------------------------------------------------------------------
.text$x:000019AC
.text$x:000019AC $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000019AC                 retn
.text$x:000019AC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000019AC
.text$x:000019AD
.text$x:000019AD ; =============== S U B R O U T I N E =======================================
.text$x:000019AD
.text$x:000019AD
.text$x:000019AD __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000019AD                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000019AD
.text$x:000019AD arg_4           = dword ptr  8
.text$x:000019AD
.text$x:000019AD                 mov     edx, [esp+arg_4]
.text$x:000019B1                 lea     eax, [edx+0Ch]
.text$x:000019B4                 mov     ecx, [edx-14h]
.text$x:000019B7                 xor     ecx, eax
.text$x:000019B9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019BE                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000019C3                 jmp     ___CxxFrameHandler3
.text$x:000019C3 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000019C3
.text$x:000019C3 _text$x         ends
.text$x:000019C3
.text$mn:000019C8 ; ===========================================================================
.text$mn:000019C8
.text$mn:000019C8 ; Segment type: Pure code
.text$mn:000019C8 ; Segment permissions: Read/Execute
.text$mn:000019C8 _text$mn        segment para public 'CODE' use32
.text$mn:000019C8                 assume cs:_text$mn
.text$mn:000019C8                 ;org 19C8h
.text$mn:000019C8 ; COMDAT (pick any)
.text$mn:000019C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019C8
.text$mn:000019C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019C8
.text$mn:000019C8 ; Attributes: bp-based frame
.text$mn:000019C8
.text$mn:000019C8 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000019C8                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000019C8 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000019C8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000019C8
.text$mn:000019C8 var_4           = dword ptr -4
.text$mn:000019C8 Dst             = dword ptr  8
.text$mn:000019C8 Src             = dword ptr  0Ch
.text$mn:000019C8 Size            = dword ptr  10h
.text$mn:000019C8
.text$mn:000019C8                 push    ebp
.text$mn:000019C9                 mov     ebp, esp
.text$mn:000019CB                 push    ecx
.text$mn:000019CC                 cmp     [ebp+Size], 0
.text$mn:000019D0                 jnz     short loc_19DA
.text$mn:000019D2                 mov     eax, [ebp+Dst]
.text$mn:000019D5                 mov     [ebp+var_4], eax
.text$mn:000019D8                 jmp     short loc_19F1
.text$mn:000019DA ; ---------------------------------------------------------------------------
.text$mn:000019DA
.text$mn:000019DA loc_19DA:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000019DA                 mov     ecx, [ebp+Size]
.text$mn:000019DD                 push    ecx             ; Size
.text$mn:000019DE                 mov     edx, [ebp+Src]
.text$mn:000019E1                 push    edx             ; Src
.text$mn:000019E2                 mov     eax, [ebp+Dst]
.text$mn:000019E5                 push    eax             ; Dst
.text$mn:000019E6                 call    _memmove
.text$mn:000019EB                 add     esp, 0Ch
.text$mn:000019EE                 mov     [ebp+var_4], eax
.text$mn:000019F1
.text$mn:000019F1 loc_19F1:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:000019F1                 mov     eax, [ebp+var_4]
.text$mn:000019F4                 mov     esp, ebp
.text$mn:000019F6                 pop     ebp
.text$mn:000019F7                 retn
.text$mn:000019F7 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000019F7
.text$mn:000019F7 _text$mn        ends
.text$mn:000019F7
.text$mn:000019F8 ; ===========================================================================
.text$mn:000019F8
.text$mn:000019F8 ; Segment type: Pure code
.text$mn:000019F8 ; Segment permissions: Read/Execute
.text$mn:000019F8 _text$mn        segment para public 'CODE' use32
.text$mn:000019F8                 assume cs:_text$mn
.text$mn:000019F8                 ;org 19F8h
.text$mn:000019F8 ; COMDAT (pick any)
.text$mn:000019F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019F8
.text$mn:000019F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019F8
.text$mn:000019F8 ; Attributes: bp-based frame
.text$mn:000019F8
.text$mn:000019F8 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:000019F8                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:000019F8 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:000019F8                                         ; DATA XREF: .rdata:00001E5Co
.text$mn:000019F8
.text$mn:000019F8 var_4           = dword ptr -4
.text$mn:000019F8
.text$mn:000019F8                 push    ebp
.text$mn:000019F9                 mov     ebp, esp
.text$mn:000019FB                 push    ecx
.text$mn:000019FC                 mov     [ebp+var_4], ecx
.text$mn:000019FF                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00001A04                 mov     esp, ebp
.text$mn:00001A06                 pop     ebp
.text$mn:00001A07                 retn
.text$mn:00001A07 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00001A07
.text$mn:00001A07 _text$mn        ends
.text$mn:00001A07
.text$mn:00001A08 ; ===========================================================================
.text$mn:00001A08
.text$mn:00001A08 ; Segment type: Pure code
.text$mn:00001A08 ; Segment permissions: Read/Execute
.text$mn:00001A08 _text$mn        segment para public 'CODE' use32
.text$mn:00001A08                 assume cs:_text$mn
.text$mn:00001A08                 ;org 1A08h
.text$mn:00001A08 ; COMDAT (pick any)
.text$mn:00001A08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A08
.text$mn:00001A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A08
.text$mn:00001A08 ; Attributes: bp-based frame
.text$mn:00001A08
.text$mn:00001A08 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00001A08                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00001A08 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00001A08                                         ; DATA XREF: .rdata:00001E90o
.text$mn:00001A08
.text$mn:00001A08 var_4           = dword ptr -4
.text$mn:00001A08
.text$mn:00001A08                 push    ebp
.text$mn:00001A09                 mov     ebp, esp
.text$mn:00001A0B                 push    ecx
.text$mn:00001A0C                 mov     [ebp+var_4], ecx
.text$mn:00001A0F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00001A14                 mov     esp, ebp
.text$mn:00001A16                 pop     ebp
.text$mn:00001A17                 retn
.text$mn:00001A17 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00001A17
.text$mn:00001A17 _text$mn        ends
.text$mn:00001A17
.text$mn:00001A18 ; ===========================================================================
.text$mn:00001A18
.text$mn:00001A18 ; Segment type: Pure code
.text$mn:00001A18 ; Segment permissions: Read/Execute
.text$mn:00001A18 _text$mn        segment para public 'CODE' use32
.text$mn:00001A18                 assume cs:_text$mn
.text$mn:00001A18                 ;org 1A18h
.text$mn:00001A18 ; COMDAT (pick any)
.text$mn:00001A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A18
.text$mn:00001A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A18
.text$mn:00001A18 ; Attributes: bp-based frame
.text$mn:00001A18
.text$mn:00001A18 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00001A18                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00001A18 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00001A18                                         ; DATA XREF: .rdata:00001ED0o
.text$mn:00001A18
.text$mn:00001A18 var_4           = dword ptr -4
.text$mn:00001A18
.text$mn:00001A18                 push    ebp
.text$mn:00001A19                 mov     ebp, esp
.text$mn:00001A1B                 push    ecx
.text$mn:00001A1C                 mov     [ebp+var_4], ecx
.text$mn:00001A1F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00001A24                 mov     esp, ebp
.text$mn:00001A26                 pop     ebp
.text$mn:00001A27                 retn
.text$mn:00001A27 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00001A27
.text$mn:00001A27 _text$mn        ends
.text$mn:00001A27
.text$mn:00001A28 ; ===========================================================================
.text$mn:00001A28
.text$mn:00001A28 ; Segment type: Pure code
.text$mn:00001A28 ; Segment permissions: Read/Execute
.text$mn:00001A28 _text$mn        segment para public 'CODE' use32
.text$mn:00001A28                 assume cs:_text$mn
.text$mn:00001A28                 ;org 1A28h
.text$mn:00001A28 ; COMDAT (pick any)
.text$mn:00001A28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A28
.text$mn:00001A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A28
.text$mn:00001A28 ; Attributes: bp-based frame
.text$mn:00001A28
.text$mn:00001A28 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00001A28                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001A28 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001A28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00001A28                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00001A28
.text$mn:00001A28 var_4           = dword ptr -4
.text$mn:00001A28
.text$mn:00001A28                 push    ebp
.text$mn:00001A29                 mov     ebp, esp
.text$mn:00001A2B                 push    ecx
.text$mn:00001A2C                 mov     [ebp+var_4], ecx
.text$mn:00001A2F                 mov     eax, [ebp+var_4]
.text$mn:00001A32                 mov     eax, [eax+14h]
.text$mn:00001A35                 mov     esp, ebp
.text$mn:00001A37                 pop     ebp
.text$mn:00001A38                 retn
.text$mn:00001A38 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001A38
.text$mn:00001A38 ; ---------------------------------------------------------------------------
.text$mn:00001A39                 align 4
.text$mn:00001A39 _text$mn        ends
.text$mn:00001A39
.text$mn:00001A3C ; ===========================================================================
.text$mn:00001A3C
.text$mn:00001A3C ; Segment type: Pure code
.text$mn:00001A3C ; Segment permissions: Read/Execute
.text$mn:00001A3C _text$mn        segment para public 'CODE' use32
.text$mn:00001A3C                 assume cs:_text$mn
.text$mn:00001A3C                 ;org 1A3Ch
.text$mn:00001A3C ; COMDAT (pick any)
.text$mn:00001A3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A3C
.text$mn:00001A3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A3C
.text$mn:00001A3C ; Attributes: bp-based frame
.text$mn:00001A3C
.text$mn:00001A3C ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00001A3C                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00001A3C ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001A3C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_1574p
.text$mn:00001A3C                 push    ebp
.text$mn:00001A3D                 mov     ebp, esp
.text$mn:00001A3F                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00001A44                 pop     ebp
.text$mn:00001A45                 retn
.text$mn:00001A45 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001A45
.text$mn:00001A45 ; ---------------------------------------------------------------------------
.text$mn:00001A46                 align 4
.text$mn:00001A46 _text$mn        ends
.text$mn:00001A46
.text$mn:00001A48 ; ===========================================================================
.text$mn:00001A48
.text$mn:00001A48 ; Segment type: Pure code
.text$mn:00001A48 ; Segment permissions: Read/Execute
.text$mn:00001A48 _text$mn        segment para public 'CODE' use32
.text$mn:00001A48                 assume cs:_text$mn
.text$mn:00001A48                 ;org 1A48h
.text$mn:00001A48 ; COMDAT (pick any)
.text$mn:00001A48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A48
.text$mn:00001A48 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A48
.text$mn:00001A48 ; Attributes: bp-based frame
.text$mn:00001A48
.text$mn:00001A48 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00001A48                 public ?value@error_code@std@@QBEHXZ
.text$mn:00001A48 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00001A48
.text$mn:00001A48 var_4           = dword ptr -4
.text$mn:00001A48
.text$mn:00001A48                 push    ebp
.text$mn:00001A49                 mov     ebp, esp
.text$mn:00001A4B                 push    ecx
.text$mn:00001A4C                 mov     [ebp+var_4], ecx
.text$mn:00001A4F                 mov     eax, [ebp+var_4]
.text$mn:00001A52                 mov     eax, [eax]
.text$mn:00001A54                 mov     esp, ebp
.text$mn:00001A56                 pop     ebp
.text$mn:00001A57                 retn
.text$mn:00001A57 ?value@error_code@std@@QBEHXZ endp
.text$mn:00001A57
.text$mn:00001A57 _text$mn        ends
.text$mn:00001A57
.text$mn:00001A58 ; ===========================================================================
.text$mn:00001A58
.text$mn:00001A58 ; Segment type: Pure code
.text$mn:00001A58 ; Segment permissions: Read/Execute
.text$mn:00001A58 _text$mn        segment para public 'CODE' use32
.text$mn:00001A58                 assume cs:_text$mn
.text$mn:00001A58                 ;org 1A58h
.text$mn:00001A58 ; COMDAT (pick any)
.text$mn:00001A58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A58
.text$mn:00001A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A58
.text$mn:00001A58 ; Attributes: bp-based frame
.text$mn:00001A58
.text$mn:00001A58 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00001A58                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00001A58 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00001A58                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00001A58                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00001A58
.text$mn:00001A58 var_4           = dword ptr -4
.text$mn:00001A58
.text$mn:00001A58                 push    ebp
.text$mn:00001A59                 mov     ebp, esp
.text$mn:00001A5B                 push    ecx
.text$mn:00001A5C                 mov     [ebp+var_4], ecx
.text$mn:00001A5F                 mov     eax, [ebp+var_4]
.text$mn:00001A62                 mov     eax, [eax]
.text$mn:00001A64                 mov     esp, ebp
.text$mn:00001A66                 pop     ebp
.text$mn:00001A67                 retn
.text$mn:00001A67 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00001A67
.text$mn:00001A67 _text$mn        ends
.text$mn:00001A67
.text$mn:00001A68 ; ===========================================================================
.text$mn:00001A68
.text$mn:00001A68 ; Segment type: Pure code
.text$mn:00001A68 ; Segment permissions: Read/Execute
.text$mn:00001A68 _text$mn        segment para public 'CODE' use32
.text$mn:00001A68                 assume cs:_text$mn
.text$mn:00001A68                 ;org 1A68h
.text$mn:00001A68 ; COMDAT (pick any)
.text$mn:00001A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A68
.text$mn:00001A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A68
.text$mn:00001A68 ; Attributes: bp-based frame
.text$mn:00001A68
.text$mn:00001A68                 public _hypot
.text$mn:00001A68 _hypot          proc near
.text$mn:00001A68
.text$mn:00001A68 var_10          = qword ptr -10h
.text$mn:00001A68 var_8           = qword ptr -8
.text$mn:00001A68 arg_0           = qword ptr  8
.text$mn:00001A68 arg_8           = qword ptr  10h
.text$mn:00001A68
.text$mn:00001A68                 push    ebp
.text$mn:00001A69                 mov     ebp, esp
.text$mn:00001A6B                 sub     esp, 8
.text$mn:00001A6E                 movsd   xmm0, [ebp+arg_8]
.text$mn:00001A73                 movsd   [esp+8+var_8], xmm0
.text$mn:00001A78                 sub     esp, 8
.text$mn:00001A7B                 movsd   xmm0, [ebp+arg_0]
.text$mn:00001A80                 movsd   [esp+10h+var_10], xmm0
.text$mn:00001A85                 call    __hypot
.text$mn:00001A8A                 add     esp, 10h
.text$mn:00001A8D                 pop     ebp
.text$mn:00001A8E                 retn
.text$mn:00001A8E _hypot          endp
.text$mn:00001A8E
.text$mn:00001A8E ; ---------------------------------------------------------------------------
.text$mn:00001A8F                 align 10h
.text$mn:00001A8F _text$mn        ends
.text$mn:00001A8F
.xdata$x:00001A90 ; ===========================================================================
.xdata$x:00001A90
.xdata$x:00001A90 ; Segment type: Pure data
.xdata$x:00001A90 ; Segment permissions: Read
.xdata$x:00001A90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001A90                 assume cs:_xdata$x
.xdata$x:00001A90                 ;org 1A90h
.xdata$x:00001A90 ; COMDAT (pick associative to section at 1118)
.xdata$x:00001A90 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00001A90                                         ; DATA XREF: .xdata$x:00001AA0o
.xdata$x:00001A91                 db 0FFh
.xdata$x:00001A92                 db 0FFh
.xdata$x:00001A93                 db 0FFh
.xdata$x:00001A94                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00001A98 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00001A98                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00001A99                 db    5
.xdata$x:00001A9A                 db  93h ; 
.xdata$x:00001A9B                 db  19h
.xdata$x:00001A9C                 db    1
.xdata$x:00001A9D                 db    0
.xdata$x:00001A9E                 db    0
.xdata$x:00001A9F                 db    0
.xdata$x:00001AA0                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00001AA4                 db    0
.xdata$x:00001AA5                 db    0
.xdata$x:00001AA6                 db    0
.xdata$x:00001AA7                 db    0
.xdata$x:00001AA8                 db    0
.xdata$x:00001AA9                 db    0
.xdata$x:00001AAA                 db    0
.xdata$x:00001AAB                 db    0
.xdata$x:00001AAC                 db    0
.xdata$x:00001AAD                 db    0
.xdata$x:00001AAE                 db    0
.xdata$x:00001AAF                 db    0
.xdata$x:00001AB0                 db    0
.xdata$x:00001AB1                 db    0
.xdata$x:00001AB2                 db    0
.xdata$x:00001AB3                 db    0
.xdata$x:00001AB4                 db    0
.xdata$x:00001AB5                 db    0
.xdata$x:00001AB6                 db    0
.xdata$x:00001AB7                 db    0
.xdata$x:00001AB8                 db    0
.xdata$x:00001AB9                 db    0
.xdata$x:00001ABA                 db    0
.xdata$x:00001ABB                 db    0
.xdata$x:00001ABB _xdata$x        ends
.xdata$x:00001ABB
.xdata$x:00001ABC ; ===========================================================================
.xdata$x:00001ABC
.xdata$x:00001ABC ; Segment type: Pure data
.xdata$x:00001ABC ; Segment permissions: Read
.xdata$x:00001ABC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001ABC                 assume cs:_xdata$x
.xdata$x:00001ABC                 ;org 1ABCh
.xdata$x:00001ABC ; COMDAT (pick associative to section at 4B8)
.xdata$x:00001ABC __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001ABC                                         ; DATA XREF: .xdata$x:00001ACCo
.xdata$x:00001ABD                 db 0FFh
.xdata$x:00001ABE                 db 0FFh
.xdata$x:00001ABF                 db 0FFh
.xdata$x:00001AC0                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001AC4 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001AC4                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001AC5                 db    5
.xdata$x:00001AC6                 db  93h ; 
.xdata$x:00001AC7                 db  19h
.xdata$x:00001AC8                 db    1
.xdata$x:00001AC9                 db    0
.xdata$x:00001ACA                 db    0
.xdata$x:00001ACB                 db    0
.xdata$x:00001ACC                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001AD0                 db    0
.xdata$x:00001AD1                 db    0
.xdata$x:00001AD2                 db    0
.xdata$x:00001AD3                 db    0
.xdata$x:00001AD4                 db    0
.xdata$x:00001AD5                 db    0
.xdata$x:00001AD6                 db    0
.xdata$x:00001AD7                 db    0
.xdata$x:00001AD8                 db    0
.xdata$x:00001AD9                 db    0
.xdata$x:00001ADA                 db    0
.xdata$x:00001ADB                 db    0
.xdata$x:00001ADC                 db    0
.xdata$x:00001ADD                 db    0
.xdata$x:00001ADE                 db    0
.xdata$x:00001ADF                 db    0
.xdata$x:00001AE0                 db    0
.xdata$x:00001AE1                 db    0
.xdata$x:00001AE2                 db    0
.xdata$x:00001AE3                 db    0
.xdata$x:00001AE4                 db    0
.xdata$x:00001AE5                 db    0
.xdata$x:00001AE6                 db    0
.xdata$x:00001AE7                 db    0
.xdata$x:00001AE7 _xdata$x        ends
.xdata$x:00001AE7
.xdata$x:00001AE8 ; ===========================================================================
.xdata$x:00001AE8
.xdata$x:00001AE8 ; Segment type: Pure data
.xdata$x:00001AE8 ; Segment permissions: Read
.xdata$x:00001AE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001AE8                 assume cs:_xdata$x
.xdata$x:00001AE8                 ;org 1AE8h
.xdata$x:00001AE8 ; COMDAT (pick associative to section at 88C)
.xdata$x:00001AE8 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001AE8                                         ; DATA XREF: .xdata$x:00001AF8o
.xdata$x:00001AE9                 db 0FFh
.xdata$x:00001AEA                 db 0FFh
.xdata$x:00001AEB                 db 0FFh
.xdata$x:00001AEC                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001AF0 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001AF0                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001AF1                 db    5
.xdata$x:00001AF2                 db  93h ; 
.xdata$x:00001AF3                 db  19h
.xdata$x:00001AF4                 db    1
.xdata$x:00001AF5                 db    0
.xdata$x:00001AF6                 db    0
.xdata$x:00001AF7                 db    0
.xdata$x:00001AF8                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001AFC                 db    0
.xdata$x:00001AFD                 db    0
.xdata$x:00001AFE                 db    0
.xdata$x:00001AFF                 db    0
.xdata$x:00001B00                 db    0
.xdata$x:00001B01                 db    0
.xdata$x:00001B02                 db    0
.xdata$x:00001B03                 db    0
.xdata$x:00001B04                 db    0
.xdata$x:00001B05                 db    0
.xdata$x:00001B06                 db    0
.xdata$x:00001B07                 db    0
.xdata$x:00001B08                 db    0
.xdata$x:00001B09                 db    0
.xdata$x:00001B0A                 db    0
.xdata$x:00001B0B                 db    0
.xdata$x:00001B0C                 db    0
.xdata$x:00001B0D                 db    0
.xdata$x:00001B0E                 db    0
.xdata$x:00001B0F                 db    0
.xdata$x:00001B10                 db    0
.xdata$x:00001B11                 db    0
.xdata$x:00001B12                 db    0
.xdata$x:00001B13                 db    0
.xdata$x:00001B13 _xdata$x        ends
.xdata$x:00001B13
.xdata$x:00001B14 ; ===========================================================================
.xdata$x:00001B14
.xdata$x:00001B14 ; Segment type: Pure data
.xdata$x:00001B14 ; Segment permissions: Read
.xdata$x:00001B14 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001B14                 assume cs:_xdata$x
.xdata$x:00001B14                 ;org 1B14h
.xdata$x:00001B14 ; COMDAT (pick associative to section at 43C)
.xdata$x:00001B14 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00001B14                                         ; DATA XREF: .xdata$x:00001B24o
.xdata$x:00001B15                 db 0FFh
.xdata$x:00001B16                 db 0FFh
.xdata$x:00001B17                 db 0FFh
.xdata$x:00001B18                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00001B1C __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00001B1C                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00001B1D                 db    5
.xdata$x:00001B1E                 db  93h ; 
.xdata$x:00001B1F                 db  19h
.xdata$x:00001B20                 db    1
.xdata$x:00001B21                 db    0
.xdata$x:00001B22                 db    0
.xdata$x:00001B23                 db    0
.xdata$x:00001B24                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00001B28                 align 20h
.xdata$x:00001B28 _xdata$x        ends
.xdata$x:00001B28
.xdata$x:00001B40 ; ===========================================================================
.xdata$x:00001B40
.xdata$x:00001B40 ; Segment type: Pure data
.xdata$x:00001B40 ; Segment permissions: Read
.xdata$x:00001B40 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001B40                 assume cs:_xdata$x
.xdata$x:00001B40                 ;org 1B40h
.xdata$x:00001B40 ; COMDAT (pick associative to section at 814)
.xdata$x:00001B40 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001B40                                         ; DATA XREF: .xdata$x:00001B50o
.xdata$x:00001B41                 db 0FFh
.xdata$x:00001B42                 db 0FFh
.xdata$x:00001B43                 db 0FFh
.xdata$x:00001B44                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00001B48 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001B48                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00001B49                 db    5
.xdata$x:00001B4A                 db  93h ; 
.xdata$x:00001B4B                 db  19h
.xdata$x:00001B4C                 db    1
.xdata$x:00001B4D                 db    0
.xdata$x:00001B4E                 db    0
.xdata$x:00001B4F                 db    0
.xdata$x:00001B50                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00001B54                 db    0
.xdata$x:00001B55                 db    0
.xdata$x:00001B56                 db    0
.xdata$x:00001B57                 db    0
.xdata$x:00001B58                 db    0
.xdata$x:00001B59                 db    0
.xdata$x:00001B5A                 db    0
.xdata$x:00001B5B                 db    0
.xdata$x:00001B5C                 db    0
.xdata$x:00001B5D                 db    0
.xdata$x:00001B5E                 db    0
.xdata$x:00001B5F                 db    0
.xdata$x:00001B60                 db    0
.xdata$x:00001B61                 db    0
.xdata$x:00001B62                 db    0
.xdata$x:00001B63                 db    0
.xdata$x:00001B64                 db    0
.xdata$x:00001B65                 db    0
.xdata$x:00001B66                 db    0
.xdata$x:00001B67                 db    0
.xdata$x:00001B68                 db    0
.xdata$x:00001B69                 db    0
.xdata$x:00001B6A                 db    0
.xdata$x:00001B6B                 db    0
.xdata$x:00001B6B _xdata$x        ends
.xdata$x:00001B6B
.xdata$x:00001B6C ; ===========================================================================
.xdata$x:00001B6C
.xdata$x:00001B6C ; Segment type: Pure data
.xdata$x:00001B6C ; Segment permissions: Read
.xdata$x:00001B6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001B6C                 assume cs:_xdata$x
.xdata$x:00001B6C                 ;org 1B6Ch
.xdata$x:00001B6C ; COMDAT (pick associative to section at 578)
.xdata$x:00001B6C __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00001B6C                                         ; DATA XREF: .xdata$x:00001B7Co
.xdata$x:00001B6D                 db 0FFh
.xdata$x:00001B6E                 db 0FFh
.xdata$x:00001B6F                 db 0FFh
.xdata$x:00001B70                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00001B74 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00001B74                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00001B75                 db    5
.xdata$x:00001B76                 db  93h ; 
.xdata$x:00001B77                 db  19h
.xdata$x:00001B78                 db    1
.xdata$x:00001B79                 db    0
.xdata$x:00001B7A                 db    0
.xdata$x:00001B7B                 db    0
.xdata$x:00001B7C                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00001B80                 db    0
.xdata$x:00001B81                 db    0
.xdata$x:00001B82                 db    0
.xdata$x:00001B83                 db    0
.xdata$x:00001B84                 db    0
.xdata$x:00001B85                 db    0
.xdata$x:00001B86                 db    0
.xdata$x:00001B87                 db    0
.xdata$x:00001B88                 db    0
.xdata$x:00001B89                 db    0
.xdata$x:00001B8A                 db    0
.xdata$x:00001B8B                 db    0
.xdata$x:00001B8C                 db    0
.xdata$x:00001B8D                 db    0
.xdata$x:00001B8E                 db    0
.xdata$x:00001B8F                 db    0
.xdata$x:00001B90                 db    0
.xdata$x:00001B91                 db    0
.xdata$x:00001B92                 db    0
.xdata$x:00001B93                 db    0
.xdata$x:00001B94                 db    0
.xdata$x:00001B95                 db    0
.xdata$x:00001B96                 db    0
.xdata$x:00001B97                 db    0
.xdata$x:00001B97 _xdata$x        ends
.xdata$x:00001B97
.xdata$x:00001B98 ; ===========================================================================
.xdata$x:00001B98
.xdata$x:00001B98 ; Segment type: Pure data
.xdata$x:00001B98 ; Segment permissions: Read
.xdata$x:00001B98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001B98                 assume cs:_xdata$x
.xdata$x:00001B98                 ;org 1B98h
.xdata$x:00001B98 ; COMDAT (pick associative to section at 8FC)
.xdata$x:00001B98 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00001B98                                         ; DATA XREF: .xdata$x:00001BA8o
.xdata$x:00001B99                 db 0FFh
.xdata$x:00001B9A                 db 0FFh
.xdata$x:00001B9B                 db 0FFh
.xdata$x:00001B9C                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00001BA0 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00001BA0                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00001BA1                 db    5
.xdata$x:00001BA2                 db  93h ; 
.xdata$x:00001BA3                 db  19h
.xdata$x:00001BA4                 db    1
.xdata$x:00001BA5                 db    0
.xdata$x:00001BA6                 db    0
.xdata$x:00001BA7                 db    0
.xdata$x:00001BA8                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00001BAC                 db    0
.xdata$x:00001BAD                 db    0
.xdata$x:00001BAE                 db    0
.xdata$x:00001BAF                 db    0
.xdata$x:00001BB0                 db    0
.xdata$x:00001BB1                 db    0
.xdata$x:00001BB2                 db    0
.xdata$x:00001BB3                 db    0
.xdata$x:00001BB4                 db    0
.xdata$x:00001BB5                 db    0
.xdata$x:00001BB6                 db    0
.xdata$x:00001BB7                 db    0
.xdata$x:00001BB8                 db    0
.xdata$x:00001BB9                 db    0
.xdata$x:00001BBA                 db    0
.xdata$x:00001BBB                 db    0
.xdata$x:00001BBC                 db    0
.xdata$x:00001BBD                 db    0
.xdata$x:00001BBE                 db    0
.xdata$x:00001BBF                 db    0
.xdata$x:00001BC0                 db    0
.xdata$x:00001BC1                 db    0
.xdata$x:00001BC2                 db    0
.xdata$x:00001BC3                 db    0
.xdata$x:00001BC3 _xdata$x        ends
.xdata$x:00001BC3
.xdata$x:00001BC4 ; ===========================================================================
.xdata$x:00001BC4
.xdata$x:00001BC4 ; Segment type: Pure data
.xdata$x:00001BC4 ; Segment permissions: Read
.xdata$x:00001BC4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001BC4                 assume cs:_xdata$x
.xdata$x:00001BC4                 ;org 1BC4h
.xdata$x:00001BC4 ; COMDAT (pick associative to section at D74)
.xdata$x:00001BC4 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00001BC4                                         ; DATA XREF: .xdata$x:00001C4Co
.xdata$x:00001BC5                 db    0
.xdata$x:00001BC6                 db    0
.xdata$x:00001BC7                 db    0
.xdata$x:00001BC8                 db    0
.xdata$x:00001BC9                 db    0
.xdata$x:00001BCA                 db    0
.xdata$x:00001BCB                 db    0
.xdata$x:00001BCC                 db    0
.xdata$x:00001BCD                 db    0
.xdata$x:00001BCE                 db    0
.xdata$x:00001BCF                 db    0
.xdata$x:00001BD0                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00001BD4 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00001BD4                                         ; DATA XREF: .xdata$x:00001C38o
.xdata$x:00001BD5                 db    0
.xdata$x:00001BD6                 db    0
.xdata$x:00001BD7                 db    0
.xdata$x:00001BD8                 db    0
.xdata$x:00001BD9                 db    0
.xdata$x:00001BDA                 db    0
.xdata$x:00001BDB                 db    0
.xdata$x:00001BDC                 db    0
.xdata$x:00001BDD                 db    0
.xdata$x:00001BDE                 db    0
.xdata$x:00001BDF                 db    0
.xdata$x:00001BE0                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00001BE4 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00001BE4                                         ; DATA XREF: .xdata$x:00001C0Co
.xdata$x:00001BE5                 db 0FFh
.xdata$x:00001BE6                 db 0FFh
.xdata$x:00001BE7                 db 0FFh
.xdata$x:00001BE8                 db    0
.xdata$x:00001BE9                 db    0
.xdata$x:00001BEA                 db    0
.xdata$x:00001BEB                 db    0
.xdata$x:00001BEC                 db 0FFh
.xdata$x:00001BED                 db 0FFh
.xdata$x:00001BEE                 db 0FFh
.xdata$x:00001BEF                 db 0FFh
.xdata$x:00001BF0                 db    0
.xdata$x:00001BF1                 db    0
.xdata$x:00001BF2                 db    0
.xdata$x:00001BF3                 db    0
.xdata$x:00001BF4                 db    1
.xdata$x:00001BF5                 db    0
.xdata$x:00001BF6                 db    0
.xdata$x:00001BF7                 db    0
.xdata$x:00001BF8                 db    0
.xdata$x:00001BF9                 db    0
.xdata$x:00001BFA                 db    0
.xdata$x:00001BFB                 db    0
.xdata$x:00001BFC                 db    1
.xdata$x:00001BFD                 db    0
.xdata$x:00001BFE                 db    0
.xdata$x:00001BFF                 db    0
.xdata$x:00001C00                 db    0
.xdata$x:00001C01                 db    0
.xdata$x:00001C02                 db    0
.xdata$x:00001C03                 db    0
.xdata$x:00001C04 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00001C04                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00001C05                 db    5
.xdata$x:00001C06                 db  93h ; 
.xdata$x:00001C07                 db  19h
.xdata$x:00001C08                 db    4
.xdata$x:00001C09                 db    0
.xdata$x:00001C0A                 db    0
.xdata$x:00001C0B                 db    0
.xdata$x:00001C0C                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001C10                 db    2
.xdata$x:00001C11                 db    0
.xdata$x:00001C12                 db    0
.xdata$x:00001C13                 db    0
.xdata$x:00001C14                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001C18                 db    0
.xdata$x:00001C19                 db    0
.xdata$x:00001C1A                 db    0
.xdata$x:00001C1B                 db    0
.xdata$x:00001C1C                 db    0
.xdata$x:00001C1D                 db    0
.xdata$x:00001C1E                 db    0
.xdata$x:00001C1F                 db    0
.xdata$x:00001C20                 db    0
.xdata$x:00001C21                 db    0
.xdata$x:00001C22                 db    0
.xdata$x:00001C23                 db    0
.xdata$x:00001C24                 db    0
.xdata$x:00001C25                 db    0
.xdata$x:00001C26                 db    0
.xdata$x:00001C27                 db    0
.xdata$x:00001C28 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00001C28                                         ; DATA XREF: .xdata$x:00001C14o
.xdata$x:00001C29                 db    0
.xdata$x:00001C2A                 db    0
.xdata$x:00001C2B                 db    0
.xdata$x:00001C2C                 db    2
.xdata$x:00001C2D                 db    0
.xdata$x:00001C2E                 db    0
.xdata$x:00001C2F                 db    0
.xdata$x:00001C30                 db    3
.xdata$x:00001C31                 db    0
.xdata$x:00001C32                 db    0
.xdata$x:00001C33                 db    0
.xdata$x:00001C34                 db    1
.xdata$x:00001C35                 db    0
.xdata$x:00001C36                 db    0
.xdata$x:00001C37                 db    0
.xdata$x:00001C38                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00001C3C                 db    0
.xdata$x:00001C3D                 db    0
.xdata$x:00001C3E                 db    0
.xdata$x:00001C3F                 db    0
.xdata$x:00001C40                 db    0
.xdata$x:00001C41                 db    0
.xdata$x:00001C42                 db    0
.xdata$x:00001C43                 db    0
.xdata$x:00001C44                 db    3
.xdata$x:00001C45                 db    0
.xdata$x:00001C46                 db    0
.xdata$x:00001C47                 db    0
.xdata$x:00001C48                 db    1
.xdata$x:00001C49                 db    0
.xdata$x:00001C4A                 db    0
.xdata$x:00001C4B                 db    0
.xdata$x:00001C4C                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00001C4C _xdata$x        ends
.xdata$x:00001C4C
.xdata$x:00001C50 ; ===========================================================================
.xdata$x:00001C50
.xdata$x:00001C50 ; Segment type: Pure data
.xdata$x:00001C50 ; Segment permissions: Read
.xdata$x:00001C50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C50                 assume cs:_xdata$x
.xdata$x:00001C50                 ;org 1C50h
.xdata$x:00001C50 ; COMDAT (pick associative to section at 64C)
.xdata$x:00001C50 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001C50                                         ; DATA XREF: .xdata$x:00001C60o
.xdata$x:00001C51                 db 0FFh
.xdata$x:00001C52                 db 0FFh
.xdata$x:00001C53                 db 0FFh
.xdata$x:00001C54                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00001C58 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001C58                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00001C59                 db    5
.xdata$x:00001C5A                 db  93h ; 
.xdata$x:00001C5B                 db  19h
.xdata$x:00001C5C                 db    1
.xdata$x:00001C5D                 db    0
.xdata$x:00001C5E                 db    0
.xdata$x:00001C5F                 db    0
.xdata$x:00001C60                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00001C64                 db    0
.xdata$x:00001C65                 db    0
.xdata$x:00001C66                 db    0
.xdata$x:00001C67                 db    0
.xdata$x:00001C68                 db    0
.xdata$x:00001C69                 db    0
.xdata$x:00001C6A                 db    0
.xdata$x:00001C6B                 db    0
.xdata$x:00001C6C                 db    0
.xdata$x:00001C6D                 db    0
.xdata$x:00001C6E                 db    0
.xdata$x:00001C6F                 db    0
.xdata$x:00001C70                 db    0
.xdata$x:00001C71                 db    0
.xdata$x:00001C72                 db    0
.xdata$x:00001C73                 db    0
.xdata$x:00001C74                 db    0
.xdata$x:00001C75                 db    0
.xdata$x:00001C76                 db    0
.xdata$x:00001C77                 db    0
.xdata$x:00001C78                 db    0
.xdata$x:00001C79                 db    0
.xdata$x:00001C7A                 db    0
.xdata$x:00001C7B                 db    0
.xdata$x:00001C7B _xdata$x        ends
.xdata$x:00001C7B
.xdata$x:00001C7C ; ===========================================================================
.xdata$x:00001C7C
.xdata$x:00001C7C ; Segment type: Pure data
.xdata$x:00001C7C ; Segment permissions: Read
.xdata$x:00001C7C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C7C                 assume cs:_xdata$x
.xdata$x:00001C7C                 ;org 1C7Ch
.xdata$x:00001C7C ; COMDAT (pick associative to section at 1794)
.xdata$x:00001C7C __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001C7C                                         ; DATA XREF: .xdata$x:00001C8Co
.xdata$x:00001C7D                 db 0FFh
.xdata$x:00001C7E                 db 0FFh
.xdata$x:00001C7F                 db 0FFh
.xdata$x:00001C80                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001C84 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001C84                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001C85                 db    5
.xdata$x:00001C86                 db  93h ; 
.xdata$x:00001C87                 db  19h
.xdata$x:00001C88                 db    1
.xdata$x:00001C89                 db    0
.xdata$x:00001C8A                 db    0
.xdata$x:00001C8B                 db    0
.xdata$x:00001C8C                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001C90                 db    0
.xdata$x:00001C91                 db    0
.xdata$x:00001C92                 db    0
.xdata$x:00001C93                 db    0
.xdata$x:00001C94                 db    0
.xdata$x:00001C95                 db    0
.xdata$x:00001C96                 db    0
.xdata$x:00001C97                 db    0
.xdata$x:00001C98                 db    0
.xdata$x:00001C99                 db    0
.xdata$x:00001C9A                 db    0
.xdata$x:00001C9B                 db    0
.xdata$x:00001C9C                 db    0
.xdata$x:00001C9D                 db    0
.xdata$x:00001C9E                 db    0
.xdata$x:00001C9F                 db    0
.xdata$x:00001CA0                 db    0
.xdata$x:00001CA1                 db    0
.xdata$x:00001CA2                 db    0
.xdata$x:00001CA3                 db    0
.xdata$x:00001CA4                 db    0
.xdata$x:00001CA5                 db    0
.xdata$x:00001CA6                 db    0
.xdata$x:00001CA7                 db    0
.xdata$x:00001CA7 _xdata$x        ends
.xdata$x:00001CA7
.xdata$x:00001CA8 ; ===========================================================================
.xdata$x:00001CA8
.xdata$x:00001CA8 ; Segment type: Pure data
.xdata$x:00001CA8 ; Segment permissions: Read
.xdata$x:00001CA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001CA8                 assume cs:_xdata$x
.xdata$x:00001CA8                 ;org 1CA8h
.xdata$x:00001CA8 ; COMDAT (pick associative to section at 98C)
.xdata$x:00001CA8 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001CA8                                         ; DATA XREF: .xdata$x:00001CB8o
.xdata$x:00001CA9                 db 0FFh
.xdata$x:00001CAA                 db 0FFh
.xdata$x:00001CAB                 db 0FFh
.xdata$x:00001CAC                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00001CB0 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001CB0                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00001CB1                 db    5
.xdata$x:00001CB2                 db  93h ; 
.xdata$x:00001CB3                 db  19h
.xdata$x:00001CB4                 db    1
.xdata$x:00001CB5                 db    0
.xdata$x:00001CB6                 db    0
.xdata$x:00001CB7                 db    0
.xdata$x:00001CB8                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00001CBC                 db    0
.xdata$x:00001CBD                 db    0
.xdata$x:00001CBE                 db    0
.xdata$x:00001CBF                 db    0
.xdata$x:00001CC0                 db    0
.xdata$x:00001CC1                 db    0
.xdata$x:00001CC2                 db    0
.xdata$x:00001CC3                 db    0
.xdata$x:00001CC4                 db    0
.xdata$x:00001CC5                 db    0
.xdata$x:00001CC6                 db    0
.xdata$x:00001CC7                 db    0
.xdata$x:00001CC8                 db    0
.xdata$x:00001CC9                 db    0
.xdata$x:00001CCA                 db    0
.xdata$x:00001CCB                 db    0
.xdata$x:00001CCC                 db    0
.xdata$x:00001CCD                 db    0
.xdata$x:00001CCE                 db    0
.xdata$x:00001CCF                 db    0
.xdata$x:00001CD0                 db    0
.xdata$x:00001CD1                 db    0
.xdata$x:00001CD2                 db    0
.xdata$x:00001CD3                 db    0
.xdata$x:00001CD3 _xdata$x        ends
.xdata$x:00001CD3
.xdata$x:00001CD4 ; ===========================================================================
.xdata$x:00001CD4
.xdata$x:00001CD4 ; Segment type: Pure data
.xdata$x:00001CD4 ; Segment permissions: Read
.xdata$x:00001CD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001CD4                 assume cs:_xdata$x
.xdata$x:00001CD4                 ;org 1CD4h
.xdata$x:00001CD4 ; COMDAT (pick associative to section at 6C8)
.xdata$x:00001CD4 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001CD4                                         ; DATA XREF: .xdata$x:00001CE4o
.xdata$x:00001CD5                 db 0FFh
.xdata$x:00001CD6                 db 0FFh
.xdata$x:00001CD7                 db 0FFh
.xdata$x:00001CD8                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00001CDC __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001CDC                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00001CDD                 db    5
.xdata$x:00001CDE                 db  93h ; 
.xdata$x:00001CDF                 db  19h
.xdata$x:00001CE0                 db    1
.xdata$x:00001CE1                 db    0
.xdata$x:00001CE2                 db    0
.xdata$x:00001CE3                 db    0
.xdata$x:00001CE4                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00001CE8                 align 20h
.xdata$x:00001CE8 _xdata$x        ends
.xdata$x:00001CE8
.xdata$x:00001D00 ; ===========================================================================
.xdata$x:00001D00
.xdata$x:00001D00 ; Segment type: Pure data
.xdata$x:00001D00 ; Segment permissions: Read
.xdata$x:00001D00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D00                 assume cs:_xdata$x
.xdata$x:00001D00                 ;org 1D00h
.xdata$x:00001D00 ; COMDAT (pick associative to section at 184C)
.xdata$x:00001D00 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001D00                                         ; DATA XREF: .xdata$x:00001D10o
.xdata$x:00001D01                 db 0FFh
.xdata$x:00001D02                 db 0FFh
.xdata$x:00001D03                 db 0FFh
.xdata$x:00001D04                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001D08 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001D08                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001D09                 db    5
.xdata$x:00001D0A                 db  93h ; 
.xdata$x:00001D0B                 db  19h
.xdata$x:00001D0C                 db    1
.xdata$x:00001D0D                 db    0
.xdata$x:00001D0E                 db    0
.xdata$x:00001D0F                 db    0
.xdata$x:00001D10                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001D14                 db    0
.xdata$x:00001D15                 db    0
.xdata$x:00001D16                 db    0
.xdata$x:00001D17                 db    0
.xdata$x:00001D18                 db    0
.xdata$x:00001D19                 db    0
.xdata$x:00001D1A                 db    0
.xdata$x:00001D1B                 db    0
.xdata$x:00001D1C                 db    0
.xdata$x:00001D1D                 db    0
.xdata$x:00001D1E                 db    0
.xdata$x:00001D1F                 db    0
.xdata$x:00001D20                 db    0
.xdata$x:00001D21                 db    0
.xdata$x:00001D22                 db    0
.xdata$x:00001D23                 db    0
.xdata$x:00001D24                 db    0
.xdata$x:00001D25                 db    0
.xdata$x:00001D26                 db    0
.xdata$x:00001D27                 db    0
.xdata$x:00001D28                 db    0
.xdata$x:00001D29                 db    0
.xdata$x:00001D2A                 db    0
.xdata$x:00001D2B                 db    0
.xdata$x:00001D2B _xdata$x        ends
.xdata$x:00001D2B
.xdata$x:00001D2C ; ===========================================================================
.xdata$x:00001D2C
.xdata$x:00001D2C ; Segment type: Pure data
.xdata$x:00001D2C ; Segment permissions: Read
.xdata$x:00001D2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D2C                 assume cs:_xdata$x
.xdata$x:00001D2C                 ;org 1D2Ch
.xdata$x:00001D2C ; COMDAT (pick associative to section at 9FC)
.xdata$x:00001D2C __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001D2C                                         ; DATA XREF: .xdata$x:00001D3Co
.xdata$x:00001D2D                 db 0FFh
.xdata$x:00001D2E                 db 0FFh
.xdata$x:00001D2F                 db 0FFh
.xdata$x:00001D30                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00001D34 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001D34                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00001D35                 db    5
.xdata$x:00001D36                 db  93h ; 
.xdata$x:00001D37                 db  19h
.xdata$x:00001D38                 db    1
.xdata$x:00001D39                 db    0
.xdata$x:00001D3A                 db    0
.xdata$x:00001D3B                 db    0
.xdata$x:00001D3C                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00001D40                 db    0
.xdata$x:00001D41                 db    0
.xdata$x:00001D42                 db    0
.xdata$x:00001D43                 db    0
.xdata$x:00001D44                 db    0
.xdata$x:00001D45                 db    0
.xdata$x:00001D46                 db    0
.xdata$x:00001D47                 db    0
.xdata$x:00001D48                 db    0
.xdata$x:00001D49                 db    0
.xdata$x:00001D4A                 db    0
.xdata$x:00001D4B                 db    0
.xdata$x:00001D4C                 db    0
.xdata$x:00001D4D                 db    0
.xdata$x:00001D4E                 db    0
.xdata$x:00001D4F                 db    0
.xdata$x:00001D50                 db    0
.xdata$x:00001D51                 db    0
.xdata$x:00001D52                 db    0
.xdata$x:00001D53                 db    0
.xdata$x:00001D54                 db    0
.xdata$x:00001D55                 db    0
.xdata$x:00001D56                 db    0
.xdata$x:00001D57                 db    0
.xdata$x:00001D57 _xdata$x        ends
.xdata$x:00001D57
.xdata$x:00001D58 ; ===========================================================================
.xdata$x:00001D58
.xdata$x:00001D58 ; Segment type: Pure data
.xdata$x:00001D58 ; Segment permissions: Read
.xdata$x:00001D58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D58                 assume cs:_xdata$x
.xdata$x:00001D58                 ;org 1D58h
.xdata$x:00001D58 ; COMDAT (pick associative to section at 744)
.xdata$x:00001D58 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001D58                                         ; DATA XREF: .xdata$x:00001D68o
.xdata$x:00001D59                 db 0FFh
.xdata$x:00001D5A                 db 0FFh
.xdata$x:00001D5B                 db 0FFh
.xdata$x:00001D5C                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00001D60 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001D60                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00001D61                 db    5
.xdata$x:00001D62                 db  93h ; 
.xdata$x:00001D63                 db  19h
.xdata$x:00001D64                 db    1
.xdata$x:00001D65                 db    0
.xdata$x:00001D66                 db    0
.xdata$x:00001D67                 db    0
.xdata$x:00001D68                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00001D6C                 db    0
.xdata$x:00001D6D                 db    0
.xdata$x:00001D6E                 db    0
.xdata$x:00001D6F                 db    0
.xdata$x:00001D70                 db    0
.xdata$x:00001D71                 db    0
.xdata$x:00001D72                 db    0
.xdata$x:00001D73                 db    0
.xdata$x:00001D74                 db    0
.xdata$x:00001D75                 db    0
.xdata$x:00001D76                 db    0
.xdata$x:00001D77                 db    0
.xdata$x:00001D78                 db    0
.xdata$x:00001D79                 db    0
.xdata$x:00001D7A                 db    0
.xdata$x:00001D7B                 db    0
.xdata$x:00001D7C                 db    0
.xdata$x:00001D7D                 db    0
.xdata$x:00001D7E                 db    0
.xdata$x:00001D7F                 db    0
.xdata$x:00001D80                 db    0
.xdata$x:00001D81                 db    0
.xdata$x:00001D82                 db    0
.xdata$x:00001D83                 db    0
.xdata$x:00001D83 _xdata$x        ends
.xdata$x:00001D83
.xdata$x:00001D84 ; ===========================================================================
.xdata$x:00001D84
.xdata$x:00001D84 ; Segment type: Pure data
.xdata$x:00001D84 ; Segment permissions: Read
.xdata$x:00001D84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D84                 assume cs:_xdata$x
.xdata$x:00001D84                 ;org 1D84h
.xdata$x:00001D84 ; COMDAT (pick associative to section at 1910)
.xdata$x:00001D84 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001D84                                         ; DATA XREF: .xdata$x:00001D94o
.xdata$x:00001D85                 db 0FFh
.xdata$x:00001D86                 db 0FFh
.xdata$x:00001D87                 db 0FFh
.xdata$x:00001D88                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001D8C __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001D8C                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001D8D                 db    5
.xdata$x:00001D8E                 db  93h ; 
.xdata$x:00001D8F                 db  19h
.xdata$x:00001D90                 db    1
.xdata$x:00001D91                 db    0
.xdata$x:00001D92                 db    0
.xdata$x:00001D93                 db    0
.xdata$x:00001D94                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001D98                 db    0
.xdata$x:00001D99                 db    0
.xdata$x:00001D9A                 db    0
.xdata$x:00001D9B                 db    0
.xdata$x:00001D9C                 db    0
.xdata$x:00001D9D                 db    0
.xdata$x:00001D9E                 db    0
.xdata$x:00001D9F                 db    0
.xdata$x:00001DA0                 db    0
.xdata$x:00001DA1                 db    0
.xdata$x:00001DA2                 db    0
.xdata$x:00001DA3                 db    0
.xdata$x:00001DA4                 db    0
.xdata$x:00001DA5                 db    0
.xdata$x:00001DA6                 db    0
.xdata$x:00001DA7                 db    0
.xdata$x:00001DA8                 db    0
.xdata$x:00001DA9                 db    0
.xdata$x:00001DAA                 db    0
.xdata$x:00001DAB                 db    0
.xdata$x:00001DAC                 db    0
.xdata$x:00001DAD                 db    0
.xdata$x:00001DAE                 db    0
.xdata$x:00001DAF                 db    0
.xdata$x:00001DAF _xdata$x        ends
.xdata$x:00001DAF
.xdata$x:00001DB0 ; ===========================================================================
.xdata$x:00001DB0
.xdata$x:00001DB0 ; Segment type: Pure data
.xdata$x:00001DB0 ; Segment permissions: Read
.xdata$x:00001DB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001DB0                 assume cs:_xdata$x
.xdata$x:00001DB0                 ;org 1DB0h
.xdata$x:00001DB0 ; COMDAT (pick associative to section at A6C)
.xdata$x:00001DB0 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001DB0                                         ; DATA XREF: .xdata$x:00001DC0o
.xdata$x:00001DB1                 db 0FFh
.xdata$x:00001DB2                 db 0FFh
.xdata$x:00001DB3                 db 0FFh
.xdata$x:00001DB4                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00001DB8 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001DB8                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00001DB9                 db    5
.xdata$x:00001DBA                 db  93h ; 
.xdata$x:00001DBB                 db  19h
.xdata$x:00001DBC                 db    1
.xdata$x:00001DBD                 db    0
.xdata$x:00001DBE                 db    0
.xdata$x:00001DBF                 db    0
.xdata$x:00001DC0                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00001DC4                 db    0
.xdata$x:00001DC5                 db    0
.xdata$x:00001DC6                 db    0
.xdata$x:00001DC7                 db    0
.xdata$x:00001DC8                 db    0
.xdata$x:00001DC9                 db    0
.xdata$x:00001DCA                 db    0
.xdata$x:00001DCB                 db    0
.xdata$x:00001DCC                 db    0
.xdata$x:00001DCD                 db    0
.xdata$x:00001DCE                 db    0
.xdata$x:00001DCF                 db    0
.xdata$x:00001DD0                 db    0
.xdata$x:00001DD1                 db    0
.xdata$x:00001DD2                 db    0
.xdata$x:00001DD3                 db    0
.xdata$x:00001DD4                 db    0
.xdata$x:00001DD5                 db    0
.xdata$x:00001DD6                 db    0
.xdata$x:00001DD7                 db    0
.xdata$x:00001DD8                 db    0
.xdata$x:00001DD9                 db    0
.xdata$x:00001DDA                 db    0
.xdata$x:00001DDB                 db    0
.xdata$x:00001DDB _xdata$x        ends
.xdata$x:00001DDB
.xdata$x:00001DDC ; ===========================================================================
.xdata$x:00001DDC
.xdata$x:00001DDC ; Segment type: Pure data
.xdata$x:00001DDC ; Segment permissions: Read
.xdata$x:00001DDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001DDC                 assume cs:_xdata$x
.xdata$x:00001DDC                 ;org 1DDCh
.xdata$x:00001DDC ; COMDAT (pick associative to section at 320)
.xdata$x:00001DDC __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00001DDC                                         ; DATA XREF: .xdata$x:00001DECo
.xdata$x:00001DDD                 db 0FFh
.xdata$x:00001DDE                 db 0FFh
.xdata$x:00001DDF                 db 0FFh
.xdata$x:00001DE0                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00001DE4 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00001DE4                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00001DE5                 db    5
.xdata$x:00001DE6                 db  93h ; 
.xdata$x:00001DE7                 db  19h
.xdata$x:00001DE8                 db    1
.xdata$x:00001DE9                 db    0
.xdata$x:00001DEA                 db    0
.xdata$x:00001DEB                 db    0
.xdata$x:00001DEC                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00001DF0                 db    0
.xdata$x:00001DF1                 db    0
.xdata$x:00001DF2                 db    0
.xdata$x:00001DF3                 db    0
.xdata$x:00001DF4                 db    0
.xdata$x:00001DF5                 db    0
.xdata$x:00001DF6                 db    0
.xdata$x:00001DF7                 db    0
.xdata$x:00001DF8                 db    0
.xdata$x:00001DF9                 db    0
.xdata$x:00001DFA                 db    0
.xdata$x:00001DFB                 db    0
.xdata$x:00001DFC                 db    0
.xdata$x:00001DFD                 db    0
.xdata$x:00001DFE                 db    0
.xdata$x:00001DFF                 db    0
.xdata$x:00001E00                 db    0
.xdata$x:00001E01                 db    0
.xdata$x:00001E02                 db    0
.xdata$x:00001E03                 db    0
.xdata$x:00001E04                 db    0
.xdata$x:00001E05                 db    0
.xdata$x:00001E06                 db    0
.xdata$x:00001E07                 db    0
.xdata$x:00001E07 _xdata$x        ends
.xdata$x:00001E07
.xdata$x:00001E08 ; ===========================================================================
.xdata$x:00001E08
.xdata$x:00001E08 ; Segment type: Pure data
.xdata$x:00001E08 ; Segment permissions: Read
.xdata$x:00001E08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E08                 assume cs:_xdata$x
.xdata$x:00001E08                 ;org 1E08h
.xdata$x:00001E08 ; COMDAT (pick associative to section at 24C)
.xdata$x:00001E08 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00001E08                                         ; DATA XREF: .xdata$x:00001E18o
.xdata$x:00001E09                 db 0FFh
.xdata$x:00001E0A                 db 0FFh
.xdata$x:00001E0B                 db 0FFh
.xdata$x:00001E0C                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00001E10 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00001E10                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00001E11                 db    5
.xdata$x:00001E12                 db  93h ; 
.xdata$x:00001E13                 db  19h
.xdata$x:00001E14                 db    1
.xdata$x:00001E15                 db    0
.xdata$x:00001E16                 db    0
.xdata$x:00001E17                 db    0
.xdata$x:00001E18                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00001E1C                 db    0
.xdata$x:00001E1D                 db    0
.xdata$x:00001E1E                 db    0
.xdata$x:00001E1F                 db    0
.xdata$x:00001E20                 db    0
.xdata$x:00001E21                 db    0
.xdata$x:00001E22                 db    0
.xdata$x:00001E23                 db    0
.xdata$x:00001E24                 db    0
.xdata$x:00001E25                 db    0
.xdata$x:00001E26                 db    0
.xdata$x:00001E27                 db    0
.xdata$x:00001E28                 db    0
.xdata$x:00001E29                 db    0
.xdata$x:00001E2A                 db    0
.xdata$x:00001E2B                 db    0
.xdata$x:00001E2C                 db    0
.xdata$x:00001E2D                 db    0
.xdata$x:00001E2E                 db    0
.xdata$x:00001E2F                 db    0
.xdata$x:00001E30                 db    0
.xdata$x:00001E31                 db    0
.xdata$x:00001E32                 db    0
.xdata$x:00001E33                 db    0
.xdata$x:00001E33 _xdata$x        ends
.xdata$x:00001E33
.bss:00001E34 ; ===========================================================================
.bss:00001E34
.bss:00001E34 ; Segment type: Uninitialized
.bss:00001E34 ; Segment permissions: Read/Write
.bss:00001E34 _bss            segment byte public 'BSS' use32
.bss:00001E34                 assume cs:_bss
.bss:00001E34                 ;org 1E34h
.bss:00001E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001E34 _allocator_arg  db    ? ;
.bss:00001E35 _piecewise_construct db    ? ;
.bss:00001E36                 align 4
.bss:00001E36 _bss            ends
.bss:00001E36
.rdata:00001E38 ; ===========================================================================
.rdata:00001E38
.rdata:00001E38 ; Segment type: Pure data
.rdata:00001E38 ; Segment permissions: Read
.rdata:00001E38 _rdata          segment dword public 'DATA' use32
.rdata:00001E38                 assume cs:_rdata
.rdata:00001E38                 ;org 1E38h
.rdata:00001E38 ; COMDAT (pick largest)
.rdata:00001E38                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00001E3C                 public ??_7error_category@std@@6B@
.rdata:00001E3C ; const std::error_category::`vftable'
.rdata:00001E3C ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00001E3C                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00001E3C                                         ; std::error_category::~error_category(void)+Ao
.rdata:00001E3C                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00001E40                 dd offset __purecall
.rdata:00001E44                 dd offset __purecall
.rdata:00001E48                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001E4C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001E50                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001E50 _rdata          ends
.rdata:00001E50
.rdata:00001E54 ; ===========================================================================
.rdata:00001E54
.rdata:00001E54 ; Segment type: Pure data
.rdata:00001E54 ; Segment permissions: Read
.rdata:00001E54 _rdata          segment dword public 'DATA' use32
.rdata:00001E54                 assume cs:_rdata
.rdata:00001E54                 ;org 1E54h
.rdata:00001E54 ; COMDAT (pick largest)
.rdata:00001E54                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00001E58                 public ??_7_Generic_error_category@std@@6B@
.rdata:00001E58 ; const std::_Generic_error_category::`vftable'
.rdata:00001E58 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00001E58                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00001E58                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00001E5C                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00001E60                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00001E64                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001E68                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001E6C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001E6C _rdata          ends
.rdata:00001E6C
.rdata:00001E70 ; ===========================================================================
.rdata:00001E70
.rdata:00001E70 ; Segment type: Pure data
.rdata:00001E70 ; Segment permissions: Read
.rdata:00001E70 _rdata          segment dword public 'DATA' use32
.rdata:00001E70                 assume cs:_rdata
.rdata:00001E70                 ;org 1E70h
.rdata:00001E70 ; COMDAT (pick any)
.rdata:00001E70                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00001E70 ; `string'
.rdata:00001E70 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00001E70                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00001E70 _rdata          ends
.rdata:00001E70
.rdata:00001E78 ; ===========================================================================
.rdata:00001E78
.rdata:00001E78 ; Segment type: Pure data
.rdata:00001E78 ; Segment permissions: Read
.rdata:00001E78 _rdata          segment dword public 'DATA' use32
.rdata:00001E78                 assume cs:_rdata
.rdata:00001E78                 ;org 1E78h
.rdata:00001E78 ; COMDAT (pick any)
.rdata:00001E78                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00001E78 ; `string'
.rdata:00001E78 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00001E78                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_17E0o
.rdata:00001E78                                         ; std::_System_error_category::message(int):loc_195Co
.rdata:00001E86                 align 4
.rdata:00001E86 _rdata          ends
.rdata:00001E86
.rdata:00001E88 ; ===========================================================================
.rdata:00001E88
.rdata:00001E88 ; Segment type: Pure data
.rdata:00001E88 ; Segment permissions: Read
.rdata:00001E88 _rdata          segment dword public 'DATA' use32
.rdata:00001E88                 assume cs:_rdata
.rdata:00001E88                 ;org 1E88h
.rdata:00001E88 ; COMDAT (pick largest)
.rdata:00001E88                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00001E8C                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00001E8C ; const std::_Iostream_error_category::`vftable'
.rdata:00001E8C ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00001E8C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00001E8C                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00001E90                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00001E94                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00001E98                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001E9C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001EA0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001EA0 _rdata          ends
.rdata:00001EA0
.rdata:00001EA4 ; ===========================================================================
.rdata:00001EA4
.rdata:00001EA4 ; Segment type: Pure data
.rdata:00001EA4 ; Segment permissions: Read
.rdata:00001EA4 _rdata          segment dword public 'DATA' use32
.rdata:00001EA4                 assume cs:_rdata
.rdata:00001EA4                 ;org 1EA4h
.rdata:00001EA4 ; COMDAT (pick any)
.rdata:00001EA4                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00001EA4 ; `string'
.rdata:00001EA4 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00001EA4                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00001EAD                 align 10h
.rdata:00001EAD _rdata          ends
.rdata:00001EAD
.rdata:00001EB0 ; ===========================================================================
.rdata:00001EB0
.rdata:00001EB0 ; Segment type: Pure data
.rdata:00001EB0 ; Segment permissions: Read
.rdata:00001EB0 _rdata          segment dword public 'DATA' use32
.rdata:00001EB0                 assume cs:_rdata
.rdata:00001EB0                 ;org 1EB0h
.rdata:00001EB0 ; COMDAT (pick any)
.rdata:00001EB0                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00001EB0 ; char `string'[]
.rdata:00001EB0 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00001EB0                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00001EC6                 align 4
.rdata:00001EC6 _rdata          ends
.rdata:00001EC6
.rdata:00001EC8 ; ===========================================================================
.rdata:00001EC8
.rdata:00001EC8 ; Segment type: Pure data
.rdata:00001EC8 ; Segment permissions: Read
.rdata:00001EC8 _rdata          segment dword public 'DATA' use32
.rdata:00001EC8                 assume cs:_rdata
.rdata:00001EC8                 ;org 1EC8h
.rdata:00001EC8 ; COMDAT (pick largest)
.rdata:00001EC8                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00001ECC                 public ??_7_System_error_category@std@@6B@
.rdata:00001ECC ; const std::_System_error_category::`vftable'
.rdata:00001ECC ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00001ECC                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00001ECC                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00001ED0                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00001ED4                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00001ED8                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00001EDC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001EE0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001EE0 _rdata          ends
.rdata:00001EE0
.rdata:00001EE4 ; ===========================================================================
.rdata:00001EE4
.rdata:00001EE4 ; Segment type: Pure data
.rdata:00001EE4 ; Segment permissions: Read
.rdata:00001EE4 _rdata          segment dword public 'DATA' use32
.rdata:00001EE4                 assume cs:_rdata
.rdata:00001EE4                 ;org 1EE4h
.rdata:00001EE4 ; COMDAT (pick any)
.rdata:00001EE4                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00001EE4 ; `string'
.rdata:00001EE4 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00001EE4                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00001EEB                 align 4
.rdata:00001EEB _rdata          ends
.rdata:00001EEB
.bss:00001EEC ; ===========================================================================
.bss:00001EEC
.bss:00001EEC ; Segment type: Uninitialized
.bss:00001EEC ; Segment permissions: Read/Write
.bss:00001EEC _bss            segment dword public 'BSS' use32
.bss:00001EEC                 assume cs:_bss
.bss:00001EEC                 ;org 1EECh
.bss:00001EEC ; COMDAT (pick any)
.bss:00001EEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001EEC                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00001EEC ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00001EEC ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00001EEC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00001EEC                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00001EED                 db    ? ;
.bss:00001EEE                 db    ? ;
.bss:00001EEF                 db    ? ;
.bss:00001EEF _bss            ends
.bss:00001EEF
.bss:00001EF0 ; ===========================================================================
.bss:00001EF0
.bss:00001EF0 ; Segment type: Uninitialized
.bss:00001EF0 ; Segment permissions: Read/Write
.bss:00001EF0 _bss            segment dword public 'BSS' use32
.bss:00001EF0                 assume cs:_bss
.bss:00001EF0                 ;org 1EF0h
.bss:00001EF0 ; COMDAT (pick any)
.bss:00001EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001EF0                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00001EF0 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00001EF0 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00001EF0                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00001EF0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00001EF1                 db    ? ;
.bss:00001EF2                 db    ? ;
.bss:00001EF3                 db    ? ;
.bss:00001EF3 _bss            ends
.bss:00001EF3
.bss:00001EF4 ; ===========================================================================
.bss:00001EF4
.bss:00001EF4 ; Segment type: Uninitialized
.bss:00001EF4 ; Segment permissions: Read/Write
.bss:00001EF4 _bss            segment dword public 'BSS' use32
.bss:00001EF4                 assume cs:_bss
.bss:00001EF4                 ;org 1EF4h
.bss:00001EF4 ; COMDAT (pick any)
.bss:00001EF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001EF4                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00001EF4 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00001EF4 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00001EF4                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00001EF4                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00001EF5                 db    ? ;
.bss:00001EF6                 db    ? ;
.bss:00001EF7                 db    ? ;
.bss:00001EF7 _bss            ends
.bss:00001EF7
.bss:00001EF8 ; ===========================================================================
.bss:00001EF8
.bss:00001EF8 ; Segment type: Uninitialized
.bss:00001EF8 ; Segment permissions: Read/Write
.bss:00001EF8 _bss            segment dword public 'BSS' use32
.bss:00001EF8                 assume cs:_bss
.bss:00001EF8                 ;org 1EF8h
.bss:00001EF8 ; COMDAT (pick any)
.bss:00001EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001EF8                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00001EF8 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00001EF8 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00001EF8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00001EF9                 db    ? ;
.bss:00001EFA                 db    ? ;
.bss:00001EFB                 db    ? ;
.bss:00001EFB _bss            ends
.bss:00001EFB
.bss:00001EFC ; ===========================================================================
.bss:00001EFC
.bss:00001EFC ; Segment type: Uninitialized
.bss:00001EFC ; Segment permissions: Read/Write
.bss:00001EFC _bss            segment dword public 'BSS' use32
.bss:00001EFC                 assume cs:_bss
.bss:00001EFC                 ;org 1EFCh
.bss:00001EFC ; COMDAT (pick any)
.bss:00001EFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001EFC                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00001EFC ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00001EFC ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00001EFC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00001EFD                 db    ? ;
.bss:00001EFE                 db    ? ;
.bss:00001EFF                 db    ? ;
.bss:00001EFF _bss            ends
.bss:00001EFF
.rdata:00001F00 ; ===========================================================================
.rdata:00001F00
.rdata:00001F00 ; Segment type: Pure data
.rdata:00001F00 ; Segment permissions: Read
.rdata:00001F00 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00001F00 _rdata          segment para public 'DATA' use32
.rdata:00001F00                 assume cs:_rdata
.rdata:00001F00                 ;org 1F00h
.rdata:00001F00 ; COMDAT (pick any)
.rdata:00001F00                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00001F00 ; wchar_t `string'
.rdata:00001F00 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00001F00                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00001F00                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00001F00                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00001F00                 unicode 0, <clude\xstring>,0
.rdata:00001F8E                 align 10h
.rdata:00001F8E _rdata          ends
.rdata:00001F8E
.bss:00001F90 ; ===========================================================================
.bss:00001F90
.bss:00001F90 ; Segment type: Uninitialized
.bss:00001F90 ; Segment permissions: Read/Write
.bss:00001F90 _bss            segment dword public 'BSS' use32
.bss:00001F90                 assume cs:_bss
.bss:00001F90                 ;org 1F90h
.bss:00001F90 ; COMDAT (pick any)
.bss:00001F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001F90                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00001F90 ; std::locale::id std::numpunct<char>::id
.bss:00001F90 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00001F90                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00001F91                 db    ? ;
.bss:00001F92                 db    ? ;
.bss:00001F93                 db    ? ;
.bss:00001F93 _bss            ends
.bss:00001F93
.bss:00001F94 ; ===========================================================================
.bss:00001F94
.bss:00001F94 ; Segment type: Uninitialized
.bss:00001F94 ; Segment permissions: Read/Write
.bss:00001F94 _bss            segment dword public 'BSS' use32
.bss:00001F94                 assume cs:_bss
.bss:00001F94                 ;org 1F94h
.bss:00001F94 ; COMDAT (pick any)
.bss:00001F94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00001F94                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00001F94 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00001F94 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00001F94                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00001F95                 db    ? ;
.bss:00001F96                 db    ? ;
.bss:00001F97                 db    ? ;
.bss:00001F97 _bss            ends
.bss:00001F97
.rdata:00001F98 ; ===========================================================================
.rdata:00001F98
.rdata:00001F98 ; Segment type: Pure data
.rdata:00001F98 ; Segment permissions: Read
.rdata:00001F98 _rdata          segment dword public 'DATA' use32
.rdata:00001F98                 assume cs:_rdata
.rdata:00001F98                 ;org 1F98h
.rdata:00001F98 ; COMDAT (pick any)
.rdata:00001F98                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00001F98 ; char `string'[]
.rdata:00001F98 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00001F98                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00001F98 _rdata          ends
.rdata:00001F98
.rdata:00001FA8 ; ===========================================================================
.rdata:00001FA8
.rdata:00001FA8 ; Segment type: Pure data
.rdata:00001FA8 ; Segment permissions: Read
.rdata:00001FA8 _rdata          segment dword public 'DATA' use32
.rdata:00001FA8                 assume cs:_rdata
.rdata:00001FA8                 ;org 1FA8h
.rdata:00001FA8 ; COMDAT (pick any)
.rdata:00001FA8                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00001FA8 ; char `string'[]
.rdata:00001FA8 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00001FA8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00001FA8 _rdata          ends
.rdata:00001FA8
.rdata:00001FC0 ; ===========================================================================
.rdata:00001FC0
.rdata:00001FC0 ; Segment type: Pure data
.rdata:00001FC0 ; Segment permissions: Read
.rdata:00001FC0 _rdata          segment dword public 'DATA' use32
.rdata:00001FC0                 assume cs:_rdata
.rdata:00001FC0                 ;org 1FC0h
.rdata:00001FC0 ; COMDAT (pick any)
.rdata:00001FC0                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00001FC0 ; wchar_t `string'
.rdata:00001FC0 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00001FC0                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00001FC0                 unicode 0, <invalid null pointer>,0
.rdata:00001FEA                 align 4
.rdata:00001FEA _rdata          ends
.rdata:00001FEA
.rdata$r:00001FEC ; ===========================================================================
.rdata$r:00001FEC
.rdata$r:00001FEC ; Segment type: Pure data
.rdata$r:00001FEC ; Segment permissions: Read
.rdata$r:00001FEC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FEC                 assume cs:_rdata$r
.rdata$r:00001FEC                 ;org 1FECh
.rdata$r:00001FEC ; COMDAT (pick any)
.rdata$r:00001FEC                 public ??_R4error_category@std@@6B@
.rdata$r:00001FEC ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00001FEC ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00001E38o
.rdata$r:00001FED                 db    0
.rdata$r:00001FEE                 db    0
.rdata$r:00001FEF                 db    0
.rdata$r:00001FF0                 db    0
.rdata$r:00001FF1                 db    0
.rdata$r:00001FF2                 db    0
.rdata$r:00001FF3                 db    0
.rdata$r:00001FF4                 db    0
.rdata$r:00001FF5                 db    0
.rdata$r:00001FF6                 db    0
.rdata$r:00001FF7                 db    0
.rdata$r:00001FF8                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00001FFC                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001FFC _rdata$r        ends
.rdata$r:00001FFC
.data$r:00002000 ; ===========================================================================
.data$r:00002000
.data$r:00002000 ; Segment type: Pure data
.data$r:00002000 ; Segment permissions: Read/Write
.data$r:00002000 _data$r         segment dword public 'DATA' use32
.data$r:00002000                 assume cs:_data$r
.data$r:00002000                 ;org 2000h
.data$r:00002000 ; COMDAT (pick any)
.data$r:00002000                 public ??_R0?AVerror_category@std@@@8
.data$r:00002000 ; class std::error_category `RTTI Type Descriptor'
.data$r:00002000 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002000                                         ; DATA XREF: .rdata$r:00001FF8o
.data$r:00002000                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002000                                         ; const type_info::`vftable'
.data$r:00002004                 align 8
.data$r:00002008 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00002021                 align 4
.data$r:00002021 _data$r         ends
.data$r:00002021
.rdata$r:00002024 ; ===========================================================================
.rdata$r:00002024
.rdata$r:00002024 ; Segment type: Pure data
.rdata$r:00002024 ; Segment permissions: Read
.rdata$r:00002024 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002024                 assume cs:_rdata$r
.rdata$r:00002024                 ;org 2024h
.rdata$r:00002024 ; COMDAT (pick any)
.rdata$r:00002024                 public ??_R3error_category@std@@8
.rdata$r:00002024 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002024 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00001FFCo
.rdata$r:00002024                                         ; .rdata$r:00002054o
.rdata$r:00002025                 db    0
.rdata$r:00002026                 db    0
.rdata$r:00002027                 db    0
.rdata$r:00002028                 db    0
.rdata$r:00002029                 db    0
.rdata$r:0000202A                 db    0
.rdata$r:0000202B                 db    0
.rdata$r:0000202C                 db    1
.rdata$r:0000202D                 db    0
.rdata$r:0000202E                 db    0
.rdata$r:0000202F                 db    0
.rdata$r:00002030                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002030 _rdata$r        ends
.rdata$r:00002030
.rdata$r:00002034 ; ===========================================================================
.rdata$r:00002034
.rdata$r:00002034 ; Segment type: Pure data
.rdata$r:00002034 ; Segment permissions: Read
.rdata$r:00002034 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002034                 assume cs:_rdata$r
.rdata$r:00002034                 ;org 2034h
.rdata$r:00002034 ; COMDAT (pick any)
.rdata$r:00002034                 public ??_R2error_category@std@@8
.rdata$r:00002034 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002034 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002034                                         ; DATA XREF: .rdata$r:00002030o
.rdata$r:00002034                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002038                 db    0
.rdata$r:00002039                 align 4
.rdata$r:00002039 _rdata$r        ends
.rdata$r:00002039
.rdata$r:0000203C ; ===========================================================================
.rdata$r:0000203C
.rdata$r:0000203C ; Segment type: Pure data
.rdata$r:0000203C ; Segment permissions: Read
.rdata$r:0000203C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000203C                 assume cs:_rdata$r
.rdata$r:0000203C                 ;org 203Ch
.rdata$r:0000203C ; COMDAT (pick any)
.rdata$r:0000203C                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000203C ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000203C ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000203C                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000203C                                         ; .rdata$r:000020ACo ...
.rdata$r:0000203C                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002040                 db    0
.rdata$r:00002041                 db    0
.rdata$r:00002042                 db    0
.rdata$r:00002043                 db    0
.rdata$r:00002044                 db    0
.rdata$r:00002045                 db    0
.rdata$r:00002046                 db    0
.rdata$r:00002047                 db    0
.rdata$r:00002048                 db 0FFh
.rdata$r:00002049                 db 0FFh
.rdata$r:0000204A                 db 0FFh
.rdata$r:0000204B                 db 0FFh
.rdata$r:0000204C                 db    0
.rdata$r:0000204D                 db    0
.rdata$r:0000204E                 db    0
.rdata$r:0000204F                 db    0
.rdata$r:00002050                 db  40h ; @
.rdata$r:00002051                 db    0
.rdata$r:00002052                 db    0
.rdata$r:00002053                 db    0
.rdata$r:00002054                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002054 _rdata$r        ends
.rdata$r:00002054
.rdata$r:00002058 ; ===========================================================================
.rdata$r:00002058
.rdata$r:00002058 ; Segment type: Pure data
.rdata$r:00002058 ; Segment permissions: Read
.rdata$r:00002058 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002058                 assume cs:_rdata$r
.rdata$r:00002058                 ;org 2058h
.rdata$r:00002058 ; COMDAT (pick any)
.rdata$r:00002058                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00002058 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00002058 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00002058                                         ; DATA XREF: .rdata:00001E54o
.rdata$r:00002059                 db    0
.rdata$r:0000205A                 db    0
.rdata$r:0000205B                 db    0
.rdata$r:0000205C                 db    0
.rdata$r:0000205D                 db    0
.rdata$r:0000205E                 db    0
.rdata$r:0000205F                 db    0
.rdata$r:00002060                 db    0
.rdata$r:00002061                 db    0
.rdata$r:00002062                 db    0
.rdata$r:00002063                 db    0
.rdata$r:00002064                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002068                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002068 _rdata$r        ends
.rdata$r:00002068
.data$r:0000206C ; ===========================================================================
.data$r:0000206C
.data$r:0000206C ; Segment type: Pure data
.data$r:0000206C ; Segment permissions: Read/Write
.data$r:0000206C _data$r         segment dword public 'DATA' use32
.data$r:0000206C                 assume cs:_data$r
.data$r:0000206C                 ;org 206Ch
.data$r:0000206C ; COMDAT (pick any)
.data$r:0000206C                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000206C ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000206C ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000206C                                         ; DATA XREF: .rdata$r:00002064o
.data$r:0000206C                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000206C                                         ; const type_info::`vftable'
.data$r:00002070                 db    0
.data$r:00002071                 db    0
.data$r:00002072                 db    0
.data$r:00002073                 db    0
.data$r:00002074                 db  2Eh ; .
.data$r:00002075                 db  3Fh ; ?
.data$r:00002076                 db  41h ; A
.data$r:00002077                 db  56h ; V
.data$r:00002078                 db  5Fh ; _
.data$r:00002079                 db  47h ; G
.data$r:0000207A                 db  65h ; e
.data$r:0000207B                 db  6Eh ; n
.data$r:0000207C                 db  65h ; e
.data$r:0000207D                 db  72h ; r
.data$r:0000207E                 db  69h ; i
.data$r:0000207F                 db  63h ; c
.data$r:00002080                 db  5Fh ; _
.data$r:00002081                 db  65h ; e
.data$r:00002082                 db  72h ; r
.data$r:00002083                 db  72h ; r
.data$r:00002084                 db  6Fh ; o
.data$r:00002085                 db  72h ; r
.data$r:00002086                 db  5Fh ; _
.data$r:00002087                 db  63h ; c
.data$r:00002088                 db  61h ; a
.data$r:00002089                 db  74h ; t
.data$r:0000208A                 db  65h ; e
.data$r:0000208B                 db  67h ; g
.data$r:0000208C                 db  6Fh ; o
.data$r:0000208D                 db  72h ; r
.data$r:0000208E                 db  79h ; y
.data$r:0000208F                 db  40h ; @
.data$r:00002090                 db  73h ; s
.data$r:00002091                 db  74h ; t
.data$r:00002092                 db  64h ; d
.data$r:00002093                 db  40h ; @
.data$r:00002094                 db  40h ; @
.data$r:00002095                 db    0
.data$r:00002096                 align 4
.data$r:00002096 _data$r         ends
.data$r:00002096
.rdata$r:00002098 ; ===========================================================================
.rdata$r:00002098
.rdata$r:00002098 ; Segment type: Pure data
.rdata$r:00002098 ; Segment permissions: Read
.rdata$r:00002098 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002098                 assume cs:_rdata$r
.rdata$r:00002098                 ;org 2098h
.rdata$r:00002098 ; COMDAT (pick any)
.rdata$r:00002098                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00002098 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002098 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00002098                                         ; DATA XREF: .rdata$r:00002068o
.rdata$r:00002098                                         ; .rdata$r:000020CCo
.rdata$r:00002099                 db    0
.rdata$r:0000209A                 db    0
.rdata$r:0000209B                 db    0
.rdata$r:0000209C                 db    0
.rdata$r:0000209D                 db    0
.rdata$r:0000209E                 db    0
.rdata$r:0000209F                 db    0
.rdata$r:000020A0                 db    2
.rdata$r:000020A1                 db    0
.rdata$r:000020A2                 db    0
.rdata$r:000020A3                 db    0
.rdata$r:000020A4                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000020A4 _rdata$r        ends
.rdata$r:000020A4
.rdata$r:000020A8 ; ===========================================================================
.rdata$r:000020A8
.rdata$r:000020A8 ; Segment type: Pure data
.rdata$r:000020A8 ; Segment permissions: Read
.rdata$r:000020A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000020A8                 assume cs:_rdata$r
.rdata$r:000020A8                 ;org 20A8h
.rdata$r:000020A8 ; COMDAT (pick any)
.rdata$r:000020A8                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000020A8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000020A8 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000020A8                                         ; DATA XREF: .rdata$r:000020A4o
.rdata$r:000020A8                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000020AC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000020B0                 db    0
.rdata$r:000020B1                 align 4
.rdata$r:000020B1 _rdata$r        ends
.rdata$r:000020B1
.rdata$r:000020B4 ; ===========================================================================
.rdata$r:000020B4
.rdata$r:000020B4 ; Segment type: Pure data
.rdata$r:000020B4 ; Segment permissions: Read
.rdata$r:000020B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000020B4                 assume cs:_rdata$r
.rdata$r:000020B4                 ;org 20B4h
.rdata$r:000020B4 ; COMDAT (pick any)
.rdata$r:000020B4                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000020B4 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000020B4 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000020B4                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000020B4                                         ; .rdata$r:00002124o ...
.rdata$r:000020B4                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000020B8                 db    1
.rdata$r:000020B9                 db    0
.rdata$r:000020BA                 db    0
.rdata$r:000020BB                 db    0
.rdata$r:000020BC                 db    0
.rdata$r:000020BD                 db    0
.rdata$r:000020BE                 db    0
.rdata$r:000020BF                 db    0
.rdata$r:000020C0                 db 0FFh
.rdata$r:000020C1                 db 0FFh
.rdata$r:000020C2                 db 0FFh
.rdata$r:000020C3                 db 0FFh
.rdata$r:000020C4                 db    0
.rdata$r:000020C5                 db    0
.rdata$r:000020C6                 db    0
.rdata$r:000020C7                 db    0
.rdata$r:000020C8                 db  40h ; @
.rdata$r:000020C9                 db    0
.rdata$r:000020CA                 db    0
.rdata$r:000020CB                 db    0
.rdata$r:000020CC                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000020CC _rdata$r        ends
.rdata$r:000020CC
.rdata$r:000020D0 ; ===========================================================================
.rdata$r:000020D0
.rdata$r:000020D0 ; Segment type: Pure data
.rdata$r:000020D0 ; Segment permissions: Read
.rdata$r:000020D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000020D0                 assume cs:_rdata$r
.rdata$r:000020D0                 ;org 20D0h
.rdata$r:000020D0 ; COMDAT (pick any)
.rdata$r:000020D0                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000020D0 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000020D0 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000020D0                                         ; DATA XREF: .rdata:00001E88o
.rdata$r:000020D1                 db    0
.rdata$r:000020D2                 db    0
.rdata$r:000020D3                 db    0
.rdata$r:000020D4                 db    0
.rdata$r:000020D5                 db    0
.rdata$r:000020D6                 db    0
.rdata$r:000020D7                 db    0
.rdata$r:000020D8                 db    0
.rdata$r:000020D9                 db    0
.rdata$r:000020DA                 db    0
.rdata$r:000020DB                 db    0
.rdata$r:000020DC                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000020E0                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000020E0 _rdata$r        ends
.rdata$r:000020E0
.data$r:000020E4 ; ===========================================================================
.data$r:000020E4
.data$r:000020E4 ; Segment type: Pure data
.data$r:000020E4 ; Segment permissions: Read/Write
.data$r:000020E4 _data$r         segment dword public 'DATA' use32
.data$r:000020E4                 assume cs:_data$r
.data$r:000020E4                 ;org 20E4h
.data$r:000020E4 ; COMDAT (pick any)
.data$r:000020E4                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000020E4 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000020E4 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000020E4                                         ; DATA XREF: .rdata$r:000020DCo
.data$r:000020E4                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000020E4                                         ; const type_info::`vftable'
.data$r:000020E8                 db    0
.data$r:000020E9                 db    0
.data$r:000020EA                 db    0
.data$r:000020EB                 db    0
.data$r:000020EC                 db  2Eh ; .
.data$r:000020ED                 db  3Fh ; ?
.data$r:000020EE                 db  41h ; A
.data$r:000020EF                 db  56h ; V
.data$r:000020F0                 db  5Fh ; _
.data$r:000020F1                 db  49h ; I
.data$r:000020F2                 db  6Fh ; o
.data$r:000020F3                 db  73h ; s
.data$r:000020F4                 db  74h ; t
.data$r:000020F5                 db  72h ; r
.data$r:000020F6                 db  65h ; e
.data$r:000020F7                 db  61h ; a
.data$r:000020F8                 db  6Dh ; m
.data$r:000020F9                 db  5Fh ; _
.data$r:000020FA                 db  65h ; e
.data$r:000020FB                 db  72h ; r
.data$r:000020FC                 db  72h ; r
.data$r:000020FD                 db  6Fh ; o
.data$r:000020FE                 db  72h ; r
.data$r:000020FF                 db  5Fh ; _
.data$r:00002100                 db  63h ; c
.data$r:00002101                 db  61h ; a
.data$r:00002102                 db  74h ; t
.data$r:00002103                 db  65h ; e
.data$r:00002104                 db  67h ; g
.data$r:00002105                 db  6Fh ; o
.data$r:00002106                 db  72h ; r
.data$r:00002107                 db  79h ; y
.data$r:00002108                 db  40h ; @
.data$r:00002109                 db  73h ; s
.data$r:0000210A                 db  74h ; t
.data$r:0000210B                 db  64h ; d
.data$r:0000210C                 db  40h ; @
.data$r:0000210D                 db  40h ; @
.data$r:0000210E                 db    0
.data$r:0000210F                 align 10h
.data$r:0000210F _data$r         ends
.data$r:0000210F
.rdata$r:00002110 ; ===========================================================================
.rdata$r:00002110
.rdata$r:00002110 ; Segment type: Pure data
.rdata$r:00002110 ; Segment permissions: Read
.rdata$r:00002110 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002110                 assume cs:_rdata$r
.rdata$r:00002110                 ;org 2110h
.rdata$r:00002110 ; COMDAT (pick any)
.rdata$r:00002110                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002110 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002110 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002110                                         ; DATA XREF: .rdata$r:000020E0o
.rdata$r:00002110                                         ; .rdata$r:00002148o
.rdata$r:00002111                 db    0
.rdata$r:00002112                 db    0
.rdata$r:00002113                 db    0
.rdata$r:00002114                 db    0
.rdata$r:00002115                 db    0
.rdata$r:00002116                 db    0
.rdata$r:00002117                 db    0
.rdata$r:00002118                 db    3
.rdata$r:00002119                 db    0
.rdata$r:0000211A                 db    0
.rdata$r:0000211B                 db    0
.rdata$r:0000211C                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000211C _rdata$r        ends
.rdata$r:0000211C
.rdata$r:00002120 ; ===========================================================================
.rdata$r:00002120
.rdata$r:00002120 ; Segment type: Pure data
.rdata$r:00002120 ; Segment permissions: Read
.rdata$r:00002120 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002120                 assume cs:_rdata$r
.rdata$r:00002120                 ;org 2120h
.rdata$r:00002120 ; COMDAT (pick any)
.rdata$r:00002120                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002120 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002120 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002120                                         ; DATA XREF: .rdata$r:0000211Co
.rdata$r:00002120                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002124                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002128                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000212C                 db    0
.rdata$r:0000212D                 align 10h
.rdata$r:0000212D _rdata$r        ends
.rdata$r:0000212D
.rdata$r:00002130 ; ===========================================================================
.rdata$r:00002130
.rdata$r:00002130 ; Segment type: Pure data
.rdata$r:00002130 ; Segment permissions: Read
.rdata$r:00002130 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002130                 assume cs:_rdata$r
.rdata$r:00002130                 ;org 2130h
.rdata$r:00002130 ; COMDAT (pick any)
.rdata$r:00002130                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002130 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002130 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002130                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002130                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002134                 db    2
.rdata$r:00002135                 db    0
.rdata$r:00002136                 db    0
.rdata$r:00002137                 db    0
.rdata$r:00002138                 db    0
.rdata$r:00002139                 db    0
.rdata$r:0000213A                 db    0
.rdata$r:0000213B                 db    0
.rdata$r:0000213C                 db 0FFh
.rdata$r:0000213D                 db 0FFh
.rdata$r:0000213E                 db 0FFh
.rdata$r:0000213F                 db 0FFh
.rdata$r:00002140                 db    0
.rdata$r:00002141                 db    0
.rdata$r:00002142                 db    0
.rdata$r:00002143                 db    0
.rdata$r:00002144                 db  40h ; @
.rdata$r:00002145                 db    0
.rdata$r:00002146                 db    0
.rdata$r:00002147                 db    0
.rdata$r:00002148                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002148 _rdata$r        ends
.rdata$r:00002148
.rdata$r:0000214C ; ===========================================================================
.rdata$r:0000214C
.rdata$r:0000214C ; Segment type: Pure data
.rdata$r:0000214C ; Segment permissions: Read
.rdata$r:0000214C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000214C                 assume cs:_rdata$r
.rdata$r:0000214C                 ;org 214Ch
.rdata$r:0000214C ; COMDAT (pick any)
.rdata$r:0000214C                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000214C ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000214C ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00001EC8o
.rdata$r:0000214D                 db    0
.rdata$r:0000214E                 db    0
.rdata$r:0000214F                 db    0
.rdata$r:00002150                 db    0
.rdata$r:00002151                 db    0
.rdata$r:00002152                 db    0
.rdata$r:00002153                 db    0
.rdata$r:00002154                 db    0
.rdata$r:00002155                 db    0
.rdata$r:00002156                 db    0
.rdata$r:00002157                 db    0
.rdata$r:00002158                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000215C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000215C _rdata$r        ends
.rdata$r:0000215C
.data$r:00002160 ; ===========================================================================
.data$r:00002160
.data$r:00002160 ; Segment type: Pure data
.data$r:00002160 ; Segment permissions: Read/Write
.data$r:00002160 _data$r         segment dword public 'DATA' use32
.data$r:00002160                 assume cs:_data$r
.data$r:00002160                 ;org 2160h
.data$r:00002160 ; COMDAT (pick any)
.data$r:00002160                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002160 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002160 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002160                                         ; DATA XREF: .rdata$r:00002158o
.data$r:00002160                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002160                                         ; const type_info::`vftable'
.data$r:00002164                 align 8
.data$r:00002168 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00002189                 align 4
.data$r:00002189 _data$r         ends
.data$r:00002189
.rdata$r:0000218C ; ===========================================================================
.rdata$r:0000218C
.rdata$r:0000218C ; Segment type: Pure data
.rdata$r:0000218C ; Segment permissions: Read
.rdata$r:0000218C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000218C                 assume cs:_rdata$r
.rdata$r:0000218C                 ;org 218Ch
.rdata$r:0000218C ; COMDAT (pick any)
.rdata$r:0000218C                 public ??_R3_System_error_category@std@@8
.rdata$r:0000218C ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000218C ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000215Co
.rdata$r:0000218C                                         ; .rdata$r:000021C4o
.rdata$r:0000218D                 db    0
.rdata$r:0000218E                 db    0
.rdata$r:0000218F                 db    0
.rdata$r:00002190                 db    0
.rdata$r:00002191                 db    0
.rdata$r:00002192                 db    0
.rdata$r:00002193                 db    0
.rdata$r:00002194                 db    3
.rdata$r:00002195                 db    0
.rdata$r:00002196                 db    0
.rdata$r:00002197                 db    0
.rdata$r:00002198                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002198 _rdata$r        ends
.rdata$r:00002198
.rdata$r:0000219C ; ===========================================================================
.rdata$r:0000219C
.rdata$r:0000219C ; Segment type: Pure data
.rdata$r:0000219C ; Segment permissions: Read
.rdata$r:0000219C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000219C                 assume cs:_rdata$r
.rdata$r:0000219C                 ;org 219Ch
.rdata$r:0000219C ; COMDAT (pick any)
.rdata$r:0000219C                 public ??_R2_System_error_category@std@@8
.rdata$r:0000219C ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000219C ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000219C                                         ; DATA XREF: .rdata$r:00002198o
.rdata$r:0000219C                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000021A0                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000021A4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000021A8                 db    0
.rdata$r:000021A9                 align 4
.rdata$r:000021A9 _rdata$r        ends
.rdata$r:000021A9
.rdata$r:000021AC ; ===========================================================================
.rdata$r:000021AC
.rdata$r:000021AC ; Segment type: Pure data
.rdata$r:000021AC ; Segment permissions: Read
.rdata$r:000021AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000021AC                 assume cs:_rdata$r
.rdata$r:000021AC                 ;org 21ACh
.rdata$r:000021AC ; COMDAT (pick any)
.rdata$r:000021AC                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000021AC ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000021AC ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000021AC                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000021AC                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000021B0                 db    2
.rdata$r:000021B1                 db    0
.rdata$r:000021B2                 db    0
.rdata$r:000021B3                 db    0
.rdata$r:000021B4                 db    0
.rdata$r:000021B5                 db    0
.rdata$r:000021B6                 db    0
.rdata$r:000021B7                 db    0
.rdata$r:000021B8                 db 0FFh
.rdata$r:000021B9                 db 0FFh
.rdata$r:000021BA                 db 0FFh
.rdata$r:000021BB                 db 0FFh
.rdata$r:000021BC                 db    0
.rdata$r:000021BD                 db    0
.rdata$r:000021BE                 db    0
.rdata$r:000021BF                 db    0
.rdata$r:000021C0                 db  40h ; @
.rdata$r:000021C1                 db    0
.rdata$r:000021C2                 db    0
.rdata$r:000021C3                 db    0
.rdata$r:000021C4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000021C4 _rdata$r        ends
.rdata$r:000021C4
.CRT$XCU:000021C8 ; ===========================================================================
.CRT$XCU:000021C8
.CRT$XCU:000021C8 ; Segment type: Pure data
.CRT$XCU:000021C8 ; Segment permissions: Read
.CRT$XCU:000021C8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000021C8                 assume cs:_CRT$XCU
.CRT$XCU:000021C8                 ;org 21C8h
.CRT$XCU:000021C8 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000021CC _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000021CC _CRT$XCU        ends
.CRT$XCU:000021CC
.CRT$XCU:000021D0 ; ===========================================================================
.CRT$XCU:000021D0
.CRT$XCU:000021D0 ; Segment type: Pure data
.CRT$XCU:000021D0 ; Segment permissions: Read
.CRT$XCU:000021D0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000021D0                 assume cs:_CRT$XCU
.CRT$XCU:000021D0                 ;org 21D0h
.CRT$XCU:000021D0 ; COMDAT (pick associative to section at 1EEC)
.CRT$XCU:000021D0 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000021D0 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000021D0 _CRT$XCU        ends
.CRT$XCU:000021D0
.CRT$XCU:000021D4 ; ===========================================================================
.CRT$XCU:000021D4
.CRT$XCU:000021D4 ; Segment type: Pure data
.CRT$XCU:000021D4 ; Segment permissions: Read
.CRT$XCU:000021D4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000021D4                 assume cs:_CRT$XCU
.CRT$XCU:000021D4                 ;org 21D4h
.CRT$XCU:000021D4 ; COMDAT (pick associative to section at 1EF0)
.CRT$XCU:000021D4 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000021D4 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000021D4 _CRT$XCU        ends
.CRT$XCU:000021D4
.CRT$XCU:000021D8 ; ===========================================================================
.CRT$XCU:000021D8
.CRT$XCU:000021D8 ; Segment type: Pure data
.CRT$XCU:000021D8 ; Segment permissions: Read
.CRT$XCU:000021D8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000021D8                 assume cs:_CRT$XCU
.CRT$XCU:000021D8                 ;org 21D8h
.CRT$XCU:000021D8 ; COMDAT (pick associative to section at 1EF4)
.CRT$XCU:000021D8 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000021D8 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000021D8 _CRT$XCU        ends
.CRT$XCU:000021D8
.CRT$XCU:000021DC ; ===========================================================================
.CRT$XCU:000021DC
.CRT$XCU:000021DC ; Segment type: Pure data
.CRT$XCU:000021DC ; Segment permissions: Read
.CRT$XCU:000021DC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000021DC                 assume cs:_CRT$XCU
.CRT$XCU:000021DC                 ;org 21DCh
.CRT$XCU:000021DC ; COMDAT (pick associative to section at 1EF8)
.CRT$XCU:000021DC ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000021DC ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000021DC _CRT$XCU        ends
.CRT$XCU:000021DC
.CRT$XCU:000021E0 ; ===========================================================================
.CRT$XCU:000021E0
.CRT$XCU:000021E0 ; Segment type: Pure data
.CRT$XCU:000021E0 ; Segment permissions: Read
.CRT$XCU:000021E0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000021E0                 assume cs:_CRT$XCU
.CRT$XCU:000021E0                 ;org 21E0h
.CRT$XCU:000021E0 ; COMDAT (pick associative to section at 1EFC)
.CRT$XCU:000021E0 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:000021E0 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:000021E0 _CRT$XCU        ends
.CRT$XCU:000021E0
.CRT$XCU:000021E4 ; ===========================================================================
.CRT$XCU:000021E4
.CRT$XCU:000021E4 ; Segment type: Pure data
.CRT$XCU:000021E4 ; Segment permissions: Read
.CRT$XCU:000021E4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000021E4                 assume cs:_CRT$XCU
.CRT$XCU:000021E4                 ;org 21E4h
.CRT$XCU:000021E4 ; COMDAT (pick associative to section at 1F90)
.CRT$XCU:000021E4 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000021E4 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000021E4 _CRT$XCU        ends
.CRT$XCU:000021E4
.CRT$XCU:000021E8 ; ===========================================================================
.CRT$XCU:000021E8
.CRT$XCU:000021E8 ; Segment type: Pure data
.CRT$XCU:000021E8 ; Segment permissions: Read
.CRT$XCU:000021E8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000021E8                 assume cs:_CRT$XCU
.CRT$XCU:000021E8                 ;org 21E8h
.CRT$XCU:000021E8 ; COMDAT (pick associative to section at 1F94)
.CRT$XCU:000021E8 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000021E8 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000021E8 _CRT$XCU        ends
.CRT$XCU:000021E8
UNDEF:000021F0 ; ===========================================================================
UNDEF:000021F0
UNDEF:000021F0 ; Segment type: Externs
UNDEF:000021F0 ; UNDEF
UNDEF:000021F0                 extrn __purecall:near   ; DATA XREF: .rdata:00001E40o
UNDEF:000021F0                                         ; .rdata:00001E44o
UNDEF:000021F4 ; void *__cdecl operator new(unsigned int)
UNDEF:000021F4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000021F4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:000021F8 ; void __cdecl operator delete(void *)
UNDEF:000021F8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:000021F8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000021FC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000021FC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000021FC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002200 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00002200                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002204 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002204                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002208 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002208                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:0000220C ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000220C                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000220C                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002210 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002210                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002210                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002210                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00002214                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00002218 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00002218                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00002218                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000221C ; void __cdecl std::_Xbad_alloc()
UNDEF:0000221C                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000221C                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_1AAp
UNDEF:0000221C                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_1ECp
UNDEF:00002220 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00002220                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00002220                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00002224 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00002224                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00002224                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00002228 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002228                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002228                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000222C ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000222C                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000222C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000222C                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00002230 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00002230                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00002230                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00002234 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002234                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002234                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00002238 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002238                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002238                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000223C ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000223C                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000223C                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00002240 ; __fastcall __security_check_cookie(x)
UNDEF:00002240                 extrn @__security_check_cookie@4:near
UNDEF:00002240                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp
UNDEF:00002240                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+Cp ...
UNDEF:00002244 ; __stdcall _CxxThrowException(x, x)
UNDEF:00002244                 extrn __CxxThrowException@8:near
UNDEF:00002244                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00002248                 extrn ___CxxFrameHandler3:near
UNDEF:00002248                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00002248                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:0000224C ; const type_info::`vftable'
UNDEF:0000224C                 extrn ??_7type_info@@6B@:near
UNDEF:0000224C                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:0000224C                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00002250                 extrn ___security_cookie:near
UNDEF:00002250                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r
UNDEF:00002250                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+14r ...
UNDEF:00002254                 extrn __fltused:near
UNDEF:00002254
UNDEF:00002254
UNDEF:00002254                 end